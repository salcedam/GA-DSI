{"5gc871": ["How terrible code gets written by perfectly sane people", "2016-12-04 01:43:12", 67, "https://www.linkedin.com/pulse/how-terrible-code-gets-written-perfectly-sane-people-christian", [[18, "So they didn't put any effort in continual refactoring so the code base went to shit and then decided to rewrite the entire thing, and in _javascript_ to boot. Talk about compounding problems!"], [5, "Everything in that list is true.\n\nBut... I think \"perfectly sane people\" with more than a few years of experience know all those problems and solutions too.  Yet these terrible projects still happen.  There are, of course, many experienced developers who aren't sane who haven't learned these lessons, however.\n\nA more interesting question would be, why do good developers who are aware of these problems, let themselves get into the situation where they abandon all their accumulated experience and march to an inevitable doom?\n\nThere are many reasons for that:\n\n1. Any one developer has limited powers in a sufficiently large team (I don't mean 1000-engineers large, 10 to 20 is enough), unless the average skill and experience is high.  But even then...\n\n2. The people paying the bills are not aware of any of this, and keeping them happy is more important than the end-result.  Brilliant code that never goes live, because the project gets cancelled due to the unrealistic expectations of the customer, might as well not exist.\n\n3. Certain rogue actors.  Experienced, skilled, intelligent engineers who are aware of Points 1 and 2, and cynically compound the problem to gain influence and bonuses for heroics and firefighting rather than good engineering."], [1, "It is not just about the code. It happens everywhere. Engineering is supposed to be a very strict and well defined discipline, yet stupidity somehow managed to infiltrate it thoroughly, on all levels.\n\nJust look at some recent big examples. E.g., the infamous Piccadilly tube line in London. It was a very well known fact from mid 19th century that the wheels wear unevenly if your route contains an uneven amount of left and right turns. Yet they built that stupid Heathrow loop and just waited until nearly all of their trains get an unsafe amount of an uneven wear. All at once. Just as it should have been expected from the first principles and more than a century of experience.\n\nHow things like this can happen? A mystery. Or, people are just dumb fucking idiots, naturally, and there is no *humane* way to offset this. I'm aware of a number of very efficient *inhumane* approaches and I'd be delighted to see them implemented, but, realistically, it cannot happen in the modern Western dumb fucking society."], [1, "> mixed spaces/tabs for indentation\n\nIs this a joke? I've been programming professionally from 2008 and I've not yet found an actual case where this was an actual problem. The code looks the same on everyone's screen if you set tab length in the editor to same as the amount of spaces in your indentation. It would take seconds to fix this :) I've never seen a tabs vs spaces argument go anywhere. It's such a dumb thing to complain about. Maybe because I'm young I don't have experience of bad code editors of old days but it's 2016 now. It's not a big deal anymore."]], [[{"comment": "So they didn't put any effort in continual refactoring so the code base went to shit and then decided to rewrite the entire thing, and in _javascript_ to boot. Talk about compounding problems!", "id": "darlosx"}, {"comment": ">continual refactoring\n\nIt's incredible how nobody seems to give a shit about refactoring. Even the cruft that everybody agrees should go, I end up having to take it on myself.", "id": "darmn9a"}, {"comment": "\"If I touch it, it's mine, so I'd better just pinch my nose and hope someone else deals.\" - too many programmers ", "id": "darmqd2"}, {"comment": "Some piece of code just can't be refactored. Refactoring implies immutable API . When the code is bad to begin with, there is no refactoring possible without breaking API.", "id": "darnshj"}, {"comment": "I don't know about the formal terminology, but I'd informally say that just requires wider-scale refactoring, including the consumers as well.\n\nObviously that's not practical if you have a truly public interface, but within companies it often is practical, albeit difficult. (i.e. Google has procedures for making API changes that span their entire internal code base in a short period of time.)", "id": "daro9c0"}, {"comment": "> It's incredible how nobody seems to give a shit about refactoring.\n\nI'm not a programmer for work, but to me having to go back and rewrite old code is like being forced to eat my vegetables.", "id": "darmooj"}, {"comment": "o.O\n\nI don't think that's typical. More often, I hear people wishing they could take the time to clean up old code, finding it very satisfying and rewarding, but business realities prevent it.", "id": "daro81w"}, {"comment": "Eating your vegeatables doesn't give you that satisfying feeling when you're done, though.", "id": "darmq27"}, {"comment": "It does if you have scurvy...", "id": "darmrp1"}, {"comment": "Eating vegetables is not a great solution to scurvy. Citrus is a much better bet when you have vitamin C deficiency.", "id": "darpoij"}, {"comment": "According to the googles, Peppers (#1), Kale (#3) and Broccoli (#5) all rank higher in Vitamin C than Citrus (#7).", "id": "darpsk0"}], [{"comment": "Everything in that list is true.\n\nBut... I think \"perfectly sane people\" with more than a few years of experience know all those problems and solutions too.  Yet these terrible projects still happen.  There are, of course, many experienced developers who aren't sane who haven't learned these lessons, however.\n\nA more interesting question would be, why do good developers who are aware of these problems, let themselves get into the situation where they abandon all their accumulated experience and march to an inevitable doom?\n\nThere are many reasons for that:\n\n1. Any one developer has limited powers in a sufficiently large team (I don't mean 1000-engineers large, 10 to 20 is enough), unless the average skill and experience is high.  But even then...\n\n2. The people paying the bills are not aware of any of this, and keeping them happy is more important than the end-result.  Brilliant code that never goes live, because the project gets cancelled due to the unrealistic expectations of the customer, might as well not exist.\n\n3. Certain rogue actors.  Experienced, skilled, intelligent engineers who are aware of Points 1 and 2, and cynically compound the problem to gain influence and bonuses for heroics and firefighting rather than good engineering.", "id": "darnwnv"}], [{"comment": "It is not just about the code. It happens everywhere. Engineering is supposed to be a very strict and well defined discipline, yet stupidity somehow managed to infiltrate it thoroughly, on all levels.\n\nJust look at some recent big examples. E.g., the infamous Piccadilly tube line in London. It was a very well known fact from mid 19th century that the wheels wear unevenly if your route contains an uneven amount of left and right turns. Yet they built that stupid Heathrow loop and just waited until nearly all of their trains get an unsafe amount of an uneven wear. All at once. Just as it should have been expected from the first principles and more than a century of experience.\n\nHow things like this can happen? A mystery. Or, people are just dumb fucking idiots, naturally, and there is no *humane* way to offset this. I'm aware of a number of very efficient *inhumane* approaches and I'd be delighted to see them implemented, but, realistically, it cannot happen in the modern Western dumb fucking society.", "id": "darq8x8"}], [{"comment": "> mixed spaces/tabs for indentation\n\nIs this a joke? I've been programming professionally from 2008 and I've not yet found an actual case where this was an actual problem. The code looks the same on everyone's screen if you set tab length in the editor to same as the amount of spaces in your indentation. It would take seconds to fix this :) I've never seen a tabs vs spaces argument go anywhere. It's such a dumb thing to complain about. Maybe because I'm young I don't have experience of bad code editors of old days but it's 2016 now. It's not a big deal anymore.", "id": "darqajs"}, {"comment": "It's a inconsistency in code style, not really professional", "id": "darqj4u"}]]], "5fu55b": ["(Solved) Error: You do not have permission to view this directory or page using the credentials you supplied (access denied due to Access Control Lists). Ask the Web server's administrator to give you access to 'C:\\inetpub\\wwwroot\\...\\Service.svc", "2016-12-01 05:56:36", 0, "http://immortalcoder.blogspot.com/2016/12/solved-error-you-do-not-have-permission.html", [], []], "5flkk2": ["Git 2.11 released - performance optimizations, advanced filter processes, and more", "2016-11-30 00:56:21", 84, "https://github.com/blog/2288-git-2-11-has-been-released", [[7, "GIT certainly seems to be getting more useful functionality than what Subversion is. Might have to make the switch ...."], [1, "> That still leaves the question of what to do when you somehow do get an ambiguous short SHA-1\n\nI one assume the short SHA-1 originates from git (ie. it has been unique at some point) wouldn't simply picking the oldest object be the correct action?"], [1, "I still don't get why the release notes for **Git** are on  **GitHub**."], [-7, "> What's new in Git 2.11?\n\n> New stuff: xyz\n\nYeah, yours gets the upvote.\n\nEdit: What, downvoters would rather the clickbait medium article? Or is your reading comprehension that bad?"]], [[{"comment": "GIT certainly seems to be getting more useful functionality than what Subversion is. Might have to make the switch ....", "id": "dalmuku"}, {"comment": "First version of git was more useful than SVN. \n\nNot because SVN is bad but because uncentralized source controls are so damn good. ", "id": "dalp9v0"}, {"comment": "Yeah. When we originally chose SVN over GIT, it was because SVN was simpler, and we didn't need all the rest the git gave. Now, most of the tooling is going for git first, then SVN later, which makes the development environment ... stale when trying to do code review tooling, etc.", "id": "dalsywc"}, {"comment": "What would be a reason to use/switch to Git for a small development team primarily working on-permises, where the SVN repository resides too?", "id": "dame7xm"}], [{"comment": "> That still leaves the question of what to do when you somehow do get an ambiguous short SHA-1\n\nI one assume the short SHA-1 originates from git (ie. it has been unique at some point) wouldn't simply picking the oldest object be the correct action?", "id": "dal9owq"}, {"comment": "I don't think `git` keeps track of how old objects are.", "id": "dalduej"}, {"comment": "Sleeping on it I think it could be problematic even if it did due to the distributed nature. Ie. A short hash could be unique each of two repos, but refer to different commit objects", "id": "daltd0i"}, {"comment": "What is the probability of that?", "id": "dalq81k"}], [{"comment": "I still don't get why the release notes for **Git** are on  **GitHub**.", "id": "dalsvwv"}, {"comment": "They're not. They're on [the Linux kernel mailing list](https://lkml.org/lkml/2016/11/29/930), in [the official Git repository](https://git.kernel.org/cgit/git/git.git/tree/Documentation/RelNotes/2.11.0.txt), and in various repository mirrors including the one on GitHub. This submission is just a blog post by GitHub, although by a Git contributor responsible for several notable improvements in 2.11. Atlassian will probably have a post in a few days, too.", "id": "dalta4i"}, {"comment": "It's been published for a while now, and it's more comprehensive, too. https://medium.com/@kannonboy/whats-new-in-git-2-11-64860aea6c4f", "id": "dalztb0"}], [{"comment": "> What's new in Git 2.11?\n\n> New stuff: xyz\n\nYeah, yours gets the upvote.\n\nEdit: What, downvoters would rather the clickbait medium article? Or is your reading comprehension that bad?", "id": "dal5oe7"}, {"comment": "The best part is that this isn't a medium post.", "id": "dalhj2f"}]]], "5fq2sf": ["When to use which CSS methodology", "2016-11-30 18:09:53", 2, "http://simurai.com/blog/2016/11/27/css-methodologies", [], []], "5fltoi": ["Introducing the fac build system", "2016-11-30 01:40:06", 24, "https://physics.oregonstate.edu/~roundyd/fac/introducing-fac.html", [[7, "I have some feedback and questions:\n\n * I'm not sold the Git integration feature as it adds complexity to the build system and requires Git. Believe it or not, not everyone uses Git for version control. If you forgot to commit a file, then your continuous integration build should catch it instead.\n * Does it track changes to the build description?\n * Does it delete files that have been removed from the build?\n * Does it detect cyclic dependencies?\n * Does it detect race conditions (i.e., two rules output to the same file)?\n * If you use Python to generate a `.fac` file, are the dependencies Python needed also tracked?\n * Can you run `fac` recursively?\n * Can you have a dependency on directory contents?\n * If you don't specify all the dependencies up-front and need to run the build multiple times to get everything right, then I'd think that alone prevents using this build system in an automated way (e.g., from Jenkins).\n\n*[Shameless plug for my build system ;)](http://jasonwhite.github.io/button/)*"], [5, "It's all fun and games with these tools until you realize that what you really needed all along was an actual programming language.  Makefiles and this guy's custom build system more or less prevent real code re-use in your automation and they inevitably get very obnoxious when it comes to flow controls and conditionals.    \n\nNaturally no one wants to code decent clopt parsing from scratch just because they need some build automation, but things like [click](http://click.pocoo.org/5/) and [baker](https://pypi.python.org/pypi/Baker/1.3) have lowered the barrier to entry so much that it's not a real annoyance."], [1, "How does this system handle phony dependencies?"]], [[{"comment": "I have some feedback and questions:\n\n * I'm not sold the Git integration feature as it adds complexity to the build system and requires Git. Believe it or not, not everyone uses Git for version control. If you forgot to commit a file, then your continuous integration build should catch it instead.\n * Does it track changes to the build description?\n * Does it delete files that have been removed from the build?\n * Does it detect cyclic dependencies?\n * Does it detect race conditions (i.e., two rules output to the same file)?\n * If you use Python to generate a `.fac` file, are the dependencies Python needed also tracked?\n * Can you run `fac` recursively?\n * Can you have a dependency on directory contents?\n * If you don't specify all the dependencies up-front and need to run the build multiple times to get everything right, then I'd think that alone prevents using this build system in an automated way (e.g., from Jenkins).\n\n*[Shameless plug for my build system ;)](http://jasonwhite.github.io/button/)*", "id": "dalqv9l"}, {"comment": "That's a lot of questions!\n\nRegarding the git integration, it could be removed as a dependency, I would just need a different mechanism to find the build root and to identify the primary fac files (i.e. ones that are not built by rules).  As far as continuous integration catching failure to add source files, that presumes that every repository has a rather large infrastructure and high level of resources. Fac is for the little people, too!\n\nChanges to the build description are indeed treated right.\n\nFiles that have been removed from the build are not deleted unless the command that generated them is retained, only it no longer produces that file.\n\nCyclic dependencies are detected, and lead to an error message.\n\nTwo commands outputting the same file also gives an error message.    The \"c\" directive exists for cases where two commands may produce the same cache file, as happens with .pyc files generated by python.\n\nRules that generated facfiles HD Ave their dependencies tracked just like other rules do.\n\nI presume by recursive use of fac you mean can roles generate rules (in fac files)? If so then yes.  Fac cannot actually run a child fac, due to its implementation using ptrace.\n\nYou can have dependencies on directories, in which case any change to the directory that affects the list of file names leads to a rebuild.\n\nAgreed, sloppy facfiles are for sloppy projects.  Many projects fall in this category, and those don't normally use continuous integration.  In the other hand, you could just instruct Jenkins to run fac a few times ignoring failures on the first few attempts.\n\nYour button looks interesting.  I presume it also uses ptrace?\n\n", "id": "dapfe7z"}], [{"comment": "It's all fun and games with these tools until you realize that what you really needed all along was an actual programming language.  Makefiles and this guy's custom build system more or less prevent real code re-use in your automation and they inevitably get very obnoxious when it comes to flow controls and conditionals.    \n\nNaturally no one wants to code decent clopt parsing from scratch just because they need some build automation, but things like [click](http://click.pocoo.org/5/) and [baker](https://pypi.python.org/pypi/Baker/1.3) have lowered the barrier to entry so much that it's not a real annoyance.", "id": "daldx54"}, {"comment": "It looks like fac's domain-specific language is meant to be generated by a higher-level language like Python.", "id": "dalq47f"}, {"comment": "It sort of scares me that it's line-oriented. So your command can be anything not containing a `\\n`?", "id": "dam7dei"}, {"comment": "Why is this scary? I understand that it's a limitation relative to make, but it's it really important for you to have multiline build commands?\n\nI would generally recommend that is a build rule doesn't fit on a line, you write a script for it.", "id": "dape0k2"}, {"comment": "Indeed.  The whole idea is to allow you to use any actual programming language you want to configure your build.", "id": "daplx1w"}, {"comment": "If you need an actual programming language your build is too complicated. And you can use one just fine from make and every other build tool I've used.", "id": "dalp23e"}, {"comment": "If you've ever worked on a large project, then the build is going to be complicated *guaranteed*. A real programming language to describe the build is a must for big projects. *Make* might be adequate for small stuff, but for anything non-trivial it's just a mountain of technical debt and slowness.", "id": "dalq1cm"}, {"comment": "What are you doing that requires a real language? A build should be simple and predictable and doesn't scale in complexity with a project.\n\nLike everything else in programming, any idiot can make something complicated but it takes talent to make something simple.", "id": "dalq68n"}, {"comment": "> A build should be simple and predictable and doesn't scale in complexity with a project.\n> Like everything else in programming, any idiot can make something complicated but it takes talent to make something simple.\n\nYou're absolutely right. That's how it *should* be. Unfortunately, that's just not how it works in practice. If you've got a few hundred (or a few thousand) developers hammering away on one codebase, then things get very complicated very quickly.\n\nTake a look at [this Makefile](https://github.com/git/git/blob/master/Makefile) and let me know if that looks simple.", "id": "dalrrps"}, {"comment": "It doesn't look too bad. Most of it is various toggles for features/libraries. It's not going to be any better with a \"real language\" and could be a lot worse without the terse syntax of make/gnu.\n\nIf I had a few thousand developers on a codebase then that makefile would be the least of my problems.", "id": "dalst9v"}, {"comment": "Is there a quick way to check how \"stable\" the git Makefile is relative to the other files in the repository?", "id": "dam864t"}, {"comment": "*Churn* is the number of times a file change and there are a few tools for calculating it floating around the Web. I don't think one ships with Git.\n\n    $ git churn | tail\n    552     git-svn.perl\n    562     gitk\n    592     sha1_file.c\n    644     refs.c\n    649     Documentation/config.txt\n    683     gitweb/gitweb.perl\n    704     diff.c\n    721     whats-cooking.txt\n    1029    cache.h\n    1564    Makefile\n\nAt a glance the Makefile appears to be very unstable. However, there are over 45k commits in the Git repository, and `Makefile` and `cache.h` are the only two files that have existed since the first commit:\n\n    $ git log --name-only e83c51633\n    commit e83c5163316f89bfbde7d9ab23ca2e25604af290\n    Author: Linus Torvalds <torvalds@ppc970.osdl.org>\n    Date:   Thu Apr 7 15:13:13 2005 -0700\n\n        Initial revision of \"git\", the information manager from hell\n\n    Makefile\n    README\n    cache.h\n    cat-file.c\n    commit-tree.c\n    init-db.c\n    read-cache.c\n    read-tree.c\n    show-diff.c\n    update-cache.c\n    write-tree.c\n", "id": "damg15x"}, {"comment": "Is there a commonly agreed upon metric for file stability? It seems like we could take the (total number of commits that have changed the file) / (the total number of commits that have occurred since the file was first created) so we don't unfairly penalize old files.", "id": "damrrj6"}, {"comment": "Not to my knowledge, nor is Git likely to promote one (but Git has a mechanism for seeing when a file was added so you could do what you suggest). [Git focuses on tracking content](https://git.wiki.kernel.org/index.php/Git_FAQ#Why_does_Git_not_.22track.22_renames.3F), not individual files, and it doesn't retain any metadata like renames (Git's rename detection is a content-similarity heuristic). A question such as, \"is this file stable?\", from that perspective, is not incredibly interesting; except that most corporate programming is not as deliberate as projects like Git or the Linux kernel, so there the question really can be interesting.\n\nThere are a lot of open-source tools for calculating \"statistics\" on Git repositories. Most of them* yield vastly uninteresting results such as total contributor distribution and work hour distribution. That information is easy to find and it tells us nothing. A far more interesting question is, \"how often does a piece of code change?\" That's still just churn, but at a much higher (lower?) level. I've heard second-hand that most code at Google survives only for a few months, in which case some of us probably obsess about quality too much -- but how do you calculate that? If you just take the diff in every commit you loose a lot of nuance (moving content) and you're hardly better off than file-based churn.\n\n*I haven't yet tried [Code Maat](https://github.com/adamtornhill/code-maat) because I can't be arsed to Clojure. It's definitely the most sophisticated one I've come across.", "id": "dan9y9m"}, {"comment": "The question is not whether any given Makefile or other declarative build definition is simple. The question is whether a comparable procedural build definition would have been simpler, for some definition of *simpler* that is not just line count or file extension (both popular metrics in Maven/Gradle discussions).\n\nGit 2.11 has 400k lines of code, 161k of which are C, and it runs on three vastly different platforms. That Makefile is not 2700 lines long -- more than 400 of those lines are comments and more than 250 lines are per-line object declarations. I'd say that definition is surprisingly simple, considering.", "id": "dalt3h9"}, {"comment": "> then things get very complicated very quickly\n\nThis is exactly why your build system should not let them go rampant.  The simpler it is by design, the harder it is to do unnecessarily complex things with it.", "id": "dalurd0"}, {"comment": "Pretty much. 80% of building could be moved out to common primitives like \"run this to create that\" or \"if that change, rebuild this\" but anything more complicated will need some custom logic", "id": "dalk60m"}, {"comment": "> what you really needed all along was an actual programming language\n\nNo way. No fucking way. This is how you get `scons`, that deplorable abomination, worst of all the build systems that ever existed.\n\nWhat you need is a *domain specific programming language*. A well-designed one.", "id": "dalupcp"}, {"comment": "What's so wrong with scons?", "id": "dalyh5n"}, {"comment": "Exactly the fact it's a general purpose language allowing to do any shit imaginable. And mind you, people *do* all the shit imaginable when they are not restrained.", "id": "dalzv93"}, {"comment": "I think the problem there is you're not holding your build code to the same standard as your main codebase. Otherwise you could say the same thing for it, yes people can make a mess, but you try to hire developers that won't, and make sure that developers that won't apply that same sensibility to the build code.", "id": "dam30qs"}, {"comment": "I actually believe that the so called \"general purpose languages\" have no place in the main code base neither. \n\nBut the build system is somehow special. No matter how rigorous the process for the rest of your system, build system is always a mess. Always. I never seen a single example of this rule not working.", "id": "dam66sx"}, {"comment": "What would you propose to use for the main code base?", "id": "damt318"}, {"comment": "The same thing - *domain specific languages*. One for every little well-defined, isolated problem domain. Including all the problem domains involved in implementing the domain specific languages themselves. \n\n\n\n", "id": "damta7w"}, {"comment": "The language for implementing all DSLs will necessarily be a general purpose language though... I guess how are you defining general purpose? As soon as you have loops and conditionals you're Turing complete.", "id": "damtj8r"}, {"comment": "> The language for implementing all DSLs will necessarily be a general purpose language though... \n\nNo. And I mentioned this fact. You can implement your DSLs using DSLs designed for implementing DSLs.\n\n> I guess how are you defining general purpose?\n\nBy, well, their purpose. C is more \"general purpose\" than, say, Bash. The latter is a DSL for managing the processes and their inputs and outputs. Both are Turing-complete.\n\nCMake is a Turing-complete language, yet you're unlikely to see there any of the abhorrent things people are doing in Scons. The latter is just a thin layer on top of Python, so people resort to the full power of Python any time they want to do something unusual.\n\n> As soon as you have loops and conditionals you're Turing complete.\n\nNot necessarily. You can have a total language instead, and it's fine for *most* of the practical use cases.\n\nAnyway, DSLs can well be Turing-complete. The difference is in restrictions they have and functionality they provide. ", "id": "damtsoc"}, {"comment": "IME there's very little knowledge about how to use build tools at all, let alone use them well. I wonder if that explains the proliferation of build tools?\n\nThe biggest issues I see are when they become too smart though and contain things like \"if $isdev\" and \"if $isci\". Some go as far as having targets like \"build-qa\", \"build-dev\" and \"build-prod\". That sort of knowledge should be in the CI server, not the build script.", "id": "daml7kh"}, {"comment": "I would say that the problem with scons is that it requires you to write code to determine the build dependencies in your code, which results in very complicated, bug-prone, and incorrect builds. For simple cases, scons is fine, but for complicated builds it gets nasty.", "id": "dapefxf"}], [{"comment": "How does this system handle phony dependencies?", "id": "dan7zoy"}, {"comment": "Fac doesn't have phony dependencies.  What do you want them for? The only use I know of is as a shorthand for listing several other targets.  One could add such a shorthand feature, but I'm not sure that it would be worth the extra effort.", "id": "dapnmwo"}, {"comment": "I don't really want phony dependencies if there's another way of getting the same functionality. (I think `phony targets` might be the more appropriate term, but I'm not sure). One of the things I use them for in Make today is stuff like `make test`, `make clean`, `make docker`, `make push`, and `make deploy` and other tasks that might depend on other tasks but don't produce an artifact in the file system when they're done. Those things arguably don't really belong in a build tool, but they are really convenient.\n\nI've been reading about shake recently and more generally trying to read about build systems with a different model than (GNU) Make. It's kind of interesting, but I don't have an immediate practical need for a better build system. I don't think Make has the ability to introduce new rules at runtime once it starts executing shell fragments. Shake does have the ability to add new rules at runtime as a result of running other rules, but doesn't use the clock.\n\nI get the sense that `fac` doesn't have the ability to add new rules at runtime and the \"normal\" way of building a fac project from scratch is to run fac repeatedly until the state of the system converges. Maybe fac has the ability to re-exec itself that's more sophisticated than just calling `fac` in a command. Maybe the difference between a multi-stage and single-stage build isn't visible to the user... I'm still trying to figure it out.\n\nI'm also trying to get a sense of the \"shape of possible rules\". It seems like `|` introduces a bourne shell fragment and `>` and `<` introduce whitespace-delimited lists of paths. I'm not sure what exactly `C` does. I don't know what ability `fac` has to include other `fac` files or what it has that duplicates the functionality of pattern rules ... etc.", "id": "dapqnd3"}]]], "5fuj6x": ["Data structure chooser \u2013 Select the methods you want and press \u201csearch\u201d", "2016-12-01 07:14:21", 10, "http://ds.shlegeris.com/", [[8, "Doesn't seem to work. I'm only getting the top banner, and an empty page below that."], [2, "Hi, I created this. Sorry for the downtime, it's up again now. If anyone  has any questions, let me know! You might also enjoy [my talk](shlegeris.com/2016/11/13/ds) about it."], [1, "Windows 10, Chrome:\n\nds.shlegeris.com/:1 Uncaught (in promise) SyntaxError: Unexpected token < in JSON at position 0"], [1, "Uh oh, maybe we crashed the site :-/"], [1, "I don't know of any data structure that does value ordering in O(1) time.  It's claiming that an ArrayList would."]], [[{"comment": "Doesn't seem to work. I'm only getting the top banner, and an empty page below that.", "id": "danff9s"}, {"comment": "Linux/Firefox, same result. I also see the following logs in the console:\n\n    \"Download the React DevTools for a better development experience: https://fb.me/react-devtools\"  ReactDOM.js?:75:9\n    \n    SyntaxError: JSON.parse: unexpected character at line 1 column 1 of the JSON data[Learn More]  (unknown)\n    \n    Firefox can\u2019t establish a connection to the server at ws://ds.shlegeris.com/sockjs-node/447/gkmqum2p/websocket.  bundle.js%20line%20634%20%3E%20eval:32:12\n    \n    Error: Incompatibile SockJS! Main site uses: \"1.0.3\", the iframe: \"1.0.1\".\n\nReact is so fucking web-scale.", "id": "danh5lx"}, {"comment": "Agreed, same experience for me. Android 7.1.1/Firefox stable channel.", "id": "danfr6u"}, {"comment": "Same problem, macbook pro user here..", "id": "dangigk"}, {"comment": "It's because it tries to fetch a JSON from /api/start-data, the server return a 404 error in HTML, and HTML rarely parses as valid JSON.", "id": "danktmx"}, {"comment": "Does that mean he chose a wrong data structure for his site? :)", "id": "danq9ta"}, {"comment": "Yes :-)", "id": "danqc8a"}], [{"comment": "Hi, I created this. Sorry for the downtime, it's up again now. If anyone  has any questions, let me know! You might also enjoy [my talk](shlegeris.com/2016/11/13/ds) about it.", "id": "dantbi2"}, {"comment": "Hey, if I could suggest some improvements, I'd like to see explanations on more of the data structures (like AugmentedOrderStatisticTreeList, for example has no description), and also a description of the methods. Some, like \"getKthBy!\" aren't super obvious.", "id": "dantrbn"}, {"comment": "Yeo, both of those are on my to-do list. Thanks!", "id": "danyx74"}], [{"comment": "Windows 10, Chrome:\n\nds.shlegeris.com/:1 Uncaught (in promise) SyntaxError: Unexpected token < in JSON at position 0", "id": "dankip5"}], [{"comment": "Uh oh, maybe we crashed the site :-/", "id": "dann8qt"}], [{"comment": "I don't know of any data structure that does value ordering in O(1) time.  It's claiming that an ArrayList would.", "id": "daq4s7z"}]]], "5garhq": ["Kano Computer Kits - $99.99 to $239.99 ($50 to $60 savings) - Thoughts? Experience?", "2016-12-03 21:00:53", 6, "https://kano.me/store/us", [[5, "Looks pretty cool. Is it a basically a RPi kit with some custom software for tutorials and to make life easier for getting things up and running? "], [3, "No experience but I sent the link to my University's makerspace. Thanks for sharing!"], [3, "I don't know how they compare to each other, but for something very similar there's Piper: https://playpiper.com/pages/piper-computer-kit  "], [3, "These are good kits. Keep in mind, you could just get a raspberry pi for $35, a microsd card for $5-10, a usb mouse and keyboard, and an hdmi cable. Then you can download KanoOS if you want that environment. But it sounds like you're just looking for a kit for someone to learn software without having to research the parts. In that case, the Kano kits are a good way to go, and work great.\n\nYou might also consider a normal PC/Mac to browse to http://code.org or http://codecombat.com. Introducing a kid to codecombat.com and offering to pay the $10/month plan if they like it is a good way for kids to get into coding."], [3, "We live in a time of unprecedented computing power and choice.  I question the need for specialized and expensive educational computers.  \n\nPutting these things together isn't a challenge nor is it all that interesting.  Money is better spent on a *real* computer.\n"], [2, "They're neat, but very pricey. The Pocket CHIP is a cheaper alternative that's also worth checking out."], [2, "Looks great, but.... overpriced?  Perhaps?"], [2, "Bought one for my kid sister last year, she loved it."]], [[{"comment": "Looks pretty cool. Is it a basically a RPi kit with some custom software for tutorials and to make life easier for getting things up and running? ", "id": "daqviwu"}, {"comment": "I just ordered one as an xmas gift...thats pretty much it, from what I could tell.\n\nAll of the instructions / tutorials are in comic form and they have lots of games and such that teach linux commands and programming. Pricey to add the screen...I probably should have just given him an old monitor...\n\nEdit:  Here is a link to the instruction books, if you're curious. http://developers.kano.me/downloads/", "id": "daqwx4l"}], [{"comment": "No experience but I sent the link to my University's makerspace. Thanks for sharing!", "id": "daqvlao"}, {"comment": "What is a makerspace?", "id": "daqw3v6"}, {"comment": "Makerspaces are facilities that allow members (and sometimes guests) to use tools to build things. Software, furniture, 3d printing, electronics projects.", "id": "dar0acz"}, {"comment": "They're also known as Hackerspaces", "id": "dar3fmz"}], [{"comment": "I don't know how they compare to each other, but for something very similar there's Piper: https://playpiper.com/pages/piper-computer-kit  ", "id": "daqzrp5"}], [{"comment": "These are good kits. Keep in mind, you could just get a raspberry pi for $35, a microsd card for $5-10, a usb mouse and keyboard, and an hdmi cable. Then you can download KanoOS if you want that environment. But it sounds like you're just looking for a kit for someone to learn software without having to research the parts. In that case, the Kano kits are a good way to go, and work great.\n\nYou might also consider a normal PC/Mac to browse to http://code.org or http://codecombat.com. Introducing a kid to codecombat.com and offering to pay the $10/month plan if they like it is a good way for kids to get into coding.", "id": "dar0hbn"}], [{"comment": "We live in a time of unprecedented computing power and choice.  I question the need for specialized and expensive educational computers.  \n\nPutting these things together isn't a challenge nor is it all that interesting.  Money is better spent on a *real* computer.\n", "id": "dar5w7u"}, {"comment": "Attaching custom hardware to a real main computer is a pain in the ass and if something goes wrong can be quite costly.\n\nBut yeah, personally, tiny mcu boards like [teensy](https://www.pjrc.com/teensy/) are better choice. RPi does not look like a good price/value. A crappy old half broken notebook plus the same teensy for a hardware interface will offer much more bang for a same buck.\n", "id": "darlrrg"}], [{"comment": "They're neat, but very pricey. The Pocket CHIP is a cheaper alternative that's also worth checking out.", "id": "daqw2yj"}, {"comment": "I installed the english wikipedia on that once: https://www.hackster.io/AyrA/information-at-your-fingertips-offline-wikipedia-85bf27\n\n", "id": "daqzcwo"}, {"comment": "Oh, neat!", "id": "dar0jn1"}], [{"comment": "Looks great, but.... overpriced?  Perhaps?", "id": "darhba4"}], [{"comment": "Bought one for my kid sister last year, she loved it.", "id": "darixax"}]]], "5fq5kl": ["My buddy just made CORS Camel - A simple CORS proxy! Let him know what you think!", "2016-11-30 18:24:15", 0, "https://corscamel.herokuapp.com/", [[1, "Update: He moved it to a new domain = [GetCors.Com](http://getcors.com/)"]], [[{"comment": "Update: He moved it to a new domain = [GetCors.Com](http://getcors.com/)", "id": "dan6obc"}]]], "5fwvwd": ["Semantic Versioning .NET libraries and NuGet packages", "2016-12-01 17:40:58", 1, "http://blog.stermon.com/articles/2016/12/01/semantic-versioning-dotnet-libs-and-nuget-pkgs", [[2, "I really like the concept here.\n\nIt would be really nice to provide support for API's that aren't class libraries - for example, say you have an ASP.NET or WCF web service library, the public API surface is restricted to a subset of the assembly's types and methods. An attribute-based way to specify exactly which parts  of the code constitute the API surface could be used to support scenarios such as these."]], [[{"comment": "I really like the concept here.\n\nIt would be really nice to provide support for API's that aren't class libraries - for example, say you have an ASP.NET or WCF web service library, the public API surface is restricted to a subset of the assembly's types and methods. An attribute-based way to specify exactly which parts  of the code constitute the API surface could be used to support scenarios such as these.", "id": "danwyho"}, {"comment": "I had in mine to only work with .NET libraries as well as NuGet packages (containing libraries, not executables) as normally you would build your application or web services based on these.\n\nTherefore I'm not able to support end-user applications and that is probably fine with me :)\n\nI have worked in the past with SwaggerWcf:\n\nhttps://github.com/abelsilva/swaggerwcf#swaggerwcf------------\n\nWhich gave me the possibility to both create a .WCF webservice (traditional SOAP/WSDL) + a REST (CSDL) service just by adding some tags to the code.\n\nAfterwards you get a nice description of your library ...\n\nI don't really know if SemVer would have worked in that case as public web services always needs to keep the previous versions (not everybody can upgrade as fast as desired), but it can definitively be implemented (I guess) maybe based on the Swagger definitions? (which is not yet a common standard)", "id": "daovhl1"}, {"comment": "Good points, I can see how this concept is more \"pure\" by only targeting libraries/packages. And certainly you are right that web service API versioning makes more sense at the API schema level, rather than assembly/compilation.", "id": "dap7qrs"}]]], "5fx9bs": ["Agile has failed. A peek at the future of programming. Key parts from an amazing talk from Uncle Bob Martin", "2016-12-01 18:50:07", 0, "https://www.codingame.com/blog/agile-failed-peek-future-programming/?utm_source=reddit&utm_campaign=blog&utm_medium=post-programming&utm_term=future", [[6, "I like this sort of summary. Some choice quotes:\n\n>Agile is about discipline. Agile is about all the promises you make, and not a list of tasks you follow. A programmer must know how to work in within short timeframes, how to estimate the needed work in relative units, how to communicate with customers\u2026 \n\n>A problem happened when business got in the way. Business was totally in line with what the Agile movement offered. The whole set of principles made sense. However business started to take control over some of the activities of software development. The issue is that business doesn\u2019t always understand what programmers are doing. It\u2019s not part of their expertise and shouldn\u2019t be.\n\n>Software craftsmanship is slowly getting swallowed up by business and project managers. The irony is that one goal of Agile was to \u201cheal the divide between business and programming\u201d (Kent Beck).\n\nand the most important bit:\n\n>Uncle Bob finally explains the need for programmers to regulate themselves, define the ethics and principles they should follow and set a level of moral discipline to respect."], [6, "The real issue isn't that we had a different breed of \"programmers\" in the past (I'm one of them programming since 1968). The real problem is the unrealistic expectation that programmers can see through the uncertainty of the customer and clearly craft the correct solution. We programmers ought to know that is pure crap.\n\nThe other thing that has happened is that venture capital driven companies want to get to market, quickly, and cash out. So the systems we build go out the door without any \"trial by fire\". We are told to drive it to market since that means we win. Of course this also means the customer of our product usually ends up with a piece of crap.\n\nI'm sure you have all heard the one about the relentless movement forward of technology. It has a shorter and shorter life time! \n\nFWIW"]], [[{"comment": "I like this sort of summary. Some choice quotes:\n\n>Agile is about discipline. Agile is about all the promises you make, and not a list of tasks you follow. A programmer must know how to work in within short timeframes, how to estimate the needed work in relative units, how to communicate with customers\u2026 \n\n>A problem happened when business got in the way. Business was totally in line with what the Agile movement offered. The whole set of principles made sense. However business started to take control over some of the activities of software development. The issue is that business doesn\u2019t always understand what programmers are doing. It\u2019s not part of their expertise and shouldn\u2019t be.\n\n>Software craftsmanship is slowly getting swallowed up by business and project managers. The irony is that one goal of Agile was to \u201cheal the divide between business and programming\u201d (Kent Beck).\n\nand the most important bit:\n\n>Uncle Bob finally explains the need for programmers to regulate themselves, define the ethics and principles they should follow and set a level of moral discipline to respect.", "id": "danq9jd"}, {"comment": "OMG this. The business has accepted the \"Agile\" spirit, but none of the practices. I have the most problems with the idea of incremental releases. \"Well I just noticed that this should be changed... can you fix it before the release?\"", "id": "danra34"}, {"comment": "My experience is the opposite: businesses superficially embrace the rituals, but do not understand the core values, nor do they have the balls to do what it takes.\n\nAnd so we end up with 60-minute standups, a \"Scrum Master\" who is really a plain old project manager, \"user stories\" that are just plain old vague feature requests rewritten to fit an awkward format, \"sory points\" that everyone translates into hours and minutes in their heads, a \"self organizing team\" where everyone does exactly what the scrum master tells them, and \"sprints\" that are really just excuses for dragging people into bi-weekly multi-day meetings to compensate for the fact that nobody is communicating, and nobody has a fucking clue what they are doing.", "id": "dao050s"}, {"comment": ".. And it gets worse when management notices that you can \"adapt scrum to your own needs\". That's when they start to mangle the process until the name \"scum\" is the only thing left of it.", "id": "dapkpd2"}, {"comment": "But when management says \"we're going to do Scrum by the book, because we've read somewhere that this is how it works best\", it also gets worse, because then everyone is expected to follow every rule to the letter, cargo culting and bikeshedding the project to death.\n\nA: *writes* The 'change password' function is broken, after I set a new password, the old one still works and the new one doesn't.\n\nB: You can't write that, it's not a proper user story. You have to write it in \"As a ___, I want to ___, so that ___.\"\n\nA: *sighs* As a user, I want the 'change password' function to be not broken, so that after I set a new password, the new works and the old one no longer does.\n\nB: Excellent! We're making so much progress here!", "id": "dapmd2q"}, {"comment": "Well I like the idea of quick iterations with feedback loops, but I guess it's too focused on short term results.", "id": "danrirw"}, {"comment": "But velocity is so good for morale and process. Keeping things moving in a regular way... Maybe we should call it programming constipation when requirements keep getting stacked without release!", "id": "danvunb"}, {"comment": "Yep, I've tried to get the designs and mockups broken down into \"functional but ugly\" and then \"functional + more features + looks good\" but every single time it's \"weeeeellllll this copy needs changing and then it'll be perfect!\"", "id": "dansaxu"}], [{"comment": "The real issue isn't that we had a different breed of \"programmers\" in the past (I'm one of them programming since 1968). The real problem is the unrealistic expectation that programmers can see through the uncertainty of the customer and clearly craft the correct solution. We programmers ought to know that is pure crap.\n\nThe other thing that has happened is that venture capital driven companies want to get to market, quickly, and cash out. So the systems we build go out the door without any \"trial by fire\". We are told to drive it to market since that means we win. Of course this also means the customer of our product usually ends up with a piece of crap.\n\nI'm sure you have all heard the one about the relentless movement forward of technology. It has a shorter and shorter life time! \n\nFWIW", "id": "dant6ka"}]]], "5fpmz8": ["Useful One-Line Scripts for Perl", "2016-11-30 16:39:16", 0, "http://www.catonmat.net/download/perl1line.txt", [[1, "here's another: http://btorpey.github.io/blog/2016/10/13/custom-tailor/\n"], [1, "Just wondering, what is the purpose of making these scripts fit on a single line? To me, it seems like in many cases it just makes it harder to read without really serving much purpose. \n\nAlso, should it really still be considered \"one line\" if you use a subroutine defined in a separate cpan module which might be many lines in & of itself? \n\nDon't mean to sound negative, I'm just curious \ud83e\udd14. Cheers "]], [[{"comment": "here's another: http://btorpey.github.io/blog/2016/10/13/custom-tailor/\n", "id": "dam347l"}], [{"comment": "Just wondering, what is the purpose of making these scripts fit on a single line? To me, it seems like in many cases it just makes it harder to read without really serving much purpose. \n\nAlso, should it really still be considered \"one line\" if you use a subroutine defined in a separate cpan module which might be many lines in & of itself? \n\nDon't mean to sound negative, I'm just curious \ud83e\udd14. Cheers ", "id": "dam4ntb"}]]], "5fyuk5": ["First Redox OS ISO Release", "2016-12-01 23:12:47", 154, "https://github.com/redox-os/redox/releases/tag/0.0.3", [[15, "Anyone able to get this to boot on virtualbox?\n\nMine get part way through the boot sequence boot and then hits a black screen."], [3, "Stuck on\n\n    DHCP: MAC: *the MAC here* Current IP: *vbox IP here*\n\nVirtualBox using recommended config, AMD CPU if it matters."], [1, "It panicked when it didn't recognize the network adapter, then it panicked when i removed the network adapter. Is a network adapter required to boot?"], [1, "Very cool. I'm excited for Redox. :) Is it beta, alpha, or pre-alpha?"]], [[{"comment": "Anyone able to get this to boot on virtualbox?\n\nMine get part way through the boot sequence boot and then hits a black screen.", "id": "daolgzk"}, {"comment": "I added an example configuration to the release notes that may help", "id": "daomhxx"}, {"comment": "thanks!\n\n**Edit:**\n\nI get further, but now I have a kernel panic: http://i.imgur.com/F7CIBiT.png.\n\n**Edit 2:**\n\nSeems there's a github issue for this error. I've posted there.", "id": "daomwl8"}, {"comment": "Changing the network driver to Intel 82540EM fixed it for me.", "id": "daopfu6"}, {"comment": "Cool, I'd been using the wrong 82540", "id": "daoq1xs"}], [{"comment": "Stuck on\n\n    DHCP: MAC: *the MAC here* Current IP: *vbox IP here*\n\nVirtualBox using recommended config, AMD CPU if it matters.", "id": "daoto18"}, {"comment": "We are tracking this issue here: https://github.com/redox-os/redox/issues/764\n\nI hope to fix it and release a new ISO today", "id": "dap2x4u"}], [{"comment": "It panicked when it didn't recognize the network adapter, then it panicked when i removed the network adapter. Is a network adapter required to boot?", "id": "daoy5b4"}, {"comment": "At the moment, yes. We are tracking this issue here: https://github.com/redox-os/redox/issues/773", "id": "dap2uqx"}, {"comment": "https://www.reddit.com/r/programming/comments/5fyuk5/first_redox_os_iso_release/daopfu6/", "id": "dap0qg8"}, {"comment": "VMware player, didn't have the option. Will give it a try when I get home to my \"proper\" setup. :)", "id": "dap6p3h"}], [{"comment": "Very cool. I'm excited for Redox. :) Is it beta, alpha, or pre-alpha?", "id": "dap9rn0"}, {"comment": "It's far from being pre-alpha, as far as I know.\n\nI mean, this is 0.3.0; it's in the early stages of development still.", "id": "dapbv6v"}, {"comment": "That's fine, but there's no way for me to map 0.3.0 to any sort of stability stage.", "id": "dapfj3w"}, {"comment": "I would say pre-alpha, but that is probably meaningless at this point. We have no requirements for stability that can be mapped to or tested.", "id": "dapl2oe"}]]], "5g4t4l": ["Crypto 101 - an introductory course on cryptography, freely available for programmers of all ages and skill levels", "2016-12-02 21:19:49", 2146, "https://www.crypto101.io/", [[535, "I'm going to bookmark this and never look at it again"], [36, "[This](http://www.vlsiinterviewquestions.org/wp-content/uploads/2012/04/xor.jpg) is the logic symbol for an XOR gate. The book shows a tri-state inverter."], [23, "Hmm so it's an introductory \"course\"?\n\nIs there going to be a \"course\" component-- as all I see is a PDF eBook?\n\nI am interested in this, though."], [21, "I read elsewhere that in the 2 years since this came out that the github repo for the book has changed a bit. Might need to check out and run the build for the pdf yourself to get the most current version."], [15, "Thanks for the share. It will go in the read log for later."], [12, "File won't open on mobile."], [7, "Crypto was so fun I went insane, and died. "], [8, "Kudos to Rackspace for the contribution. "], [5, "I took an online crypto class once. Didn't finish though.\n\nFirst rule of crypto; don't do it yourself, leave it to the professionals. Even if the theory is solid, you'll still have a chance to mess it up in the implementation."], [3, "now everyone's gonna write their own crypto"], [2, "This ebook is fantastic and the author, LVH, one of my favorite PyCon speakers every year. Super accessible, great for beginners."], [1, "AtlasTX?"], [1, "Does it come with an introductory picture of Bruce Schneier freely available for programmers of all ages and skill levels?"], [-8, "Sadly it's another one of those \"state of the art crypto from early 1990s\", with all the shit you should stay away from (bad ciphers, bad modes), and nothing about recent advances. You might as well use any obsolete textbook for it.\n\nWhat world needs is something that was written with modern crypto in mind, and which drops all the historical crap."]], [[{"comment": "I'm going to bookmark this and never look at it again", "id": "dapxxqw"}, {"comment": "Sums up my r/programming experince in one sentence.", "id": "daq09si"}, {"comment": "We need a support group.", "id": "daq2d7q"}, {"comment": "I'll bookmark that too.", "id": "daqa5pl"}, {"comment": "I thought that's what this was...", "id": "daqe4jk"}, {"comment": "Sums up my life in one sentence.", "id": "daq3qwp"}, {"comment": "You can change that. It takes some work but I know you can do it. Just try this, just this once: go check out the link here. Read through it. It's just one time. And then in the future you can look back and say to yourself, yes, I did manage to do it one time and that was easy. I'll try it again. From there you will build a habit. I know you can do it. That's how I break my bad habits and starts my good ones. I promise it can work if you just nudge yourself a bit!", "id": "daqcxvl"}, {"comment": "Nice and motivating comment, I'm going to save it and never look at it again. ", "id": "daqfl4v"}, {"comment": "In my case I would do it this once, feel satisfied that I did it this once and then never do it again.", "id": "daqggvu"}, {"comment": "There's more dev stuff to learn than time to learn it. Following your advice and actually doing this course means something else won't get learned due to lack of time. Or even worse, reduced redditing time.", "id": "dar1d5c"}, {"comment": "Thank you, you're great and very motivational!  I've actually been trying to change that recently.  I just bought a $15 course on coding today because I know I'll be much more likely to actually learn it knowing I've spent money on it, even if not a significant amount.  And I did save the link to my Pocket.  I want to learn basic coding before I get into cryptography- don't want to take on too many things at once.", "id": "darks0e"}, {"comment": "r/meirl", "id": "daq5kp6"}, {"comment": "Bookmarked. Already forgot about it. ", "id": "daqafjv"}, {"comment": "Even worse, I'm going to read every page of it and roll my own crypto.", "id": "daq1uqb"}, {"comment": "Just use it in production directly, then it will get tested by more people.", "id": "daqg1fd"}, {"comment": "Set it up in a black hat conference with the details of a bank account, and you won't have to worry about paying bounties!", "id": "daqiady"}, {"comment": "I thought that same thing right before I read the comments :P", "id": "daq5r7j"}, {"comment": "As someone who is really hating this about themselves right now, yep.", "id": "daq6sty"}, {"comment": "Can you ELIF what this means, like making your own crypto algorithm? Wouldn't it help to build it for learning purposes?", "id": "daqaglm"}, {"comment": "Are you trying to respond to /u/bureX ?\n\nYes I think you hit upon the key factor. For *educational* purposes, sure, writing your own security/encryption code can only be enlightening.\n\nBut the phrase \"roll your own\" connotes not just implementing it but using it in a real case... [BAD IDEA](http://motherboard.vice.com/read/why-you-dont-roll-your-own-crypto).\n\n", "id": "daqd7g5"}, {"comment": "It's really something where a surprising number of programmers needs to be educated about.", "id": "daqg26d"}, {"comment": "Yes I was. Thanks for the explanation and the links. Very helpful. ", "id": "daqjrl1"}, {"comment": "I'm reading it right now (it's also available as a well formatted \"real\" pdf book). It is both extremely interesting and not too hard to read. \n\nI would recommend you download it and keep a bookmark on your desktop (or something) to read it whenever you want to procrastinate.", "id": "daqfnwa"}, {"comment": "Haha right?\n\nI pushed myself to learn algebra and am pushing myself to learn set theory for cryptography.", "id": "daqc86e"}, {"comment": "I'll bookmark this, then lose the bookmark, and search all over my backups for when I remember it two months later, and not find it.", "id": "daqevnx"}, {"comment": "Just like every GitHub repository you starred.", "id": "daqkke7"}, {"comment": "You should also download a copy under a file name you will no longer recognize in a day or so. Reference AND security.", "id": "daqm8jy"}, {"comment": "I believe you stole this top comment from [another recent post on this sub](https://www.reddit.com/r/programming/comments/5e9o2f/a_list_of_computer_science_courses_with_video/) ", "id": "daqxxhv"}, {"comment": "I'll look at it again.  ", "id": "daq10xg"}, {"comment": "Well look at Mr. I have time to read things!\n\n^^^I ^^^need ^^^a ^^^new ^^^job.", "id": "daqamtn"}], [{"comment": "[This](http://www.vlsiinterviewquestions.org/wp-content/uploads/2012/04/xor.jpg) is the logic symbol for an XOR gate. The book shows a tri-state inverter.", "id": "dapijkk"}, {"comment": "In crypto diagrams xor is always \u2295. Anything else is just silly.", "id": "daq2eud"}, {"comment": "In case anyone is wondering, this symbol is used because xor is the same as addition modulo 2. ", "id": "daqjcck"}, {"comment": "What is addition module 2?", "id": "daqp73c"}, {"comment": "You add and then modulo 2.", "id": "daqpl9s"}, {"comment": "In math, yes, but even in logic arrow diagrams, you have it? Why break the convention?", "id": "daq4zzp"}, {"comment": "Different disciplines have different conventions. Like math notation was ever consistent between branches.\n\nCrypto diagrams are not circuits, and its XORs are generally not 1-bit, but wide, so there's really little risk of confusion.", "id": "daq5jci"}, {"comment": "Math and other disciplines use i for imaginary numbers, engineers often use j to avoid a mixup with currents - different strokes for different volks. ", "id": "daqcn2e"}, {"comment": "*Not* using it would be breaking convention.", "id": "daqjfjh"}, {"comment": "Tweet the correction at them, I'm sure they'll be happy you found something they missed.", "id": "dapkoqq"}, {"comment": "Good thing crypto involves abstract mathematical operations, and not physical gates, or else they wouldn't be right.", "id": "daq5w0z"}, {"comment": "It doesn't.  A tri-state inverter doesn't have a circle at the right side.\n\nIt shows an [inverter](https://en.wikipedia.org/wiki/Inverter_\\(logic_gate\\)#/media/File:Not-gate-en.svg) with a vertical line coming into it, symbolizing that the inverter is programmable (as discussed in the text.)  This is clearly an invented symbol, and makes perfect sense given the text and an understanding of what an inverter is in the first place.\n\nNow, I don't feel that this invented symbol is particularly useful.  If you understand inverters enough to immediately recognize the symbol for an inverter, you're almost certain to already understand xor, so the invented symbol is useless.  If you don't immediately recognize this as an inverter, the drawing is just noise.  And if you're too used to tri-state inverters so you see them even where they're not, the drawing will just draw out the incorrect pedant in you ;)\n\n", "id": "daq0q50"}, {"comment": "> A tri-state inverter doesn't have a circle at the right side.\n\nYou're thinking of a \"tri-state buffer,\" which is the circuit that is actually used in practice. Everyone in this subthread seems to be making this error. A \"tri-state inverter\" may as well as not exist, because there is no such thing in any standard cell library.\n\nYou can build a \"tri-state inverter\" by first inverting the data input to a tri-state buffer. This would give you an inverted input when the enable line is activated, and high-Z when deactivated.\n\nI agree that the use of the symbol in the presentation is absolutely inane. Co-opting and distorting commonly-used symbols from hardware in a presentation to software people is a terrible idea for the reasons you mentioned.", "id": "daq7jja"}, {"comment": "The symbol for xor in cryptography is (by convention) \u2295; it's not a circuit diagram.", "id": "daqisxp"}, {"comment": "I've always seen a tri-state inverter with the circle on the side, not the point. I think their picture is meant to be a regular buffer inverter (circle on the point) with an aux input controlling whether it inverts or not. A new symbol, so to speak, which acts like XOR, but in a conceptually slightly different way.\n\nI think they should have used the XOR symbol, but I'm not sure what they chose to do is wrong per se.", "id": "dapozkw"}, {"comment": "As a circuit designer who has drawn hundreds of tristate inverters, I get what you're saying, but that's definitely a tristate inverter.", "id": "dapxpaf"}], [{"comment": "Hmm so it's an introductory \"course\"?\n\nIs there going to be a \"course\" component-- as all I see is a PDF eBook?\n\nI am interested in this, though.", "id": "dapi78l"}, {"comment": "Coursera has an excellent intro to crypto course that is probably still free. It covers everything from early history through modern public key crypto.  There are quizzes, homework problems, and dedicated discussion forums. A little math heavy, but pretty good.  Mostly the take away should be: don't invent your own crypto.", "id": "dapvhq1"}, {"comment": "\"Don't invent your own crypto\"\n\nAs a mathematician it's always fun trying to determine just how broken people's DIY crypto is ;)", "id": "daq8spc"}, {"comment": "This makes me sad because I am going to end up needing to roll my own for micropython.", "id": "daqbn4a"}, {"comment": "Why?", "id": "daqi07w"}, {"comment": "Well, there are different stages of \"rolling your own\":\n\n1. Don't even use crypto. There are plenty of vulnerabilities that can hurt you before crypto is of any use. Think a public, read-only HTTP server, or an image viewer (where people view untrusted images).\n\n2. Use a well tested, properly vetted crypto library. 2 problems: how do you determine what's well tested and vetted, and how do you use it properly? Some mistakes, such as re-using nonces are easy to make, and can nullify your crypto.\n\n3. Implement known primitives yourself. Be sure to test the hell out of them. Seek out test vectors, see that they match. You don't want to end up with a *slightly* different primitive than the official one, because that tiny difference might break it completely. And of course, chose well vetted, easy to implement primitives. And mind timing attacks. And have your code reviewed by experts if you can.\n\n4. Invent your own primitive\u2026 Well, it has been done successfully, obviously. Else crypto wouldn't exist. Get a PhD, write papers, become an expert yourself\u2026 after a couple decades, you might end up with a primitive that stands the test of time.\n\nI suppose you don't need to go all the way to stage 4.\n\nStage 3 is relatively easy to attain, provided you followed an introductory cryptography course first, and make sure you're not alone. One pair of eyeballs is really not enough to vet crypto code into production. No matter what you do, have other people review your code and tests. Now as a starting point, I suggest you do whatever Daniel J. Bernstein says. Here are my current favourite primitives:\n\n- Chacha20 or Xchacha20 for encryption. It's fast, simple, and immune to timing attacks if you don't screw up.\n- Poly1305 for one time authentication. It's fast, and not too hard to immunise against timing attacks.  One big hurdle: figuring big numbers modulo arithmetic.  Or you can copy/port code from the web. Ensuring that code is constant time is not hard: no branch that depends on secret input, and no array index that depends on secret input.\n- Curve25519 and the like for public-key cryptography. Look up the constructions for encryption, signature, and key generation. Simple to implement if you figure out that dammed modulo arithmetic (I haven't yet).\n- Blake2b for cryptographic hash. Faster than MD5, reputedly very strong. A variant of this was a finalist for SHA3. Also, it's simple to implement.\n- Argon2i for password hashing. Or Scrypt if you don't trust Argon, I believe we have more proofs for Scrypts.\n\nFor practical purposes, I strongly suggest you look up Libsodium before you implement your own library. Even if you don't use it, most ideas there are worth stealing.\n", "id": "daqn0db"}, {"comment": "The Coursera Cryptography I by Dan Boneh is absolutely excellent, especially if you do all the assignments and programming for exercises. Unfortunately you then join the queue of people wondering when Crypto II will ever see the light of day...\n\nEdit: Forgot to mention that Prof Boneh has a draft graduate textbook on crypto that also looks excellent (although incomplete so far): http://toc.cryptobook.us", "id": "daqinoo"}, {"comment": "Yup, that's the one. Thanks for sharing the book link. Had no idea it existed.", "id": "daqnhrp"}, {"comment": "It says \"Get pre-release (PDF)\" which I am assuming means that the \"course\" will be coming out later.", "id": "dappriy"}], [{"comment": "I read elsewhere that in the 2 years since this came out that the github repo for the book has changed a bit. Might need to check out and run the build for the pdf yourself to get the most current version.", "id": "dapw8my"}, {"comment": "Compiling a book. \n\nWhat a time to be alive ", "id": "daqccqv"}, {"comment": "That's been the best way to do it for 40 years, since Knuth invented TeX. ", "id": "daqdkct"}, {"comment": "https://github.com/crypto101/book for the lazy enough to compile a book but not lazy enough to google.", "id": "daqclxo"}, {"comment": "Or whatever would make more sense than what I wrote.", "id": "daqcm74"}, {"comment": "Thank you Duck", "id": "daqf2hs"}, {"comment": "    blic/amsfonts/cm/cmmi10.pfb></usr/share/texmf-dist/fonts/type1/public/amsfonts/\n    cm/cmmi7.pfb>\n    Output written on XOR.pdf (1 page, 18346 bytes).\n    Transcript written on XOR.log.\n    \n    MPtoPDF 1.4.1 : XOR is converted to XOR-mps.pdf\n    mv Illustrations/XOR/XOR-mps.pdf Illustrations/XOR/XOR.pdf\n    ./org2tex Crypto101.org\n    Wrong type argument: stringp, nil\n    make: *** [Makefile:21: Crypto101.tex] Error 255\n    \n\nOh well.", "id": "daqfy81"}, {"comment": "The link on the site *should* be up-to-date. \n\nFrom page 14:\n> The copy of this book that you are reading right now is based on\nthe git commit with hash 3f89ec3, also known as 0.4.0-22-g3f89ec3.\n\nThat [commit](https://github.com/crypto101/book/commit/3f89ec3c26d607448ac2aea369b88bf4e90c4680) is from July 18, 2016.", "id": "dar4b8c"}], [{"comment": "Thanks for the share. It will go in the read log for later.", "id": "dapganx"}, {"comment": "You mean never right", "id": "dapv7wr"}, {"comment": "^", "id": "dapxvkj"}], [{"comment": "File won't open on mobile.", "id": "dapv98m"}, {"comment": "Works fine for me.", "id": "daq4j0z"}, {"comment": "^ typical developer.", "id": "daqa4ue"}, {"comment": "Had to open it manually via Moon+ Reader on Android", "id": "daq83zk"}, {"comment": "Yeah, also on Android. Am used to PDFs just opening in some default app that comes with the phone.", "id": "daq853t"}], [{"comment": "Crypto was so fun I went insane, and died. ", "id": "dapth8d"}, {"comment": "Sold!", "id": "daqohrn"}], [{"comment": "Kudos to Rackspace for the contribution. ", "id": "dapxx4y"}], [{"comment": "I took an online crypto class once. Didn't finish though.\n\nFirst rule of crypto; don't do it yourself, leave it to the professionals. Even if the theory is solid, you'll still have a chance to mess it up in the implementation.", "id": "daqi4of"}, {"comment": ">First rule of crypto; don't do it yourself, leave it to the professionals. Even if the theory is solid, you'll still have a chance to mess it up in the implementation.\n\nSomeone has to do it themselves, right? Otherwise there's no-one to leave it to.", "id": "daqo5n2"}, {"comment": "That's just the propaganda they use to convince us to use *their* crypto!", "id": "daqojhz"}, {"comment": "You can use implementations by djb and agl. Maybe a few others. ", "id": "daqozkx"}], [{"comment": "now everyone's gonna write their own crypto", "id": "daqdruj"}], [{"comment": "This ebook is fantastic and the author, LVH, one of my favorite PyCon speakers every year. Super accessible, great for beginners.", "id": "daq2y5e"}], [{"comment": "AtlasTX?", "id": "daq41cc"}], [{"comment": "Does it come with an introductory picture of Bruce Schneier freely available for programmers of all ages and skill levels?", "id": "daqxtdy"}], [{"comment": "Sadly it's another one of those \"state of the art crypto from early 1990s\", with all the shit you should stay away from (bad ciphers, bad modes), and nothing about recent advances. You might as well use any obsolete textbook for it.\n\nWhat world needs is something that was written with modern crypto in mind, and which drops all the historical crap.", "id": "daq29iy"}, {"comment": "Go write that book. I'd read it. <3", "id": "daq2nri"}, {"comment": "There's an actual course: https://www.coursera.org/learn/crypto", "id": "daq8ltz"}, {"comment": "Even better, thanks! ", "id": "daqisui"}, {"comment": "\"Use libsodium\". Short book. ", "id": "daqdlg0"}, {"comment": "And that would be way better book that the one OP posted.", "id": "daqk0bs"}, {"comment": "Care to provide some examples?", "id": "daqcl4h"}, {"comment": "DES, 3DES, RC4, CBC, \"textbook\" RSA (which is horribly insecure without book worth of workarounds) etc. All of that is like teaching people web design and devoting half the book to <font> tag and using <table>s for layout. \n\nMeanwhile nothing about protocol design (which is the most common way crypto fails), modes that are actually usable barely covered etc.\n\nlibnacl actually solved quality approachable crypto on implementation side if you want to get good starting point.", "id": "daqcv87"}, {"comment": "I've read the chapters about DES and 3DES. The author explains why NOT to use them. I find such information quite interesting and useful.", "id": "daqjty1"}, {"comment": "So you prefer that text about crypto does not mention DES, etc?\nI don't think you even took a look at that material, because it's purpose is to show what are common pitfalls and how to avoid them.\nAlso, I am more inclined to believe endorsement of Thomas Ptacek over vague complaint by some /u/taw.\n", "id": "daqfbki"}, {"comment": "> So you prefer that text about css does not mention <font> tag, etc?\n\n> So you prefer that text about chemistry does not mention attempt to turn lead into gold, etc?\n\n> So you prefer that text about windows programming does not mention DOS 5.0, etc.?\n\nIt should be common sense. Somehow in crypto world it's not.", "id": "daqhel2"}, {"comment": "There's value in historical context. Take a look at the course plans for the cryptography classes at any top CS university, and you'll find no shortage of units on DES/triple DES, the Caesar cipher, the days when frequency analysis was a viable attack, etc. \n\nIf you just teach someone the current state of things, they don't get any of the evolutionary context to really understand the motivation behind some of the less obvious things that modern crypto algorithms do. ", "id": "daqo70k"}, {"comment": "I know a lot of universities teach this outdated crap, that's why state of security is so dismal today.", "id": "daqr8k7"}, {"comment": "You're clearly trolling, but I'll bite anyway...people who don't understand why things like CBC/CFB are a crucial part of AES and why ECB isn't suitable are more likely to introduce successors to modern encryption algorithms that share the same vulnerabilities. The best way to learn about what those vulnerabilities are and how they can be exploited is to learn about the historical context and prior algorithms that aren't strong enough, and to learn *why* they're not strong enough and what was done in modern encryption algorithms to circumvent those weaknesses. \n\nSomeone working in cryptography needs to understand why DES isn't good enough. To do that, they need to understand DES and the attacks that have been demonstrated on it. You're completely delusional if you think anyone is using DES or the Viginier Cipher or any of the other historical encryption schemes just because they were told it exists in a class which then promptly spent a week teaching them why they're no longer used. ", "id": "daqu1xh"}]]], "5fy8fx": ["Understanding and Preventing Overflow", "2016-12-01 21:31:49", 0, "https://www.embeddedrelated.com/showarticle/532.php", [], []], "5g3hym": ["How to screen Android developer skills - guide for IT recruitment -> pls help me improve it", "2016-12-02 17:24:39", 0, "https://devskiller.com/how-to-screen-android-developer-skills-to-find-best-guide-for-it-recruitment/", [[1, "So when did we jump to people writing articles about developmemt on platforms they are clueless about? The naiviete is astounding. FYI Generalities around your universe does not mean they exist in others."]], [[{"comment": "So when did we jump to people writing articles about developmemt on platforms they are clueless about? The naiviete is astounding. FYI Generalities around your universe does not mean they exist in others.", "id": "daqp7ly"}]]], "5gafys": ["markovjs - Reinforcement Learning in Javascript", "2016-12-03 19:59:12", 0, "https://github.com/lsunsi/markovjs", [[0, "just a little library I coded. (: I'm working with Reinforcement Learning for my college thesis and I'm tired of people thinking it is difficult or hard.\n\nJust added an example repo and another memory implementation (based on immutablejs)."]], [[{"comment": "just a little library I coded. (: I'm working with Reinforcement Learning for my college thesis and I'm tired of people thinking it is difficult or hard.\n\nJust added an example repo and another memory implementation (based on immutablejs).", "id": "daqpvms"}]]], "5gcxdk": ["jsdoc-plugin-testSpec: JSDoc plugin which connects inline comments & mocha tests specs with docs elements.", "2016-12-04 04:10:17", 1, "https://urosjarc.github.io/jsdoc-plugin-testSpec/", [], []], "5fr2hl": ["Introducing Amazon Lightsail", "2016-11-30 21:02:25", 341, "https://aws.amazon.com/blogs/aws/amazon-lightsail-the-power-of-aws-the-simplicity-of-a-vps/", [[74, "Just so I'm understanding correctly, this seems a hell of a lot like Digital Ocean right?"], [50, "[deleted]"], [28, "As [someone on HN](https://news.ycombinator.com/item?id=13072474) pointed out, traffic is ridiculously expensive:\n> $0.09 per GB for bandwidth overages. So, your $5 server with 1TB out becomes a $95 if you have 2TB out.\n\n"], [23, "What differentiates a VPS from a conventional Amazon instance?"], [8, "Who at Amazon gets to name these things?"], [8, "I feel like they missed an opportunity to have this product just be a nice frontend for AWS resources which already exist. Use lightsail to create an manage an EC2 instance for beginners, but as you become more comfortable with AWS you can dip your toes into the their terrible UI and actually see the components which were created to make that VM possible (EC2, EBS, probably EIP). \n\nIt'd be a great upsell to help new users get started on the AWS platform. \n\nInstead its just some pithy competitor to DO that I have a hard time believing anyone will seriously use. "], [8, "congratulations AWS, you are offering now ... almost the same service that Digital Ocean provides 3+ years ago (and in some cases with less CPU cores) and less CPU cores AND memory than Linode too for the same price. And, only in one AWS datacenter, not more than 6 datacenters around the world, like Digital Ocean and Linode now. don't forget AWS, your crap CPU core performance in comparison."], [5, "Does anybody know if a free-tier elegible account can use lightsail without paying, or paying less? I was able to see that the $5 / mo plan offer 1 free month.\n\nI was considering moving to DigitalOcean because I'm having a hard time accessing my wordpress site after I stopped and started the instance in order to create an image of it. I think I'll give lightsail a go."], [6, "Seems to lack OS options compared to DO"], [3, "> Lightsail is currently available in all the Availability Zones in the us-east-1 (N. Virginia) region.\n\nGah, the popular (read: cheap and easy to use) VPS providers never have an Aus/NZ option (no, Singapore doesn't count). Seeing as EC2 is available in Sydney I thought Lightsail might change things, apparently not.\n\nEdit: ok I lied, Vultr has Sydney."], [3, "Can you attach EBS volumes or are you stuck with the base storage?"], [3, "Good luck running gitlab on a 512M RAM VPS."], [1, "this should be the warning flare for the little guys. I imagine in the future plans will improve"], [1, "What do people use VPS mainly for? If I want to run a Linux lab with full permissions would that be a good solution instead of virtualization on my weaker laptop? I am pretty much looking to practice for RHCSA and I would like to be able to do everything that I can on my laptop but remotely. Would VPS be a good fit? I've never used one before."], [1, "I don't think people get that AWS is meant for large scale applications that require auto scaled/load balanced EC2 servers with RDS servers that have replication and read only servers etc... For this application it ties everything together so well. \n\nDoing the same on digital ocean or and equivalent VPS provider would be a nightmare.\n\nIf you are just joe blogs wanting to set up a website for your mate who is a plumber then AWS isn't really for you... Until now of course, since Lightsail is essentially replicating the same model as all the good VPS companies such as Linode and Digital Ocean."], [0, "I wrote a quick post about it: https://ayesh.me/amazon-lightsail-review\n\n</shamelessselfpromotion>\n\n\nThe only thing I don't like with AWS is their traffic costs. That's something I have no control over, and I have to use a prepaid card with AWS because one DoS is enough to cost me a fortune. "], [0, "A complete rip-off of DigitalOcean :)"], [-10, "Just like Google Compute Engine!"]], [[{"comment": "Just so I'm understanding correctly, this seems a hell of a lot like Digital Ocean right?", "id": "dameama"}, {"comment": "The pricing is almost exactly identical to DO. In the higher tiers, you get fewer cpus for the same price as DO offers. \n\nSeems like they are trying to get some of that \"I want a super easy vm with no fuss\" market.", "id": "damhm13"}, {"comment": ">\"I want a super easy vm with no fuss\"\n\nWhich is pretty much the opposite of AWS", "id": "damwu9l"}, {"comment": "Hm, I wonder why automating the setup of an AWS EC2 image is too difficult? I guess because other stuff can be added on and users can get confused later.", "id": "danc1gs"}, {"comment": "Maybe because their whole UI is complete shit and a horrible design by committee nightmare. \n\nAmazon is pretty meh as a coproration in my opinion.", "id": "danc6y6"}, {"comment": "What are you talking about?  They just overhauled their whole UI to make it pretty!  Of course it's still not functional but it's modern!", "id": "dankax1"}, {"comment": "More like just the landing page. I give you one, maybe 2 click at most, away from that page and you'll see the exact old UI.", "id": "danmnef"}, {"comment": "Classic example of a UI designed by engineers.\n\nI struggle to understand how a company with as many employees as Amazon, on a project that brings in as much revenue as AWS, couldn't hire some UX and IA people.", "id": "daneoj5"}, {"comment": "Pride. Probably designed by seniors", "id": "dangcbl"}, {"comment": "Dear god, the permissions system is insane. They give you an UI to then have to put in json format permissions which it then gives you vague validation errors about and tells you to fix it.\n\nI walked away and used Azure just because while Microsoft has a similar system, their validator actually gives you the exact error.", "id": "danq4ig"}, {"comment": "I finally bit the bullet a month ago and learned how to set up EC2 instances on the next leg of my journey from Heroku to Digital Ocean to AWS. After you climb over the learning curve of EC2, Digital Ocean feels like its only competitive feature is a better UI and that's about it. AWS has such terrible interfaces and docs though that a UI improvement is apparently a business idea by itself.", "id": "damfbpd"}, {"comment": "From what I hear: AWS also lacks a \"never charge me more than $X per month... kill the server first\" option.\n\nThat is a pretty enticing option.", "id": "damsuab"}, {"comment": "That's why I've never used AWS for personal projects. No matter how much I fuck up, I'll never wake up to a $2000 bill.", "id": "dan22ef"}, {"comment": "It is Amazon and they have refunded people who have done so, but an actual feature would be nice ", "id": "dan8dof"}, {"comment": "I've woken up to 2 of those with Amazon due to Rds and then an out of control ec2. Amazon credited me both times as long as I fixed the issue that caused the runaway", "id": "danc3rh"}, {"comment": "You can set up billing alerts so you know when the costs crossed a certain number. Than you can get in yourself and kill stuff.\n\nI would never want a service provider to kill a service unexpectedly.", "id": "dan9ag6"}, {"comment": "Sure, but we're talking about a provider _allowing you_ to set a threshold where the service is halted, to save _you_ unexpected or unintended charges - not about arbitrary termination.", "id": "dana416"}, {"comment": "I understand that. But do you really want to risk production machines terminated because of a single limitation? I really see no case in which I would be fine with a sudden termination of instances.", "id": "danazkp"}, {"comment": "Personal vm's..? ", "id": "danb6cf"}, {"comment": "If it would be okay to terminate them while I'm not using them, I terminate them when I'm done.\n\nMost people use AWS for production things. The risk of accidental termination is really high with a set cost limit. Also, you continue to pay for things like S3 storage, so cost can't be limited there, which means you'll still end up above your cost limitation.", "id": "danbspm"}, {"comment": "I haven't seen any hint that this discussion is about production VMs in the first place, and most definitely not uptime-critical ones..", "id": "dand5gr"}, {"comment": "But if there is a limitation on your account, that affects personal AND production VMs. Most accounts will also have production VM's active.\n\nFor personal stuff, this could be great. But it's just better to terminate when you're done using it. It is way safer and less chance of terminating things that shouldn't be terminated.", "id": "dandnct"}, {"comment": "Yeah, there should be configurable caps on pretty much everything there.\n\nSo I can specify that \"never run more than x VMs\" and just deal with site being slightly slower instead of racking extra costs", "id": "dan64ef"}, {"comment": "If you use something like Elastic Beanstalk (which a lot of smaller services do) then you can set that exact setting. You can't set it account wide though.", "id": "dan9c64"}, {"comment": "Autoscaling is a feature, but not one that's on by default. It only scales to more servers if you configure it to be allowed to do so, and only up to the max that you allow it to go. You can't configure your limit in terms of $ amount, but you can impose limits.", "id": "dana38g"}, {"comment": "Which provider has that option though? As far as I'm aware everyone charges for overages", "id": "dane74w"}, {"comment": "I've heard digital ocean does.  But I don't have any experience with it.", "id": "dank0uu"}, {"comment": "I definitely agree. Honestly AWS was only daunting at first for me because of the UI but after I actually set up an instance and ssh'd into it, I found it to be incredibly easy.\n\nHeroku and Digital Ocean are nice but once I got used to AWS's flexibility I couldn't go back.", "id": "damfrtd"}, {"comment": "I've been using AWS for the past six months, and it's still daunting. One of the worst things about the UI is that it lets you names things, but then asks you to choose those things by their [opaque IDs](http://imgur.com/a/1iQEf).", "id": "daner6j"}, {"comment": "If you don't care about a UI, just use ovh. I sanely better deal hardware wise but also an insanely worse UI", "id": "damrjmy"}, {"comment": "Until a car hits the pole outside the data center and takes them offline for 8 hours.\n\nFor personal/hobby projects its fine but there's a reason businesses pay for AWS.", "id": "damz45t"}, {"comment": "Did that happen?", "id": "dan144m"}, {"comment": "Twice.\n\nhttps://groups.google.com/forum/m/#!topic/montrealrb/UkEzcNvHRDg\n\nhttps://twitter.com/ovh_support_en/status/661229620675526657\n\nDon't worry, they had redundant fiber lines out of the building. The problem was they were run on the same pole the car hit. Twice.\n\nCheap as hell though. If you're setting up a Minecraft server they're awesome. Just think really hard about production servers there.", "id": "dan2d90"}, {"comment": "> https://twitter.com/ovh_support_en/status/661229620675526657\n\nholy shit", "id": "dan6bl0"}, {"comment": "Yeah I feel like all the hatred I'm reading here toward AWS is from people who never really had to manage an extensive network of systems. \n\nRunning a VPS for a blog or your own personal builds is one thing. When it comes down to enterprise level computing (including things like redundancy, backup, compliance, etc.) the smaller VPS providers just don't cut the mustard (sometimes). \n\nAWS isn't as difficult as some people here make it out to be. I can spin up any EC2 instance I want in a virtual network in about 5 minutes total. ", "id": "dangz47"}, {"comment": "AWS had their share of failures too...", "id": "dan67a7"}, {"comment": "I can't think of one that has been AWS wide. The biggest ones I know of have been region-wide, with many impacting only single availability zones. That will get you if you've chosen to run your app only in a single region (which, to be fair, many do), or in only a single AZ (which almost nobody does, and nobody should), but the tools are absolutely there to design your architecture to be extremely fault tolerant even in the face of AWS outages. ", "id": "dana6hy"}, {"comment": "...which is the same thing you'd have to do for OVH servers\n\noverall it is cheaper service with worse API", "id": "danbiq5"}, {"comment": "They're getting there, but they don't have [nearly the availability](https://www.ovh.com/us/about-us/datacenters.xml) of AWS. If you want to provide a service to North America right now with reasonable latency, you only have one region to choose from, meaning your application will still be vulnerable to whole-region outages. It seems to me like for anything where availability is *that* valuable, OVH is only viable in Europe right now. ", "id": "dankxbp"}, {"comment": ">AWS has such terrible interfaces and docs\n\nI used to feel this way until I tried Microsoft Azure", "id": "damwjiw"}, {"comment": "Microsoft Azure VPS is very unstable :(", "id": "danagx8"}, {"comment": "It's pricing also kicks the shit out of EC2, unless you're using Spot Instances and no bandwidth. Bandwidth is dirt cheap at DO and expensive as hell on AWS.", "id": "damxsfm"}, {"comment": "omg wait until you're using their CLI or other automation tools and you're doing it across 20 of their products and not just EC2. It can be so bad.", "id": "damyu86"}, {"comment": "> AWS has such terrible interfaces and docs though that a UI improvement is apparently a business idea by itself.\n\nHow else would they sell you a training and certification program? The  AWS web UI is just freaking awful.", "id": "danb8hx"}, {"comment": "Indeed. Also [Vultr](https://www.vultr.com/). I'd be interested in seeing some benchmarks, though what I really liked about Digital Ocean and Vultr was the ease of use.", "id": "dameexj"}, {"comment": "I'm pleased with vultr CPU performance. It's the best windows vps I've found.", "id": "damxm3u"}, {"comment": "Very similar but unlike DigitalOcean, there are ways to accidentally go over the $/Mo you pay. For example:\n\n- Delete a VM but keep and don't use the IP ($3/mo)\n\n- Use excess traffic ($0.09/GB, which is $90/TB)\n\nBilling on AWS has always been a problem.\n\nPlus as someone else mentioned, CPUs on the higher tiers are much more limited on AWS. DO is also available wolrdwide while Lightsail is only available in us-east.", "id": "damxm29"}, {"comment": "I expect it'll be possible to accidentally spend more with DigitalOcean once they start billing for bandwidth and charging for unattached IP addresses.", "id": "danesm3"}, {"comment": "It's also possible (likely even) that DigitalOcean won't enable these things by default.", "id": "danvb74"}, {"comment": "Oh, they will enable them.", "id": "danvwgi"}, {"comment": "Indeed, based on pricing and similar specs it's probably to directly compete with DO\n\nAmazon: https://media.amazonwebservices.com/blog/2016/ls_pricing_dots_2.png\n\nDO: http://i.imgur.com/tPZqz6K.png\n\nUsing an AWS VPS though is probably meant to be a gateway drug into the rest of their offerings.  ", "id": "damozxg"}, {"comment": "Amazon pricing has always been a nightmare to predict so I welcome a simpler and more predictable pricing model from them.\n\nAs of today DO and Linode are a better deal though. Of course AWs offers a whole host of other services so this will be very useful for people taking advantage of kinesis, RDS, S3 or any one of two dozen other services they offer.\n\nI hope google follows, they are already cheaper than AWS.\n", "id": "dangii9"}], [{"comment": "[deleted]", "id": "damgt5q"}, {"comment": "Yes but I am pretty sure Lightsail comes with a cape.  \n\nhttps://www.digitalocean.com/community/questions/does-digital-ocean-come-with-a-cape-and-a-motorcycle-like-amazon-lightsail", "id": "damn9al"}, {"comment": "\"We're always looking for ways to continue to improve the services we offer here at DO but motorcycles and capes never made their way to our Uservoice or product roadmap until now. We'd love to hear more from you. Can you open a ticket on your DO account with us with the subject \"Attn: Community\" and we can talk more there.\"", "id": "damnqdb"}, {"comment": "NO CAPES!", "id": "danejep"}, {"comment": "If you compare it like that, AWS has always been more expensive and will probably always be, so not much news in that.\n\nYou can find VPS providers down to $14/YEAR (yes pr year) for 30gb disk, 1vCpu and 512MB RAM with \"1TB bandwidth/month\" (well try and exhaust it........). They make DigitalOcean and Linode look like shit, but just try and actually use them and see what you get.\n\nI make my living by running things of DigitalOcean with Vultr and Linode as failover/backup (I use both depending on what I feel like), and I'm not a big fan of AWS myself, but you can't deny they are big and I think their product might end up being better/more stable/more secure/better future proofed.", "id": "damh8fr"}, {"comment": "Your last point is probably the best argument; they are probably the least susceptible to failing/closing down versus smaller providers.", "id": "danrzph"}, {"comment": "DigitalOcean has reached \"critical mass\" I think. The warnings will be long and easily heard before they go under.\n\nI must admit I don't trust Vultr and Linode that much, based on pure \"mass\". Especially Vultr is low in my trust rank because of their \"proprietary stack\" and I can't find any revenue or economics about them... They got a nice product tho, especially their $5 / 125GB storage VPS is nice. OpenCloud = Fuck dropbox forever. It's backed by RAID btw (I asked their support).", "id": "dao5ogb"}, {"comment": "> You can find VPS providers down to $14/YEAR (yes pr year) for 30gb disk, 1vCpu and 512MB RAM with \"1TB bandwidth/month\" (well try and exhaust it........).\n\nWhich one? and how reliable is it?", "id": "danunrb"}, {"comment": "https://lowendbox.com/tag/yearly/\nGo find some here.. I can't remember what the name was, and I think it might even have been a Black friday offer, but they are not too far off. If you want to play with this kind of stuff, browse Lowendbox website for cool offers.\n\nPlease note these are pretty much (99,99% of the time) OpenVZ boxes, so expect overselling. The performance is not great, and it's especially the I/O that iwll suffer, so will uptime.. But the ones (at low yearly prices) I've used before (a few years back) were actually \"great\". I think I've paid $8/year for a 128MB RAM, 1vCPU, 5GB node with 50GB traffic pr. month (and cutoff above that). The RAM was burstable to 256MB and honestly it ran pretty decently. Fine for experiments, and probably also hosting blogs or stuff like that. I enabled SWAP to a 256MB file just to give it some space, and then I just kept Nginx + PHP5FPM + MySQL with 32MB InnoDB pool on it. Really fun to play with. \n\nPerformancewise I would place it around or slightly above a Raspberry Pi model A 1 with singlecore and 256MB RAM.", "id": "dao5fu5"}, {"comment": "Well then you can't really compare them with amazon can you?", "id": "daqntrm"}, {"comment": "Narh. It probably wasn't clear enough in my actual first comment, but I meant that the ultra cheap services are usually not production worthy... \nThose ultra cheap Lowendbox servers are still fun to play around with, and you never know what you might get, just don't go putting your critical stuff on them.\n\nFrom experience I can tell that it's usually not random Hypervisor crashes or even bad CPU performance that gets you, but simply piss-poor network and disk I/O. I had a relatively simple SaaS product being hosted somewhere way to cheap, and the latency went from 20 ms (to generate the dashboard without network) to 290ms randomly, because of disk I/O, and we would get downtime alerts and even complete unreachability on the IP's from various networks. I've also had another node somewhere else that collected IP Camera images and that worked perfectly for years... Go figure??? \n\n\nLinode and DigitalOcean are very much ready for \"prime time\". Vultr seems to be too, but can't really vouch 100% yet. ", "id": "dar7klg"}, {"comment": "> Linode and DigitalOcean are very much ready for \"prime time\". Vultr seems to be too, but can't really vouch 100% yet. \n\nDo you know of any good (and cheap :)) European providers? I'm not comfortable putting my private data on American providers. \n", "id": "darp6h0"}, {"comment": "... and no IPv6.", "id": "damoogu"}, {"comment": "I actually run one DigitalOcean instance exactly for this reason.\n\nI run a monitoring job on DigitalOcean probing some of my home automation thingies that only have IPv6 addresses.\n\nI wish my employer's offering (GCE) offered IPv6.\n", "id": "dan1wgo"}, {"comment": "Interesting! I've yet to deal with any \"IoT\" piece that only supports IPv6, but things like home automation hardware make sense for that. I'm curious which hardware you're using. ", "id": "dan7xcb"}, {"comment": "It's not that they _only_ support IPv6. It's that I switched from having 5 static IPv4 addresses to Monkeybrains where I have great IPv6 and a IPv6 PD /52 or something sufficiently ridiculous, but no longer have a static IPv4 (or five), so I use IPv6 where possible now instead, especially because that's the only static way into my house.\n\n(Well, actually, I have reverse tunnels over ssh to various services to static IPv4 addresses in The Cloud and stuff... but it's less sexy)\n", "id": "dan8m43"}], [{"comment": "As [someone on HN](https://news.ycombinator.com/item?id=13072474) pointed out, traffic is ridiculously expensive:\n> $0.09 per GB for bandwidth overages. So, your $5 server with 1TB out becomes a $95 if you have 2TB out.\n\n", "id": "damzbko"}, {"comment": "So pay $10/month and deal with it.  Drink one less cup of Starbucks per month and it's paid for.", "id": "damzo7b"}, {"comment": "What a shitty response. There are a many reasons why you could suddenly have double or triple the traffic that you were expecting, resulting in some hefty charges. There are zero mechanisms built into AWS to prevent this kind of thing from happening, not to mention the traffic charges are in no relation to the actual cost. ", "id": "dan17us"}, {"comment": "Not exactly true. You can set up warnings that will trigger when you reach a certain cost. ", "id": "dan494o"}, {"comment": "With Azure you can have it cut off. If Azure can do it I don't see why Amazon can't.", "id": "dan4d8n"}, {"comment": "[deleted]", "id": "dancd5c"}, {"comment": "Its only been the most complained about thing since the start of AWS\n\nthey don't care about the usecase (hobbyists) that limits help with", "id": "danci3d"}, {"comment": "AWS isn't a hobbyist provider. Open and shut case.", "id": "danh2fp"}, {"comment": "That was the point, yeah", "id": "danhoni"}, {"comment": "It still seems fairly stupid. How am I supposed to learn to use AWS if I'm afraid to touch it? I make recommendations at work for what technologies we will use, and I'm probably going to recommend something I'm familiar with (or could at least become familiar with) without having to go through the hassle of having the company set up an account somewhere so I won't get a $2K bill when someone fucks up. ", "id": "danicvt"}, {"comment": "> I'm afraid to touch it? \n\nWhy would you be? The nightmare scenario people are talking about (overnight bandwidth explosion) is only possible if you make your site public.", "id": "danjll8"}, {"comment": "But that's the problem, Lightsail seems to be attempting to enter that market (that and the small dev team that may not have sysadmin experience), but with the hefty overages it's just too risky.", "id": "danu7v4"}, {"comment": "Then your $10 server with 2TB out becomes $100 if you have 3TB out.", "id": "dani33g"}, {"comment": "What's the point of automatic scaling if the payments are structured against that feature? ", "id": "dandcyc"}], [{"comment": "What differentiates a VPS from a conventional Amazon instance?", "id": "damh6ty"}, {"comment": "Bandwidth included in the price, no security groups to set up, no need to worry about volumes off the bat.", "id": "damhcpj"}], [{"comment": "Who at Amazon gets to name these things?", "id": "damndg4"}, {"comment": "Someone more competent than whoever is responsible for thinking up the version suffixes at Microsoft.", "id": "damu6m9"}, {"comment": "This is one of their better ones though at least.", "id": "damxyu6"}, {"comment": "I bet there are great names people have thought of. I'd love to see Amazon open up naming suggestions. AWS Boaty McBoatface coming soon!", "id": "damy9lh"}, {"comment": "What, were you expecting Elastic VPS? ;)", "id": "danb8a2"}, {"comment": "EPS? :D", "id": "danh36k"}], [{"comment": "I feel like they missed an opportunity to have this product just be a nice frontend for AWS resources which already exist. Use lightsail to create an manage an EC2 instance for beginners, but as you become more comfortable with AWS you can dip your toes into the their terrible UI and actually see the components which were created to make that VM possible (EC2, EBS, probably EIP). \n\nIt'd be a great upsell to help new users get started on the AWS platform. \n\nInstead its just some pithy competitor to DO that I have a hard time believing anyone will seriously use. ", "id": "damt3yg"}, {"comment": "It sounds like you're describing Elastic Beanstalk", "id": "dan25m9"}, {"comment": "do you need ec2/aws if you want custom applications/stack on the instance?", "id": "damtvu9"}, {"comment": "There is a service that is somewhat similar to what you are describing called Mobile Hub.", "id": "damzo4p"}], [{"comment": "congratulations AWS, you are offering now ... almost the same service that Digital Ocean provides 3+ years ago (and in some cases with less CPU cores) and less CPU cores AND memory than Linode too for the same price. And, only in one AWS datacenter, not more than 6 datacenters around the world, like Digital Ocean and Linode now. don't forget AWS, your crap CPU core performance in comparison.", "id": "dan09td"}, {"comment": "PLUS no local storage, meaning IOps is just shit compared to a Droplet on DO.  Like 1/100th level shit.", "id": "danucf2"}], [{"comment": "Does anybody know if a free-tier elegible account can use lightsail without paying, or paying less? I was able to see that the $5 / mo plan offer 1 free month.\n\nI was considering moving to DigitalOcean because I'm having a hard time accessing my wordpress site after I stopped and started the instance in order to create an image of it. I think I'll give lightsail a go.", "id": "damghoe"}, {"comment": "No, best you can do is one more free and then $5 per month thereafter.\n\nIf it's a blog you are hosting, then just a VPS from another provider, like RamNode etc. I pay something like $32 per year for a box with RamNode.\n\nI'll definitely try out LightSail, but I can't see myself moving unless  Amazon can beat my current plan.", "id": "damnk7i"}, {"comment": "If you're just hosting a blog, I'm not sure why you'd pay for a VPS over one of the many free services out there (github.io for starters). ", "id": "damsrkn"}, {"comment": "didn't even know about GitHub.io, wow. what other free services would you recommend?", "id": "daootwc"}, {"comment": "For a simple website, github.io is one of the best. Surge.sh is also really great. Azure has a free website hosting service that can be scaled up to a paid tier if your traffic increases. Just hosting it in an AWS S3 bucket is a surprisingly great option for a few pennies a month. Heroku/App Engine are also free tier options, but they're not as good because they have spin up times if your website hasn't been accessed in a while. \n\nA simple blog could be hosted on any of these. If you wanted comment support or something more dynamic, you might need something more powerful, like a VPS. \n\n", "id": "daquyd8"}, {"comment": "I use OpenShift to run my WordPress site.  It's not a huge site.  I was running it on the free plan for the last couple years.  I ended up needing more storage so now I'm paying for a couple extra GB of storage.  I think it's still less than $1 per month.", "id": "dan5ya2"}, {"comment": "I thought it said you get 750 hours free per lightsail account?  Idk, maybe I read it wrong.", "id": "dan0acq"}, {"comment": "I think that only applies to the smallest plan.", "id": "daniaf6"}], [{"comment": "Seems to lack OS options compared to DO", "id": "damuxsd"}], [{"comment": "> Lightsail is currently available in all the Availability Zones in the us-east-1 (N. Virginia) region.\n\nGah, the popular (read: cheap and easy to use) VPS providers never have an Aus/NZ option (no, Singapore doesn't count). Seeing as EC2 is available in Sydney I thought Lightsail might change things, apparently not.\n\nEdit: ok I lied, Vultr has Sydney.", "id": "dan410s"}, {"comment": "AWS services often launch in only one or a small handful of regions, but usually make it out to all or at least most of them. It will likely make it to Sydney eventually.", "id": "danabh6"}, {"comment": "Locally, Binary Lane (Sydney, Melbourne, & Brisbane) and Exigent (Sydney & Melbourne) are good.", "id": "danf114"}], [{"comment": "Can you attach EBS volumes or are you stuck with the base storage?", "id": "damn7gf"}, {"comment": "Base storage - based even on their docs and even that they've set up a separate site for it...  they're hiding away a lot of the infrastructure details involved.  ", "id": "damq0jt"}], [{"comment": "Good luck running gitlab on a 512M RAM VPS.", "id": "damz6l5"}, {"comment": "Yeah, that's not going to cut it :) We [advise against](https://docs.gitlab.com/ce/install/requirements.html#memory) anything under 1GB, and recommend 4GB, which means that you'd be looking at $40/month with Lightsail.", "id": "danfz68"}], [{"comment": "this should be the warning flare for the little guys. I imagine in the future plans will improve", "id": "dankvki"}], [{"comment": "What do people use VPS mainly for? If I want to run a Linux lab with full permissions would that be a good solution instead of virtualization on my weaker laptop? I am pretty much looking to practice for RHCSA and I would like to be able to do everything that I can on my laptop but remotely. Would VPS be a good fit? I've never used one before.", "id": "daoh8zj"}], [{"comment": "I don't think people get that AWS is meant for large scale applications that require auto scaled/load balanced EC2 servers with RDS servers that have replication and read only servers etc... For this application it ties everything together so well. \n\nDoing the same on digital ocean or and equivalent VPS provider would be a nightmare.\n\nIf you are just joe blogs wanting to set up a website for your mate who is a plumber then AWS isn't really for you... Until now of course, since Lightsail is essentially replicating the same model as all the good VPS companies such as Linode and Digital Ocean.", "id": "dap8m6l"}], [{"comment": "I wrote a quick post about it: https://ayesh.me/amazon-lightsail-review\n\n</shamelessselfpromotion>\n\n\nThe only thing I don't like with AWS is their traffic costs. That's something I have no control over, and I have to use a prepaid card with AWS because one DoS is enough to cost me a fortune. ", "id": "danbkf2"}], [{"comment": "A complete rip-off of DigitalOcean :)", "id": "danm3ap"}], [{"comment": "Just like Google Compute Engine!", "id": "damfzk9"}, {"comment": "It is not like GCC, we are paying for 2x(1 vCPU, 1.7 GB) 29 USD/month. With Amazon Lightsail we would be paying 40 USD/month with 600 MB of RAM as dead weight.", "id": "damiu4a"}]]], "5fwdtc": ["Let's crowd-source: Interesting Compiled Programming Languages by Wishlist Features", "2016-12-01 15:49:02", 0, "https://docs.google.com/spreadsheets/d/1BAiJR026ih1U8HoRw__nzbCSFnnHicWrjxpW5l6-O3w/edit#gid=0", [[1, "The background is that I've long been looking for a productive and performant general-purpose compiled programming language, that can stand up to at least the majority of tasks I would use a language for, while being something safer and more productive than pure C.\n\nI understand that no single language might match all one's requirements, but that is why I felt this kind of list would make sense ... then maybe I could identify two or three languages to learn and use, for the different use cases where they shine the most."], [1, "So after posting this on the wrong thread, yay tabs!\n\nFor D:\n\n* Supports fibers https://dlang.org/phobos/core_thread.html#.Fiber\n* Frontend is non-GPL license(Boost), alternative backends include LLVM are available\n* Generics, puts C++'s meta-programming to shame\n* Nested functions, yes\n* As defined by wikipedia, has first class functions (note function pointers as well as delegates so includes a context)\n* Has OSX support however we're still implementing/improving the Objective-C interop\n* Android support is available in a third party compiler (currently beta)\n* Package/modules, first class all files are done as modules\n* Hello world is at 209kb (Windows 32bit) but this can be cut down if you really cared about it\n\nI recommend also adding CTFE to this list, I am sure D will be one of the very few with that one."], [1, "The colours are making an implied value judgement on the garbage collection column. It's judging having a mandatory garbage collector (green) apparently superior to an optional garbage collector (yellow). Surely those should be coloured the other way around as flexibility would seem obviously better than not, assuming equal implementation quality?"]], [[{"comment": "The background is that I've long been looking for a productive and performant general-purpose compiled programming language, that can stand up to at least the majority of tasks I would use a language for, while being something safer and more productive than pure C.\n\nI understand that no single language might match all one's requirements, but that is why I felt this kind of list would make sense ... then maybe I could identify two or three languages to learn and use, for the different use cases where they shine the most.", "id": "danil01"}], [{"comment": "So after posting this on the wrong thread, yay tabs!\n\nFor D:\n\n* Supports fibers https://dlang.org/phobos/core_thread.html#.Fiber\n* Frontend is non-GPL license(Boost), alternative backends include LLVM are available\n* Generics, puts C++'s meta-programming to shame\n* Nested functions, yes\n* As defined by wikipedia, has first class functions (note function pointers as well as delegates so includes a context)\n* Has OSX support however we're still implementing/improving the Objective-C interop\n* Android support is available in a third party compiler (currently beta)\n* Package/modules, first class all files are done as modules\n* Hello world is at 209kb (Windows 32bit) but this can be cut down if you really cared about it\n\nI recommend also adding CTFE to this list, I am sure D will be one of the very few with that one.", "id": "dankyta"}, {"comment": "Many thanks! What is CTFE? :)", "id": "danra3l"}, {"comment": "Most likely Compile Time Function Evaluation. Basically allowing code to be executed in compile time, which allows for some nice things (e.g. imagine you have an \"ID\" type that is basically the hash of some string and you use a lot of predefined IDs in the source code - with CTFE you can have the hash calculator construct the value at compile time instead of having it calculated at startup time. Another example would be to generate a parser, using a description of the code to parse  - AFAIK there is a regexp library in D that can create regexp \"matchers\" at compile time so your regexp checks are already precompiled at runtime and are in machine code).", "id": "daoc1w6"}, {"comment": "CTFE: Compile Time Function Execution/Evaluation is the ability to execute code at compile time. Basically what /u/badsectoracula said.\n\nBut it can go a lot further, because D doesn't really support runtime reflection all that much most of it is pushed into compile time. So now things like ORM's are made during compilation which reduces lookups at runtime. So in a way it can be an optimization technique simply by making sure there is no code to run at runtime.", "id": "daoimlt"}], [{"comment": "The colours are making an implied value judgement on the garbage collection column. It's judging having a mandatory garbage collector (green) apparently superior to an optional garbage collector (yellow). Surely those should be coloured the other way around as flexibility would seem obviously better than not, assuming equal implementation quality?", "id": "danmjz0"}, {"comment": "Yeah, this is a problem ... I mean, I guess either way might be interesting for someone ... and for me personally I'm somewhat indifferent to both, although I'd of course use a non-GC'ed language for embedded work etc ... hard to know how to do.", "id": "danoovd"}, {"comment": "Green for both? I'd understand the table to be saying 'green - has this feature', 'yellow - has something similar but not quite or not fully implemented etc'. A language with an optional garbage collector still has the feature available.", "id": "danp8sw"}, {"comment": "Ok, I now changed the title to \"Provides a GC\", and added another column \"Can run without GC\", so that one gets at least one red box for languages that can't run without its GC. Hope it gives a more fair impression.", "id": "danr2ul"}]]], "5g1rpz": ["Mutmut: a Python mutation testing system", "2016-12-02 09:09:58", 5, "https://medium.com/@boxed/mutmut-a-python-mutation-testing-system-9b9639356c78#.plyau9sl3", [[1, "Author here. I'm happy to answer any questions!"]], [[{"comment": "Author here. I'm happy to answer any questions!", "id": "daplmm5"}]]], "5fx4az": ["Where did the popularity of the `i` variable come from?", "2016-12-01 18:25:29", 1, "http://retrocomputing.stackexchange.com/q/1796/621", [[27, "I always read it as i(ndex)."], [12, "In terms of programming, it came from FORTRAN,  no doubt."], [11, "Fortran 77 had implicit variable typing, so that I was the first (in alphabetical order) variable that was implicitly integer:\n\n* implicit convention that undeclared variables are INTEGER if their name begins with I, J, K, L, M, or N (and REAL otherwise)\n\nSource: https://en.wikipedia.org/wiki/Fortran#FORTRAN_77"], [2, "I always thought it was via fortran from doing physics. i hat, j hat, k hat denote vector components.\n\ngoing `for (i = 0; i < 100; i++)` feels an awful lot like traversing a vector.\n\nhttps://en.wikipedia.org/wiki/Unit_vector"], [1, "I'm not sure why people always comment on Stack Exchange links with answers to the question -- the answer is right there, on the linked page"], [1, "I believe back in the day it was common to make all variables single character, but only in the case of i,j,k there was no additional clarity by using a longer variable name."], [0, "How is this question not marked as *Irrelevant*, it is Stack overflow after all. "], [0, "tltc;dr: FORTRAN"]], [[{"comment": "I always read it as i(ndex).", "id": "dano8wy"}, {"comment": "i = integer", "id": "danom8n"}, {"comment": "I'm not sure I buy this actually; *i* and *j* have been used in indices in matrix math and similar since well before the computer era. (Per [wikipedia][1], using *i* and *j* as subscripts for matrix elements goes back to at least 1913. Probably it'd be possible to trace it back much further, but this was the first thing I thought of checking.)\n\nNow of course mathematicians talk about \"integers\" as well, but:\n\n* First of all, if the index variables were named after the class they are drawn from, I'd expect *n* (for natural) and *m* or something like that instead. Integers include zero and negatives.\n* Second, it seems a little weird that they'd name the variables after the set they could be drawn from anyway.\n\nI'm with DonManuel; I think in that context, *i* is a mnemonic for index, and *j* is the letter after *i*. And I think that using them as loop variables continues from that lineage.\n\n[1]: https://en.wikipedia.org/wiki/Matrix_(mathematics)#History", "id": "danqoy9"}, {"comment": ">*i* is a mnemonic for index, and *j* is the letter after *i*.\n\nIn mathematics if a 3rd subscript is ever needed it's almost always *k* in my experience, again just because it's next in the alphabet.\n", "id": "danqy7i"}, {"comment": "We can trace the use of 'i' at least to the 18th century and Euler. My guess is that its simply easy to write/read; mathematicians value brevity and clarity very highly.", "id": "dao3g30"}, {"comment": "While I don't consider Wikipedia as much of a source, I have no dispute with anything else you wrote.", "id": "danqzcb"}, {"comment": "Yep, that was my initial thought too.", "id": "danw9hd"}], [{"comment": "In terms of programming, it came from FORTRAN,  no doubt.", "id": "danp62y"}], [{"comment": "Fortran 77 had implicit variable typing, so that I was the first (in alphabetical order) variable that was implicitly integer:\n\n* implicit convention that undeclared variables are INTEGER if their name begins with I, J, K, L, M, or N (and REAL otherwise)\n\nSource: https://en.wikipedia.org/wiki/Fortran#FORTRAN_77", "id": "danqqqh"}, {"comment": "God is real. Unless declared INTEGER.", "id": "dansz15"}, {"comment": "Real numbers were created by man. Integers were created by God.", "id": "danuypq"}, {"comment": "The Kronecker quote:\n\n\"die ganzen Zahlen hat der liebe Gott gemacht, alles andere ist Menschenwerk / God made the integers, all else is the work of man.\"\n\nwas actually the favourite quote of my uni prof and he'd always get all philosophical about natural numbers lol, your post reminded me of this", "id": "dao6vyx"}, {"comment": "It's a beautiful quote. I didn't know it was from Kronecker. And he was right: integers are really something.\n\nThanks.", "id": "daoxctj"}, {"comment": "The question is why IJKLMN was chosen, and the answer is matrix notation.", "id": "danzusy"}], [{"comment": "I always thought it was via fortran from doing physics. i hat, j hat, k hat denote vector components.\n\ngoing `for (i = 0; i < 100; i++)` feels an awful lot like traversing a vector.\n\nhttps://en.wikipedia.org/wiki/Unit_vector", "id": "dant4i8"}], [{"comment": "I'm not sure why people always comment on Stack Exchange links with answers to the question -- the answer is right there, on the linked page", "id": "dapjnrn"}], [{"comment": "I believe back in the day it was common to make all variables single character, but only in the case of i,j,k there was no additional clarity by using a longer variable name.", "id": "dapqbvg"}], [{"comment": "How is this question not marked as *Irrelevant*, it is Stack overflow after all. ", "id": "dao1dla"}, {"comment": "It's actually not from Stack Overflow, but from Retrocomputing, a different Stack Exchange site for vintage-computer hobbyists.", "id": "daofsdt"}], [{"comment": "tltc;dr: FORTRAN", "id": "danoern"}]]], "5g0ks8": ["MMBasic is a free and open BASIC interpreter for 32 bit microcontrollers.", "2016-12-02 04:50:17", 12, "http://mmbasic.com/", [], []], "5g8qqa": ["(JavaScript and Web Development) Frameworks without the framework: why didn't we think of this sooner?", "2016-12-03 11:49:23", 0, "https://svelte.technology/blog/frameworks-without-the-framework/", [[5, "Cool! It looks like history is repeating itself and we are inventing Zero Cost Abstraction for the web. But I think that it's fine and we really should have done it a long time ago."], [2, "> Svelte generates components that work in all modern JavaScript environments, but the Svelte compiler only runs in Node 6+ and browsers that support ES2015 features. Please reopen this page in a different browser such as Chrome.\n\nUghh, no support for firefox? I think its more honest to say that the compiler only support V8 engine."]], [[{"comment": "Cool! It looks like history is repeating itself and we are inventing Zero Cost Abstraction for the web. But I think that it's fine and we really should have done it a long time ago.", "id": "daqe3h4"}, {"comment": "> we really should have done it a long time ago.\n\nWe did. Look up Adobe Flex, OpenLaszlo or Java Applets. It's all compiled code that outputs bitcode meant for an interpreter. The only difference is the interpreter in question is Javascript instead of a plugin. Heck, I can even tell you why something so obvious hasn't been written for JS before. \n\nThere's a predictable cycle these 'revelations' go through. You start with the ball of mud (pure JS and jQuery). Then you start to think there might be a better way to organize things, so you organize your code using MVC. Then you think that leaves your code too coupled together, so you re-write it to be more modular, using dependency injection/inversion of control patterns (Angular 1). But this all takes quite a bit of boilerplate to achieve and it's starting to slow you down, so you make a framework to get rid of most of the boilerplate for you (Angular 2, React). Eventually, the framework gets too big, too slow, too much of a pain in the ass to deal with, so you say fuck it! I can get things done much faster in pure js!\n\nGuess which part of the cycle we're in now?", "id": "daqkmtb"}], [{"comment": "> Svelte generates components that work in all modern JavaScript environments, but the Svelte compiler only runs in Node 6+ and browsers that support ES2015 features. Please reopen this page in a different browser such as Chrome.\n\nUghh, no support for firefox? I think its more honest to say that the compiler only support V8 engine.", "id": "daqkbit"}]]], "5gdjbj": ["My favorite bug", "2016-12-04 06:32:15", 46, "https://algo.is/my-favorite-bug/", [[52, ">But I\u2019ve thought about this experience multiple times since it happened. Why did it happen in the first place?\n\nBecause your C++ was *terrible*."], [22, "Oh fuck me!\n\nThis is trivial stuff, people, you can only make these mistakes when you're very inexperienced. Alternatively, you should know this is trivial and be sufficiently ashamed **not** to call it \"favourite\".\n\nAnd then, [the fix](https://github.com/SuprDewd/CompetitiveProgramming/commit/a72e4ec132d595beb7614c11e41bebf76e12f937) is incorrect. The correct things to do are one of\n\n* make the object noncopyable\n\n* pass it to size() with a **const** ref\n\n* implement copying\n\nOP, I see you're following... I am old and ragged. I've done this more times than I care to remember (on the plus side, it was sufficiently long ago that I don't remember specific occasions anymore :-)), and have seen it even more.\n\n\"In C++, OOP means **O**bject **O**wnership **P**rotocols\"."], [10, "This comment thread makes me very happy I don't have to write C++"], [3, "TL;DR: Author loves passing shallow copies of objects by value and corrupting data."], [2, "Now that I'm using C++14 I've resolved to basically [never have `new` or `delete`](http://scrupulousabstractions.tumblr.com/post/37576903218/cpp11style-no-new-delete) in my code. I developed a pretty careful attitude to memory management using C++03, but I sleep better knowing bugs like this are impossible using smart pointers and modern C++."], [2, "*cough*Rust*cough*"], [1, "     #define FIND_UPDATE(cmp, target) \\\n        int pos[MAX_LEVEL + 2]; \\\n        memset(pos, 0, sizeof(pos)); \\\n        node *x = head; \\\n        node *update[MAX_LEVEL + 1]; \\\n        memset(update, 0, MAX_LEVEL + 1); \\\n        for(int i = MAX_LEVEL; i >= 0; i--) { \\\n            pos[i] = pos[i + 1]; \\\n            while(x->next[i] != NULL && cmp < target) { pos[i] += x->lens[i]; x = x->next[i]; } \\\n            update[i] = x; \\\n        } x = x->next[0];\n\nwhy isn't this a function?"], [1, "[deleted]"], [1, "I find a good rule of thumb is that if you're implementing a class that needs a destructor, but you don't think you'll need a copy constructor or assignment operator for its intended use, you should make \"private\" dummy implementations of them so you catch yourself if you ever end up needing them."], [-1, "I hit the word swag and stopped reading."]], [[{"comment": ">But I\u2019ve thought about this experience multiple times since it happened. Why did it happen in the first place?\n\nBecause your C++ was *terrible*.", "id": "darea4i"}, {"comment": "Seriously, the WTF-factor per paragraph while reading this was huge.  Why would you not just use `size_t` for your loop variable instead of inventing all kinds of ways of shooting yourself in the foot?  Why would you deliberately violate the rule of three (slash rule of five slash rule of zero) and not expect to suffer dearly for it?  The only conclusion I can come to is that competitive programming rots the brain.\n\nEdit: I feel the need to point out that using a signed integer type for your loop variable can have advantages, in that the compiler is better able to optimize it since it can assume no overflow.  However, the entire standard library is designed with unsigned integer types in mind when working with indices and sizes and it's by far the safer and simpler route to stick to `size_t`, as those optimizations are likely to be relatively minor compared to the wide array of footguns that come from trying to mix signed and unsigned types.  And if you absolutely must use a signed type, at least use one with the same width as `size_t`, such as `ssize_t` (non-standard) or `intptr_t` (standardized but not technically guaranteed to be the same width as `size_t`, but it virtually always will be) or `long` if you're using a Unix platform (but not Windows.)  But definitely not `int`.\n", "id": "darefrq"}, {"comment": "More like, competetive programming leads to programmers that are very fast in C++, but don't know it very well.\n", "id": "darekxz"}, {"comment": "It seems like you're generalizing from a single blog post, which basically only represents my knowledge of C++. I'm sure there are competitive programmers that don't know much about C++, as well as competitive programmers that are experts in C++, just as there are programmers that work on production code that are experts in C++, as well as programmers that work on production code that don't know much about C++. I don't think we have any data to suggest there is a correlation between the two.", "id": "darlu9c"}, {"comment": "I only meant that there's subset of C++ users who are contest-only programmers and don't know it very deeply. If they wanted to, they would specialize in \"pro c++\". No need to be defensive, it's OK to be transisting like that. Most people commenting here don't understand \"cultural difference\" and feel offended that \"ignorant\" people like you are using C++ ;)\n\nI was using C++ since I was 14, just like many of my friends, to compete in official Polish competitions. C, C++ and Pascal are the only languages that are allowed in official Polish algorithm competitions (olympiads), and nobody uses Pascal here, because there's no standard library with data structures and algorithms, not even sort. And those olympiads produce world-class competitors.", "id": "darmn9m"}, {"comment": ":)", "id": "darmvyu"}, {"comment": "First, let me note that you guys are judging this as if it was a piece of production code, which it is not. Please read my comment below.\n\nNow, I think we both agree that mixing signed and unsigned integers is just a bad idea. So assuming we would only use unsigned integers, I would like to hear your thoughts on the issue I raised in the post about looping through all but the last element of a vector. That is, the following piece of code will output \"loop\" a lot of times:\n\n    vector<int> v;\n    for (size_t i = 0; i < v.size() - 1; i++) {\n        cout << \"loop\" << endl;\n    }\n\nThis is something that is very dangerous from a competitive programming point of view, as it is very easy to make this mistake, the compiler doesn't complain about it, and your program would otherwise work in all cases where the vector is not empty, possibly making it very hard to debug. I think this is a valid reason for using signed integers. And besides, in programming contests, we don't care about safety (as in, someone trying to, say, get shell access by smashing the stack) and the size of any array we will ever be able to work with will safely fit in a 32-bit signed integer.", "id": "darhu1g"}, {"comment": "I'd handle the empty container case explicitly:\n\n    if(v.empty()) return;\n\nOr perhaps:\n\n    assert(!v.empty());\n\n", "id": "dariefo"}, {"comment": "Everybody makes mistakes, especially when under time pressure. What you propose requires one to realize that the empty vector is a special case. But that is easy to miss. What I'm looking for is either a way to make absolutely sure that you notice this every time you write such a loop (in which case it can easily be handled separately), or better, a way that gets rid of this special case.", "id": "darjibn"}, {"comment": "And yet by trying to avoid a potential bug all you did was introduce another bug with that awful `size()` thing, so it's just shifting things around.  And this new bug was so insidious that it went undetected for years, apparently.  Do you think it would go undetected if you accidentally wrote an infinite loop?\n\nThere are other ways you could potentially handle it as well.  If what you're actually doing is working with pairs of items (e.g. i and i+1) then how about starting at i=1 and working instead with i-1 and i.\n", "id": "darjv80"}, {"comment": "Yes, I'm afraid you're absolutely correct. I introduced a horrendous bug while trying to circumvent the issue we're discussing (talk about defeating the purpose, am I right?). But now I've fixed the bug. And I maintain that the way I propose is still the better way in the context of competitive programming.\n\nBut, alas, I think we're arguing over two different solutions to the same problem, but under different premises. I agree with everything you've said so far in basically any context I can think of outside of competitive programming. But for competitive programming, I'm not convinced your way is better.", "id": "darler1"}, {"comment": "But it *is* a special case, all throughout C++ this is true.", "id": "darq7ta"}, {"comment": "I'd use an iterator and `std::previous`. Can easily wrap that up to check for empty before giving back an iterator (else return end()). But alas I understand this might not be the best solution in save the microseconds competitions.", "id": "darqce9"}, {"comment": "Couldn't you write:\n\n    for (size_t i = 0; i + 1 < v.size(); i++) {\n\ninstead to avoid this problem?", "id": "darme26"}, {"comment": "Yes. But the point is that you would first have to notice that there is the possibility of underflow happening. If you already know that, it's easy to circumvent the issue by, say, doing what you suggested, or dealing with the empty list as a special case, as /u/Rhomboid suggested. But even in this seemingly obvious piece of code, this is something that's easy to miss. And then, the underflow could also manifest itself in more obscure ways. An even better solution is if thinking about this was completely unnecessary, and there was no chance of underflow.\n\nThe approach I take in the blog post is to always use size(x), which casts to a signed int, instead of x.size(). I believe this approach satisfies what I request above. But since this is the approach I currently use, I would love to be proven wrong or shown a better way.", "id": "darms6p"}, {"comment": "What happens if you need to index something larger than can be stored in a signed 32-bit integer? Tada, now you have another bug. Don't cast to a signed int if you don't need a signed int.", "id": "darnud7"}, {"comment": "As I've mentioned before, in the context of competitive programming, you won't ever be working with arrays even near that size.\n\nBut even outside of competitive programming, I don't really think your point makes much sense. You're only able to access an index of twice the size. And after that, tada, you have exactly the same problem as before.", "id": "daro3se"}, {"comment": "Because code written in competitive programming contests don't need to be maintained, so people take all sorts of short cuts that reduce readability and does not comply with the standard", "id": "darpl4x"}, {"comment": "For practical purposes, you're probably right. In programming contests, however, the circumstances are completely different. We trade in common coding practices for the ability to code quickly and without bugs (although I probably haven't done a good job of justifying the latter).\n\nIt was my mistake to not make the distinction between real life code and competitive programming code more clear, but please don't confuse the two.", "id": "dargxby"}, {"comment": "I definitely understand the difference between real code and time-pressured code; but you said that your skiplist came out of a library which you were allowed to write and then bring with you into the competition, so \"it was a programming competition\" does not excuse that abomination.", "id": "darhn0a"}, {"comment": "Ah, I see what you mean. The thing is, you're only allowed to bring (up to) 25 pages of *printed* material. So this would include any code that you want to bring, formulas, theorems, etc. So any code that we wrote, we'd try to make it as compact and short as we could (within reason), so that more algorithms would fit in our material, and so that it would take less time to type into the computer. (Whether or not only allowing printed material is a good idea is a different question.)", "id": "dari6i3"}], [{"comment": "Oh fuck me!\n\nThis is trivial stuff, people, you can only make these mistakes when you're very inexperienced. Alternatively, you should know this is trivial and be sufficiently ashamed **not** to call it \"favourite\".\n\nAnd then, [the fix](https://github.com/SuprDewd/CompetitiveProgramming/commit/a72e4ec132d595beb7614c11e41bebf76e12f937) is incorrect. The correct things to do are one of\n\n* make the object noncopyable\n\n* pass it to size() with a **const** ref\n\n* implement copying\n\nOP, I see you're following... I am old and ragged. I've done this more times than I care to remember (on the plus side, it was sufficiently long ago that I don't remember specific occasions anymore :-)), and have seen it even more.\n\n\"In C++, OOP means **O**bject **O**wnership **P**rotocols\".", "id": "darj0af"}, {"comment": "Yes, of course this is trivial stuff! Who hasn't written something like\n\n    for (i = 0; i < strlen(s); ++i) {\n    }\n\nonce or twice in their career and later realized how stupid it was... I was very familiar with this example well before I started competitive programming (which is why I so quickly realized how stupid this bug was, when I discovered it). There is nothing new here, that's not the point.\n\nBut realize that saying \"this is obvious\" is so easy after you've been told what the issue is. It's not that I didn't know the difference between pass-by-reference and pass-by-value. Heck, I'm positive that I used pass-by-reference in my code all the time, even with this bug still in my template. (And yes, I'll try to find an example from my submission history.)\n\nThe reason this is my favorite bug is because of how long it stuck with me, how oblivious to it I was, while at the same time having knowledge of why something like this would be very stupid. You see, the template code is something I wrote once (probably in a hurry and tired one evening), and that was that. I never thought about the template code. It's just there, it's trivial code, and obviously it just does its job. Correctly. When writing a solution, I was always focusing on the logic of the solution. And that's why it managed to get past me for so long.\n\nI think it's hilarious that I had this handicap for the first two years of my programming contest endeavours. I've told this story to a few of my friends (which I'll admit are also competitive programmers), and they enjoyed it. I thought maybe the average programmer would also enjoy it. If not, I'm sorry for wasting your 15 minutes.\n\nAnd finally, regarding the \"correct\" way to fix this, I actually went with the second way you proposed. The commit I linked to was my friend's minimal fix, but [here](https://github.com/SuprDewd/CompetitiveProgramming/commit/8f841312c3f4c595f7ecea6e132b568d5de42939) is how I fixed it just a couple of days later.\n\nEdit: [Here](http://codeforces.com/contest/166/submission/1392564) is a good example from just a few months after the size bug was introduced, showing that I did have intuition for when to pass-by-reference.", "id": "darkjva"}, {"comment": "You should not be allowed near a compiler.", "id": "darocg0"}, {"comment": "I'm a c programmer with no experience in C++ and I don't understand why the fix is wrong, care to explain? I get only the overloading copy(), which would make the code not crash but still terribly slow", "id": "daro22w"}, {"comment": ">Stop enjoying things!", "id": "darnnq8"}], [{"comment": "This comment thread makes me very happy I don't have to write C++", "id": "darltex"}, {"comment": "You've never *really* fucked up until you've fucked up in C++.", "id": "darmgr5"}, {"comment": "Hey, I'm glad I at least made someone happy!", "id": "darm3ro"}], [{"comment": "TL;DR: Author loves passing shallow copies of objects by value and corrupting data.", "id": "daroy64"}], [{"comment": "Now that I'm using C++14 I've resolved to basically [never have `new` or `delete`](http://scrupulousabstractions.tumblr.com/post/37576903218/cpp11style-no-new-delete) in my code. I developed a pretty careful attitude to memory management using C++03, but I sleep better knowing bugs like this are impossible using smart pointers and modern C++.", "id": "daro5ff"}], [{"comment": "*cough*Rust*cough*", "id": "darovhf"}], [{"comment": "     #define FIND_UPDATE(cmp, target) \\\n        int pos[MAX_LEVEL + 2]; \\\n        memset(pos, 0, sizeof(pos)); \\\n        node *x = head; \\\n        node *update[MAX_LEVEL + 1]; \\\n        memset(update, 0, MAX_LEVEL + 1); \\\n        for(int i = MAX_LEVEL; i >= 0; i--) { \\\n            pos[i] = pos[i + 1]; \\\n            while(x->next[i] != NULL && cmp < target) { pos[i] += x->lens[i]; x = x->next[i]; } \\\n            update[i] = x; \\\n        } x = x->next[0];\n\nwhy isn't this a function?", "id": "dargze9"}, {"comment": "I mentioned in another comment that we were only allowed to bring 25 pages of printed material to the contest, so we had to make any code that we wanted to bring with us pretty compact. This allowed us to bring more algorithms, and also meant we had to type less into the computer.\n\nSo with the piece of code you mention, we probably saw some repeated code and decided to factor it out, but noticed that making it a macro rather than a function would be simpler and save more typing.", "id": "darifp5"}, {"comment": "How exactly is this simpler than a function?", "id": "darnvvp"}], [{"comment": "[deleted]", "id": "darild5"}, {"comment": "I'm not sure if you're being sarcastic, but if not, I think you misunderstood what was happening. The skip list's size function was implemented in O(1).", "id": "darkua3"}, {"comment": "i probably did, sorry", "id": "darovgu"}], [{"comment": "I find a good rule of thumb is that if you're implementing a class that needs a destructor, but you don't think you'll need a copy constructor or assignment operator for its intended use, you should make \"private\" dummy implementations of them so you catch yourself if you ever end up needing them.", "id": "darmymz"}, {"comment": "Or just = delete them", "id": "darq7m2"}], [{"comment": "I hit the word swag and stopped reading.", "id": "dargn5q"}, {"comment": "Nice to know you're so arrogant that you will stop reading because someone else communicates differently.", "id": "darkqec"}, {"comment": "Yes, this sounded immature. Fixed.", "id": "dargrt8"}, {"comment": "Fuck that, be yourself", "id": "darnlvn"}]]], "5fq5fi": ["The Not-So-Passionate Programmer: finding a job when you're just a normal person", "2016-11-30 18:23:28", 12, "https://codewithoutrules.com/2016/11/30/not-a-passionate-programmer/", [[27, "Maybe it's a culture difference, but in the countries where I've worked \"passionate\" doesn't mean \"Willing to work 100 hours a week\" or \"Puts his life on the line for the product\". Where I've lived and worked, \"passionate\" just means \"Isn't a yes man, and actually cares about doing good work\". Not about pushing it out the gate, or about working overtime, not passionate about side projects or refactoring at home. Just simply saying \"Yes, that way would be easier, but it'll result in bad code. I don't want to make bad code. I want to take this route, which might add a few days to the ticket but will have a better outcome in the long term\".\n\nThat's what passion in programming is to me. Caring about what you do, instead of just being a yes-man who goes with the flow"], [2, "It's probably easier to find a job if you're not passionate about programming."], [2, "I really don't like that, because I enjoy building personal projects and improving my craft, that I'm seen as not normal. It's pretty shitty to put me (and all others) in some other category because we enjoy what we do."], [-1, "Where can I find a job as a non-passionate surgeon? I just want to operate from 9-5, not my concern whether patients live"]], [[{"comment": "Maybe it's a culture difference, but in the countries where I've worked \"passionate\" doesn't mean \"Willing to work 100 hours a week\" or \"Puts his life on the line for the product\". Where I've lived and worked, \"passionate\" just means \"Isn't a yes man, and actually cares about doing good work\". Not about pushing it out the gate, or about working overtime, not passionate about side projects or refactoring at home. Just simply saying \"Yes, that way would be easier, but it'll result in bad code. I don't want to make bad code. I want to take this route, which might add a few days to the ticket but will have a better outcome in the long term\".\n\nThat's what passion in programming is to me. Caring about what you do, instead of just being a yes-man who goes with the flow", "id": "dam60gq"}, {"comment": "[deleted]", "id": "damiqds"}, {"comment": "I hate to break it to you, but people tend to work in order to get paid. We're either lucky enough to enjoy our field while earning good money or we tolerate unpleasantness because we need to eat and feed the kids too. A large number of software professionals are in the latter category.", "id": "damvy6j"}, {"comment": "[deleted]", "id": "dank6a2"}, {"comment": "> Why spend 4 to 8 years getting an education in a field you don't want so you can work 30 to 60 years in a job you hate? Why shit on people that do love this craft?\n\nThe alternatives are worse ? I love my job, but I can imagine than between being a cashier at Walmart, a white collar in a suit or a programmer, the latter one is better ?\n", "id": "danl7s0"}, {"comment": "I work for a tiny operation my sub project has 5 developers Java+angular. If there is a week I am not working 60 hours a week it's the luckiest damn week of the year. It just starts out as \"Well we have this deadline and we need you to work over for no pay\" and this continues more and more as others just keep pilling it on as you keep say well it's gonna be better soon. ", "id": "dan3eul"}, {"comment": "I bet thats illegal.", "id": "daneqfw"}, {"comment": "I would love to know if this is.. I have a similar issue going on at work for me right now but as far as I can tell I'm salaried so there's nothing to be done.", "id": "danl36i"}, {"comment": "perhaps you should start a journal", "id": "daneqf7"}, {"comment": "Time to find a new job. I wrote a thing which might be helpful: https://codewithoutrules.com/saneworkweek/", "id": "danpbxx"}, {"comment": "What would happen if you decided to have 40 hours week? Would they fire you?", "id": "daoq8gm"}], [{"comment": "It's probably easier to find a job if you're not passionate about programming.", "id": "dam6p63"}], [{"comment": "I really don't like that, because I enjoy building personal projects and improving my craft, that I'm seen as not normal. It's pretty shitty to put me (and all others) in some other category because we enjoy what we do.", "id": "dankg65"}, {"comment": "My point wasn't that liking what you do is abnormal. But some people feel like they're at a disadvantage if they don't spend all their spare time coding. So \"normal\" in this context is more of a self-deprecating thought where someone like you seen as superior.", "id": "danpfs7"}], [{"comment": "Where can I find a job as a non-passionate surgeon? I just want to operate from 9-5, not my concern whether patients live", "id": "danire8"}, {"comment": "> Where can I find a job as a non-passionate surgeon? I just want to operate from 9-5, not my concern whether patients live\n\nAs a non-ER surgeon. Most surgeries are scheduled at reasonable hours. If you don't want to worry about patient mortality, go into cosmetic surgery.\n", "id": "dannki3"}, {"comment": "passionate != conscious professional", "id": "daoqa73"}]]], "5g26tj": ["[JavaScript] SpeechSynthesisUtterance", "2016-12-02 11:11:56", 0, "https://developer.mozilla.org/ru/docs/Web/API/SpeechSynthesisUtterance", [[1, "The [speech synthesis](http://mdn.github.io/web-speech-api/speak-easy-synthesis/) thing is nice!\n\nUnfortunately it will be abused by the advertising industry since\n\n> speech synthesis needs no permissions to work on Desktop Firefox or Firefox OS"]], [[{"comment": "The [speech synthesis](http://mdn.github.io/web-speech-api/speak-easy-synthesis/) thing is nice!\n\nUnfortunately it will be abused by the advertising industry since\n\n> speech synthesis needs no permissions to work on Desktop Firefox or Firefox OS", "id": "daoxxiw"}]]], "5g41qg": ["Go's Real-time GC in Theory and Practice", "2016-12-02 19:09:37", 0, "https://blog.pusher.com/golangs-real-time-gc-in-theory-and-practice/?utm_source=reddit&utm_campaign=blog&utm_medium=social&utm_content=go-sub", [[3, "It is a bit silly to provide numbers for Java without naming the GC in use and its settings."]], [[{"comment": "It is a bit silly to provide numbers for Java without naming the GC in use and its settings.", "id": "dapbam6"}, {"comment": "Yeah, I felt the article was a bit too light on detail as well. The author is hanging out in the /r/golang thread; you could ask him there.", "id": "dapbi7a"}, {"comment": "The article links to the repo containing the exact Makefile the Java version is build/run with: https://gitlab.com/gasche/gc-latency-experiment/blob/master/Makefile", "id": "dapvm3c"}]]], "5gbekw": ["R Course Finder now includes 140 R programming courses", "2016-12-03 23:01:35", 24, "http://r-exercises.com/2016/12/03/r-course-finder-updated-again/", [[1, "Just a random thought I had when I took an R based course: wouldn't it make sense for R to incorporate declarative statements for selecting and manipulating data?  A lot of the tasks you perform totally make sense in an imperative paradigm, but sometimes you're doing tasks that are more akin to CRUD functions in SQL, and the imperative paradigm is much more clunky for those purposes."]], [[{"comment": "Just a random thought I had when I took an R based course: wouldn't it make sense for R to incorporate declarative statements for selecting and manipulating data?  A lot of the tasks you perform totally make sense in an imperative paradigm, but sometimes you're doing tasks that are more akin to CRUD functions in SQL, and the imperative paradigm is much more clunky for those purposes.", "id": "daqxwgx"}, {"comment": "the answer to your question is the library/package dplyr \n\nhttps://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf\n\nIt have SQL-like syntax like C# LINQ.\n\nYou should check out the tidyverse packages (packages that made for the tidyverse).\n\n~~Henry Wickham.~~\nedit/update:\n\nAlso look up Hadley Wickham. He's the most influential programmer in R as of now and most of his packages are often use including dplyr.", "id": "dar1f8d"}, {"comment": "I might be missing something here but this looks like standard R programming with functions.  Can you simply use a query string, \"SELECT * FROM db WHERE x='y' AND...\"?", "id": "dar1i74"}, {"comment": "edit/update:\n\nOh, I think I understand, you want to call SQL from as a string using R?\n\nI'm sure there's a package for that. SAS and other language let you do what you've stated via proc/packages/libraries.\n\nignore:\n\n~~You can't do that because that's like asking to change English to Chinese.~~\n\n~~At least IIRC, you can't change a programming language paradigm after you create the programming language. You can create a DSL (Domain Specific Language), and hope for the best.~~\n\n\n~~You can try to tack on the paradigm later such as OOP like C++ and PHP. Early PHP have no OOP and they tack on class and such.~~\n\n~~But it is still within the syntax of PHP. What you propose, if I'm reading correctly, is changing R language syntax, which within my knowledge is not possible.~~\n\n~~PHP let's you do OOP where as in contrast Ruby IS OOP. so the difference is pretty huge.~~", "id": "dar1qri"}, {"comment": "I was thinking more along the lines of a translation interface implemented with a either a language construct or a library that could implement declarative language imperatively.  In other words, a construct or library that could appear like a function on the R front end, but which would only accept a single statement as a parameter.\n\nE.g. runStatement(String SQL).  The backend would translate the statement into imperative logic and perform the functions that we currently call manually. It could return results, update tables in a CSV, and perform delete and create functions too.\n\nAs far as I can tell, this should be implementable, albeit it would be a huge undertaking.", "id": "dar1xh2"}, {"comment": "Why yes, yes you can :)\n\nThere's the [RODBC](http://rprogramming.net/connect-to-database-in-r/) package which can connect to various databases and bring data back into R via the databases' own native SQL. \n\nThen there's the [sqldf](https://www.r-bloggers.com/manipulating-data-frames-using-sqldf-a-brief-overview/) package which allows you to mung data already in R using SQLite-like syntax like so:\n\n    sqldf(\"select * from table where column = 'string'\")\n\nwhich does just what you think it does.\n\n~~On mobile now but will be back to add links.~~ Links added.", "id": "dar4z11"}, {"comment": "That's awesome!  I'm looking forward to the links.  ", "id": "dar5618"}, {"comment": "I'll just warn you from experience, RODBC can involve a lot of manual query manipulation which gets old quickly and can be error-prone. I've spent a pretty stupid amount of time cleaning up commas around my date fields for example while interfacing with a (God forgive me) Access database.", "id": "darb5hy"}, {"comment": "Yep.\n\nPHP and Ruby prefer prepared statement and libraries that fix sql injections and such. \n\nI'm pretty sure rolling your own SQL is asking for SQL injections.\nThe advantage of having a library and package is they can warn you of your syntax mistake. Having a SQL string does not unless you're staring at the RMDB console complaining.", "id": "darknqs"}]]], "5fylla": ["Cleaner Pub-Sub using the Event Aggregator Pattern", "2016-12-01 22:31:49", 3, "http://www.nimaara.com/2016/02/14/cleaner-pub-sub-using-the-event-aggregator-pattern/", [], []], "5fxkf4": ["Software Folklore", "2016-12-01 19:43:01", 0, "http://beza1e1.tuxen.de/lore/index.html", [[1, "I'm laughing my boots off here! :))"]], [[{"comment": "I'm laughing my boots off here! :))", "id": "dant105"}, {"comment": "Haha", "id": "dant849"}, {"comment": "Thanks for sharing, I'll be telling the story of *Mel* for sure.", "id": "dantwhj"}]]], "5g6dh3": ["Bob Martin - \"The Future of Programming\"", "2016-12-03 01:55:48", 1, "https://www.youtube.com/watch?v=ecIWPzGEbFc", [[3, "It looks to me as he is really trying to get the government to react and form such a body, and then hopefully get promoted as a chairman of it or something (as it's his idea that programmers need licences like doctors do). That's all he's talking about lately. He wrote some good books in the past, and held some good presentations, but last couple of years, well, I'm not sure what to think of him... Kent and Fowler also started to degrade a bit. All three of them are forcing their own ideas so hard, and even when presented that they don't work in all the cases these guys won't back down. As if they're trying to go in the history as Teslas of programming or something... Don't get me wrong, read their books, they are great. But just don't feel that you need to follow strictly everything they say."], [1, "Holy shit"]], [[{"comment": "It looks to me as he is really trying to get the government to react and form such a body, and then hopefully get promoted as a chairman of it or something (as it's his idea that programmers need licences like doctors do). That's all he's talking about lately. He wrote some good books in the past, and held some good presentations, but last couple of years, well, I'm not sure what to think of him... Kent and Fowler also started to degrade a bit. All three of them are forcing their own ideas so hard, and even when presented that they don't work in all the cases these guys won't back down. As if they're trying to go in the history as Teslas of programming or something... Don't get me wrong, read their books, they are great. But just don't feel that you need to follow strictly everything they say.", "id": "daqgtxg"}, {"comment": "Never forget that these people are not programmers, they are professional speakers and authors. They are measured on how many conferences they attend and how many books they sell; their theories don't have to actually work and may even be detrimental to their job if too exactly defined.", "id": "daqrdcq"}], [{"comment": "Holy shit", "id": "daqd4ig"}]]], "5g0cg1": ["Code review in remote teams", "2016-12-02 04:04:50", 13, "https://hypothes.is/blog/code-review-in-remote-teams/", [[5, "What do you think about naming this \"Code review in remote teams\"? The current name feels unclear to me because the article seems to focus more on how to code review in general, rather than how to code review in remote teams."]], [[{"comment": "What do you think about naming this \"Code review in remote teams\"? The current name feels unclear to me because the article seems to focus more on how to code review in general, rather than how to code review in remote teams.", "id": "daoq8ee"}, {"comment": "While it has good advice on code reviews in general, I expected it to focus more on code reviews while working remotely.  One challenge, for instance, is timezones.  If a dev on the east coast gets his CR out mid afternoon, the west coast devs have left the office.  The east coast dev can either rely on other east coast devs or wait until the next morning for feedback.  We have an even bigger issue with an office in China, where every code review pass to get feedback and update it is limited to once per day.  \n\nFor remote code reviews I'd:\n\n* be explicit in who needs to approve a code review\n* group reviewers' areas by timezone, if possible\n* temporarily change work hours if necessary (temporary solution, but works in certain circumstances)\n* send out work-in-progress so remote devs have less feedback when it's time to commit\n* after a code review is closed and pushed, recognize it's still subject to feedback and changes in follow-up commits", "id": "dapazzf"}, {"comment": "You have the same problem if the potential reviewers are too busy on their own task until the next morning.", "id": "daqtiea"}]]], "5fq19k": ["Why You Should Take Another Look at C#", "2016-11-30 18:01:52", 1, "https://realm.io/news/goto-mads-torgersen-why-take-another-look-at-c-sharp/", [[4, "\"C# is a widely used language (number four, and one of the three above is not a programming language\u2013I\u2019m not talking about JavaScript, I\u2019m talking about SQL).\u00a0\"\n\n\"It is nice to be one of the three technologies on that list, two of which are programming languages, and\u00a0yay for Python also for being on there.\"\n\nNice burns, but... * grumble *\n"], [4, "Or instead of waiting around for C# to get its shit together, just use any of a number of languages that exist today that already compile to all of these platforms, already have better language constructs, etc.\n\n"], [2, "I hadn't touched C# before taking a class on it this year, and I've been pleasantly surprised so far.\n\nI've been using Linux as my sole daily driver for a couple years now, and like most people my only experience with C# on Linux was people online going \"haha no it's made by Microsoft, silly! I *guess* you could try Mono, though...\"\n\nWell, turns out that Mono works incredibly well, and Monodevelop is a fantastic IDE out of the box. Even if you're not into IDEs, mcs (I think?) works just like any other command line compiler so you can use Emacs and Makefiles if you so choose.\n\nAt this point, I'd have to say C# is now my second favorite language, and my favorite popular language since I'm one of twelve Dlang lovers."], [1, "C# is Java done correctly. Java is still missing a bunch of features from C++ (operator overloading being the big one), and C# has some very nice additions to the language as well."]], [[{"comment": "\"C# is a widely used language (number four, and one of the three above is not a programming language\u2013I\u2019m not talking about JavaScript, I\u2019m talking about SQL).\u00a0\"\n\n\"It is nice to be one of the three technologies on that list, two of which are programming languages, and\u00a0yay for Python also for being on there.\"\n\nNice burns, but... * grumble *\n", "id": "dam7g4t"}], [{"comment": "Or instead of waiting around for C# to get its shit together, just use any of a number of languages that exist today that already compile to all of these platforms, already have better language constructs, etc.\n\n", "id": "damp3sj"}], [{"comment": "I hadn't touched C# before taking a class on it this year, and I've been pleasantly surprised so far.\n\nI've been using Linux as my sole daily driver for a couple years now, and like most people my only experience with C# on Linux was people online going \"haha no it's made by Microsoft, silly! I *guess* you could try Mono, though...\"\n\nWell, turns out that Mono works incredibly well, and Monodevelop is a fantastic IDE out of the box. Even if you're not into IDEs, mcs (I think?) works just like any other command line compiler so you can use Emacs and Makefiles if you so choose.\n\nAt this point, I'd have to say C# is now my second favorite language, and my favorite popular language since I'm one of twelve Dlang lovers.", "id": "dannabr"}], [{"comment": "C# is Java done correctly. Java is still missing a bunch of features from C++ (operator overloading being the big one), and C# has some very nice additions to the language as well.", "id": "dapofew"}]]], "5g2kr3": ["Moving expressions for mathematics and other things", "2016-12-02 13:19:50", 0, "https://docs.google.com/document/d/1lvNqkBI3CzP6dQApgjdKyvx9XLxvoFjf7QQqAS-yGeE/edit?usp=sharing", [], []], "5fsq5q": ["How to be a good programmer", "2016-12-01 01:36:13", 0, "https://medium.com/@cakrawalabuka/how-to-be-a-good-coder-7da3fe9d4607#.mfzmlt9vd", [[3, "#5 write up nonsense on blog for great fame"], [2, "How to be a 'not-good' writer:\n\n> 90% of the time when a software engineer work in a company, they do always work in a team for a specific project / product. It is very rare for them to work in solo. Working in a team can be huge advantage for you and it is also the right opportunity to solve problems with different perspective, add a bunch of LinkedIn connections, and learn something from your team-mate\u2019s past experiences. \n\nWow.\n\n"]], [[{"comment": "#5 write up nonsense on blog for great fame", "id": "dan3uqt"}], [{"comment": "How to be a 'not-good' writer:\n\n> 90% of the time when a software engineer work in a company, they do always work in a team for a specific project / product. It is very rare for them to work in solo. Working in a team can be huge advantage for you and it is also the right opportunity to solve problems with different perspective, add a bunch of LinkedIn connections, and learn something from your team-mate\u2019s past experiences. \n\nWow.\n\n", "id": "damtyie"}, {"comment": "Holy hell I think my eyes just started bleeding. ", "id": "daoq1b3"}]]], "5g8x8k": ["The first release candidate of Redis 4.0 is out", "2016-12-03 12:56:49", 118, "http://www.antirez.com/news/110", [[8, "I love antirez "], [4, "So what's a typical use case for redis? "], [3, "So this seems like a good opportunity to trumpet my ignorance: What is a situation in which I would adopt Redis, in say, my Rails app that works perfectly fine at a few thousand users on Postgres alone?\n\nHaving played with caching before with memcached, I found that the huge problems associated with cache invalidation did not outweigh simply throwing more power at Postgres, which itself is fully capable of building in-memory caches of commonly run queries. I assume there is some threshold at which SQL is doing too much work to be efficient, but I haven't hit it yet."], [-32, "> The first release candidate of Reddit 4.0 is out\n\nwhat now? oh it's Redis, not Reddit."]], [[{"comment": "I love antirez ", "id": "daqwlsy"}], [{"comment": "So what's a typical use case for redis? ", "id": "dar1suz"}, {"comment": "Caching results which take a long time to calculate. Or session state. Or anything else you need quick access to and don't want to introduce global variables etc to store them", "id": "dar21t6"}, {"comment": ">don't want to introduce global variables etc to store them\n\nIn a load balanced environment, you don't have reliable \"global variables\" either", "id": "dar4830"}, {"comment": "Not intentionally trolling question: if I'm already using Postgres as my source of truth, is there a compelling reason to not also use it as my source of cached truth? (e.g. potentially with hstore, or json)", "id": "darbpwo"}, {"comment": "Querying PostGres every single time is slower than querying redis, because redis is in-memory ( + you don't get the overhead of an SQL query).", "id": "darc0v4"}, {"comment": "Yepp, changing every to hitting the cache then the Postgres will add something like 1 microsecond of overhead, but could save much more. Even a simple query takes 13 ms in my experience with postgres.", "id": "dariakz"}, {"comment": "You are not going to cache very simple queries unless they are called in massive numbers.\n\nEdit: You are also not necessarily caching each query result but the result of multiple queries to get a whole ensemble of data (i.e. a single user's complete social profile, a customer's account info, the sales report for 2012...).", "id": "darop6k"}, {"comment": "In short: insane speeds vs. getting the freshest results. It's a compromise. ", "id": "daronxa"}, {"comment": "Using redis as a queue makes threading insanely easier to implement. Also it makes it easy to communicate between languages (bindings are available for pretty much all of them).", "id": "dari8bj"}, {"comment": "Storing queues for async workers", "id": "darb8zs"}, {"comment": "We use it as the main database for our service where the data is small enough to easily fit in memory. Redis is fast, reliable, and stupidly easy to manage.", "id": "darjto6"}, {"comment": "https://redis.io/topics/introduction", "id": "dareqo1"}], [{"comment": "So this seems like a good opportunity to trumpet my ignorance: What is a situation in which I would adopt Redis, in say, my Rails app that works perfectly fine at a few thousand users on Postgres alone?\n\nHaving played with caching before with memcached, I found that the huge problems associated with cache invalidation did not outweigh simply throwing more power at Postgres, which itself is fully capable of building in-memory caches of commonly run queries. I assume there is some threshold at which SQL is doing too much work to be efficient, but I haven't hit it yet.", "id": "darf43b"}, {"comment": "Depends, sounds like you likely won't hit the point it matters. It's best when you could see a noticeable reduction in the hits to your Postgres with a low TTL like 10 seconds.", "id": "darifqd"}, {"comment": "One place I have used Redis in a Postgres-backed app is for temporary state (think email verification tokens) and as a poor man's message queue for async or scheduled processes.", "id": "darjxci"}, {"comment": "When you have more than a few dozen hits *per second*\n\n", "id": "darkwub"}], [{"comment": "> The first release candidate of Reddit 4.0 is out\n\nwhat now? oh it's Redis, not Reddit.", "id": "daqrao1"}]]], "5fxlsm": ["\u2018Member HTML Login Forms?(x-post /r/reactjs)", "2016-12-01 19:49:39", 11, "https://medium.com/@sAbakumoff/member-html-login-forms-78c3ad3ba4e4#.2k3htpvk4", [[7, "This is what happens when you substitute your own specific architectural judgement with someone else's general solution \n\nUse your brain.  Stop trying to outsource architecture to internet blog posts.\n\nYou can use redux while still keeping some state in components.  You don't need to use container components for every application.  Nothing bad happens if you don't dogmatically follow js-hipster-architecture-vLatest."], [2, "Is is me or is the CSRF token missing?"], [0, "I've found that MobX is a much better solution for typical React CRUD apps.  Flux/Redux is great for apps with very high UI complexity, but most projects don't fall into that category, and you end up paying a high cost for the abstraction."]], [[{"comment": "This is what happens when you substitute your own specific architectural judgement with someone else's general solution \n\nUse your brain.  Stop trying to outsource architecture to internet blog posts.\n\nYou can use redux while still keeping some state in components.  You don't need to use container components for every application.  Nothing bad happens if you don't dogmatically follow js-hipster-architecture-vLatest.", "id": "danv8py"}, {"comment": "This is exactly what I tried to convey in the article! Great to see that people share this view :)", "id": "daonun8"}], [{"comment": "Is is me or is the CSRF token missing?", "id": "daox6lj"}, {"comment": "Sorry, I am not sure what you mean..is it Cross-Site Request Forgery? Where is it missing? ", "id": "daoxic0"}, {"comment": "You usually have a dynamically generated token somewhere in your form to prevent people from copying the form and inserting it into their own pages to force user agents to make requests they shouldn't.\nThe react examples don't seem to contain such token.\n\nIf you don't, people can force you to log out of random sites you visited and do other stuff (like call the delete account function)", "id": "daoxkrn"}, {"comment": "I see. Yes, this type of data protection is missing in the react examples, but the matter is the code sends the data to a server manually, by using XmlHttpRequest or a wrapper around it. Perhaps it has some protection method. I recall that ASP.NET login control used to generate the hidden fields for a form that contained a server-side generated value which then was validated. I didn't mention it in the article since it's more focused on UI.", "id": "dap0w5f"}], [{"comment": "I've found that MobX is a much better solution for typical React CRUD apps.  Flux/Redux is great for apps with very high UI complexity, but most projects don't fall into that category, and you end up paying a high cost for the abstraction.", "id": "dao5ffc"}, {"comment": "Thanks for sending the comment! I didn't know about MobX, will definitely take a  look.\n\n", "id": "daooh1x"}]]], "5fizdf": ["Browsix: Unix in the browser tab", "2016-11-29 17:43:07", 111, "https://browsix.org/", [[45, "This is the beginning of the story told in the [Birth & Death of JavaScript talk](https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript) by Gary Bernhardt."], [16, "OK, I'll try the Terminal in the browser. Let's see if it works correctly.\n\n    $ curl\n    usage:\n     curl URL\n    Error while executing undefined: Uncaught TypeError: Cannot read property 'split' of undefined\n\nwat"], [12, "Just because you can, doesn't mean you should."], [10, "Everything that is wrong with the internet summarized in one program, the internet isn't meant to deliver applications, but rather information!"], [2, "Interesting idea. A bit too raw to be useful... no \"cd\" and no \"pwd\" hmmm... also it feels a bit sluggish. May be my computer but it's so much faster in my local KDE konsole..."], [2, "https://i.imgur.com/LPsvt4A.png lul\n\n(Repeatedly pressing backspace)"], [2, "can somebody explain to me why this is so different from any other emulator in javascript?"], [1, "This is all Fabrice Bellard's fault for emulating the kernel in JS. \nhttp://bellard.org/jslinux/"]], [[{"comment": "This is the beginning of the story told in the [Birth & Death of JavaScript talk](https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript) by Gary Bernhardt.", "id": "dakrgck"}, {"comment": "The eerily reminiscent bit was when you read down to the init section.\n\nBrowsix uses systemd *in your browser*.", "id": "dal6lr1"}, {"comment": "It is actually not the full systemd, it is a small init written in Go: https://github.com/plasma-umass/systemgo .  Systemd unit files are a good idea compared to shell scripts, so this lets you use them.", "id": "dalcceh"}, {"comment": "why are they a good idea compared to shell scripts?", "id": "dalwtoy"}, {"comment": "They define desired state, and let init handle the logic, rather than in arbitrary scripts.", "id": "dalykdy"}, {"comment": "And you can just have it run a shell script if you're that sort of person.", "id": "damytd6"}], [{"comment": "OK, I'll try the Terminal in the browser. Let's see if it works correctly.\n\n    $ curl\n    usage:\n     curl URL\n    Error while executing undefined: Uncaught TypeError: Cannot read property 'split' of undefined\n\nwat", "id": "dakt4h5"}, {"comment": "    $ less README\n    /usr/bin/less: command not found\n    $ cat README\n    Welcome to Browsix!\n\n    For more info, please check out:\n    https://github.com/plasma-umass/browsix\n\n    Known issues with this shell:\n    - 'cd' is not implemented.\n    - backspacing past '$' produces \"interesting\" results", "id": "dakzcet"}, {"comment": "Thanks!  Most of the utilities are written in TypeScript in an async manner, and async programming is hard and terrible. I fixed that issue here: https://github.com/plasma-umass/browsix/commit/be95e39a5a28a1d1ce7925e51491d6bf3e894d4f\n\nBut, curl for now only connects to local (in-Browsix) socket servers, the issue is tracked here: https://github.com/plasma-umass/browsix/issues/33", "id": "dalauwi"}, {"comment": "Yeah. Guess they have to work more on that.\n\nLet's check back in a year. :)", "id": "dal29q8"}, {"comment": "Better to try the LaTeX demo (make sure to use the bleeding-edge Chrome feature, which makes things considerably faster). The terminal will be replaced with a proper shell soon (dash).\n\nhttps://browsix.org/latex-demo/", "id": "dalbw2g"}], [{"comment": "Just because you can, doesn't mean you should.", "id": "dal983i"}], [{"comment": "Everything that is wrong with the internet summarized in one program, the internet isn't meant to deliver applications, but rather information!", "id": "dakqbop"}, {"comment": "True, but phone lines weren't meant to deliver IP either, and I'm glad people made it happen anyway.", "id": "daks1mq"}, {"comment": "And telegraph lines weren't even meant to deliver audio!", "id": "dalfsiv"}, {"comment": "[mind blown!](https://www.youtube.com/watch?v=LLpIMRowndg)", "id": "daktz8i"}, {"comment": "Don't tell me that you are honestly glad for web apps?", "id": "dakxkeh"}, {"comment": "Do you really want a world without Google Maps?", "id": "dal0dcs"}, {"comment": "ok, fair enough, point conceded :)", "id": "dal14kv"}, {"comment": "The way I see it; if you go back in time to the early decade of the web where PC usage was far more desktop oriented we had lots of desktop applications. Many of them were shit. Well, still true today.\n\nSure there are some great ones. But most are just bad, or do the job but have bad aspects. Why? Because building a decent application is hard. Web, desktop, or otherwise. Not trivial.\n\nThat's why only a small number of web applications are amazing. Like Google Maps. That's why most are bad.", "id": "dal1nsu"}, {"comment": "Nothing stopping it from being a normal app.", "id": "dal48c1"}, {"comment": "You'd have to download and install it, and either update by hand or have yet-another-updater setup.", "id": "dal4p5z"}, {"comment": "Solved by package managers decades ago.", "id": "dal5na0"}, {"comment": "Which is still more work than just visiting an url.", "id": "dal6blt"}, {"comment": "Doesn't have to be\n\nDisclaimer: I hate package managers", "id": "dalurf3"}, {"comment": "To install, then it's less work, works faster and works offline.", "id": "dal6nkq"}, {"comment": "but if people really preferred to use package managers and desktop based applications for everything then web apps would be a tiny niche.", "id": "dal85ta"}, {"comment": "Telnet literally dates back to the 1960's so I'd argue that the Internet was very much meant to deliver interactive applications.  https://tools.ietf.org/html/rfc15\n\nYou can make the argument about the WWW and HTML, but not about the Internet as a whole.", "id": "dal34po"}, {"comment": "Yes, you are 100% right, in fact the internet was as you suggest, university machine sharing etc, but I was indeed referring to www and the like", "id": "dal38ix"}, {"comment": "It's 2016, dude.  We've been downloading applications for 20+ years now.  Obviously you disapprove of this particular project, but I'm not sure how your disapproval connects with what you wrote above.\n", "id": "dalsw4r"}, {"comment": "You don't provide any explanation or reason for your statement, so I think there is a lot more with your statement in itself. That in itself does not mean that nothing is wrong with the internet as-is, mind you, but neither is your statement there above.", "id": "dal2aux"}, {"comment": "The net is not the web.", "id": "dalqqgn"}], [{"comment": "Interesting idea. A bit too raw to be useful... no \"cd\" and no \"pwd\" hmmm... also it feels a bit sluggish. May be my computer but it's so much faster in my local KDE konsole...", "id": "dal291a"}, {"comment": "Are you being facetious?  I mean, of course Konsole will be/feel faster.  It's not running inside a browser.", "id": "dalsuj8"}, {"comment": "Why would we want to run the same \"applications\" in the browser when they look and work the same but are much slower.", "id": "daluva6"}, {"comment": "I don't know... I didn't say it was a good or bad idea.", "id": "dam8khc"}, {"comment": "[deleted]", "id": "damj1iq"}, {"comment": "Are you being facetious? If so, then, oh, hehe.\n\n\nBut in case you aren't, sure, Javascript has come a long way, but it's still slower than a native app.", "id": "dammprl"}, {"comment": "[deleted]", "id": "damnu3z"}, {"comment": "I thought QBasic was the cool kid in town.", "id": "dampcbo"}], [{"comment": "https://i.imgur.com/LPsvt4A.png lul\n\n(Repeatedly pressing backspace)", "id": "dalvg3d"}], [{"comment": "can somebody explain to me why this is so different from any other emulator in javascript?", "id": "dam22zm"}, {"comment": "Sure, let me take a stab. Browsix implements an abstraction - essentially Unix system calls - that lets conventional applications (compiled to JS) run inside the browser. Browsix lets these apps interop via the normal process / IPC abstractions that Unix provides (e.g., sockets & pipes). See, for example, the LaTeX editor / renderer. Ordinary JS code can also use Browsix and easily glue apps together.", "id": "damdlgp"}], [{"comment": "This is all Fabrice Bellard's fault for emulating the kernel in JS. \nhttp://bellard.org/jslinux/", "id": "dalvtyq"}]]], "5fpghn": ["Zero-cost abstractions", "2016-11-30 15:58:33", 183, "https://ruudvanasseldonk.com/2016/11/30/zero-cost-abstractions", [[57, "Damn, that's pretty impressive. Congrats to the Rust/LLVM teams for making magic like this possible."], [39, "Is this another case where functional code is more complicated than the imperative code it replaces?\n\n    for i in 12..buffer.len() {\n        let prediction = coefficients.iter()\n                                     .zip(&buffer[i - 12..i])\n                                     .map(|(&c, &s)| c * s as i64)\n                                     .sum::<i64>() >> qlp_shift;\n        let delta = buffer[i];\n        buffer[i] = prediction as i32 + delta;\n    }\n\nvs.\n\n    for (int i = 0; i < n - 12; i++) {\n      int64 sum = 0;\n      for (int j = 0; j < 12; j++) {\n        sum += coefficients[j] * buffer[i + j];\n      }\n      buffer[i + 12] += sum >> qlp_shift;\n    }"], [9, "I think it is actually pretty amazing that the compiler can unroll this loop. So basically the compiler extracts the information from `zip` and knows that the loop has a fixed size?\n\nIs MIR or LLVM responsible for this optimization?\n"], [10, "Zero **runtime** cost. I\u2019m sure there\u2019s a non-zero compile-time cost (which is completely acceptable, ofc)."], [5, "> Fortunately these structures are not allocated on the heap, as they would likely be in a language like Java or Python.\n\nAt least in principle, escape analysis would be used to allocate them on the stack. In HotSpot, simple iterators are commonly allocated on the stack (and then optimized further). When you have a JIT (which means you can afford one), general abstractions become zero-cost based on their use-site. The upside is that you get a few, general and powerful abstractions that are then completely optimized based on how they're used. The downside is that it is not guaranteed, and a JIT requires more RAM and power (and in practice usually a warmup period, although that can be solved)."], [0, "If you enjoyed that article, you might also enjoy [Rich Hickey's](http://blog.cognitect.com/blog/2014/8/6/transducers-are-coming) blog post on transducers.  "], [2, "LLVM at work..."]], [[{"comment": "Damn, that's pretty impressive. Congrats to the Rust/LLVM teams for making magic like this possible.", "id": "dam4lfd"}, {"comment": "It's indeed cool - I believe that Scala for instance has difficulty making such idioms fast.  It does take a while to get used to of course.", "id": "dam7lct"}, {"comment": "Kotlin can sometimes inline functional method calls on collections, but it only eliminated the temporary closure object, temporary collections and iterables are still a thing.", "id": "danlr4w"}, {"comment": "[deleted]", "id": "damhxqu"}, {"comment": "Rust is getting futures soon I think. Other than that there is no reason the Rust compiler couldn't do the same optimizations, there's nothing in the language inherently preventing them.", "id": "damiw2z"}, {"comment": "Yes, the futures package is being heavily worked on, as well as the \"tokio\" abstraction on top of it. (tokio is futures + an event loop)\n\nI haven't watched the OPs talk yet, so I can't say for sure, but I'm pretty sure that it's a fundamentally different abstraction. Or at least, normally coroutines are, in my understanding.", "id": "damj5jt"}, {"comment": "> I think we have it even better with C++, ever heard of: \"negative overhead abstractions\"?\n> \n\nUmm... listen to his talk from this year.  He implemented most of it in LLVM as compiler intrinsics with some syntactic sugar so that C++ usage is pretty.  He gives an example of them in C too.  Nothing would prevent Rust from taking advantage of it (assuming it gets mainlined).", "id": "damldy2"}, {"comment": "I think I've been over this video before in /r/rust and since I can't reply to the original deleted post I'm going to repeat my original reply to a discussion about that video here for others.\n\n> Looking at this video again and comparing it to the design of Rust's futures they seem to be describing the same zero-allocation state machine style functionality. The C++ proposal has that os_async_context that he extends to define his state machine and that seems to match the rust Future almost exactly. He makes his AwaiterBase and awaiter to define how to proceed through the state machine for this task just like the example Join does in the blog post.\n\n> It seems the only real difference between the two approaches is that the C++ one is completion based while the Rust one is readiness based. The completion design is certainly more flexible and with it built in to the compiler you could probably avoid the allocations the blog mentions for chaining operations. However, you cannot avoid the extra overhead of having to have a unique buffer for each in flight task and he doesn't even talk about that, presumably because he is building this on Windows so you have that to do async IO there anyway. On a Linux system using epoll you should be able to get much better performance with something like Rust's Future than with the proposed C++ coroutine model because the Rust model will let you reuse buffers at the application level when reading from a socket. The readiness model also makes it easier to handle cancellation and backpressure, as pointed out in the blog.\n\n> Aside from that one (major) difference they appear to have the same benefits over the traditional callback model of reducing allocations, not requiring virtual method calls, and allowing the compiler to inline the entire operation for even more of a performance win (if that would be useful in a particular situation). A future async/await implemention in Rust that desugars to this Future design would remove the one advantage the C++ version has: usability.\n\n> This is a long running debate in the computing world but personally I would rather have the readiness model than the completion model. Not only does it offer more optimization opportunities it is what Linux is already using. You can emulate the readiness model using completions on Windows for a small overhead but emulating completion using readiness has a much higher cost. This means the C++ proposal will result in the most efficient possible code on Windows and (much?) slower code on Linux. The Rust Future design will offer the most efficient possible code on Linux and somewhat slower code on Windows with a fixed overhead cost. As most high performance networking happens on Linux it makes sense to optimize for that environment. Since async disk IO basically doesn't exist on Linux it doesn't make sense to try to optimize for that scenario by using a completion based design, especially not when it would come at the cost of reducing performance of socket IO. Amusingly, I actually just learned that the libaio (POSIX AIO api, what the video is showing for doing his task on Linux) library is actually just implemented under the covers as a thread pool doing regular disk IO.\n\nFor reference the blog post mentioned is https://aturon.github.io/blog/2016/08/11/futures/ and the video is https://youtu.be/_fu0gx-xseY\n", "id": "dan7m37"}, {"comment": "Pretty sure those two are related but not contradictory things.  While Rust is fairly neat in its approach, it's still suffering from callback hell.  AFAIK coroutines work well with that because the callbacks are transformed into linear code (i.e. instead of the and_then it's simply a co_yield) but the asynchronous parts simply transfer control back to the polling mechanism underneath.", "id": "dansezj"}, {"comment": "> A future async/await implemention in Rust that desugars to this Future design would remove the one advantage the C++ version has: usability.\n\nis exactly addressing callback hell.", "id": "danv0zq"}], [{"comment": "Is this another case where functional code is more complicated than the imperative code it replaces?\n\n    for i in 12..buffer.len() {\n        let prediction = coefficients.iter()\n                                     .zip(&buffer[i - 12..i])\n                                     .map(|(&c, &s)| c * s as i64)\n                                     .sum::<i64>() >> qlp_shift;\n        let delta = buffer[i];\n        buffer[i] = prediction as i32 + delta;\n    }\n\nvs.\n\n    for (int i = 0; i < n - 12; i++) {\n      int64 sum = 0;\n      for (int j = 0; j < 12; j++) {\n        sum += coefficients[j] * buffer[i + j];\n      }\n      buffer[i + 12] += sum >> qlp_shift;\n    }", "id": "dam0j8d"}, {"comment": "Whether it is more complicated depends on the perspective; whether you were 'raised' with imperative programming (I suspect this is the case for most) or functional programming. My main worry was whether the functional one would be more inefficient because of slices, iterators or whatevs, but that is not the case. While I found both code samples 'non-complicated', it is clear that in terms of nice syntax, Rust gives emphasis on the imperative style - I'm referring to the need for \"extra\" syntax, `&` and `|`.", "id": "dam3ywv"}, {"comment": "> Whether it is more complicated depends on the perspective; whether you were 'raised' with imperative programming (I suspect this is the case for most) or functional programming.\n\nIt sounds reasonable, but people are repeating it like it's proven. Are there any people actually being raised with functional instead of imperative, to prove this claim?\n\nSome people disagree that it's only a matter of getting used to it, You can say that imperative approach is more intuitive, because you're following state, and functional is more like mathematical definitions, more abstract. I personally honestly don't know.", "id": "dam8yrk"}, {"comment": "I wasn't raised with functional, but I spent a lot of time with it and do feel that functional usually makes more sense to me.\n\nThe whole zip/map/sum chain adequately reflects the _intent_ of the code. I can understand, at a high level, what it's trying to do. Whereas with imperative code there's a lot of mental state to keep track of when figuring out what's going on. In this case, not so much, but longer iterator chains are easier to read for me than the equivalent imperative code.\n\nThe only time I'm confused by iterator code is when the closures start modifying external state (captured upvars). I think this is considered bad style in Rust and other languages, though, and if you need to do that a mix of a for loop and iterators makes more sense.", "id": "dambzbd"}, {"comment": "> In this case, not so much, but longer iterator chains are easier to read for me than the equivalent imperative code.\n\nCan you give an example? I'd like to try my hand at rewriting more stuff into imperative.", "id": "damd5jr"}, {"comment": "Usually stuff involving multiple `filter()`/`flat_map()` calls, especially when such iterators are `zip()`d together.\n\nhttps://www.reddit.com/r/rust/comments/5ez38g/rusts_iterators_are_inefficient_and_heres_what_we/dah17fr/ gives a taste of this", "id": "damh8u7"}, {"comment": "    elements\n      .withIndex\n      .map(f)\n      .filter(g)\n      .flatMap(h)\n      .foreach(i)", "id": "damis9c"}, {"comment": "`withIndex` and `foreach` don't exist in Rust, (`withIndex` would be `enumerate`, `foreach` doesn't exist in the standard library but exists in the `itertools` crate) and `flatMap` is `flat_map`. And you'd need to know what `f`, `g`, `h`, and `i` are.", "id": "damjizi"}, {"comment": "I used to believe that I could not adequately understand functional code vs imperative. It took quite a bit of practice...  but, now, I actually predominantly prefer writing my code in a functional style. There are contexts of use whether one style tends to dominate the other, of course, but in general - I now lean towards functional. ", "id": "daqf4s7"}, {"comment": "I believe MIT used to teach Scheme as the first language. Some places still educate using a functional language first, and some in industry would have come from such places. It is also used in some software produced by academia. But even if you were 'raised' with imperative, you can still swap paradigms. F# seems to be getting industry attention. I see no reason why people who have spent more time in the functional paradigm compared to the imperative/OO paradigm might not grasp functional programs easier.\n\n> Some people disagree that it's only a matter of getting used to it, You can say that imperative approach is more intuitive, because you're following state, and functional is more like mathematical definitions, more abstract. I personally honestly don't know.\n\nI don't really think you can simplify it like this. But if forced to, I would probably say something like this. The building blocks of the imperative paradigm, managing state using assignments, conditionals, loops are very simple to understand. Anyone can manually trace their steps through code. But I also think that when you put them together the result can become very complex. If you mix nested loops interwoven with conditionals, the resulting piece of program could do anything! Of course that is wrong; you can trace manually trace the exact run - assuming you don't make a mistake. On the other hand, the building blocks of functional programming, of arguable more abstract nature, might be more complex to grasp. But when you do, the composition of them is simpler to understand, and harder to get wrong. \"Take the coefficient array (iter), pair it up with the current buffer section (zip), and compute the pair products (map). Then sum it together (sum) and shift the sum (>>)\". ", "id": "damcd8g"}, {"comment": "> I believe MIT used to teach Scheme as the first language.\n\nThey did until roughly 2009, as far as I can tell.", "id": "damfudg"}, {"comment": "Coming from a maths background, I can say that the first example is far easier for me to understand. Functional programming has the benefit of never needing to think about state, which frees you to think about the *function* of the code.", "id": "dan4cij"}, {"comment": "I'm from both backgrounds and while I can understand functional, and I know simple abstractions like map etc, it always take a while to follow. I don't know, maybe I'm not doing it right. I try to deduce what happens with arguments, but maybe I really should focus on definitions.", "id": "dan8r6k"}, {"comment": "Functional programming is far more about the 'what' than the 'how'; oftentimes you can eliminate arguments altogether (check out point-free Haskell code).", "id": "danjfzs"}, {"comment": "> Whether it is more complicated depends on the perspective; whether you were 'raised' with \n\nThis already presupposes that the difference is 100% cultural/education, i.e. nurture vs nature. Do you have any actual evidence to support that?\n\nFunctional programming is a mathematical approach, procedural programming is much closer to a natural language approach. When you give someone cooking directions or navigational directions, you specify it as a series of steps. And I think that ultimately the latter is much easier for a wider range of people to understand. People are wired for natural language, that's why we almost all learn it with no problem, whereas math is difficult for many people.\n\nI remember teaching and being taught delta epsilon. For some reason, this ends up being an extremely challenging topic in freshman calculus. Even in graduate machine learning, you will see people have issues with PAC learnability which is basically the same thing. The best explanation I saw of delta epsilon was one where the entire notion was explained as a procedural game between two opponents. Most of the students in these classes were in a very mathematical frame of mind, had done barely any programming, and still found procedural delta epsilon easier to understand than functional delta epsilon.\n\nBeing exposed to functional concepts no doubt helps but I still think there is inherent preference in most people towards procedural.", "id": "damdpf5"}, {"comment": "It makes sense.\n\nFunctional language is timeless, two operations are the same, the transformation is merely a proof, for all intents and purposes the operation is instantaneous, even though there is no concept of time in functional programming. If you want to bring time, space (side-effects) etc, you have to reconstruct these traits (Monads were the way). It's elegant and simple to analyze functional programs, and its easy to reason and analyze them because you have access about everything.\n\nOTOH imperative programming is easier to understand for human beings, even if its harder to analyze. The complex constructs of space and time (the steps and the tape) are intuitive to humans already. Because you go step by step you only have to reason about that step to understand what its doing, you get a natural separation of things you need to focus on at a time. The cost is that you can get things that are incredibly hard to understand fully, only in small pieces.\n\nWhich is why I think we see the evolution. The code at small-scale is imperative-like and easy to understand what each piece does. But the pieces are merged with strong functional-like constraints (even if the glue is imperative-like itself, the way things are glued is functional-like) which make it easier to reason about the whole.\n\nSo the example above. For loops are easier to reason about, because you can easily go step by step and see where things are done for each element, where it's done for all elements, and how things expand. OTOH it's hard to understand what the whole thing is doing, or the consequences of it, the functional iterator chaining system does better at showing the overall intention.", "id": "damfj38"}, {"comment": "> This already presupposes that the difference is 100% cultural/education, i.e. nurture vs nature. Do you have any actual evidence to support that?\n\nThis was a poor choice of word by me, and I never said it is 100% cultural or education. Even accepting a cultural bias, what I mean is, someone who have 1000 hours in paradigm X, and 0 hours in paradigm Y, will be better at X than Y  -- 100%.\n\n> Functional programming is a mathematical approach, procedural programming is much closer to a natural language approach.\n\nI do think natural language has a strong influence but not because of sequencing - but more because of some relation to pattern matching - arguably more functional in nature. Even sentences of weird structure, understand we can, Yoda says.\n\n> When you give someone cooking directions or navigational directions, you specify it as a series of steps. \n\nI specify it as steps because that is what they asked for - asking for directions is asking for the steps to get there from their current position. If instead they asked me, \"How do we know when we are there?\", I would have given them \"patterns\" to match, and the order doesn't matter. If you can see sign X, house number Y, and a gas station, then you are there.\n", "id": "damez44"}, {"comment": "Recipes are only partially procedural. They are also partially declarative. They usually don't say \"dice a medium onion\", they list \"a medium onion, diced\" in the ingredients.", "id": "damp80s"}, {"comment": "Yes, and as someone who didn't grow up cooking, this is a point of personal frustration. :-) It can be hard to what parts of a recipe to take seriously and what's just a suggestion or an unstated assumption (that you know how to dice onions to the right size, e.g.). But I get why the recipes are the way they are: if you know how to cook a dish roughly already, the steps are a tedious distraction from the essence of the thing. ", "id": "dan3nzo"}, {"comment": "That doesn't really speak to which approach is better in which situation, and whether we should expect programmers to be trained in both.\n\nSomething being \"easier\" or more \"natural\" doesn't necessarily correlate to being more precise, concise, efficient, maintainable, extensible, etc.\n\nFor these micro-examples, it's a matter of personal preference, but for large scale design decisions, I don't think it's that simple.", "id": "dampv27"}, {"comment": "Look at those code samples: none of them is purely functional nor purely imperative.  The \"functional\" version mutates a buffer while iterating over it; the \"imperative\" version is full of expressions (as is most C, incidentally) - this isn't at all like you're write the assembler, say.\n\nAnalogies such as cooking are really dangerous because they appear sensical but often don't generalize.  You're going to need a much larger sample to generalize than just one activity.\n\nAlso, I think it's not actually an example of a very imperative approach; recipes are full of high-level \"functional\" instructions.  Sure, there's a imperative (aka monadic) overview, but it's fairly abstract.  They don't describe all the actions necessary to measure that gallon of milk, and often describe actions in terms of outcomes (until golden brown), which is rather declarative.  Even the steps are often out of order and it's left as an exercise to the execution environment (aka cook) to implement a particular ordering so that things time appropriately (e.g. make sauce like this, make pie like this, make crunch like this...)\n\n", "id": "danesvu"}, {"comment": "Generally functional code in Rust compiles down to the same thing as the equivalent for loop. (Though there are perf differences between [internal and external iteration](https://medium.com/@veedrac/rust-is-slow-and-i-am-the-cure-32facc0fdcb#.gliytm883) -- these usually crop up in code that would be even more complicated as a for loop anyway)\n\nIn release mode. In debug mode it sometimes ends up being slower because the closures aren't inlined.\n\n(Slices are just pointer+length pairs so they really don't have a cost).", "id": "dambmsh"}, {"comment": "You've changed more than just the iterators. A fairer comparison would be something like\n\n    for i in 0..buffer.len() - 12 {\n        let mut sum: i64 = 0;\n        for j in 0..12 {\n            sum += coefficients[j] * buffer[i + j] as i64;\n        }\n        buffer[i + 12] += (sum >> qlp_shift) as i32;\n    }\n\nvs\n\n    for i in 0..buffer.len() - 12 {\n        let sum = coefficients.iter()\n                              .zip(&buffer[i..])\n                              .map(|(&c, &s)| c * s as i64)\n                              .sum();\n        buffer[i + 12] += (sum >> qlp_shift) as i32;\n    }\n", "id": "dam19ax"}, {"comment": "The point stands though. Why hope that the compiler will fuse loops, when a hand-fused loop is shorter and simpler?", "id": "dam1jva"}, {"comment": "The compiler isn't fusing any loops, though. There's only one loop, inside `sum`. The iterator method could even be faster, if the compiler doesn't manage to elide bounds checks.", "id": "dam1x2j"}, {"comment": "Good point, I didn't realize that zip and map worked on iterators and not collections.", "id": "dam282s"}, {"comment": "Honestly both are equally readable to me.\n\nHaving looked at and written quite a bit of LINQ queries this kind of programming style comes pretty natural to me so I don't think your rewrite is inherently more readable.", "id": "dam4txd"}, {"comment": "I have to admit that I am ambivalent, because indeed the imperative version is also clean and readable. Perhaps even cleaner than the iterator-based version, because the syntax for the closure that takes two references is a bit noisy. But there is a key difference: the imperative version encodes *how* it is computing a value without clarifying its meaning, whereas the iterator-based version encodes *what* it is computing. With the imperative version, you have to read between the lines to realise \u201cah, this is just an inner product\u201d. In particular you have to mentally match up the indices. The iterator-based version reads to me as \u201cput a * between the coefficients and a slice of the buffer, and sum those products\u201d. It is a smaller step to recognise that that is an inner product.", "id": "damlmr2"}, {"comment": "The imperative version uses arithmetic, arrays and loops. The iterator-based version uses arithmetic, arrays, loops, and higher order functions. Neither uses a scalar product function. Whether a scalar product is more recognizable as a loop or a zip+map+sum is purely a matter of experience. I think it makes more sense to gain experience in the way that works better (shorter code, fewer dependencies, etc).", "id": "dammq4u"}, {"comment": "That's the point I was going to make as well.", "id": "dannewq"}, {"comment": "Make it more functional and it's a bit easier I think:\n\n     update buffer i delta = (sum (zipWith (*) coefficients (take 12 (drop i buffer)) >> qlp_shift)\n                             + delta\n\nthen just\n\n      buffer' = take 12 buffer ++ zipWith (update buffer) [0..] (drop 12 buffer)", "id": "dam984x"}, {"comment": "I don't find that easier to read than the imperative code. A bit of a mix may work (Python):\n\n    for i in range(n - 12):\n       buffer[i+12] += sum(coefficients[j] * buffer[i+j] for j in range(12)) >> qlp_shift", "id": "dam9lgp"}, {"comment": "But you never use the modified values in future computations: that is `buffer' !! 12` is never used in the computation of `buffer' !! 13` and so forth.\n\nAlso I don't think you can add the part of the buffer with the sum?", "id": "dambfxi"}, {"comment": "I think that approach doesn't work, you need something more complicated. If we simplify the problem a bit:\n\n    buffer = [1] * 20\n    for i in range(len(buffer) - 12):\n        buffer[i + 12] += sum(buffer[i + j] for j in range(12))\n    \n    print buffer\n\nthen the equivalent Haskell code will require crazy recursion:\n\n    foo a = let b = (take 12 a) ++ bar (drop 12 a) b in b\n    bar a b = (head a + sum (take 12 b)) : bar (tail a) (tail b)\n\n    main = print (show (take 20 (foo (repeat 1))))\n\nI wonder if that can be done simpler.", "id": "damks54"}, {"comment": "Wouldn't this do the same thing?    \n    \n    import Data.List (tails)\n    windows i = takeWhile ((==i) . length) . map (take i) . tails\n\n    foo = zipWith (+) =<< sumWindows\n      where sumWindows = map sum . windows 12", "id": "damlje5"}, {"comment": "I'm getting compile errors. Can you make a complete snippet that I can paste and run [here](https://www.tutorialspoint.com/compile_haskell_online.php)? For reference, here's the output of both of my snippets:\n\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13, 25, 49, 97, 193, 385, 769, 1537]", "id": "damlqah"}, {"comment": "Oh, sorry, misunderstood what you where doing there. That could be just written via a recursive definition abusing laziness, right?\n   \n    import Data.List\n    windows i = takeWhile ((==i) . length) . map (take i) . tails\n\n    foo ls = ls'\n      where ls' = beginning ++ zipWith (+) rest (sumWindows ls')\n            (beginning, rest) = splitAt 12 ls\n            sumWindows = map sum . windows 12\n\n    main = print . foo $ replicate 20 1\n", "id": "damq5bw"}, {"comment": "OK, I've got a one-liner, it's not very good though.\n\n    import Data.List\n\n    foo a = b where b = zipWith (+) a (replicate 12 0 ++ map (sum . take 12) (tails b))\n\n    main = print (foo (replicate 20 1))\n\nLooking at this, then at the Python code and back again, I think we've firmly established the superiority of functional programming in some aspects and inferiority in others :-)", "id": "damsged"}, {"comment": "The cool part of functional code to me is that it is easy to reason about. You can just replace any part of the code with a name, no thinking necessary. Just paste the code you are replacing to the right side of the new definition.  \nThat makes code really composable and modular and allows you to express your intentions instead of your implementation. \n\nThis does only work because you don't have any mutable state, though. So if you mix functional programming with state in rust you get a hard to follow mess that is more complex than the iterative version.\n\nThat is probably why so many people trying to give haskell solutions were confused. The original problem is basically just the Fibonacci sequence over 12 steps with the original array mixed in. But the way iterators are mixed with state makes that super confusing. Probably best to stay in one paradigm in rust, like factoring the iterators into their own function if you really wanted to use them. The original rust example probably should just be iterative, though.", "id": "dancjtv"}, {"comment": "~~I see this in most if not all the Haskell attempts in the entire thread. You can't simply split it up and only do a simple map over the second parts based on the original buffer entries. While the first 12 elements are the same, and the 13th element is indeed itself plus the value computed from the *previous original* 12 elements, this is only the case because the *resulting* 12 elements are unchanged from the previous ones. When you compute the 13th element, you use the old 12th element, but you should use the new one.~~\n\nNevermind, I didn't look close enough. I think you may be the first to get that right.", "id": "damquk6"}, {"comment": "I'm curious to see if the imperative forms of this code result in a similarly optimized generated code, or if the compiler leverages the semantics of the functional code to do a better job.\n", "id": "dancbow"}, {"comment": "The imperative code is just as much trouble, if not more so to understand.  If you don't know idioms like zip, map, and sum (or reduce) that well, it might look more complicated.", "id": "damgzf9"}, {"comment": "I don't think the functional style is any clearer to read.  At least, not much.\n\nHowever, I'd have a *lot* more faith that its correct than your code.  No offense intended: I'd write the imperative version no better.\n\nOne problem with this particular imperative code is all that index arithmetic. That's something that's very hard to read accurately.  Oh sure, it's trivial to understand what you *mean*, but if you'd have introduced an off-by-one somewhere, or accidentally swapped the order of iteration, that would be much harder to spot than in the other version.\n\nI do prefer the `+=` final line, but that's a minor detail the \"functional\" version could use too (aside, I think it's a little odd to call something that mutates a buffer while iterating over it functional).", "id": "danenxw"}, {"comment": "Yeah, the original code is not very functional, better to call it iterator-based. We [tried](https://www.reddit.com/r/programming/comments/5fpghn/zerocost_abstractions/dam984x/) making a pure functional version, but it's hard to get right and not very readable.", "id": "danersb"}, {"comment": "No.", "id": "dampaa7"}], [{"comment": "I think it is actually pretty amazing that the compiler can unroll this loop. So basically the compiler extracts the information from `zip` and knows that the loop has a fixed size?\n\nIs MIR or LLVM responsible for this optimization?\n", "id": "dam4d3j"}, {"comment": "Unrolling is just partial evaluation, and pretty simple in theory. LLVM handles that; I doubt unrolling is going to be MIR's job for a long time.\n", "id": "dam6cmg"}, {"comment": "Why not? Loop unrolling + constant folding + DCE are trivial optimisations and may benefit a lot from a higher level IR knowledge that is erased further down.", "id": "dam7byc"}, {"comment": "The latter two are obvious wins, but loop unrolling is mostly about low-level concerns: how large is the generated assembly, is the loop carried dependency the bottleneck, is it better to partially unroll, how should you apply SIMD? MIR's job should be to make sure that LLVM has all of the information it needs to make the right decision, since it can't answer these questions itself.", "id": "dam97za"}, {"comment": "> but loop unrolling is mostly about low-level concerns\n\nNo! The most value you'll get from the loop unrolling is in enabling the other optimisations. Most importantly, in combination with an aggressive inlining and a partial specialisation. The earlier you do it, the better, and the more high level information you have in your IR by that moment, the better.\n\n\n\n", "id": "dam9la6"}, {"comment": "Even if I entirely agreed, though I can't think of that many *high* level optimizations that benefit from unrolling, there's no point if you can't figure out if unrolling is the right thing to do. Unrolling everything by default is a recipe for disaster. And let's not forget that a large part of the justification for MIR is to lower compile times; sending LLVM large blocks of unrolled code is not going to improve things.\n", "id": "dam9v12"}, {"comment": "And this is exactly why you need a backtracking in a compiler pipeline. Try unrolling, see if it helps, backtrack if not.", "id": "dama9oe"}, {"comment": "But you'd need to backtrack from LLVM to MIR, which ain't happening.", "id": "damagqe"}, {"comment": "No, no, I mean optimisations on MIR level only, including specialisation.", "id": "damaj5y"}, {"comment": "Well, yes, but you don't know whether unrolling hurts until you're stuck in LLVM. So that solution isn't great.", "id": "damaq0b"}, {"comment": "> The earlier you do it, the better, and the more high level information you have in your IR by that moment, the better.\n\nAnd the less information you have about the target machine, the more likely you are going to completely blow your icache.", "id": "dammf00"}, {"comment": "Did not you get that I'm talking about some very different kinds of unrolling-enabled optimisations?\n\nYou do not need to know anything about the target platform if your unrolling is creating a many times smaller and faster *specialised* version of a function called from the loop body. Or if your loop unrolling is eliminating all of the code (e.g., folds into a single operation).", "id": "damnoik"}], [{"comment": "Zero **runtime** cost. I\u2019m sure there\u2019s a non-zero compile-time cost (which is completely acceptable, ofc).", "id": "dam8c00"}, {"comment": "\"zero cost abstractions\" as a slogan has always meant runtime cost. There's always costs to everything, that's engineering.", "id": "damg219"}, {"comment": "The question I would ask is whether the compile-time cost increases versus say an imperative version such as the one posted elsewhere in the thread. And if there is an compile-time cost increase, how significant is it, and is the cost worth the benefit of perceived improved readability?\n\nEven if it all boils down to the same runtime code, if you can get that same code with a small hit in readability but a big win in compile time, was is it worth the readability improvement?", "id": "danhco4"}, {"comment": "And a non-zero cognitive burden on the developer.  It seems there are three or more axis of Complexity in language-system design, Runtime, Compile-time, Developer-brain-burden or some similarly named entity can be a third. There could be more.  Go exists to provide some distributed systems developers a low-cognitive-burden alternative to C and C++ and Rust and D, at reasonable speed that still does not approach raw C but is \"faster than Python or Ruby or Scala\".  It's funny for some extremely \"simple on purpose\" language my brain rebels. What no generics/templates? What no exceptions?  Gaah!", "id": "dam8qsj"}, {"comment": "> And a non-zero cognitive burden on the developer\n\nErr, no. The entire purpose of abstractions is to *reduce* the cognitive burden. The abstracted Rust version is significantly easier to read, understand and maintain than the unrolled assembly.", "id": "damaclf"}, {"comment": "The *lack* of abstractions is a cognitive burden, not the opposite.", "id": "dambqtr"}, {"comment": "That's true in many cases, and the contrary is true in many occasions.", "id": "damcmkk"}, {"comment": "When abstraction is a cognitive burden it is simply a *wrong* abstraction.", "id": "damcx90"}, {"comment": "C++ is mostly an enormous pile of accidental complexity (\"wrong\" abstractions). \nWhereas Rust seems to be much more clean.\nDiscuss amongst yourselves.\n", "id": "damkt2m"}, {"comment": "And actually it's not even an abstraction. Abstractions _must_ lessen cognitive burden, since they allow a concept implemented concretely in code to be considered _in abstract_.\n\nUsually when programmers say they find abstractions to add cognitive overhead are used to working with code that has merely separated parts of the implementation into different files, classes, etc., but cannot actually be considered piecemeal at all.\n\nRusts' ability to eliminate the overhead of method dispatching seems really, really intriguing.", "id": "damjunt"}, {"comment": ">when scotsmen are a burden they are simply the wrong scotsmen", "id": "dammxw9"}, {"comment": "No you idiot. It is a bloody *definition* of an abstraction.", "id": "damnjwz"}, {"comment": "What is?", "id": "damugp3"}, {"comment": "Lowering the cognitive burden is.", "id": "danexjl"}, {"comment": "But you said  that would make it a *wrong* abstraction. How can it be a wrong abstraction if it's not an abstraction? Sounds like you're the idiot, you idiot.", "id": "dants27"}, {"comment": "I suspect people confuse _cognitive burden_ with _cognitive initial cost_. There's always going to be a learning curve. For instance, the interaction of the core abstractions in Rust is not something to be understood over a weekend.", "id": "danei37"}, {"comment": "Probably. Yet, cumulatively they cannot even be compared. Initial cost is one off, and running cost is permanent.", "id": "danez2y"}, {"comment": "Yes, its O(1) vs O(N).  They are not the same fruit.", "id": "danf3y7"}, {"comment": "[deleted]", "id": "damg2y3"}, {"comment": "Looks like you mis-parsed. They were saying that *Go* does not approach the performance of C.", "id": "damheko"}, {"comment": "I did! Thanks.", "id": "damhfow"}], [{"comment": "> Fortunately these structures are not allocated on the heap, as they would likely be in a language like Java or Python.\n\nAt least in principle, escape analysis would be used to allocate them on the stack. In HotSpot, simple iterators are commonly allocated on the stack (and then optimized further). When you have a JIT (which means you can afford one), general abstractions become zero-cost based on their use-site. The upside is that you get a few, general and powerful abstractions that are then completely optimized based on how they're used. The downside is that it is not guaranteed, and a JIT requires more RAM and power (and in practice usually a warmup period, although that can be solved).", "id": "damfixw"}], [{"comment": "If you enjoyed that article, you might also enjoy [Rich Hickey's](http://blog.cognitect.com/blog/2014/8/6/transducers-are-coming) blog post on transducers.  ", "id": "dam3keb"}, {"comment": "Why do you think they are related?\n", "id": "damiov7"}, {"comment": "I dunno how transducers work in Clojure, but I've heard that they're like the SERIES package in Common Lisp. The SERIES package allows you to express a series of transformations on a sequence without producing intermediary sequences, thus allowing for a less-cost abstraction (actually might be zero cost, I'm not sure). So that may be what he thought about.\n\n>A series is a data structure much like a sequence, with similar kinds of operations. The difference is that in many situations, operations on series may be composed functionally and yet execute iteratively, without the need to construct intermediate series values explicitly. In this manner, series provide both the clarity of a functional programming style and the efficiency of an iterative programming style. ", "id": "damuvmh"}, {"comment": "That's pretty much what iterators are in Rust. The only problem is that iterators have different concrete values, which need to stored in boxed form. ", "id": "danebrm"}, {"comment": "It's worth noting that having different types with the option to coerce them to a single type is strictly more flexible than languages that only offer a single type. The latter are automatically/compulsarily doing something equivalent to the boxing, and thus can't benefit as easily from things like inlining in cases where the boxing isn't necessary.", "id": "danv87l"}, {"comment": "Absolutely! It's common for people to come to Rust from 'classic' object-oriented languages, and they try to repeat those patterns and get frustrated. It takes a while to accept that there is no subtyping (as they understand it) and learn the more general mechanisms on offer.", "id": "daovxzi"}], [{"comment": "LLVM at work...", "id": "danekvt"}]]], "5fxffb": ["AWS Snowmobile \u2013 Move Exabytes of Data to the Cloud in Weeks", "2016-12-01 19:19:22", 0, "https://aws.amazon.com/blogs/aws/aws-snowmobile-move-exabytes-of-data-to-the-cloud-in-weeks/", [[0, "I absolutely forgot that I had cloud-to-butt installed."]], [[{"comment": "I absolutely forgot that I had cloud-to-butt installed.", "id": "dansdod"}]]], "5g9bai": ["URL Parsing in WebKit", "2016-12-03 15:16:17", 22, "https://webkit.org/blog/7086/url-parsing-in-webkit/", [[10, "I'm surprised this guy actually works on WebKit or for Apple. What a bad article.\n\nTrying to justify the article with examples like:\n\n> you might be trying to reduce your server\u2019s bandwidth use by removing unnecessary characters in URLs. If you are doing a user agent check on requests to your server hosting https://example.org/ and putting `<a href=\"https:/webkit.org\">` for WebKit-based user agents instead of `<a href=\"https://webkit.org\">`\n\nis just ridiculous. Anyone doing that *deserves* to have their application break, and *no-one should be surprised*."], [4, "So, this is all about how it behaves with malformed URLs?  Are people actually surprised that malformed URLs may not work as expected?  Did I miss something in the article?"], [-4, "Nobody should care about things breaking when malformed data is used: they knew what they were doing was wrong, it doesn't work consistently already, so breaking them is a non-concern.\n\nProgram like an idiot, get treated as such. "]], [[{"comment": "I'm surprised this guy actually works on WebKit or for Apple. What a bad article.\n\nTrying to justify the article with examples like:\n\n> you might be trying to reduce your server\u2019s bandwidth use by removing unnecessary characters in URLs. If you are doing a user agent check on requests to your server hosting https://example.org/ and putting `<a href=\"https:/webkit.org\">` for WebKit-based user agents instead of `<a href=\"https://webkit.org\">`\n\nis just ridiculous. Anyone doing that *deserves* to have their application break, and *no-one should be surprised*.", "id": "daqrlz9"}], [{"comment": "So, this is all about how it behaves with malformed URLs?  Are people actually surprised that malformed URLs may not work as expected?  Did I miss something in the article?", "id": "daqm4bz"}, {"comment": "> So, this is all about how it behaves with malformed URLs? Are people actually surprised that malformed URLs may not work as expected? Did I miss something in the article?\n\nMost URLs are malformed if you think about it. The reason for this is that humans enter URLs into the URL bar often and what you enter there is not a URL that can be safely transmitted to the server. In particular internationalization and escaping comes in quickly. Likewise internationalized URLs in the context of JavaScript strings is a very tricky issue due to UTF-16 -> UTF-8 etc.\n\nHonestly. This is a really hard problem and most systems do not handle URLs consistently and/or correctly.", "id": "daqygrw"}, {"comment": "In Chrome, the URL parser is distinct from the thing that parses the omnibox input.", "id": "daraayq"}], [{"comment": "Nobody should care about things breaking when malformed data is used: they knew what they were doing was wrong, it doesn't work consistently already, so breaking them is a non-concern.\n\nProgram like an idiot, get treated as such. ", "id": "daqsymw"}, {"comment": "> Nobody should care about things breaking when malformed data is used\n\n\"This site doesn't work in Chrome, but it works in Internet Explorer. It's obviously Chrome's fault. I'll keep using IE.\"", "id": "daqwmza"}, {"comment": "> Nobody should care about things breaking when malformed data is used\n\nThis is what got us into the mess that was pre HTML5 HTML. There is a good reason HTML5 defines exactly how to deal with failure. We have been through this twice already and the high horse approach does not work.", "id": "daqyeiv"}]]], "5g2zf6": ["How to perform a good code review", "2016-12-02 15:23:08", 18, "https://blog.alphasmanifesto.com/2016/11/17/how-to-perform-a-good-code-review/", [[4, "Point #7 is arguably the most important one. The last thing you want is your devs (or any person you're giving feedback to) going into blocking mode because you've given them the perception of talking to a jerk. I've been in both positions, unfortunately."], [2, "These points are probably not just limited to programming. They're probably helpful in reviewing all sorts of things, because they relate to how critical context is, being humble as the reviewer, the importance of giving reasons, and human interaction. Bookmarked this."], [2, "I laughed at:\n\n\"Quick Checklist\"\n<proceeds to list nearly 50 individual checklist items>\n\nBut overall I like the advice. \n\nOn the other hand, a colleague of mine likes to highlight lines of code when he reviews my stuff with a code review comment that just says \"no.\" He violates most of the advice in the list on a regular basis. People dread his code reviews. He's also the best code reviewer on the team by far: his reviews are brutally thorough and find lots of issues that other people might miss. "], [1, "Code reviews are something I'm new to and think is possibly a thorny subject in general due to \"people\".\n\nFrom my perspective, I tend to like to do things in a particular way (essentially C# with a \"functional programming\" slant, always with KISS and DRY in the forefront of my mind). So I'd probably struggle to find the balance between subjective and objective. I think the idea of **having fairly rigid code review guidelines** is probably key.\n\nI've asked for peer reviews of some of my code amongst my team before and have had virtually no feedback. I have had a couple of things pointed out to me that I had missed, which were greatfully received as if it improves my code / the code then I'm happier, but most people did not seem to interested in buying into the idea of code reviews and giving me the impression that they'd read my code at all. On the other hand when I've been asked for help on a particular task and I've pointed out how I would make a couple of changes \"if it were me\" those suggestions also seemed to be well received.\n\nI guess the main issue for me is the team dynamics, some team members seem receptive to the idea of code reviews (and more \"progressive\" ideas and practices in general) and others seem to have one way of doing things that they've stuck to for years. \n"], [1, "dang after doing all that could have probably written two apps"], [1, "The \"quick checklist\" is scary. If you find issues with all these points, that means the person creating the PR was not aware of all this, and likely will have to start from scratch. So a lot of time will be wasted (1st coding effort, 1st review effort). If a team needs this \"quick checklist\", then obviously something is wrong in whatever they do before coding (detailed design)."]], [[{"comment": "Point #7 is arguably the most important one. The last thing you want is your devs (or any person you're giving feedback to) going into blocking mode because you've given them the perception of talking to a jerk. I've been in both positions, unfortunately.", "id": "dapgop0"}, {"comment": "Yes! Juniors in our company (I also believe in others too) are by default scared of review. I was scared too. Just because of that anticipation: \"Oh god, what they will say about my code.\" And guys like: \"Wtf is this shit!?\" are unfortunately very real. After some period with developers that behave professionally, you realize that code review is such a good learning platform. ", "id": "dapk81g"}], [{"comment": "These points are probably not just limited to programming. They're probably helpful in reviewing all sorts of things, because they relate to how critical context is, being humble as the reviewer, the importance of giving reasons, and human interaction. Bookmarked this.", "id": "dap22rk"}], [{"comment": "I laughed at:\n\n\"Quick Checklist\"\n<proceeds to list nearly 50 individual checklist items>\n\nBut overall I like the advice. \n\nOn the other hand, a colleague of mine likes to highlight lines of code when he reviews my stuff with a code review comment that just says \"no.\" He violates most of the advice in the list on a regular basis. People dread his code reviews. He's also the best code reviewer on the team by far: his reviews are brutally thorough and find lots of issues that other people might miss. ", "id": "daq8ayr"}, {"comment": "So review the reviews? It's continuous improvements all the way down!", "id": "daqc75s"}, {"comment": ">with a code review comment that just says \"no.\"\n\nIf it's a category of issue that's been brought up enough times with the author and it's not an educational opportunity for other reviewers, this might actually be necessary just for time constraints on the reviewer.  Though, just a couple extra words would be a lot better.  I know there are times when I've left a comment as short as \"no inline SQL\" or \"no magic values\". But it's really audience dependant... simple little blurbs may be sufficient for your team if you've worked together enough.", "id": "dar583s"}], [{"comment": "Code reviews are something I'm new to and think is possibly a thorny subject in general due to \"people\".\n\nFrom my perspective, I tend to like to do things in a particular way (essentially C# with a \"functional programming\" slant, always with KISS and DRY in the forefront of my mind). So I'd probably struggle to find the balance between subjective and objective. I think the idea of **having fairly rigid code review guidelines** is probably key.\n\nI've asked for peer reviews of some of my code amongst my team before and have had virtually no feedback. I have had a couple of things pointed out to me that I had missed, which were greatfully received as if it improves my code / the code then I'm happier, but most people did not seem to interested in buying into the idea of code reviews and giving me the impression that they'd read my code at all. On the other hand when I've been asked for help on a particular task and I've pointed out how I would make a couple of changes \"if it were me\" those suggestions also seemed to be well received.\n\nI guess the main issue for me is the team dynamics, some team members seem receptive to the idea of code reviews (and more \"progressive\" ideas and practices in general) and others seem to have one way of doing things that they've stuck to for years. \n", "id": "daprt1f"}, {"comment": "That is right, but the problem with rigid code guidelines is that it will likely force every developer to be reading that while they develop. Trying to remember stylistic choices while fixing a problem can become very distracting. \n\nWhat we do in our team is let our standards be living standards. Whenever a stylistic discussion comes up and does not come to an easy agreement we call for voting. Results of the voting may be: Option 1, Option 2, ..., Option N, or it doesn't matter. \n\nFor example, in our discussion about LINQ and IQuerables, we decided to use method chaining and not the pseudo-sql syntax. On region usage, we suggest avoiding them but it's not a hard rule. As for using DTOs or anonymous objects in responses, we decided to let each dev pick their choice and review on a case by case basis.", "id": "daqiwi3"}, {"comment": "I'm not so much thinking of code guidelines. We do have those and I encourage the use of them, but that is at least partly handled by linters. I was more thinking of code **review** guidelines. i.e. Guidelines on what should and shouldn't be brought up in a code review and the kinds of things that should be looked at. ", "id": "daqja21"}, {"comment": "Ah, you're right. Sorry about that.\n\nStill, I never had the chance to view one of those. Would you like to tell me more?", "id": "dar2xhh"}, {"comment": "Hmm, I'm not sure, as I say I'm new to code reviews. I'm basically thinking of a way of dividing between subjective and objective. But I'm thinking of things like\n\n* **do** review changes / **don't** review entire classes/files\n* **do** mention that you can't understand code, which implies it is not elegant code and not well architected, even if the original author think it is\n* **do** mention when unit tests are missing\n* **do** mention when somebody used use LINQ query syntax over LINQ method syntax\n* **don't** mention when somebody aligned the \"=\" in a sequence of variable assignments\n* **do/don't** mention improvements when the original requirements are strictly speaking met\n\nI mean I don't have anything specific in mind and actually I don't agree with the example points I've just made. But I think there should ideally be a line drawn somewhere that should help everyone get along and avoid wasted time on unnecessary code changes.\n\nI know the way I code is very different to most of my colleagues and I wouldn't write code the way they do and they certainly don't write code in the same way that I do, even though it all passes the same StyleCop/linter rules. If I were doing formal reviews of their code and being picky about everything I didn't agree with, the list of changes would often be long.\n\nI also know that some rules such as those I mention above would be different from one company to another. e.g. taking the first example of reviewing changes only vs changes in context. On one hand reviewing changes only may be seen as productive as we may be able to assume that the rest of the code is \"good\" and that the organisation cannot afford an additional round of development, review, testing etc. On the other hand an organisation may value the idea of review in context and that more value can be added e.g. by further refactorings and may have time to do so.\n\nI'm saying that given a group of developers there's so much that **would** be written differently in different hands, but that as individuals we need a bit of guidance to allow us to sift through what is personal opinion (subjective) and is therefore not worth raising and what is more quantifiably (objectively) worth raising and adds recognised business value.\n\nP.S. I tend to use LINQ method syntax for simple LINQ queries, but LINQ query syntax for more complex queries \ud83d\ude09. I kind of think that guidelines are good and I agree that for intermediate/senior developers that guidelines are there to be broken and are less than \"rules\"\n", "id": "dar5ej3"}], [{"comment": "dang after doing all that could have probably written two apps", "id": "daq25bx"}], [{"comment": "The \"quick checklist\" is scary. If you find issues with all these points, that means the person creating the PR was not aware of all this, and likely will have to start from scratch. So a lot of time will be wasted (1st coding effort, 1st review effort). If a team needs this \"quick checklist\", then obviously something is wrong in whatever they do before coding (detailed design).", "id": "darba3v"}]]], "5foczs": ["EO-lang", "2016-11-30 10:27:44", 12, "https://github.com/yegor256/eo/blob/master/README.md", [[21, "Not sure if elaborate joke"], [11, "TL;DR\n\n> Here is a classic \"hello, world\" example:\n>\n>     import org.eolang.cli\n>     import org.eolang.printed\n>     import org.eolang.string\n>     cli:\n>       printed:\n>         string:\n>           \"Hello, world!\"\n\nand\n\n>     object fibonacci(1) as Int:\n>       Int @n\n>       ctor():\n>         fibonacci: 1\n>       ctor(Int n)\n>       Int int():\n>         if:\n>           firstIsLess: @n, 2\n>           1,\n>           plus:\n>             @n\n>             fibonacci:\n>               minus: @n, 1\n\nand\n\n> An object may have up to five attributes.\n\n> The attribute name must match `@[a-z][a-z0-9]{2,15}`.\n\n(yes, that's a restriction to 3-16 characters, and five attributes) and [this issue](https://github.com/yegor256/eo/issues/34)\n\n> How about, mandatory testing? Objects have methods and every method must be tested. If at least one method has no test, compiler have a right throw a warning or even cancel compilation.\n\nof course [this one](https://github.com/yegor256/eo/issues/1)\n\n> I don't know, that's why asking. Do we really need generics? What is the benefit of them? Can't we just declare the type at the time of its usage?\n\nand [this shorthand syntax](https://github.com/yegor256/eo/issues/8)\n\n> Presently there is a weird division in programming where you have to use Multiple of a type of object differently than a single object.\n>\n> This leads to creating String and List and so forth. Collection objects are used extremely frequently in real application code. What if the langauge were to be able to create this collection behavior automatically?\n>\n> What if using a plural form of a known class name would automatically compile to a collection by default.\n\nand the logo is a cactus.\n"], [4, "This looks like the twitch version of program language design."], [1, "This looks like the result of analysing why Python3 has (comparatively) failed and using the subsequent data to produce something with even greater odds of not simply failing, but failing sooner.\n\nI've never been a great fan of Python's usage of whitespace for relative indentation to specify block scope and this definitely succeeds in bringing the concept to its logical conclusion.\n\nAlso, perhaps the subtlety is lost on me, but the intro makes a marked point of declaring flow-control statements to be \"not tolerated\" and then immediately proceeds to demonstrate what is essentially a flow-control statement."], [3, "Not impressed by the lists on that page, or by [this](https://github.com/yegor256/eo/issues/4) conversation and [this](https://github.com/yegor256/eo/issues/1) conversation. I wouldn't be so blunt about it, but the repo declares itself \"the future of OOP\". I'm happy to offer more detailed criticism if anyone is interested."], [2, "I prefer Yegor's opinionated blogposts to this."], [1, "Why even bother with a JVM language? I think the language authors should have focused on LLVM rather than Java. Seems like a quick way to shoot yourself in the foot.\n\nI mean hell, I will have preferred a BEAM language to JVM."]], [[{"comment": "Not sure if elaborate joke", "id": "dalw8bc"}, {"comment": "[Does this look like an elaborate joke to you?](https://www.google.com/patents/US20120023476)", "id": "dalwae1"}], [{"comment": "TL;DR\n\n> Here is a classic \"hello, world\" example:\n>\n>     import org.eolang.cli\n>     import org.eolang.printed\n>     import org.eolang.string\n>     cli:\n>       printed:\n>         string:\n>           \"Hello, world!\"\n\nand\n\n>     object fibonacci(1) as Int:\n>       Int @n\n>       ctor():\n>         fibonacci: 1\n>       ctor(Int n)\n>       Int int():\n>         if:\n>           firstIsLess: @n, 2\n>           1,\n>           plus:\n>             @n\n>             fibonacci:\n>               minus: @n, 1\n\nand\n\n> An object may have up to five attributes.\n\n> The attribute name must match `@[a-z][a-z0-9]{2,15}`.\n\n(yes, that's a restriction to 3-16 characters, and five attributes) and [this issue](https://github.com/yegor256/eo/issues/34)\n\n> How about, mandatory testing? Objects have methods and every method must be tested. If at least one method has no test, compiler have a right throw a warning or even cancel compilation.\n\nof course [this one](https://github.com/yegor256/eo/issues/1)\n\n> I don't know, that's why asking. Do we really need generics? What is the benefit of them? Can't we just declare the type at the time of its usage?\n\nand [this shorthand syntax](https://github.com/yegor256/eo/issues/8)\n\n> Presently there is a weird division in programming where you have to use Multiple of a type of object differently than a single object.\n>\n> This leads to creating String and List and so forth. Collection objects are used extremely frequently in real application code. What if the langauge were to be able to create this collection behavior automatically?\n>\n> What if using a plural form of a known class name would automatically compile to a collection by default.\n\nand the logo is a cactus.\n", "id": "dalw2n4"}, {"comment": "And saying they have no GC and then stating they will reference count.\n\nAlso \"If all objects would live on the stack, then there is no need for GC, just reference counting.\" (If everything lives on the stack, neither is needed.)", "id": "daly8v1"}, {"comment": "There's a reason you can only have five attributes. [Look here](https://github.com/yegor256/eo/issues/39). Not a good reason, but a reason nontheless.", "id": "dalz944"}, {"comment": "What's wrong with a cactus?", "id": "danbd16"}, {"comment": "I never said it was bad, but I still would never touch it.", "id": "danca9d"}], [{"comment": "This looks like the twitch version of program language design.", "id": "dalz40o"}], [{"comment": "This looks like the result of analysing why Python3 has (comparatively) failed and using the subsequent data to produce something with even greater odds of not simply failing, but failing sooner.\n\nI've never been a great fan of Python's usage of whitespace for relative indentation to specify block scope and this definitely succeeds in bringing the concept to its logical conclusion.\n\nAlso, perhaps the subtlety is lost on me, but the intro makes a marked point of declaring flow-control statements to be \"not tolerated\" and then immediately proceeds to demonstrate what is essentially a flow-control statement.", "id": "dalwpke"}, {"comment": "How is python 3 even tangentially related to this? Python 2 has indentation based blocks too", "id": "dam8kqh"}, {"comment": "> I've never been a great fan of Python's usage of whitespace for relative indentation...\n\nNote that I said \"Python\", not \"Python 3\"", "id": "dambp2q"}, {"comment": "This is what I was referring to:\n\n> This looks like the result of analysing why Python3 has (comparatively) failed and using the subsequent data to produce something with even greater odds of not simply failing, but failing sooner.", "id": "dambrmo"}, {"comment": "Do a bit of Googling and you'll find plenty of articles claiming Python3 to either be failing, failed or facing an uncertain future.\n\nI don't take a position on any of those 3 being accurate in absolute terms, but what is certainly a fact is that compared to Python2 (i.e. *comparatively*) it can currently be considered to have objectively failed in terms of its goal to surpass its predecessor.", "id": "damc0hc"}, {"comment": "No disagreement on that, but this project has no relationship with python 3 whatsoever. It's an experimental toy language.", "id": "damejx5"}, {"comment": "Well, I don't think the author appears to intend it as a toy language.\n\nThat aside though, I was using the situation of Python3 to illustrate my statement, I wasn't trying to imply that this new langauge was on par with it.", "id": "damepnu"}], [{"comment": "Not impressed by the lists on that page, or by [this](https://github.com/yegor256/eo/issues/4) conversation and [this](https://github.com/yegor256/eo/issues/1) conversation. I wouldn't be so blunt about it, but the repo declares itself \"the future of OOP\". I'm happy to offer more detailed criticism if anyone is interested.", "id": "dambmie"}, {"comment": "Please do. I am very interested.", "id": "dan3mva"}, {"comment": "**RE: garbage collection**\n\nReference counting *is* a form of garbage collection, and it has unusually poor throughput. It can be slightly more predictable, but it is always very expensive to reclaim large and complex data structures, so it can still cause huge, irregular latency spikes. I suggest you look at what Go is doing with its garbage collector, or just piggyback on someone else's runtime (Go, Javascript, C#, Java, etc.)\n\n**RE: generics**\n\nIf you don't have generics your type checking will become unsound over very trivial bits of code (or you'll have massive code duplication). Making your type system so unsound means it's much less useful for local reasoning, as you can no longer trust type annotations. It looks like there are already people in your community making this argument though.\n\n**RE: \"the future of OOP\"**\n\nI don't fault your ambition, but declaring it as though it is already true makes you appear delusional. It's probably a misunderstanding, but it will put some people off working with you. I'd also strongly recommend that you seek out (or author) a precise definition of OOP, and justify why that definition is important and good. Or you could abandon the label. Otherwise you're going to waste huge amounts of time arguing in circles around an idea that isn't clearly defined. You could also focus on more granular properties of your language instead (e.g. referential transparency, support for AOP, support for transactions.)\n\n**RE: mutability**\n\nI just want to point out that most code quality issues are not caused by mutability alone. They are caused by the combination of mutability and non-local aliasing. You can permit mutation when you're confident there's no non-local aliasing. This might not have an influence on your language design, but I wanted to mention it because although immutability is often great, it is also limiting, and is becoming a bit of a cargo cult.\n\n**RE: your readme**\n\nPlease put the things you are hoping to achieve above the things you dislike. It will make you seem less like grouches, and more like people with a clear direction and exciting ideas.\n\n* AOP isn't too well-known. You could link to a short primer about it.\n* You want to build unit testing into the language, or provide strong library support?\n* The only bullet-points that sound like they *might* offer some innovation are very ambiguous. E.g. \"persistance\", \"transactions\", \"continuous integration\", \"build automation\".\n\nI'm just really not sure what your language is, or what it's trying to achieve that isn't already available. At the moment it sounds a bit like Typed Clojure (which already exists), but maybe that's just because I've misunderstood your direction.\n\n**RE: types and objects**\n\nI'm slightly confused by these sections, but left with the impression that you should take a look at TypeScript. I realise you don't like classes, but TypeScript doesn't actually have traditional classes. It has interfaces with optional default implementations, and they are structurally typed. Your conflict between a desire for duck typing and for type safety might also be resolved by row types/structural typing, which you can see in typescript (and Flow, Elm, PureScript, etc).\n\nAnyway, I hope some of that is helpful. Good luck!", "id": "danmhax"}], [{"comment": "I prefer Yegor's opinionated blogposts to this.", "id": "daluv6n"}, {"comment": "But you have both at the same time with this:\n>If you need to have more that five (properties), your design very likely is wrong. So, it's a good trigger for you to realize your \"mistake\" earlier than later", "id": "danv7ys"}, {"comment": "Or try this\n\n[https://github.com/yegor256/eo/blob/58/src/main/java/org/eolang/compiler/Main.java](https://github.com/yegor256/eo/blob/58/src/main/java/org/eolang/compiler/Main.java)\n\nSuch perfection: immutable, safe from inheritance, no evil getter/setters, no code logic in constructor, etc. Brilliant. One might even try to run it.", "id": "dap0w3t"}], [{"comment": "Why even bother with a JVM language? I think the language authors should have focused on LLVM rather than Java. Seems like a quick way to shoot yourself in the foot.\n\nI mean hell, I will have preferred a BEAM language to JVM.", "id": "dan3se8"}]]], "5g4qwl": ["Generating autumn leaves falls with WebGL", "2016-12-02 21:09:25", 2, "http://oos.moxiecode.com/js_webgl/autumn/", [], []], "5fru28": ["Kubernetes CI/CD with Docker and Node", "2016-11-30 23:09:12", 0, "https://distelli.engineering/kubernetes-ci-cd-with-docker-and-node-2ac29cf48b2b#.5dij4xw01", [], []], "5fs1na": ["AWS Snowmobile \u2013 Massive Exabyte-Scale Data Transfer Service", "2016-11-30 23:43:41", 0, "https://aws.amazon.com/snowmobile/", [[3, "Amazon has lost its damned mind.\n\n**Widget Co. CTO**: \"Moving to Amazon would be nice but at the current upload rate it would take 4 years to get all of our data into the cloud.\"\n\n**Amazon**: \"Fuck it... send a truck\"\n\n"], [1, "You think there is a demand for service like this?"], [1, "Not programming related; this belongs on r/trucking :-P\n\nSeriously though, holy shit. I can't believe AWS is offering FTL shipping as a service. It makes sense, but it's bonkers. Is it April in Seattle?"], [1, "AWS already supported shipping drives to them for import / export https://aws.amazon.com/blogs/aws/send-us-that-data/ . This looks like an extension + rebranding of the service."]], [[{"comment": "Amazon has lost its damned mind.\n\n**Widget Co. CTO**: \"Moving to Amazon would be nice but at the current upload rate it would take 4 years to get all of our data into the cloud.\"\n\n**Amazon**: \"Fuck it... send a truck\"\n\n", "id": "damlcjf"}], [{"comment": "You think there is a demand for service like this?", "id": "damkefx"}, {"comment": "Well, there may only be a few customers with problems this big, but you can bet they're the kind of customers that can afford to pay big bucks for the convenience. Small countries, state governments, multinational corporations, etc.", "id": "dapltsj"}], [{"comment": "Not programming related; this belongs on r/trucking :-P\n\nSeriously though, holy shit. I can't believe AWS is offering FTL shipping as a service. It makes sense, but it's bonkers. Is it April in Seattle?", "id": "damo5xe"}], [{"comment": "AWS already supported shipping drives to them for import / export https://aws.amazon.com/blogs/aws/send-us-that-data/ . This looks like an extension + rebranding of the service.", "id": "dan4lll"}]]], "5gby3x": ["StageXL 1.0 -- same API as Flash, but open source, runs in browsers without any plugin, fast, and in Dart", "2016-12-04 00:47:32", 37, "https://medium.com/@bp74/stagexl-1-0-a9c5ff22a534", [[5, "StageXL is a fantastic library for those using Dart. I haven't used it in over a year, but I bet it's much more fleshed out now. It was very easy to get sprites on the screen and even use flash documentation to help me get going."], [2, "I'm curious about alpha transparency of videos... Is it a thing? I can do it in. "], [1, "How does this compare to the obvious competitor OpenFL claiming to be exactly the same thing but in Haxe? The article seems to go out of it's way not to talk about it."], [1, "I would love for there to be a fully working AS3 runtime that can run in browsers."]], [[{"comment": "StageXL is a fantastic library for those using Dart. I haven't used it in over a year, but I bet it's much more fleshed out now. It was very easy to get sprites on the screen and even use flash documentation to help me get going.", "id": "dar216s"}], [{"comment": "I'm curious about alpha transparency of videos... Is it a thing? I can do it in. ", "id": "darb1yo"}], [{"comment": "How does this compare to the obvious competitor OpenFL claiming to be exactly the same thing but in Haxe? The article seems to go out of it's way not to talk about it.", "id": "darahs4"}, {"comment": "Seems that this supports same API and runs in browser. OpenFL has a little different API then flash, but can run with same code in browser/PC/iOS/Windows Phone/Android.", "id": "darn5hz"}], [{"comment": "I would love for there to be a fully working AS3 runtime that can run in browsers.", "id": "darpdb4"}]]], "5gbgcp": ["I made a lightweight Java cryptography program using AES, I'm hoping you'll check it out", "2016-12-03 23:10:51", 0, "https://github.com/gangspencer/FEM", [[5, "A few notes on this:\n\n- I'd recommend reviewing the way you're using Git. This \"folder per version\" layout would be somewhat difficult to work with - anyone trying to export the current tree ends up with a subfolder for every version you've released. What happens to your \"final_version\" folder when the next version comes out?\n- Regarding [this comment](https://github.com/gangspencer/FEM/blob/master/FINAL_VERSION/Cryptographer.java#L72), PKCS does not pad your \"password\", it's there to pad the plaintext.\n- The encryption implementation is vulnerable to both CBC padding Oracle and CBC bitflip attacks."], [3, "Not to detract from OP's post, but passpack also as an open source js encryption library that they use for client side packing of data."], [2, "Nice I like it. Keep working man."], [2, "As an educational thing?  Fuck yeah!\n\nFor a production thing?  Needs review.  (Nothing personal, but... it's encryption.  It *always* needs review!)"]], [[{"comment": "A few notes on this:\n\n- I'd recommend reviewing the way you're using Git. This \"folder per version\" layout would be somewhat difficult to work with - anyone trying to export the current tree ends up with a subfolder for every version you've released. What happens to your \"final_version\" folder when the next version comes out?\n- Regarding [this comment](https://github.com/gangspencer/FEM/blob/master/FINAL_VERSION/Cryptographer.java#L72), PKCS does not pad your \"password\", it's there to pad the plaintext.\n- The encryption implementation is vulnerable to both CBC padding Oracle and CBC bitflip attacks.", "id": "darha1g"}, {"comment": "Regarding the \"folder per version\" system, OP could look into `git tag`, as that seems to do exactly what you need. ", "id": "darop71"}], [{"comment": "Not to detract from OP's post, but passpack also as an open source js encryption library that they use for client side packing of data.", "id": "daqwph3"}, {"comment": "I'll be sure to check that out. Sounds very interesting!", "id": "daqz0k2"}], [{"comment": "Nice I like it. Keep working man.", "id": "daqwami"}, {"comment": "Thanks very much, I most certainly will", "id": "daqwpbn"}], [{"comment": "As an educational thing?  Fuck yeah!\n\nFor a production thing?  Needs review.  (Nothing personal, but... it's encryption.  It *always* needs review!)", "id": "dara87w"}]]], "5g5at5": ["CageNet and SwiftNet - Face Swap using CNN", "2016-12-02 22:44:03", 1, "https://arxiv.org/pdf/1611.09577v1.pdf", [], []], "5g3aud": ["Why does JavaScript need a style guide?", "2016-12-02 16:41:51", 0, "https://github.com/airbnb/javascript/issues/102#issuecomment-28157738", [[2, "I like the airbnb style guide and the linting ability and everything. I really do. I'm even ok with how often it's PO'd at me for leaving end-line spaces (because I use vim and have bad keyboard habits, I guess).  \nBut the default has me error out for using for loops. I like the for-of and for-in syntax. For loops. Error. Fucking hell. I look up why and there's an okish reason not to use them. This is somewhat even more annoying. I love JS, ES6 or whatever. Generators and promises and all that. It's good stuff. But fucking for loops, man. "]], [[{"comment": "I like the airbnb style guide and the linting ability and everything. I really do. I'm even ok with how often it's PO'd at me for leaving end-line spaces (because I use vim and have bad keyboard habits, I guess).  \nBut the default has me error out for using for loops. I like the for-of and for-in syntax. For loops. Error. Fucking hell. I look up why and there's an okish reason not to use them. This is somewhat even more annoying. I love JS, ES6 or whatever. Generators and promises and all that. It's good stuff. But fucking for loops, man. ", "id": "dap9ilr"}]]], "5ftyzs": ["Geohot\u2019s Self-Driving Car Platform Is Now Open-Source And Available To Download on Github", "2016-12-01 05:22:50", 127, "https://github.com/commaai", [[39, "Yup. Open source.\n\nhttps://github.com/commaai/openpilot/blob/master/selfdrive/visiond/visiond\n"], [26, "> Currently it performs the functions of Adaptive Cruise Control (ACC) and Lane Keeping Assist System (LKAS) for Hondas and Acuras. It's about on par with Tesla Autopilot at launch, and better than all other manufacturers.\n\nCocky as always."], [20, "I don't see any unit tests. That's very comforting for a safety critical system."], [12, "You wouldn't download a car."], [10, "> Acura ILX 2016 with AcuraWatch Plus\n\n> * Limitations: Due to use of the cruise control for gas, **it can only be enabled above 25 mph**\n\n> Honda Civic 2016 Touring Edition\n\n> * Limitations: Due to limitations in steering firmware, **steering is disabled below 18 mph**\n\nWell that's reassuring"], [3, "OMG Guys, why aren't you hyped? This is the code that tries to beat tesla.!!"], [1, "Now that we know he was outright lying about how capable his system is, can we please stop promoting it.\n\nSelf-driving isn't cruise control on a highway, it's driving safely through a school zone."], [0, "This the same kid who unlocked the iPhone? Amazing how much he's accomplished for his age."], [-1, "now lets see him build a car for it, improving a single thing is no accomplishment."]], [[{"comment": "Yup. Open source.\n\nhttps://github.com/commaai/openpilot/blob/master/selfdrive/visiond/visiond\n", "id": "dan7s6v"}, {"comment": "[deleted]", "id": "dancwc6"}, {"comment": "doesn't even have source code, so it surely isn't open source.", "id": "dane285"}, {"comment": "It has [plenty of source code](https://github.com/commaai/openpilot/blob/master/board/main.c) **and** a [permissive license](https://github.com/commaai/openpilot/blob/master/LICENSE.openpilot), so it surely is open source.", "id": "danhfb5"}, {"comment": "If a fundamental part of the system is proprietary, then you cannot call the whole system open-source. It must be possible to build the software from source. If it **only** works with some piece of proprietary software mixed into it, then it can't be called free. \n\nedit: reworded a bit for clarity", "id": "danjtmh"}, {"comment": "i understand your philosophical argument and agree with it, but we'd also have to call linux not open source then ", "id": "danknw7"}, {"comment": "> i understand your philosophical argument and agree with it, but we'd also have to call linux not open source then \n\nYou can use Linux with hardware that doesn't require non-free drivers or firmware. It's unfortunate that most hardware isn't like that, but firmware is out of the scope of what constitutes the kernel itself, and free drivers exist for almost all hardware for which it is possible.\n\nI'm not taking the same stance as the FSF and saying that just shipping non-essential non-free software is condemnable. But leaving out *essential parts* of the actual software, such that *nobody* can run it just from source (independent of external factors such as hardware) certainly makes the system as a whole non-free. ", "id": "danl5f3"}, {"comment": "Linux works fine without proprietary code.\n\nThis repo is nothing but a little glue code to pipe things to a self driving blob. It's roughly like MS open sourcing their boot loader and calling the windows kernel open source.", "id": "danw0ox"}, {"comment": "doesn't top level show MIT?", "id": "dangya0"}, {"comment": "Thing is, being open source is kind of pointless here. If there's not an enormous corporation behind it that can be sued when it drives into a family of four at a bus stop, who the hell is ever going to use it in their cars?", "id": "danh34b"}, {"comment": "if by driving into a family of four saves me, then i'm ok with it", "id": "dankoss"}], [{"comment": "> Currently it performs the functions of Adaptive Cruise Control (ACC) and Lane Keeping Assist System (LKAS) for Hondas and Acuras. It's about on par with Tesla Autopilot at launch, and better than all other manufacturers.\n\nCocky as always.", "id": "dandwbw"}, {"comment": "What he doesn't mention is Honda/Acura *already have ACC and LKAS*. I'm almost 99% certain all he did was rip their software out of their car (which would help to explain why his \"open source\" software has some rather large binary chunks) and *possibly* tweak it a bit. The video I saw of his system in action appeared to just be using the default Acura systems with a computer interfaced with the car. He was even having the reporter use the default buttons on the steering wheel that normally turn those functions on.\n\nThere's a very good chance he ends up getting sued for this.", "id": "dao8i2o"}, {"comment": "Except this can be installed into a car that does not have those features. It's a DIY kit that you install into your car, not just a piece of software.", "id": "dap4st2"}, {"comment": "I've watched a lot of geohot's stuff, since the jailbreak of the first iPhone. It actually is true that his self-driving car software is very good. Even Elon Musk has tried several attempts to collaborate with him in the past (I can try find the interview if you like).\n\nBut yeah, the quote is quite cocky. I think a lot of people of his level are like this. But remember: you can be right and still be cocky about it :)", "id": "danel95"}, {"comment": "> It actually is true that his self-driving car software is very good.\n\nMaybe, maybe not. But that's besides the point. If you want to be cocky you don't just need to be good, you need to be the best. He's burning bridges left and right and as a potential customer that is an issue.", "id": "danevk2"}, {"comment": "I wouldn't care, as long as the performance can be objectively measured and compared.", "id": "danhlbi"}, {"comment": "exactly anyone who thinks a bridge is burnt because someone is cocky are clearly not in it for the right reasons.", "id": "dankl01"}], [{"comment": "I don't see any unit tests. That's very comforting for a safety critical system.", "id": "danjj40"}, {"comment": "Unit tests are for developers who write bugs", "id": "dann4b8"}, {"comment": "Which is everyone", "id": "dao5u8q"}, {"comment": "I mean, if you're that concerned, you should probably be asking why it wasn't written in Ada or something like that.", "id": "danvns8"}, {"comment": "Which is a good point. This kind of function imposes ASIL-D grade requirements on the software and engineering process. Yet it's pretty clear to see that the system in this repo was designed by someone how would recognize an ASIL level if it punched him\nIn the face. ", "id": "daoukol"}, {"comment": "I'd be very worried if a system *that* critical was written by someone who relied on unit tests.", "id": "danrf9z"}, {"comment": "*wat*", "id": "dao3es8"}, {"comment": "lmao you rather have untested cowboy code running your car? WHAT", "id": "dansvdj"}, {"comment": "You sure mean \"by someone who relied **only** on unit tests\", right?", "id": "daobcrp"}], [{"comment": "You wouldn't download a car.", "id": "danlte3"}, {"comment": "That will be cool when you can download the open source car part plans, have your 3D printer print it, have your bot swarm assemble the parts and install open source self-driving software.", "id": "dao9frq"}], [{"comment": "> Acura ILX 2016 with AcuraWatch Plus\n\n> * Limitations: Due to use of the cruise control for gas, **it can only be enabled above 25 mph**\n\n> Honda Civic 2016 Touring Edition\n\n> * Limitations: Due to limitations in steering firmware, **steering is disabled below 18 mph**\n\nWell that's reassuring", "id": "danlk0r"}, {"comment": "They're building on the backs of features that weren't designed to be used at low speed: cruise control and lane-keep assist.  If someone can't stay in their lane below 18 mph, there's a much bigger problem than steering firmware.", "id": "danwwdv"}, {"comment": "What use is self-driving that stops working when you slow down?", "id": "dar7yha"}], [{"comment": "OMG Guys, why aren't you hyped? This is the code that tries to beat tesla.!!", "id": "dan1img"}, {"comment": "There's a *lot* more to an autonomous vehicle than code.  There's no way this project is going to \"beat Tesla\" with naught but a smartphone as its only sensor array.  Tesla adds a forward-facing radar + a 360 degree array of ultrasonic sensors for its implmentation.  Google adds LIDAR to that, and Google's the only company operating truely autonomously at this point.\n\nThis project only seems to be a replacement for Honda's lane-keeping assist and adaptive cruise-control... and the latter technology has been around for decades.  Really don't see a Tesla-killer in the works here.  This isn't even in the same ballpark IMO.", "id": "dan7mge"}, {"comment": "Does it have to though? If anything it could be a free and open equivalent that exists for a reason other than market domination.\n\nThat's like saying OSM has no other use outside of being a Google Maps competitor.", "id": "dan6ruv"}, {"comment": "Considering geohot was bragging about how it would beat Tesla, yes it does need to.", "id": "dan7db3"}, {"comment": "Are you 13?", "id": "dan9ejj"}, {"comment": "I know Poe's Law, but I hoped he was sarcastic ", "id": "dane0gs"}, {"comment": "Unlikely. Look at comment history.", "id": "danykyh"}], [{"comment": "Now that we know he was outright lying about how capable his system is, can we please stop promoting it.\n\nSelf-driving isn't cruise control on a highway, it's driving safely through a school zone.", "id": "dar7ksq"}], [{"comment": "This the same kid who unlocked the iPhone? Amazing how much he's accomplished for his age.", "id": "dao6fxx"}], [{"comment": "now lets see him build a car for it, improving a single thing is no accomplishment.", "id": "danho1a"}, {"comment": "I don't think he improved anything though. He basically just re-created something that was built a decade ago...", "id": "danscdp"}, {"comment": "> improving a single thing is no accomplishment\n\nYeah, like when Google came along, everyone was like \"Meh we got Yahoo! who needs another search engine?\"", "id": "danwy65"}, {"comment": "a search engine might look like one big thing but it's really plenty of stuff, e.g. here it would be the complete car with better batteries awesome automatic driving etc. What he did was not much because better algorithms for these things come in every few days. You can just take those and implement them. Tesla could too but has a lot more overhead in managing development, and a lot more things to check in order to make sure that the tech doesn't kill someone by accident. All things geohot doesn't have to care about at all.", "id": "daoaiwo"}, {"comment": "> You can just take those and implement them\n\nOK, where's your implementation?", "id": "daod2dt"}, {"comment": "I implemented many things", "id": "daof9i2"}, {"comment": "Of course you did!  I built the lunar lander.", "id": "daofgwd"}]]], "5g8qrm": ["OAR is not REST", "2016-12-03 11:49:52", 1, "http://mooreniemi.github.io/rest/apis/2016/11/08/oar-is-not-rest.html", [[2, "I've always thought any RPC API could be represented as an \"OAR\" interface (I like the term btw) it's just a problem of how you model it. An RPC interface for, say, adding a friend to a user could look like:\n\n    GET /users/<id>/add_friend?friend_id=...\n\nbut if you think about it for a second you could certainly model this action as the creation of a resource:\n\n    POST /users/<id>/friends\n\nwhere the POST body contains the other users id and any other relevant information.\n\nThe API drift problem that REST purportedly solves has never really seemed like a big issue to me. If your API is modeled somewhat sanely then it's unlikely the endpoints will change often or ever at all. If they do, coding for backwards compatibility and using semantic versioning is all that's needed and doesn't incur nearly as much overhead as a true \"RESTful\" API design would."], [-2, "And we should care why?"]], [[{"comment": "I've always thought any RPC API could be represented as an \"OAR\" interface (I like the term btw) it's just a problem of how you model it. An RPC interface for, say, adding a friend to a user could look like:\n\n    GET /users/<id>/add_friend?friend_id=...\n\nbut if you think about it for a second you could certainly model this action as the creation of a resource:\n\n    POST /users/<id>/friends\n\nwhere the POST body contains the other users id and any other relevant information.\n\nThe API drift problem that REST purportedly solves has never really seemed like a big issue to me. If your API is modeled somewhat sanely then it's unlikely the endpoints will change often or ever at all. If they do, coding for backwards compatibility and using semantic versioning is all that's needed and doesn't incur nearly as much overhead as a true \"RESTful\" API design would.", "id": "daqxayp"}], [{"comment": "And we should care why?", "id": "daqr2wt"}, {"comment": "This comment is definitely not helping anyone.", "id": "dar7i0l"}, {"comment": "Neither are overly pedantic posts about what is or isn't REST. \n\nBut I stand by my question, why should I care about \"OAR\" and whether or not it is \"REST\"? Without being able to answer that question the rest is as academic as explaining the difference between a cheese sandwich and a hotdog.", "id": "darlnwh"}]]], "5g55qa": ["What is the truck/bus factor of open source projects?", "2016-12-02 22:19:42", 0, "https://medium.com/@aserg.ufmg/what-is-the-truck-factor-of-github-projects-bb0d5f019a6f#.tnipv14th", [[1, "[Let me google that for you](http://lmgtfy.com/?q=What+is+the+truck%2Fbus+factor+of+open+source+projects%3F)"], [1, "[Let me google that for you](http://lmgtfy.com/?q=What+is+the+truck%2Fbus+factor+of+open+source+projects%3F)"], [1, "[Let me google that for you](http://lmgtfy.com/?q=What+is+the+truck%2Fbus+factor+of+open+source+projects%3F)"], [1, "[Let me google that for you](http://lmgtfy.com/?q=What+is+the+truck%2Fbus+factor+of+open+source+projects%3F)"], [1, "[Let me google that for you](http://lmgtfy.com/?q=What+is+the+truck%2Fbus+factor+of+open+source+projects%3F)"], [1, "Could someone here Google that for me?"]], [[{"comment": "[Let me google that for you](http://lmgtfy.com/?q=What+is+the+truck%2Fbus+factor+of+open+source+projects%3F)", "id": "daqxghh"}], [{"comment": "[Let me google that for you](http://lmgtfy.com/?q=What+is+the+truck%2Fbus+factor+of+open+source+projects%3F)", "id": "daqxh6o"}], [{"comment": "[Let me google that for you](http://lmgtfy.com/?q=What+is+the+truck%2Fbus+factor+of+open+source+projects%3F)", "id": "daqxzna"}], [{"comment": "[Let me google that for you](http://lmgtfy.com/?q=What+is+the+truck%2Fbus+factor+of+open+source+projects%3F)", "id": "daqy4mh"}], [{"comment": "[Let me google that for you](http://lmgtfy.com/?q=What+is+the+truck%2Fbus+factor+of+open+source+projects%3F)", "id": "daqy51f"}], [{"comment": "Could someone here Google that for me?", "id": "dar4b99"}]]], "5g796t": ["Reflections on Rusting Trust", "2016-12-03 04:56:17", 72, "http://manishearth.github.io/blog/2016/12/02/reflections-on-rusting-trust/", [[-3, "I would argue the same does not apply to Go, as you can choose to build Go from source, in which case it's ultimately built by a go1.4 compiler written in C, which you can build with the C compiler of your choice."]], [[{"comment": "I would argue the same does not apply to Go, as you can choose to build Go from source, in which case it's ultimately built by a go1.4 compiler written in C, which you can build with the C compiler of your choice.", "id": "daqnrk6"}, {"comment": "That's true of every bootstrapped compiler, all of which were originally compiled using a compiler written in a different language. Nobody is claiming that RoTT attacks are practical, only that they're possible.", "id": "daqqv6s"}, {"comment": "Right, but Ken Thompson's point was that gcc can only be compiled by itself, as the original assembly compiler is gone, so backdoors in gcc will persist. Since you can choose from multiple C compilers when you build Go, it's much harder for a backdoor to remain hidden", "id": "daqqzfn"}, {"comment": "Ken Thompson's point was about the notion of trust itself, using gcc as an example. The specific attack described applies to every bootstrapped compiler, though different compilers will have different degrees of ease in mitigating such an attack. I think it's true that Go would have an easy time mitigating such an attack, but I'd say that's because gccgo exists, rather than because one can compile 1.4 from C (especially since because, AFAIK, the C version of Go 1.4 only ever compiled via the Plan9 toolchain).\n\nI think the reason your original comment is being downvoted is because of the assertion that this \"does not apply to Go\". Rather, in Go, it's merely \"highly impractical\", as opposed to other languages where it is \"fairly impractical\". One could still write this same blog post for Go (and the author of this blog knows Go quite well, so I wouldn't be surprised if he did!).", "id": "daqu6b3"}, {"comment": "Rust's compiler was originally written in OCaml. It would take a longer bootstrapping process to get a \"clean\" compiler, but it's doable.", "id": "daqzjka"}]]], "5g0y2p": ["Spec-ulation Keynote - Rich Hickey", "2016-12-02 06:04:32", 24, "https://youtu.be/oyLBGkS5ICk", [[15, "I have never once heard Rich Hickey say anything I disagree with and I've watched many of his talks multiple times but I still can't get into Clojure.  Since he's manifestly smarter and better spoken than me, I feel like I might be the problem."], [1, "> Logic systems don't have \"And nothing else will ever be true!\".\n\nUuh. Closed world assumption? Everything that is not true is false. Most logic systems do have this. Prologs (not a logic system I know) cut operator even turns this statement into an operation.\n\nI feel like Rich really gets it wrong this time. His request to support all the abominations that you have ever written and keep them compatible with recent changes, might work if you have people pay for using your library and a company behind it. But doesn't fly if you maintain these things out of goodwill in your anyhow limited spare time.\n\nThe best example of this style going horribly wrong are the linux kernel file system modules. Different api versions all in use at the same time by the same code with no clear documentation on what to use when.\n\nIt's also ironic that the examples he uses to make his point namely, Unix APIs, Java and HTML, are horrible to work with especially because they either never developed good API's (looking at you unix poll), or they, like browsers, have become so bloated that nobody want to touch them with a ten foot pole. One of the reasons why it takes so long for browser standards to be adopted is that they have to be integrated with all the cruft that is accumulating there for almost three decades now.\n\n\"Man browsers are so reliable and bug free and it's great that the new standards like flexbox get widespread adoption quickly, but I just wish the website I made for my dog in 1992 was supported better.\" -no one ever.\n\nCombinatorial complexity is not your friend.\n\nI'd rather have people throw away stuff in a new major release, maybe give me some time to update like sqlite or python do, and then have me migrate to a new system where they have less maintenance cost and I profit from more consistency and reliability.\n\nI think that Joe Armstrong has a better take on this. https://www.youtube.com/watch?v=lKXe3HUG2l4\n\nAlso even though I'm a fulltime Clojure dev, I would take Elms semantic versioning that is guaranteed through static type analysis anytime over spec's \"we probably grew it in a consistent way\" handwaving.\ufeff\n"], [1, "I made this table to illustrate one of what i thought was the main takeaways, hopefully its correct\n\nIf i change the function is ok to keep the same name?\n\n           | output | input\n --------- |---------|------\nincrease   | yes    | no\ndecrease   | no     | yes\n:\n\nExamples with functions:\n\n`* means optional\n\n                | output                           | input\n------------    | -------------------------------- | -----------------------------------------\nincrease        | x -> x to x -> x,y               | x -> x to x,y -> x\ndecrease        | x -> x,y to x,y -> x,y           | x,y -> x,y  to x, *y -> x,y\n\n"]], [[{"comment": "I have never once heard Rich Hickey say anything I disagree with and I've watched many of his talks multiple times but I still can't get into Clojure.  Since he's manifestly smarter and better spoken than me, I feel like I might be the problem.", "id": "daopiz5"}, {"comment": "I have to say Rich Hickey is one of the best of our times. He is full of insights.", "id": "daoqo64"}, {"comment": "What I like about Hickey is that he always starts with a problem, establishes that it's a serious one, analyzes the cause and only then comes up with a solution. You may not always like his particular solution, but you can agree with his analysis of the problem. This approach is neither obvious nor the most common. Other people start with a solution, a certain tool, concept or technique, and then think about what good use they can extract from that tool. The advantage of the second approach is that you can guarantee that at least your solution is theoretically complete (because that's how the solution emerges in the first place). The problem with the second approach is that your product may end up diverging, solving problems that aren't really important and then working to solve more and more problems that arise from the direction you've chosen that are less and less related to real problems. The first approach tends to converge, and solve more real problems even if the solutions are less elegant. ", "id": "daovivm"}, {"comment": "Or Clojure might be the problem. Person who created the language != the language.", "id": "daorb27"}, {"comment": "I agree with many things that Rich Hickey says. Often I have a feeling that some solution is the \u201cright\u201d one compared to another, but Rich is able to spell out clearly and exactly *why* that is the case.\n\nBut one thing that I deeply believe in are strong static type systems. I never understood why apparently this is not missed in Clojure. (Or maybe it is, as they finally got [core.typed](https://github.com/clojure/core.typed).)", "id": "daozsf9"}, {"comment": "Rich developed clojure.spec for the next version of Clojure and it will move into core. Core.typed is not new, but it still has problem. Most clojure developers don't care for types, so Schema is a much more popular library then core.typed. Now, clojure.spec will probably even more popular. \n\nhttp://clojure.org/about/spec", "id": "dap3640"}, {"comment": "I would wager that Clojure community self-selects for people that are not fans of types. There are already good options for people that are (F#, Elm, Reason/ocaml, etc. etc.).", "id": "dap858z"}, {"comment": "Sure. Clojure is very up front that they don't see the dynamic typing as a disadvantage. I think this is a good strategy, why compete in a field where there is good such good competition.\n\nEmbracing dynamic and validation with spec brings advantages that static types can't, thats the selling point.", "id": "dap9del"}, {"comment": "Oh God yes. I think Hickey is a genius and he's basically always right. I also love LISPs and specifically I think that Clojure is the best LISP I've seen, I really dig the Clojure language.\n\nBUT I have made my mind up about strong typing and I think that F#/Ocaml/Haskell levels of typing is a good thing. I've been wrong about many things in development, some of which have taken me years to come to terms with and change my way of thinking. But surely stronger typing is generally better than weaker typing especially in languages that are as popular as Clojure or more popular.", "id": "dar6xem"}, {"comment": "You probably could not get into Clojure because of the simple vs easy  thing. Its not easy to start Clojure and to develop things based on this philosophy and that turns people away. The benefits however are quite large if you do it all.", "id": "dap37np"}, {"comment": "the reason I have been leaning away from clojure is because easy things are easy, and hard things are very hard...", "id": "dap5byl"}, {"comment": "I totally disagree, its hard to get started but hard things are usually where the win is.", "id": "dap5jq4"}, {"comment": "What do you guys mean by \"hard things\". It's highly possible that what one of you thinks of as a hard problem is different from what the other is thinking of.", "id": "daq2ssk"}, {"comment": "What would you say prevents you from \"getting into\" clojure?", "id": "daqtdrr"}, {"comment": "I think it's a combination of getting over the hurdle of being able to read lisp code when I'm used to all those curly brace languages and the jvm.", "id": "dar1xle"}, {"comment": "Learning a new language requires an uncomfortable journey. The longer journey the more rewarding it can be. Cloure is a Lips, and lisps are based on the lambda calculus, which is a logic for describing computation. If you haven't made the journey to a language based in logic, then i highly recommend you do so. Even if you have to return to where you started, you yourself will be changed, and so the place your at now will seem different. \n", "id": "darar6o"}], [{"comment": "> Logic systems don't have \"And nothing else will ever be true!\".\n\nUuh. Closed world assumption? Everything that is not true is false. Most logic systems do have this. Prologs (not a logic system I know) cut operator even turns this statement into an operation.\n\nI feel like Rich really gets it wrong this time. His request to support all the abominations that you have ever written and keep them compatible with recent changes, might work if you have people pay for using your library and a company behind it. But doesn't fly if you maintain these things out of goodwill in your anyhow limited spare time.\n\nThe best example of this style going horribly wrong are the linux kernel file system modules. Different api versions all in use at the same time by the same code with no clear documentation on what to use when.\n\nIt's also ironic that the examples he uses to make his point namely, Unix APIs, Java and HTML, are horrible to work with especially because they either never developed good API's (looking at you unix poll), or they, like browsers, have become so bloated that nobody want to touch them with a ten foot pole. One of the reasons why it takes so long for browser standards to be adopted is that they have to be integrated with all the cruft that is accumulating there for almost three decades now.\n\n\"Man browsers are so reliable and bug free and it's great that the new standards like flexbox get widespread adoption quickly, but I just wish the website I made for my dog in 1992 was supported better.\" -no one ever.\n\nCombinatorial complexity is not your friend.\n\nI'd rather have people throw away stuff in a new major release, maybe give me some time to update like sqlite or python do, and then have me migrate to a new system where they have less maintenance cost and I profit from more consistency and reliability.\n\nI think that Joe Armstrong has a better take on this. https://www.youtube.com/watch?v=lKXe3HUG2l4\n\nAlso even though I'm a fulltime Clojure dev, I would take Elms semantic versioning that is guaranteed through static type analysis anytime over spec's \"we probably grew it in a consistent way\" handwaving.\ufeff\n", "id": "dapngj7"}, {"comment": "> I would take Elms semantic versioning that is guaranteed through static type analysis anytime over spec's \"we probably grew it in a consistent way\" handwaving.\ufeff\n\nHow does it work in Elm? The doco isn't really clear. Is it only versioning at the type level? Or does it perform extra static analysis?\n\nFor example is this caught as a breaking change:\n\n    Result<User,Err> GetUser(string userId) {\n        ...code to get user from db...\n        return Result(user)\n    }\n\nChanged to:\n\n    Result<User,Err> GetUser(string userId) {\n        return Result(Err(\"I don't even try to get the user\"))\n    }\n\nThe types are the same and yet the behaviour is clearly different. If that kind of basic behavioural change does not force a major version increment then Elms semantic versioning is limited and doesn't solve the core problems Rich was talking about.\n\nIf it does perform more advanced static analysis then that's really cool and id love to look into it in more depth.\n\nBy the way spec and static typing are complementary; not mutually exclusive.", "id": "dapukg0"}, {"comment": "> might work if you have people pay for using your library and a company behind it. But doesn't fly if you maintain these things out of goodwill in your anyhow limited spare time.\n\nI think he was right on the money when he said it was a social choice.\n\nWriting easy to read code adds 20-30% development time but as a community we consider it a good tradeoff because code is read more often than it is written.\n\nCan't we make the same argument in support of library backwards compatibility?\n\nEven my internal-only company libraries are used by half a dozen other teams. Many open source libraries are used by thousands of developers.\n\nIsn't a 20-30% overhead for the library author a great tradeoff for the community if it results in a 5% decrease in user dev time?\n\nI would argue most library authors break far more frequently than they need to and focus on what is best for the library author and not the consuming developer.\n\nI understand the mentality and think it is fair enough especially because of lot of the library authors aren't being financially compensated. But it is also a huge drain on productivity.", "id": "daptboj"}], [{"comment": "I made this table to illustrate one of what i thought was the main takeaways, hopefully its correct\n\nIf i change the function is ok to keep the same name?\n\n           | output | input\n --------- |---------|------\nincrease   | yes    | no\ndecrease   | no     | yes\n:\n\nExamples with functions:\n\n`* means optional\n\n                | output                           | input\n------------    | -------------------------------- | -----------------------------------------\nincrease        | x -> x to x -> x,y               | x -> x to x,y -> x\ndecrease        | x -> x,y to x,y -> x,y           | x,y -> x,y  to x, *y -> x,y\n\n", "id": "darbuy7"}]]], "5g23f4": ["How easy is functional programming to understand ?", "2016-12-02 10:42:39", 0, "https://m.youtube.com/watch?v=peOk3W7KZ4o", [], []], "5g4b3p": ["Kolton Andrus on Lessons Learnt From Failure Testing at Amazon and Netflix and New Venture Gremlin", "2016-12-02 19:54:45", 4, "https://www.infoq.com/podcasts/failure-as-a-service#utm_source=reddit&utm_campaign=external&utm_medium=link", [], []], "5fqyvy": ["A sound static type system comes to Dart", "2016-11-30 20:45:36", 8, "http://news.dartlang.org/2016/11/dart-strong-mode-and-ahead-of-time_30.html", [[3, "Is the AOT stuff tied to Flutter or can I generate a binary that can run without a Dart interpreter installed on some Linux server?  That would be really, really cool."], [3, "Are the slides to the talk on Sound Dart available somewhere other than flicking through the video?"], [2, "[strong mode](https://github.com/dart-lang/sdk/blob/master/pkg/dev_compiler/STRONG_MODE.md#strong-mode) any better docs than this on the soundness? a paper perhaps detailing ? or is this soundness of the not so sound category of soundness"], [2, "It's really too bad the Dart team is only now coming to the realization that a real static type system is a requirement for sound code. It would have been much easier to design Dart with a static type system from day one instead of retrofitting a \"strong mode\" as an afterthought.\n\nGilad's love for Smalltalk is well documented, it's a pity this infatuation impacted Dart so profoundly.\n"]], [[{"comment": "Is the AOT stuff tied to Flutter or can I generate a binary that can run without a Dart interpreter installed on some Linux server?  That would be really, really cool.", "id": "damp3r1"}, {"comment": "It's not tied to Flutter, but Flutter is using it.\n\nI don't know if the AoT folks have it set up to actually be able to build a nice standalone command line Linux binary, but the various bits and pieces should be there.", "id": "damsyvk"}], [{"comment": "Are the slides to the talk on Sound Dart available somewhere other than flicking through the video?", "id": "damv2d6"}, {"comment": "Alas, no, sorry. :(", "id": "damw56b"}], [{"comment": "[strong mode](https://github.com/dart-lang/sdk/blob/master/pkg/dev_compiler/STRONG_MODE.md#strong-mode) any better docs than this on the soundness? a paper perhaps detailing ? or is this soundness of the not so sound category of soundness", "id": "dan0mt0"}], [{"comment": "It's really too bad the Dart team is only now coming to the realization that a real static type system is a requirement for sound code. It would have been much easier to design Dart with a static type system from day one instead of retrofitting a \"strong mode\" as an afterthought.\n\nGilad's love for Smalltalk is well documented, it's a pity this infatuation impacted Dart so profoundly.\n", "id": "danabx4"}, {"comment": "Initially, the intent was for Dart to run from source in a browser. The language designers wanted the same \"just refresh the page\" developer iteration loop that JS provides because they felt it would help adoption.\n\nWhen an app is parsed and loaded from source every time, there isn't a convenient time to run a type checker, which is one of the main reasons the type system is optional.\n\nWith the decision to not put the VM in Chrome, it means all Dart execution models involve some well-defined compilation step. At that point, it was much more feasible for us to have a more baked-in static type system.", "id": "danaz44"}, {"comment": "That sounds a lot like premature optimization to me, and I'm having a really hard time believing this was the main reason.\n\nBesides, you could have had your cake and eat it too: require type annotations in the language from day one and have two modes: one strict compilation mode that you use during development and one runtime that's used in the browser and that ignores type annotations.\n\n", "id": "danb7we"}, {"comment": "> I'm having a really hard time believing this was the main reason.\n\nIt was one reason, but I don't know if it was the main one. (I wasn't involved in the language design then.) A big part of it is also that many of the language designers are big Smalltalk fans and just aren't that keen on static types.\n\n> one strict compilation mode that you use during development and one runtime that's used in the browser and that ignores type annotations.\n\nYes, that's exactly how the original optional type system works.\n\nHaving a runtime that ignores them leads towards two knock on effects:\n\n1. It means you can't have *any* language features that rely on the static types for their runtime behavior. That means no overloading, no C#-style extension methods, no implicit conversions, etc. Some of that's fine, but it really does tie your hands in some ways.\n\n2. Since the runtime doesn't rely on the types anyway, you can allow an object of type `dynamic` to flow silently to a place where any other type is expected. Likewise, objects of, say, `List<dynamic>`. That's fine if the runtime doesn't care anyway.\n\n    But when you *also* have ahead-of-time compilation targets that matter for production (like compiling to JS for the web and machine code for iOS where you can't JIT), then that makes it *much* harder to efficiently compile code that *is* statically typed and doesn't want the overhead of worrying about `dynamic`. If you're compiling:\n\n        addTwo(List<int> pair) {\n          print(pair[0] + pair[1]);\n        }\n\n    You want to compile that fast code that just safely assumes the only thing you'll ever get out of that list is integers. That doesn't work if the type system allows:\n\n        var items = <dynamic>[\"not\", \"integers!\"];\n        addTwo(items);\n\n    This is the main difference in the type rules for strong mode.", "id": "danlzuj"}, {"comment": "So you guys finally gave up the \"dart will replace javascript\" goal?", "id": "danc6yu"}, {"comment": "I can't speak for the entire team, but that was absolutely never a goal for many of us. Languages never get replaced. People are still using COBOL, after all.", "id": "danlp7w"}]]], "5ga7gg": ["Flexible Paxos: Reaching agreement without majorities (Code Mesh 2016)", "2016-12-03 19:09:36", 32, "https://www.youtube.com/watch?v=gYkueS5sKqo", [], []], "5fvdzc": ["Introduction to CoffeeScript", "2016-12-01 10:43:58", 0, "http://www.discoversdk.com/products/coffeescript#/product-analysis", [[9, "Did the author succeeded in building a time machine and went to the future ?"], [3, "Did the author succeeded in building a cryogenic chamber and froze himself for years?"], [1, "The last CoffeeScript user."]], [[{"comment": "Did the author succeeded in building a time machine and went to the future ?", "id": "dandjft"}, {"comment": "whats wrong with some history. anyway all the posts here will be history in one year :)", "id": "danga6z"}, {"comment": "The post was published yesterday and is titled **Introduction To CoffeeScript**. I don't see any history involved here :)", "id": "dani3jy"}], [{"comment": "Did the author succeeded in building a cryogenic chamber and froze himself for years?", "id": "dane5el"}, {"comment": "https://connorlenahan.files.wordpress.com/2014/03/futurama-season-1-1-space-pilot-3000-fry-frozen-ufos-destroy-earth.jpg", "id": "danfba7"}], [{"comment": "The last CoffeeScript user.", "id": "daojm73"}]]], "5fp3u8": ["A curated awesome list of lists of interview questions.", "2016-11-30 14:24:52", 398, "https://github.com/MaximAbramchuck/awesome-interview-questions", [[269, "Hm, I'm JavaScript dev. Let's see what they have for me. \"[Top 85 JavaScript Interview Questions ](http://career.guru99.com/top-85-javascript-interview-questions/)\". \n\n> Between JavaScript and an ASP script, which is faster?\n\n> JavaScript is faster. JavaScript is a client-side language and thus it does not need the assistance of the web server to execute. On the other hand, ASP is a server-side language and hence is always slower than JavaScript.  Javascript now is also a server side language (nodejs).\n\n\nVery curated, very awesome, wow."], [219, "> 2. Name and describe a different Linux/Unix command for each letter of the alphabet. But also, describe how a common flush toilet works.\n\nRight - I'd like to smack this curator upside the head with a shovel"], [200, "You mean a curated list of SHITTY interview questions?"], [166, "Oh, this should be quite successful. We all know how much reddit loves lists of resources that they can save, and (at least in my case) never come back to. Thanks, OP"], [157, "I'm sorry, this is shit. I clicked on the first set of C interview questions, just out of curiosity, and found this:\n\n> How do you construct an increment statement or decrement statement in C?\n\nMaybe you're interviewing different coders than I am, but if I find myself seriously wondering whether you even know how to increment something, I think we can safely end the conversation right there. Thank you for your time, but this isn't a good fit.\n\n> Some coders debug their programs by placing comment symbols on some codes instead of deleting it. How does this aid in debugging?\n\nSeriously? Not only are we asking \"why would you comment things out while debugging\", but you phrase it as \"placing comment symbols on some codes\"?\n\n>  Can I use \u0093int\u0094 data type to store the value 32768? Why?\n\n> Answer:No. \u0093int\u0094 data type is capable of storing values from -32768 to 32767.\n\nWhile, yes, I concede that int is only required to be able to store 16-bit values, systems on which int is less than 32 bit are a rarity in today's world. There's a big difference between \"this might not work on embedded systems\" and \"no, you can't do that\". If you want to know whether the interviewee knows the required range of int according to the C spec, then *ask him that*.\n\n> Can two or more operators such as \\n and \\t be combined in a single line of program code\n\nTHOSE AREN'T OPERATORS JESUS FUCKING CHRIST\n\n> What is wrong in this statement?  scanf(\u0093%d\u0094,whatnumber);\n\n> Answer: An ampersand & symbol must be placed before the variable name whatnumber. \n\nAnd here I thought the missing quotes around %d were the problem. And given that you don't show the declaration of `whatnumber`, how am I supposed to know that isn't a pointer in the first place?\n\n> How do you generate random numbers in C?\n\nWell, I'd probably use a well-tested library such as Mersenne Twister, or maybe a... oh. You want me to say \"rand()\". Ok.\n\n> What is wrong with this statement? myName = \u0093Robin\u0094;\n\n> Answer:You cannot use the = sign to assign values to a string variable. Instead, use the strcpy function. The correct statement would be: strcpy(myName, \u0093Robin\u0094);\n\nUhh. Ok. I was going to write up a scathing critique of just how dumb this is, starting with the fact that there is no such thing as a \"string variable\" in C, but... I give. I'm stopping here. I lack the strength to finish."], [53, "What's it curated by, a regex? Here's the first link I followed for Postgres questions: http://nazafbtemplate.blogspot.co.uk/2014/06/frequently-asked-basic-postgresql.html"], [51, "How long until we get a curated list of lists of lists of interview questions?"], [39, ">Write a program to show the singleton pattern used in python.\nSingleton patter is used to provide a mechanism that limits the number of instances that can be used by one class. It also allows the same object to be shared between many different parts of the code. This allows the global variables to be used as the actual data that is used is hidden by the singleton class interface. The singleton class interface can have only one public member and one class method Handle. Private constructors are not used to create an object that is used outside the class. The process waits for the static member function to create new instances and return the singleton object.\nThe code that is used to call the singleton object is:\n\n    Singleton& Singleton::Handle()\n    {\n       if( !psingle )\n       {\n           psingle = new Singleton;\n       }\n       return *psingle;\n    }\n\nI..... what?"], [36, "Over the past five years, I have developed a set of heuristics I would like to believe help me wade through the enormous range of programming resources I am bombarded with every day. They are simple rules of thumb to help sort the wheat from the chaff. I am of course but a journeyman, not a master, and I cannot say these heuristics shall always hold true. And I use them sceptically - we must always be vigilant that the habits and prejudices we establish do not wall us off from fresh perspectives and new ways of thinking.\n\nNevertheless, I think there is one heuristic I can bet on safely. It is this:\n\n> All programming articles whose titles employ the word 'awesome' are hot, molten clumps of real human excrement\n\nThe second I would tender to this community is as follows:\n\n> The self-serving arrogance and self-assuredness of the term 'curated' indicates the the author is a purveyor of hot, molten clumps of real human excrement.\n\nAnd a final, tentative rule of thumb I have alighted upon over the years:\n\n> Any company that interviews engineers using 'language pearls' questionnaires is hopelessly unqualified to manage them. Any job there will be akin to lowering your head into a pneumatic tube firing hot, molten clumps of real human excrement."], [21, "Had a look at some of the lists for C. One of the questions was \"Write a program that outputs \"Hello World\" without using a semi-colon\".\n\nWhy would you ever need to do that to solve a real problem? Although, I suppose it tests your problem solving skills...\n\nFor reference, a possible solution:\n\n    #include <stdio.h>\n    int main() {\n        if (printf(\"Hello World!\\n\")) {}\n    }"], [20, "That this is #1 on /r/programming this morning sort of highlights exactly why I don't visit this sub much anymore. I'm only here now because I clicked through to this post from the front page.\n\nAlso, most of the best discussions are posted here hours after they're posted on HN.\n\nIn before \"Unsubscribe then\"."], [13, "Hmmm. Let's see, for Java\n\n> 20 Essential Java Interview Questions\n\nhttp://www.toptal.com/java/interview-questions\n\nFirst thing they do is ask me a billion questions about my name, my company's name, who I am trying to hire, my email, my skype name... Nope.\n\nNot curated. Not reasonable. Useless list."], [13, "> **What does ruby name refers to?**\n\n> * Ruby names refer to the classes, variables, methods, constants and modules that help in the creation of the program. \n>\n> * These are the names that distinguish other names with the specified ruby names that are being mentioned above.\n> * Ruby names are useful and used to be written as it is shown. They are useful in the context of writing the programs and while generating the module. \n> * Ruby names refer to the classes that has to be built and through which the objects will be declared, and methods that will perform on the data that is given.\n> * The names are reserved such that they can\u2019t be used anywhere else and for any other purpose. The name that is used can be in lower or upper case, letter, number or an underscore.\n\nThis made me stupider.\n"], [12, "I had a cursory glance at the C++ questions, and I feel like a lot of what is asked is technicalities about the language and none of which helps you understand if the candidate can write or design good software."], [13, "it s shit"], [13, "One of the C++ ones:\n\n> Do you think the following code is fine? If not, what is the problem?\n\n> T *p = 0;\n> delete p;\n\n> \\- No, the code has a problem. The program will crash in an attempt to delete a null pointer.\n\nWhat ? No it won't..."], [9, "Looking at some of the languages I am proficient in, I can honestly say the \"curator(s)\" do not understand the languages in question.  Stop up-voting this crap."], [9, "I read some java interview questions and they were crap, considering how people from the other languages are complaining I'd say a removal of the \"awesome\" seems fitting"], [6, "Followed through to the first list of Python questions: [Python interview questions and answers - freshers, experienced](http://www.careerride.com/python-interview-questions.aspx)\n\nFirst of all, 100% of the code examples are formatted incorrectly. Is part of the prep fixing their examples?\n\nThe author is universally unclear, ere are some good examples:\n\nWhat are the ways to write a function using call by reference?\n\n* In the function?  Call the function by reference? What the writer actually means is \"How can you write a function that takes a reference to an object as its argument?\"\n\nHow can the ternary operators be used in python?\n\n* They can't, Python has no ternary operator.  It has a logical expression with similar results, which is what the author mentions.\n\nHow the string does get converted to a number?\n\n* Typically when asked this question, I would expect the interviewer to want some insight into how the actually code works - i.e. the \"How\".  The question the author answers here is \"What should you do to convert a string to a number?\"\n\nPast this point in the article the questions look like copy/pasted code from the internet combined with literally nonsensical questions and answers.\n\nPerhaps the later entries are better, couldn't be bothered to look any further."], [5, "OK I am not a programmer per trade but I found this in one of the question involving C++\n\n> Which type is best suited to represent the logical values?\n> \n> a) integer\n> \n> b) boolean\n> \n> c) character\n> \n> d) all of the mentioned\n\nI would say depending on the situation a and b.\n\nSince an int can be evaluated like a bool as false if 0 and true if different than 0 one can associate different instances of success or failure to an int, since by default if( var ) is equivalent of if( var!=0 )\n\nPlus, from personal experience, maybe because I am terrible at coding, in some cases vector<bool> might not be great because the structure is adapted for low memory footprint by getting only one bit per entry in the vector, which depending on the machinery that you have around, might cause issues."], [4, "> Which is used to tell the computer that where a pointer is pointing to?"], [4, "I took a look and agree with the general sentiment here that what I saw was... less than good. But I didn't downvote it for one reason: real-life employers actually ask these questions and it's handy to know answers to some of the weird ones. Something something \"but if they ask silly questions the job can't be that good\" I hear someone say. Not true. For some reason really competent engineers at good companies I'd like to work for still ask reaaaaaly bad interview questions.\n\nI think it's akin to the problem I see with people teaching natural languages: they always seem to teach a language they don't speak themselves in daily life, only in polite circumstances (think a speech). Then the student goes into a pub after a year of learning, say, German, and doesn't understand anything anyone says."], [4, "Here's a good interview question:\n\n\"Tell me about the most interesting thing you worked on or most interesting problem you had to solve?\"\n\nAnd then discuss.\n"], [4, "\"Would you rather fight one horse-sized duck, or 100 duck-sized horses?\""], [3, "Is there a curated awesome list of curated awesome lists?"], [3, "Wow, these are really bad. "], [3, "Everyone (including myself) agrees this list is shit. Which demands this question: is there a non-shit curated list like this?"], [3, "This list isn't curated..."], [2, "and of all the things programmers and redditors need, nothing about soft skills."], [2, "SQL Lite. "], [3, "Some of the C# questions were good. "], [2, "I would like to see a list of interview excercises, or do-it-at-home excercises to give to an interviewee. Excercises are often more useful and give a better indication of one's skills then some interview questions or quiz."], [2, "This isn't a curated list. It's just a list of hundreds of links to hundreds of questions. No commentary whatsoever. Useless. "], [2, "OP forgot a /s at the end of the title.\n"], [2, "Lots of mistakes in the \"C\" list.  Small errors, outdated assumptions, typos that would change the context.\nI have not looked into the rest yet.\n"], [2, "> 21) What is wrong with this statement? myName = \u0093Robin\u0094;\n\n>Answer:You cannot use the = sign to assign values to a string variable. Instead, use the strcpy function. The correct statement would be: strcpy(myName, \u0093Robin\u0094);\n\nWho said it was a string? I see no declarations of either of those fields, for all I know they were defined with scalar types and are perfectly valid."], [1, "Checked out the C# ones, I can see some of them being useful.\n\nI find these questions are very subjective. It's more much interesting and engaing if you pair programme with the interviewer and attempt to solve a problem together.\n\nThat establishes whether or not you can problem solve and pair with another programmer which would show some semblance of interpersonal skills."], [1, "Curated."], [1, "Looking at some of the languages i was like \"Fuck yea. I know these stuff so i can get a job\" came to the comments...i see i was wrong."], [1, "maybe good for studying to answer interviewer's bad questions, but don't ask these yourself"], [1, "So as a learning developer I have no idea why this is apparently a terrible list, having never interviewed. Can anyone point me to an actually awesome list of interview questions instead? (Note: I'm learning C# and .Net) "], [1, "[\"I've never killed a man.\"](https://www.youtube.com/watch?v=ngu0RKsv3qE&t=30s)"], [1, "Well, why all of this hate on this post? I'm not a professional programmer, I'm phd student and I use python in my daily work. I found some of the [related questions](https://www.toptal.com/python/interview-questions) really interesting."]], [[{"comment": "Hm, I'm JavaScript dev. Let's see what they have for me. \"[Top 85 JavaScript Interview Questions ](http://career.guru99.com/top-85-javascript-interview-questions/)\". \n\n> Between JavaScript and an ASP script, which is faster?\n\n> JavaScript is faster. JavaScript is a client-side language and thus it does not need the assistance of the web server to execute. On the other hand, ASP is a server-side language and hence is always slower than JavaScript.  Javascript now is also a server side language (nodejs).\n\n\nVery curated, very awesome, wow.", "id": "dam10ww"}, {"comment": "Today I learned that 227 people clicked the upvote button before looking at any of the questions on this \"curated\" list.", "id": "dam4abq"}, {"comment": "I just looked at languages I am proficient in and found *glaring* errors and grammar/spelling issues.  It's fucking useless.", "id": "dam57be"}, {"comment": "OMG the real fear/danger here is that \"tech recruiters\" will use this list.\n\nIf you give a (correct) answer that is not exactly the same as what they see on this list, \"Sorry\".\n\nThey really need to put this on wikipedia or some better site where experts can evolve it closer towards truth.  Github isn't nearly as fluid in that process.", "id": "dam7zrc"}, {"comment": "Any company who picks recruiters that are that dumb is going to have equally stupid people in engineering roles since their hiring process isn't screening out the right candidates. Such a company is not one I want to work for anyway.", "id": "dame3fm"}, {"comment": "Amen", "id": "damncyb"}, {"comment": "Well, trying be fair, it has 11K stars on GitHub, a thousand of forks and 45 contributors.\n\nIt may become ~~not shit~~ better one day, who knows.\n\n", "id": "damgt3i"}, {"comment": "With something this bad, it's better to just start afresh.", "id": "dami0e3"}, {"comment": "Sure. And some day a million monkeys will finally bash out the script to Hamlet.", "id": "damjfvh"}, {"comment": "In the meantime, an endless supply of Perl scripts are being produced.", "id": "dang672"}, {"comment": "Still rising. Maybe there's enough good questions in there that people might find it useful. I doubt it though.", "id": "damk3p8"}, {"comment": "How about [Top 20 GO Programming (Golang) Interview Questions & Answers](http://career.guru99.com/top-20-go-programming-interview-questions/):\n\n> **2) What is syntax like in GO?**\n\n> Syntax in GO is specified using Extended Backus-Naur Form (EBNF)\n\n> Production = production_name \u201c=\u201d [ Expression ]  \n> Expression = Alternative { \u201cl\u201d Alternative }  \n> Alternative = Term { Term }  \n> Term = Production_name l token [ \u201c\u2026\u201dtoken] l Group l Option l Repetition  \n> Group = \u201c ( \u201c Expression\u201d)\u201d  \n> Option = \u201c [ \u201c Expression \u201c ]\u201d  \n> Repetition = \u201c {\u201c Expression \u201c}\u201d\n\nSome obvious problems:\n\n1. Nobody capitalizes it as \"GO\", which immediately puts the author's experience into question.\n2. The answer provided is a definition of EBNF syntax itself and completely unrelated to Go.\n3. Even if the answer had been the syntax for Go, it wouldn't offer any insight into your ability to write Go, which is why nobody will ask you this question.", "id": "dam3u6b"}, {"comment": "Also, nobody would ask this in an interview.\n\nWait... some idiot in HR would ask this after finding the question on a \"curated list of awesome interview questions\".\n\nIf somebody did ask, I would just say its syntax was in the C-style family of languages.", "id": "dam74t6"}, {"comment": "It's disturbing to me that someone even thought of this question.", "id": "dame5dv"}, {"comment": "If some jackass asked me to write EBNF syntax for language X during an interview it would be interview over. I've fielded all sorts of idiotic whiteboard questions before - from writing programs in brainfuck to counting missing numbers in near infinite lists - but that would be my breaking point. \n\nHell, throw the entirety of programming pearls at me if it makes you feel like more of a man, I can take it. Just don't expect me to get the syntax right every time.", "id": "dam8t96"}, {"comment": "\"near infinite lists\"...?  I imagine that would nearly take a pretty long time.\n", "id": "dam9o0x"}, {"comment": "You're thinking inside the box. You need to switch up some paradigms, show you're a team player, and solve this problem. BTW I've just decided I'm not going to hire you and this is now being done for my amusement... and I'm bored... you can tell because I'm yawning and talking in a tone that suggests I think you're inferior to me.", "id": "damawv9"}, {"comment": "> Is it possible to break JavaScript Code into several lines?\n\nWell, I really hope you don't have to put all your JavaScript Code into a single line!", "id": "dam60rr"}, {"comment": "Well, you want to minimize the size of your javascript. And it's not like there's any software to do it, so\n\nFuck, I can't find a way to phrase this joke without it sounding too real.", "id": "dam6gjx"}, {"comment": "You don't write your javascript minified from the get-go?!  ", "id": "dambwxf"}, {"comment": "This doesn't surprise me. My first thought after reading the title was \"Wow, 'awesome list of...' is becoming the go-to title for ~~blog~~ github posts and is probably meaningless by now\".\n\n/r/programming doesn't have a whole lot of quality control, likely because the submitted content usually takes a long time to digest, so instead it's upvoted based on titles and initial feelings. I see a ton of really quality content get immediately downvoted here.", "id": "dam6y5e"}, {"comment": "Yeah it's odd.  You'd think that, given the comments, this would be sitting at zero.  Nope, people are up-voting blindly, because they're not even looking at the site, nor the comments.", "id": "dambz4z"}, {"comment": "Wait, you mean the up-arrow isn't a bookmark?", "id": "damiheq"}, {"comment": "That's what the save feature is for. ", "id": "dan6r7s"}, {"comment": "Roll down a little, look at this:\n \n> **69. Write the point of difference between web-garden and a web-farm?**\n \n>Both web-garden and web-farm are web hosting systems. The only difference is that web-garden is a setup that includes many processors in a single server while web-farm is a larger setup that uses more than one server.", "id": "damb2g9"}, {"comment": "I've literally never heard of those expressions. Server farm is the only even remotely similar. I guess I should just fucking quit my job.", "id": "damp8p8"}, {"comment": "\"Web-garden\" is adorable.", "id": "damm1gq"}, {"comment": "You can write asp and asp.net in javascript. ", "id": "dam17oq"}, {"comment": "Wow, they haven't seen truly crappy JS...\n\nBut seriously, I get what they're saying: if there's something that *can* be computed client-side, it's almost certainly going to be faster to do it client-side rather than making one extra request/response cycle to get it, even if the server computes it a lot faster.", "id": "damot0n"}], [{"comment": "> 2. Name and describe a different Linux/Unix command for each letter of the alphabet. But also, describe how a common flush toilet works.\n\nRight - I'd like to smack this curator upside the head with a shovel", "id": "dam255o"}, {"comment": "\"T\", as in \"Thanks for your time, I have other interviews to attend\" - this kind of question just screams \"unprofessional\".", "id": "dam3kxz"}, {"comment": "Have you guys gone to a lot of interviews? This is *exactly* the kind of questions that come up; I would expect the first one in a written exam and the second one asked by the project manager to see how eloquently you can describe a mechanism.\n\nAs for \"thanks for your time\", is the job market really that great again? ", "id": "damf6zr"}, {"comment": "The toilet thing seems like a relative of the \"break down what happens when you enter an URL into your browser\" question, except simpler and for plumbers.", "id": "damgl9c"}, {"comment": "Plumbing Administrators, thankyou.", "id": "damqcer"}, {"comment": "I've done a ton of tech interviews, and never had anything like this. I would definitely TFYT any interviewer that did this to me.\n\nBoth times I've looked for jobs in the past 3 years I've had 3-4 competing offers after about 3-6 months of looking. So that seems pretty good.", "id": "damh5oi"}, {"comment": "Happy to hear about the job market :) \n\nI've never had plumbing questions either, but several baseball- themed ones (luckily, not about baseball itself, but it broke down to statistics).", "id": "damhj5k"}, {"comment": "I mean, statistics and probability are fine questions.", "id": "damhku5"}, {"comment": "> Have you guys gone to a lot of interviews?\n\nI interview for jobs once or twice a year, even if I have no intention of leaving my current job - gotta keep that interview game strong. Besides, maybe they'll offer something too good to pass up, you never know.\n\n>As for \"thanks for your time\", is the job market really that great again?\n\nI have yet to go more than 2-3 weeks without a job offer when I'm actually looking.", "id": "daml09f"}, {"comment": "I'll give you the second one (I've heard variations of that in various \"Google-esque\" interviews, usually in a technical context), but I strongly object to the first one. This is an interview, not a game-show (though I wouldn't be opposed to a programmer gameshow).", "id": "damt4vd"}, {"comment": "> This is exactly the kind of questions that come up\n\nWhere are you interviewing?", "id": "damtxhk"}, {"comment": "Finance in New York. Last major bank I applied to, I talked to *eight* people total who were smitten with me, and one who was not - didn't get the job. Also part of this was a 1 hour written exam.", "id": "dan3x7e"}, {"comment": "The market where I live is certainly good enough for developers to be picky during interviews. I also have never witnessed any questions as stupid as those, but I guess it could happen.", "id": "danowuy"}, {"comment": "I've interviewed at a lot of places and never encountered a question that dumb. And yes, it's absolutely a candidate's market today.", "id": "dao2w02"}, {"comment": "    alias a=\"ls\"\n    alias b=\"ls\"\n    alias c=\"ls\"\n    alias d=\"ls\"\n    alias e=\"ls\"\n    alias f=\"ls\"\n    alias g=\"ls\"\n    alias h=\"ls\"\n    alias i=\"ls\"\n    alias j=\"ls\"\n    alias k=\"ls\"\n    alias l=\"ls\"\n    alias m=\"ls\"\n    alias n=\"ls\"\n    alias o=\"ls\"\n    alias p=\"ls\"\n    alias q=\"ls\"\n    alias r=\"ls\"\n    alias s=\"ls\"\n    alias t=\"ls\"\n    alias u=\"ls\"\n    alias v=\"ls\"\n    alias w=\"ls\"\n    alias x=\"ls\"\n    alias y=\"ls\"\n    alias z=\"ls\"", "id": "damfocy"}, {"comment": "Bonus points if you wrote a shell script to generate those.\n", "id": "damh65z"}, {"comment": "    for i in $(seq 97 122); do printf \"alias \\x$(printf %x $i)='ls'\\n\"; done", "id": "dan5w0i"}, {"comment": "for letter in {a..z}; do alias ${letter}=ls; done", "id": "dan7an6"}, {"comment": "my man!   \n(edit: or my woman, I really don't know)", "id": "damkut8"}, {"comment": "Slow down!", "id": "dampoyk"}, {"comment": "You forgot to describe the works of a common flush toilet.\n\n", "id": "danuha0"}, {"comment": "Awk  \nBz (i feel like this is a command but I'm not sure)  \nCat  \nDd  \nEcho  \nFsck  \nGrep   \nIfconfig  \nJava maybe?  \nKill  \nLs  \nMan  \nNano  \nPs  \nRm  \nSed  \nTmux (not installed by default but still awesome)  \nUniq  \nVim  \nWc  \nYum  \nZip  \n\nThat's all I got\n\nEdit: formatting", "id": "dam3doq"}, {"comment": "You spelled \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\sed\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ wrong. Remember, if there are fewer than 50 backslash escapes, your sed command isn't ready yet.", "id": "dam3zck"}, {"comment": "You can also use various other chars to separate things, I personally like `|`s.", "id": "dam5kyb"}, {"comment": "\\\\|", "id": "dam6rc5"}, {"comment": "Using the extended regex flag to eliminate the need for all of those escapes really boosted my sanity", "id": "dam70s0"}, {"comment": "I always give up, do inline perl instead.\n\nAnd after a week of that, I end up rewriting the entire shell script in perl after telling myself \"it's just a quick and dirty bash script\". It never is.", "id": "dam8rnr"}, {"comment": "I regularly make fun of my one coworker who's a perl fan, but using `perl -i -pe` over `sed` has saved me a lot of sanity...", "id": "dami32g"}, {"comment": "For personal use, I write alot of webscrapers. WWW::Mechanize is... there are no words.\n\nI tried to write one in python once, to give it a chance. But it's not nearly as usable. Not a jab at python, it's serviceable enough when I'm writing plex plugins.", "id": "damip6v"}, {"comment": "I generally use perl too unless it's columns then I just use awk since the syntax is simpler.", "id": "damsatn"}, {"comment": "I'm sorry, but we won't be progressing your application. You failed to explain how a flush toilet works.", "id": "dam48sv"}, {"comment": "Well, you see, when you press the flush button the bowl is flooded with the tears of former applicants for this role. Once Gravity has drained the cistern of the bitter tears of inconsolable sadness it is slowly refilled until a float attached to a mechanical solenoid stems the flow again. \n\nAfter the cistern is at capacity, new tears are simply mashed into the office carpet by HR managers while they write condescending emails telling applicants to study hard and try again in six months if they want a chance to pass the Google-esque interviews used to screen prospective developers who want to work on the in-house shopping cart software written in PHP4 by functionally retarded outsourced programmers in 2004. \n\nThey only hire the best and brightest here, after all. Being able to implement merge sort flawlessly from memory or regurgitate the Sieve of Eratosthenes in brainfuck on a whiteboard is critical to avoiding unexpected T_PAAMAYIM_NEKUDOTAYIMs. Plus they hired that one Google reject years ago and put him in charge of hiring, and... well... does he ever have an axe to grind and something to prove.", "id": "dam9gsc"}, {"comment": "I wish to subscribe to your newsletter", "id": "damat3k"}, {"comment": ">Bz \n\nYou may be thinking of `bc` the calculator", "id": "dam3ycd"}, {"comment": "I was thinking of bz compression. Did not know about the calculator ", "id": "dam5int"}, {"comment": "bzip2", "id": "damgiy5"}, {"comment": "More likely the bzip2 utility for making .bz2 files.", "id": "dam6l5h"}, {"comment": "bzcat\n\nAlso, none of those commands will work unless you make an initial case insensitive command line.", "id": "dam6y3n"}, {"comment": "> not installed by default but still awesome\n\nA lot of other things you mention aren't installed \"by default\" across all Unix and Linux flavors.\n\nThere are basically two baselines you could go by... POSIX (more relevant for Unix) and GNU (more relevant for Linux). ~~OSX doesn't comply with either by default, so there you go.~~ (yeah they do, thanks /u/NSCFType)\n\nFollowing that standard, your incorrect guesses are:\n\nbz fsck ifconfig java nano tmux vim yum zip\n\nThe following is a list of all shell commands that are both in POSIX and GNU (edit, removed if and for which are not really shell commands):\n\nalias\n\nawk\n\nbasename\n\nbc\n\nbg\n\ncal\n\ncat\n\ncd\n\nchgrp\n\nchmod\n\nchown\n\ncksum\n\ncmp\n\ncomm\n\ncommand\n\ncp\n\ncron\n\ncrontab\n\ncsplit\n\ncut\n\ndate\n\ndd\n\ndf\n\ndiff\n\ndir\n\ndirname\n\ndu\n\necho\n\nenv\n\nexpand\n\nexpr\n\nfalse\n\nfg\n\nfile\n\nfind\n\nfold\n\nfuser\n\ngetopts\n\ngrep\n\nhash\n\nhead\n\niconv\n\nid\n\nip\n\njobs\n\njoin\n\nkill\n\nlink\n\nln\n\nlocal\n\nlogname\n\nls\n\nmake\n\nman\n\nmkdir\n\nmkfifo\n\nmore\n\nmv\n\nnc\n\nnice\n\nnl\n\nnohup\n\nop\n\npaste\n\npathchk\n\npr\n\nprintf\n\nps\n\npwd\n\nread\n\nrenice\n\nrm\n\nrmdir\n\nsed\n\nselect\n\nsleep\n\nsort\n\nsplit\n\nss\n\nstat\n\nsu\n\nsum\n\ntail\n\ntee\n\ntest\n\ntime\n\ntouch\n\ntop\n\ntput\n\ntr\n\ntrue\n\ntsort\n\ntty\n\ntype\n\nulimit\n\numask\n\nunalias\n\nuname\n\nunexpand\n\nuniq\n\nuuencode\n\nuudecode\n\nvi\n\nwait\n\nwc\n\nwho\n\nwrite\n\nxargs\n", "id": "damdnrs"}, {"comment": "> OSX doesn't comply with either by default\n\n[macOS](http://www.opengroup.org/openbrand/register/brand3627.htm) has conformed to the [Single Unix Specification](https://en.wikipedia.org/wiki/Single_UNIX_Specification), a superset of POSIX, since 2007.\n\n\n\n", "id": "dameq9f"}, {"comment": "huh, til", "id": "damf2m4"}, {"comment": "So, this list doesn't cover q and y. I'd expect 'quota' and 'yacc' to be commonly acceptable, even though they apparently don't pass your (POSIX && GNU) test. ", "id": "damfzp3"}, {"comment": "'yes' is fairly pervasive as well. Maybe there's a better standard to apply. `yes` and `quota` are GNU, `yacc` is POSIX. I think anything in POSIX || GNU is reasonable, although I figured that doing an && would really ensure those scripts were available almost anywhere... of course, I'm sure a handful of the above aren't available on a clean Ubuntu install, for example.", "id": "damjh2h"}, {"comment": "Missing ones: head, od (had to look that one up, o is hard), quota, xargs.", "id": "dam78zv"}, {"comment": "You missed head. Also jobs for j.", "id": "dam9ztf"}, {"comment": "bash\n\njoin\n\nod\n\nxargs\n\nAnd my goto Q command is\n\nqemu-img", "id": "damb18g"}, {"comment": "Prefer Jq - it's awk/sed/less for JSON.", "id": "damec89"}, {"comment": "What about O?", "id": "damhbkf"}, {"comment": "> Tmux (not installed by default but still awesome)\n> \n\ntee\n\nif you want something installed by default", "id": "damp36u"}, {"comment": "That's a fun question to ask, without the describe or toilet part. It's surprisingly telling of someone's background in Linux. ", "id": "dam93xc"}, {"comment": "Yes, but with the toilet part, it's an annoying question that is not respectful of the candidate or their time. It doesn't tell you anything about whether or not they can do the job unless you're building an IoST (Internet of Shitty Things). It doesn't tell you if they will do the job. All it _might_ tell you is whether  they'd fit in with your environment, and there are far better ways to ask this.\n\nThis curated list of questions is unfortunately littered with similarly bad ones. ", "id": "dam9jxa"}, {"comment": "    ag\n    bash\n    cp\n    dd\n    echo\n    finger\n    grep\n    head\n    ip\n    jq\n    killall\n    ls\n    man\n    nc\n    objdump\n    perl\n    qmake\n    ruby\n    ssh\n    tcpdump\n    uname\n    VBoxManage\n    which\n    xz\n    yes\n    zsh", "id": "damh2cb"}, {"comment": "    alias a=alias\n    a b=a\n    b c=b\n    c d=c\n", "id": "dan6nwz"}, {"comment": "I'm really confused how these two sentences relate to each other?", "id": "damtp0a"}], [{"comment": "You mean a curated list of SHITTY interview questions?", "id": "dam2dx9"}, {"comment": "It's amazing how many votes this post has, huh?\n\nThis is a horrendous list of lists of horrendous questions.\n\nAnd I've been on reddit since it was programming focused - so, really early days. Since that day, to this day, the commenters on this site and then this sub when we switched to subreddits... fucking hate these stupid types of interview questions (rightfully so!).", "id": "damdhph"}, {"comment": "Seriously. I bookmarked it at first, then read some of the questions...\n\nAn endless stream of questions with \"correct\" answers.\n\nWho gives a fuck if you've memorized the behaviour of <language> in <specific corner-case>?\n\nToo many questions with not enough problems.", "id": "damtn3d"}, {"comment": "I think the awesomeness is the volume.\nIf they were going for quality at the top they would design it that way, it would be a ranking not a list", "id": "dan9ugr"}, {"comment": "At the risk of sounding snarky - are there any \"awesome\" lists that aren't terrible? I don't think I've ever seen that sunglasses button attached to any quality content on Github.\n\nIf I'm choosing a library, I'd like to know how long it has been around, how large the dev team is, whether dev efforts are waning, what test coverage is like, how many other projects use it, etc. To keep the promise of curation, you should also be reviewing said library, and weighing pros and cons, and pointing out limitations or pitfalls.\n\nBut I never see any of that. Most seem like an upturned wheelbarrow of search results, with no actual indication of curation.", "id": "damikuq"}, {"comment": "These lists are a a way of farming Github stars/forks to make one's github profile look \"interesting\". ", "id": "damkel6"}, {"comment": "So *that's* why I can't find work in an industry that's allegedly starved for talent.", "id": "dan546p"}, {"comment": "Coming soon to library shelves, \"The Click-Bait Resume: 47 tricks to maximize exposure\".", "id": "daqg0r2"}, {"comment": "> At the risk of sounding snarky - are there any \"awesome\" lists that aren't terrible?\n\nThe problem is that there aren't any awesome questions that exist without context.  Good questions tend to directly relate to the job you would be doing.  A good question for a, say, web developer working on an event ticketing platform won't be a good question for an embedded systems programmer working on microcontrollers for dishwashing machines.  Yeah they could both probably answer a \"how do you implement a circularly linked list\" question but it has no bearing on the work they've done in the past or will do for your company.", "id": "dampr1k"}, {"comment": "Ah, I'm not really talking about the questions. \"Awesome\" lists have been a (dodgy) Github trend for years, and they span many topics.", "id": "dampwd2"}, {"comment": "Oh, I gotcha.  That was a rhetorical question not an actual \"please send me lists of questions that aren't terrible\"", "id": "dampy1c"}, {"comment": "Well, really, that list will be useful in preparing for an interview for precisely that reason.  Though that's probably not intended.", "id": "damoyfm"}], [{"comment": "Oh, this should be quite successful. We all know how much reddit loves lists of resources that they can save, and (at least in my case) never come back to. Thanks, OP", "id": "dalwucb"}, {"comment": "It's extra successful because you can tell everyone who is upvoting this didn't even look at the exceptionally poor quality of questions on the list.", "id": "dam57bo"}, {"comment": "It's curated, it must be good.", "id": "dameanx"}, {"comment": "Curation process:\n\n\"Is there a question mark on the page? If yes, add to curated list.\"", "id": "damefny"}, {"comment": "r/me_irl", "id": "dam0j5k"}, {"comment": "Me too thanks \n\nq_q", "id": "dam5o8g"}, {"comment": "Hey atleast I check the comments if the list is worth it.", "id": "dam5l4g"}, {"comment": "If more than 5 recruiters get their hands on this list, it'll set this industry back another 5 years.  ", "id": "dambjvq"}, {"comment": "Thankfully this is a particular resource you're better off not saving or ever visiting again.", "id": "dam58fj"}], [{"comment": "I'm sorry, this is shit. I clicked on the first set of C interview questions, just out of curiosity, and found this:\n\n> How do you construct an increment statement or decrement statement in C?\n\nMaybe you're interviewing different coders than I am, but if I find myself seriously wondering whether you even know how to increment something, I think we can safely end the conversation right there. Thank you for your time, but this isn't a good fit.\n\n> Some coders debug their programs by placing comment symbols on some codes instead of deleting it. How does this aid in debugging?\n\nSeriously? Not only are we asking \"why would you comment things out while debugging\", but you phrase it as \"placing comment symbols on some codes\"?\n\n>  Can I use \u0093int\u0094 data type to store the value 32768? Why?\n\n> Answer:No. \u0093int\u0094 data type is capable of storing values from -32768 to 32767.\n\nWhile, yes, I concede that int is only required to be able to store 16-bit values, systems on which int is less than 32 bit are a rarity in today's world. There's a big difference between \"this might not work on embedded systems\" and \"no, you can't do that\". If you want to know whether the interviewee knows the required range of int according to the C spec, then *ask him that*.\n\n> Can two or more operators such as \\n and \\t be combined in a single line of program code\n\nTHOSE AREN'T OPERATORS JESUS FUCKING CHRIST\n\n> What is wrong in this statement?  scanf(\u0093%d\u0094,whatnumber);\n\n> Answer: An ampersand & symbol must be placed before the variable name whatnumber. \n\nAnd here I thought the missing quotes around %d were the problem. And given that you don't show the declaration of `whatnumber`, how am I supposed to know that isn't a pointer in the first place?\n\n> How do you generate random numbers in C?\n\nWell, I'd probably use a well-tested library such as Mersenne Twister, or maybe a... oh. You want me to say \"rand()\". Ok.\n\n> What is wrong with this statement? myName = \u0093Robin\u0094;\n\n> Answer:You cannot use the = sign to assign values to a string variable. Instead, use the strcpy function. The correct statement would be: strcpy(myName, \u0093Robin\u0094);\n\nUhh. Ok. I was going to write up a scathing critique of just how dumb this is, starting with the fact that there is no such thing as a \"string variable\" in C, but... I give. I'm stopping here. I lack the strength to finish.", "id": "dam5uoj"}, {"comment": "You made it farther down the list then I did... I lost it when they wanted to convert a for-loop to a while-loop, and figuerd it was better to increment the variable inside the while-loop rather than in the condition. Also, they forgot to declare the variable as an int.", "id": "dam8ytl"}, {"comment": "Actually, omitting the type is valid in C, it always defaults to int (which is why the program `main;` compiles, surprisingly).", "id": "damer25"}, {"comment": "Uh, I did not know that (but now I do). But in any case, I guess we can all agree that it's bad practice.", "id": "dami0cl"}, {"comment": "This misfeature was removed in C99 though.", "id": "dan0tii"}, {"comment": "That's only true for global identifiers, which this was not.\n\nTBF, though, the for loop doesn't include the `int` keyword either, so presumably we are meant to assume the variable to have been defined previously in the function.", "id": "dan04gk"}, {"comment": "ANSI C, requires it to work for locals as well. IRL, I've only ever seen it used with 'unsigned' and 'register', but it definitely has its place.", "id": "dancajv"}, {"comment": "I love this post. Not on its own, but all the comments pointing out how badly curated this \"awesome\" list is are so entertaining to read. Thanks for taking the time!", "id": "dam9pih"}, {"comment": "I usually skim the Reddit comments first to see whether it's worthwhile reading the actual article...  Thanks for saving me some time!  :)", "id": "dama0jh"}, {"comment": "There's some real gems in there if you want to farn karma over at /r/badcode (though /r/badinterviews might be better if that's a thing) ", "id": "danuydr"}, {"comment": "> Maybe you're interviewing different coders than I am, but if I find myself seriously wondering whether you even know how to increment something, I think we can safely end the conversation right there. Thank you for your time, but this isn't a good fit.\n\nI was asked \"how do you declare a pointer?\" *(scratching my head looking for the trap)* \"Er... with a star?\" \"Correct!\". After 20 years of C programming :-/    (and I didn't get the job.)", "id": "damqpb6"}, {"comment": "    for (a=1; a<=5; i++) {\n        for (b=1; b<=a; b++)\n            printf(\"%d\",b);\n        printf(\"\\n\");\n    }\n\nROTFL.", "id": "damrd3w"}, {"comment": "Haven't even read the list yet... but your telling me I shouldn't even if I just had my first technical interview last week?", "id": "damnke1"}, {"comment": "Find a different list. This list is just plain nonsense. ", "id": "damtoge"}], [{"comment": "What's it curated by, a regex? Here's the first link I followed for Postgres questions: http://nazafbtemplate.blogspot.co.uk/2014/06/frequently-asked-basic-postgresql.html", "id": "dalzr0z"}, {"comment": "Also it seems very much focused on languages, when (imo) the ideal interview question doesn't really care about the language you use. ", "id": "dam0ws0"}, {"comment": "Yeah, but who's ever been asked an ideal interview question?", "id": "damjh4g"}, {"comment": "Depends on the position and the resume", "id": "danfdmb"}], [{"comment": "How long until we get a curated list of lists of lists of interview questions?", "id": "daly3pg"}, {"comment": "As soon as some undergrad receives an answer to the question: \"but how about sorting _lists of lists of lists_?\"", "id": "dam0q3z"}, {"comment": "inb4 list of types of lists", "id": "dam0z1u"}, {"comment": "Don't be silly, that's far too much abstraction.", "id": "dalz3rc"}, {"comment": "Is this [meta](https://www.reddit.com/r/programming/comments/5fpghn/zerocost_abstractions/)?", "id": "dam1chs"}, {"comment": "May I present you [awesome-awesome](https://github.com/bayandin/awesome-awesomeness)?", "id": "dam15f7"}, {"comment": "> awesome-awesome\n\nPlease don't.", "id": "dam9g4n"}, {"comment": "> awesome-awesomeness\n\nFTFY", "id": "damkvh2"}, {"comment": "How long until they're actually curated?", "id": "dam6u4h"}], [{"comment": ">Write a program to show the singleton pattern used in python.\nSingleton patter is used to provide a mechanism that limits the number of instances that can be used by one class. It also allows the same object to be shared between many different parts of the code. This allows the global variables to be used as the actual data that is used is hidden by the singleton class interface. The singleton class interface can have only one public member and one class method Handle. Private constructors are not used to create an object that is used outside the class. The process waits for the static member function to create new instances and return the singleton object.\nThe code that is used to call the singleton object is:\n\n    Singleton& Singleton::Handle()\n    {\n       if( !psingle )\n       {\n           psingle = new Singleton;\n       }\n       return *psingle;\n    }\n\nI..... what?", "id": "dam26fg"}, {"comment": "I think that's a C++ example you're supposed to convert to Python? Maybe? \n\nExcept the idea of singletons in Python (or any other language that allows for easy monkey patching) makes me cringe really hard.", "id": "dam3xob"}, {"comment": ">Except the idea of singletons ~~in Python (or any other language that allows for easy monkey patching)~~ makes me cringe really hard.\n\njk jk, they have their place.", "id": "dam49lu"}, {"comment": "Only by virtue of occasionally being the least bad solution ", "id": "dam5k0g"}, {"comment": "I don't know, I can count the use cases on the fingers of... one finger (Null Object Pattern).", "id": "damvnik"}, {"comment": "It's not even a *good* singleton in the wrong language!\n\n    Singleton& Singleton::Handle() {\n        static Singleton instance;\n        return instance;\n    }\n\nThere. Short, simple, easy to read, thread safe, exception safe, and no dynamic allocation. Still not Python, though.", "id": "damasv4"}, {"comment": "There's a weird edge case there with  destruction order where if someone keeps a pointer to the instance, you can get unexpected errors at program exit. Slightly safer is:\n\n    Singleton& Singleton::Handle() {\n      static auto* instance = new Singleton;\n      return *instance;\n    }", "id": "dambqi4"}, {"comment": "And who deletes `instance`?\n\nI'm of the opinion that if you're hanging on to a pointer and using it past the destruction of a static class you get what's coming to you, unless I'm missing something :P", "id": "damcagx"}, {"comment": "Unless Singleton represents something that has to be destructed for external reasons (e.g., its destructor makes a call to finalize state in a database, although that would be weird for a singleton), it doesn't matter - the OS cleans up the leaked memory and so forth at process termination.\n\nThe problem only arises in certain cases where you've given a pointer to the singleton instance to another static-lifetime object, so it's mostly academic anyway.", "id": "damchyb"}, {"comment": "Eh, I can see that advantage of that - weird edge-case agreed - but valid nonetheless!", "id": "damcqsj"}, {"comment": "We have this issue because we do leak checking at shutdown - got around it by having a registry for Singletons and destructing them in reverse order.", "id": "damf3qd"}, {"comment": "Care to elaborate or link an article? Is the problem just that static objects are torn down in an unspecified order?", "id": "damloqr"}], [{"comment": "Over the past five years, I have developed a set of heuristics I would like to believe help me wade through the enormous range of programming resources I am bombarded with every day. They are simple rules of thumb to help sort the wheat from the chaff. I am of course but a journeyman, not a master, and I cannot say these heuristics shall always hold true. And I use them sceptically - we must always be vigilant that the habits and prejudices we establish do not wall us off from fresh perspectives and new ways of thinking.\n\nNevertheless, I think there is one heuristic I can bet on safely. It is this:\n\n> All programming articles whose titles employ the word 'awesome' are hot, molten clumps of real human excrement\n\nThe second I would tender to this community is as follows:\n\n> The self-serving arrogance and self-assuredness of the term 'curated' indicates the the author is a purveyor of hot, molten clumps of real human excrement.\n\nAnd a final, tentative rule of thumb I have alighted upon over the years:\n\n> Any company that interviews engineers using 'language pearls' questionnaires is hopelessly unqualified to manage them. Any job there will be akin to lowering your head into a pneumatic tube firing hot, molten clumps of real human excrement.", "id": "dam98qx"}], [{"comment": "Had a look at some of the lists for C. One of the questions was \"Write a program that outputs \"Hello World\" without using a semi-colon\".\n\nWhy would you ever need to do that to solve a real problem? Although, I suppose it tests your problem solving skills...\n\nFor reference, a possible solution:\n\n    #include <stdio.h>\n    int main() {\n        if (printf(\"Hello World!\\n\")) {}\n    }", "id": "dam4q28"}, {"comment": "And just for the lolz, [here's the solution it actually suggests](http://quiz.geeksforgeeks.org/commonly-asked-c-programming-interview-questions-set-1/):\n\n    int main(void)\n    {\n        if (printf(\"Hello World\")) ;\n    }\n\n\"Curated\" is the wrong word. \"Spewed\" seems more appropriate.", "id": "dam5iaz"}], [{"comment": "That this is #1 on /r/programming this morning sort of highlights exactly why I don't visit this sub much anymore. I'm only here now because I clicked through to this post from the front page.\n\nAlso, most of the best discussions are posted here hours after they're posted on HN.\n\nIn before \"Unsubscribe then\".", "id": "dam7g5d"}, {"comment": "Serious question: Ya, signal to noise on /r/programing is variable but where do you find a diverse community of opinion? HN has it's own echo chamber. Various language or platform specific subs have their scope limitations. ", "id": "dam9lca"}, {"comment": "Yeah, I really don't know.\n\nHN has its issues, but thinking about it I believe one reason I like it is that it's a fairly good one-stop-shop for generic tech news. I.e. right now there is some good discussion about all of the AWS announcements coming out of AWS re:Invent conference.\n\nReddit can sort of do that if I subscribe to the right subreddits, and if they don't degrade to image macro shitposting. But it takes a lot more management on my end to find, subscribe, maybe make multi-reddits (like the idea of this feature, but have ended up not using it for whatever reason), etc.\n\nhttps://lobste.rs/ is pretty cool, as you get a generic front page, but you can dig into areas of interest through the tags. I would be very happy if that site took off. Or if HN stole that feature.", "id": "damev4z"}, {"comment": "I upvoted this submission because it is hilariously bad.", "id": "damfmq2"}], [{"comment": "Hmmm. Let's see, for Java\n\n> 20 Essential Java Interview Questions\n\nhttp://www.toptal.com/java/interview-questions\n\nFirst thing they do is ask me a billion questions about my name, my company's name, who I am trying to hire, my email, my skype name... Nope.\n\nNot curated. Not reasonable. Useless list.", "id": "dam47s4"}], [{"comment": "> **What does ruby name refers to?**\n\n> * Ruby names refer to the classes, variables, methods, constants and modules that help in the creation of the program. \n>\n> * These are the names that distinguish other names with the specified ruby names that are being mentioned above.\n> * Ruby names are useful and used to be written as it is shown. They are useful in the context of writing the programs and while generating the module. \n> * Ruby names refer to the classes that has to be built and through which the objects will be declared, and methods that will perform on the data that is given.\n> * The names are reserved such that they can\u2019t be used anywhere else and for any other purpose. The name that is used can be in lower or upper case, letter, number or an underscore.\n\nThis made me stupider.\n", "id": "dame0i2"}], [{"comment": "I had a cursory glance at the C++ questions, and I feel like a lot of what is asked is technicalities about the language and none of which helps you understand if the candidate can write or design good software.", "id": "dam2lqp"}], [{"comment": "it s shit", "id": "dam3wvs"}], [{"comment": "One of the C++ ones:\n\n> Do you think the following code is fine? If not, what is the problem?\n\n> T *p = 0;\n> delete p;\n\n> \\- No, the code has a problem. The program will crash in an attempt to delete a null pointer.\n\nWhat ? No it won't...", "id": "dambsxw"}], [{"comment": "Looking at some of the languages I am proficient in, I can honestly say the \"curator(s)\" do not understand the languages in question.  Stop up-voting this crap.", "id": "dam5646"}], [{"comment": "I read some java interview questions and they were crap, considering how people from the other languages are complaining I'd say a removal of the \"awesome\" seems fitting", "id": "dam3mw2"}], [{"comment": "Followed through to the first list of Python questions: [Python interview questions and answers - freshers, experienced](http://www.careerride.com/python-interview-questions.aspx)\n\nFirst of all, 100% of the code examples are formatted incorrectly. Is part of the prep fixing their examples?\n\nThe author is universally unclear, ere are some good examples:\n\nWhat are the ways to write a function using call by reference?\n\n* In the function?  Call the function by reference? What the writer actually means is \"How can you write a function that takes a reference to an object as its argument?\"\n\nHow can the ternary operators be used in python?\n\n* They can't, Python has no ternary operator.  It has a logical expression with similar results, which is what the author mentions.\n\nHow the string does get converted to a number?\n\n* Typically when asked this question, I would expect the interviewer to want some insight into how the actually code works - i.e. the \"How\".  The question the author answers here is \"What should you do to convert a string to a number?\"\n\nPast this point in the article the questions look like copy/pasted code from the internet combined with literally nonsensical questions and answers.\n\nPerhaps the later entries are better, couldn't be bothered to look any further.", "id": "dam56e4"}, {"comment": "> **How is \u201cself\u201d explicitly defined in a method?**  \n> \u201cSelf\u201d is a reference variable and an instance attribute that is used instead of the local variable inside the class. The function or the variable of the self like self.x or self.meth() can be used in case the class is not known. There are no variables declared as local. It doesn\u2019t have any syntax and it allow the reference to be passed explicity or call the method for the class that is in use. The use of writebaseclass.methodname(self, <argument list>) shows that the method of \\_init\\_() can be extended to the base class methods. This also solves the problem that is syntactic by using the assignment and the local variables. This tells a way to the interpreter the values that are to be used for the instance variables and local variables. The use of explicit self.var solves the problem mentioned above.", "id": "damxk80"}], [{"comment": "OK I am not a programmer per trade but I found this in one of the question involving C++\n\n> Which type is best suited to represent the logical values?\n> \n> a) integer\n> \n> b) boolean\n> \n> c) character\n> \n> d) all of the mentioned\n\nI would say depending on the situation a and b.\n\nSince an int can be evaluated like a bool as false if 0 and true if different than 0 one can associate different instances of success or failure to an int, since by default if( var ) is equivalent of if( var!=0 )\n\nPlus, from personal experience, maybe because I am terrible at coding, in some cases vector<bool> might not be great because the structure is adapted for low memory footprint by getting only one bit per entry in the vector, which depending on the machinery that you have around, might cause issues.", "id": "dam2yz4"}], [{"comment": "> Which is used to tell the computer that where a pointer is pointing to?", "id": "dam6ifb"}], [{"comment": "I took a look and agree with the general sentiment here that what I saw was... less than good. But I didn't downvote it for one reason: real-life employers actually ask these questions and it's handy to know answers to some of the weird ones. Something something \"but if they ask silly questions the job can't be that good\" I hear someone say. Not true. For some reason really competent engineers at good companies I'd like to work for still ask reaaaaaly bad interview questions.\n\nI think it's akin to the problem I see with people teaching natural languages: they always seem to teach a language they don't speak themselves in daily life, only in polite circumstances (think a speech). Then the student goes into a pub after a year of learning, say, German, and doesn't understand anything anyone says.", "id": "dam9xze"}], [{"comment": "Here's a good interview question:\n\n\"Tell me about the most interesting thing you worked on or most interesting problem you had to solve?\"\n\nAnd then discuss.\n", "id": "damfrrt"}, {"comment": "That's the one I ask.  I thought I invented it! :)", "id": "damizku"}, {"comment": "I wish I invented it.  It's just what I converged on after hundreds of interviews.  I usually ask a few tech questions but mostly to figure out if they know how a computer works.  Most software people don't anecdotally (I don't hold it against them but it's nice if they do).\n\n", "id": "damkjq7"}], [{"comment": "\"Would you rather fight one horse-sized duck, or 100 duck-sized horses?\"", "id": "damq8di"}], [{"comment": "Is there a curated awesome list of curated awesome lists?", "id": "dam3gd1"}, {"comment": "\nThere's a curated list of awesome lists of awesome lists.\n\nhttps://github.com/sindresorhus/awesome-awesome-awesome-awesome", "id": "dam3i54"}], [{"comment": "Wow, these are really bad. ", "id": "damct2e"}], [{"comment": "Everyone (including myself) agrees this list is shit. Which demands this question: is there a non-shit curated list like this?", "id": "dame2rj"}, {"comment": "No, interview questions aren't something you should need to study for.", "id": "damqbrt"}], [{"comment": "This list isn't curated...", "id": "damv7bz"}], [{"comment": "and of all the things programmers and redditors need, nothing about soft skills.", "id": "dalz3d3"}], [{"comment": "SQL Lite. ", "id": "dam7et9"}], [{"comment": "Some of the C# questions were good. ", "id": "damaqax"}], [{"comment": "I would like to see a list of interview excercises, or do-it-at-home excercises to give to an interviewee. Excercises are often more useful and give a better indication of one's skills then some interview questions or quiz.", "id": "damdp7p"}], [{"comment": "This isn't a curated list. It's just a list of hundreds of links to hundreds of questions. No commentary whatsoever. Useless. ", "id": "damh4s6"}], [{"comment": "OP forgot a /s at the end of the title.\n", "id": "damh572"}], [{"comment": "Lots of mistakes in the \"C\" list.  Small errors, outdated assumptions, typos that would change the context.\nI have not looked into the rest yet.\n", "id": "damiy1q"}], [{"comment": "> 21) What is wrong with this statement? myName = \u0093Robin\u0094;\n\n>Answer:You cannot use the = sign to assign values to a string variable. Instead, use the strcpy function. The correct statement would be: strcpy(myName, \u0093Robin\u0094);\n\nWho said it was a string? I see no declarations of either of those fields, for all I know they were defined with scalar types and are perfectly valid.", "id": "damr3dy"}, {"comment": "Answer: `;` is used to begin a comment in an INI file but has no special meaning the end according to `GetPrivateProfileString`. You must put comments on their own lines in INI files.", "id": "dand9g9"}], [{"comment": "Checked out the C# ones, I can see some of them being useful.\n\nI find these questions are very subjective. It's more much interesting and engaing if you pair programme with the interviewer and attempt to solve a problem together.\n\nThat establishes whether or not you can problem solve and pair with another programmer which would show some semblance of interpersonal skills.", "id": "dam45lb"}, {"comment": "The C# ones are medicore to terrible, other than the first link which is actually fairly reasonable.", "id": "dam7fwy"}, {"comment": "No, this is hot garbage. At best they are generic programming questions that have no bearing on candidates knowledge of c#. At worst they are trying to obfuscate a question about some language feature. ", "id": "dam9fj8"}], [{"comment": "Curated.", "id": "dam76ks"}], [{"comment": "Looking at some of the languages i was like \"Fuck yea. I know these stuff so i can get a job\" came to the comments...i see i was wrong.", "id": "damfsmw"}], [{"comment": "maybe good for studying to answer interviewer's bad questions, but don't ask these yourself", "id": "dami6x2"}], [{"comment": "So as a learning developer I have no idea why this is apparently a terrible list, having never interviewed. Can anyone point me to an actually awesome list of interview questions instead? (Note: I'm learning C# and .Net) ", "id": "damidnb"}, {"comment": "\"Tell me about the most interesting technical problem you've solved, and how you did so\"\n\n\"Explain to me how computers / the internet / your operating system actually works\"\n\n\"How do you stay on top of changes in the industry?\"\n\n\"Tell me about a time someone changed your mind regarding a technical decision\"\n\n\"Why are you a programmer?\"\n\n\"Why are you learning C# and .net? How do they compare to other technologies?\"\n\n\"When does performance matter?\"", "id": "dammiyk"}, {"comment": "Keep learning and coding, you shouldn't have to study specifically for interview questions and when your a junior it's OK to not be an expert on every vague language feature.", "id": "damqgu3"}], [{"comment": "[\"I've never killed a man.\"](https://www.youtube.com/watch?v=ngu0RKsv3qE&t=30s)", "id": "dandobz"}], [{"comment": "Well, why all of this hate on this post? I'm not a professional programmer, I'm phd student and I use python in my daily work. I found some of the [related questions](https://www.toptal.com/python/interview-questions) really interesting.", "id": "daneuf2"}]]], "5g2xgg": ["Int64 & Uint64 are now Stage 1 proposals for an ECMA-262 future edition, AKA \"JS\"", "2016-12-02 15:08:41", 8, "https://mobile.twitter.com/BrendanEich/status/804121369910734849", [[3, "Awesome"], [3, "Aww, but the whole \"Javascript may not be waterproof, but at least it always floats\" is one of my favorite jokes :-("], [1, "Why?"]], [[{"comment": "Awesome", "id": "dapd9kv"}], [{"comment": "Aww, but the whole \"Javascript may not be waterproof, but at least it always floats\" is one of my favorite jokes :-(", "id": "dapt7ll"}], [{"comment": "Why?", "id": "dap59ma"}, {"comment": "Better question is why did it take so long. JavaScript needs an integer type if you're going to actually use it for serious software development.", "id": "dapbybp"}, {"comment": "Could you provide a use-case? Or do you mean for performance?\n\nI just find it weird to add data types into a language like Javascript, but perhaps it won't get as complex as I'm seeing it my mind.", "id": "dapo0rw"}, {"comment": "> Could you provide a use-case?\n\nAccording to https://mobile.twitter.com/BrendanEich/status/804407811094384640 :\n\n> goal is to make asm.js subset fast as safe native.\n\nSo Emscripten and similar tools.", "id": "dapqnca"}, {"comment": "Hmmm... I love asm.js but I cannot imagine it surviving as webassembly is coming up.", "id": "dapsq67"}, {"comment": "It's likely that the actual backend for wasm and asm.js will be the same (or at least could be), the difference will be the bytecode/representation over the wire.\n\nThere's plenty of reason to use asm.js over wasm for quite some time, probably at least a few years until support for wasm is widespread.", "id": "dapu7go"}, {"comment": "> It's likely that the actual backend for wasm and asm.js will be the same (or at least could be), the difference will be the bytecode/representation over the wire.\n\nI'm not sure it _will_ be, but actually is. Wasm is in alpha (or some other state), and you could download Firefox developer edition (or any other bleeding edge firefox version) and run webasm today, and IIRC it will be subject to be enabled by default in Q1 2017.  \nAs far as I can tell (I haven't read up about it all too much), it will share some kind of backend with asm.js. So yes I agree, that's the entire reason I believe asm.js will die.  \nMozilla realized you could make Javascript really fast by using a subset of Javascript to let the JIT go wild. Other project/companies (and Mozilla) saw Mozilla's work but realized that there were no actual reason to target _Javascript_, so they instead came up with webassembly.\n\n> There's plenty of reason to use asm.js over wasm for quite some time, probably at least a few years until support for wasm is widespread.\n\nI don't want to sound all too pessimistic, because I like asm.js.  \nCould you give me any reason? The benchmarks I've seen and from my own tests it's just as good as asm.js, possibly getting better over time.\n\nThere is no widespread support for asm.js and there has never been. wasm is basically the next iteration of asm.js, but with the whole web community on it.\n\nWhile I agree that it will take a few years before wasm will be useful, I don't necessarily agree that it will be because of browser support (Firefox/Chrome uses rolling releases and Microsoft Edge has been releasing new features rapidly as well... Apple doesn't care about Safari though so that could be potential problem).  \nI'm more looking forward for potential frameworks being built in a language and then compiled to wasm, but that will probably take some time before they materialize. I see no real reason why we're using frameworks like Angular and React with Javascript, because right now, we are really not using Javascript anymore. React uses JSX and Angular uses Typescript. I know that you can skip those features, but it's not very nice or good without them. And they're _not_ Javascript.", "id": "dapv9rd"}, {"comment": "Support for asm.js is actually pretty much universal for any browser implementing typed arrays. Even if they don't optimize it, it's just JavaScript, it can run in any current JavaScript environment.\n\nIf you actually want to use wasm in the wild... you can't. The biggest hurdle to using it will be mobile devices stuck using browsers they can't upgrade. I can pretty much guarantee you we're looking at 2-5 years before it's actually a viable target, whereas asm.js is viable now.\n\nThe fact that a lot of attention and effort is being put into wasm makes asm.js an even _more_ appealing target, because it will be able to take advantage of that effort in a shared backend, while still having universal support.", "id": "daq2w6p"}, {"comment": "If you're just using it on the client, you can live without it.  Now that Node puts it on the server, you don't want shit t turning into floats on you", "id": "dapw3q6"}, {"comment": "Fair point!", "id": "dapw5or"}]]], "5g4fa5": ["A billion user load test on healthcare.gov with Nava\u2019s Scalable Login System", "2016-12-02 20:14:51", 17, "https://blog.navapbc.com/the-billion-user-load-test-ffb035aeb2d6", [[4, "I am a little confused on what the test actually tested?\n\nI am guessing that they were testing how their API handled 8k requests per second when they had a billion users in their database?"]], [[{"comment": "I am a little confused on what the test actually tested?\n\nI am guessing that they were testing how their API handled 8k requests per second when they had a billion users in their database?", "id": "dapnvzu"}, {"comment": ">  they were testing how their API handled 8k requests per second when they had a billion users in their database\n\nLooks like it, where that ~8k requests/sec is 50 times greater than their historical peak load.", "id": "dappomr"}, {"comment": "I got the impression that the 1 billion users was 50 times the number of true users they had in there database.", "id": "daq8eqs"}]]], "5g8h1t": ["What is a virtualenv and how to install it?", "2016-12-03 10:14:45", 0, "http://tutorials.technology/tutorials/10-whats-is-a-virtualenv-and-how-to-install-it.html", [[1, "[Let me google that for you](http://lmgtfy.com/?q=What+is+a+virtualenv+and+how+to+install+it%3F)"], [1, "[Let me google that for you](http://lmgtfy.com/?q=What+is+a+virtualenv+and+how+to+install+it%3F)"], [1, "[Let me google that for you](http://lmgtfy.com/?q=What+is+a+virtualenv+and+how+to+install+it%3F)"], [1, "[Let me google that for you](http://lmgtfy.com/?q=What+is+a+virtualenv+and+how+to+install+it%3F)"], [0, "[Let me google that for you](http://lmgtfy.com/?q=What+is+a+virtualenv+and+how+to+install+it%3F)"], [0, "[Let me google that for you](http://lmgtfy.com/?q=What+is+a+virtualenv+and+how+to+install+it%3F)"], [0, "[Let me google that for you](http://lmgtfy.com/?q=What+is+a+virtualenv+and+how+to+install+it%3F)"], [0, "[Let me google that for you](http://lmgtfy.com/?q=What+is+a+virtualenv+and+how+to+install+it%3F)"]], [[{"comment": "[Let me google that for you](http://lmgtfy.com/?q=What+is+a+virtualenv+and+how+to+install+it%3F)", "id": "daqwrow"}], [{"comment": "[Let me google that for you](http://lmgtfy.com/?q=What+is+a+virtualenv+and+how+to+install+it%3F)", "id": "daqxggy"}], [{"comment": "[Let me google that for you](http://lmgtfy.com/?q=What+is+a+virtualenv+and+how+to+install+it%3F)", "id": "daqxh68"}], [{"comment": "[Let me google that for you](http://lmgtfy.com/?q=What+is+a+virtualenv+and+how+to+install+it%3F)", "id": "daqxj9z"}], [{"comment": "[Let me google that for you](http://lmgtfy.com/?q=What+is+a+virtualenv+and+how+to+install+it%3F)", "id": "daqxa0z"}], [{"comment": "[Let me google that for you](http://lmgtfy.com/?q=What+is+a+virtualenv+and+how+to+install+it%3F)", "id": "daqxzmx"}], [{"comment": "[Let me google that for you](http://lmgtfy.com/?q=What+is+a+virtualenv+and+how+to+install+it%3F)", "id": "daqy4ln"}], [{"comment": "[Let me google that for you](http://lmgtfy.com/?q=What+is+a+virtualenv+and+how+to+install+it%3F)", "id": "daqy50t"}]]], "5geyx9": ["The Full Stack, Part I", "2016-12-04 14:00:21", 4, "https://www.facebook.com/note.php?note_id=461505383919", [], []], "5flf4q": ["What\u2019s new in Git 2.11?", "2016-11-30 00:31:12", 229, "https://medium.com/@kannonboy/whats-new-in-git-2-11-64860aea6c4f", [[19, "More intuitive stash numbers, yay!"], [11, "Yay, finally! Show the diff against the first parent without having to repeat the commit:\n\n    git diff <merge commit>^-1"], [11, "The better diff heuristics are going to be a blessing for anyone who has to review changes. "], [2, "Reading these changelogs (and the Dolphin ones, especially) gets me really motivated.  Nothing makes me want to put my nose to the grindstone like seeing the strides that these FOSS teams make regularly.\n\nI would totally keep git feature changelogs up on the wall as motivational posters."], [-6, "Is git 2 in a stable release? Why is it not the installed version from package managers? Should I get git 2? Is there anything I should know before moving to git 2?"]], [[{"comment": "More intuitive stash numbers, yay!", "id": "dals8jv"}], [{"comment": "Yay, finally! Show the diff against the first parent without having to repeat the commit:\n\n    git diff <merge commit>^-1", "id": "dalsltq"}, {"comment": "This also works:\n\n    git diff <merge commit>^-", "id": "dalx50r"}], [{"comment": "The better diff heuristics are going to be a blessing for anyone who has to review changes. ", "id": "dalulkb"}, {"comment": "That is the change I am most curious about. Does it apply to conflict detection too?\n\n(Sadly, no Windows build yet...)", "id": "dalwa68"}, {"comment": "Iirc gits merge is pretty simple. You have the  parent where both versions started to differ and new versions a and b.\nYou then create a diff for a and b and overlay them over the parent. If they overlap you get a conflict.\n\nThe diff heuristics probably won't change whether the resulting hunks collide so in practice it probably won't affect merging either?", "id": "damphky"}, {"comment": "If you use vim you can mix the power of the improved diff algorithms with the niceness of vimdiff by using [this](https://github.com/LemonBoy/autobahn) small tool.", "id": "dalyqxe"}], [{"comment": "Reading these changelogs (and the Dolphin ones, especially) gets me really motivated.  Nothing makes me want to put my nose to the grindstone like seeing the strides that these FOSS teams make regularly.\n\nI would totally keep git feature changelogs up on the wall as motivational posters.", "id": "dam8dsv"}], [{"comment": "Is git 2 in a stable release? Why is it not the installed version from package managers? Should I get git 2? Is there anything I should know before moving to git 2?", "id": "dalhaox"}, {"comment": "What, exactly, are you talking about? Debian has git 2.1.4 packaged https://packages.debian.org/jessie/git and we all know Debian is the most conservative on package versions. \n\nIf you are still on git 1, well, git 2.0 is a more usable version (which is not hard because git is the antithesis of user friendly but w/e):\nhttps://blogs.atlassian.com/2014/06/happened-git-2-0-full-goodies/", "id": "dali4ne"}, {"comment": "Oh. On Ubuntu, with apt-get, I'm getting 1.9.1. I'm also getting this version when going through chocolatey on Windows.", "id": "dalia85"}, {"comment": "? http://packages.ubuntu.com/xenial/git is 2.7.4 and this is the current LTS.\n\nhttps://chocolatey.org/packages/git.install is 2.10.2", "id": "dalix5o"}, {"comment": "Ok, did some search and found out that, out of the box, it doesn't seem to come with the right repository setup. Had to do this: ~~http://unix.stackexchange.com/questions/33617/how-can-i-update-to-a-newer-version-of-git-using-apt-get~~ http://unix.stackexchange.com/a/170831", "id": "daljydi"}, {"comment": "The hell does your `/etc/apt/sources.list` look like?\n\n**Edit:**\n\nI just looked into my Ubuntu installation from the linux windows 10 doohickey, and it seems that has git 1.9.1 out of the box.\n\nThese are my sources:\n\n    deb http://archive.ubuntu.com/ubuntu trusty main restricted universe multiverse\n    deb http://archive.ubuntu.com/ubuntu trusty-updates main restricted universe multiverse\n    deb http://archive.ubuntu.com/ubuntu trusty-backports main restricted universe multiverse\n    deb http://security.ubuntu.com/ubuntu trusty-security main restricted universe multiverse", "id": "dalold0"}, {"comment": "You're using packages from Trust Tahir, which is Ubuntu 14.04. The version number means it was released in April 2014 and then they don't upgrade major versions (hence why it's stable). \n\nThe most recent LTS (Long Term Support) version of Ubuntu is 16.04: Xenial Xerus..", "id": "dalsy2g"}, {"comment": "I went through that same thing playing with the windows subsystem for linux/ubuntu, though I did notice git was from the stone age pretty quickly, since git for windows stays up to date so well now.\n\nI still can't find anything online that explains _why_ that is the way that it is, only the same (or similar) steps to get modern git on ubuntu.", "id": "dalp2ct"}, {"comment": "I wish I could just use my distro of choice. The whole thing is still in beta though, so I can't really complain.", "id": "dalp6ow"}, {"comment": "Yeah, though the point is it's not just the WSL/ubuntu, it's ubuntu.\n\nI could easily imagine somebody who didn't care _all that much_ (like, maybe, /u/Allov) just trusting ubuntu and assuming that if they don't have a newer version of git it must be a problem with git.", "id": "dalph7b"}, {"comment": "It's *Ubuntu 14.04*. It's a year-and-a-half old LTS release and [Git 2.0 came out a month after](https://git.kernel.org/cgit/git/git.git/tag/?h=v2.0.0) -- unfortunate but necessary.\n\nI've found 14.x particularly painful for other reasons, notably the half-baked systemd migration, and would recommend anyone to move their personal machines either to 16.04 or [off LTS](http://www.tedunangst.com/flak/post/long-term-support-considered-harmful).\n\nWSL almost certainly started before 16.04 was out. Hopefully they can migrate to 16.04. Alternatively, consider using [MSYS2](https://msys2.github.io/).", "id": "dalrtti"}, {"comment": "I've managed to upgrade WSL/ubuntu to 16.x on my Surface Pro 3, basically the steps are:\n\n\tsudo apt-get update\n\tsudo apt-get upgrade\n\tsudo apt-get dist-upgrade\n\tsudo do-release-upgrade\n", "id": "dam0ay0"}]]], "5fq1id": ["An Addiction to Change", "2016-11-30 18:03:04", 10, "https://thoughtsahead.com/2016/11/30/an-addiction-to-change/", [[3, "I am (thankfully) not a professional programmer - I do it for the fun of it mostly.\n\nIn projects, changes are usually necessary, sometimes logical or a \"good choice\".\n\nNecessary if something broke, does not work or some other change requires changes downwards (e. g. a new release of a programming language with slightly diferent semantics).\n\nLogical if something that may not have been thought before, like some feature or a minimal feature, may have a better use case lateron.\n\nA \"good choice\" if it may extend or improve on something, be it speed but also documentation (and documenting the behaviour).\n\nIf a project does not change, either it may already be perfect or simple; or it was not looked at for a really long time.\n\nThe motivation to want to change something is a huge contributing factor. For some of my larger projects, I have a huge todo list. I only work through it every now and then when I feel like it. Without that list, I would have less things to do but I would also know of fewer\nthings to WANT to do, too. So I don't really feel that it is an addiction to change per se for the sake of making a change. Changes often drive projects forward (and sometimes backwards)."], [0, "All kidding aside this is not a healthy attitude. There is nothing novel about programming to justify all the churn. In fact mathematics, physics, chemistry, etc. are much more intellectually demanding and yet they don't move at the same pace as programming. The framework flavor of the week syndrome would not fly in any other engineering circle.\n\nBeing comfortable with the churn is a good survival tactic but let's not pretend it is something to be embraced."]], [[{"comment": "I am (thankfully) not a professional programmer - I do it for the fun of it mostly.\n\nIn projects, changes are usually necessary, sometimes logical or a \"good choice\".\n\nNecessary if something broke, does not work or some other change requires changes downwards (e. g. a new release of a programming language with slightly diferent semantics).\n\nLogical if something that may not have been thought before, like some feature or a minimal feature, may have a better use case lateron.\n\nA \"good choice\" if it may extend or improve on something, be it speed but also documentation (and documenting the behaviour).\n\nIf a project does not change, either it may already be perfect or simple; or it was not looked at for a really long time.\n\nThe motivation to want to change something is a huge contributing factor. For some of my larger projects, I have a huge todo list. I only work through it every now and then when I feel like it. Without that list, I would have less things to do but I would also know of fewer\nthings to WANT to do, too. So I don't really feel that it is an addiction to change per se for the sake of making a change. Changes often drive projects forward (and sometimes backwards).", "id": "dam79uh"}, {"comment": "> If a project does not change, either it may already be perfect or simple; or it was not looked at for a really long time.\n\nThe answer IMHO, has always, always been the latter. You could do code that was perfect and simple in the 90s, but the hardware, considerations and such are different now. You could just wrap on the code and keep the original, but then the wrapping and bending over can get out of hand, at which point you want to change the core.\n\nI agree with you though. Change is not always good or positive. Not all change is cost-effective. And change for the sake of change risks forgetting the lessons of yesterday.", "id": "damiqwg"}], [{"comment": "All kidding aside this is not a healthy attitude. There is nothing novel about programming to justify all the churn. In fact mathematics, physics, chemistry, etc. are much more intellectually demanding and yet they don't move at the same pace as programming. The framework flavor of the week syndrome would not fly in any other engineering circle.\n\nBeing comfortable with the churn is a good survival tactic but let's not pretend it is something to be embraced.", "id": "damio7d"}, {"comment": "> The framework flavor of the week syndrome would not fly in any other engineering circle.\n\nTell that to the homotopy type theorists!", "id": "damvq8m"}, {"comment": "This is my opinion, but I think your statement on 'intellectual demand' is rather disingenuous. Saying that one field is more intellectually demanding than another is empty; in that programming, chemistry, physics and mathematics all span many different subcategories. In fact, they often mesh together. \n\nQuantum computation, machine learning, protein folding analysis, rocket propulsion systems and more are just some examples (and there are more than I can fill in here). Programming is more than just application development - and even that can get complicated. \n\nOn the other hand, the fields you mentioned are not as they seem at face value either. Feynman was a physicist, in the same way anyone else working in physics should be called physicist. That doesn't equalize their intellectual demand. Just some food for though, I guess.", "id": "dan2e8j"}]]], "5gdps4": ["FusionScript 0.1.0 Experimental is now (mostly) stable!", "2016-12-04 07:17:11", 1, "https://gist.github.com/ChickenNuggers/ed4abc97ac56cef4b6fea4f7347f1f39", [[1, "Is there any overall synopsis? What problems does FusionScript try to solve, what does it try to make different/better?"]], [[{"comment": "Is there any overall synopsis? What problems does FusionScript try to solve, what does it try to make different/better?", "id": "darnfgg"}]]], "5fr3qm": ["Introduction to Asynchronous Programming in C#", "2016-11-30 21:08:06", 3, "http://www.jeremykruer.com/introduction-to-asynchronous-programming-in-c-part-2/", [[6, "       [HttpGet]\n        public async Task<List<string>> GetAsync()\n        {\n            return await _syncService.SearchAsync();\n        }\n\n\nThere is no need to await the results only to return an async Task<T>.  Just return the Task<T>.  Doing it that way makes an asynchronous construct only to call it synchronously.   This is better:\n\n       [HttpGet]\n        public Task<List<string>> GetAsync()\n        {\n            return _syncService.SearchAsync();\n        }\n\nThe whole benefit of async/await is being able to start a task and do some other work without getting the task results immediately.\n\n     var searchTask = _syncService.SearchAsync(); //start the search task\n     ... do some other long running tasks\n     return await searchTask; //finish the search task\n\n"], [1, "Transcript or blog entry for part 1, please."]], [[{"comment": "       [HttpGet]\n        public async Task<List<string>> GetAsync()\n        {\n            return await _syncService.SearchAsync();\n        }\n\n\nThere is no need to await the results only to return an async Task<T>.  Just return the Task<T>.  Doing it that way makes an asynchronous construct only to call it synchronously.   This is better:\n\n       [HttpGet]\n        public Task<List<string>> GetAsync()\n        {\n            return _syncService.SearchAsync();\n        }\n\nThe whole benefit of async/await is being able to start a task and do some other work without getting the task results immediately.\n\n     var searchTask = _syncService.SearchAsync(); //start the search task\n     ... do some other long running tasks\n     return await searchTask; //finish the search task\n\n", "id": "damrke5"}], [{"comment": "Transcript or blog entry for part 1, please.", "id": "damkuoy"}, {"comment": "https://www.youtube.com/watch?v=zPCUgEg2l2A\n\nFrom a quick read part 1 is apparently a video, I was fooled for a while xD", "id": "damw3t2"}]]], "5fqv4s": ["Three Stories about the Digital Divide (18 min video+links)", "2016-11-30 20:27:51", 1, "https://codeandtalk.com/v/accessibility-camp-new-york-2016/01-luke-swarthout-three-stories-about-the-digital-divide", [], []], "5g4h20": ["Building fast numerical software", "2016-12-02 20:23:24", 2, "https://bandgap.io/blog/fast_numerical_software/", [[2, "I wouldn't link to a website still full or Lorem Ipsum personally, doesn't give a good impression.\n\nAnyway. Perf seems awesome even if I can't read assembly.\n\nImho the real thing to remember is : vectorize then do everything using a good BLAS"]], [[{"comment": "I wouldn't link to a website still full or Lorem Ipsum personally, doesn't give a good impression.\n\nAnyway. Perf seems awesome even if I can't read assembly.\n\nImho the real thing to remember is : vectorize then do everything using a good BLAS", "id": "dapflul"}, {"comment": "Actually, I was thinking about adding a discussion of BLAS, but somehow it slipped my mind.\n\nThanks for inducing me into fixing the lorem ipsum; now the most embarrassing part of the site is the simple cubic favicon :)", "id": "dapq3ty"}]]], "5g8opd": ["Lineage-driven Fault Injection", "2016-12-03 11:28:05", 0, "https://people.ucsc.edu/~palvaro/molly.pdf", [], []], "5gezdx": ["The history of the name Google", "2016-12-04 14:04:46", 1, "http://www.pixelstech.net/article/1480818179-The-history-of-the-name-Google", [], []], "5ga28g": ["Quick multiplication overflow test (bit hacks).", "2016-12-03 18:38:08", 0, "https://lion137.blogspot.co.uk/2016/12/effective-overflow-testing-bit-hacks-ii.html", [[1, "Both [gcc](https://gcc.gnu.org/onlinedocs/gcc/Integer-Overflow-Builtins.html) and [clang](http://clang.llvm.org/docs/LanguageExtensions.html#builtin-functions) have builtin functions for that which are much faster. Also you should test your functions to make sure they actually work correctly."]], [[{"comment": "Both [gcc](https://gcc.gnu.org/onlinedocs/gcc/Integer-Overflow-Builtins.html) and [clang](http://clang.llvm.org/docs/LanguageExtensions.html#builtin-functions) have builtin functions for that which are much faster. Also you should test your functions to make sure they actually work correctly.", "id": "daqozrb"}, {"comment": "Actually, I didn't know that, anyway good, that they are here. I checked performance, there is no difference between built and those functions.  ", "id": "daqqrj3"}, {"comment": "My guess is that you did not use the result and the compiler got rid of the whole computation. If you do something with it, gcc's function will be [over 10 times faster](http://ideone.com/X3iswI). You should also have a look at your `unsigned_long_overflow` function again and write tests for it. Keep in mind that the size of `unsigned long` does not have to be 64 bit. I'd also suggest that you post to /r/learnprogramming or http://codereview.stackexchange.com/ instead of /r/programing.", "id": "daqueay"}, {"comment": "In my machine,  compile:r (gcc (Ubuntu 5.4.0-6ubuntu1~16.04.4) 5.4.0 20160609) unsigned long max value = 2 ^ 64 - 1; I've heavily tested this function against naive. \n", "id": "darln4a"}]]], "5g3kxm": ["\u201cPerformance is a feature\u201d \u2014 Interview with Marco Cecconi, Stack Overflow \u2013 Medium", "2016-12-02 17:41:49", 2, "https://medium.com/@JUGru/its-all-about-the-performance-interview-with-marco-cecconi-stack-overflow-5be0347dccb#.whrzhxtgu", [], []], "5g86g3": ["Reflections on Rusting Trust", "2016-12-03 08:46:56", 5, "https://manishearth.github.io/blog/2016/12/02/reflections-on-rusting-trust/", [], []], "5g6ezx": ["How Do Software Developers in New York, San Francisco, London and Bangalore Differ?", "2016-12-03 02:03:26", 25, "http://stackoverflow.blog/2016/11/How-Do-Developers-in-New-York-San-Francisco-London-and-Bangalore-Differ/?cb=1", [[13, "Accumulated wealth and earnings potential, mostly."], [8, "We are developers working a lot with Bangalore. We find they have to check with their manager for everything and they don't last long. Here in France, management gives more general goals and as long as the company does well, we do well. France is weird, an individualistic community. We don't think much anymore about San Francisco or London - they look like developer ghost towns with nothing but managers and marketing."], [3, ".Net is popular in Delhi, India too."], [3, "The extra you get with Bangalore developers is strict process adherence. \n\nIf you want to get something done quickly, send it to India and watch 100 programmers implement it in a week, all following the same process for development and QA.\n\n\n\n"], [-1, "Wow, lots of use for that dead, awful language! :-)"], [-11, "A San Franciscan developer loves to talk concepts. \n\nA New Yorker developer just gets the job done. \n\nA Londoner developer is extinct. \n\nA Bangalorean developer just copies from StackOverflow. \n"]], [[{"comment": "Accumulated wealth and earnings potential, mostly.", "id": "daqcx2z"}], [{"comment": "We are developers working a lot with Bangalore. We find they have to check with their manager for everything and they don't last long. Here in France, management gives more general goals and as long as the company does well, we do well. France is weird, an individualistic community. We don't think much anymore about San Francisco or London - they look like developer ghost towns with nothing but managers and marketing.", "id": "daqmu9r"}, {"comment": "I don't know why you're saying SF is a develop ghosttown, literally every other person there is a developer (also, Sunnyvale is Silicon Valley but it's not SF)", "id": "dar4mhz"}, {"comment": "Could you please elaborate? I thought that the job market for developers in SF is really hot. Any sources?", "id": "daqxcgf"}, {"comment": "Just me. I had a fix mission to Synopsys in Sunnyvale and all I saw was empty cubes surrounded by managers' closed boxes. Same with Cadence. The devs are all in India, we talk to them every day with cc: to handlers in CA.", "id": "daqy4eb"}], [{"comment": ".Net is popular in Delhi, India too.", "id": "daqkc5q"}], [{"comment": "The extra you get with Bangalore developers is strict process adherence. \n\nIf you want to get something done quickly, send it to India and watch 100 programmers implement it in a week, all following the same process for development and QA.\n\n\n\n", "id": "daqxrw4"}, {"comment": "The loss you get is the process does not do anything but fix bugs. There is no improvement.", "id": "daqynnd"}, {"comment": "It depends on the company you outsource to. The ones that follow strict processes are very good at both implementation and QA. However, a common flaw is the lack of innovation and creativity. Basically, if the offshore developers encounter a repeat situation, they will find the resolution in their process; faced with a novel situation, they will struggle much more than, say, a developer in London. At least, that is how it has been, based on my experience heading a mixed team of local and offshore developers.", "id": "daqyxct"}], [{"comment": "Wow, lots of use for that dead, awful language! :-)", "id": "daqtvo0"}], [{"comment": "A San Franciscan developer loves to talk concepts. \n\nA New Yorker developer just gets the job done. \n\nA Londoner developer is extinct. \n\nA Bangalorean developer just copies from StackOverflow. \n", "id": "daqe6u6"}, {"comment": "Extinct?", "id": "daqglrs"}]]], "5g4ecv": ["Another version of Ray (a python web framework) released", "2016-12-02 20:10:20", 0, "https://medium.com/@felipevolpone/ray-0-2-released-7c354bf21a1f#.s3ug5o6w8", [], []], "5fzzml": ["ML Type-System Paper Explained (by Eric Lippert)", "2016-12-02 02:29:28", 36, "https://ericlippert.com/2016/11/30/4498/", [[6, "> I\u2019ve asked a number of ML and Haskell experts why this is, and they usually say something about how it is \u201cmore natural\u201d to say \u201cstring list\u201d, but this is question-begging; it is only \u201cmore natural\u201d because that\u2019s what you\u2019re used to seeing! VB solves the problem with \u201cList of String\u201d, which seems far more \u201cnatural\u201d to me than \u201cstring list\u201d.\n\nParameterized types are a bit like applying adjectives to nouns (`steam engine`), or adverbs to verbs (`quickly accept`). Sure the example `List of String` works out because it's a collection of something.\n\nSomething like `readonly permission` is only a little awkward as `permission of readonly`.\n\nBut that `engine of steam` is starting to convey the wrong idea because 'of' adds its own implications.\n\nHow about `local cloud` vs `cloud of local`, ugh. :)\n\n---\n\n*However*, I'm surprised at the survey of ML and Haskell experts... because Haskell puts the type parameters on the right:\n\n    datatype Tree a = Leaf a | Branch (Tree a) (Tree a)\n\nAnd, while the OCaml equivalent is this:\n\n    type 'a tree = Leaf of 'a | Branch of 'a tree * 'a tree\n\n(Protip: in Vim I use conceal-char to render single-quote+alpha as greek, as these type parameters are usually presented in documents.)\n\nIn the OCaml community I've often heard the parameters on the left was an unfortunate choice. Many would prefer them on the right, harmonious with function arguments. Myself, I've come to prefer the type parameters on the left, but some smarter people than me even wish OCaml went to the right, and seem to have sound reasons for it (which I can't find reference to now...).\n"]], [[{"comment": "> I\u2019ve asked a number of ML and Haskell experts why this is, and they usually say something about how it is \u201cmore natural\u201d to say \u201cstring list\u201d, but this is question-begging; it is only \u201cmore natural\u201d because that\u2019s what you\u2019re used to seeing! VB solves the problem with \u201cList of String\u201d, which seems far more \u201cnatural\u201d to me than \u201cstring list\u201d.\n\nParameterized types are a bit like applying adjectives to nouns (`steam engine`), or adverbs to verbs (`quickly accept`). Sure the example `List of String` works out because it's a collection of something.\n\nSomething like `readonly permission` is only a little awkward as `permission of readonly`.\n\nBut that `engine of steam` is starting to convey the wrong idea because 'of' adds its own implications.\n\nHow about `local cloud` vs `cloud of local`, ugh. :)\n\n---\n\n*However*, I'm surprised at the survey of ML and Haskell experts... because Haskell puts the type parameters on the right:\n\n    datatype Tree a = Leaf a | Branch (Tree a) (Tree a)\n\nAnd, while the OCaml equivalent is this:\n\n    type 'a tree = Leaf of 'a | Branch of 'a tree * 'a tree\n\n(Protip: in Vim I use conceal-char to render single-quote+alpha as greek, as these type parameters are usually presented in documents.)\n\nIn the OCaml community I've often heard the parameters on the left was an unfortunate choice. Many would prefer them on the right, harmonious with function arguments. Myself, I've come to prefer the type parameters on the left, but some smarter people than me even wish OCaml went to the right, and seem to have sound reasons for it (which I can't find reference to now...).\n", "id": "daojhom"}, {"comment": "> Parameterized types are a bit like applying adjectives to nouns (steam engine), or adverbs to verbs (quickly accept). Sure the example List of String works out because it's a collection of something.\n\nThis becomes an especially trenchant point once you start thinking of parameterized types as type-level functions. Even better if your language is dependently-typed and actually _does_ offer type-level functions.", "id": "dapbznz"}, {"comment": "Type level functions and type dependency are two separate features. You can see this by looking at the lambda cube where systems with only type dependency, only type level functions, and both exist.", "id": "daqfau7"}, {"comment": "Of course. Even in Scala, we use \"type-level functions\" thanks to type-constructor polymorphism, and even have \"the type lambda trick\" to do partial application at the type level. I'm just thinking of the dependently-typed languages I know of in practice (primarily Coq and Idris) where type-level functions are (often) described as such.", "id": "daqobw6"}]]], "5g1qgo": ["Code is Better when We Write it Together - 8th Light Blog - \"Pairs Go Faster\"", "2016-12-02 09:01:12", 3, "https://8thlight.com/blog/daniel-irvine/2016/11/28/code-is-better-when-we-write-it-together.html", [[1, "This blog post, like all others on the topic, fail to touch on the sensitive subject of skill level difference between the pair. I consider myself a very good dev and I program at a pace 3-4 times of most of my coworkers. How would my coworkers be able to keep up if we're doing pair programming? Or how would I avoid becoming extremely frustrated, if I was watching them work at a much slower pace than me?"]], [[{"comment": "This blog post, like all others on the topic, fail to touch on the sensitive subject of skill level difference between the pair. I consider myself a very good dev and I program at a pace 3-4 times of most of my coworkers. How would my coworkers be able to keep up if we're doing pair programming? Or how would I avoid becoming extremely frustrated, if I was watching them work at a much slower pace than me?", "id": "daoz228"}, {"comment": "> How would my coworkers be able to keep up if we're doing pair programming?\n\nDaily paired-programmer here.  Part of pairing is helping each other learn and become better programmers.  You're 3-4 times faster than your co-workers?  Great!  Now help them become 3-4 times faster too by teaching and sharing what you know (this works both ways obviously).  Now pair-switch, and the entire team speeds up.  Yes, this means you slow down in the short term, but in the long term everyone speeds ups. This also helps to reduce the \"[bus factor](https://en.wikipedia.org/wiki/Bus_factor)\", as everyone starts getting exposed to more and more of the codebase.\n\n> Or how would I avoid becoming extremely frustrated, if I was watching them work at a much slower pace than me?\n\nPairing isn't one person coding while the other person sits idly by and getting frustrated at their partner's slow pace.  It should be a collaborative effort, and if you see a better way to do things then speak up, your pair will thank you for it. \n", "id": "dap0fqz"}, {"comment": "Those are both valid points. But to me they bring value to my employer, not me personally as a developer.", "id": "dap4dpy"}, {"comment": "I get that. So, from my point of view I get more joy out of working on a high functioning team that can move quickly and get things done.   It is supremely frustrating to work with devs that are behind the curve,  and I'd rather spend some of my time building them up than continue to deal with that frustration.  It's definitely an investment to do this though. ", "id": "dap5lch"}]]], "5fzauj": ["VirtualMouse of Whitestorm framework. Picking objects in 3D apps \u2013 WhitestormJS Framework", "2016-12-02 00:29:10", 0, "https://medium.com/whitestormjs-framework/virtualmouse-of-whitestorm-framework-picking-objects-in-3d-apps-15f7b785d867#.lnehfcrwr", [], []], "5fyhjb": ["Golang's Real-time GC in Theory and Practice - Pusher Blog", "2016-12-01 22:13:50", 100, "https://blog.pusher.com/golangs-real-time-gc-in-theory-and-practice/", [[14, "Nice visualization.\n\nGo goes from strength to strength with every release."], [13, "The Java GC has some conservative initial parameters. There's no obvious way to bring the max pause time down to the level of some of these other languages, which are very impressive, but it can be a lot better than what this article indicates.\n\nI downloaded the benchmark they used, and tried a few different tuning parameters using the G1 GC:\n\n* Baseline: 73ms max pause, 45 ms average\n* -Xmx800m (800 MB heap):  43 ms max, 18 ms average\n* -Xmx400m (400 MB heap):  142 ms max, 22 ms average\n    * This is the effect of a very small heap.\n* -XX:MaxGCPauseMillis=50 (try to keep pause times under 50ms):  72 ms max, 41 ms average\n    * This was probably too much GC pressure to honor the pause time requirement. The experiment below combining a larger heap with a pause time limit worked better.\n* -XX:MaxGCPauseMillis=50 -Xmx800m: 35 ms max, 16 ms average\n* -XX:MaxGCPauseMillis=20 -Xmx800m: 22 ms max, 12 ms average\n\n**TL;DR:** The Java garbage collector is very sensitive to its parameters. A little bit of tuning can go a long way. This is probably true for other GCs as well.\n\n**Edit:** Reference points for Go and Haskell on my machine. I made no attempt to tune the performance of these, and I may have old versions of these languages installed, as I don't typically develop in them.\n\n* Go: 47 ms\n* Go (Array): 8 ms\n* Haskell: 49 ms\n\n    "], [10, "I wonder what their requirements are for \"realtime\" since update rates of say 60 times a second you only have 16.66ms in total. Having up to 7ms consumed just by GC alone is a non starter."], [10, "Go with generics and Rust style enums would basically be a perfect language. "], [4, "A quick [translation to D](https://gist.github.com/thedeemon/e651eb05a7f835df6f7bec3cf3c8a86a) shows maximum GC pause of 15 ms. (with the \"bad\" compiler - dmd on a Linux x64)\n\nWhich is worse than OCaml's 2.5 ms but seems to be better than Java and Haskell, and not so far from Go."], [3, "*Bringing up something that is otherwise buried in the thread.*\n\nNim's creator, Araq, has [graced us with a Nim version of the benchmark](http://forum.nim-lang.org/t/2646#16351). And I use \"graced us\" liberally, because according to his comment this version has a worst case latency of 0.3 ms.\n\nAraq is a game developer, for who latency matters very much, and the design of the Nim GC was made with harsh latency requirements in mind. In his version of the benchmark, he uses `GC_setMaxPause` to tell the GC the maximum pause time it is allowed to (incidentally 0.3 ms). Another solution is to disabled the GC automatic runs and instead call `GC_step` manually (which also takes a maximum pause time argument).\n\nIf you can manage to confirm Araq's measurements on your machine, it would mean Nim beats OCaml by a factor of 7x."], [2, "Anyone know how number of moves left is calculted so (step 4)? \n    \n    2*|white| + |grey|"], [2, "I'm curious how the Java version would perform if run on Azul's Zing JVM. They claim to have sub-millisecond pause times even on gigantic heaps."], [1, "Does anyone know if the Go runtime and compiler toolchain are suitable as a compile target for other languages, or would that be more trouble than it's worth? "], [-6, "They should choose Rust instead"]], [[{"comment": "Nice visualization.\n\nGo goes from strength to strength with every release.", "id": "dao9gwu"}, {"comment": "That's not going to stop /r/programming from shitting on it every chance they get though.", "id": "daor0ah"}, {"comment": "If it had generics we could shit in a generic way, without repeating ourselves", "id": "daoulf9"}, {"comment": "generic-ish: https://github.com/joeshaw/gengen ", "id": "daovjod"}, {"comment": "(Visualization creator here) Thanks! :-) I hope it was enlightening. I was thinking of expanding it a bit, and posting it on its own. I'd like to make it clearer what the program and the GC have pointers to, and I'd like to illustrate other phases (e.g. sweep).", "id": "dap31m2"}, {"comment": "I concur it's a nice visualization, succinct and to the point.", "id": "dapd34o"}, {"comment": "> Go goes from strength to strength with every release.\n\nThe only improvements I've seen mentioned were about the GC (which has seen quite some overall over the last few releases), could you sum up what I missed?", "id": "dapd5k8"}], [{"comment": "The Java GC has some conservative initial parameters. There's no obvious way to bring the max pause time down to the level of some of these other languages, which are very impressive, but it can be a lot better than what this article indicates.\n\nI downloaded the benchmark they used, and tried a few different tuning parameters using the G1 GC:\n\n* Baseline: 73ms max pause, 45 ms average\n* -Xmx800m (800 MB heap):  43 ms max, 18 ms average\n* -Xmx400m (400 MB heap):  142 ms max, 22 ms average\n    * This is the effect of a very small heap.\n* -XX:MaxGCPauseMillis=50 (try to keep pause times under 50ms):  72 ms max, 41 ms average\n    * This was probably too much GC pressure to honor the pause time requirement. The experiment below combining a larger heap with a pause time limit worked better.\n* -XX:MaxGCPauseMillis=50 -Xmx800m: 35 ms max, 16 ms average\n* -XX:MaxGCPauseMillis=20 -Xmx800m: 22 ms max, 12 ms average\n\n**TL;DR:** The Java garbage collector is very sensitive to its parameters. A little bit of tuning can go a long way. This is probably true for other GCs as well.\n\n**Edit:** Reference points for Go and Haskell on my machine. I made no attempt to tune the performance of these, and I may have old versions of these languages installed, as I don't typically develop in them.\n\n* Go: 47 ms\n* Go (Array): 8 ms\n* Haskell: 49 ms\n\n    ", "id": "daof47v"}, {"comment": "For extra context, the same program in Go [will use a lot less memory](http://benchmarksgame.alioth.debian.org/u64q/go.html) than a Java counterpart with generally better GC timings.", "id": "daohkkb"}, {"comment": "> A little bit of tuning can go a long way. This is probably true for other GCs as well.\n\nI think for Java it is understatement. Java GC tuning is an industry in itself with technical books,  articles,  consulting etc and if that is not enough buy Azul's well marketed products.", "id": "daogsbo"}, {"comment": "Oh, definitely. But this example shows that adding two parameters gets you from 50% worse than other languages, to 100% better.\n\nI don't know how the Go or Haskell GCs work, but the Java one also does a lot of online tuning (e.g. young vs old sizes, how many regions are collected in a single pause). That isn't going to help in a benchmark that runs in under a second, but will probably benefit a production system that is running for more than a few seconds. In a short benchmark like this, the added complexity might actually hurt.", "id": "daohcla"}, {"comment": "I use Java for a reasonably sized server application with ~16G heap and Java GC pauses are sometimes 5-30 sec. A lot of time has been spent on tuning GC parameters. Normally things run fine but I remain unsure that tuning made things better or worse.", "id": "daoi416"}, {"comment": "If you are seeing that kind of pause time it's because it's falling back to the stop the world throughput collector because the concurrent collector couldn't keep up.  You most likely either have some event that is causing a large amount of memory to be allocated or your heap is too small.  When it's going slow grab a heap dump and open it up in JMAT.  Seeing what is actually in the heap is usually pretty enlightening.", "id": "daonzu6"}, {"comment": "This is a real-world application on go-1.8-beta1 with a 18GB heap -> https://twitter.com/brianhatfield/status/804355831080751104 (sub-millisecond pauses!)", "id": "daovi5a"}, {"comment": "That's a good point about online tuning. Since GCs need to make a tradeoff between throughput and latency, doing online tuning makes sense because it can figure out the runtime characteristics of your program, and make a better guess at what you would want to optimise for.\n\nReally we should be running these benchmarks for longer in order to get a fairer comparison to Java. Ideally, we should only start measuring pauses once the benchmark has been running for a couple of seconds.\n\nIt seemed as though Racket also suffered during this initial \"ramp up\" time.", "id": "daowm0e"}, {"comment": "It's not really that hard.  All you really need to understand is that the time spent in GC is largely based on the number of objects that survive the collection.  Just give yourself a big enough tenured space to keep full collections infrequent and tune the young generation to try to avoid promoting objects.  I've never really had an issue keeping CMS or G1 pause times under 100 ms.  If my services were pausing longer it was usually an indication of some bad code that was filling the heap with junk.  ", "id": "daonppv"}, {"comment": "That's awesome you looked further into this. Would you be able to add the best tuned version to [the repo](https://gitlab.com/gasche/gc-latency-experiment)? (Probably just update the Makefile). I might try running it on my machine to see how it compares.\n\nAs a non-Java person, I'm still curious why this is not better out of the box. The Java RTS has had a huge amount of effort poured into it, and I would have thought that by now it would be an industry leader at optimising for low latency.\n\nIt appears you can use a concurrent tricolour mark and sweep collector in the old generation (the same as Golang). Presumably this exists for reducing latency. I don't see any theoretical reason why this  shouldn't be getting the same kind of low latencies as Go does.", "id": "daowjl8"}, {"comment": "> The Java RTS has had a huge amount of effort poured into it, and I would have thought that by now it would be an industry leader at optimising for low latency.\n\nThere are a few things to be aware of here.\n\nJava/HotSpot has several GC algorithms. The default is quite old, but very stable. The G1 GC is the one being actually developed and improved and it will be the default in Java 9. So the first thing to do when tuning Java GC is pick the newest GC engine.\n\nThe Java GC does not optimise for low latency exclusively, it tries to strike a balance between many different factors which your analysis entirely ignores! In particular it is compacting (Go's GC is not), which is very useful for long term stability as you can't get deaths due to heap fragmentation, and it tries to collect large amounts of garbage quickly, which Go's GC doesn't try to do (it's pure mark/sweep, not generational), and it tries to be configurable, which Go's GC doesn't care about. For many apps you do tend to want these things, they aren't pointless.\n\nThis is especially true because for most servers a 100msec pause time is just fine. 8msec is the kind of thing you need if you're doing a 60fps video game but for most servers it's overkill and they'd prefer to bank the performance.\n\nTo put this in perspective Google is having problems migrating to G1 because even though it gives lower and more predictable pause latencies, it slows their servers down by 10%. A 10% throughput loss is unacceptable at their scale (translates to a 10% increase in java server costs) and they want G1 to become even more configurable to let them pick faster execution at the cost of longer pauses. ", "id": "dap79e7"}, {"comment": "> In particular it is compacting (Go's GC is not), which is very useful for long term stability as you can't get deaths due to heap fragmentation, and it tries to collect large amounts of garbage quickly, which Go's GC doesn't try to do\n\nHere is what Ian lance Taylor has to say about fragmentation [1]\n\n\"Heap fragmentation is not normally a concern with the current Go runtime. The heap is implemented to that large pages are divided up into blocks that are all the same size. This means that the usual definition of fragmentation--a small block prevents coalescing of large blocks--can not occur. \"\n\nJava GC does lot of advanced things but most of those things are required in case of Java because of huge memory bloat it creates in first place. \n\n1. https://groups.google.com/d/msg/golang-nuts/Ahk-HunIqgs/1sOi...", "id": "daq0iou"}, {"comment": "I'll look into submitting PR later.\n\nAs a caveat, I'm definitely not an expert in Java GC. Most of this is gleaned from the Oracle GC tuning guide, and my experience with a throughput-oriented Java program with a very very large heap (hundreds of GB), which has totally different goals than this benchmark. If you're interested in garbage collection, that document might be really interesting, even if you're not specifically working in Java: [https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html]\n\nJava GC performance seems very sensitive to overall heap size, and new generation size. Both of those things start with pretty conservative settings (e.g. a 6 MB heap), and are tuned online. The default collector is also supposed to be throughput-oriented, rather than latency oriented. The goal is that 99 percent of runtime is spent in the application, not in GC. In my experience, we see very long pause times (over a minute of GC time for a heap that is around 100 GB), but overall the GC time is a tiny fraction of our total run time.\n\n### Testing online tuning\n\nAs a point about online tuning, I increased the number of iterations in the benchmark by 100x, and looked at the end of the benchmark phase. Using the default collector with no tuning the max pause time is over 100 ms, but that happens only at the very beginning when the heap is still growing. Once the program reaches steady state, the maximum pause is about 35ms. The benchmark takes about 20s to run.\n\nIf I add the -XX:MaxGCPauseMillis=20 option, the steady state behavior shows lots of very short (under 2 ms) pauses, with an occasionally full collection that takes about 70 ms. I'd say this is a failure of the default collector (which is supposed to be throughput-oriented) to get realtime results. Also, the overall runtime increased from 20 seconds to 3 minutes.\n\nWith G1 GC and no tuning, I see similar behavior, the max pause is very long (about 200 ms), but occurs at the start of the run. Steady state behavior has a max pause of under 40ms. Total runtime is about 20 s. The -XX:MaxGCPauseMillis=20 doesn't seem to affect max pause in this case, but increased total runtime to 40s.\n\n", "id": "dap23kz"}, {"comment": "I just came across that guide today. It's been helpful in answering some of these questions.\n\nBy the sounds of [this section](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref28), the VM will use heuristics to select the GC algorithm used automatically. I'd be interested to see how the concurrent mark and sweep collector compares with the G1 collector for this benchmark if it was explicitly selected.\n\nThat's some interesting analysis of longer runs of the program. It essentially confirms my expectations of how it would behave. The one thing that surprises me is that the G1 collector did not perform better than the default.\n\nIt would be interesting to find out which of the algorithms is being selected by default.", "id": "dap4q1x"}, {"comment": "Oh, another thing thing (can you tell I like experiments...). I counted the total number of pauses, total pause time, and total run time for my extended benchmark.\n\n* Go: 67 ms max, 1062 pauses, 23.6 **s** total pause, 22 ms mean pause, 91 s total runtime\n* Java, G1 GC, no tuning: 86 ms max, 65 pauses, 2.7 **s** total pause, 41 ms mean pause, 20 s total runtime\n* Java Parallel GC, no tuning: 94 ms max, 119 pauses, 4.5 **s** total, 38 ms mean, 20 s total runtime\n\nSo, in this benchmark, Go has slightly better pause times, but spends more time in GC than Java does running the whole program.\n\n**Edit:** I don't mean to turn this into a \"my platform is better than yours\". The tradeoff between\nmax pause time and throughput is interesting. Even if the max latency is worse in Java, the fact that\nJava can process messages so much faster in this benchmark *might* mean that the 99th percentile latency\nwill be better.\n\n**Edit 2:** I totally forgot to mention, I'm using the Go array-based code, and I modified the Java code\nto also use an array to store messages.", "id": "dapa17l"}, {"comment": "Interesting results, and I suppose another symptom of the throughput vs latency tradeoff the runtime systems are making.\n\nI didn't read it as a \"my platform is better than yours\". It's good to highlight the strengths and weaknesses of each platform for different use cases.", "id": "dapbvqu"}, {"comment": "G1 isn't designed to provide arbitrarily low pause times. There's another GC algorithm being developed called Shenandoah that is supposed to provide nearly pauseless operation at a cost of much larger heap overheads.", "id": "dap7sja"}, {"comment": "Not arbitrarily low. Java document [1] just says less than 1 sec.\n\nShenandoah pauses are currently 23ms(avg) and 45ms(max)[2]. Go 1.8 beta is offering sub milli sec pauses. \n\n1. https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref28\n\n2. http://www.slideshare.net/RedHatDevelopers/shenandoah-gc-java-without-the-garbage-collection-hiccups-christine-flood\n\n", "id": "daq197x"}, {"comment": "No, those are heuristics for people to manually select the collector. The parallel collector is the current default, but I believe Java 9 will use G1 as the default. I think that makes sense, since \n\nWith no other tuning, the steady-state behavior of CMS is about 45 ms pauses with occasional very fast full collections (6 ms). The entire benchmark was about 30 seconds. Setting a pause time goal didn't seem to help.\n\n ", "id": "dap9br1"}], [{"comment": "I wonder what their requirements are for \"realtime\" since update rates of say 60 times a second you only have 16.66ms in total. Having up to 7ms consumed just by GC alone is a non starter.", "id": "daocqzx"}, {"comment": "> In computer science, real-time computing (RTC), or reactive computing describes hardware and software systems subject to a \"real-time constraint\", for example from event to system response. Real-time programs must guarantee response within specified time constraints, often referred to as \"deadlines\".\n\nSo you can have a system that guarantees that the maximum stop-the-world pauses won't take more than 100ms and that would still be a realtime system - unsuitable for avionics and a lot of other things, but realtime still.\n\n> Having up to 7ms consumed just by GC alone is a non starter.\n\nThat's very workload-relative - this might interest you: [Today I submitted changes to the garbage collector that make typical worst-case stop-the-world times less than 100 microseconds](https://groups.google.com/forum/?fromgroups#!topic/golang-dev/Ab1sFeoZg_8)\n\nEDIT: https://twitter.com/brianhatfield/status/804355831080751104", "id": "daoklv8"}, {"comment": "We are writing a pipelined message bus. Therefore the system can have multiple messages passing through it at any one point in time. This means it can handle much more publishes a second than `1/the average latency`. So in this case, it doesn't make sense to use the required throughput (e.g. 60 messages per second) to get the maximum latency for a message.", "id": "daoyfq6"}, {"comment": "This is not a Graphic application so 60 times a sec has no meaning here and in the very first line author mentions \"..source to destination in less than 100ms\".", "id": "daogh54"}, {"comment": "Hi! By \"realtime\" we're referring to latency rather than a refresh rate. Including round-trip times on the open internet, we aim for around 100ms. This is fast enough to enable two-player realtime games, for example.", "id": "dap35co"}], [{"comment": "Go with generics and Rust style enums would basically be a perfect language. ", "id": "daoqp5x"}, {"comment": "The food in this vegan restaurant tastes so delicious. It would be perfect if they added meat and cheese.", "id": "daovo9h"}, {"comment": "A fair point, but I think it's true that there's a clear vacancy for a language with the following characteristics:\n\n* First-class value type support\n* The popular ML stuff; generics, sum types, type classes/traits, etc\n* High quality GC\n\nF# is a candidate, but (amusingly) using value types can require more code duplication than in Go. It also has no real equivalent for Rust traits or Haskell type classes, but it looks like [that might change](https://www.youtube.com/watch?v=hK5GJoH4PlI).\n\nIncidentally, the hypothetical language I'm describing is not the language that I want for myself. I think it's a very conservative vision of the future, and one that is not worth the effort of building a new language. My dream language is far more alien!", "id": "dapbzhd"}, {"comment": "OCaml? Not sure if it supports good value types.", "id": "daqnops"}, {"comment": "It doesn't, sadly. It has functors though, and is likely to soon have implicit modules (filling the same role as type classes). It would be wonderful if it had good value types. ", "id": "daqs4dj"}, {"comment": "Point taken, but you have to admit that nothing improves a veggie burger like bacon.", "id": "daqijk2"}, {"comment": "Haha, or \"The pizza in this Neapolitan ristorante is amazing. It would be perfect if they put pineapple, pasta and meatballs on top.\"", "id": "daow944"}, {"comment": "> The food in this vegan restaurant tastes so delicious. It would be perfect if they added meat and cheese.\n\nI thought Go's creators thought that generics aren't as important as is commonly thought and didn't know how to implement them well, not that they thought that generics are immoral.\n\n", "id": "daqnzvb"}, {"comment": "Honest question. If you want Rust's features... why not just use Rust? (Then you'd have 0ms GC, but maybe some (low) Rc costs if you use that). Is it all about the concurrency primitives?", "id": "daotk02"}, {"comment": "Good question. We do like the sound of what Rust promises at Pusher.\n\nFor us, the main reason we choose Go over many other languages, including Rust, was that we needed a Raft library (https://raft.github.io/) -- something Go has battle tested libraries for and Rust does not.\n\nAs you suggested, concurrency support was also a factor. Our application is highly concurrent, and Go's greenthreads (goroutines) made this very simple to model (since each thread has such low overhead). \n\nOn top of that, we did have concerns about the maturity of the language in general: Golang seemed to take breaking changes more seriously, and we thought that the ecosystem in general was stronger for Go. Rust seems to be rapidly improving in this area however.", "id": "daowdag"}, {"comment": "> Golang seemed to take breaking changes more seriously\n\nThe core parts (language, compiler and standar library) follow roughly the same policy. (Rust has a tier system that roughly corresponds to new Go packages going to `golang.org/x/...` before getting into the standard library, but it boils down to the same concept.)\n\nIn terms of the ecosystem as a whole, arguably Rust's takes breaking changes more seriously than Go's. Rust has a centralized package repository (crates.io) which guarantees version locking, while Go pretty much leaves you on your own here: do your own vendoring or face the possible breaking changes upstream.\n\nPlus, big refactoring work in the Rust compiler is tested against _all published crates_. For example, they did this before [turning the new MIR work on by default](https://github.com/rust-lang/rust/pull/28748).", "id": "dap1c7o"}, {"comment": "> Golang seemed to take breaking changes more seriously,\n\nHonestly I do not know how golang mange the breaking changes, and what are the policy that drives this process. But the one in Rust is outstanding. Probably you know that there are three versions of Rust: nightly, beta and stable. Each is public and every six month the nighly becomes beta, and the beta becomes stable. This slide windows allows several public testing of what will become the next Rust.\n\nEvery Rust feature is publicly discussed and evaluated in an open RFC process, and is supported with data about how it behave against the crates that are available in crates.io. Basically the new feature is checked against real code base to understand how it breaks / behave in the current codebase. And if this the result is not good, the feature is modified or delayed to Rust 2.0\n\nI have no doubt that golang achieve very good results in whatever process do they have, but I do not see how it can be 'more serous' that the Rust one.\n\n> and we thought that the ecosystem in general was stronger for Go.\n\nThis is true.", "id": "daoyght"}, {"comment": "> every six ~~month~~ **weeks**\n\nFTFY\n\n> And if this the result is not good, the feature is modified or delayed to Rust 2.0\n\nAFAIK, the delayed case is highly hypothetical, it has never cropped up yet. Actually, a large focus of the community when evaluating new features is evaluating their interactions with features known to be potentially interesting to avoid locking Rust into a position where a 2.0 would be necessary.", "id": "dapdf7s"}, {"comment": "> The delayed case is highly hypothetical, it has never cropped up yet.\n\nEh, https://github.com/rust-lang/rust/issues?q=is%3Aopen+is%3Aissue+label%3Arust-2-breakage-wishlist\n\nStill only three issues :)", "id": "dapnf2i"}, {"comment": "Oh! And what a list!\n\nAmong the 3, one is a compiler specific issue, not even a language one... I'd personally be open to just declare the whole compiler interface unstable and ask folks to use cargo or suffer the instability.", "id": "dapo0ei"}, {"comment": "I thought we had a tag with like, ten of them, but I can't find it now, idk.", "id": "dapoaeh"}, {"comment": "Do'h, thanks : )", "id": "dapft32"}, {"comment": "Rust supports [channels](https://doc.rust-lang.org/beta/std/sync/mpsc/fn.channel.html) that are even a superset of Go ones in terms of functionality (you can separate the sender & receiver ends), so there shouldn't be anything to stop the OP from using it :)", "id": "daouc1l"}, {"comment": "You can also get sender and receiver ends of a Go channel:\n\n    ch := make(chan T)\n    var sender chan<- T = ch\n    var receiver <-chan T = ch\n\nNow the compiler ensures that you can't receive from `sender` and you can't send to `receiver`.", "id": "dap0ljr"}, {"comment": "Rust's `std::sync::mpsc` channels only support \"one -> one\" and \"many -> one\" sending (`Receiver`s are not cloneable), whereas Go's built-in channels support multiple receivers. \n\nRust's `select` macro also supports less functionality than Go's, as it can only select on receivers, not senders, and I think it doesn't randomise the winner like Go does, which is important to prevent e.g. the first receiver in the select statement always being selected if it always has a message waiting, starving the others.", "id": "dap1z70"}, {"comment": "Rust does not have the ability to spin up dozens/hundreds of thousands of threads, which Go does.\n\nThis makes it easier to handle a number of work-loads in Go, at the cost of potential data-races of course ;)", "id": "dapdi9p"}, {"comment": "Because Rust as of right now is inherently worse than Go in writing scalable servers due to the missing support for coroutines: Those are required for a work-stealing scheduler which I consider essential to make servers reliable.\nThus the only way Rust could be on par in a real world scenario would be if your server is very simple or only consists of routes/request-handlers which have approximately the same computational complexity.", "id": "daovtcc"}, {"comment": "This is not really accurate. Rust support [Futures](https://github.com/alexcrichton/futures-rs/), and the [performance](https://aturon.github.io/blog/2016/08/11/futures/) looks amazing, including go in the comparison.\n\nAlso Rust is well positioned in the [channels](http://rustbyexample.com/std_misc/channels.html) PoV. ", "id": "daoyat3"}, {"comment": "> Rust support Futures, and the performance looks amazing, including go in the comparison.\n\nWithout delving much further in the relative merits, we can say however that Rust concurrency/server story is *less mature* than Go.\n\nI mean [futures](https://crates.io/crates/futures) look amazing, put 0.1.6 does not necessarily give much confidence into the stability of their design and implementation :)", "id": "dapdovd"}, {"comment": "That looks correct, yes : )", "id": "dapfrk2"}, {"comment": "I'm aware of futures-rs and they indeed are the best futures library I've probably ever seen, but nonetheless you're probably just as aware that those futures can't migrate between threads, right?\n\nSo what you misunderstood is me talking about (worst-case) latency and throughput VS absolute performance. In the context of \"serious\" servers the former is generally more important than the latter.\n\nI mean: Are you sure your database or filesystem can handle 2M req/s? Or would you rather say your team can handle writing 2 LOC of state machines and promises VS just banging out the code and it just works.\u2122\n\nThe problem with those synthetic benchmarks you see with tokio-rs and the like is that they are simply not a representation of real world performance and scalability. It doesn't even need to be hard. Here let me give you an example where Rust's minihttp will just be utterly destroyed by the competition:\n\nWrite a route which is, let's say, 10 times as computational heavy as the \"Hello World\" route. In the real world this could be for instance a route returning 10 rows from the database and a route returning 100. Now benchmark both at the same time concurrently and tell me how much faster Rust still is - especially in the 95th percentile. \ud83d\ude09\n\nYes Rust is a superior language, but right now at this moment it's a horrible horrible tool to write _scalable_ \u00b9 servers in since you can't trust it to give you a steady latency as long as it doesn't provide work stealing.\n\n\u00b9 And that includes servers with a large number of concurrent connections (e.g. chat server) or with a high throughput (e.g. nginx).", "id": "daoyz3u"}, {"comment": ">Yes Rust is a superior language, but right now at this moment it's a horrible horrible tool to write scalable \u00b9 servers in since you can't trust it to give you a steady latency as long as it doesn't provide work stealing.\n\n\nCome on, there are at least a dozen ways to skin that cat, and a thread-pool scheduling 'coroutines' is only one of them. \n\n\nIts true, right now there is no scheduler over a thread pool for futures/tokio, although that is definitely planned. \n\n\nHowever you absolutely can run your futures in a thread-pool [e.g.](https://github.com/tokio-rs/tokio-minihttp/blob/master/src/lib.rs#L64) \n\nIn addition, there is already a feature rich API around running long computation in a thread or thread pool and creating a future from the result of your computation.  [like in this tutorial](https://github.com/alexcrichton/futures-rs/blob/master/TUTORIAL.md#concrete-futures-and-streams) \n\n\nGo uses the mantra of explicit is better than implicit, but, if I may spread a little FUD myself,  there are a lot of unknowns in Go's scheduler. When it works, it works beautifully, and it absolutely makes writing scalable apps simpler.  But when it doesn't work like you expect, it is hard to have any idea what is going on. \n\n\nIn the Rust+Futures approach,  you do have to be explicit about running parallel computation, but if something goes wrong, you at least have a clue as to where to look. ", "id": "dap90ww"}, {"comment": "First of all: My reply to /u/steveklabnik1 [here](https://www.reddit.com/r/programming/comments/5fyhjb/golangs_realtime_gc_in_theory_and_practice_pusher/dapgwxp/) answers some of your criticism.\n\n> Come on, there are at least a dozen ways to skin that cat, and a thread-pool scheduling 'coroutines' is only one of them.\n\nKind of. It's hard to come up with a system whose `time_to_develop * worst_case_performance` factor is smaller than that, or can you think of any? And that's my entire point of my comment: If you use a thread-pool, which is not properly scheduled in a way that allows tasks from a blocked processor to be transferred to a idling one, it will simply not perform well in the 95th percentile. Just take a look at all respectable scalable server languages and you will notice that one way or the other they use something like that. (C# etc. doesn't count as scalable because just like with minihttp only their synthetic benchmarks perform well, while under actual workload it's only about as good as Ruby if it had a proper VM.)\n\n> there are a lot of unknowns in Go's scheduler\n\nActually the Go scheduler is extremely simple. Each worker-thread (called a \"processor\") uses a 512-slot atomic work queue. If a coroutine is started even though the queue is full it's put into a unbounded global queue. If a processor's own queue is empty it will pick another random processor and steal half it's queue. If that fails for all neighbouring processors it will try to take a batch of 256 coroutines from the global queue or sleep until a new one is started. [Here](https://github.com/zonyitoo/coio-rs/blob/master/src/runtime/processor.rs)'s a prototypal implementation of it in Rust. It's not _that_ complicated right? In fact I'd argue it's not harder to figure out bugs with this than with a standard thread-pool. (I've never had a issue with Go's scheduler yet and I've never heard of anyone having problems though.)\n\nBut I can only repeat it like before: Regular thread-pools don't scale. There are enough papers out there arguing for that (e.g. [page 6](https://ai2-s2-pdfs.s3.amazonaws.com/5343/61b70ff69ea6c68e8bdad73c468fce408ad0.pdf)) and I chose to believe the mountain of proof. (I mean it's not hard to understand that if you only have a single work-queue it will be the ultimate choking point due to locking).", "id": "dapiaie"}, {"comment": "Hey, I'm one of the authors of Tokio and just thought that I would try to clarify some additional things (besides what others have). Tokio is very young and lacks solid documentation, which is something we plan on tackling as soon as 0.1 is released. So, the lack of docs is probably to blame for the misconceptions.\n\n> I'm aware of futures-rs and they indeed are the best futures library I've probably ever seen, but nonetheless you're probably just as aware that those futures can't migrate between threads, right?\n\nThis is not correct. `Future` in futures-rs does not have any bounds, which means that there is no implication of being pinned to a thread vs. being able to be sent across threads. In fact, *most* of Tokio's futures ARE sendable across threads and the ones that aren't are such because it wouldn't make sense to do so.\n\n> The problem with those synthetic benchmarks you see with tokio-rs and the like is that they are simply not a representation of real world performance and scalability.\n\nThis is true and I agree w/ you. However, the benchmarks were created to evaluate the *overhead* of Tokio compared with writing the same code by hand on epoll. The point of the benchmark is to show that there is no measurable overhead. The goal of Tokio is to keep this true.\n\nSo, now to the example that includes a server that has a route that is 10x as computationally heavy as an other one. Computationally heavy routines is the \"problem\" with asynchronous programming. Go solves this by providing green threads. Rust initially provided green threading as well, however given that Rust didn't need a runtime, the green threading was much too expensive to justify (even though it was on par with Go's).\n\nNow, that doesn't mean that you *can't* use green threading w/ Rust and `futures-rs` is even designed to allow arbitrary executors to be used and for futures to be able to be compatible with any executor. This means that to handle the computationally expensive case, you have three options:\n\n1) Insert yield points in the computation (cooperative threading).\n\n2) Send the socket to a thread pool executor and process it there. Note, that this will still be *async* for bits that \"block\" on I/O but will be able to multiplex the computationally expensive bits across threads. This works because futures **can** be sent across threads.\n\n3) Use a green threaded executor for computationally expensive bits\n\nEither way, Rust + Tokio is designed for speed, while Tokio is still a bit rough and lacks documentation, I'm quite confident that it will be quite faster for even large / complex cases.\n", "id": "dapfjyb"}, {"comment": "First of all: My reply to /u/steveklabnik1 [here](https://www.reddit.com/r/programming/comments/5fyhjb/golangs_realtime_gc_in_theory_and_practice_pusher/dapgwxp/) answers some of your criticism.\n\n> The point of the benchmark is to show that there is no measurable overhead.\n\nYeah I know. I simply pointed out exactly the same to /u/apd, for the exact same reason. \ud83d\ude09\n\nBut now that you're already here I've got some technical things to say regarding the use of mio in tokio-rs: Please integrate mio directly in tokio instead of depending on it. I'm sure you know [this method](https://github.com/carllerche/mio/blob/c8312b719bb4d640806d8bbbd00e258df955e647/src/sys/unix/kqueue.rs#L189) and I'd rather see it gone. Why? Well that thing alone literally consumes >20% CPU of my entire application on OS X. Personally I believe that mio is simply too low level to provide the optimal performance _apart from epoll_. If you recreate mio behind a more high-level interface in tokio I'm sure you could mostly optimize things like that away.\n\n> Computationally heavy routines is the \"problem\" with asynchronous programming.\n\nFinally someone at least acknowledges this. \ud83d\ude2d You're literally the first person to do so ever since I've been advocating for alternative scheduling solutions in Rust.\n\nThe thing is: It's not just \"heavy-heavy\" routines (like the dreaded example of computing Fibonacci numbers in node.js), it's even the simple stuff, like my example of routines querying a database where the amount of returned rows is variable. The difference might be small per call - something less than 1\u00b5s, but your server might not just receive one request per second, or call such a method only once per request. All in all this results in jitter, which - as random as it is - can multiply and cause serious, noticeable latency jitter. And if your lowest-level framework on which everything else is based has such a problem it will obviously effect everyone, if they like it or not.\n\nI can even give you an example: I've once evaluated whether I should use C# or Go (among others) for a large low-latency streaming server. Go's 95th percentile was consistently worse than C#'s for simple benchmarks like with minihttp. I believe C# was only a few % higher than the average latency and Go on the other hand 10x larger (but still around a millisecond or so). But then I tried adding some parsing and computational functionality to it. Guess what happened with C# and it's non-work-stealing scheduler? It was absolutely horrible. Jitter of death of doom and thus a terrible 95th percentile. Go on the other hand didn't even show a difference to the hello world example except for the elevated average latency. And I want nothing more than having the same peace of conscience with Rust. I'm sure most want nothing else. Unfortunately synthetic benchmarks mislead people there into believe that something is good even though it's only on paper, but I guess one gets more upvotes and clicks for that. \ud83d\ude1f\n\n> futures-rs is even designed to allow arbitrary executors to be used and for futures to be able to be compatible with any executor.\n\nYeah. /u/zonyitoo and me are already planning to use it in [coio-rs](https://github.com/zonyitoo/coio-rs/), maybe even tokio directly if the above performance problem gets solved. But...\n\n> Now, that doesn't mean that you can't use green threading w/ Rust\n\nNope. It does mean that. Rust's stdlib and especially it's implementation of `drop()` uses thread local storage, which is incompatible with green-threading/work-stealing coroutines. At least until Rust provides direct support for it and I've opened an issue [here](https://github.com/rust-lang/rust/issues/33368) a long time ago. It's really a shame because coio-rs was a really interesting - and I'd even go so far as to say: the most promising networking - project in Rust. But I'm of course biased as hell since I've been working on it. \ud83d\ude00 It's scheduler is a direct clone of Go's and it already showed superior performance in comparison, even though we didn't really had that much time to optimize it yet.", "id": "daplrbc"}, {"comment": ">  nonetheless you're probably just as aware that those futures can't migrate between threads, right?\n\nSo, it's more complex than that. Let's go over the bits:\n\n1. futures\n2. mio, providing an event loop and nonblocking io\n3. tokio-core, using futures + mio\n4. other things like tokio-service, tokio-proto\n5. tokio itself, which is tokio-core + other tokio-* packages\n\nFutures themselves may or may not, individually, be able to be moved between threads. It's certainly not an inherent limitation of futures.\n\ntokio-core does not provide the ability to automatically move futures between event loops. But that's because it's just the low-level primitives for doing this stuff.\n\none of those libraries in 4 will be whose job it is to implement this kind of functionality. It's true that it's not there yet, but it absolutely will be.\n\ntokio itself doesn't even quite have a release yet.\n\n> right now at this moment it's a horrible horrible tool to write scalable \u00b9 servers in\n\nI'll give you this, at least until the tokio stack becomes more fully. It's not an inherent limitation, it's a libraries issue. You can see from above that it's still very much early days :)", "id": "dap7eja"}, {"comment": "Hey Steve, I'll get directly get to the point and ask you here: Are you guys monitoring me, or sharing direct links to my comment? The few upvotes I had are gone, yours are as usual in the positive... Even though this is so far down in the thread? WTF? Seriously feels like you guys are ganging up on me (again) and it sucks.\n\n> It's certainly not an inherent limitation of futures.\n\nYou're right. The futures are `Send`, but are the callbacks also `Sync`? I mean: Will the callback you passed to one of the Future continuation methods, be okay if it's called from a different thread? But okay... Let's say you modify futures-rs to impose that restriction on them to make load balancing possible. How would go about writing a common \"read-eval-write-loop\" in a server? The only options which come to my mind which have previously been explored with Rust are using state machines or an Arc that shares the request-local data among the future continuations. Both options are basically also the most popular options in the C++ community and are well established. But do you seriously think writing such code is as easy as writing the same using coroutines, where you don't have to worry about all of that while retaining the exact same performance?\n\nSo the question I'm now asking you is: Is being only as comfortable as C++ in writing scalable servers really, _really_, the best thing Rust should aim for? The only difference being the syntax but not the methodology? I personally hope not. And I say that with all my heart, since Rust is truly the only language I've ever really loved.", "id": "dapgwxp"}, {"comment": ">  sharing direct links to my comment? \n\nI was 99% sure of my answer, so I went into tokio's chat and asked to be sure. In order to provide the proper context for my question, I shared a link, but it's certainly not \"hey downvote this person.\" I only ever saw you with one upvote, personally, but it's also not like i'm paying a ton of attention or something.\n\nI'm not aware of any particular actions to brigade, and if I did, I'd tell them to knock it off. I don't think you should be in the negatives for you comment.\n\nIf there's any reason why these few comments are upvoted and yours isn't, I would argue that it's because you said something that's not true, and the replies are pointing that out. Even though this is a bit far downthread, it's still on the front page of /r/programming, so I imagine a lot of people are still reading it. I wouldn't attribute what's basically two or three votes to something nefarious.\n\n> I mean: Will the callback you passed to one of the Future continuation methods, be okay if it's called from a different thread? \n\nWell, with the work-stealing model, Send would be what matters, not Sync. You'd be moving the whole future to the other thread.\n\n> How would go about writing a common \"read-eval-write-loop\" in a server?\n\nThis is what the whole tokio stack is for :)\n\n> The only options which come to my mind which have previously been explored with Rust are using state machines or an Arc that shares the request-local data among the future continuations.\n\nFutures/tokio compiles down to a state machine.\n\n> But do you seriously think writing such code is as easy as writing the same using coroutines,\n\nI do not personally have a ton of experience using coroutines, so I can't say.\n\n> where you don't have to worry about all of that while retaining the exact same performance?\n\nWhat worries do you have here? It's not clear to me what problems you're referring to.\n\n> Is being only as comfortable as C++ in writing scalable servers really, really, the best thing Rust should aim for?\n\nWell, tokio is aiming to be more like Finagle, which isn't in C++, and in my understanding, is currently considered the best-practice architecture. It's not clear to me that anything better can be done; it's already compiling down to (as carl said in his reply) the same thing as you'd write by hand with the low-level primitives.", "id": "dapic3f"}, {"comment": "> If there's any reason why these few comments are upvoted and yours isn't, I would argue that it's because you said something that's not true, and the replies are pointing that out.\n\nCan you tell me what I was wrong about? Can _you_ proof that I was wrong in any point, except for my vague statement of futures not being able to migrate threads?\n\n> Well, with the work-stealing model, Send would be what matters, not Sync. You'd be moving the whole future to the other thread.\n\nDoes future-rs prevent you from accidentally passing a callback with reference to data which has not been protected by e.g. a Mutex? Or is the only answer \"just use an `Arc<Mutex<T>>`\"? The latter would kinda suck right? You'd have to stuff aaaaall your local data into structs for everything and pass it everywhere. Let alone the reference counting... Seriously: Why... _Why_ are Rust devs so strongly reluctant to having coroutines? Does it make development too easy?\n\n> This is what the whole tokio stack is for :)\n> Futures/tokio compiles down to a state machine.\n\nOh come on. That paragraph was a bit longer than that.\n\n> I do not personally have a ton of experience using coroutines, so I can't say.\n\nJust take a look at Go - it takes only like 2 days to learn it. And every time you see the dreaded `if err != nil` close your eyes like everybody else. Maybe you might like it even, because while no one likes the language I don't think there are many who deny it's productivity, a large part of it is thanks to the usage of coroutines.\n\n> What worries do you have here?\n\nDecreased productivity due to increased coding overhead (futures/promises + state machines = boiler plate). Inherently missing support for work stealing which is one of the most popular solutions to the problem of bad scalability with regular thread pools.\n\n> Well, tokio is aiming to be more like Finagle, which isn't in C++, and in my understanding, is currently considered the best-practice architecture.\n\nBy what standard is it considered the best? I mean: Maybe you're right about that, but I tried researching it and reading some code, but I barely found anything. I understand that the best projects don't necessarily need to be the most popular ones but if the only examples you find are ~100 LOC it doesn't make it any easier either to evaluate how it works.\n\nWhat I did find however is that finagle does use work-stealing! So... will tokio add the same? As I've written in my reply to /u/rovar above there is a mountain of proof of it being our currently best option in solving bottlenecks for scalable worker pools (as they are used in servers). But in the end I can't think of a comfortable solution right now that would make working with `future-rs` if it's callbacks would require `Send`.\n\n> it's already compiling down to (as carl said in his reply) the same thing as you'd write by hand with the low-level primitives.\n\nYes I know. Raw performance etc. right? The thing is not whether it's compiled instructions are perfect but more like whether the algorithm is the right one. It's as if I said \"`fn bubblesort()` compiles down to the same thing as you'd write by hand with the low-level primitives\".\n\nP.S.: Sorry for confusing Sync/Send a bit. I wasn't able to touch Rust for a while now and it shows. I'm sure you understand what I meant though.", "id": "dapjydu"}, {"comment": "> Can you tell me what I was wrong about? Can you proof that I was wrong in any point, except for my vague statement of futures not being able to migrate threads?\n\nYes. This is the statement that's wrong: \n\n> those futures can't migrate between threads, right?\n\nFutures can absolutely be moved between threads. It is true that automatic, work-stealing movement between threads is not implemented yet, but it is possible, and you can do it by hand today, and it will happen automatically tomorrow. (metaphorically speaking).\n\n> Does future-rs prevent you from accidentally passing a callback with reference to data which has not been protected by e.g. a Mutex?\n\nAgain, to be precise with the terminology (because it matters), futures says nothing about concurrency at all. When you use futures with concurrency, through something like tokio, then it's subject to the normal concurrency rules. However, that doesn't inherently mean you have to put stuff in a mutex. I agree that requring an Arc<Mutex<T>> around everything would be terrible for performance.\n\n> Seriously: Why... Why are Rust devs so strongly reluctant to having coroutines? Does it make development too easy?\n\nSnark doesn't make me sympathetic to your cause :wink:.\n\nI don't think anyone is \"strongly reluctant\" to having coroutines. But nobody has been doing a ton of work on coroutines in Rust. That is, it wasn't like there was some decision to reject coroutines by some Rust Cabal, but nobody has stepped up and said \"hey I really want coroutines in Rust and I'm gonna do the work\". Or at least, I think there are some small libraries, but they are mostly toys.\n\n> Just take a look at Go - it takes only like 2 days to learn it\n\nI have taken many looks at Go. But I'm not sure why you bring it up in this context; goroutines are not coroutines, at least in my understanding of coroutines.\n\nOn worries:\n\n> Decreased productivity due to increased coding overhead (futures/promises + state machines = boiler plate).\n\nYou don't write the state machines yourself, that's the compiled output. Futures are higher-level than that.\n\n>  Inherently missing support for work stealing which is one of the most popular solutions to the problem of bad scalability with regular thread pools.\n\nAgain, this is not inherent, this is a \"it hasn't been done yet and is planned.\" Tokio is still very much in early stages.\n\n> By what standard is it considered the best?\n\n\"People who write highly scalable application servers consider it best-in-class.\" This isn't my personal area of specialty, but it's what I hear from people.\n\n> So... will tokio add the same?\n\nAs I've said a number of times, yes. Absolutely.\n\n> P.S.: Sorry for confusing Sync/Send a bit. I wasn't able to touch Rust for a while now and it shows. I'm sure you understand what I meant though.\n\nIt's all good! Frankly I still get them confused from time to time myself :)", "id": "dapmtgq"}, {"comment": "You mean something like [Nim](http://nim-lang.org)? :)\n\nIn all seriousness, Nim is awesome, and I do believe it has a pretty low-latency GC as well. I am planning to port the benchmarks shown in this article to Nim and see how it compares.", "id": "daoxgwf"}, {"comment": "I think the point about Nim's GC is not so much that it is low-latency but rather than it's *controllable*.\n\nIn the context of video games, where you are stuck with a 16.6ms budget per frame, it's quite amazing to be able to call the GC at the end of the frame saying: OK, we hate up X, so you have (16.6 - X) ms to work, and the rest will have to wait.\n\nSuch fine-grained control over the GC is *amazing*.", "id": "dapdtdh"}, {"comment": "That's a very good point. Here are some preliminary results as well the Nim benchmark code for those that are interested: http://forum.nim-lang.org/t/2646", "id": "daplj3g"}, {"comment": "Nice. I note that you have hard-coded 10ms and get a 10ms maximum pause time...\n\n... have you tried with using a lower value for `GC_step`? Like `5_000`, to beat Go ;) ?", "id": "dapo5rm"}, {"comment": "Yes, of course :)\n\nCheck out Araq's version. Much faster!", "id": "dapppnn"}, {"comment": "That sounds really great. Not knowing anything about Nim, are you saying that the GC is incremental, and the program can bound the running time of each pause? That sounds excellent for applications with hard latency requirements.", "id": "daps1l5"}, {"comment": "As far as I know, Nim actually has two GCs: one throughput-oriented and one latency-oriented.\n\nAlso, the GC can be either left to its own devices, or the developer can temporarily deactivate automatic collection and instead use the `GC_step` function to tell the GC to move the collection forward. The `GC_step` function takes an integer argument representing its maximum execution time in microseconds.\n\nOr, as in Nim's creator Araq's version ([here](http://forum.nim-lang.org/t/2646#16351)), simply use `GC_setMaxPause` (also specified in microseconds).\n\nNote how in his version the maximum latency is 300 us, exactly as specified by `GC_setMaxPause`.", "id": "daqg7l4"}, {"comment": "> Go with generics\n\nYou can kinda wing it with https://github.com/joeshaw/gengen and/or https://github.com/bouk/gonerics if you really need it... <runs>", "id": "daovfmr"}], [{"comment": "A quick [translation to D](https://gist.github.com/thedeemon/e651eb05a7f835df6f7bec3cf3c8a86a) shows maximum GC pause of 15 ms. (with the \"bad\" compiler - dmd on a Linux x64)\n\nWhich is worse than OCaml's 2.5 ms but seems to be better than Java and Haskell, and not so far from Go.", "id": "daozkvz"}, {"comment": "That's interesting. From what I can tell from [the docs](https://dlang.org/spec/garbage.html), it looks like the GC is stop-the-world. So the pause of 15ms seems quite impressive, given the heap size.\n\nYou should add that benchmark to [the repo](https://gitlab.com/gasche/gc-latency-experiment) if you get the chance.", "id": "dap0mgq"}, {"comment": "Heap size is irrelevant in this case, D's GC is not copying and the data here consists of byte arrays that don't need to be scanned for pointers, so there is not so much work for GC at all. This is just a happy scenario for D's GC. In most other scenarios where a lot of garbage is created and lots of objects need scanning, its GC becomes very slow.", "id": "dap1ivx"}, {"comment": "If it is just a byte array, then it is defeating the point of the benchmark. The whole point is to see how long the pause times are when there are a lot of pointers to traverse. In the Go example, the array elements pointers to `message`s (byte arrays).\n\nI'm not familiar with D, but in your benchmark it looks like it is the same as Go: i.e. that the array contains pointers to `Message`s. Otherwise, when you write into the array, surely you would need to take into account the size in bytes of the preceding messages?", "id": "dap4bbq"}, {"comment": "Yes, it's the same as in Go: array of pointers to arrays of bytes.\n\nI just mean most of the heap data is occupied by those 1k arrays of bytes that don't get scanned. Scanning 200k pointers is not the same as scanning 200 MB of data.", "id": "daphzw2"}, {"comment": "Ok, it's sounds like we're in agreement. What I don't understand is why you think this is a \"happy scenario for D's GC\" when both D's and essentially any other GC's running time is proportional to the number of pointers.", "id": "daprw19"}, {"comment": "It needs to scan less than 1% of heap, doesn't need to traverse a lot (just a linear array of pointers) and it doesn't have to copy the data (unlike many other GCs). \n\nIf those 200MB were full of pointers it could cause a second long pause.", "id": "daq7c0f"}, {"comment": "What you say is true of Go's GC too. I wouldn't call it a \"happy case\" for low latency though because it's still breaking the weak generational hypothesis that both these GCs are assuming: that most objects die young. Every pointer in the array must be traversed during a collection.", "id": "daqfics"}], [{"comment": "*Bringing up something that is otherwise buried in the thread.*\n\nNim's creator, Araq, has [graced us with a Nim version of the benchmark](http://forum.nim-lang.org/t/2646#16351). And I use \"graced us\" liberally, because according to his comment this version has a worst case latency of 0.3 ms.\n\nAraq is a game developer, for who latency matters very much, and the design of the Nim GC was made with harsh latency requirements in mind. In his version of the benchmark, he uses `GC_setMaxPause` to tell the GC the maximum pause time it is allowed to (incidentally 0.3 ms). Another solution is to disabled the GC automatic runs and instead call `GC_step` manually (which also takes a maximum pause time argument).\n\nIf you can manage to confirm Araq's measurements on your machine, it would mean Nim beats OCaml by a factor of 7x.", "id": "daqgjnt"}], [{"comment": "Anyone know how number of moves left is calculted so (step 4)? \n    \n    2*|white| + |grey|", "id": "daogtl5"}, {"comment": "`|grey|` indicates the number of objects in the grey set.\n\nThe work is done when all objects are in the black set. The grey objects only need to be moved once. The white objects first need to be moved to the grey set, and then moved to the black set. That is why there is a `2*`.", "id": "daowoey"}], [{"comment": "I'm curious how the Java version would perform if run on Azul's Zing JVM. They claim to have sub-millisecond pause times even on gigantic heaps.", "id": "dapaqxp"}], [{"comment": "Does anyone know if the Go runtime and compiler toolchain are suitable as a compile target for other languages, or would that be more trouble than it's worth? ", "id": "daofcg1"}, {"comment": "In general, you can provide your own syntax over another language easily, but this requires you to keep the semantics the same. For instance, you could start requiring parentheses around flow control conditions, and that wouldn't be hard; if you wanted to change how goroutines work, that would be extremely difficult.\n\nYou can often achieve minor to moderate changes through lowering. That is, you come up with potentially verbose code in the target language that has the meaning you  want. Then you teach your compiler how to convert the code you want people to write into that verbose version.\n\nFor instance, if you want to add a `do-while` loop to Go, your compiler might take:\n\n    do {\n      io.Println(\"Hello world!\")\n    } while !ShouldEnd()\n\nand convert it to:\n\n    bool __tmp41 = false;\n    for !__tmp41 || !ShouldEnd() {\n      __tmp41 = true\n      io.Println(\"Hello world!\")\n\nThis can be used to add syntactic sugar. If you take this concept to extremes, you could use exception syntax for errors (try/catch/finally + throw), building up a call stack as you do so. You *might* even be able to unify panics and Error.\n\nSome things would require runtime costs, some would be very hard, and others would be impossible. You could change the type casting rules, but that would require you to invoke runtime functions when casting from `interface{}`. You could add parameterized types, but it would be hard to ensure that everything ends up in the right namespaces and there are no duplicate types and so forth. You probably can't add pointer arithmetic.", "id": "daomuti"}], [{"comment": "They should choose Rust instead", "id": "daofy9h"}]]], "5fwce0": ["Let's Stop Copying C", "2016-12-01 15:39:06", 507, "https://eev.ee/blog/2016/12/01/lets-stop-copying-c/", [[281, "> \u201cOh boy!\u201d says your prot\u00e9g\u00e9. \u201cLet\u2019s see what 7 \u00f7 2 is! Oh, it\u2019s 3. I think > the computer is broken.\u201d\n\n> They\u2019re right! It is broken. I have genuinely seen a non-trivial number of > people come into #python thinking division is \u201cbroken\u201d because of this.\n\nI disagree on this one.  I chose int because I want the performance of integer arithmetic.  I don't want to pay the penalty of convert to float, do float division, can convert back to int just because some amateur cooks don't realize that knives are sharp and can cut you.\n \n\n"], [218, "> But a double* might be NULL, which is not actually a pointer to a double; it\u2019s a pointer to a segfault.\n\nI lol'd"], [172, ">a language from 1969 \u2014 so old that it probably couldn\u2019t get a programming job.  \n  \nOuch."], [158, "So I actually took the time to count how many times each language was mentioned and tried to decide whether that was positively, negatively or ambiguously. Here are the languages I found at least 7 times, sorted by how positive their overall rating was according to the author's preferences:\n\nLanguage | Rating\n-------------|---------:\nHaskell | 100.0 %\nPython3 | 94.1 %\nJulia | 92.9 %\nLisps | 91.7 %\nAda | 88.9 %\nF# and Nim | 87.5 %\nLua | 85.7 %\nPerl6 and Ruby | 75.0 %\nPython2 and Swift | 73.5 %\nRust | 72.2 %\nBASIC, COBOL and Tcl | 71.4 %\nOCaml | 70.0 %\nErlang | 55.0 %\nFortran | 50.0 %\nPerl5 | 46.9 %\nShell/Bash | 42.9 %\nGo | 39.3 %\nD | 38.2 %\nC# | 32.4 %\nPHP | 31.8 %\nawk | 31.3 %\nJava | 20.6 %\nJavaScript | 16.7 %\nACS | 0.0 %\n\nYep, I have nothing good to do today. And my statistics class seems to take its toll on me.\n\n*Edit: Added ACS which I forgot about because it was so NULL*\n\n*Another edit: Added Tcl*"], [66, "Integer division? Really?!? I have a counter suggestion: let's stop including floating point into languages by default. This can be available as an extension, but default must be integer and rational only."], [62, "> A pet peeve. Spot the difference:\n\tif (looks_like_rain()) {\n\t\t...\n\t}\n\tif (!looks_like_rain()) {\n\t\t...\n\t}\n\nI spot it before reading 'Spot the difference'. "], [55, "wait, so always use whitespace when using substraction? as in, 2-3 is a syntax error? i dont like that at all. also, it might just be not being used to this but this-thing looks really weird. it automatically registers as substraction."], [47, "I thought that this was very well written. I agree with a lot of what Eevee wrote, and I appreciate the effort that Eevee made to justify each of the opinions presented, so that even if I don't agree, I at least understand Eevee's cogent reasoning.\n\nOne point in particular that I wholeheartedly agree with is \"Negative modulo\":\n\n> The modulo operator, `%`, finds the remainder after division. Thus you might think that this always holds:\n>\n>     0 <= a % b < abs(b)\n>\n> But no \u2014 if `a` is negative, C will produce a negative value. This is so `a / b * b + a % b` is always equal to `a`. Truncating integer division rounds towards zero, so the sign of `a % b` always needs to be away from zero.\n>\n> I\u2019ve never found this behavior (or the above equivalence) useful.  ...\n\nThis behavior always seemed odd to me. In abstract algebra, we learn about how the integers **Z** is a ring, and the integers modulo n\u2014denoted **Z**/n**Z**\u2014is also a ring. The mathematics is beautiful and seemingly natural. The behavior of many programming languages where `a % b` is negative when `a` is negative thus seems unnatural.\n\nEvery now and then I need to restrict an integer to a particular range, and this presents a dilemma: do I just use `a % max` and ignore the scenario where `a` might be negative? Or, do I write something like `((a % max) + max) % max`? And, if I choose the latter, is this the idiomatic approach?"], [41, "> Single return and out parameters\n\n> Single return: C#...\n\n> Half-assed multiple return: C++11...\n\nShould mention that this were addressed in both C++17 and C# 7.0.\n"], [37, "> It gets a little weirder when you consider that there are type names with spaces in them. And storage classes. And qualifiers. And sometimes part of the type comes after the name.\n\nThe syntax of C declarations can be easily understood by treating them as 2 distinct parts (as per the grammar of the language):\n\n    [specifier-qualifier-list] [declarator]\n\nThe \"specifier-qualifier-list\" can contain storage class specifiers (`static`, `extern`, `auto`, `register`, `typedef`), qualifiers (`const`, `volatile`, `restrict`), type specifiers (`int`, `char`, `double`, `void`, `short`, `long`, `unsigned`, typedef'd names, etc.) and `struct`, `union` or `enum` (with or without a tag). Any of these in *any order*. The compiler checks whether the particular combination means something semantically sensible at a later point.\n\nThe other part is the declarator. You can treat it as an ordinary expression that complies with the precedence and associativity rules of the language. The difference is that the only allowed operators inside it are: the unary `*` (means a pointer instead of dereference), the binary `[]` (means an array instead of subscripting an array), the 1+n-ary `()` (means a function instead of a function call) and the grouping parentheses `()` override the precedence and associativity of the rest. Additionally, you can have `const`, `volatile` and `restrict` sprinkled in between the asterisks, to indicate that they apply only at the particular level of dereferencing the pointer. That's pretty much all of it.\n\nSo, in `extern const volatile _Atomic unsigned long long int *restrict foo[]`, the specifier-qualifier-list is `extern const volatile _Atomic unsigned long long int` and the declarator is `*restrict foo[]`. Because `[]` takes precedence over `*`, that means \"an array (of indefinite size) of pointers to unsigned long long ... whatever... int\". The `restrict` applies to the individual elements of the array (the pointers) and tells the compiler that they cannot possibly alias any other pointers of the same type in the current scope.\n\n> C lets you assign pointers to int variables\n\nOnly if you explicitly turn off `-Wint-conversion` with Clang or GCC, or don't pay any attention to warnings. Any decent compiler will emit a warning by default in such cases.\n\n> I don\u2019t think there are too many compelling reasons to have ++\n\nThe post-increment operator returns the old value with a purpose. Since C is an expression-oriented language, I don't consider this a dirty trick: `stack[size++] = ...`."], [32, "I have a better idea: Let's stop writing JavaScript."], [28, "I program a lot. How often do I have to calculate powers of numbers in my code? Maybe once a year. I don't think that writing pow(x, y) instead of x ** y is too laborious.  \"**\" does not even resemble the mathematical notation."], [29, "> Interestingly enough, C95 specifies `and`, `or`, `not`, and some others as standard alternative spellings, though I\u2019ve never seen them in any C code and I suspect existing projects would prefer I not use them.\n\nI actually used them exclusively in a C++ project I built from scratch at my previous company. I had a few colleagues positively astonished that it compiled, the most savvy ones thinking I had introduced a macro somewhere but unable to find it...\n\nAt first, my colleagues were a bit weird out, but they quickly caught on. The fact that Python uses those too means they were already used to them anyway.\n\nI personally prefer [them](http://en.cppreference.com/w/cpp/language/operator_alternative), because I like having *a modicum of redundancy*; compare:\n\n - The only single character variation of `or` that is a keyword is `xor`.\n - `and` and `not` have no single character variation that is a keyword.\n\nOn the other hand:\n\n - it's pretty easy to accidentally miss `!`, it's easily mistaken for a `(`, `l`, `i` or `j`.\n - it's pretty easy to mistype `&&` as `&` and `|` as `||`, and `|!` is easily mistaken as `||`.\n\nUsing the alternative spelling is like use CRC to get a better guarantee of integrity."], [27, "> Quick test: `1 & 2 == 2` evaluates to 1 with C precedence, false otherwise. Or just look at a precedence table: if equality appears between bitwise ops and other math ops, that\u2019s C style.\nA bit wrong: D, expr, JavaScript, Perl 5, PHP.\n\nIn D, it produces:\n\n    Error: 2 == 2 must be parenthesized when next to operator &\n\nSo this problem does not exist in D.\n\n> And sometimes part of the type comes after the name.\n\nNot in D.\n\n> If 4, you have UTF-8 strings.\n\n4 in D.\n\n> C#, D, expr, Lua, and Standard ML have no octal literals at all.\n\nD at one time did have octal literals, but no more. They have been replaced with a template instantiation:\n\n    import std.conv;\n    int mask = octal!777;"], [21, "Re: Assignment as expression\n\n    if (ptr = get_pointer()) \n    {\n        ...\n    }\n\n*versus*\n\n    ptr = get_pointer();\n    if (ptr) \n    {\n        ...\n    }\n\nI prefer the latter, since it's easier to debug.\n\n\n"], [20, "As a hardcore C fanboy I feel split about this article. Some very valid points are raised (single var returns, error handling, #include) but I think some of the qualms the author has with C come down to coding conventions.\n\n* C has a pow() function included in the standard library, and a ** operator wouldn't work since you can have indirect pointers.\n\n* I don't see any issue with for loops. The syntax is great when you want to iterate in weird ways. \n\n* Your issues with typing are with bad coding style. I rarely use typedefs, and when I do, you always add \"_t\" to the name. I'd say the issues raised with braces is also dependent on coding style. \n\nIn my not-a-professional-programmer opinion, I think it comes down to the fact that C is very flexible but has specific use cases - low level, high performance, etc. I have written a hobby operating system, assembler, and Scheme interpreter in C. For projects that involve lots of string manipulation, internet connectivity, first class functions etc I turn to a higher level language. "], [24, "The author had me until they suggested to get rid of braces and use python-style indentation. _Shudders_."], [16, "The exponentiation operator was added to JavaScript in ECMAScript 2016, and it uses \\*\\*."], [16, "\"The great thing about static typing is that I know the types of all the variables, but that advantage is somewhat lessened if I can\u2019t tell what the variables are.\"\n\nHa! Just finished a small C++ project and this is true. The auto type inference is a bad trade off: it saves typing when writing the code, but the error messages produced get more and more surreal as the code grows."], [13, " He makes some good points, but many of his suggestions come at a cost to performance.\n> If you\u2019re willing to ditch the bitwise operators (or lessen their importance a bit), you can even use ^, as most people would write in regular ASCII text.    \n\nWhy would you want to get rid of bitwise operators?  They're ***so*** much faster in some situations."], [6, "> Half-assed multiple return: ECMAScript 6\n\nES6's MRV semantics are identical to Ruby's and very close to Python's (with the difference that the RHS in Python can be an arbitary iterable), it should be in the section below. It is a bit noisier due to explicit variable declaration, but then e.g. Rust would be disqualified as well.\n\n> Half-assed multiple return:  Erlang\n\nErlang literally just uses tuples for MRV, they have an unusual syntax (braces) but they're still tuple. Erlang's MRV is also used for a pseudo-monadic error system.\n\nWhich incidentally means Erlang's classification in the next section is also incorrect, does have exceptions but they're usually used in the same way they are in Rust (as terminal faults, though that), rarely used for error signalling (except across processes through supervision links).\n\n> Half-assed multiple return: PHP\n\nWhile true, the `list()` special form really doesn't belong with C++ and D, PHP can at least unpack MRVs at the binding site.\n\n> Multiple return via tuples: Go\n\nGo doesn't have tuple, MRV is a special case of the language (and some builtins even have variable-arity return). In fact the lack of tuples is the first \"type system\" item in /u/munificent's \"The Language I Wish Go Was\" essay from way back in 2010.\n\n> C++17 doesn\u2019t quite have the same problem with std::optional<T>, since non-reference values can\u2019t be null.\n\nAFAIK it's non *pointer* values which can't be null, C++ references can't legally be null (just getting a null reference is an UB, let alone using it).\n\n> Everything\u2019s an expression: Rust.\n\nAssignment is an exception to that rule, it's a statement. `if a = b` is not legal in Rust. Some pattern matches (`if let`) look similar but are subtly different. Also\n\n> Rust has a special if let block that explicitly combines assignment with pattern matching, which is way nicer than the C approach.\n\nTechnically `let a = b` is already a pattern match, but it only allows *irrefutable* matches. `if let` (and the full `match`) allow *refutable* matches as well. Though many FP languages allow refutable matches in \"assignments\".\n\n> Bracing myself: C#, D, Erlang, Java, Perl, Rust.\n\nErlang's semi-colons are *separators* between match clauses, and commas are *separators* between statements. This means the last match doesn't get a semicolon (it gets a period) and the last statement of a block doesn't get a comma.\n\nRust is also a bit of a weirdo, semicolon semantics are a bit different than they are in C, IIRC."], [8, "How about people that have never programmed in C, stop complaining about C."], [7, "Maybe I'm just old fashioned but I've never understood why people hate \"type first\". You can always just use a dynamically typed language or one that supports inference but in a statically typed language, I  don't see how its an issue at all."], [5, "It all depends on what the outcome/goal is. For C some of its design decisions do make sense given the context, as they cannot assume too much about the underlying hardware, are just trying to expose that hardware in a more convenient and portable way than writing in assembly, but are not trying to take on the responsibility of guiding or forcing the programmer into architecting good solutions (this can easily be seen in contrast to C++ which definitely is trying to get the programmer to architect better solutions, or at least what they consider to be better architectural design decisions). \n\nAs there's pros and cons to either languages that tell you how you should write your programs and those that do not (like C). I don't think there's any one clear choice, rather it depends on what the language is trying to achieve. Although the higher level the language is, the more I'd expect it to tell you how you should be writing programs in it. \n\nA number of languages that copy C, are just copying C syntactically (which the article does address some of C's syntactical issues). This is probably more so just as a result of trying to make their language feel familiar to those who do not know the language itself (compared to if they made a completely new syntax which would make it feel very foreign). I don't think there's any one answer here, as at the end of the day we all have our own preferences. \n\nI disagree with the articles criticism of for loops in C. For one they're needed, C's types lack the information to know how many elements should be iterated. The type that could potentially offer it would be arrays (where you can guarantee `sizeof(array) / sizeof(typeof(*array))` would equal the number of elements in the array), but there's a number of fundamental floors with offering a foreach with that behaviour. The first is, just because the array is declared to hold a certain amount of elements, doesn't mean those are the actual \"elements\" you want to iterate (an array like this is not the same as a container). The second is problems arise with how passing references of arrays work, as you'll only get a pointer reference to the array rather than a copy of the array itself, this means that the information required for the above is now lost, the biggest implication of this would be in confusing programmers that aren't being careful (since C's type system wouldn't be able to protect them from this). The third is how should element references work? Should your iterations get a pointer to the element or should you get a copy of the element. The fourth as alluded to earlier, C has no containers, if you want an iterate-able list/collection of values in C you have to build that up from the underlying fundamentals (which given its relaxed nature, you can do in a variety of ways), so simply because of this I'd argue it would be incorrect to introduce any kind of notion of foreach into the C standard. If you want these constructs (such as foreach) you have to build them (which you certainly can), which I think is fine given what C is.\n\nAnother complaint I had (much in the same vain as the for loops) was regarding strings. This is another example of where you should really be building the string type you want, rather than using what is provided for you (unless it works for your given situation). \n\n> Most runtime errors in C are indicated by one of two mechanisms: returning an error code, or segfaulting.\n\nThat's only if you're lucky enough to have your uncaught runtime error produce a bus error or segfault. You can easily have runtime errors that will happily go by unbeknownst to you. Or it might only blow up on very specific conditions. "], [6, "In the type first topic, I want to say that C++'s auto may be used for type inference, so you don't need to put the type before variable's name. Also, classes now have type inference, meaning that we don't need to complete their template parameters when instantiating them, nor use functions like `make_*` anymore (except for `make_shared`, which allocates one block of memory for both value and the reference counter).\n\n    auto foo = std::tuple{42, \"call me maybe\"s, 3.14f};\n\nThough you may say that classes like `std::unique_ptr` still need its template parameter to be given (and it remains true even for the `make_unique` function). That's true, but C++17 brought something to help us out in this case. There's a way to help the type inference on guessing a class's template parameters called [deduction guide](http://en.cppreference.com/w/cpp/language/class_template_deduction). Basically, this allows for writing guides to the type deduction system, like so:\n\n    template <typename T>\n    explicit unique_ptr(T*) -> unique_ptr<T>;\n\nWhenever we pass a pointer to a type `T` to `unique_ptr`, this guide will tell the type deduction that now we want `unique_ptr` to be guessed to `unique_ptr<T>`, thus allowing us to do so:\n\n    auto foo = std::unique_ptr{new int{42}};\n\nWe could also do something like that for vectors:\n\n    template <typename T, typename... Ts>\n    requires (std::is_same<T, Ts>{} && ...)\n    vector(T, Ts...) -> vector<T>;\n\nNow we can write:\n\n    auto vec = std::vector{1, 2, 3, 4};\n\nThough I hope the standard brings these specific guides in future std libraries (I haven't seen a word on it)."], [6, "It annoys me, around the integer, that he previously says weakly typed implicit conversions are painful (which I agree with, I always explicitly cast), but then goes on to say 7/2 = 3.5. No, 7/2 should equal compile-time exception: cannot divide integers. (double (7/2)) should equal 3.5. "], [5, "I feel dirty saying this, but my favorite language for optional/mandatory block delimiters is Microsoft Basic (QuickBASIC, QBASIC, classic VB, VB.Net -- anything newer than BASICA/GWBASIC).\n\nYou can say \"If condition then DoStuff\" with no End If, but only if it's all on the same line.  It avoids cluttering the code with really simple checks, but otherwise you get the delimiters with no question of where an open brace should go."], [4, "kudos for the share. Although the author seems to have good intentions I question the value of such bitching about what works and has worked for several decades. If you have a new hotness, blog about why it's great, not why everything else sucks..."], [3, "> To be fair, C is pretty consistent about making math operations always produce a value whose type matches one of the arguments. \n\nActually... `char * char` gives an `int`. C++ pilfered the rule, so we can use it to inspect the resulting type:\n\n    #include <iostream>\n     \n    #define PRINTER(Type_) void print_type(Type_) { std::cout << #Type_ \"\\n\"; }\n     \n    PRINTER(char)\n    PRINTER(unsigned char)\n    PRINTER(short)\n    PRINTER(unsigned short)\n    PRINTER(int)\n    PRINTER(unsigned int)\n     \n    int main() {\n    \tprint_type('a' * 'b');\n    \treturn 0;\n    }\n\n(see [ideone](http://ideone.com/O18XLE)).\n\nIn C and C++, any integer type smaller than `int` is first widened to `int` before an arithmetic operation is applied to it."], [3, "[Try this to feel better fellow C and C alike developer](http://h2co3.org/blog/index.php/2016/12/01/lets-stop-bashing-c/)"], [3, "Some comments are ok but some are WTFs or show that he does not know all the languages by heart.\n\nFor instance, no mention of ruby's \"unless\" rather than \"if !\".\nNo matter if you use it or not, it should be mentioned.\n\nOther parts are weird:\n\nNo hyphens in identifiers\n\n\"snake_case requires dancing on the shift key (unless you rearrange your keyboard, which is perfectly reasonable). It slows you down slightly and leads to occasional mistakes like snake-Case.\"\n\nWTF? Slows you down? Compared to what? SnakeCase? I have to hit a second key for the upcased 'c' too, so I don't get that statement... how is that different from an underscore???\n\nI think that the main difference is cultural mostly. Some communities love snAkInG around, others don't. I am looking at you python which I speak natively for all my scaly friends - ssszZSzzSszsss."]], [[{"comment": "> \u201cOh boy!\u201d says your prot\u00e9g\u00e9. \u201cLet\u2019s see what 7 \u00f7 2 is! Oh, it\u2019s 3. I think > the computer is broken.\u201d\n\n> They\u2019re right! It is broken. I have genuinely seen a non-trivial number of > people come into #python thinking division is \u201cbroken\u201d because of this.\n\nI disagree on this one.  I chose int because I want the performance of integer arithmetic.  I don't want to pay the penalty of convert to float, do float division, can convert back to int just because some amateur cooks don't realize that knives are sharp and can cut you.\n \n\n", "id": "danlgmu"}, {"comment": "Or sometimes that's just the behaviour you want. If you want that behaviour, then having to wrap every division with a call to floor is going to make it harder to read.", "id": "danmnru"}, {"comment": "Python has [//](https://www.python.org/dev/peps/pep-0238/) for this.", "id": "danngns"}, {"comment": "In Dart, truncating division is done with [~/](https://api.dartlang.org/stable/1.20.1/dart-core/num/operator_truncate_divide.html). (// is a comment.)", "id": "danpos7"}, {"comment": "One of my **very few** frustrations with Ada is that division rounds rather than truncates (1 / 2 = 1, but 1 / 3 = 0). I know it's likely the \"more correct\" answer, but that was likely my most common error. \n\nEdit: I was mistaken (it's been too many years since I've been able to work in Ada professionally). I was thinking of converting a float to an integer (e.g. `Integer (F)`). ", "id": "danno1j"}, {"comment": "Strange, the [ARM](http://www.ada-auth.org/standards/12rm/html/RM-4-5-5.html) says otherwise:\n\n> Signed integer division and remainder are defined by the relation: \n\n    A = (A/B)*B + (A rem B)\n\n> where (A rem B) has the sign of A and an absolute value less than \n> the absolute value of B. Signed integer division satisfies the\n> identity: \n\n    (-A)/B = -(A/B) = A/(-B)\n\nwhich is a definition of truncating. A mod B is 0 or has the sign of B,\nit is not rounding either (and has no corresponding division operator).\nThere is also a nice table showing a few examples in the link.", "id": "danqvdx"}, {"comment": "The point is that the meaning of / is overloaded and unclear to novices and even to routine programmers in cases where the types of values isn't immediately obvious. Other languages solve this by making integer division explicitly a different operator.", "id": "danp6uw"}, {"comment": "Not that I am in favor of making things pointlessly complicated to novices, but novice comprehension is probably the singular worst metric I have ever read for how a programming language should be set up. Many novices are also confused by: objects, inheritance, functions, types, loops, recursion, if statements, and basic syntax.\n\nAnd there isn't really a better alternative to integer division that I am aware of regarding beginners. You could have the system default to doubles or floats, but then you'll have novices equally confused about rounding errors. Try explaining to a beginner how IEEE 754 floats are actually set up and their eyes will gloss over. Atleast integer division has relatively simple rules and many people are exposed to it in grade school when they learn about remainders before moving on to decimals. \n\n", "id": "danvluk"}, {"comment": "> ut novice comprehension is probably the singular worst metric I have ever read for how a programming language should be set up.  \n\nThis.  I learned quickbasic in the early 90's writing BBS software, and my first exposure to C was the WWIV BBS engine.  It was like looking at ancient Sumerian for me with all the wobbly braces and strange variable declaration of old-style C \n\n    main(argc, argv)\n    char *argv[];\n    {\n        return 0;\n    }", "id": "danx9cc"}, {"comment": ">Other languages solve this by making integer division explicitly a different operator.\n\nWhich is fine. C is still primarily a systems language where we are trying to write optimal code and not use floating point in a 8kb micro or get shot in the face by yet another Intel floating point bug in a kernel.", "id": "danpr68"}, {"comment": "The point isn't to remove integer division and only do floating point division. It's to give the two things different names.", "id": "danqr8j"}, {"comment": "Well, same for C. They just chose to give the `/`-name to the more useful operation, and call the other one `*1.0/`.", "id": "danyzzh"}, {"comment": "Yeah, that's kind of a ridiculous criticism. You're doing division with integers, therefore you get integer division. Don't blame the programming language because most math (and, even, comp sci) curriculums freely mix integers and rationals.", "id": "danvy8r"}, {"comment": "At the same time, it can often be a little annoying if you're trying to figure out a simple expression like\n\n    float day_frac = time_s / stats::day_length_s;\n\nAnd you're far removed from the definitions. Its not a huge issue but it does give me pause\n\nI'd prefer no implicit conversions between float/int/double myself, they're fundamentally different things and I don't want the compiler to pretend they're similar", "id": "dao9neb"}, {"comment": "Interesting choice of instruction wrt. to division then, given that integer division is usually a good bit slower than float division.\n\nFor Haswell:\n\n|instruction | latency (cycles before result is ready) | recip. throughput (cycles before next issue)|\n|---------|---------|----------------------------------|\n| div r8   | 22 - 25 | 9 |\n| div r16 | 23 - 26 | 9 |\n| div r32 | 22 - 29 |  9 - 11 |\n| div r64 | 32 - 96 | 21 - 74 |\n| ---------- | ---------- | ---------- |\n| idiv r8   | 23 - 26 | 8 |\n| idiv r16 | 23 - 26 | 8 |\n| idiv r32 | 22 - 29 | 8 - 11 |\n| idiv r64 | 39 - 103 | 24 - 81 |\n| ---------- | ---------- | ---------- |\n| fdiv(r)(p) | 10 - 24 | 8 - 18 |\n| divss / divps | 10 - 13 | 7 |\n| divsd / divpd | 10 - 20 | 8 - 14|\n| vdivps | 18 - 21 | 14 |\n| vdivpd | 19 - 35 | 16 - 28 |\n\nsource: http://www.agner.org/optimize/instruction_tables.pdf\n\nWith that said, I agree that the current behaviour is useful and I wouldn't want it to change.", "id": "danqbwe"}, {"comment": "Depends on what you want as an output as well, some platforms (notably embedded platforms) pay a non-trivial cost for any conversion from integer register to a floating point register.   While the floating point div may be faster, if you intend to use the results in other integer math or in branching instruction it may wash out or be worse.", "id": "danrkys"}, {"comment": "Good point; I shouldn't make blanket statements like that without benchmarking.\n\n[I'll run a comparison and post the results.](http://i3.kym-cdn.com/photos/images/original/000/293/051/bb8.jpg)\n", "id": "danugr1"}, {"comment": "Here's the result from my benchmark.  I ran a loop a bunch of time doing MDAS on 16-bit integers, storing the results in 16-bit integers.  Then I ran with the same numbers using 32-bit integers storing the results in 32-bit integers, and so on for several data types.\n\n    16-bit integer ....  3682 milliseconds\n    32-bit integer ....  3588\n    64-bit integer .... 10998\n    32-bit floating ...  6505\n    64-bit floating ...  7457 \n\nThe only result that surprised me was the 64-bit integer.  I'm running a 64-bit OS on a 64-bit chip.\n", "id": "dao1d4f"}, {"comment": "Need to see what instructions this is using to know what this means. Also, which processor?", "id": "dao1o1w"}, {"comment": "100% agree. Programming computers is different then some sort of infinite precision, freely-casting math abstraction and this is just one of the things programmers have to learn.\n\nThat being said, for some high level scripting language that is used for different tasks this may be exactly what you want.", "id": "dantzpu"}, {"comment": "It difference in speed between int/float and converting is so trivial that most C programmers ignore it. By the time Python figures out what division means for its args you've wasted 2000x the time of converting everything to a float, division, and casting back to an int.", "id": "dantm4s"}, {"comment": "Math in most languages is \"fundamentally broken\" anyway as far as the prot\u00e9g\u00e9 would be concerned. Just try  3.3 == 3 * 1.1. Hint: the answer is false in any language using binary floating point. Integer math is less complex than IEEE floating point math and as a consequence easier to reason about for a novice - it does not help that float math can give different results depending on CPU register size and optimization settings.", "id": "dao3vop"}, {"comment": "> 7 \u00f7 2\n\n    ~ $ perl6\n    To exit type 'exit' or '^D'\n    > 7 \u00f7 2\n    3.5\n    >", "id": "danotqx"}, {"comment": "> > 7 \u00f7 2\n\nDid you just type `\u00f7` in a terminal? 0_o Why is it even accepted by the language? :o", "id": "danq817"}, {"comment": "Because it's Perl?", "id": "danr0rb"}, {"comment": "Yes, I just did a copy-and-paste of the quote into my terminal.\n\nYou might like this:  (unicode roman numerals)\n\n    > my $\u03a9 = \u2162 * \u216c\n    > say $\u03a9\n    150\n", "id": "danrhys"}, {"comment": "Perl 6 is fairly liberal with operators. Pretty much anything that can be represented in Unicode graphemes is fair game for operators.\n\n", "id": "danszk8"}, {"comment": "His point was that beginners don't understand that dividing integers will always give you another integer; it's counter-intuitive.\n\nSmalltalk does it right. The result of `7/2` is `(7 / 2)`. What is that? It's a Fraction! It's another subclass of Number which has a numerator and a denominator. You can use it like any other number, although you need to make sure you convert it to a float before you show it to the user.\n\nWant an integer? Okay. `(7/2) asInteger.` is `3`. Want a float? `(7/2) asFloat` is `3.5`. ", "id": "dao9n6u"}, {"comment": "Couldn't you argue though that correctness should be the default, not performance?\n\nEveryone starts out as amateurs, better to have slow but correct software, rather than fast and buggy.", "id": "dao1xmj"}, {"comment": "Except that C was designed with performance in mind. Not all languages should be like this, you're correct, but some languages should allow for it.", "id": "daoiw6g"}, {"comment": "> Except that C was designed with performance in mind.\n\nThe same cannot be said of the bulk of the languages which copied C's semantics.", "id": "daoq73t"}], [{"comment": "> But a double* might be NULL, which is not actually a pointer to a double; it\u2019s a pointer to a segfault.\n\nI lol'd", "id": "danlxq2"}, {"comment": "If only that were true... I happen to work on a system (z/OS) where you can always dereference a NULL pointer without getting a segfault. The page at address 0 is guaranteed to be accessible.", "id": "dantos4"}, {"comment": "Dereferencing `NULL` is also undefined behavior. The compiler assumes you wouldn't do such a thing, which can lead to both interesting optimizations and some _really_ bizarre bugs.", "id": "danvh5t"}, {"comment": "That's awesome. Please tell me its a zero'd page.", "id": "danu576"}, {"comment": "Lol, no :) It contains pointers to the most important operating system data. Usually it's read only, so you're safe. There are situations when it is read write though, if you happen to overwrite it, you may as well hit the reboot button.", "id": "danufey"}, {"comment": "I can't remember exactly how the option worked, but vxWorks had some build flag where you could either enable or disable all access to the 0 page, or enable/disable write-access to it.\n\nOur organization had some teams that argued for leaving the flag in the \"enable access\" state, because their code was so bad that it would throw unknown/untraceable access violations when run in the more strict mode.\n\nso they had pointer bugs (in our organization's code, not in vxWorks itself) that they couldn't track down, and they wanted to just hope they never hit those bugs during regular runtime, and/or hope they could bring things back online with recovery if/when it happened...rather than fix their code.\n\nthis was in the guts of an LTE network infrastructure product.\n\nsadly, they won the political/budget/schedule battle on that one.", "id": "dao773n"}, {"comment": "Is there a compiler setting for whatever C compiler z/OS ships with to insert null checks on all pointer dereferences (that can't be proven to never be NULL) or would that kill performance / not be useful?", "id": "danuwvi"}, {"comment": "Yes, there is an option to do that. I didn't know that until you made me look, actually. Probably not good for performance though, but I would need to measure that.", "id": "danvlgc"}, {"comment": "What would be a good benchmark? I can think of a shitty one off the top of my head. I think Perl has been ported to z/OS so you could run the test suite for perls compiled with and without that setting.", "id": "danw7hg"}, {"comment": "> you may as well hit the reboot button\n\nConsidering what z/OS runs on, not exactly an option, eh?", "id": "daogxz8"}, {"comment": "Wat.\n\nSo if these machines are supposed to run such super critical stuff to justify the ridiculous costs of a mainframe running z/OS, why do they set themselves up for catastrophic failure with terrible design like this? :S\n\nI hope it's only read-write in some kind of supervisor mode. (I have no idea how the permissions system works on these)", "id": "daowdp2"}, {"comment": "A NULL pointer [doesn't necessarily have the *value* 0](http://c-faq.com/null/machexamp.html) though. And NULLs for different types may have different values (representations).", "id": "danvr85"}, {"comment": "However (from http://c0x.coding-guidelines.com/6.3.2.3.html)\n\n* An integer constant expression with the value 0, or such an expression cast to type void *, is called a null pointer constant.\n* Any two null pointers shall compare equal.", "id": "daopwuv"}, {"comment": "So? When you convert 0 to a pointer, it can change the bit value. And comparison knows about that.", "id": "daotbqz"}, {"comment": "I guess it means that unless you're actually able to dereference a null ptr, the fact that null might be nonzero doesn't effectively matter. And if you're able to dereference a null pointer on an OS that you're supporting, you should be taking larger steps towards safety in that regard.. but that would have been true even if null was always guaranteed to be equal to zero.", "id": "daovwb3"}, {"comment": "Even though you type `(void *)0` in the source code, the actual pointer may end up having the value 0x589abf8a8f3 or anything else your target system desires (including an arbitrary address with the \"null pointer flag\" set) \u2013 as long as it compares equal to all other instances of `(void *)0`.\n\nThis is incredibly unintuitive, which is why people have recommended to use the constant `NULL` (and more recently, `nullptr`) in source code instead. Sure, its definition is `#define NULL (void *)0`, but that makes it more clear that a \"null pointer\" is an abstract concept defined in the language \u2013 not necessarily a physical memory address.", "id": "daovu9p"}, {"comment": "I used to work in a place where the code ran on both Solaris and AIX-based mainframes (IBM). Whenever we got a bug-report that was Solaris-only, it meant that someone dereferenced NULL, but the consequences weren't enough to break the program after that point. So standard practice was to route those services over to the IBM machines until a fix could be prepared.", "id": "dao1qiv"}, {"comment": "Another z/OS developer?  You should hang out with us in /r/mainframe !", "id": "dao0zcg"}, {"comment": "Linux used to allow any program to mmap memory at 0 and use it, but I think it led to exploitation of NULL dereferences in the kernel, somehow. Now programs aren't allowed to map addresses lower than the vm.mmap_min_addr sysctl, which is by default set to 65536. The relevant chain of emails discussing this is here: http://yarchive.net/comp/linux/address_zero.html", "id": "daodlrf"}], [{"comment": ">a language from 1969 \u2014 so old that it probably couldn\u2019t get a programming job.  \n  \nOuch.", "id": "danjmk5"}, {"comment": "I don't understand that argument, you don't stop using something when its old, you stop using it when it stops being useful.\n\nChairs were invented so many years ago, we should stop using them. No I don't have any better alternative, but until we find one, we can sit on the floor, no way I'm sitting on chairs again, such an old technology.", "id": "dankis3"}, {"comment": "I believe it is a jab at the current hiring environment for programming jobs that descriminates against older applicants. ", "id": "dankrbi"}, {"comment": "I'm not sure whether it's a jab or if the practice is so commonplace that many people don't even notice it as a problem.", "id": "danpr2a"}, {"comment": "If you're older, you notice it as a problem.", "id": "dao9n0z"}, {"comment": "Or if you're younger and don't have your head stuck up your own ass.", "id": "daol0lg"}, {"comment": "I think this is the correct interpretation of that grotesque statement.", "id": "dantwsd"}, {"comment": "We *do* have better alternatives.\n\nIn most cases, C is absolutely the wrong language anyway. I can't believe people *still* write high-level programs in C.\n\nIn most cases, probably about 5-10% of the code are performance critical anyway. Write those in C if you absolutely must and the rest in a sane language.\n\nAnd what about Rust? Probably *too hard to segfault*, with its strong typing and borrow checker. People would have to actually think before they write and ship code, and that's not the C way :)\n\nBut yeah, if your platform only has a C compiler, then sure, code in C.", "id": "danp68z"}, {"comment": "Honestly, even if you value C for its simplicity and want to write OO-free C-style code, you should still probably use C++. RAII, move semantics, guaranteed copy elision (coming in C++17), templates, and the STL are just too valuable to pass up.", "id": "danrj4c"}, {"comment": "C++ is not necessarily better than C. In many cases, C is exactly what you need", "id": "dantoku"}, {"comment": "My point was that many of the problems C++ solves are problems you're going to have to solve during normal C development in any decent sized project. Templates, RAII, and the STL come to mind. Doing that in pure C is just reinventing the wheel in a project-specific way.\n\nAlthough there are some cases were you don't have a choice.", "id": "dants4y"}, {"comment": "I strongly agree (and this is how I tend to write C++). C++ does not need to be massively more complicated than C, and move/ownership semantics provide an extremely useful way to reason about programs. Plus more stack allocation is always a good thing, and C++ makes that a lot easier than C.", "id": "danu24h"}, {"comment": "> Plus more stack allocation is always a good thing\n\nMade me twinge for a moment, on reflex. :) On modern systems, yes. In the past, stack allocation was something to minimize -- but you'd also avoid dynamic heap allocations too.", "id": "danuwk5"}, {"comment": "Hahahaha, while updating my game engine, I changed my mesh loader to load into the stack instead of the heap, it made it about 20 times faster. But, since I support some Very Large meshes, I have to reserve almost a whole gigabyte of stack space (~48 bytes per vert:pos,norm,tan,uv,index,bone info,etc. allowing a couple million verts per mesh). Setting the Stack Reserve Size to 1000000000 looks so wrong, but the performance gains feel so right.", "id": "danybjp"}, {"comment": "Good lord man, at that point I think you might just wanna implement a custom memory allocator.\n\n\u2026Though you do get points for having the balls to allocate a gigabyte of stack space. I think I would not have been able to get myself to do that.", "id": "dao0luo"}, {"comment": ">Good lord man, at that point I think you might just wanna implement a custom memory allocator.\n\nNot a bad idea, adding it to my backlog.\n\n>\u2026Though you do get points for having the balls to allocate a gigabyte of stack space. I think I would not have been able to get myself to do that.\n\nI did it an order of magnitude at a time, each time wondering if I could really get away with it.", "id": "dao42p3"}, {"comment": "Templates and STL are a nightmare for those who value simplicity.", "id": "danu94e"}, {"comment": "If and only if, when abused. They can make multitude things much simpler in terms of API design, for cost of complex abstraction. \n\nAnd STL can make sometimes your life much easier, doubly so, when working with default collections. Which you are doing most of the times. ", "id": "dao318c"}, {"comment": "I think a better analogy is choosing to sit in upholstered furniture rather than (what were presumably the first chairs) conveniently located rocks. The fact is that as humanity acquires new knowledge over time and our grasp of technology improves, we tend to make better stuff. I don't stop using things when they're no longer useful, I stop using them when better options become available.", "id": "danm1cz"}, {"comment": "Tricky thing is, most of my early \"office-chairs\" were worse for my back than a wooden dining chair. Sometimes new things are nice for a bit, but then you realise they're subtly doing very bad things.\n\nC, well C is overt bad things, and some subtle bad things ...", "id": "dao9x60"}, {"comment": "> a language from 1969 \u2014 so old that it probably couldn\u2019t get a programming job.\n\nbut it can still boot your computer.", "id": "daoozi1"}], [{"comment": "So I actually took the time to count how many times each language was mentioned and tried to decide whether that was positively, negatively or ambiguously. Here are the languages I found at least 7 times, sorted by how positive their overall rating was according to the author's preferences:\n\nLanguage | Rating\n-------------|---------:\nHaskell | 100.0 %\nPython3 | 94.1 %\nJulia | 92.9 %\nLisps | 91.7 %\nAda | 88.9 %\nF# and Nim | 87.5 %\nLua | 85.7 %\nPerl6 and Ruby | 75.0 %\nPython2 and Swift | 73.5 %\nRust | 72.2 %\nBASIC, COBOL and Tcl | 71.4 %\nOCaml | 70.0 %\nErlang | 55.0 %\nFortran | 50.0 %\nPerl5 | 46.9 %\nShell/Bash | 42.9 %\nGo | 39.3 %\nD | 38.2 %\nC# | 32.4 %\nPHP | 31.8 %\nawk | 31.3 %\nJava | 20.6 %\nJavaScript | 16.7 %\nACS | 0.0 %\n\nYep, I have nothing good to do today. And my statistics class seems to take its toll on me.\n\n*Edit: Added ACS which I forgot about because it was so NULL*\n\n*Another edit: Added Tcl*", "id": "danvoww"}, {"comment": "And javascript is now the most popular, most pervasive language. It's the new C. \n\nThe problem is not technological. It's social. \n\nLook how popular the You Don't Know JS books are nowadays. Look how often they get praised on reddit. A terrible, terrible series of books. There's absolutely nothing new in these books information-wise, only a lot of \"fuck the good parts, you should use ALL the parts... dae leet.. derp\". People will juggle knives just to look edgy. \n\nPro tip: If you want to design the next mostly big language, don't make it a safe, thoughtfully designed one where little can go wrong. Nope. Make it so shitty and so needy of fixes that people will have plenty to blog and brag about for years and years and years. ", "id": "dao0obm"}, {"comment": "> People will juggle knives just to look edgy  \n\nI am *so* using that in the future. Thank you.", "id": "dao3anx"}, {"comment": "Bleeding, how to fix? ", "id": "daooqdy"}, {"comment": "> Pro tip: If you want to design the next mostly big language, don't make it a safe, thoughtfully designed one where little can go wrong. Nope. Make it so shitty and so needy of fixes that people will have plenty to blog and brag about for years and years and years.\n\n...no. If you want to design the next big language, make a system of communication between computers across the world, develop some software to browse the data those computers are serving, get that to be a massive part of the average person's day, but not before adding scripting support to that system in such a way that it's inherently open source, and no other language can feasibly be added in the future.", "id": "daockep"}, {"comment": "Yup. People don't purposely use shitty languages, shitty languages are the most widely available. C was popular because Unix was built on it, Basic was popular because it came with every computer of the late 80's, and Javascript is popular because every browser runs it.", "id": "daoph8x"}, {"comment": "> C was popular because Unix was built on it\n\nI think C also competed pretty strongly on technical merits when you consider the constraints of the time.\n\nPascal, Lisp, and ML are all older and ostensibly \"better\" but:\n\n* Pascal's string handling was so limited\u2014strings of different length have different *type*\u2014that it was virtually impossible to reuse code for working with strings.\n\n* Lisp was too slow for system- and general application programming.\n\n* I'm not sure if ML even had working implementations at the time.\n\nC is actually a pretty nice language *for the seventies*. I think the reason *why* it was was because Ritchie was building it in the context of Unix. The best way to do good design, I've found, it is simultaneously be a real user of the thing you're designing.", "id": "dap5q1o"}, {"comment": "Hm, I don't know.  I say back in the day, the most popular language was BASIC.  It was in almost every microcomputer imaginable.  JS is the new BASIC, not the new C.", "id": "dao9yon"}, {"comment": "Sadly the essay repeatedly misclassifies some languages. I feel Erlang was misclassified more often than it was correctly classified.", "id": "dao0rsx"}, {"comment": "Yeah, some of the Erlang ones really confused me. For some reason it's in the \"half-assed multiple return\" category instead of \"multiple return via tuples\", despite the fact that Erlang is all about tuples. I also wanted to see it called out in the \"assignment as expression\" section, since `=` in Erlang is a match operator.", "id": "dao3ysz"}, {"comment": "Before calling in ratings, it'd be a good idea to make very clear what it's rating. Brainfuck could score high in this chart. That doesn't make it a great language.\n\nThis mostly just takes things that are considered to be irritating in C and checks if the other languages do it \"differently enough\". It doesn't take into account the languages' other strengths and weaknesses.", "id": "daoaxuk"}, {"comment": "I just summed up in numbers how the article speaks about different languages, that is from the perspective of whether they share subjectively judged flaws with C. No more to it than that, I did it just for fun :-)", "id": "daobmvp"}, {"comment": "I knew haskell was good, but that good", "id": "danzeup"}, {"comment": "To be fair this is really just how syntactically good it is.", "id": "dao0jb6"}, {"comment": "Not even that. It's how good Haskell is at not having the same syntax problems as C, which still leaves plenty of room for it to have syntax problems all of its own.", "id": "daod4p2"}, {"comment": "Haskell has its own problems. For example, the record system is an absolute mess.", "id": "dao4rmu"}, {"comment": "And laziness turned out to be a pretty crappy default.", "id": "dao6144"}, {"comment": "There are arguments for both sides here.\n\nThere's [no consensus](http://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html) on that one.", "id": "daobwec"}, {"comment": "Their spec on C# is outdated though. C# 7 supports multiple returns via Tuples, for instance.", "id": "dao9k44"}, {"comment": "Technically that's still not a multiple return, but achieves a similar thing.", "id": "daosc3k"}, {"comment": "It is an MRV via tuple (rather than as special syntax), which is perfectly fine and an entire category of MRV in TFA. The vast majority of language do MRV via tuple (or unpacking/deconstruction of some sequence type).\n\nThe problem is more that C# 7.0 isn't a thing at this point.", "id": "daov4p7"}, {"comment": "This doesn't say much. F#, for example, is cited maybe half of the times it should be cited. ", "id": "dao4nm9"}], [{"comment": "Integer division? Really?!? I have a counter suggestion: let's stop including floating point into languages by default. This can be available as an extension, but default must be integer and rational only.", "id": "dannvh6"}, {"comment": "Seriously.  If you want to be a programmer, learn how computers work.  The existence of integer types is all the justification needed for integer division.", "id": "danqcwh"}, {"comment": "Integer division should probably have a separate operator because it's semantic meaning is different from floating point division.\n\nEDIT: spelling", "id": "danwndh"}, {"comment": "IMO the semantic meaning is the same, it's just not possible to store a fraction in an integer type.", "id": "dao760g"}, {"comment": "> The existence of integer types is all the justification needed for integer division.\n\nExactly. I can understand the reasons why you may not always want to have an integer division implemented in hardware, but at least a software implementation is always mandatory. And of course the reasoning given by the OP is plain ridiculous. ", "id": "dans2y1"}, {"comment": "The suggestion that the `/` operator return a `float` or `double` was completely ludicrous.  I can understand calling it `div` or something to make it more obvious, but holy crap.", "id": "danseb8"}, {"comment": "That's how you can spot a JavaScript/Python/Ruby/etc programmer complaining about lower level languages.", "id": "danu7np"}, {"comment": "fun fact: `7 / 2 == 3` in Ruby", "id": "daob28a"}, {"comment": "You really like kicking hornet nests.\n\nHere's my suggestion: express all numbers as [computable real numbers](https://en.m.wikipedia.org/wiki/Computable_number). Problem solved.", "id": "danoojn"}, {"comment": "Can we not? When languages get too fancy with their built-in numbers you can get unexpected promotion and other strange problems. Most of the time what you want is either an arbitrary precision integer or a fixed-width integer that throws an error on overflow.", "id": "danvpn4"}, {"comment": "\\>not doing all your numerical stuff using Cauchy sequences in lieu of numbers\n\nIt's 2016, get onboard with the program kid.", "id": "danwqcp"}, {"comment": "Hey man, some of us like comparing numbers and not having it take an unbounded amount of time.", "id": "danx8gb"}, {"comment": "Not just unbounded, I think any implementation of computable reals will have some reals that you can't compare with zero in finite time. A.k.a. equality of computable reals is undecidable.", "id": "danxliy"}], [{"comment": "> A pet peeve. Spot the difference:\n\tif (looks_like_rain()) {\n\t\t...\n\t}\n\tif (!looks_like_rain()) {\n\t\t...\n\t}\n\nI spot it before reading 'Spot the difference'. ", "id": "danp6kz"}, {"comment": "That's probably because you're already conditioned to look for this exact thing. I know I am, exactly because I've been bitten an embarassing number of times. ", "id": "danz54i"}, {"comment": "I actually kept looking at it because I assumed he meant \"aside from the very obvious difference\" :/", "id": "daott1c"}, {"comment": "Still, one of the few things I like about Ruby.\n\n    unless (looks_like_rain()) { }\n\nand any C style language could easily copy it.", "id": "daoms2f"}, {"comment": "Doesn't solve every problem.\n\n    if (looks_like_rain() && !owns_umbrella) { }", "id": "daowumq"}, {"comment": "Still would be easier to read without parentheses. ", "id": "dao9qp2"}], [{"comment": "wait, so always use whitespace when using substraction? as in, 2-3 is a syntax error? i dont like that at all. also, it might just be not being used to this but this-thing looks really weird. it automatically registers as substraction.", "id": "danjg4q"}, {"comment": "Ooh... so that's why you can't use hyphens in variables, never crossed my mind.", "id": "dankt07"}, {"comment": "Notable counterexample: since Lisp barely has syntax, `*standard-output*` is a perfectly fine variable name, despite having asterisks (earmuffs) and a hyphen.", "id": "danv793"}, {"comment": "More specifically, it's because there are no infix operators in lisps.\n\nSubtraction is:\n\n    (- 7 3)\n\nMultiplication is:\n\n    (* 2 5)\n\nAnd so on. This also means there's no such thing as operator precedence. The following is unambiguous:\n\n    (* 2 (- 7 (* 4 4)))", "id": "daoa5bp"}, {"comment": "It also means such operators are often defined with arbitrary arity:  \n  \n    (+)           ;; 0 (the additive identity)\n    (+ 1)         ;; 1\n    (+ 1 2 3 4 5) ;; 15", "id": "daognut"}, {"comment": "`2-3` just seems lazy to me... and most auto-formatters these days will add the spaces in.", "id": "danmu63"}, {"comment": "It is lazy.  It can also lead to things like `2--3` or `2 -3`, which are syntactically valid and highly confusing.", "id": "danq6zu"}, {"comment": "And then there is the limit operator, \"while x approaches zero\":\n\n    while (x --> 0) {\n        ...\n    }\n\nhttp://stackoverflow.com/questions/1642028/what-is-the-name-of-the-operator-in-c", "id": "dao7jfc"}, {"comment": "Ah yes, the good old \"goes to\" operator.\n\nDoes it work in reverse?  `while (0 <-- x)`  It would be an off by one error if it did.", "id": "dao7l9w"}, {"comment": "I remember \"inventing\" this some time ago. I thought to myself \"Hey, this should work right?\" Stared at it for a few minues. \"Yes hahahah it will.\" I compiled, tested, satisfied my curiosity and promptly rewrote it to a more traditional condition.", "id": "daow5xm"}, {"comment": "`2--3` is a syntax error in C, becuase `--` is the decrement operator.", "id": "danr0rm"}, {"comment": "Hah, it's so confusing, I couldn't even come up with a correct example.  `2 --3`?  No, because `--` is also prefix.  Screw it.", "id": "danrfuc"}, {"comment": "Have you heard of the arrow operator? It decreases towards a number\n\n    while(a --> b) {", "id": "daoauku"}, {"comment": "`2-- 3` and `2 --3` mean the same thing, whitespaces between tokens don't matter* in C. You could write `2- -3`.\n\n* there are exceptions... I think", "id": "dao94hq"}, {"comment": "I've heard of at least one language that forbids whitespace that misrepresents operator precedence.\n\nSo you could type:\n\n     2 - 3*5\n\nBut the compiler would reject it as:\n\n    2-3 * 5", "id": "danucuh"}, {"comment": "Nim has a feature where whitespace determines precidence, so both of those would work, but the first would give -13 and the second -5. Or at least, that's my understanding https://github.com/nim-lang/Nim/wiki/Whitespace-FAQ#strong-spaces", "id": "dao9xeg"}, {"comment": "I thought that when I started using lispy languages, but now for me it feels ugly to use an underscore to separate words, and my pinky finger complains :)", "id": "danl11z"}, {"comment": "Agda has this, and while it takes getting used to, it's actually pretty nice. It also means that you can have variables named e.g. `a\u2264b` (where the value is probably a proof that `a` is less than or equal to `b`)", "id": "dao5xhh"}, {"comment": "Ideally: `2-3` wouldn't be a syntax error, it would refer to a variable named `2-3`.\n\nMaybe it's because I never write arithmetic without spaces around operators, but I think it's a real shame most languages don't allow hyphens in names. It looks nicer than `snake_case`, [while still having readability advantages over `camelCase`](https://whathecode.wordpress.com/2011/02/10/camelcase-vs-underscores-scientific-showdown/). It's easier on the fingers too since you don't have to use the shift key.", "id": "dao6bar"}], [{"comment": "I thought that this was very well written. I agree with a lot of what Eevee wrote, and I appreciate the effort that Eevee made to justify each of the opinions presented, so that even if I don't agree, I at least understand Eevee's cogent reasoning.\n\nOne point in particular that I wholeheartedly agree with is \"Negative modulo\":\n\n> The modulo operator, `%`, finds the remainder after division. Thus you might think that this always holds:\n>\n>     0 <= a % b < abs(b)\n>\n> But no \u2014 if `a` is negative, C will produce a negative value. This is so `a / b * b + a % b` is always equal to `a`. Truncating integer division rounds towards zero, so the sign of `a % b` always needs to be away from zero.\n>\n> I\u2019ve never found this behavior (or the above equivalence) useful.  ...\n\nThis behavior always seemed odd to me. In abstract algebra, we learn about how the integers **Z** is a ring, and the integers modulo n\u2014denoted **Z**/n**Z**\u2014is also a ring. The mathematics is beautiful and seemingly natural. The behavior of many programming languages where `a % b` is negative when `a` is negative thus seems unnatural.\n\nEvery now and then I need to restrict an integer to a particular range, and this presents a dilemma: do I just use `a % max` and ignore the scenario where `a` might be negative? Or, do I write something like `((a % max) + max) % max`? And, if I choose the latter, is this the idiomatic approach?", "id": "danoy68"}, {"comment": "Happens from people calling `%` \"modulo\" when it's really \"remainder\".", "id": "danyond"}, {"comment": "> This behavior always seemed odd to me.\n\nIf you do what the article says C does (which IIRC C does *not* actually guarantee; it's implementation defined), then you can wind up with negative results from modulo, which you and the author don't like.\n\nBut if you flip it around and have `-3 % 2` produce 1, you \"need\" to have `-3 / 2` evaluate to -2 instead of -1. That's kind of OK, except that it means `(-a)/b` is no longer `-(a/b)`, which is another identity you'd expect. (And I think you get it for all *b \u2260 0* with negative-modulo C semantics, though I'm not *100%* positive of that.)\n\nOr you could have `-3 % 2` produce 1 and `-3 / 2` produce -1, but then you lose the identity `a / b * b + a % b`, which you'd also want. (*Edit* fixed dumb error saying `-3 % 2` could produce 2.)\n\nBasically, you're bound to wind up with something surprising no matter what you do.\n\n(My gut reaction is the identity that relates `/` and `%` is very important, and the choice between `(-a)/b == -(a/b)` and `0 <= (a % b) < b` much less so, and either would be pretty defensible.)", "id": "danrau1"}, {"comment": "Depends on what C standard you're using.  Under C89, it is implementation-defined whether division floors or truncates.  Under C99, it is required to truncate toward zero.\n\nRegarding which one they *should* have done, I lean very strongly towards flooring, as the article does.  If I look at a table of what happens when I divide a number, the difference becomes obvious.\n\n    |  x | x/4 (floor) | x/4 (trunc) |\n    |----+-------------+-------------|\n    | -9 | -3 R 3      | -2 R -1     |\n    | -8 | -2 R 0      | -2 R  0     |\n    | -7 | -2 R 1      | -1 R -3     |\n    | -6 | -2 R 2      | -1 R -2     |\n    | -5 | -2 R 3      | -1 R -1     |\n    | -4 | -1 R 0      | -1 R  0     |\n    | -3 | -1 R 1      |  0 R -3     |\n    | -2 | -1 R 2      |  0 R -2     |\n    | -1 | -1 R 3      |  0 R -1     |\n    |  0 |  0 R 0      |  0 R  0     |\n    |  1 |  0 R 1      |  0 R  1     |\n    |  2 |  0 R 2      |  0 R  2     |\n    |  3 |  0 R 3      |  0 R  3     |\n    |  4 |  1 R 0      |  1 R  0     |\n    |  5 |  1 R 1      |  1 R  1     |\n    |  6 |  1 R 2      |  1 R  2     |\n    |  7 |  1 R 3      |  1 R  3     |\n    |  8 |  2 R 0      |  2 R  0     |\n    |  9 |  2 R 1      |  2 R  1     |\n\n* The remainder is always between 0 and N-1.\n* For all y, there are exactly N values of x for which `x/N == y`.\n* For all x, `(x+N)/N == (x/N) + 1`.", "id": "daoglhx"}, {"comment": "A division/remainder pair is defined by having the properties\n\na = a*(a/b) + a%b\n\nabs(a % b) < abs(b)\n\nBut that's not enough to get the sign.  I know of three definitions in use.\n\nOne is yours.  It has a periodic remainder but I know of no easy definition nor properties for the associated division.\n\nThe next one is having sign(a%b) = sign(a).  The associated division is the truncation of the real one, and it keeps the property -a/b = a/-b = -(a/b).  That's the definition used by at least FORTRAN, C, Ada and all the processors I've checked the behavior.\n\nThe last one is having sign(a%b) = sign(b).  The associated division is the floor of the real one and it has a periodic remainder. (Ada has a mod operator which gives the remainder, it does not have a corresponding division operator).\n\nIn my experience, the most useful division, by a large margin, is the truncation one.  For the remainder, about half of the time I like want the association with the truncation division, the other half I want a periodic remainder (in which case I often don't care about the division, I don't remember a case where b could be negative so keeping the remainder positive or giving it the sign of b does not seem to matter).\n\nSo the choice is not that odd:\n\n- it keeps the remainder and division operator coherent\n\n- seems to be by far the most useful one for the division\n\n- it is not vastly inferior for the remainder, adjustment is commonly needed but it would be as common with another choice\n\n- it has the most efficient hardware mapping", "id": "dant4ma"}], [{"comment": "> Single return and out parameters\n\n> Single return: C#...\n\n> Half-assed multiple return: C++11...\n\nShould mention that this were addressed in both C++17 and C# 7.0.\n", "id": "dao1aso"}, {"comment": "/r/programming likes to fault articles for not including things that haven't been finalized yet, especially when the upcoming standard agrees with the theme of the article anyways. At least saying something like JS has `**` now is current (if a little fresh still).", "id": "daonk10"}, {"comment": "> were addressed\n\n*Will be*, neither exists at the point in time when the article was written.\n\nThe essay does mention C++17 at one point (`nulls` \u2014 special mentions) but does not use it for classification", "id": "daov72l"}, {"comment": "C++17 is feature-complete and there is a compiler with a full implementation. You can use it right now. ", "id": "daoyq25"}, {"comment": "What adresses that problem in C++17?", "id": "daou9yt"}, {"comment": "[Structured bindings](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0217r2.html)", "id": "daov884"}], [{"comment": "> It gets a little weirder when you consider that there are type names with spaces in them. And storage classes. And qualifiers. And sometimes part of the type comes after the name.\n\nThe syntax of C declarations can be easily understood by treating them as 2 distinct parts (as per the grammar of the language):\n\n    [specifier-qualifier-list] [declarator]\n\nThe \"specifier-qualifier-list\" can contain storage class specifiers (`static`, `extern`, `auto`, `register`, `typedef`), qualifiers (`const`, `volatile`, `restrict`), type specifiers (`int`, `char`, `double`, `void`, `short`, `long`, `unsigned`, typedef'd names, etc.) and `struct`, `union` or `enum` (with or without a tag). Any of these in *any order*. The compiler checks whether the particular combination means something semantically sensible at a later point.\n\nThe other part is the declarator. You can treat it as an ordinary expression that complies with the precedence and associativity rules of the language. The difference is that the only allowed operators inside it are: the unary `*` (means a pointer instead of dereference), the binary `[]` (means an array instead of subscripting an array), the 1+n-ary `()` (means a function instead of a function call) and the grouping parentheses `()` override the precedence and associativity of the rest. Additionally, you can have `const`, `volatile` and `restrict` sprinkled in between the asterisks, to indicate that they apply only at the particular level of dereferencing the pointer. That's pretty much all of it.\n\nSo, in `extern const volatile _Atomic unsigned long long int *restrict foo[]`, the specifier-qualifier-list is `extern const volatile _Atomic unsigned long long int` and the declarator is `*restrict foo[]`. Because `[]` takes precedence over `*`, that means \"an array (of indefinite size) of pointers to unsigned long long ... whatever... int\". The `restrict` applies to the individual elements of the array (the pointers) and tells the compiler that they cannot possibly alias any other pointers of the same type in the current scope.\n\n> C lets you assign pointers to int variables\n\nOnly if you explicitly turn off `-Wint-conversion` with Clang or GCC, or don't pay any attention to warnings. Any decent compiler will emit a warning by default in such cases.\n\n> I don\u2019t think there are too many compelling reasons to have ++\n\nThe post-increment operator returns the old value with a purpose. Since C is an expression-oriented language, I don't consider this a dirty trick: `stack[size++] = ...`.", "id": "dankcbm"}, {"comment": "Given the length of your post, I am not sure the use of the word \"easily\" is totally appropriate... :)", "id": "dansfu9"}, {"comment": "> C lets you assign pointers to int variables, only if you...\n\nMeaning, **C lets you assign pointers to int variables.** Regardless of it generating warnings or what you do with them, which are more concerns of the compiler than the language.\n\nI'm just going to go un-see the part where it's \"easily understood\" that there's a partial ordering that can be applied to a salad of 18 words and 3 symbols interspersed with _an arbitrary expression_ to... declare one variable.", "id": "danv4m0"}, {"comment": "Well, if you don't set your compiler to treat such things as errors or at least read your compilers warnings, then that is entirely your fault.\n\nWould it probably have been better if the language standard just had forbidden this (except with e.g. an explicit cast)? Sure. Is it a problem in reality, hindering competent programmers? No. Any compiler and any static analysis software will flag this.", "id": "danwj4q"}, {"comment": "> a salad of 18 words and 3 symbols\n\nOf which 3 in the first example are almost mutually exclusive\n\n    const volatile _Atomic\n\nA constant variable, that may change at any time (likely hardware mapped) that is also atomic? I think I sense a trite observation here. What's the other one?\n\n\n    extern const volatile std::unordered_map<unsigned long long int, std::unordered_map<const long double * const, const std::vector<std::basic_string<char>>::const_iterator>> foo\n\nThat is quite a type! Apart from the the fact that it's not useful, again mixing `const` with `volatile` and might not compile as the keys are `const`: it's a map from an integer to maps from constant floats to vectors of iterators to strings. I challenge you to find a type system that even allows you to express that type. It's again a trite example that doesn't make sense from someone who doesn't understand what's going on.\n\nThe preferred example shows just how inane this observation was:\n\n    let x: ... = ...;\n\nLovely how the author doesn't actually put any types in, or any expressions even. C++ is super easy to declare a variable and initialise it as well, you just use\n\n    ... x = ...;\n\nClearly the first thing is a type specifier and the final thing is an initial value.\n", "id": "daoc0r2"}, {"comment": "> C++ is super easy to declare a variable and initialise it as well, you just use\n> ... x = ...;\n> Clearly the first thing is a type specifier and the final thing is an initial value.\n\nWhile I agree the article could have been better-written on that part, you *can't* just say that C++ declarations are `... x = ...`, because they might be `... x ... = ...`, and it's the facts that `x` is neither at the start nor the end and that the type is split between two ellipses that (I agree) is obnoxious.", "id": "daolcbr"}], [{"comment": "I have a better idea: Let's stop writing JavaScript.", "id": "danxbm4"}, {"comment": "Screw that, let's double-down on the JavaScript and run our servers on the stuff, and import libraries to do literally everything for us, up to and including single lines of code, and then we'll run JavaScript to manage dependencies between all the libraries, as well as the libraries which make some libraries compatible with other libraries.  And we'll edit the whole thing in notepad...", "id": "daoqsv6"}, {"comment": "I dislike it too but it's so useful how it's become a standard in all browsers. I don't think we could get everyone together to agree on a new language to be that widely adopted in the browser so I think we are stuck with it.", "id": "dao1fim"}], [{"comment": "I program a lot. How often do I have to calculate powers of numbers in my code? Maybe once a year. I don't think that writing pow(x, y) instead of x ** y is too laborious.  \"**\" does not even resemble the mathematical notation.", "id": "dao65bt"}, {"comment": "As someone who does exponentiation regularly, don't take away my operator! I'm fine with `**`, and considering that most written math uses super scripts instead of an operator I don't think it really needs to match anything.", "id": "daopu3r"}, {"comment": "Also, \\*\\* kinda looks ambiguous in something like C and C++ where pointers use those too. Although the same problem already exists with \\* and &...", "id": "daow45i"}], [{"comment": "> Interestingly enough, C95 specifies `and`, `or`, `not`, and some others as standard alternative spellings, though I\u2019ve never seen them in any C code and I suspect existing projects would prefer I not use them.\n\nI actually used them exclusively in a C++ project I built from scratch at my previous company. I had a few colleagues positively astonished that it compiled, the most savvy ones thinking I had introduced a macro somewhere but unable to find it...\n\nAt first, my colleagues were a bit weird out, but they quickly caught on. The fact that Python uses those too means they were already used to them anyway.\n\nI personally prefer [them](http://en.cppreference.com/w/cpp/language/operator_alternative), because I like having *a modicum of redundancy*; compare:\n\n - The only single character variation of `or` that is a keyword is `xor`.\n - `and` and `not` have no single character variation that is a keyword.\n\nOn the other hand:\n\n - it's pretty easy to accidentally miss `!`, it's easily mistaken for a `(`, `l`, `i` or `j`.\n - it's pretty easy to mistype `&&` as `&` and `|` as `||`, and `|!` is easily mistaken as `||`.\n\nUsing the alternative spelling is like use CRC to get a better guarantee of integrity.", "id": "danw7jw"}], [{"comment": "> Quick test: `1 & 2 == 2` evaluates to 1 with C precedence, false otherwise. Or just look at a precedence table: if equality appears between bitwise ops and other math ops, that\u2019s C style.\nA bit wrong: D, expr, JavaScript, Perl 5, PHP.\n\nIn D, it produces:\n\n    Error: 2 == 2 must be parenthesized when next to operator &\n\nSo this problem does not exist in D.\n\n> And sometimes part of the type comes after the name.\n\nNot in D.\n\n> If 4, you have UTF-8 strings.\n\n4 in D.\n\n> C#, D, expr, Lua, and Standard ML have no octal literals at all.\n\nD at one time did have octal literals, but no more. They have been replaced with a template instantiation:\n\n    import std.conv;\n    int mask = octal!777;", "id": "danzh4s"}], [{"comment": "Re: Assignment as expression\n\n    if (ptr = get_pointer()) \n    {\n        ...\n    }\n\n*versus*\n\n    ptr = get_pointer();\n    if (ptr) \n    {\n        ...\n    }\n\nI prefer the latter, since it's easier to debug.\n\n\n", "id": "danjq0z"}, {"comment": "How?", "id": "dankp3s"}, {"comment": "You can set a single breakpoint at the point after the value has been set but before the condition has been tested.\n\nEDIT - one piece of hard-won advice worth repeating is that you should never do this with `fork`. Always assign as part of the test... you totally don't want to let the `pid=fork()` get separated from the `if(pid==0)`. ", "id": "danktxz"}, {"comment": "Oh yeah that's true.", "id": "dankx2w"}, {"comment": "The common case (maybe not as common in C) is that you're doing equality comparison in conditionals. For many people this falls into pattern matching where you brain sees *an* equal sign and immediately thinks equality comparison is happening.\n\nUnder those conditions, assignment in conditionals can be confusing due to our brains being the ultimate in lazy pattern matching systems and leading our understanding astray.", "id": "danwaq3"}, {"comment": "While the same ease of debugging holds for loops, I prefer\n\n    while (ptr = get_pointer()) \n    {\n         ...\n    }\n\nto\n\n    while(1)\n    {\n        ptr = get_pointer();\n        if(!ptr)\n        {\n            break;\n        }\n        ...\n    };\n\njust  because of aesthetics.", "id": "dankswk"}, {"comment": "The whole point of while structures is that you can see at a glance from the condition what the loop will do... Breaks and continues are very confusing this way and can almost always be translated into a more appropriate construct.", "id": "danm5zt"}, {"comment": "    for (ptr = get_pointer(); ptr; ptr = get_pointer()) {\n        ....\n    }\n\nBetter yet, use tail recursion.\n\n(What do you mean, the language you're using doesn't support tail call elimination? What kind of *savage* are you?)", "id": "danllyi"}, {"comment": "When avoiding assignment as expression, I typically see this as\n\n    ptr = get_pointer();\n    while (ptr) {\n        ...\n        ptr = get_pointer();\n    }\n\nor \n\n    do {\n        ptr = get_pointer();\n        if (ptr) {\n            ...\n        }\n    }\n\nUsing a `for` loop, as /u/PM_ME_UR_OBSIDIAN points out, is not uncommon, but that still makes setting a breakpoint awkward. ", "id": "dannw6i"}], [{"comment": "As a hardcore C fanboy I feel split about this article. Some very valid points are raised (single var returns, error handling, #include) but I think some of the qualms the author has with C come down to coding conventions.\n\n* C has a pow() function included in the standard library, and a ** operator wouldn't work since you can have indirect pointers.\n\n* I don't see any issue with for loops. The syntax is great when you want to iterate in weird ways. \n\n* Your issues with typing are with bad coding style. I rarely use typedefs, and when I do, you always add \"_t\" to the name. I'd say the issues raised with braces is also dependent on coding style. \n\nIn my not-a-professional-programmer opinion, I think it comes down to the fact that C is very flexible but has specific use cases - low level, high performance, etc. I have written a hobby operating system, assembler, and Scheme interpreter in C. For projects that involve lots of string manipulation, internet connectivity, first class functions etc I turn to a higher level language. ", "id": "danph3n"}, {"comment": ">  I rarely use typedefs, and when I do, you always add \"_t\" to the name.\n\nAren't all types ending with \"_t\" reserved for future use (either by POSIX or the standard, I can't recall)?", "id": "danrllt"}, {"comment": "> (either by POSIX or the standard, I can't recall)?\n\n[By POSIX](http://stackoverflow.com/a/3225396/362981).", "id": "danski8"}, {"comment": "You're correct, it's POSIX. However it hasn't stopped people from using it (back to bad coding conventions :p )", "id": "danwgah"}, {"comment": "> The syntax is great when you want to iterate in weird ways\n\nBut... what if you want to iterate in normal ways?", "id": "dao1xpy"}, {"comment": "Then it's still just as easy to use?", "id": "dao56d1"}, {"comment": "Having C-style for loops does not prevent a language from also having less flexible (and harder to get wrong) alternatives. Just as C++11 added ranged-based for without losing the older style.", "id": "daoq0v7"}], [{"comment": "The author had me until they suggested to get rid of braces and use python-style indentation. _Shudders_.", "id": "dao86cc"}, {"comment": "Yeah, I was pretty disgusted by that too.", "id": "daowa7j"}], [{"comment": "The exponentiation operator was added to JavaScript in ECMAScript 2016, and it uses \\*\\*.", "id": "dankrju"}], [{"comment": "\"The great thing about static typing is that I know the types of all the variables, but that advantage is somewhat lessened if I can\u2019t tell what the variables are.\"\n\nHa! Just finished a small C++ project and this is true. The auto type inference is a bad trade off: it saves typing when writing the code, but the error messages produced get more and more surreal as the code grows.", "id": "danug5s"}, {"comment": "That doesn't make much sense. Why would the error message be different with or without auto?", "id": "daot6rx"}, {"comment": "gcc or clang? I've heard the latter has much better error messages.", "id": "danzk6z"}, {"comment": "I was switching between both, both have improved error messages relative to a couple years ago, but I don't think one is uniformly better.", "id": "danzqzt"}], [{"comment": " He makes some good points, but many of his suggestions come at a cost to performance.\n> If you\u2019re willing to ditch the bitwise operators (or lessen their importance a bit), you can even use ^, as most people would write in regular ASCII text.    \n\nWhy would you want to get rid of bitwise operators?  They're ***so*** much faster in some situations.", "id": "dao7vl4"}, {"comment": "They also let you pack information when memory is at premium. A language without unsigned integer types and bitwise operators is just useless for many applications out there.", "id": "daob2fe"}, {"comment": "The author isn\u2019t saying that bitwise *operations* should be removed, just that different *notations* for them should be considered. `|`, `&`, and `^` are valuable ASCII operator real-estate, and in the context of a new language, bitwise operations may not be the best meanings to assign to them.", "id": "daoq3ss"}, {"comment": "Provide them as built-in functions, then. C compilers offer intrinsic SIMD functions for similar purposes. Also, I'd love to see built-in \"rotate\" functions. They're notably absent from C, but hardware usually supports bitwise rotation.", "id": "daon9ri"}], [{"comment": "> Half-assed multiple return: ECMAScript 6\n\nES6's MRV semantics are identical to Ruby's and very close to Python's (with the difference that the RHS in Python can be an arbitary iterable), it should be in the section below. It is a bit noisier due to explicit variable declaration, but then e.g. Rust would be disqualified as well.\n\n> Half-assed multiple return:  Erlang\n\nErlang literally just uses tuples for MRV, they have an unusual syntax (braces) but they're still tuple. Erlang's MRV is also used for a pseudo-monadic error system.\n\nWhich incidentally means Erlang's classification in the next section is also incorrect, does have exceptions but they're usually used in the same way they are in Rust (as terminal faults, though that), rarely used for error signalling (except across processes through supervision links).\n\n> Half-assed multiple return: PHP\n\nWhile true, the `list()` special form really doesn't belong with C++ and D, PHP can at least unpack MRVs at the binding site.\n\n> Multiple return via tuples: Go\n\nGo doesn't have tuple, MRV is a special case of the language (and some builtins even have variable-arity return). In fact the lack of tuples is the first \"type system\" item in /u/munificent's \"The Language I Wish Go Was\" essay from way back in 2010.\n\n> C++17 doesn\u2019t quite have the same problem with std::optional<T>, since non-reference values can\u2019t be null.\n\nAFAIK it's non *pointer* values which can't be null, C++ references can't legally be null (just getting a null reference is an UB, let alone using it).\n\n> Everything\u2019s an expression: Rust.\n\nAssignment is an exception to that rule, it's a statement. `if a = b` is not legal in Rust. Some pattern matches (`if let`) look similar but are subtly different. Also\n\n> Rust has a special if let block that explicitly combines assignment with pattern matching, which is way nicer than the C approach.\n\nTechnically `let a = b` is already a pattern match, but it only allows *irrefutable* matches. `if let` (and the full `match`) allow *refutable* matches as well. Though many FP languages allow refutable matches in \"assignments\".\n\n> Bracing myself: C#, D, Erlang, Java, Perl, Rust.\n\nErlang's semi-colons are *separators* between match clauses, and commas are *separators* between statements. This means the last match doesn't get a semicolon (it gets a period) and the last statement of a block doesn't get a comma.\n\nRust is also a bit of a weirdo, semicolon semantics are a bit different than they are in C, IIRC.", "id": "dansplc"}, {"comment": "> Assignment is an exception to that rule, it's a statement\n\nTo be 100% correct, declarations (`let a ...`, `fn foo ...`) are the exception, a (mutating) assignment itself is an expression that has value `()`.", "id": "danzvgf"}], [{"comment": "How about people that have never programmed in C, stop complaining about C.", "id": "daouegf"}], [{"comment": "Maybe I'm just old fashioned but I've never understood why people hate \"type first\". You can always just use a dynamically typed language or one that supports inference but in a statically typed language, I  don't see how its an issue at all.", "id": "dant9g7"}, {"comment": "The problem is that it's not type first in C. It's \"type around the identifier\" which you have to parse from the inside to the outside. This gets super hard to read once you deal with a combination of function pointers and arrays.\n\nLet's say we want an array of 3 function pointers that return an array of 4 chars, called x.\n\nRust:\n\n    let x: [fn() -> [char; 4]; 3];\n\nC:\n\n    char (*(*(x)[3])(void))[4];\n\nI'm not even sure which parentheses are necessary in the C case. Also, note how the inner most types appear outside, which is just super weird in every regard. It's like when you are writing a XML document, but you put the inner most tags on the outside and the `<?xml version=\"1.0\" ?>` tag on the inside.", "id": "danu00e"}, {"comment": "> we want an array of 3 function pointers that return an array of 4 chars, called x\n\nTranslated to C thinking:\n\n> We have a variable called `x`; it can be subscripted with an index less than 3; the result of that can be called with no arguments; the result of that can be subscripted with an index less than 4; the result of that is `char`.\n\nTranslated to C code:\n\n           x\n           x[3]\n         (*x[3])(void)\n         (*x[3])(void)[4]\n    char (*x[3])(void)[4];\n\nBut of course returning arrays from functions is illegal anyway. :)\n", "id": "daorclp"}, {"comment": "The problem is described in the article. The compiler can\u2019t determine whether it\u2019s parsing a declaration or an expression without a symbol table that indicates whether an identifier refers to a type. That makes source-processing tools needlessly difficult to implement.\n\nFurthermore, in C++, making that determination may require running Turing-complete template code, and therefore it\u2019s provably impossible to parse arbitrary C++. But of course, real humans tend to write very non-arbitrary code, so in practice we get by well enough.", "id": "daoqyhx"}], [{"comment": "It all depends on what the outcome/goal is. For C some of its design decisions do make sense given the context, as they cannot assume too much about the underlying hardware, are just trying to expose that hardware in a more convenient and portable way than writing in assembly, but are not trying to take on the responsibility of guiding or forcing the programmer into architecting good solutions (this can easily be seen in contrast to C++ which definitely is trying to get the programmer to architect better solutions, or at least what they consider to be better architectural design decisions). \n\nAs there's pros and cons to either languages that tell you how you should write your programs and those that do not (like C). I don't think there's any one clear choice, rather it depends on what the language is trying to achieve. Although the higher level the language is, the more I'd expect it to tell you how you should be writing programs in it. \n\nA number of languages that copy C, are just copying C syntactically (which the article does address some of C's syntactical issues). This is probably more so just as a result of trying to make their language feel familiar to those who do not know the language itself (compared to if they made a completely new syntax which would make it feel very foreign). I don't think there's any one answer here, as at the end of the day we all have our own preferences. \n\nI disagree with the articles criticism of for loops in C. For one they're needed, C's types lack the information to know how many elements should be iterated. The type that could potentially offer it would be arrays (where you can guarantee `sizeof(array) / sizeof(typeof(*array))` would equal the number of elements in the array), but there's a number of fundamental floors with offering a foreach with that behaviour. The first is, just because the array is declared to hold a certain amount of elements, doesn't mean those are the actual \"elements\" you want to iterate (an array like this is not the same as a container). The second is problems arise with how passing references of arrays work, as you'll only get a pointer reference to the array rather than a copy of the array itself, this means that the information required for the above is now lost, the biggest implication of this would be in confusing programmers that aren't being careful (since C's type system wouldn't be able to protect them from this). The third is how should element references work? Should your iterations get a pointer to the element or should you get a copy of the element. The fourth as alluded to earlier, C has no containers, if you want an iterate-able list/collection of values in C you have to build that up from the underlying fundamentals (which given its relaxed nature, you can do in a variety of ways), so simply because of this I'd argue it would be incorrect to introduce any kind of notion of foreach into the C standard. If you want these constructs (such as foreach) you have to build them (which you certainly can), which I think is fine given what C is.\n\nAnother complaint I had (much in the same vain as the for loops) was regarding strings. This is another example of where you should really be building the string type you want, rather than using what is provided for you (unless it works for your given situation). \n\n> Most runtime errors in C are indicated by one of two mechanisms: returning an error code, or segfaulting.\n\nThat's only if you're lucky enough to have your uncaught runtime error produce a bus error or segfault. You can easily have runtime errors that will happily go by unbeknownst to you. Or it might only blow up on very specific conditions. ", "id": "daokjta"}], [{"comment": "In the type first topic, I want to say that C++'s auto may be used for type inference, so you don't need to put the type before variable's name. Also, classes now have type inference, meaning that we don't need to complete their template parameters when instantiating them, nor use functions like `make_*` anymore (except for `make_shared`, which allocates one block of memory for both value and the reference counter).\n\n    auto foo = std::tuple{42, \"call me maybe\"s, 3.14f};\n\nThough you may say that classes like `std::unique_ptr` still need its template parameter to be given (and it remains true even for the `make_unique` function). That's true, but C++17 brought something to help us out in this case. There's a way to help the type inference on guessing a class's template parameters called [deduction guide](http://en.cppreference.com/w/cpp/language/class_template_deduction). Basically, this allows for writing guides to the type deduction system, like so:\n\n    template <typename T>\n    explicit unique_ptr(T*) -> unique_ptr<T>;\n\nWhenever we pass a pointer to a type `T` to `unique_ptr`, this guide will tell the type deduction that now we want `unique_ptr` to be guessed to `unique_ptr<T>`, thus allowing us to do so:\n\n    auto foo = std::unique_ptr{new int{42}};\n\nWe could also do something like that for vectors:\n\n    template <typename T, typename... Ts>\n    requires (std::is_same<T, Ts>{} && ...)\n    vector(T, Ts...) -> vector<T>;\n\nNow we can write:\n\n    auto vec = std::vector{1, 2, 3, 4};\n\nThough I hope the standard brings these specific guides in future std libraries (I haven't seen a word on it).", "id": "danmnhg"}], [{"comment": "It annoys me, around the integer, that he previously says weakly typed implicit conversions are painful (which I agree with, I always explicitly cast), but then goes on to say 7/2 = 3.5. No, 7/2 should equal compile-time exception: cannot divide integers. (double (7/2)) should equal 3.5. ", "id": "daoh5eq"}], [{"comment": "I feel dirty saying this, but my favorite language for optional/mandatory block delimiters is Microsoft Basic (QuickBASIC, QBASIC, classic VB, VB.Net -- anything newer than BASICA/GWBASIC).\n\nYou can say \"If condition then DoStuff\" with no End If, but only if it's all on the same line.  It avoids cluttering the code with really simple checks, but otherwise you get the delimiters with no question of where an open brace should go.", "id": "dano6oz"}, {"comment": "This is my personal rule for using if with no brackets in C-likes:\n\n    if (foo) bar(); // fine\n    \n    if (foo)   // not fine\n       bar();\n\n    if (reallyLongPredicateThatDoesntFitOnOneLine) // fine\n    {\n       someEquallyLongFunctionCallThatWillAlsoNotFitOnOneLine();\n    }", "id": "dansoen"}], [{"comment": "kudos for the share. Although the author seems to have good intentions I question the value of such bitching about what works and has worked for several decades. If you have a new hotness, blog about why it's great, not why everything else sucks...", "id": "daohn34"}], [{"comment": "> To be fair, C is pretty consistent about making math operations always produce a value whose type matches one of the arguments. \n\nActually... `char * char` gives an `int`. C++ pilfered the rule, so we can use it to inspect the resulting type:\n\n    #include <iostream>\n     \n    #define PRINTER(Type_) void print_type(Type_) { std::cout << #Type_ \"\\n\"; }\n     \n    PRINTER(char)\n    PRINTER(unsigned char)\n    PRINTER(short)\n    PRINTER(unsigned short)\n    PRINTER(int)\n    PRINTER(unsigned int)\n     \n    int main() {\n    \tprint_type('a' * 'b');\n    \treturn 0;\n    }\n\n(see [ideone](http://ideone.com/O18XLE)).\n\nIn C and C++, any integer type smaller than `int` is first widened to `int` before an arithmetic operation is applied to it.", "id": "danvne9"}, {"comment": "Remember that in C the type of `'a'` is `int`, so `'a' * 'b'` giving an `int` is surprising for a different reason.\n\nOf course you're still right that `char * char` gives an `int`, and your sample program is also correct since in C++ the type of `'a'` is `char`, but for C I'd suggest a program like [this ideone](http://ideone.com/xgx0BL).\n\n_edit: typo_", "id": "dao5ss8"}], [{"comment": "[Try this to feel better fellow C and C alike developer](http://h2co3.org/blog/index.php/2016/12/01/lets-stop-bashing-c/)", "id": "daot33x"}], [{"comment": "Some comments are ok but some are WTFs or show that he does not know all the languages by heart.\n\nFor instance, no mention of ruby's \"unless\" rather than \"if !\".\nNo matter if you use it or not, it should be mentioned.\n\nOther parts are weird:\n\nNo hyphens in identifiers\n\n\"snake_case requires dancing on the shift key (unless you rearrange your keyboard, which is perfectly reasonable). It slows you down slightly and leads to occasional mistakes like snake-Case.\"\n\nWTF? Slows you down? Compared to what? SnakeCase? I have to hit a second key for the upcased 'c' too, so I don't get that statement... how is that different from an underscore???\n\nI think that the main difference is cultural mostly. Some communities love snAkInG around, others don't. I am looking at you python which I speak natively for all my scaly friends - ssszZSzzSszsss.", "id": "daou01n"}]]], "5fmdtd": ["Arduboy, the game system the size of a credit card. Create your own games, learn to program or download from a library of open source games for free!", "2016-11-30 03:23:25", 460, "https://www.arduboy.com/", [[38, "Hmmm, this seems like a really cool concept. I like the idea of of programming with memory size in mind, it's amazing the tricks developers did on old consoles to save memory. But, it doesn't seem to have an emulator, I'm not prepared to spend $50 just to try it."], [28, "I have one of these, and also a [Gamebuino](http://gamebuino.com). The latter is better: it's an open design (you can easily build your own), the processor is slightly more powerful, it has I2C headers for multiplayer gaming or adding your own hardware, you can programmatically control the display backlight, it has a brightness sensor, and - this being the killer feature - loads games from a micro-SD card, meaning you can switch between games on the fly without having to hook the device up to a PC. It's also about a third cheaper..."], [21, "#$49"], [21, "Was looking around for screen resolution specs and found 128x64. Is that correct? So tiny!"], [20, "Physically too small, and not enough memory (less than a gameboy)\n\nEDIT:  And worse, you can't swap out games with SIM cards or anything.  If you want to change games you have to hook the device up to a computer and use the dev tools to compile/upload the other game onto the device.  \n\n\n"], [12, "* Buck per bang feels abysmal.\n\n* What's the point of using Harvard-based microcontroller in this case? You need a PC to upload new game to it. \n\nIf I'm taking a train ride, I'd want to have several games, not one. If I have laptop to upload games, I might as well use it for gaming.\n"], [9, "> Arduboy is a game system the size of your imagination!\n\nSo... my imagination is the size of a credit card? :("], [6, "I feel a bit mixed about this. On one hand it's cool to see people making and selling projects, and giving people the opportunity to make and do something cool is fantastic.\n\nBut, on the other hand, it feels a little lame to just throw a screen and some microswitches on a commodity processor and call it a \"game system\". Yeah it's got enough raw horsepower that you can make something that looks and plays alright, but it seems a bit weak compared to even something like an original game boy with actual hardware designed for games (like sound chips and so on).\n\nstill, it looks pretty slick, so it's not all bad, but it just doesn't sit right for me I suppose. "], [5, "I like the concept, but come on, for $49 I'd like to atleast have the specs of a Gameboy, not less."], [3, "My girlfriend bought 2 for $20/per when they were on Kickstarter. We got 4 because of shipping errors. \n\nThey're pretty neat to tinker with, especially when you realize they're just Arduino Leonardo boards. They can accept and send USB commands, so they can be used as HID devices. I'm working on trying to make a Linux-based system monitor on one for funsies.\n\nThey're neat, but not $50 neat. I look at mine as a novel intro to Arduino programming, albeit sans all the pin headers that make Arduino boards *really* interesting. "], [2, "I've seen this before.  Seems sort of fun to play with, but kind of silly price for such weak capabilities (exactly 2 buttons other than the D-pad, no start or select, 1-bit pixels, so no greyscale at all without manual dithering, only 1 game loaded onto it at the time, pitiful memory), making it pretty much useless if you plan on using it to really play games, and even if you want to make games past any sub-gameboy toy level.\n\nAt that rate if you want to get started with some tiny embedded programming, it's not too expensive to track down a used GameBoy Advance, a flash cart, and fire up [DevKit Advance](http://devkitadv.sourceforge.net/) to start programming your own GameBoy, GameBoy Color, or GameBoy Advance games and getting involved in that community."], [2, "$50 is to much, raspberry pi is cheaper. Would rather buy that"], [1, "The game \"the battle for zuthrah\" is addicting af..."], [0, "It's sweet!"], [0, "Hugged?"], [0, "So you like [small](http://blog.thisisnotrocketscience.nl/projects/microgameboy/) reddit?"], [-1, "I'd hold out until someone manages to mass-produce [Sprite_TM's ESP32 Gameboy](https://hackaday.com/2016/11/07/tiny-game-boy-that-plays-witcher-3-and-other-things-that-blew-my-mind/)\n\nedit: Apparently this rustled some jimmies. Anyone want to tell me why?"]], [[{"comment": "Hmmm, this seems like a really cool concept. I like the idea of of programming with memory size in mind, it's amazing the tricks developers did on old consoles to save memory. But, it doesn't seem to have an emulator, I'm not prepared to spend $50 just to try it.", "id": "dalox01"}, {"comment": "You could also try the [pico 8](http://www.lexaloffle.com/pico-8.php), it's very much in the spirit of programming games in a limited environment and can actually a creativity boost.", "id": "dalsrz7"}, {"comment": "I like pico 8 somewhat, but it is no fun writing lua with such few characters per line. I know you can just code in a separate editor but it breaks the \"immersion\" a bit.", "id": "dam2e4f"}, {"comment": "There's a similar Lua-based project that's OSS which gives you 50% more horizontal pixels: https://github.com/RamiLego4Game/LIKO-12", "id": "damcuie"}, {"comment": "I wish there was something like this that had an assembly language as well. Not sure why, just sounds fun. ", "id": "dam1jlj"}, {"comment": "How about [Octo](http://johnearnest.github.io/Octo/)?", "id": "dam2lzd"}, {"comment": "There's also [Pocketchip](https://getchip.com/pages/pocketchip), which is designed for PICO8 programming, though the keyboard looks a bit fiddly", "id": "damofuj"}, {"comment": "The original GameBoy had 16 times the memory and 30 times the storage of this device. Old console tricks won't even cut it, you're going to need to come up with new ideas.", "id": "dalx247"}, {"comment": "And more screen space...", "id": "dalyhpb"}, {"comment": "I'm surprised how low spec it actually is. You can probably get a Gameboy Color for well under $50 nowadays with higher specs. Of course it's probably not as easy to program for Gameboy and you'd have to get a cartridge maker, but I feel like the specs should be a bit higher. I guess these types of parts aren't cheap to get though.", "id": "damjtun"}, {"comment": "Not sure about the difficulty, actually, there's enough emulators around you can try yourself on.", "id": "damm8a5"}, {"comment": "The Gameboy Color programming manuals is available as a leaked PDF.", "id": "damvw8m"}, {"comment": "It's probably because there isn't enough demand for this to buy the pieces in bulk.", "id": "dap2w0m"}, {"comment": "You should check out one of the [Uzebox](http://belogic.com/uzebox/index.asp) implementations then. ATMega-based, and with an emulator.\n\nA friend of mine just made one that [fits inside a SNES controller](https://www.kickstarter.com/projects/simmonespring/uzebox-dtv-retro-gaming-goodness-in-the-palm-of-yo).", "id": "dalprb5"}, {"comment": "I'll check it out, thanks!", "id": "dalq9f4"}, {"comment": "Maybe I can introduce my own diy small gaming console,a bit  like the uzebox but with an arm cortex m micro vga and usb gamepads. Bitboxconsole.blogspot.com there is also a micro version...", "id": "damk1ky"}, {"comment": "I made an OLED low level memory emulator so you can write fast algorithms for it!\n\nhttp://codepen.io/SarahC/pen/wWjjEL\n\n", "id": "dandwu2"}, {"comment": "There is some beta emulator projects available on community.arduboy.com and we are working on building an HTML5 one so stay tuned if you're still interested!", "id": "dalw1ja"}, {"comment": "There's a color arduino-based project with a slighly bigger screen (2.2\") that has been featured in [hackaday](https://hackaday.com/2015/05/27/mimimalist-arduino-gaming-platform/) that you can build for less than half the price of an Arduboy.\n\nIt was designed to be as inexpensive as possible with readily available parts from ebay, aliexpress, banggood, etc. and easy enough to be built by inexpensive hobbyists. At the time all parts costed < 20 USD so likely it can be built for less now as components get cheaper as time goes by.\n\n\nThe motivation for it was that I was a bit disappointed that all the existing freely available projects were expensive and none offered a color screen.\n\n\nTetris gameplay demo\n\n\nhttps://www.youtube.com/watch?v=ycriUQhm9pg\n\nBreakout gameplay demo\n\nhttps://www.youtube.com/watch?v=RhVOQ9A0XP8\n\n\nBuilding instructions\n\nhttp://vilaca.eu/handheld-arduino-color-console/\n\n\nGame source code repository\n\nhttps://github.com/vilaca/Handheld-Color-Console\n\n\nAs everything is open-source some people have cloned it and made derivative projects and that's great :)\n\n\nI do not make any money from it but still have fun playing it from time to time. I've a 3d printer on its way and hope to make a case for it when I learn enough about 3d printing.\n\n\nEDIT:\n\nHere's a project based on it that looks much better than my original attempt\n\nhttp://www.instructables.com/id/Arduino-MINTIA-Game-Console-in-a-Candy-Box/", "id": "damggws"}, {"comment": "There's no emulator but it's not that big of a problem in practice for most apps. For my (as of yet unfinished) project, I created a simulator instead: I just recompile the C++ code targeting Linux, and link with SDL-based implementations of the screen and the button input. \n\nIt works nicely in practice because there's enough flash space (32K) and CPU speed (16 MHz) that C++ is viable for \"normal\" (i.e. not demo-quality, boundary-pushing) games.", "id": "dalxnp7"}, {"comment": "I made an OLED low level memory emulator so you can write fast algorithms for it!\n\nhttp://codepen.io/SarahC/pen/wWjjEL\n\n", "id": "dandwp2"}], [{"comment": "I have one of these, and also a [Gamebuino](http://gamebuino.com). The latter is better: it's an open design (you can easily build your own), the processor is slightly more powerful, it has I2C headers for multiplayer gaming or adding your own hardware, you can programmatically control the display backlight, it has a brightness sensor, and - this being the killer feature - loads games from a micro-SD card, meaning you can switch between games on the fly without having to hook the device up to a PC. It's also about a third cheaper...", "id": "dalrtn7"}, {"comment": "The gamebuino screen resolution is smaller and prone to ghosting. I do love the SD card and the ability to plug into it other components.\n\nOur device is much smaller, and is intended that you can keep it in your pocket or wallet all the time. Gamebuino isn't going to survive that.\n\nWe're looking at adding SD card support in our next version.\n\nAnd if you'd like to save money, we have a guide on our community.arduboy.com that shows you how to build a clone for $12 using ebay parts.", "id": "dalw3si"}, {"comment": "The Gamebuino screen is lower resolution, but actually physically slightly larger - and the addressable backlight can be incorporated into gameplay, as in Crabator where it dims and flickers as your health decreases. It can ghost with rapid movement, that's true - though if you make sure the contacts on the back are clean it's a very minimal issue - but the Arduboy screen suffers from bad banding which is just as, if not more, distracting.\n\nYou're right that the Arduboy is a lot smaller - though as others have pointed out, you then need a laptop with you to change games. It also has a dramatic effect on battery life: the Arduboy gets eight hours per charge, the Gamebuino 24 hours plus.\n\nSD card support would be fantastic: if you can get that in the same form factor and address the problems the display has with banding, the Arduboy would be much closer to beating the Gamebuino.", "id": "dalzi4s"}], [{"comment": "#$49", "id": "dals8h2"}, {"comment": "Yesterday my Raspberry Pi arrived at home. Yeah, I'm also finding the price a bit steep for such limited device.", "id": "daly6wv"}, {"comment": "To be fair, display assemblies for the RasPi are like $35+.\n\nAnd then you still don't have I/O or battery or case.", "id": "dalz65t"}, {"comment": "Yeah, but you got a much more powerful and versatile device you can connect to an actual monitor.\n\nDon't get me wrong, the device seems to be super cool, but the hardware you get for that price is as best lacking. Is like those emulators/clones of old hardware. You are asking 50$ for something that is either emulating a NES or cloning 30-year old hardware, jsut with a cool case.", "id": "dam03c7"}, {"comment": "To be fair you can get an ATmega324u/battery/screen/+ wifi for like $20 if you're willing to CHINA", "id": "dam899f"}, {"comment": "The effect of Moore's Law is that the ancillary stuff--buttons, PCB, display, etc.--adds to the cost more than the processor itself. Put an STM32 and a small S-RAM chip on board, and you'll barely add to the cost while having something more powerful than the Game Boy Advance.\n\nBut then you're creeping out of \"small retro programming\" territory. What are you gonna do? *shrug*", "id": "dalz0x3"}, {"comment": "Well remove the sram and screen add vga and you got a bitbox console. 16bit memories... ", "id": "damk80j"}, {"comment": "Over 100 games available for it so that's less than 49 cents a game, plus the ability to make your own. If you're not into making and sharing games, it's probably a bit expensive if you're used to gaming on the Playstation 4.", "id": "dalw2ha"}, {"comment": "Gameboy on ebay: under $20\n\nAmount of games available: 1049\n\nNo need to insult critics as console peasants when your product is worse than actual consoles.", "id": "dalx43x"}, {"comment": "Those Gameboy games aren't free though...\n\n(That said I think I agree)", "id": "dam3313"}], [{"comment": "Was looking around for screen resolution specs and found 128x64. Is that correct? So tiny!", "id": "dalit7b"}, {"comment": "It's super tiny.... \n\nToo tiny to be played enjoyably for long time..... \n\nbut nice cool conversation starter in when you pull it out. ", "id": "dalppms"}, {"comment": "That's what she said.", "id": "dalu1zm"}, {"comment": "I'd say it depends on the game.  I could see myself playing a puzzle game (like 2048) for quite a while on this.", "id": "daltc9e"}, {"comment": "The Gameboy had 160x144, which was enough to waste years on it.", "id": "dalx2qu"}, {"comment": "Which is like ~65% more pixels + it had grayscale opposed to b/w, in '89\n\nI understand wanting to keep base arduino compability but this is way below even original gameboy in every way\n\n\n", "id": "dalyoqm"}, {"comment": "re: grayscale, my understanding is that was just simulated by PWM.  Is the clock / refresh rate on the Arduboy not fast enough for that?", "id": "dam5hdv"}, {"comment": "Don't think so, STN displays like used in the GameBoy had far too slow reaction times (100ms IIRC) for anything like that.", "id": "dam8l7z"}, {"comment": "Slow display reaction times would make PWM *better* (no flicker).", "id": "damcu5t"}, {"comment": "I dont know how it implimented it, but it only had to manage \"Light Gray\" and \"Dark Gray\". It wasnt 256 shades. ", "id": "dam95ii"}, {"comment": "It used a 2-bit (4 shades) palette.", "id": "damhisy"}, {"comment": "Is that including black and white?", "id": "damtous"}, {"comment": "There are only those 4 shades of green.", "id": "dangoux"}, {"comment": "> I understand wanting to keep base arduino compability but this is way below even original gameboy in every way\n\nThe arduboy is not in anyway compatible with the gameboy.", "id": "damoa2a"}, {"comment": "Nobody said it was.", "id": "damyhl7"}, {"comment": "> (I understand wanting to keep base arduino compability) but (this is way below even original gameboy in every way)\n\n?\n", "id": "dap2rf9"}, {"comment": "I misread the comment I was replying to or maybe I was simply making a statement and adding to the discussion.", "id": "dap4dox"}, {"comment": "Probably.  I have some experience with an SSD1306 OLED that is 128x64 and looks pretty much like the OLED they are using.", "id": "daln0k5"}, {"comment": "It's not so bad actually, the pixels are nice and big. It's the highest resolution screen we could find that would still fit within the credit card size dimensions.", "id": "dalw20h"}], [{"comment": "Physically too small, and not enough memory (less than a gameboy)\n\nEDIT:  And worse, you can't swap out games with SIM cards or anything.  If you want to change games you have to hook the device up to a computer and use the dev tools to compile/upload the other game onto the device.  \n\n\n", "id": "daliqi9"}, {"comment": "The size might be a problem.  But the memory, or rather, the overall constraints make it very appealing to me.  It's not about competing with a PS Vita, it's about the whole experience of making games, playing and sharing them.", "id": "daltdk3"}, {"comment": "> it's about the whole experience of making games, playing and sharing them\n\nStill, you're getting a less capable platform than a 27 year old handheld. For a higher price. The Gameboy could even do multiplayer! I'd say the GameBoy gives a better experience in all three fields.", "id": "dalx0jr"}, {"comment": "Still, it's not about power.  It's about constraints, and it's the constraints that make it appealing.\n\n\nNow, the price, I can't justify.  It's just stupid.  It should have been $4.99 plus shipping and handling.", "id": "dam8o7m"}, {"comment": "I wasn't comparing it to a Vita.  I was comparing it to the original gameboy, which was historically the least capable handheld to provide a compelling gaming experience.", "id": "daly80i"}, {"comment": "that's a pretty strong opinion against it, i didn't think it was that bad but oh well", "id": "damn1hj"}, {"comment": "My point still stands.  The gameboy is targeted exclusively to people who just want to play decent games.\n\n\nThe arduboy is targeted to gamers, tinkerers and gamers _and_ tinkerers.", "id": "dam8rt3"}, {"comment": "Less memory (2.5K vs. 40K), less ROM, but much faster CPU. Might lend itself to procedural generation / aggressive compression?", "id": "dalwz0s"}, {"comment": "It's not meant to be a gameboy, it's it's own thing! And you'd be surprised, we designed it for big fingers so it's rather pleasant to use.", "id": "dalw491"}, {"comment": "I think the size issue is about the display.", "id": "dalyjdo"}, {"comment": "People seemed pretty keen on keeping it credit card sized. This is actually all the result of a prototype that I made for myself, I never intended it to be a product. But I got thousands of emails of people wanting to buy one so I made some improvements and put it on kickstarter. I'm just riding out the interest from a viral video this isn't meant to change the world or disrupt gaming. It's just a fun project and a fun community.", "id": "dalzc7y"}], [{"comment": "* Buck per bang feels abysmal.\n\n* What's the point of using Harvard-based microcontroller in this case? You need a PC to upload new game to it. \n\nIf I'm taking a train ride, I'd want to have several games, not one. If I have laptop to upload games, I might as well use it for gaming.\n", "id": "dalpzx3"}, {"comment": "I just replied elsethread pointing to the [Gamebuino](http://gamebuino.com), which fixes both your complaints: it's cheaper and it loads games from a micro-SD, meaning you can swap between games on the go.", "id": "dalruyh"}, {"comment": "It's actually the same price (39 GBP = ~49 USD). Loading is MUCH better, though it still reflashes the chip instead of executing the code from memory (as in GameBoy), though it's unlikely that reflash limit will be reached.\n\nI2C headers look really nice.", "id": "daltths"}, {"comment": "You've forgotten to take VAT into account. The Gamebuino is \u00a339 inclusive of VAT, whereas the Arduboy is $49 exclusive of VAT, which is \u00a346.80 plus an \u00a38-10 Customs clearance charge bringing the total closer to \u00a350-55. [Pimoroni](https://shop.pimoroni.com/products/arduboy) is the only authorised UK reseller of the Arduboy, and charges \u00a348 including VAT (with, obviously, no Customs charge 'cos it comes from within the UK.)", "id": "dalu8he"}, {"comment": "I could almost see doing an architecture where a microcontroller sits on the cartridge, and the connector just gives you access to the display controller, buttons, WiFi, etc.", "id": "dam1hzm"}, {"comment": "The point is to develop games yourself, not replace your actual Game Boy.", "id": "dalv2uy"}, {"comment": "And why wouldn't you do that for say, Android, and make something other people might end up playing? That actually feels nice, you know? ", "id": "dalvzxe"}, {"comment": "It's for people who want to experience what it was like to develop games with very constrained resources and as close to the hardware as possible. Not my cup of tea, just explaining the point of it. ", "id": "dalw3fj"}, {"comment": "> It's for people who want to experience what it was like to develop games with very constrained resources and as close to the hardware as possible. Not my cup of tea, just explaining the point of it.\n\nThere are easier ways to experience that.  Lots of us do that by just developing for old systems.  (NES, Atari, actual Gameboy).  It's loads of fun. Free emulators and open source tools make it easy to get started, and a lot of the systems have flash-based cartridges available if you eventually want to spend money and play on the real thing.  (and the fact that you program this in C(ish) means you're not all THAT close to the hardware.)\n\nPlease note that I'm not opposed to this thing. I'm all in favor of more interesting gadgets existing, and if people are excited about it, great!  I'm just saying you can more accurately \"experience what it was like\" by just developing for old systems themselves.", "id": "dam7bqe"}, {"comment": "> (and the fact that you program this in C(ish) means you're not all THAT close to the hardware.)\n\nA lot closer than Java on Android :P", "id": "dan0dn2"}, {"comment": "Very true.  But comparing it to Atari programming (where you literally have to count processor cycles of each assembly instruction to figure out where on the TV the electron beam is so you can draw at the right time), it feels miles away.", "id": "dan5lbn"}, {"comment": "Even then I'd rather develop something for Gameboy emulators \u2013 still better chance that people will actually play it.", "id": "dalx5lt"}, {"comment": "It is, but it's giving a rather unrealistic picture of \"what it was like.\"  No handheld system ever had constraints that were close to this bad.", "id": "damo8gu"}, {"comment": "The learning curve to develop for Android is much steeper, and the community isn't nearly as friendly as ours. We have a great place for people to learn to get started.\n\nIt's also completely free and open source to publish your games to our site, it's a little more difficult to get into the play store.\n\nAnd, you obviously haven't held an Arduboy because it actually, you know, feels nice. (shock and surprise)\n\nWhile we don't have the same size as Android, there are over 10,000 people to try a game you made and that user base is highly more engaged than you're average android user.\n\nIt's all about the community!", "id": "dalw6p2"}, {"comment": "I can't imagine how the learning curve for android is much steeper than this", "id": "dam1n9n"}, {"comment": "As I mentioned elsewhere the real value is in the community and making and sharing games. If you just want to play the games, we have over 100 online, meaning it's less than 49 cents per game and new ones are coming out all the time. But yes I do agree having SD card on it so all the games go with it would be much better!", "id": "dalw4zv"}], [{"comment": "> Arduboy is a game system the size of your imagination!\n\nSo... my imagination is the size of a credit card? :(", "id": "dam1j8v"}, {"comment": "Lol, no you can make as many games and create whatever you want so it's up to you and the community to make it bigger than it's physical size!", "id": "dan6yz1"}], [{"comment": "I feel a bit mixed about this. On one hand it's cool to see people making and selling projects, and giving people the opportunity to make and do something cool is fantastic.\n\nBut, on the other hand, it feels a little lame to just throw a screen and some microswitches on a commodity processor and call it a \"game system\". Yeah it's got enough raw horsepower that you can make something that looks and plays alright, but it seems a bit weak compared to even something like an original game boy with actual hardware designed for games (like sound chips and so on).\n\nstill, it looks pretty slick, so it's not all bad, but it just doesn't sit right for me I suppose. ", "id": "dalypm3"}, {"comment": "> but it seems a bit weak compared to even something like an original game boy with actual hardware designed for games (like sound chips and so on).\n\nHow'd you even do that for small projects? FPGA? Or are Chinese fabs cheap enough nowadays that you could theoretically tape out your own ASIC?", "id": "dam39s7"}, {"comment": "yeah, it would be a challenge for sure. Sound chips wouldn't be as big a deal because I'm sure there are still synth chips of some sort of another available, plus there are loads of codec chips and whatnot so if you wanted dedicated audio hardware it's probably pretty doable.\n\nDesigning your own graphics hardware would indeed be a much bigger challenge involving a lot of integration and details, but that's also why the game boy from nearly 30 years ago offers a much more compelling experience. I just watched a video showing some of top games for the arduboy, and quite a few of them actually look pretty cool, but you can see the hardware limitations are pretty painful.\n\nLike I said before, it is pretty awesome that people can develop this kind of stuff at all, both on the hardware and software side, so I suppose overall it's a power for good. But, the gamer in me looks at someone slapping a tiny little screen on a microcontroller and calling it a 'game system' as being a bit overblown. ", "id": "dam9fj3"}], [{"comment": "I like the concept, but come on, for $49 I'd like to atleast have the specs of a Gameboy, not less.", "id": "daltumz"}, {"comment": "The chip is actually about 4 times more powerful than the original, but lacks a dedicated hardware for graphics and sound. I've spent years trying to get a screen that could do the graphics of gameboy (Resolution and color depth) but it just doesn't exist.", "id": "dalw982"}], [{"comment": "My girlfriend bought 2 for $20/per when they were on Kickstarter. We got 4 because of shipping errors. \n\nThey're pretty neat to tinker with, especially when you realize they're just Arduino Leonardo boards. They can accept and send USB commands, so they can be used as HID devices. I'm working on trying to make a Linux-based system monitor on one for funsies.\n\nThey're neat, but not $50 neat. I look at mine as a novel intro to Arduino programming, albeit sans all the pin headers that make Arduino boards *really* interesting. ", "id": "dalub9p"}, {"comment": "The pins are still available on the back if you open the case and would like to solder to it. Waiting to see when someone adds some functionality to it.", "id": "dalw7gy"}, {"comment": "You know, seeing as I have 4, I might do it to one of them. I wanted to keep one unmodded for myself, my girlfriend wants to keep one to load games on, and one is going to a friend, leaving one unaccounted for. If I crack it open, I might post a HOWTO or something... ", "id": "dam01r7"}], [{"comment": "I've seen this before.  Seems sort of fun to play with, but kind of silly price for such weak capabilities (exactly 2 buttons other than the D-pad, no start or select, 1-bit pixels, so no greyscale at all without manual dithering, only 1 game loaded onto it at the time, pitiful memory), making it pretty much useless if you plan on using it to really play games, and even if you want to make games past any sub-gameboy toy level.\n\nAt that rate if you want to get started with some tiny embedded programming, it's not too expensive to track down a used GameBoy Advance, a flash cart, and fire up [DevKit Advance](http://devkitadv.sourceforge.net/) to start programming your own GameBoy, GameBoy Color, or GameBoy Advance games and getting involved in that community.", "id": "dalsbd3"}, {"comment": "I would argue getting started with GBA homebrew is a much steeper learning curve without as strong focus on helping beginners up and running.\n\nI actually think if you're a beginner, starting with Arduboy and then going to GBA homebrew would be a natural progression!", "id": "dalw883"}], [{"comment": "$50 is to much, raspberry pi is cheaper. Would rather buy that", "id": "dam07l4"}, {"comment": "Raspberry pi is great! but you'll have to add a power bank, usb cable, screen, buttons and a 3d printed case to get to the same level and it will never be as portable. So it's really a different application.", "id": "dan71q1"}], [{"comment": "The game \"the battle for zuthrah\" is addicting af...", "id": "dam24q0"}], [{"comment": "It's sweet!", "id": "dalq9gg"}], [{"comment": "Hugged?", "id": "daly4gk"}], [{"comment": "So you like [small](http://blog.thisisnotrocketscience.nl/projects/microgameboy/) reddit?", "id": "dammrnu"}], [{"comment": "I'd hold out until someone manages to mass-produce [Sprite_TM's ESP32 Gameboy](https://hackaday.com/2016/11/07/tiny-game-boy-that-plays-witcher-3-and-other-things-that-blew-my-mind/)\n\nedit: Apparently this rustled some jimmies. Anyone want to tell me why?", "id": "daltcjv"}, {"comment": "I came here to reply to this. I want to do this.", "id": "dalw8e5"}, {"comment": "Please do this. :)", "id": "dalwl59"}]]], "5fqoia": ["Building Compassionate Software", "2016-11-30 19:56:29", 2, "https://ashfurrow.com/blog/building-compassionate-software/", [], []], "5fvgaj": ["Richard Feynman (physicist) discussing computer science heuristics", "2016-12-01 11:04:11", 65, "https://www.youtube.com/watch?v=EKWGGDXe5MA", [[17, "I stand by the belief that the true scientific geniuses are the ones who are both capable of understanding and expanding their respective fields, while simultaneously conveying these complex ideas in simpler terms for the general public.\n\nI was born after Feynmans death, but it's just a testament to his passion for teaching that I can go back and watch or listen to his previous lectures and feel just as captivated as if I were there many years ago.\n\nThank you for sharing this. Every time I see or listen to something new of his, I get a deeper appreciation for who he was."], [6, "> Richard Feynman (physicist)\n\nMichael Jordan (basketball player)\n\nIsaac Newton (mathematician)\n\nMartin Luther King Jr. (public speaker)\n\n\n"], [1, "Those transitions at the beginning though..."]], [[{"comment": "I stand by the belief that the true scientific geniuses are the ones who are both capable of understanding and expanding their respective fields, while simultaneously conveying these complex ideas in simpler terms for the general public.\n\nI was born after Feynmans death, but it's just a testament to his passion for teaching that I can go back and watch or listen to his previous lectures and feel just as captivated as if I were there many years ago.\n\nThank you for sharing this. Every time I see or listen to something new of his, I get a deeper appreciation for who he was.", "id": "danpujb"}, {"comment": "Feynman is easily the scientist I have the most respect for.  His ethical stance on the challenger disaster alone is enough for me to hold him in the highest respect.", "id": "dantns5"}, {"comment": "> His ethical stance on the challenger disaster\n\nWhat stance is that?", "id": "daom5mf"}, {"comment": "He was the lone dissent on the investigation commission of challenger tragedy.", "id": "daon6ud"}, {"comment": "to add to what ascenx said, there was political pressure from the commission to ignore/downplay the O-ring issues and he threatened to leave the commission alltogether.\n\nhttps://en.wikipedia.org/wiki/Rogers_Commission_Report#Role_of_Richard_Feynman\n\n\n> Not only did this confirm that NASA management had clearly failed to communicate with their own engineers, but the disparity engaged Feynman's emotions. When describing these wildly differing estimates, Feynman briefly lapses from his damaging but dispassionate detailing of NASA's flaws to recognize the moral failing that resulted from a scientific failing: he was clearly upset that NASA presented its clearly fantastical figures as fact to convince a member of the public, schoolteacher Christa McAuliffe, to join the crew. Feynman was not uncomfortable with the concept of a 1/100 risk factor, but felt strongly that the recruitment of laypeople required an honest portrayal of the true risk involved.[6]\n\n---\n\n> Based on his experiences with NASA's management and engineers, Feynman concluded that the serious deficiencies in NASA management's scientific understanding, the lack of communication between the two camps, and the gross misrepresentation of the shuttle's dangers, required that NASA take a hiatus from shuttle launches until it could resolve its internal inconsistencies and present an honest picture of the shuttle's reliability.  Feynman soon found that, while he respected the intellects of his fellow Commission members, they universally finished their criticisms of NASA with clear affirmations that the Challenger disaster should be addressed by NASA internally, but that there was no need for NASA to suspend its operations or to receive less funding. Feynman felt that the Commission's conclusions misrepresented its findings, and he could not in good conscience recommend that such a deeply flawed organization as NASA should continue without a suspension of operations and a major overhaul. His fellow commission members were alarmed by Feynman's dissent, and it was only after much petitioning that Feynman's minority report was included at all. **Feynman was so critical of flaws in NASA's \"safety culture\" that he threatened to remove his name from the report unless it included his personal observations on the reliability of the shuttle**, which appeared as Appendix F.\n\n---\n\nThe following is a quote of Richard Feynmans in relation to the Challenger Disaster.  I've always loved this quote and for a long time had it on my resume as I think it perfectly describes the attitude of a successful software developer (and explains the divide between engineers and management).\n\n*For a successful technology, reality must take precedence over public relations, for Nature cannot be fooled.*", "id": "daoxr82"}], [{"comment": "> Richard Feynman (physicist)\n\nMichael Jordan (basketball player)\n\nIsaac Newton (mathematician)\n\nMartin Luther King Jr. (public speaker)\n\n\n", "id": "dao4dj1"}, {"comment": "Isaac Newton was a physicists first, mathematician second. It's almost like putting\n\nMichael Jordan (baseball player)\n\nNot quite that bad, though.", "id": "daod6lg"}, {"comment": "> Isaac Newton was a physicists first, mathematician second.\n\nThe division between those two things was not well-defined back then. It's not terribly well-defined now!", "id": "daoioym"}, {"comment": "It's pretty well defined now. There are rare fields like string theory which are big in pop culture, where there are some number of people who blur the line. But your run of the mill High Energy or Condensed Matter theorist, is extremely far removed from being a mathematician.\n\nAs for then, people just called themselves natural philosophers. But looking back on it we can clearly see that Newton was mostly interested in physics, and invented calculus as a tool. Newton is still perhaps the most important physicist in history, but as a mathematician nobody would mention him before Euler or Gauss or Riemann, and many others.", "id": "dapvflg"}, {"comment": ">Isaac Newton (mathematician and alchemist)\n\nFtfy", "id": "dao4tmr"}, {"comment": "You have written a list", "id": "daoeval"}], [{"comment": "Those transitions at the beginning though...", "id": "daok3us"}]]], "5fxx7z": ["Type-checking a Dynamic Language", "2016-12-01 20:41:27", 8, "http://journal.stuffwithstuff.com/2010/08/31/type-checking-a-dynamic-language/", [[1, "Discussion 6 years ago: https://www.reddit.com/r/programming/comments/d7qwo/typechecking_a_dynamic_language/\n\n"]], [[{"comment": "Discussion 6 years ago: https://www.reddit.com/r/programming/comments/d7qwo/typechecking_a_dynamic_language/\n\n", "id": "danv7w3"}]]], "5g9njw": ["Learn coding structures with Social Networking Patterns", "2016-12-03 16:57:23", 0, "http://weall.com/book/chapter?name=LEARN%20CODING%20STRUCTURES%20WITH%20SOCIAL%20NETWORKING%20PATTERNS", [[4, "nope"]], [[{"comment": "nope", "id": "daqn3co"}]]], "5gbmzh": ["Jekyll Admin is out for a while and seeking for help. ReactJS developers, help Jekyll Admin become better!", "2016-12-03 23:47:19", 0, "https://github.com/jekyll/jekyll-admin", [], []], "5g0xaw": ["How To Get Started In Golang", "2016-12-02 06:00:20", 8, "https://www.howistart.org/posts/go/1", [[3, "\"Go is a lovely little programming language designed by smart people you can trust and \"\n\nCringe. \n\nOne thing I found helpful is to make sure all projects are in your GOPATH directory. A bit different from other languages. I also higly recommend the Kernighan book on Go."], [-3, "youtube"]], [[{"comment": "\"Go is a lovely little programming language designed by smart people you can trust and \"\n\nCringe. \n\nOne thing I found helpful is to make sure all projects are in your GOPATH directory. A bit different from other languages. I also higly recommend the Kernighan book on Go.", "id": "daoy3f7"}], [{"comment": "youtube", "id": "daom9j8"}]]], "5g2adw": ["Continuous fuzzy testing of open source software, by Google", "2016-12-02 11:45:39", 14, "https://github.com/google/oss-fuzz", [[3, "Fuzz testing, not fuzzy testing :-)"]], [[{"comment": "Fuzz testing, not fuzzy testing :-)", "id": "daox2i7"}, {"comment": "Yes, sorry for the typo! ", "id": "daoz9d3"}]]], "5g2adv": ["A curated list of sweet Hyper packages, themes, and resources.", "2016-12-02 11:45:39", 0, "https://github.com/bnb/awesome-hyper", [], []], "5fsahs": ["How to Make a Neural Network (LIVE)", "2016-12-01 00:25:07", 8, "https://www.youtube.com/watch?v=vcZub77WvFA", [[0, "Really informative video"]], [[{"comment": "Really informative video", "id": "damrqmq"}]]], "5g0rcq": ["Big Data Guide: How to Set Up Spark with Jupyter painlessly on AWS EC2 clusters, with S3 I/O", "2016-12-02 05:27:02", 1, "https://github.com/PiercingDan/spark-Jupyter-AWS", [], []], "5gbhl7": ["The Magical Password", "2016-12-03 23:17:25", 14, "https://return.co.de/blog/articles/magical-password/", [[5, "I kinda expected an article(not complaining, this was a cool read) about a bug in some crypto that let two different strings get turned into the same hash, resulting in a 'magic' password that could be 2 things."], [1, "This article was inspired by this podcast: https://softwareengineeringdaily.com/2016/11/19/debugging-stories-with-haseeb-qureshi/\n\nAs always, I'd appreciate any helpful comments regarding style, language and content."], [1, "Wow, that sucks! Glad you found the \"bug\" and thanks for the story "]], [[{"comment": "I kinda expected an article(not complaining, this was a cool read) about a bug in some crypto that let two different strings get turned into the same hash, resulting in a 'magic' password that could be 2 things.", "id": "dar7iit"}], [{"comment": "This article was inspired by this podcast: https://softwareengineeringdaily.com/2016/11/19/debugging-stories-with-haseeb-qureshi/\n\nAs always, I'd appreciate any helpful comments regarding style, language and content.", "id": "daqwget"}, {"comment": "I think the title is misleading (nothing \"magical\" about the password) and the story is pretty anti-climactic. If the environment was \"recently\" split in two that would've been, at least, number 3 or 4 to check after closing two or three of those tickets.\n\nIt's not a bad story, but I had a bit of a \"meh\" after reading it.", "id": "dar0xby"}, {"comment": "The title was used intentionally be we actually thought that there is something special or \"magical\" about the password that causes that problem. So we were on the wrong track.\nBut with every bad situation, you'll learn something from it - as we did.", "id": "dar2sn5"}, {"comment": "I am always a fan of the more relaxed writing style in such posts and you did a pretty good job IMHO. I liked it. Fun story too, had similar things happen to me over the years. ", "id": "daqzqeo"}, {"comment": "I'm glad, you liked it. The last article I published here was actually criticised for my relaxed writing style. But personally, I also enjoy reading those article and therefore I tend to use that style for my articles.", "id": "darpdg0"}, {"comment": "Write however you want. It is your blog. Don't try to please every critic online. It will destroy you and you still won't please them! If the content is good the writing style shouldn't matter. \n\nSome of my favourite little stories are things like the 500 mile email bug, the Crash Bandicoot memory card bug and the rescue a running Unix system with just Emacs. \n\nSo yeah just be yourself and write hoe you would like to read it. ", "id": "darpxmb"}], [{"comment": "Wow, that sucks! Glad you found the \"bug\" and thanks for the story ", "id": "darl9vt"}]]], "5fzluc": ["[RFC] My first public elevation API, what do you think ?", "2016-12-02 01:21:16", 8, "http://elevationapi.xyz/", [[1, "Finally finished this simple, yet useful, API. What do you think ?\n\nShould I also include some libraries for Python/PHP/\u2026 ?\n\nThanks !"]], [[{"comment": "Finally finished this simple, yet useful, API. What do you think ?\n\nShould I also include some libraries for Python/PHP/\u2026 ?\n\nThanks !", "id": "dao9ax3"}, {"comment": "I'd love to help with the python lib!", "id": "daok8j4"}, {"comment": "The only code I have set is for python, but its missing pipy packaging and some d\u00e9tails. We could contribute over github if you want; DM me ;-)", "id": "daoveyi"}]]], "5g2mjo": ["Advent of Code 2016", "2016-12-02 13:35:47", 38, "http://adventofcode.com/2016", [[1, "what is it guys?"], [1, "q.v. my comment on a different thread\n\n> I never got around to doing all of these from 2015, so I'm doing them now. For anybody else who didn't do the 2015 tree it is still there in it's entirety if you click on \"Events\"."]], [[{"comment": "what is it guys?", "id": "daq7vvk"}, {"comment": "Programming challenges for fun and personal satisfaction. ", "id": "daqeha1"}], [{"comment": "q.v. my comment on a different thread\n\n> I never got around to doing all of these from 2015, so I'm doing them now. For anybody else who didn't do the 2015 tree it is still there in it's entirety if you click on \"Events\".", "id": "daqehme"}]]], "5g0zxs": ["I'm a beginning programmer and had fun writing this a few weeks ago!", "2016-12-02 06:15:13", 4, "https://gist.github.com/RyanYoak/0b5ac1b1c4054bdd890b6d367e176705", [[4, "That's a good start, but you could make methods to handle your code duplication. Adding more methods to minimize the number of indents would make code easier to follow, and documentation could be made on particular methods, or if named and structured well you may not need much for documentation. \n\nI would also consider using more descriptive variable names. \n\nThese adjustments may seem a bit excessive for just beginning, but they will ultimately help you if you revisit the code. It will be way less work for missed cases if your code is more streamlined. \n\nYou should be proud of the work you've done though! Sorry if this wasn't helpful, but even just basic code review can be helpful for growth as a developer. I mean this all to be encouraging. "], [4, "`provenNumbers` is a list but you are using it to detect membership (`n not in provenNumbers`). Although it doesn't matter for the purposes of this code you could consider changing it to a `set()`.\n\nChecking membership for a list is an O(n) complexity operation. That is the length of the operation grows as the size of the list (`n`) grows. It does this by checking the first element, then the second element, then the third, etc.\n\nA membership test in a set will be an O(1) operation, meaning that regardless of the size of the set it'll still be able to tell you if `x` is in it in a constant amount of time. That is, the number of steps it takes to test membership doesn't get larger as the set gets larger. It does this using maths called [hashing](https://en.wikipedia.org/wiki/Hash_function#Hash_tables).\n\nWhere for a list in python you might do:\n\n    n = 100000\n    x = []\n    for i in range(n):\n            x.append(i)\n            _ = i in x\n            print(\"\\r{}/{}\".format(i, n), end=\"\")\n\nfor a set you would do:\n\n    y = set()\n    for i in range(n):\n            y.add(i)\n            _ = i in y\n            print(\"\\r{}/{}\".format(i, n), end=\"\")\n\nand running it you can see the vast difference in speed.\n"], [3, "I like your optimization of checking if the current value has already been solved.  Some beginners would miss that their first time through."], [3, "Nice job! \n\nSome more code review stuff:\n\n* You generally want to put your `import`s at the top of the file. This makes it easy to see at a glance which dependencies your code has. Also, I'm not sure how Python `import`s perform, but if your function is meant to be run many times, putting the `import` in the function means it will run every time your function is called, so this could potentially slow down your function as Python has to check every single time whether `time` has been imported yet. \n* oh god please use descriptive variable names\n* `print` is a function just like `append` or `int`, so write it the same way - don't put a space before the parentheses. \n* Don't terminate lines with semicolons. \n* In fact, just generally speaking, install a linter. A linter is a tool that enforces good coding style. It will warn you about things like semicolons in Python. You should be able to find a linter plugin for whatever text editor you are using. \n* You have some redundant conditionals. If `n not in provenNumbers` is false, then `n in provenNumbers` will always be true because it is literally the negation of the first condition. You could just use `else`. \n* You have some explicit duplication. Look at your inner `while` loop (`while (n != 1)`). The two branches of the conditional are identical, except for what they set `n` to. You can delete lines 24-31 and de-indent 35-42 by one level so that they fall after the `else` block. "]], [[{"comment": "That's a good start, but you could make methods to handle your code duplication. Adding more methods to minimize the number of indents would make code easier to follow, and documentation could be made on particular methods, or if named and structured well you may not need much for documentation. \n\nI would also consider using more descriptive variable names. \n\nThese adjustments may seem a bit excessive for just beginning, but they will ultimately help you if you revisit the code. It will be way less work for missed cases if your code is more streamlined. \n\nYou should be proud of the work you've done though! Sorry if this wasn't helpful, but even just basic code review can be helpful for growth as a developer. I mean this all to be encouraging. ", "id": "daortt5"}], [{"comment": "`provenNumbers` is a list but you are using it to detect membership (`n not in provenNumbers`). Although it doesn't matter for the purposes of this code you could consider changing it to a `set()`.\n\nChecking membership for a list is an O(n) complexity operation. That is the length of the operation grows as the size of the list (`n`) grows. It does this by checking the first element, then the second element, then the third, etc.\n\nA membership test in a set will be an O(1) operation, meaning that regardless of the size of the set it'll still be able to tell you if `x` is in it in a constant amount of time. That is, the number of steps it takes to test membership doesn't get larger as the set gets larger. It does this using maths called [hashing](https://en.wikipedia.org/wiki/Hash_function#Hash_tables).\n\nWhere for a list in python you might do:\n\n    n = 100000\n    x = []\n    for i in range(n):\n            x.append(i)\n            _ = i in x\n            print(\"\\r{}/{}\".format(i, n), end=\"\")\n\nfor a set you would do:\n\n    y = set()\n    for i in range(n):\n            y.add(i)\n            _ = i in y\n            print(\"\\r{}/{}\".format(i, n), end=\"\")\n\nand running it you can see the vast difference in speed.\n", "id": "daotevs"}, {"comment": "Another reason to use a set: it more closely matches conceptually what the OP is trying to do.", "id": "dap2kq7"}], [{"comment": "I like your optimization of checking if the current value has already been solved.  Some beginners would miss that their first time through.", "id": "daot0le"}], [{"comment": "Nice job! \n\nSome more code review stuff:\n\n* You generally want to put your `import`s at the top of the file. This makes it easy to see at a glance which dependencies your code has. Also, I'm not sure how Python `import`s perform, but if your function is meant to be run many times, putting the `import` in the function means it will run every time your function is called, so this could potentially slow down your function as Python has to check every single time whether `time` has been imported yet. \n* oh god please use descriptive variable names\n* `print` is a function just like `append` or `int`, so write it the same way - don't put a space before the parentheses. \n* Don't terminate lines with semicolons. \n* In fact, just generally speaking, install a linter. A linter is a tool that enforces good coding style. It will warn you about things like semicolons in Python. You should be able to find a linter plugin for whatever text editor you are using. \n* You have some redundant conditionals. If `n not in provenNumbers` is false, then `n in provenNumbers` will always be true because it is literally the negation of the first condition. You could just use `else`. \n* You have some explicit duplication. Look at your inner `while` loop (`while (n != 1)`). The two branches of the conditional are identical, except for what they set `n` to. You can delete lines 24-31 and de-indent 35-42 by one level so that they fall after the `else` block. ", "id": "daotydw"}, {"comment": "Some additions:\n\n* Don't use tabs in Python but use 4 spaces, follow PEP8, might as well learn this early\n* If statements mostly have redundant brackets like: if (n != 1), although other languages might require it, this generally isn't really done in Python code\n\nImports generally go at the top, sometimes you might place an import statement in a function in some cases, but that is generally only to get around an import loop/cycle.", "id": "dapm5dq"}, {"comment": "Imports are cached in Python and the cost of checking if it is in a dictionary is veeeeeeeeery small, but still it is way better to put them at the top.", "id": "daoymp7"}]]], "5g8biy": ["Improving cache consistency", "2016-12-03 09:28:04", 22, "http://simongui.github.io/2016/12/02/improving-cache-consistency.html", [[1, "[bottled water](https://github.com/confluentinc/bottledwater-pg) might be interesting to look at, for those who use postgres. It pushes into kafka topics, which is a less specific application than what the author talks about, but in principle the stream could then be pushed into redis or whatever. (Or one could use the logical decoding feature of postgres 9.4+ directly to write to a cache server, but that'd require quite some implementation effort, probably)"]], [[{"comment": "[bottled water](https://github.com/confluentinc/bottledwater-pg) might be interesting to look at, for those who use postgres. It pushes into kafka topics, which is a less specific application than what the author talks about, but in principle the stream could then be pushed into redis or whatever. (Or one could use the logical decoding feature of postgres 9.4+ directly to write to a cache server, but that'd require quite some implementation effort, probably)", "id": "daqif60"}]]], "5fl78n": ["WebVR coming to Servo: Architecture and latency optimizations", "2016-11-29 23:55:10", 24, "https://blog.mozvr.com/webvr-servo-architecture-and-latency-optimizations/", [[1, "Can't wait for Firefox to be powered by Servo altogether. Current engine and lack of multiprocess tabs is really hurting :|"]], [[{"comment": "Can't wait for Firefox to be powered by Servo altogether. Current engine and lack of multiprocess tabs is really hurting :|", "id": "dalv2lu"}, {"comment": "Try changing `dom.ipc.processCount` to 4+ in `about:config`. That sets the size of the process pool for tabs.", "id": "damb5t7"}]]], "5g242v": ["Reinventing Fast Inverse Roots Using 8th Grade Math", "2016-12-02 10:48:32", 50, "http://www.bullshitmath.lol/FastRoot.slides.html", [[17, "This is absolutely not \"8th grade\" maths."], [13, "Unviewable on mobile."], [5, "I like the content, but the delivery was a little annoying. For some reason, the formulas kept screwing up and obscuring the text, and the next slide took very long to load each time. But I think that could just be me. (Firefox 49.0b10) "], [6, "Well written! 10/10"], [6, "What a horrid website. Why can't things just be on the page and there be a link to go to the next page? \n\nAlso, the cast does not convert a float to a long or a long to a float. It takes a pointer to a float in memory and returns a pointer to a long that still points to that float allowing you to do operations on the float the compiler wouldn't let you do through a float type. In memory, the float is unchanged. That's how it works. "], [3, "It could have been on one page. Really the question is how many ads are there on each page? And no, I'm not disabling my ad blocker to find out. "], [3, "the format of these types of page ensures im never going to read it and that i'll downvote it every time i see it"], [3, "Good read but I agree with others that the say this isn't 8th grade math"], [1, "The latex shows up wrong for me\n\nhttp://i.imgur.com/dbsJaxb.png"], [1, "Nice post even if I have some difficulties  to understand what 8grade math means, as in Italy we have a completly different system."]], [[{"comment": "This is absolutely not \"8th grade\" maths.", "id": "dap4ilf"}, {"comment": "depends where you went for 8th grade maths", "id": "dap4x8b"}, {"comment": "[deleted]", "id": "dapqjir"}, {"comment": "you are not 8 years old in the 8th grade", "id": "dapqprp"}, {"comment": "sorry, misread wikipedia", "id": "dapqrw0"}, {"comment": "I might have exaggerated it a bit; the important bit is that the relationship is (in the right representation) linear, which makes the connection easier to see and analyze.", "id": "dapcuwk"}, {"comment": "It's Algebra 1 math.  For the US that's either 9th or 10th grade with some small cases of 8th grade.", "id": "dapf01n"}, {"comment": "\"The eighth grade mathematics curriculum in Canada and the United States usually includes either Pre-algebra or Algebra I.\"\n\n\"Between 1990 and 2011, the share of 8th graders enrolled in Algebra 1 or a higher math course nearly tripled, from 16 percent to 47 percent,\"\n\nI was in 8th grade back in 1990, and I certainly remember learning Algebra before high school.", "id": "dapi2f6"}, {"comment": "I took Algebra I in 8th grade, was very common in my school district.", "id": "dapn8gr"}, {"comment": "I took it in 7th grade. 9th was trig", "id": "daptsmb"}, {"comment": "I took in in 8th grade. Geometry 9th, Algebra 2 10th, Pre-Calc 11.", "id": "dapui4d"}, {"comment": "7th grade for me", "id": "dapwbhi"}], [{"comment": "Unviewable on mobile.", "id": "dap21ya"}, {"comment": "Which device are you on? It seems to run fine on all of my android devices, but I have no clue if it works on iOS.", "id": "dapc7ge"}, {"comment": "On iOS. Not unviewable, but very annoying to swipe through the slides and all the text being small ", "id": "daphgk5"}], [{"comment": "I like the content, but the delivery was a little annoying. For some reason, the formulas kept screwing up and obscuring the text, and the next slide took very long to load each time. But I think that could just be me. (Firefox 49.0b10) ", "id": "dap7uwy"}, {"comment": "Huh, that seems strange, it might be because MathJax (the LaTeX) renderer is lagging a bit since it seems to work well from my end. Unfortunately, the slides do take up a fair bit of size, so it'll likely lag on slower connections. I would normally recommend the non-interactive version, but it currently hangs on most browsers. Instead, the article http://www.phailed.me/2014/10/0x5f400000-understanding-fast-inverse-sqrt-the-easyish-way/ gives a pretty good overview of this material, but it focuses on the historical development of the original constant rather than the intuition behind the general arbitrary power method. Thanks for the feedback :)", "id": "dapcqx0"}], [{"comment": "Well written! 10/10", "id": "daoxows"}], [{"comment": "What a horrid website. Why can't things just be on the page and there be a link to go to the next page? \n\nAlso, the cast does not convert a float to a long or a long to a float. It takes a pointer to a float in memory and returns a pointer to a long that still points to that float allowing you to do operations on the float the compiler wouldn't let you do through a float type. In memory, the float is unchanged. That's how it works. ", "id": "dappufv"}, {"comment": "> Also, the cast does not convert a float to a long or a long to a float. It takes a pointer to a float in memory and returns a pointer to a long that still points to that float allowing you to do operations on the float the compiler wouldn't let you do through a float type. In memory, the float is unchanged. That's how it works.\n\nI never said the float is changed in memory. ", "id": "dapsmso"}, {"comment": "    *(long*)& takes a float and outputs a long\n\n    *(float*)& takes a long and outputs a float\n\nthis is not what it does", "id": "dapt7l5"}, {"comment": "In non-standard C (because this is an alias violation within the standard, but it doesn't matter), the first expression takes an l-value of float type and outputs an l-value of long type, hence the description. It doesn't matter which `float -> long` function it is, the analysis just rests on the fact that this is a function from the set of floats to the set of longs and it obeys certain algebraic laws.", "id": "daptfzz"}, {"comment": "OH\n\nI missed the dereference operator and long i, not long *i. You're quite right, I take that back. ", "id": "dapushg"}], [{"comment": "It could have been on one page. Really the question is how many ads are there on each page? And no, I'm not disabling my ad blocker to find out. ", "id": "dap1zwk"}, {"comment": "There is none, actually.", "id": "dap222g"}, {"comment": "> It could have been on one page.\n\nAs the URL indicates (`.slides.`), these are clearly slides from a presentation. Given that OP doesn't seem to be the author, I'm perfectly fine with the content not having been reformatted prior to posting.", "id": "dapakm0"}, {"comment": "Hey, good observation. Removing slides (ie http://www.bullshitmath.lol/FastRoot.html) and it's on one page!  \n\n", "id": "dapbbxn"}, {"comment": "Holy shit this is 100x better", "id": "daplw5a"}, {"comment": "yeah, wow", "id": "dapuv7f"}, {"comment": "Hah, and (paging /u/possiblyquestionable ) the .html version reliably crashes desktop Chrome tabs, renders in Firefox with NoScript, but hangs when scripting is enabled.  :-)\n\n   The \"Notebook View\" button (takes me to an url starting with nbviewer ) renders the page (with a footnote at the top instead of bottom), but doesn't properly transform the MathJax into code.", "id": "daqzy6g"}], [{"comment": "the format of these types of page ensures im never going to read it and that i'll downvote it every time i see it", "id": "dap9phq"}], [{"comment": "Good read but I agree with others that the say this isn't 8th grade math", "id": "dapjfl6"}], [{"comment": "The latex shows up wrong for me\n\nhttp://i.imgur.com/dbsJaxb.png", "id": "dapufxd"}, {"comment": "What browser are you on?", "id": "dapzlkk"}, {"comment": "Firefox I think.", "id": "dapzr7h"}], [{"comment": "Nice post even if I have some difficulties  to understand what 8grade math means, as in Italy we have a completly different system.", "id": "daqzgwt"}]]], "5g069j": ["I created /r/musicianprogrammer just now, a subreddit for programmers that are also musicians. Is anyone interested?", "2016-12-02 03:34:02", 65, "https://np.reddit.com/r/musicianprogrammer", [[14, "What about /r/musicprogramming ?"], [10, "joined :) . curious about what you aim to accomplish with the sub though."], [6, "Does the [Sonic Pi](http://sonic-pi.net/) qualify?"], [4, "I'm holding out for someone to create the /r/musicianprogrammerbeekeeperclogdancer subreddit.  "], [3, "Definitely interested! I'm a CS major who people mistake for a music major because of how many groups I play in >.<"], [2, "definitely interested. jazz musician who is currently back in university getting a degree in computer science. (because being being a poor musician didn't seem like a fun future!)\n\ni'm currently building some apps using ToneJS.  An Aural Skills trainer.\n\nid be interested in finding some libraries to dynamically generate sheet music from some input. "], [2, "I read that as /r/muscularprogrammer and was confused for a bit."], [1, "Sold, I havent played the piano or studied music theory in years but i've been looking for a good excuse to jump back in."], [1, "I think these 2 groups have a lot of overlap.\n\nI am interested."], [1, "Well, I play klarinet, piano and saxophone, but I rarely mix that with being a programmer. I'll take a look and maybe subscribe."], [1, "Count me in"], [1, "Highly...Jazz Guitarist here who makes his living programming Delphi."], [1, "Subscribed"], [1, "I always wondered if we could teach computers to create meaningful music using machine learning. Lets do it!"], [1, "I'm both a musician and a programmer, I'm not even slightly interested in combining those two, though. How would that work?"], [1, "Big fan of \n\nhttp://overtone.github.io/\n\nand \n\nhttps://github.com/alda-lang/alda"]], [[{"comment": "What about /r/musicprogramming ?", "id": "dap1d97"}], [{"comment": "joined :) . curious about what you aim to accomplish with the sub though.", "id": "daonjmc"}], [{"comment": "Does the [Sonic Pi](http://sonic-pi.net/) qualify?", "id": "daope6v"}], [{"comment": "I'm holding out for someone to create the /r/musicianprogrammerbeekeeperclogdancer subreddit.  ", "id": "dapfvli"}, {"comment": "Don't let your memes be dreams, friend. Be the change  you want to see in the world!", "id": "dapjvx9"}], [{"comment": "Definitely interested! I'm a CS major who people mistake for a music major because of how many groups I play in >.<", "id": "daov2wf"}], [{"comment": "definitely interested. jazz musician who is currently back in university getting a degree in computer science. (because being being a poor musician didn't seem like a fun future!)\n\ni'm currently building some apps using ToneJS.  An Aural Skills trainer.\n\nid be interested in finding some libraries to dynamically generate sheet music from some input. ", "id": "daos1fq"}, {"comment": "I'm with you, buddy...keep the dream!", "id": "dap1a28"}, {"comment": "I have a similar situation at hand. I decided to code more and dropped my idea of getting a jazz degree after my BTech. \nWould have been a lot of fun to go the jazz way, but I think I'll be happy with this decision. I'm learning a lot of things but among that, I'm trying to build something like MorphWiz with ProcessingJS. You might like it!", "id": "dapo510"}, {"comment": "what i quickly discovered is that I like creating stuff.  With music, you just create music.\n\nBut with programming, you can create anything (including music, obviously)! The ability to \"create\" and \"express myself\" has increased ten fold.\n\nim familiar with Processing but ill have to check out MorphWiz. thanks! trying to avoid reinventing the wheel when it comes to properly displaying sheet music. (given how many different ways you can subdivide a beat, etc...)", "id": "dapoaxz"}, {"comment": "http://lilypond.org/", "id": "darewuf"}], [{"comment": "I read that as /r/muscularprogrammer and was confused for a bit.", "id": "dap7tqb"}, {"comment": "That would be /r/brogramming.", "id": "dapj3vp"}], [{"comment": "Sold, I havent played the piano or studied music theory in years but i've been looking for a good excuse to jump back in.", "id": "daop3wm"}], [{"comment": "I think these 2 groups have a lot of overlap.\n\nI am interested.", "id": "daot8b2"}], [{"comment": "Well, I play klarinet, piano and saxophone, but I rarely mix that with being a programmer. I'll take a look and maybe subscribe.", "id": "daoxcmi"}], [{"comment": "Count me in", "id": "daoyh92"}], [{"comment": "Highly...Jazz Guitarist here who makes his living programming Delphi.", "id": "dap1924"}], [{"comment": "Subscribed", "id": "dap1a3n"}], [{"comment": "I always wondered if we could teach computers to create meaningful music using machine learning. Lets do it!", "id": "dap5fy8"}], [{"comment": "I'm both a musician and a programmer, I'm not even slightly interested in combining those two, though. How would that work?", "id": "dapfv1o"}, {"comment": "Upvoted because it's a good question, even if you seem a bit dismissive.\n\nOff the top of my head:\n\n[Creating music in as few lines of code as possible](https://www.youtube.com/watch?v=MqZgoNRERY8)\n\n[Creating music with a programming language *designed* to make music](http://sonic-pi.net/)\n\n[Listening to music which is intended to make it easier to write code (or work on anything)](http://mtcb.pwop.com/)\n\n[Creating fresh rhymes with AI](http://deepbeat.org/)\n\nA lot of people combine their passion for music with their love of making computers bow to their whims. I am personally working on a program that uses a simple genetic algorithm to generate interesting melodies.", "id": "dapk84o"}, {"comment": "The reason why I sounded so dismissive is that I play the bass, which is an instrument you have to mostly feel and that I play mostly by ear, whereas coding is very rigid, musically speaking. I can't think of a way how to combine those two elements.\n\nHow would you go about making electronic programmatically with a groove?\n\nThis is actually quite interesting.", "id": "daprj6u"}, {"comment": "**Disclaimer: I am not a musician, just a music lover, so pardon any inaccuracies or misused words**\n\nThe thing is, most good music follows very specific rules, dictated by what we as humans find pleasing. If you can figure out what those rules are, you can start to find programmatic ways of working them.\n\nAm I saying I'd rather listen to music written and performed by a machine? Nah. But it's an interesting exercise, and it can be viewed as a tool. \n\nHere's an example:\n\nEver had trouble coming up with a good chord progression in a certain part of a song? What if you could feed what you have so far into a machine learning algorithm that can use your style to output a few ideas that you can work with? This is exactly what a friend of mine, who writes a *lot* of music, asked me to make for him. And I have to say, it's been a hell of a good time trying to figure out.\n\nHe's not going to be using it to write entire songs, but what we've built together so far has gotten him out of a few instances of musician's block, so to speak.\n\nEven outside of this admittedly fanciful and limited application, there are all kinds of projects out there that really make you think about just how artistic programming can be. That first link I gave you in my first reply is a good example of that, in my opinion. Dude created a fairly complex and interesting piece of music out of a few mathematical expressions. Sure, to the computer it's just bits and bytes, but with a basic understanding of what humans find pleasing, you can make computers do things that we could never dream of doing ourselves, at least not as quickly as a computer can.\n\nI hope that makes sense. ", "id": "dapugdv"}, {"comment": "I'm a huge fan of /u/adamneely1, yesterday I saw [his video on harmonic polyrythms](https://www.youtube.com/watch?v=_gCJHNBEdoc).\n\nBasic idea: Harmonies and polyrythms are the same thing, except on a different scale. From a programming standpoint this is a very interesting idea.", "id": "daqdv56"}], [{"comment": "Big fan of \n\nhttp://overtone.github.io/\n\nand \n\nhttps://github.com/alda-lang/alda", "id": "dappsnw"}]]], "5g0omf": ["A whole mess of documentation aggregated in an easy to read, searchable site, with offline mode.", "2016-12-02 05:11:26", 207, "http://devdocs.io/", [[15, "I use this every day! Something I really appreciate is that it makes the styling of all your docs consistent, which eases reading. "], [5, "Clean, fast UI.\n\nIs there support for more than one level of depth in the table-of-contents pane on the left?"], [3, "I use this on my tablet with the offline mode function to read on a commute train and at night in bed.  I have two complaints:\n\n* The ordering of some of the table of contents is out of order, i.e., it doesn't match what I see on my desktop when I hit the url. This is a minor annoyance.\n* No images seem to get captured on my tablet - for example, I'm reading the Vue documentation on my tablet now and I don't get a nice life cycle image that's in the docs. This is a bit more of an annoyance, but the offline feature is pretty good."], [2, "Used it on a flight recently and it was fantastic. Offline mode rocks!"], [2, "I'll take a whole mess over a curated list any day. This is a fantastic resource. Thank you! "], [2, "Not trustable. The one time I needed it due to lack of Internet, it wouldn't load, the offline data. I had visited it only a week beforehand.\n\nIt's fine to use as a single source of doc when you're online, but don't trust it for offline use. Use something like [Zeal](https://zealdocs.org/) (desktop app) instead."], [1, "no java, no scala..."]], [[{"comment": "I use this every day! Something I really appreciate is that it makes the styling of all your docs consistent, which eases reading. ", "id": "daorj0p"}], [{"comment": "Clean, fast UI.\n\nIs there support for more than one level of depth in the table-of-contents pane on the left?", "id": "dap2v5m"}, {"comment": "I think so? I have right now Backbone > Sync > Backbone.ajax. Is that what you mean? ", "id": "dape9ti"}], [{"comment": "I use this on my tablet with the offline mode function to read on a commute train and at night in bed.  I have two complaints:\n\n* The ordering of some of the table of contents is out of order, i.e., it doesn't match what I see on my desktop when I hit the url. This is a minor annoyance.\n* No images seem to get captured on my tablet - for example, I'm reading the Vue documentation on my tablet now and I don't get a nice life cycle image that's in the docs. This is a bit more of an annoyance, but the offline feature is pretty good.", "id": "dapcxif"}], [{"comment": "Used it on a flight recently and it was fantastic. Offline mode rocks!", "id": "dap6sf3"}], [{"comment": "I'll take a whole mess over a curated list any day. This is a fantastic resource. Thank you! ", "id": "dap7hpu"}], [{"comment": "Not trustable. The one time I needed it due to lack of Internet, it wouldn't load, the offline data. I had visited it only a week beforehand.\n\nIt's fine to use as a single source of doc when you're online, but don't trust it for offline use. Use something like [Zeal](https://zealdocs.org/) (desktop app) instead.", "id": "dapo1y6"}, {"comment": "You have to explicitly enable offline mode, and then enable each package you want to have downloaded for offline mode. ", "id": "dapr7lb"}, {"comment": "That's what I did. And it worked when I tested it by disconnecting the wifi and restarting the browser. But when I needed it a week later, it didn't work.\n\nI did not clear my history, or cookies, or whatever.\n\nI think web tech is just unreliable for offline work. It's not what it's intended for.", "id": "daptgs5"}, {"comment": "Oh yea I dunno about that then, worth investigating. I mean I looked into the source and it's just dumping everything into local storage which is kinda... weird...", "id": "daptqt4"}, {"comment": "Offline mode for websites stores it in cache which expires. Google Docs has the same problem on Chromebooks despite enabling offline mode. If you go some time without logging in or visiting the docs site, you lose the offline version. The internet is down at 3am which is common with Comcast, you're bored, and think *\"I'll revisit some notes I typed on my Chromebook last month\"*... nope.\n\nIt's not hard to make a Chrome App with all the html/css/js code you need right there stored locally. Not sure why Google doesn't do that for docs.", "id": "daq3vgi"}], [{"comment": "no java, no scala...", "id": "dapzahb"}]]], "5g8wg9": ["Macros: the Red language way", "2016-12-03 12:48:12", 65, "http://www.red-lang.org/2016/12/entering-world-of-macros.html", [[9, "As a fan of Rebol I was really excited about Red when it was first announced and I have been watching its progress for the last few years. But I'm starting to get a little nervous. After so many years, and despite  steady progress, it's not even close to bootstrapping (it still relies on Rebol2.) This itself isn't a bad thing, but it hints at the complexity of the project... and I don't think I anyone needs yet another highly complex language/toolchain/runtime. Is this feeling unjustified? Is the complexity only temporary?\n\nGreat work on the macro system!"], [5, "Congrats to the Red team. I've been steadily watching this project. If it ever accomplishes all its goals, I can't help but think it'll have a big impact. Finally a high-level language I can compile without the garbage of a massive run time and 2 GB installer. The Visual Studio IDE has got to be many times the size of this project."], [2, "I like macros, enough that I [used them as examples in an essay I wrote](http://www.zerobugsandprogramfaster.net/essays/6.html).\n\nThe main difficulty is that they can be difficult to debug, since their output is largely free-form, you can produce anything, and it's often hard to figure out where the original error came from.\n\nBecause of this, I prefer not to use them in serious projects (with multiple people, or projects that are long enough that I might forget what I did six months earlier). \n\nAny innovation in macro processing should be done in debugging them, and it would be welcome because of their power. \n\n"], [1, "First time I heard of this language and the title perked my interest as I am currently studying Lisp macros. Looking at the code samples, it reminds me a little bit of Elm. How does Red compare to functional languages like F# (and Racket maybe)?"]], [[{"comment": "As a fan of Rebol I was really excited about Red when it was first announced and I have been watching its progress for the last few years. But I'm starting to get a little nervous. After so many years, and despite  steady progress, it's not even close to bootstrapping (it still relies on Rebol2.) This itself isn't a bad thing, but it hints at the complexity of the project... and I don't think I anyone needs yet another highly complex language/toolchain/runtime. Is this feeling unjustified? Is the complexity only temporary?\n\nGreat work on the macro system!", "id": "daqf7t6"}, {"comment": "> After so many years, and despite steady progress, it's not even close to bootstrapping (it still relies on Rebol2.)\n  \nRed is pretty much capable of bootstrapping itself ( https://gitter.im/red/red?at=583c161a8255fe6b76d99654 ,  \nhttps://trello.com/c/zUiFKF8B/159-0-9-5-port-the-toolchain-to-red-if-time-permits ) , it is just that due to less time (lots of features to be added) and few developers, bootstrapping has a low priority.\n    \n    \n> highly complex language/toolchain/runtime\n  \nTo minimize time taken to develop the current compiler (written in rebol) which would be thrown away once bootstrapped, the current toolchain was written quickly and hence is a bit complex. \n  \nThe toolchain and compiler will be rewritten during the 1.x cycle. That toolchain will be highly modular thereby reducing complexity.\n  \n  \n  \nBesides the runtime is already written in R/S and accounts for about 75% of the code, the compiler written in rebol is only about 25% of the code. (IIRC, dockimbel said this once.)", "id": "daqfmn0"}, {"comment": "(Author here) FYI, the whole toolchain (Red compiler, Red/System compiler and the linker) weights about 17k sLOC (23k LOC) and the runtime library is ~57k sLOC. The whole codebase zipped is 1.2MB. Compared to most other programming tools or even apps, that's extremely small, and not the sign of a complex system, especially given the insane amount of features packed there.", "id": "daqgrxx"}, {"comment": "> especially given the insane amount of features packed there.\n\n*This* is one sign of a complex system ;-)", "id": "daqjsmc"}, {"comment": "Richness of features is not complexity. A mechanical watch is a complex system, a swiss army knife is not.", "id": "daqm2fi"}, {"comment": "That's an unfortunate analogy to make :). While Swiss army knives look cool but they're actually pretty terrible knives. If you're unlucky enough to jam the mechanisms, perhaps by get it a little muddy, or bending one of those blades, all you'll end up with is a fishing weight. This is further compounded by the fact that the hinges often become loose and begin to wobble under normal use.\n\n> Richness of features is not complexity.\n\nIt's all relative. More \"features\", more bugs. If you want a good knife that you can rely on and that will last you a life time, then you want one with a fixed handle. You wont have a lot of gimmicky features, and it might not make the best saw, but then neither will your Swiss army knife. Which is more complex QED.", "id": "daqoyak"}, {"comment": "What if it was a formally verified Swiss army knife?", "id": "dar4v9b"}, {"comment": "True, but I'd rather have a bunch of well written built-in libraries than have to write my own everything and google for a module. Think writing a GUI in Perl. There are 9 different 1/2 solutions that are mostly not supported. Python has Tkinter which has little doc and the doc that exists is very limiting (also requires a ton of code for just a form with a button and text box). I'll take the overall complexity of the built-ins any day if I can write an app for a coworker, compile it, and then hand them an .exe without them having to install a bunch of junk. Your point is valid though lol ;).", "id": "daqkole"}, {"comment": "On the other hand, a paucity of features requires a re-implementation of at least some of them in every user's program. \n\nIn some languages, though, that is the whole philosophy.\n\n", "id": "darklo3"}, {"comment": "Would an independent branch to rewrite the current src in Red (starting from a snapshot at some point in time and not keeping up with the main branch until it's done) be of interest/benefit to the project given its current plans?", "id": "daqj9o6"}, {"comment": "This is not needed, Red can run the current toolchain code written in Rebol2, almost unchanged. We just lack a few minor features in order to switch it to Red. Those will be added in the next milestones.\nFor Red 2.0, we plan a full rewrite of the toolchain in order to unroll our target architecture (not doable during bootstrapping), including a JIT compiler and a highly modular compiler with a public API. Basically, the toolchain will become a framework, not dissimilar to LLVM, just about one order of magnitude smaller.", "id": "daqmaa5"}, {"comment": "I can\u2019t imagine that you have worked on many tool chains if you think that red is complex.  Red is taking so much time because it is a monumental effort by very few people.  Most new languages nowadays ride on top of some vm so that the language can be quickly created; red is very rebellious just like its ancestor rebol, it is an attempt to reboot software development itself.  Not only do most languages use existing tools for their implementations but most successful languages are also developed by large teams with good funding.  The red team does not have any of these luxuries and yet they have gotten this far. At this point, I would imagine that you would have more faith in their abilities, not less.", "id": "daqj53l"}, {"comment": "If you look at posts from dlyund you'll see he is a FORTH guy (although he's proficient with a number of languages), so his entire compiler, interpreter, editor, everything is probably in a few kB. Of course that isn't the fairest comparison because I doubt his system has some of the Red features of DRAW and all the REBOL dialects. He's also all for eliminating complexity of the entire system if that makes sense (from what i can tell).", "id": "daqkwq6"}, {"comment": "I see, I guess I should have given some effort to understand where he was coming from instead of assuming. It is too easy to assume something and then, give an answer(that is why I like math =))", "id": "daqlv96"}, {"comment": "> At this point, I would imagine that you would have more faith in their abilities, not less.\n\nYou may think that but as someone who's worked on programming languages and their implementations professionally, I'm wondering why it's taking so long to do something a basic as bootstrapping. I'm worried because I know how easy it is to bootstrap a well designed language; and how hard it can be to bootstrap a poorly designed one [0]. Red has been in development for years and it still relies on Rebol2 to function? This isn't a priority?\n\nRed is an open source language that requires proprietary software to run... Red is an open source language which aims to be efficient and suitable for systems programming but needs a slow, interpreted language to function?\n\nThis isn't a priority?\n\nSpeaking for myself, and as someone who's worked on and bootstrapped a number of languages I just can't trust languages that can't build themselves. Bootstrapping is a basic sanity check. The ease and quality of the bootstrap say a lot about the language foundations.\n\nTo be clear, I'm not trying to bash Red here, I'm just posting some concerns, with the hope that somebody in the know can explain what the problem is and why they think that cross platform graphics libraries and macro's are more important than completing the basic bootstrap? I suspect that there's a bit more to it than not thinking that this is important. Maybe the runtime isn't stable yet?\n\n> Red is taking so much time because it is a monumental effort by very few people. \n\nThis tells us much more about the language than you might think it could.\n\nI've spent the last few years working at a company on and in a Forth-like language designed for data acquisition, storage, and processing. The initial bootstrap was the work of one person and took about a week. The base system, including assembler, compiler, linker, interpreter, editors and debugger, easily fits into the allotted 4K words, and deployable programs are often much smaller than this.\n\nNow getting the system to this state took several years of constant refinement. Not all of this was implemented in a week! On the other hand, the initial bootstrap, which allowed the system to become self hosting took one person about a week to complete. The language is now on it's 7th major revision. As part of developing the system, and applications, the language is bootstrapped many times a day [1].\n\nSo if Red hasn't been bootstrapped in after 3 years of development by a team of people I have to wonder - why not?\n\nI'll grant that Forth and Red/Rebol are very different languages, and I never expected the bootstrap to happen overnight, but according to the roadmap, progress on self-hosting is at 0%?\n\nI still think Red is a great project and I'm really looking forward to the end result! :-) I was hoped for some more information.\n\n[0] I'm not implying that Rebol or Red are badly designed! :-)\n[1] This is facilitated by the fact that our compiler can compile millions of LOCs a second so bootrapping/rebuilding is *instant*.", "id": "daqnn0s"}, {"comment": "> Red is an open source language that requires proprietary software to run... Red is an open source language which aims to be efficient and suitable for systems programming but needs a slow, interpreted language to function?\n> This isn't a priority?\n\nAt this point, Red isn't terribly usable, so I wouldn't worry about it too much. The REBOL 2 dependency will eventually go away, when the time comes.", "id": "daqrw1w"}, {"comment": ">Forth-like language designed for data acquisition, storage, and processing. The initial bootstrap was the work of one person and took about a week\n\nForth is designed to be easily bootstrapped like that, so it's not surprising it went quickly. ", "id": "daqxmtt"}, {"comment": "I'm honestly not sure what your point was there?\n\n\"Forth\" is a family of languages with as many dialects as there are implementations. Some implementations are easy to bootstrap, while other's are written as a one off, and no attempt is made to make them self-hosting. As that old adage about Forth goes - if you've seen one Forth, you've seen one Forth. It's certainly possible to design a Forth which is a pain in the ass to bootstrap, and the design of a meta-compiler is something of an art.\n\nYour comment implies that all Forth's are the same and this is absolutely not true.\n\nUnfortunately you're unlikely to find a half decent Forth implementation with a meta-compiler and or target-compiler outside of commercial implementations these days, and you're not likely to get the source code.\n\nOne of the biggest issues facing the Forth community is that the development of Forth went underground with the completion of the ANS Forth standard in 1994. Two decades later almost every company using Forth in industry has their own implementation and the handful of barely usable free and open source implementations are not at all representative of modern Forth.\n\nSince Forth, and the Forth community, is relatively self-contained it doesn't have much need to interact with the outside world... there's a vast amount of knowledge and technology that isn't publicly available.\n\nIt may be fairer to say that while *implementing* a toy Forth is spectacularly easy, implementing and *bootstrapping* a practical Forth system isn't. When people mess around writing their own Forth (or Lisp!) implementation they very rarely get as far as doing things like designing meta-compilation processes, and that is a real shame. It's a lot of fun, and it's very simple; once you know how, it can be called easy.", "id": "daqzg8r"}, {"comment": ">The initial bootstrap was the work of one person and took about a week. The base system, including assembler, compiler, linker, interpreter, editors and debugger, easily fits into the allotted 4K words, and deployable programs are often much smaller than this.\n\nSounds very interesting, is very any information about this project available for public?", "id": "daqxs0h"}, {"comment": "There will be an open source release. When is hard to pin down and I'd like to avoid disappointment, so let's say it will be available to the public sometime within the next year. I believe there will be some pre-releases, for testing, to weed out any problems before making it available to the wider public. If you're interested in being part of that, send me a PM and I'll add you to the list.", "id": "daqzx10"}, {"comment": "In general, implementation language and implemented language may have very different objectives, e. g. implementation language could be well suited to process ASTs and IRs and implemented language be intended to produce highly efficient numeric processing machine code.\n\nBut in the Red vs Rebol case we have 2 language declared to be very close, yet Red still isn't bootstrapped. In this case I tend to agree with you, and this make me think that either Red has problems, or its creators have a very different view on what is important and when, or both. Neither option looks particularly encouraging.", "id": "darpfgm"}, {"comment": "bootstrapping too soon is also a problem. I don't remember where I read that when bootstrapping the developers start to focus in the things that make build compiler easy and put other features aside. \n\nAfter reading about compilers for more than a year, is start to be obvious that you can make a compiler with anything (yikes, even js!) so if Rebol want a shoot I think better focus is some more useful things for the users.", "id": "daqiqos"}, {"comment": "> when bootstrapping the developers start to focus in the things that make build compiler easy and put other features aside.\n\nThat may be true when you're designing a new language from first principles. Since Red is building on a well designed, understood, and practical language,  that shouldn't be a concern to anyone :-). There will certainly be areas where Red and Rebol diverge but at it's core, the two languages are almost identical.\n\nIndeed one would think that this would make bootstrapping Red relatively easy. There fact that (according to the roadmap) there's been zero progress in this area so far implies that it's not so trivial. Why isn't this trivial? What is stopping the system from being bootstrapped?\n\nOne of the biggest problems for Rebol was that it was comparatively very slow. When Red was announced this was highlighted as one of the problems that Red was going to solve. I fail to see how they can achieve this as long as they continue to rely on Rebol2 to run the thing.\n\nConversely, you don't want to leave it too long to bootstrap or you could find that you've built a language which can't easily, or efficiently, be bootstrapped. Smalltalk is a fantastic example of this.\n\nSmalltalk was bootstrap once upon a time, but all of the available free and open source, and commercial implementations today have lost the ability to boostrap. This is absolutely insane. When you can't bootstrap from source you're saying that the description of the system is incomplete; the description is missing something. If you can bootstrap then you've proven the description is complete/sufficient. It's the base-line; *the* sanity check.\n\nIn the case of Red what's missing from the description of the system is Rebol2.\n\nRebol2 which is only available as a binary, and under a proprietary license, and is required to do anything with Red?\n\nIn the case of Smalltalk there have been numerous efforts in the past decade to bootstrap the system. They can't do it. As a result Smalltalk programmers are unable to build a clean version of their system and have to resort to ad-hoc scripts that \"strip\" the system image to deploy applications...", "id": "daqll96"}, {"comment": "\"When Red was announced this was highlighted as one of the problems that Red was going to solve. I fail to see how they can achieve this as long as they continue to rely on Rebol2 to run the thing.\" - this just shows, that you might not properly understand Red's architecture and what is Rebol 2 actually used for.", "id": "daqmcyl"}, {"comment": "> that you might not properly understand Red's architecture and what is Rebol 2 actually used for.\n\nI might well not, but please enlighten me/us! :-)", "id": "daqnv75"}, {"comment": "> One of the biggest problems for Rebol was that it was comparatively very slow. \n\nWhen I hear people say that speed was a problem I often wonder what they were doing with R2. I only ever had a couple scenarios where R2 was too slow. Of course, it can't do everything well. :-)\n\n> When Red was announced this was highlighted as one of the problems that Red was going to solve. I fail to see how they can achieve this as long as they continue to rely on Rebol2 to run the thing.\n\nR2 is only used today to build the Red binary. Once you have that, Red does everything else without any need for R2. So, today, if you use a prebuilt Red binary, R2 need never darken your doorstep. The entire toolchain, including Red/System, the cross-compiler, and the high level runtime, are all included in the single Red EXE. \n\nHow this addresses speed, if that's an issue, is two-fold. Actually three-fold now that Red has macros.\n\n1. Native code compiler\n2. Red/System C-level dialect\n3. Compile time macros", "id": "daqxdts"}, {"comment": "If you look at a post or two from me on the Red programming sub-reddit, you'll see I asked the same question and got a similar reply. You can look there for more details. There isn't many posts, so you could probably find it fast. I think I made a comment saying they should spell that out somewhere to eliminate precisely this confusion as I was thinking along the same lines as you.", "id": "dar32vp"}, {"comment": "First, let me say that your feelings can certainly be justified. We've all seen projects fail, and complexity is often to blame. As has been mentioned here, complexity is relative. Sometimes we just push it around. Being dependent on a single, external EXE doesn't ring as terribly complex to me and, as DocKimbel said, that can be addressed without great difficulty at this point.\n\nI love the Forth model, of building the language on a small number of primitives, but could never get into Forth for my daily work. We each have different likes and needs. I still think it would be fun, and instructive, to have a Forth back-end target for Red, but I haven't identified a subset of Red that could be dramatically simplified while still giving me all the features I want. I came to Red from Rebol, and always knew there was a cost for what the languages provide. Red adds new goals. Maybe not all important to me, but important to the designer, team, and/or investors.\n\nI think Team Red is doing a good job of balancing what features to include, the cost/benefit of each, and when to remove the R2 dependency. They also focus on keeping things stable and, all important to me, the conceptual integrity of the project. For me, Red is not complex *given the functionality it provides*, and I'd be hard pressed to choose what to remove at this point, for my uses. While Red may be able to simplify some things without removing features, I don't know that those reductions will be great.\n\nThat's a long way of saying, to me, that Red's goal is to keep things as simple as possible while providing the features deemed important; not to be simple at all costs. Is there risk with trying to do more? Of course. But I have a great deal of confidence in the team.", "id": "daqwz1d"}, {"comment": "You may want to check out [Code Valley](https://codevalley.com). Red says \"it shifts some data and transformations from run-time to design-time.\" Code Valley goes even further: it is like a system for decentralised programmable macros (called 'Vendors'), that, when engaged, come together to form a custom, 'decentralised compiler' that returns an output executable. The 'compiler' disappears as soon as the executable is returned.\n\nEach time a Vendor is engaged, its developer-owner receives a small micro-payment, and Vendors can be a 'part' of many decentralised compilers at once. The better the Vendor (relative to its competitors), the more times it will be selected. \n\nThe project itself has been in development for over a decade, but it is up and running. You can see a snapshot of the current state of the system (i.e. number of Vendors, total contracts, total builds) [here](https://marketplace.codevalley.com). \n\nYou can actually *use* the system [here](https://marketplace.codevalley.com/use-it). If you pick it up quickly, you may want try your hand at joining the other side and becoming a Vendor builder. \n\nDisclaimer: I've been part of the Code Valley team for the past three years now. If you have any questions at all, please don't hesitate to ask. It's pretty cool stuff! (But yes, I'm biased.)", "id": "dar91qd"}], [{"comment": "Congrats to the Red team. I've been steadily watching this project. If it ever accomplishes all its goals, I can't help but think it'll have a big impact. Finally a high-level language I can compile without the garbage of a massive run time and 2 GB installer. The Visual Studio IDE has got to be many times the size of this project.", "id": "daqkimb"}, {"comment": "Don't most compiled high level languages have pretty small runtimes? Rust, go, comes to mind. ", "id": "dar00e0"}, {"comment": "Don't forget C.", "id": "dar17ot"}, {"comment": "Some, yes. Rust and Go are both 60+M downloads, while Red is ~1MB and is a single EXE. I *think* Go cross compiles since 1.5, but I don't know about Rust. I don't know about GCC. Once you use any of them, as system level languages, there shouldn't be any required runtimes, same as Red/System.\n\nDifferent states of maturity in various areas, e.g. dependency management. Red is still young in many ways, and being carefully planned to stay small.", "id": "dar2bue"}, {"comment": "Go and rust are also single binary files. They may not be officially, but they can surely be statically compiled to fit this purpose, and both take up mess than 30MB. Still may be a lot more than red, but I'm not familiar enough with red to determine if that even means anything. Either way, size isn't everything :) ", "id": "dar4ji1"}, {"comment": "Size is not everything, agreed. But I also agree with @dlyund that size and complexity can be related. And a 10x-60x reduction is, at least, very nice. :-)", "id": "dar8svm"}, {"comment": "Rust is far more low level than what I have in mind as is Go. When I say \"high\", I mean Python, Ruby, Rebol...etc.", "id": "dar2gj4"}, {"comment": "Do you mean dynamic? Go is a little limited, but with garbage collection, concurrency abstractions, and their particular brand of duck-typed interfaces, I don't think I could claim it isn't high-level.", "id": "dar41r2"}], [{"comment": "I like macros, enough that I [used them as examples in an essay I wrote](http://www.zerobugsandprogramfaster.net/essays/6.html).\n\nThe main difficulty is that they can be difficult to debug, since their output is largely free-form, you can produce anything, and it's often hard to figure out where the original error came from.\n\nBecause of this, I prefer not to use them in serious projects (with multiple people, or projects that are long enough that I might forget what I did six months earlier). \n\nAny innovation in macro processing should be done in debugging them, and it would be welcome because of their power. \n\n", "id": "daqxiwf"}, {"comment": "Macros are easier to debug than anything else, at least in Lisp-like languages, cannot say anything about Red which I am only about to try out now. \n\nFew tips:\n\n1) Review the generated AST in all stages. Do not forget to implement or infer pretty-printing, it's cheap.\n\n2) Make your code generation stages *small-step*. Really small. The smaller - the better. Just the same advice as with any other compiler, really, because this is what macros are - *compilers*.\n\n3) Add an ability to embed debugging markers and logging implicitly. Design your intermediate ASTs accordingly, to leave space for such markers.\n\n4) Do not destroy the source location information and preserve it in all the lowering steps.\n\nI never had any issues with debugging macros, and I'm using macros for pretty much *everything* I do.", "id": "dar066q"}, {"comment": ">I'm using macros for pretty much everything I do.\n\nWhat macro language are you using?", "id": "dare8f2"}, {"comment": "Any that supports proper, Common Lisp-style macros.", "id": "darnu1c"}], [{"comment": "First time I heard of this language and the title perked my interest as I am currently studying Lisp macros. Looking at the code samples, it reminds me a little bit of Elm. How does Red compare to functional languages like F# (and Racket maybe)?", "id": "daqigog"}, {"comment": "It is hard to compare Red to functional languages, languages that are highly opinionated about how one should write code. Red is more akin to Common Lisp than it is to most other languages. However, it does not contain the historical cruft that Common Lisp inherited throughout its development process. I would say that Red emphasizes the ability for programmers to express themselves; the expressiveness of the language is the paramount tenet, everything else is secondary.", "id": "daqjfzk"}, {"comment": "> Red is more akin to Common Lisp than it is to most other languages. However, it does not contain the historical cruft that Common Lisp inherited throughout its development process.\n\nI would say it has way more in common with REBOL, because it's directly inspired by it, and it doesn't contain the historical cruft of REBOL.\n\nAs REBOL isn't such a well known language, the comparison to Lisp may make more sense to those not in the know, but Red is much, much less inspired by Lisp than by REBOL.", "id": "daqrs8v"}, {"comment": "To add to Jacob's comment, I often think of Redbol langs as language construction toolkits. That said, where Elm has a specific design goal, and Red is great if you want to write DSLs, or even just be able to express intent more clearly in an app, it is a truly general purpose language.", "id": "daquqek"}]]], "5fks83": ["Building native macOS applications with Rust", "2016-11-29 22:46:11", 100, "https://blog.bugsnag.com/building-macos-apps-with-rust/", [[-2, "One comment but nothing here, looks like someone is shadow banned. "]], [[{"comment": "One comment but nothing here, looks like someone is shadow banned. ", "id": "dam2jso"}]]], "5fs4kf": ["Build a media library with React, Redux, and Redux-saga", "2016-11-30 23:56:51", 0, "https://scotch.io/tutorials/build-a-media-library-with-react-redux-and-redux-saga-part-2", [], []], "5fzk2q": ["What you don\u2019t know about web development", "2016-12-02 01:12:48", 2, "https://hackernoon.com/what-you-dont-know-about-web-development-d7d631f5d468#.dwjbhcpy1", [], []], "5ges43": ["what programming language should i start to learn?", "2016-12-04 12:49:33", 0, "http://pastebin.com/tEnjTMKW", [[3, "Python "], [3, "Python.\n\nP.S.: Why the pastebin.com link? Even text posts will now get you karma."], [2, "QBasic"], [1, "Usually, which programming language to learn depends on what you want to do. [Python](https://learnpythonthehardway.org) has gained a reputation of being easy to learn for beginners. If you want to do web development, JavaScript is the way to go. For app development (not advisable for beginners), learn Java or Swift."], [1, "Read about multiple languages and later you will be able to pick one that you like.\n\n(I started with BlitzMax)"], [1, "C#"]], [[{"comment": "Python ", "id": "darode7"}], [{"comment": "Python.\n\nP.S.: Why the pastebin.com link? Even text posts will now get you karma.", "id": "darp240"}], [{"comment": "QBasic", "id": "daro7ac"}, {"comment": "well i was going to use codeacademy but QBasic is not on their tutorial list, is there a site, video or anyplace else to learn QBasic?", "id": "daro9hw"}, {"comment": "Just a heads up, that was a sarcastic answer.", "id": "darpojo"}], [{"comment": "Usually, which programming language to learn depends on what you want to do. [Python](https://learnpythonthehardway.org) has gained a reputation of being easy to learn for beginners. If you want to do web development, JavaScript is the way to go. For app development (not advisable for beginners), learn Java or Swift.", "id": "daroenj"}, {"comment": "python seems like the one to go", "id": "daroh9e"}], [{"comment": "Read about multiple languages and later you will be able to pick one that you like.\n\n(I started with BlitzMax)", "id": "daropat"}], [{"comment": "C#", "id": "darq5wp"}]]], "5g6s23": ["Vue.js Internals: How computed properties work", "2016-12-03 03:14:50", 20, "https://skyronic.com/blog/vuejs-internals-computed-properties", [[3, "I wrote this post :) Let me know if you have any questions/feedback!"]], [[{"comment": "I wrote this post :) Let me know if you have any questions/feedback!", "id": "daq85px"}]]], "5g3vlb": ["Software engineers should write", "2016-12-02 18:38:34", 0, "http://www.shubhro.com/2014/12/27/software-engineers-should-write/", [[1, "The argument I have for this is we simply don't have time. \n\nFor example I work with an engineer that was French most of his life and moved to the US. Our CEO and CTO believe that the engineer who writes the code should also write the engineering report because good programmers should be able to write perfectly as well. We stood up around 5 semantic services (microarchitecture style project) in approximately 3 months. The engineering report took the author roughly 2 weeks to properly detail and had roughly about 300 pages in length and required the proof reading and corrections of an additional two engineers. I do feel it's fair to add that his English was extremely proficient but his writing skills left something to be desired, so both those engineers were completely warranted. \n\nDuring that two weeks document, I started seeing our project manager start following up on his weekly ticket progress reports only to see none of the engineers involved tickets progressing. Suggesting that they should be working on the engineering report in their spare time in order to not let their technical duties fall to the wayside. \n\nSo if you follow this line of logic to its conclusion, your going to add an insurmountable amount of work to an engineer's plate that takes away from development time and starts putting more time towards documentation and even business proposals where we need to dum down the language and \"tech speak\" in-order for it to even be usable by the perspective business audiences. It's just not practical.  "]], [[{"comment": "The argument I have for this is we simply don't have time. \n\nFor example I work with an engineer that was French most of his life and moved to the US. Our CEO and CTO believe that the engineer who writes the code should also write the engineering report because good programmers should be able to write perfectly as well. We stood up around 5 semantic services (microarchitecture style project) in approximately 3 months. The engineering report took the author roughly 2 weeks to properly detail and had roughly about 300 pages in length and required the proof reading and corrections of an additional two engineers. I do feel it's fair to add that his English was extremely proficient but his writing skills left something to be desired, so both those engineers were completely warranted. \n\nDuring that two weeks document, I started seeing our project manager start following up on his weekly ticket progress reports only to see none of the engineers involved tickets progressing. Suggesting that they should be working on the engineering report in their spare time in order to not let their technical duties fall to the wayside. \n\nSo if you follow this line of logic to its conclusion, your going to add an insurmountable amount of work to an engineer's plate that takes away from development time and starts putting more time towards documentation and even business proposals where we need to dum down the language and \"tech speak\" in-order for it to even be usable by the perspective business audiences. It's just not practical.  ", "id": "daricvl"}]]], "5fwo30": ["Fluent DSL for querying spring data JPA repositories using spring data Specifications, without boilerplate code or a generated metamodel.", "2016-12-01 16:56:23", 0, "https://github.com/consoleau/kotlin-jpa-specification-dsl", [], []], "5g2vj1": ["Explanation of everything you can see in htop/top on Linux", "2016-12-02 14:53:35", 29, "https://peteris.rocks/blog/htop/", [[5, "htop is so good, I install it on all my Linux systems now. It's just easier to read than top."], [2, "Good article, well done!"], [2, "I like that the article manages to perfectly balance simple explanation and technical depth; good read!"], [2, "Love htop.\n\nI like to use this alias to remove the junk info:\n```\nalias htop='htop --user=$(whoami) --sort-key=PERCENT_CPU'\n```\n\nYou can go in Setup (F2) and hide threads too, to further unclutter."]], [[{"comment": "htop is so good, I install it on all my Linux systems now. It's just easier to read than top.", "id": "dapkkhc"}, {"comment": "Written by the original creator of GoboLinux!\n\nYou know where something pretty originated - within better ideas. :)\n\nLucas and hisham are slowly bringing GoboLinux up to \"modern standards\" - anyone who wants to help is surely very much welcome. (I myself am sitting in the fate of lack-of-time sorta but GoboLinux is still my favourite distribution by far.)", "id": "daqjvkr"}], [{"comment": "Good article, well done!", "id": "dap9kxa"}], [{"comment": "I like that the article manages to perfectly balance simple explanation and technical depth; good read!", "id": "dapfime"}], [{"comment": "Love htop.\n\nI like to use this alias to remove the junk info:\n```\nalias htop='htop --user=$(whoami) --sort-key=PERCENT_CPU'\n```\n\nYou can go in Setup (F2) and hide threads too, to further unclutter.", "id": "dapnuho"}]]], "5g9q2h": ["Make Phone Calls with Crystal and Twilio", "2016-12-03 17:15:14", 2, "https://www.twilio.com/blog/2016/12/make-phone-calls-crystal-twilio.html", [], []], "5g39y3": ["Martin Fowler - FunctionLength", "2016-12-02 16:36:01", 84, "http://martinfowler.com/bliki/FunctionLength.html", [[63, "Deep nesting is what gets you, not function length per se. If you can write a long, flat function that does a single logical unit of work and bits of it don't have to be reused, go with it. I find it much easier to understand code like that than to jump between dozens of small functions in order to get a slight idea of what is actually being done in the code."], [10, "Another reason I split code into sensibly sized, does-one-thing functions, is that when something fails I can zero in on the exact function causing the problem.  Code re-use is interesting in the abstract; in practice, having functions which handle exactly one task makes it easy to find and fix problems.  If you look at long meandering functions you'll often find multiple places it can fail from a single cause.  (and usually cut-n-paste code is the reason.)"], [7, "To my mind, it's about the mental load of jumping up and down the ladder of abstraction. Completely contrived example:\n\n    var thing\n    for each (item in container)\n      if (item.something = parameter)\n        thing = item\n        break\n     thing.frobbleStuff\n     if (thing.canDrong)\n      thing.drong(otherThing)\n\non a higher level of abstraction, this is\n\n    thing = getThing(container, parameter)\n    thing.doStuff(otherThing)\n\n(Or you can make it a one-liner, whatever).\n\nThe first manner forces your brain to descend down the abstraction ladder for the first \"logical\" block (search), go up, then descend down again for the second.\n\nUnless you need to know details of those, this up-down travel is a wasted brain power.\n\nNow... some people (here included) argue that they need to know the details much of the time, and the above isolation of parts hides that. To that, I  say: a person can juggle a limited amount of detail (5-6 things) in their head at one time, that's in cognitive science. So no, not only you don't need to know these details, you also don't really know them. You are in fact constantly, subconsciously, pushing some to light, and others back, as you go along the code like my first example.\n\n\n     \n      "], [4, "Splitting up a function into tiny logical units might seem like a sensible idea during development but can turn into a debug and maintenance nightmare later on. I'd thus tend more towards favoring the \"re-use rule\", although this of course always depends on the individual situation."], [0, "> Any function more than half-a-dozen lines of code starts to smell to me\n\nAnd here we go again with the dogma. Didn't we already decide that was a bad idea ten years ago?\n\n> Some people are concerned about short functions because they are worried about the performance cost of a function call. \n\nThat's the least of my concern.\n\nThe main problem with functions that only contain a handful of lines is spaghetti code.\n"], [-1, "Well put, sir!\n\nNow, this appears to be at odds with what all the \"cool kids\" are doing, which is to use lambdas to avoid having to come up with names for things that should probably be functions.  "], [-24, ">If you have to spend effort into looking at a fragment of code to figure out what it's doing, then you should extract it into a function and name the function after that \u201cwhat\u201d\n\nYou should create a new function if you're going to use that block of code in multiple places. You shouldn't create a new function if you just see some code you don't immediately understand. You can put a comment at the top of block of code explaining what it does instead of a creating a new useless function.\n\n>Once I accepted this principle, I developed a habit of writing very small functions - typically only a few lines long [2]. Any function more than half-a-dozen lines of code starts to smell to me, and it's not unusual for me to have functions that are a single line of code\n\nWhat a fucking shit idea. I hope I never have to work on the same codebase as this guy\n\n>Some people are concerned about short functions because they are worried about the performance cost of a function call.\n\nNo, I'm worried that retards like you don't care about the mental costs that come with creating new functions for no reason. Instead of just reading code, now I have to jump around, wonder where the function gets called, under what conditions it can be called in, what it returns, etc. It's just extra effort you've made me waste because you think it's better to create new functions all the time than to just put a single comment explaining what the block of code does.\n\n\n\nIt's no wonder no one can write software when supposed \"gurus\" are giving advice of this quality. Just kill me "]], [[{"comment": "Deep nesting is what gets you, not function length per se. If you can write a long, flat function that does a single logical unit of work and bits of it don't have to be reused, go with it. I find it much easier to understand code like that than to jump between dozens of small functions in order to get a slight idea of what is actually being done in the code.", "id": "dap5miq"}, {"comment": "Well, if you've named the functions properly then you wouldn't have to jump into the function to see what it does.", "id": "dap9cwy"}, {"comment": "I used to think that, before I watched other programmers try to debug my small functions.\n\nTo debug effectively, one needs to step through _everything_ that gets executed between \"known good\" and \"known bad.\"  My experience indicates people have an easier time of that, if there are fewer larger functions.\n\nGetting beyond 3 calls deep starts spilling things out of my head. 5 deep is pretty heavy, especially considering the exponential nature where each function tends to call 2-3 more functions each. Five layers can be 30 functions.  But most other people I've worked with seem to think 3 layers of calls is almost impossibly tangled.", "id": "dapc3bv"}, {"comment": ">To debug effectively, one needs to step through everything that gets executed between \"known good\" and \"known bad.\"\n\nI'm not sure that's true, the only times I've had to step through everything when the logic is terribly bad and filled with lots of side-effects or doesn't have any debugging/logging of its own. In Lisps I've rarely had to debug and when I didn't really have to step through everything, the same has been true of C/C++ and Java and Python. With Ruby and JavaScript however, and with PHP, it feels like there's been a need to step through everything. It could be be cause of the lack comments, poor function naming or some other reason but you shouldn't have to rely on a debugger to figure out what's between known good and known bad.", "id": "dapgigs"}, {"comment": "> I'm not sure that's true, the only times I've had to step through everything when the logic is terribly bad and filled with lots of side-effects or doesn't have any debugging/logging of its own.\n\nSounds like 98% of the production code I encounter.", "id": "dapkg7y"}, {"comment": "I'm working in JavaScript and PHP these days.\n\nAnd by \"step through\" I meant 'read through', looking for the places where what the code says is diverging from what was expected.  After all, if I knew what the cause was, I'd go straight to implementing the fix.\n\nBut reading the code also turns out to be relevant for making changes.  If I don't understand what's there and won't call it, I'm left with re-implementing everything from scratch.", "id": "daplc22"}, {"comment": "I think it's all a manner of your own personal process for eliminating possible causes of a bug. Personally, I quite like how easy it is to examine a small function, determine that it's not problematic, and then very easily portion that off as \"ok\" in my mind. If 4 or 5 smaller functions were instead all crammed into the body of a single top-level method that I'm debugging, I might clear the first fifth but then kind of forget where the first fifth ends and the next fifth begins and start re-examining code I've already proven to be functional. \n\nBut, everybody is different...I can understand how someone might find exactly the opposite to be true. \n\nAs for the \"call depth\" argument...I tend to agree with that, however I think there's a crucial distinction...getting much beyond 3 calls deep *of code that is part of the codebase in question* makes things difficult, but almost nothing is actually that shallow in reality. You're probably calling a method \"bottom level\" when it's only working with the standard library or with some big third party libs...right? That's how I think about it, at least. But I've found that when you partition your own codebases off into smaller libraries or at least logical units, you can start to draw that same line even for code you technically \"own\" *most of the time*. ", "id": "dapvg9h"}, {"comment": "> Personally, I quite like how easy it is to examine a small function, determine that it's not problematic, and then very easily portion that off as \"ok\" in my mind.\n\nIn my experience - often (not necessarily most of the time) the issues are caused by two functions having hidden post/precondiitons that are not satisfied when the functions are used together.\n\n    void TcpSocket::SetNetworkAddress( const std::string& address ) {\n        // 'address' is reference as we don't accept 'nullptr' values here.\n        // Store it as pointer reference to avoid reallocating the string.\n        this->targetAddress = &address;\n    }\n\nAnd\n\n    unique_ptr<TcpSocket> GetSocketForUrl( const std::string& url ) {\n        // Get the 'host' portion of the url.\n        std::string host = GetHostAddressFromUrl( url );\n    \n        // Return a new TcpSocket with the host address set on it.\n        auto socket = make_unique<TcpSocket>();\n        socket->SetNetworkAddress( host );\n        return socket;\n    }\n\n\nBoth functions may check out okay when examined on their own - however when combined together, the `std::string& address` reference given to the `SetNetworkAddress` ends up being a reference to the `std::string host` variable local to `GetSocketForUrl` function. This variable is destroyed at the end of the `GetSocketForUrl` invalidating the address stored in `TcpSocket`.\n\n", "id": "daq68la"}, {"comment": "Screw them. They write code that you can't understand without launching it in a debugger.", "id": "dapf56t"}, {"comment": "> if you've named the functions properly\n\nWell, in my experience thinking of consistent and meaningful names is hard.  ", "id": "dapepgw"}, {"comment": "Other on this thread either have forgotten or not yet learned that naming things is legitimately one of the two hardest problems in computer science (the other of course being cache management and off-by-one errors).", "id": "dapfmlp"}, {"comment": "I dunno there are some pretty hard computer science problems dealing with computational complexity that may be *slightly* more difficult ", "id": "dapqey6"}, {"comment": "Usually those problems have a correct solution - or at least an approximation that gives good results each day.\n\nThe correct solution to \"what should I name this function?\" changes each day. A name that made sense one day tells you nothing the next one when the context in your head is completely different - unless you encode the whole context into the function name:\n\n`LoadRedditCommentsByPostID_DoesNotRequireAuthentication_ThrowsExceptionIfIDIsWrong_IsNotThreadSafe(string id)`\n\nEdit: +`_DateInUTCFormat`", "id": "daq5bhk"}, {"comment": "I'll admit I was being a bit tongue-in-cheek and ignoring the linguistic part of programming language theory, but if you can encode the whole context of a function into the function name then there is a solution, unlike some problems of computational complexity (as far as we know). ", "id": "daq97ux"}, {"comment": "> but if you can encode the whole context of a function into the function name then there is a solution, unlike some problems of computational complexity (as far as we know). \n\nAs I wrote in another comment, that would solve the halting problem in my opinion, which is impossible. \n\nUnless you implicitely assume that every function may or may not terminate, or throw a bug, or execute this or that conditional branch and so on.", "id": "daqgmg6"}, {"comment": "I think \"Giving a function a name that perfectly describes what is does\" can be reduced to the halting problem. There you go, it is even impossible! So we can only approximate. That approximation happens intuitively, and happens faster the more experience a programmer has in naming things.", "id": "daqgl60"}, {"comment": "Naming something is normally pretty easy I find, even though I iterate a few times on many names. Sometimes it is hard, but then you might want to consider splitting things up differently to make the concept clearer.\n", "id": "daqdsf8"}, {"comment": "Sure it is! I spend like 15% -20% thinking about good names of methods, parameters and classes. It pays of so much, since the program does exactly what it says.", "id": "daqgjbn"}, {"comment": "I don't believe it's possible to name things like that. You can't always perfectly, 1-to-1 summarize what function does. If you think you did it, it's an illusion, because you already know what this function does.", "id": "dapgd7f"}, {"comment": "\"This documentation probably makes perfect sense to someone who already understands the system.\"", "id": "dapqqgi"}, {"comment": "Sure in general but `Empty` being `l => l.Count == 0` seems to perfectly summarize what the function does.", "id": "dapwhmg"}, {"comment": "I'd expect trashcan.Empty() to actually empty the trashcan.", "id": "daqf1wn"}, {"comment": "Isn't that why instance methods exist is because Foo() may mean different things based on context?", "id": "dargkxo"}, {"comment": "Code is truth. Identifier names, like comments, are frequently inaccurate.", "id": "daq8g4n"}, {"comment": "Look at this long function. Ugh.\n\n...\n\nLook at the deep callstack for this crash. Ugh.\n", "id": "dapekl6"}, {"comment": "I don't mind a deep call stack. As long as it's not filled with garbage indirection. I worked on a code base once where all the core functionality was called by callbacks to callbacks to callbacks. Someone created this stupid vector of {void *, string} structs for some reason, and then added a record for all the main functions, then they call the functions by a fucking switch on the string (that also modified the string as it was going for another layer of wtf) to get the address to call. For some reason, they thought this garbage reimplentation of function calling was brilliant and used it all over the place, often several layers deep. I almost feel like it was a joke or something started by a disgruntled ex employee.\n\nThe call stacks were absolutely insane, if anything went wrong, all you'd see would be calls to the crap functions that manipulate the function pointers and strings (which all had names like _alias1 or doAction2 or process) because there was like 4 layers of this shit with tons of calls at each step before you get to anything with a meaningful name.", "id": "dapgkv6"}, {"comment": "With a deep callstack you can at least get a better idea of what events lead up to the crash. In comparison, the alternative - knowing it happened somewhere in a 400-line method - is no help.", "id": "dapj32m"}, {"comment": "Eh, if you know what line it happened on, the events that lead to it are in the lines above it.", "id": "daqddcb"}, {"comment": "The problem is when something gives malformed input which causes a crash 5 calls deeper.\n", "id": "daqaxou"}, {"comment": "Why? Just backtrack it then. At least you know it was the malformed input.\n\nHaving many small functions also enables you to write better unit tests, which increases the trust you can put in functions on the callstack and enables you to look to the more untested/suspicious methods faster.", "id": "daqghls"}, {"comment": "I like a well detailed call stack.  It really well describes the flow that got to the line of code.", "id": "daqfnnl"}, {"comment": "I think the basic idea is that unless you need a deep understanding of not only what the code is doing but how it's doing it, you never actually have to dive into those smaller functions. It's a case of optimizing for the common case (reading code to know what it does) instead of the uncommon case (understanding what code does but needing to know *how* it does it). \n\nIt also actually makes the latter *easier* in my opinion (if functions are named and broken up well), because now you can look at a series of steps A -> B -> C -> D, and easily separate the code that shows how A is done from the code that shows how B is done. It only really becomes more inconvenient when you need to know learn how all 4 of those steps are done at once. ", "id": "dapv7fh"}, {"comment": "> jump between dozens of small functions in order to get a slight idea of what is actually being done in the code.\n\nThose small functions should have clear names though. If you have to read a function to know what it does at a high level, it needs a bit of refactoring.", "id": "dapc12v"}, {"comment": "Many times, a small function does something very abstract and context-sensitive, maybe also calling a few other \"small functions\", and, as a result, even a good name doesn't help in understanding what it really does. That only deepens the call graph for no particular benefit. Moreover, what's a good name for you might be an unintuitive name for others.", "id": "dapefl2"}, {"comment": "Can you give an example of this small abstract context sensitive function? I can't think of a good reason for a function to be context sensitive, and doesn't that mean it's less abstract since you care about arbitrary state?", "id": "dapfreu"}, {"comment": "Suppose you have a function named `findValidThresholds` which also calls a few other similarly named functions. Without the context of the caller, how can you know what exactly is a \"threshold\" and what is a \"valid threshold\"?", "id": "dapga13"}, {"comment": "I'd argue that that's a poorly designed function. It should probably be a method on an object so we know what we are finding thresholds for. Additionally, we're missing some info, is this void and presumably setting an object's data or global, or are we returning the valid threshold?\n\nImo, void functions that set globals are a pain in the ass to work with. Managing state shouldn't be such a headache.", "id": "daphkdn"}, {"comment": ">  It should probably be a method on an object so we know what we are finding thresholds for.\n\nI'm pretty sure that everyone in this threads uses `function` and `method` interchangeably.", "id": "dapj0gr"}, {"comment": "> Those small functions should have clear names though.\n\nThen I've never seen a clear name in my life.\n\nIt's really easy to convince somebody that clear names can summarize a function. Of course, in theory, it COULD be possible. But in practice, I've never seen it implemented successfully.\n\nIf you (or somebody else, or Bob Martin) can show me a codebase with names like that, I'm sold. But I don't believe such a codebase exists.", "id": "dapgelr"}, {"comment": "\"Clear names\" are easy to find for embarrassingly real-world stuff such as `paintFenceInYellow()`, not so much for abstract, non-physical, mind constructs.", "id": "daphiiz"}, {"comment": "Hmm, I'm probably biased because I mostly work with representations of real things. (image manipulation, audio, 3d models, customer data, etc.)", "id": "daphrf8"}, {"comment": "I'm working on a software for temporal manipulation, we spent roughly one year in meetings trying to find meaningful names for the objects we were manipulating.", "id": "dapj3ux"}, {"comment": "Interesting, what names did you choose?\n\nAlso, \"temporal manipulation\", when I google it just get Magic Cards. What is that exactly, are you manipulating video, or running some kind of timing software, or what? Sounds super interesting.", "id": "dapk4f6"}, {"comment": "It's a sequencer for interactive media : \n\nwww.i-score.org\n\nFor instance :\n\n* For temporal durations / spans : Time constraints\n* For temporal synchronization : Time nodes\n", "id": "dapkuti"}, {"comment": "awesome.\n\n> open source\n\n> c++\n\n> intermedia sequencer for the precise and flexible scripting of interactive scenarios\n\nThis is highly relevant to an upcoming project I'm planning! Thanks!", "id": "dapmh4p"}, {"comment": "nice :) It's still alpha but we are able to use it in shows; it's mainly lacking polish (and manpower). \n\nFeel free to drop in the chat if you want some help / advice; the logic is very different from other softwares in this category (QLab, etc.)", "id": "dapq2vj"}, {"comment": "DoPageServiceHandlerMemoryAllocationWindowBox", "id": "dapl7cm"}, {"comment": "But any modification like slightly changing what it does when searching for bug cause makes it problematic.", "id": "dap67sc"}], [{"comment": "Another reason I split code into sensibly sized, does-one-thing functions, is that when something fails I can zero in on the exact function causing the problem.  Code re-use is interesting in the abstract; in practice, having functions which handle exactly one task makes it easy to find and fix problems.  If you look at long meandering functions you'll often find multiple places it can fail from a single cause.  (and usually cut-n-paste code is the reason.)", "id": "dappqqs"}, {"comment": "I have a similar mindset. As a class has a single intention, functions should have a single purpose. ", "id": "dapy8ez"}], [{"comment": "To my mind, it's about the mental load of jumping up and down the ladder of abstraction. Completely contrived example:\n\n    var thing\n    for each (item in container)\n      if (item.something = parameter)\n        thing = item\n        break\n     thing.frobbleStuff\n     if (thing.canDrong)\n      thing.drong(otherThing)\n\non a higher level of abstraction, this is\n\n    thing = getThing(container, parameter)\n    thing.doStuff(otherThing)\n\n(Or you can make it a one-liner, whatever).\n\nThe first manner forces your brain to descend down the abstraction ladder for the first \"logical\" block (search), go up, then descend down again for the second.\n\nUnless you need to know details of those, this up-down travel is a wasted brain power.\n\nNow... some people (here included) argue that they need to know the details much of the time, and the above isolation of parts hides that. To that, I  say: a person can juggle a limited amount of detail (5-6 things) in their head at one time, that's in cognitive science. So no, not only you don't need to know these details, you also don't really know them. You are in fact constantly, subconsciously, pushing some to light, and others back, as you go along the code like my first example.\n\n\n     \n      ", "id": "daph71z"}, {"comment": "I agree but your example doesn't fully demonstrate the benefits IMO. The point is to abstract into functional pieces so you obviously know what they're doing. A better form of abstraction for your example would be:\n\n    thing = firstThingWithParameterIn(container)\n    if (thing)\n      thing.frobbleStuff\n      thing.drong(otherThing)\n\nYou don't need to see the code to understand how to get the first item matching a property, it's trivial. The other logic is important and moving it down a layer isn't an abstraction unless it's a single coherent unit of logic. So if all this process does is make a coffee, then it makes sense to say:\n\n    if (thing)\n       thing.makeMeACoffee(otherThing)\n\nReading the code, you can clearly see the different steps and know what's going on instead of having to read some big mess of for loops and random function calls.", "id": "dapmuh4"}], [{"comment": "Splitting up a function into tiny logical units might seem like a sensible idea during development but can turn into a debug and maintenance nightmare later on. I'd thus tend more towards favoring the \"re-use rule\", although this of course always depends on the individual situation.", "id": "dapg4tb"}], [{"comment": "> Any function more than half-a-dozen lines of code starts to smell to me\n\nAnd here we go again with the dogma. Didn't we already decide that was a bad idea ten years ago?\n\n> Some people are concerned about short functions because they are worried about the performance cost of a function call. \n\nThat's the least of my concern.\n\nThe main problem with functions that only contain a handful of lines is spaghetti code.\n", "id": "dapv2o5"}], [{"comment": "Well put, sir!\n\nNow, this appears to be at odds with what all the \"cool kids\" are doing, which is to use lambdas to avoid having to come up with names for things that should probably be functions.  ", "id": "dapg3fo"}, {"comment": "> which is to use lambdas to avoid having to come up with names for things that should probably be functions. \n\nlambdas are an additional solution to the problem of \"where do I put my code\".", "id": "dapj5qv"}, {"comment": "True in theory.  In practice, often misused, at least in my experience.", "id": "dapk3oc"}], [{"comment": ">If you have to spend effort into looking at a fragment of code to figure out what it's doing, then you should extract it into a function and name the function after that \u201cwhat\u201d\n\nYou should create a new function if you're going to use that block of code in multiple places. You shouldn't create a new function if you just see some code you don't immediately understand. You can put a comment at the top of block of code explaining what it does instead of a creating a new useless function.\n\n>Once I accepted this principle, I developed a habit of writing very small functions - typically only a few lines long [2]. Any function more than half-a-dozen lines of code starts to smell to me, and it's not unusual for me to have functions that are a single line of code\n\nWhat a fucking shit idea. I hope I never have to work on the same codebase as this guy\n\n>Some people are concerned about short functions because they are worried about the performance cost of a function call.\n\nNo, I'm worried that retards like you don't care about the mental costs that come with creating new functions for no reason. Instead of just reading code, now I have to jump around, wonder where the function gets called, under what conditions it can be called in, what it returns, etc. It's just extra effort you've made me waste because you think it's better to create new functions all the time than to just put a single comment explaining what the block of code does.\n\n\n\nIt's no wonder no one can write software when supposed \"gurus\" are giving advice of this quality. Just kill me ", "id": "dap5fs4"}, {"comment": "I think he has a point but goes too far in it.\n\nSome times I will break logic out of a function for no other reason than to \"simplify\" the function.  The challenge is in good abstractions.  The best candidates are sections of code in a function that can stand on its own and you can reason enough about it just from the function name without having to keep in mind the exact implementation of every one of these helper functions.\n\nShort functions for its own sake leads to spaghetti that I'll refactor before I'll even be willing to make any functional changes to it.", "id": "dap7ad8"}, {"comment": "Exactly. It's good to break things into chunks, but if you're spending more time playing hide-n-seek finding which function you're calling you've gone too far.\n\nI wonder... does any editor let you have a \"replace function call with body\" view? \n\nI'll shorten it, but let's say i had code... (excuse my formatting, lazy.)\n\n* function x() {\n* callY();\n* }\n\n* function callY() {\n* print(\"Hello\");\n* }\n\nDoes any editor have a button I could click where it would replace callY() in function x() with the body of callY() using whatever parameters I sent and so on down the line until I had all the code that would run if I called x() visible inside the brackets of x()?\n\n* function x() {\n* print(\"Hello\");\n* }\n\nAfter thinking about this, I really really hope something like it exists.", "id": "dapa7iy"}, {"comment": "> I wonder... does any editor let you have a \"replace function call with body\" view? \n\nI've never seen that before, but a coworker and I have disccussed this a bunch.  We also want to be able to look at a class and see like a flattened version of the class heirarchy.  So if the class inherits something, I'd like it to show up in the class itself.\n\n    class A {\n        var variable1;\n    }\n    class B inherits A {\n        var varible2;\n    }\n\nSo in this case I'd love a view that shows:\n\n    class B inherits A {\n        var variable1; // with maybe a visual indicator that this was inheritied\n        var variable 2;\n    }", "id": "dapf3to"}, {"comment": "That would save so much time. Somebody needs to develop these features asap. \n\nImagine if you could also modify the inherited class or a function from right inside the same view as the child :O\n\nThat would also make building maintainable code so much easier if you could go both ways and write something like... Sorry for formatting, on mobile.\n\nClass X implements y {\n/* Implements */ Class y {...}\n} \n\nAnd have class y automatically be created (if it isn't already) and modified from right inside class X.\n\nThen separating functionality is as easy as turning on flat code mode and wrapping code you want in a separate function, or class, and the editor takes care of moving it out and calling it.... Oh god, I need this so bad now.\n\n ", "id": "dapifbm"}, {"comment": "Yeah, that would be so great!", "id": "dapj6lu"}, {"comment": "When you put a comment in a long method then how do you find the start end stop of the context for this comment? If you create a new function and instead of comment you just put a name for this function then it's obvious that the context is from start to the end of this function.", "id": "dap6cvw"}, {"comment": "The way I do it is to logically separate things into blocks of code. Blocks of code are separated by an extra blank line. Whenever a block of code needs extra explanation as to what is going on I put a comment on top of it explaining what it does. If a block of code is used in the exact same way in multiple places I break it out into a function.", "id": "dap8htc"}, {"comment": "So you're saying you think this is good:\n\n    void doSomething() {\n        // do thing x\n        code\n        code\n        code\n    \n        // do thing y\n        code\n        code\n        code\n    \n        // do thing z\n        code\n        code\n        code\n\n        code\n        code\n        code\n        code\n    }\n\nBut this is absolutely horrible and only something that would be espoused by complete idiots:\n\n    void doSomething() {\n        doThingX();\n        doThingY();\n        doThingZ();\n\n        code\n        code\n        code\n        code\n    }\n\n    void doThingX() {\n        code\n        code\n        code\n    }\n\n    void doThingY() {\n        code\n        code\n        code\n    }\n\n     void doThingZ() {\n        code\n        code\n        code\n    }\n\nIt's a little bit more verbose, although how significant that increase is depends a lot on the language and contents of functions, but it's not really that huge of a change, I'm not sure why you feel so strongly about it. Modern IDEs can even convert between the two with just a few keystrokes if whichever approach you choose turns out to be the less ideal one. Personally, in a lot of cases, I wouldn't have a problem with either one.", "id": "dapd145"}, {"comment": "There was an article by John Carmack where he talked about why he preferred the first (unless the functions are pure functions). IIRC his opinion was that the second way looked nicer from an aesthetics perspective but it tended to hide bugs.", "id": "dapjhpo"}, {"comment": "I've read the article you're referring to and his preferred style is actually how I usually code. I tend to use a lot of pure functions though, so my average function length is probably closer to that of someone who prefers the second style.  \n\nThat said, this was a simplified example as I was trying to point out that it's a relatively minor distinction in many cases, especially if you're separating blocks with whitespace a comment as a convention. I was objecting to the vehemence of the argument for in-lining by default, not the concept itself.", "id": "dapl9j6"}, {"comment": ">So you're saying you think this is good:\n\nYes, that is exactly what I'm saying. If the code inside doThingX/Y/Z is not repeated elsewhere I vastly prefer your first example.", "id": "dapd7xh"}, {"comment": "Meh. I prefer the second, but would not blink if I saw a ~~second~~first.\n\nIt's all not that important in the end.", "id": "dapeqxs"}, {"comment": "It is very important once your codebase starts growing in size. Think of your codebase as a graph. Think of every function, class, file as a node, and things calling each other or being instanced somewhere as an edge. \n\nIf you have a graph with a lower amount of nodes (and consequently lower amount of edges), you'll have a much easier time going through the whole thing, or holding parts of the graph in your head as you're adding/changing/removing features. ", "id": "dapf1ml"}, {"comment": "I don't think the size of that graph is as important to understanding and/or reading a codebase as you make it out to be.", "id": "dapgbgi"}, {"comment": "You're ignoring the fact that as humans we have the luxury of pruning that graph at some point, because we don't need to execute the code, just understand it. Once you get to the point where you understand what the code does, you get to stop diving deeper. Unless you're going to fix a bug or implement a feature, but I'd argue that the constrained scope of a smaller function (even if its never reused) actually *helps* with that...there's less noise around the code you're editing, less chance for you to mess with something you have no business touching on accident, etc. ", "id": "dapvtcn"}, {"comment": "The chances of some node being connected to more edges are higher if you have a higher amount of nodes and edges on average. In this sense, whenever you're looking at any individual node or edge, if your code base has more nodes and edges then on average you'll have to keep more things in mind and bring bigger subgraphs into context.\n\nYou are right that at a local level being able to read something better helps more, but the moment you start dealing with interactions between different subgraphs (which happens all the time) you'll have more trouble if you have more nodes and edges to consider.\n\nYou're looking at local costs instead of global ones. I'm saying that cutting on the many but small global costs is better than cutting on the few but big local ones.", "id": "dapwdy1"}, {"comment": "~~I guess [John Carmack](http://number-none.com/blow/john_carmack_on_inlined_code.html) is a complete idiot then.~~\n\nedit: I totally misread what you meant. I thought you were saying the first example was horrible. My bad.", "id": "dapiy9b"}, {"comment": "I completely agree. It's not like stack frames cost money but... god damn. I'd hate to traverse a codebase like that", "id": "dap7b83"}, {"comment": "While I agree that you have to balance internal and external complexity, he does have a point about expressing intent.  \n\nAs in his smalltalk highlight is implemented as reverse example, having to remember that the reason we are reversing the colors here is to highlight the text is more effort than just seeing highlight text and not caring how that is done.\n\n>now I have to jump around\n\nWhy do you have to jump around?  You just saw a function that named \"highlight\". Why not believe it does what it says in the name and go on your merry way unless highlight is acting funny.  ", "id": "dap9pe2"}, {"comment": "I really hope you're trolling. \n\nTake something like:\n\n    if (a == b || (a < c && a > d) || ((c != f || f == 0) && (g - c > .0001)) {\n        ...\n    }\n\nI see code like a few times a year. I don't know the context, there are no comments or unit tests, and the developer that wrote it was hit by a bus some time in 1997 and lives off their \"jump to conclusions\" mat idea. \n\nRefactoring into something like:\n\n    if (someRandomFunctionName(a, b) \n      || anotherRandomFunctionName(a, c, d) \n      || yetAnotherFunctionName(c, f, g)) {\n        ...\n    }\n\nmakes a lot of sense to me. \n\nIf you were here I'd give you a hug and tell you it will be ok then make you pay for the hookers and blow. \n\nYou're welcome.", "id": "dap9ix8"}, {"comment": "I'm a novice, but how is that better than:\n\n    if ( a == b\n      || (a < c && a > d)\n      || ((c != f || f == 0) && (g - c > .0001))\n      ) {\n        ...\n    }\n\n\nWhat function name are you going to come up with that immediately describes `(a < c && a > d)` to me? \n\nEdit: Thanks for the answers guys, this sort of thing is super helpful to someone who's just starting out. ", "id": "dapciwm"}, {"comment": "the problem that occurs sometimes in production codebases is that the reasons for the test conditions aren't captured.\n\nat face value neither half of /u/my_safe_for_work_acc's made-up scenario is clear. this is often a problem with contrived examples. I'm going to keep pushing the example, if the abstraction stretches too thin hopefully you can still see the generic benefit that well-named functions can provide over random code snippets.\n\nback to the example. if we named the functions something like this:\n\n1. areValvePressuresEqualized(a,b)\n2. isValvePressureWithinRange(a,c,d)\n3. isLowEndPressureCalibrated(c,f)\n4. openValveApplicationAllowed(f)\n5. ValveLowPressureCalibrationCloseEnough(c,g)\n\nit could tell you a story about your product's requirements, such as:\n\n1. no matter what the relative values are, we're ok so long as both valves are the same pressure.\n2. even if the valve pressures aren't the same, things are ok so long as our first valve pressure is within a certain range.\n3. is the low end of our pressure zone calibrated correctly? (this is a stretch, given the largely contrived example, because what's the value of this information on its own?)\n4. maybe we allow a lower pressure zone limit of 0. still raises the question of how or why this is important, but it still tells you more than (randoVarXYZ == randoConstant123) test conditions.\n5. maybe our measurement apparatus, or the tolerances of our product components, are fine so long as certain things are within a certain range.\n\nthese are contrived, and when you put them together in the given example, they still don't make more sense than the raw test conditions. but ideally, well-named functions can help convey why you're doing something, in addition to the raw \"what\" it is that you're doing.\n\nand yes, the typical caveats about documentation, comments, etc being out of date apply, but some see this sort of separation as a step in the right direction for this and other testability/flexibility reasons.", "id": "dapdk7r"}, {"comment": "If it's a condition that's only ever being used in this function I often do something like\n\n    boolean valvePressuresEqualized = a == b;\n    if (valvePressuresEqualized) { [...] }\n\nMight lead to a few more lines of code but I find it nicer than commenting every inline condition and easier (than an extracted function) to see what's really being checked should I need to know. Has the drawback of not being testable in isolation, but for simple stuff I like it.", "id": "dapeeo4"}, {"comment": "yours is a nice middle ground that could still be pretty testable, if a and b were parameters to your function. but then you can run into parameter soup, which isn't good either.\n\nI think this is definitely something where neither extreme is always right. I try to error on the side of readability, because it's usually more true that we'll need to go back and change or extend something, than we'll have to worry about its performance.\n\nif performance does become a concern, there are plenty of tools to either mitigate that while keeping some level of abstraction, or measure well enough to know which smaller pieces really need to be highly optimized.", "id": "dapeu33"}, {"comment": "Yea, performance isn't really something I think about when doing this either, I just find it more readable like this. I'm not against extracting into functions if it \"feels right\" and/or the logic is used from different places, but for me this approach is where I start (and most of the time end).", "id": "dapggnk"}, {"comment": "It's a matter of preference to be honest. \n\nThe cognitive load for me to process this:\n\n   if (areFundsAvailable(a, b) \n     || isAmountWithinThreshold(a, c, d) \n     || hasAcceptableLoss(c, f, g)) {\n       ...\n   }\n\nis much lower. Part of refactoring code like this involves breaking the expressions into chunks that are easier to consume and giving them useful names. ", "id": "dapdlid"}, {"comment": "Code tends to have a meaning that often can be expressed in plain words.\n\nYour example looks like \n\n    !range(c,d).contains(a)", "id": "dapeni6"}, {"comment": "\n>It's no wonder no one can write software when supposed \"gurus\" are giving advice of this quality. Just kill me  \n\nI'd love to. One less dipshit who writes bloated methods and prefers comments over self-documenting code.", "id": "dapata5"}, {"comment": "Go suck Martin Fowler's dick and keep writing shit code you mongoloid", "id": "dapc1n5"}, {"comment": "> You should create a new function if you're going to use that block of code in multiple places. You shouldn't create a new function if you just see some code you don't immediately understand\n\ndepends on the use case and the language really. Imagine you are writing an ORM which amounts to a lot of code. You have a function called Resolve which resolves all kinds of relationships , one to one, one to many ,many to many, and all reverse relationships(i.e. if user owns roles, then resolve all users for a role ). It can quickly amount to 1000 lines of code in a single function. I know that, I wrote such piece of code. At some point it is hard to follow. Abstracting some parts into smaller functions even used only once, can greatly reduce de cognitive load of for loops, reflection tricks and co. In general your point is valid, but it's not a rule either. \n\n\n", "id": "dap8l4b"}, {"comment": "Yes, I do what you said too. In the language I use most of the time I can create new functions locally (inside another function) and doing what you said really is useful for methods that get too big. But the nuance of your comment is not present in the original piece.", "id": "dap8udu"}, {"comment": "Absolutely this. Serial bullshit from Fowler.", "id": "dap5s4w"}]]], "5fnmra": ["Webassembly initial steps tutorial or how to start with wasm", "2016-11-30 07:27:55", 8, "http://tutorials.technology/tutorials/11-webassembly-initial-steps-tutorial.html", [], []], "5frr6n": ["\u03bc-son: a human-readable, ultra-fast, ultra-compact JSON encoding scheme", "2016-11-30 22:55:56", 6, "https://bitbucket.org/tkatchev/muson", [[2, "Human readable?"], [1, "Nice touch with the limit of the cache. Maybe in a future version the encoder could increase/decrease the limit based on the input and write the value along the signature if that improves things a lot.\n\nIt would be interesting to see the encoding/decoding performance overhead of a muson proxy for mobile communications, using it as a _wire only_ endpoint to reduce bandwidth but still reuse existing JSON libraries/code in both client and server code."]], [[{"comment": "Human readable?", "id": "damorjj"}, {"comment": "Yeah I was thinking the same thing. The small size is cool, but this\n\n    { \"root\" : [\n        { \"id\": 1, \"cost\": 0.25, \"tags\": [ {\"name\": \"blue\", \"visible\":true} ] },\n        { \"id\": 2, \"cost\": 0.34, \"tags\": [ {\"name\": \"blue\", \"visible\":null} ] },\n        { \"id\": 3, \"cost\": 0.25, \"private\": true }\n    ]}\n\nis MUCH more readable than\n\n    {root:[{cost:Real,id:Int,private:?Bool,tags:?[{name:String,visible:?Bool}]}]}\n    [#0.25#1~[\"blue\"T]#0.34#2~[*0~]*1#3T~]\n\nat least in my opinion.", "id": "damoy1q"}, {"comment": "Easy or comfortable editing wasn't the goal, obviously. Being able to understand the contents of a message at a glance and being able to manipulate them with normal text-processing tools was.\n\nThink about how much harder log grepping and writing tests would be if a purely binary format like protobuf was used.\n", "id": "dan9pju"}], [{"comment": "Nice touch with the limit of the cache. Maybe in a future version the encoder could increase/decrease the limit based on the input and write the value along the signature if that improves things a lot.\n\nIt would be interesting to see the encoding/decoding performance overhead of a muson proxy for mobile communications, using it as a _wire only_ endpoint to reduce bandwidth but still reuse existing JSON libraries/code in both client and server code.", "id": "damkguj"}]]], "5g39y9": ["JavaScript Developers: Watch Your Language! - Web Standards", "2016-12-02 16:36:03", 4, "https://bocoup.com/weblog/javascript-developers-watch-your-language", [[1, ">2021\n\nI really hope I'll be targetting wasm by then."]], [[{"comment": ">2021\n\nI really hope I'll be targetting wasm by then.", "id": "daplywn"}, {"comment": "My programming experience is 80% JS and 18% Bash with random bits of other languages here and there. Is Go on the roadmap for WebAssembly? I've been looking at it as a potential first step into native programming.", "id": "dapsv4o"}, {"comment": "GopherJS might target it in the future.", "id": "dapwx2e"}]]], "5fqyoe": ["5 Secrets of the Switch Statement, Including the Reason It Even Exists.", "2016-11-30 20:44:37", 50, "https://medium.com/@bartobri/5-secrets-of-the-switch-statement-633953b2e741#.9mkejzafd", [[55, "It's not true that the switch statement has no real purpose. Many compilers optimize switch statements differently from chains of if's, and they can be easier to read. Also fall-through *is* occasionally very useful. It should probably not be the default behavior... instead of 'break' there should probably be a 'fallthrough' keyword or something.\n"], [45, "1. The minimum number of cases a compiler must permit is 256.\n2. You can declare local storage by following the switch\u2019s open curly brace with a declaration.\n3. Execution starts at the matching case and continues until a break or curly.\n4. The default case can appear anywhere in the list of cases.\n5. The switch statement is almost never used as originally intended.\n\n\n> Fall-through was intended to allow common end processing to be done after some case-specific preparation had occurred. In practice it\u2019s a severe misfeature, as almost all cases end with a break.\n~ Peter Van Der Linden, author of \u201cExpert C Programming\u201d"], [30, "This was a particularly terrible article, completely skips over the actual reason as to why the switch statement exists. ( although it briefly hints that it might start to dig into it by mentioning that you have to support a minimum of 256 cases when implementing a compiler ) \n\nJump Tables.\n\nThis is also the reason as to why the switch statement also ends up being significantly faster then chains of if conditionals. a switch statement in C is really just a compiler generated jump table.\n\nThe concept of a jump table comes from back when we considered ourselves lucky to have 64 k of ram split up into 256 pages of 256 bytes ( and you had a stack of 256 ). And this is exactly the historic reason as why 'break' is explicitly defined ( because you would do a JSR to your table, and execute away until a RET was reached which would then continue execution from the statement after the JSR. )\n\nIf you were clever enough and were really squeezed for ram you actually could reuse your jump table across multiple usages by setting a page index externally. \n\n\n"], [7, "This article misses the main benefit switches provide - compiler safety when used with enums (especially in very large code bases).\n\nBy adding a new case to an enum, your code won't compile until all switches handle it (which is why using a default case can often be bad practice). Using if-else chains will compile just fine and possibly create a really subtle bug. "], [6, "Let's not forget other variants of the `switch` idea, like destructuring pattern matching in the ML family of languages and the `cond ` expression in the Lisp family."], [1, "Don't some compilers make trees out of switches sometimes?"], [1, "Usual medium ramble. Not really worth it. Got again duped by the clickbaity title and didn't check the link. \n\nHe talks about the compilers without specifying anywhere what is the language he's talking about. Are all compilers the same?  Weird. Suddenly it's like I don't know anything anymore."], [1, "Fall-through is the greatest feature of switch. Stop demonising it."], [-1, "5 Secrets of the Goto Statement.\n\n1. Goto 2.\n2. Goto 3.\n3. Goto 4.\n4. Goto 5.\n5. Goto 1."]], [[{"comment": "It's not true that the switch statement has no real purpose. Many compilers optimize switch statements differently from chains of if's, and they can be easier to read. Also fall-through *is* occasionally very useful. It should probably not be the default behavior... instead of 'break' there should probably be a 'fallthrough' keyword or something.\n", "id": "damho9h"}, {"comment": "Agreed. I'm not sure about other new languages, but Swift has precisely the keyword and behavior you described: [Fallthrough keyword in Swift](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID140) ", "id": "damnk1a"}, {"comment": "In C++17, you'll be able to add the new [fallthrough] attribute where you purposefully omit 'break' to shut up compiler warnings about missing \"break\", since it's most often a bug. ", "id": "dampsfu"}, {"comment": "Golang doesn't break by default as well. https://github.com/golang/go/wiki/Switch", "id": "dan8olh"}, {"comment": "https://en.m.wikipedia.org/wiki/Duff's_device", "id": "dampc8b"}, {"comment": "At work we use a proprietary language, and it's switch statement specifically doesn't fall through. In fact, I don't even think you can fall through (without coding something like a goto), but now I'm curious and will have to check tomorrow.  ", "id": "dan5kny"}, {"comment": "> At work we use a proprietary language\n\nAre there any good reasons to do this?", "id": "danfcj9"}, {"comment": "Could be a domain specific language.", "id": "danhyzp"}, {"comment": "I would also like to know the answer to this. ", "id": "daobmxe"}, {"comment": "Agree with your points. I acknowledged both the speed gains and fall-through as valid uses for the switch statement though. My point at the end was that it is rarely ever used for either case.", "id": "damiv7o"}, {"comment": "Check out page 34 and 35 of this pdf: http://www.xsim.com/papers/Bario.2001.emubook.pdf .\n\nSwitch statements following certain criteria can sometimes be compiled into jump tables which operate in O(1) as opposed to a series of if-else which operates in O(n). Most of the time this performance gain isn't huge, but for emulators (as in the PDF I linked to above) it certainly has an impact.", "id": "damjovy"}, {"comment": "Interesting. Thanks for the response.", "id": "damjyjd"}], [{"comment": "1. The minimum number of cases a compiler must permit is 256.\n2. You can declare local storage by following the switch\u2019s open curly brace with a declaration.\n3. Execution starts at the matching case and continues until a break or curly.\n4. The default case can appear anywhere in the list of cases.\n5. The switch statement is almost never used as originally intended.\n\n\n> Fall-through was intended to allow common end processing to be done after some case-specific preparation had occurred. In practice it\u2019s a severe misfeature, as almost all cases end with a break.\n~ Peter Van Der Linden, author of \u201cExpert C Programming\u201d", "id": "damb34b"}, {"comment": "The minimum is 257 in C90 (specifically, I think, so that compilers don't limit it to 8 bits), and 1023 in C99 and C11.", "id": "damr40c"}], [{"comment": "This was a particularly terrible article, completely skips over the actual reason as to why the switch statement exists. ( although it briefly hints that it might start to dig into it by mentioning that you have to support a minimum of 256 cases when implementing a compiler ) \n\nJump Tables.\n\nThis is also the reason as to why the switch statement also ends up being significantly faster then chains of if conditionals. a switch statement in C is really just a compiler generated jump table.\n\nThe concept of a jump table comes from back when we considered ourselves lucky to have 64 k of ram split up into 256 pages of 256 bytes ( and you had a stack of 256 ). And this is exactly the historic reason as why 'break' is explicitly defined ( because you would do a JSR to your table, and execute away until a RET was reached which would then continue execution from the statement after the JSR. )\n\nIf you were clever enough and were really squeezed for ram you actually could reuse your jump table across multiple usages by setting a page index externally. \n\n\n", "id": "damlhg7"}, {"comment": "Author here. While I didn't use the term \"jump tables\" I do address the speed argument and found it to be overstated for most practical purposes. That said, thanks for your feedback. In hindsight i probably shouldn't have subtitled the article with \"the reason it exists\".", "id": "dammm7k"}, {"comment": "While it mentions the speed argument it also seems very dismissive of it. \n\nIt also seems to completely skip the code readability benefits. ", "id": "damoyyl"}, {"comment": "It seems the whole purpose of the article is to be dismissive of switch as a language feature.\n> So that\u2019s the switch statement. Quirky and flawed with barely enough use cases to justify it\u2019s own existence.\n> \n\n..that's an ignorant statement IMO. Switch belongs because it's the high-level way to express a 1:M comparison. If you model what's naturally a 1:M comparison as a collection of 1:1 comparisons then you've discarded information that's useful for the compiler and anyone who reads the code.", "id": "damsf6n"}, {"comment": "The more I think about this article it the more it dawns on me how completely off the mark it is. \n\nIts kind-of scary how someone with the tiniest amount of knowledge, about the subject matter can write an article which can misinform people who may stumble across it to try to understand a concept they have just been introduced to so greatly.\n\ngoing through the poster's submission history it appears he only wrote his first C program 8 months ago, unsure if im more sad or angry about this whole thing. ", "id": "damttzj"}, {"comment": "Seriously that sums up half the articles to hit the front of r/programming - in the same way people should not be getting their news from social media, you can't assume a popular article here is good technology or even good best practice or even correct. It's like electing Donald Trump to POTUS and the wild success of shit like MongoDB are facets of the same echo chamber problem.", "id": "damv341"}, {"comment": "honestly, at this point I'm just downvoting everything on medium.com as a knee-jerk reaction", "id": "damy2ox"}, {"comment": "Problem is, they get upvoted. How does this happen?", "id": "dang015"}, {"comment": "I normally don't click on programming articles on reddit because they rarely interest me ( long gone are the days where /r/programming linked things such as blog posts from oldnewthing ) \n\nI'm half tempted to write a few and publish them somewhere. Last time I wrote a programming article was in 1998, things have changed slightly since then. ", "id": "dands09"}, {"comment": "Oh definitely. We punch cards with both hands now. ", "id": "daobtxo"}, {"comment": "lmao, I still have some old punch cards laying around, but alas by '98 punch cards had already been completely gone for 10 years, and mostly gone for 15.", "id": "daocq8e"}, {"comment": "Why is MongoDB shit? (Btw, wikipedia says that CERN uses it amongst Disney and MTV).", "id": "dao9bg2"}, {"comment": "as far as modeling information for retrieval goes, Mongo and other so-called NoSQL represent a total abandonment of modern principles. You will never find a highly skilled relational expert advocate for Mongo no matter what the use case. NoSQL was perpetuated by the army of relational-illiterate brogrammers bleating in the echo chamber.", "id": "daogpcp"}, {"comment": "Personally, I find switch statements to be less readable than ifs.\n\nThere's an extra level of indentation, and you have to be conscious of whether a particular statement will fall-through or not. Meaning that some cases will depend on previous cases, where others will not. With ifs all of the conditions required to enter are listed clearly at the entry point.  ", "id": "danh3iu"}, {"comment": "That just isn't possible, especially if your cases are one line method calls. It just takes up less space. For 10 cases you'd have to mentally parse 20 lines. \n\nAlso, a switch tells me, conceptually, that I am mapping multiple inputs to one output. There are definitely exceptions to this, but its generally true. The ifs often contain lots of side effect code. Its just convention, but I think that programmers see the braces after an if differently than they see a switch case. ", "id": "daobywu"}, {"comment": "As I said, it's a personal opinion. \n\nAlso, even if your cases are one line, unless they're returning immediately then they're at least two lines (one for break).\n\nI don't see how you can think of a switch mapping two things - you can only switch on one variable at a time", "id": "daon5wm"}], [{"comment": "This article misses the main benefit switches provide - compiler safety when used with enums (especially in very large code bases).\n\nBy adding a new case to an enum, your code won't compile until all switches handle it (which is why using a default case can often be bad practice). Using if-else chains will compile just fine and possibly create a really subtle bug. ", "id": "dan4ivh"}, {"comment": "> By adding a new case to an enum, your code won't compile until all switches handle it \n\nThat's not true, is it?!", "id": "dan7ztf"}, {"comment": "If you compile with -Werror, -Wswitch with clang, incomplete cases of switch statements are rejected, provided you *didn't* use 'default:'.", "id": "danamik"}, {"comment": "[deleted]", "id": "danbh9x"}, {"comment": "Enjoy: http://clang.llvm.org/docs/DiagnosticsReference.html#wswitch", "id": "dancwbs"}, {"comment": "This article is about c so enum types and various other operators ( such as ranged case statements, or string selectors) are allowed to be omitted. ", "id": "dandp07"}], [{"comment": "Let's not forget other variants of the `switch` idea, like destructuring pattern matching in the ML family of languages and the `cond ` expression in the Lisp family.", "id": "dan09aa"}], [{"comment": "Don't some compilers make trees out of switches sometimes?", "id": "dan7hf8"}, {"comment": "Can even be a combination of an if tree and jump tables, especially if the cases are mostly sparse.", "id": "dang8p9"}], [{"comment": "Usual medium ramble. Not really worth it. Got again duped by the clickbaity title and didn't check the link. \n\nHe talks about the compilers without specifying anywhere what is the language he's talking about. Are all compilers the same?  Weird. Suddenly it's like I don't know anything anymore.", "id": "danfsor"}], [{"comment": "Fall-through is the greatest feature of switch. Stop demonising it.", "id": "dang0l2"}], [{"comment": "5 Secrets of the Goto Statement.\n\n1. Goto 2.\n2. Goto 3.\n3. Goto 4.\n4. Goto 5.\n5. Goto 1.", "id": "damfapl"}, {"comment": "3 1/2. Goto 7.", "id": "damqeih"}, {"comment": "9 3/4: Goto Hogwarts", "id": "dankv6s"}]]], "5fyxp7": ["Bootstrap Tutorial for Beginners \u2013 A Complete Beginners\u2019 Guide", "2016-12-01 23:27:31", 0, "http://www.doctoralhub.com/bootstrap-tutorial-for-beginners/", [], []], "5g8s2u": ["Rooting an appliance for fun (and maybe profit?)", "2016-12-03 12:02:54", 23, "https://mambrui.github.io/2016/11/rooting-vm", [[3, "Very nice hack. You should earn a few bucks since you disclosed this in public so they can patch the exploit ASAP. "]], [[{"comment": "Very nice hack. You should earn a few bucks since you disclosed this in public so they can patch the exploit ASAP. ", "id": "daqqw51"}]]], "5fvqbr": ["Typing Practice for Programmers", "2016-12-01 12:35:16", 0, "https://typing.io/", [[9, "This does not reflect what you actually type in a decent code editor at all.\n\nSomething like IntellJ does a ton of auto-completion, so typing closing brackets is never really done manually. Same for repeating variable names. You type the first few chars and then auto-complete the rest."], [2, "Requires signin with Google, which is an instant turn-off for me.  First off, at least a demo version should work without any kind of login.  Second, why feed the Google my typing idiosycracies in addition to everything else they have on me?"]], [[{"comment": "This does not reflect what you actually type in a decent code editor at all.\n\nSomething like IntellJ does a ton of auto-completion, so typing closing brackets is never really done manually. Same for repeating variable names. You type the first few chars and then auto-complete the rest.", "id": "danhafv"}], [{"comment": "Requires signin with Google, which is an instant turn-off for me.  First off, at least a demo version should work without any kind of login.  Second, why feed the Google my typing idiosycracies in addition to everything else they have on me?", "id": "danfwc0"}, {"comment": "there is a demo without signing in", "id": "dapoen0"}]]], "5ftsnf": ["Buttery Smooth Emacs", "2016-12-01 04:49:18", 0, "https://m.facebook.com/notes/daniel-colascione/buttery-smooth-emacs/10155313440066102", [], []], "5fjef7": ["Old Design Patterns in Scala", "2016-11-29 19:01:03", 37, "http://www.lihaoyi.com/post/OldDesignPatternsinScala.html", [[4, "> While initializing nested Expressions is verbose and annoying in Java or C++, in Scala it is possible to make the syntax much more concise. For example, Scalatags lets you define your nested Frag objects as such:\n\n    val frag = html(\n      body(\n        h1(id := \"my-title\")(\n          \"Hello\"\n        ),\n        p(backgroundColor := \"red\")(\n          \"World\"\n        )\n      )\n    )\n\n    frag.render\n\n> Which in Java would be something like\n\n    Frag frag = new HtmlFrag({},\n      new HtmlFrag(\n        new Header1Frag({new Attr(\"id\", \"my-title\")},\n          new StringFrag(\"Hello\")\n        ),\n        new ParagraphFrag({new Attr(\"background-color\", \"red\")},\n          new StringFrag(\"Hello\")\n        )\n      )\n    )\n\n    frag.render()\n\nAside from the fact that `{...}` won't work...\n\nThat is an unfair comparison. It is not that hard in Java to provide short, dedicated methods for construction either as static imports or by using subclassing. It could simply look like:\n\n    Frag frag =\n      html(\n        body(\n          h1(attrs(att(\"id\", \"my-title\")),\n            \"Hello\"\n          ),\n          p(attrs(att(\"background-color\", \"red\")),\n            \"World\"\n          )\n        )\n      );\n\nProviding that interface for the example above is just as annoying in Scala as in Java.\nOnly if you decide to only use case classes do things get easier."], [3, "You didn't address the reusability of the builder pattern. With a proper builder pattern, you can set values, call .Build(), change one of the values, and call .Build() again. The result is two entirely different objects that differ only by the one called value. Not something I've found easy to do (cleanly) with Scala. "], [2, "I have no experience with Scala, so this may be a stupid question: with the implicit adapters, how would the compiler know which one to use if there's multiple adapters for a type pair? Would that be a compiler error?"]], [[{"comment": "> While initializing nested Expressions is verbose and annoying in Java or C++, in Scala it is possible to make the syntax much more concise. For example, Scalatags lets you define your nested Frag objects as such:\n\n    val frag = html(\n      body(\n        h1(id := \"my-title\")(\n          \"Hello\"\n        ),\n        p(backgroundColor := \"red\")(\n          \"World\"\n        )\n      )\n    )\n\n    frag.render\n\n> Which in Java would be something like\n\n    Frag frag = new HtmlFrag({},\n      new HtmlFrag(\n        new Header1Frag({new Attr(\"id\", \"my-title\")},\n          new StringFrag(\"Hello\")\n        ),\n        new ParagraphFrag({new Attr(\"background-color\", \"red\")},\n          new StringFrag(\"Hello\")\n        )\n      )\n    )\n\n    frag.render()\n\nAside from the fact that `{...}` won't work...\n\nThat is an unfair comparison. It is not that hard in Java to provide short, dedicated methods for construction either as static imports or by using subclassing. It could simply look like:\n\n    Frag frag =\n      html(\n        body(\n          h1(attrs(att(\"id\", \"my-title\")),\n            \"Hello\"\n          ),\n          p(attrs(att(\"background-color\", \"red\")),\n            \"World\"\n          )\n        )\n      );\n\nProviding that interface for the example above is just as annoying in Scala as in Java.\nOnly if you decide to only use case classes do things get easier.", "id": "dakndkg"}, {"comment": "That's a fair point", "id": "daknuhm"}, {"comment": "Yours is not as concise either though. Just because the author showed a less concise way than you did doesn't change his point that Scala can make it more concise.", "id": "dal7hty"}, {"comment": "I never said Java was more concise in general. It's a shit language compared to Scala. Also, I agree with the point itself. However, that doesn't mean he has to make up an inflated example, does it?", "id": "dalzc1m"}, {"comment": "By subclassing or with `using static` (in C#, I don't know if Java has an equivalent).", "id": "dakz0z1"}, {"comment": "> Providing that interface for the example above is just as annoying in Scala as in Java. Only if you decide to only use case classes do things get easier.\n\nSo if you ignore the basic Scala feature that makes this a lot easier than Java then it isn't any easier than Java. Um, sure?\n\n(Named parameters also make it much easier to write business-readable literals in this kind of style - this connects with the builder example)", "id": "dalttna"}, {"comment": ">So if you ignore the basic Scala feature that makes this a lot easier than Java\n\nI ignored it because his Scala example also didn't use case classes.\n\nEDIT: Let me clarify this point:\n> Only if you decide to only use case classes do things get easier.\n\nMany public interfaces do not use case classes, either for aesthetic or practical reasons such as implementing caching/flyweights. Yes, internally many libraries with such structure will represent it with case classes, and in a sense that leads to less effort (a good thing), but I was merely talking about the example, which does not at all represent how a modern Java library for structured data would expose its functionality.\n", "id": "dalz3kz"}, {"comment": "The article isn't particularly about public libraries though, it's about needing to write expressions, which happens a lot in all kinds of code. The kinds of requirements that lead a few libraries to avoid case classes are very much the exception rather than the rule, IME (especially in code that doesn't need strong ABI compatibility guarantees, which is the overwhelming majority of code - popular published libraries have important systematic differences from regular code).", "id": "dam00ue"}, {"comment": "But wouldn't you agree that it should show an example that actually uses case classes if case classes (besides named parameters) are the crucial feature to point out there (in the \"You often do not use a parser\" section)?", "id": "dam0exj"}, {"comment": "Point taken", "id": "dam0jp2"}], [{"comment": "You didn't address the reusability of the builder pattern. With a proper builder pattern, you can set values, call .Build(), change one of the values, and call .Build() again. The result is two entirely different objects that differ only by the one called value. Not something I've found easy to do (cleanly) with Scala. ", "id": "dalb911"}, {"comment": "I didn't write the article, but don't case classes with their `copy` method do the trick?  \n  \n    case class Foo(int: Int = 1, string: String = \"...\", char: Char = 'c')\n    \n    Foo(\n      int = 234,\n      string = \"hello\"\n    ).copy(int = -3, char = 't')\n    .copy(int = 44)", "id": "dalc28z"}, {"comment": "But a Case Class isn't a Class. (semantics). They're really just data structures so can't be used the same way. They're all the attributes of a duck without the ability to quack. ", "id": "daldlqy"}, {"comment": "Well a case class is a class, it just can't be inherited from, is that what you're missing?", "id": "daldyep"}, {"comment": "Yes, of course it's a type of class (hence my remark about semantics).  But, strictly speaking, they shouldn't be used the same as your simple class and they come with their own caveats and conditions. Implied immutability, lack of inheritance, strict dependencies on constructor args, automatically defined equals, toString, and hash methods, an automatically generated companion object, etc...If you need complex behaviour from your class, Case Classes aren't what you would typically want to use. (exceptions not withstanding b/c somebody is gonna bring it up I'm sure)", "id": "daleq7g"}, {"comment": "How often would you want to reuse a builder for non-data classes? ", "id": "dalosgu"}, {"comment": "I've found very few reasons to use vanilla classes over case classes. \n\nGiven your list of all the things that are excellent about case classes especially!", "id": "dalsqwt"}, {"comment": "I would say the paradigm is different.  case classes are exactly what you want to use in most cases, because mutable state and a lack of referential transparency makes code hard to reason about.\n\nIf you try and write scala like it's a better java, you can for sure.  But you're really missing an opportunity to make your code better.  The patterns are different and it might feel weird, but you never NEED complex behaviour for your class - it's a design decision - and one that you shouldn't take lightly.", "id": "dalurr8"}, {"comment": "Agreed that the paradigm is different. Case classes are what you want in some cases, but not all. They're great when you need explicit pattern matching behaviour and they're great for data representation, but at some point, some class somewhere is going to take on 'complex behaviour'.  \n\nMy point was only that what is demonstrated is NOT a builder pattern. Yes, case classes exhibit Builder like behaviour, but standard classes do not in Scala.\n\nAndd ugh  on the 'make your code better'. Seriously, can we get away from the idea that any one language is a silver bullet that magically 'Makes your Code Better (tm)'?  The unmitigated magical BS I have seen and had to deal with in Scala because some cleverer-than-thou developer is using obscure implicit imports is ridiculous.  Nothing about spending an hour trying to figure out what implicitly imported trait is causing divergent behaviour is 'better code'.", "id": "dam5r4a"}], [{"comment": "I have no experience with Scala, so this may be a stupid question: with the implicit adapters, how would the compiler know which one to use if there's multiple adapters for a type pair? Would that be a compiler error?", "id": "dakxbo8"}, {"comment": "Correct, it would be a compiler error, saying \"ambiguous implicit\" as it doesn't know which takes precedence. Implicit resolution has well defined scoping rules", "id": "dakyl5z"}, {"comment": "Thanks for answering. That makes the most sense.", "id": "dakzr7u"}, {"comment": "Np. Implicits get a bad wrap, but they are actually a very important feature in Scala as they allow typeclasses (and thus, adhoc polymorphism). It's just implicit conversions that are nasty", "id": "dal0m9r"}]]], "5fo84n": ["Scala Pattern Matching, from a Java developer perspective. Part 1.", "2016-11-30 09:50:50", 16, "http://www.softwaredevelopmentstuff.com/2016/11/30/scala-pattern-matching-from-a-java-developer-perspective-part-1/", [[3, "The article misses Extractor objects (the `apply` and `unapply` methods)\nhttp://docs.scala-lang.org/tutorials/tour/extractor-objects.html\n\nAny class can be used in a pattern matching `case`, if it implements `unapply`."], [2, "Hey, just to let you know - as I was clicking around your blog I noticed that the performance was pretty slow (30+ seconds per page load).\n\nCould be because of Reddit traffic, but you may want to invest in a beefier hosting set up if you'll be posting here often."]], [[{"comment": "The article misses Extractor objects (the `apply` and `unapply` methods)\nhttp://docs.scala-lang.org/tutorials/tour/extractor-objects.html\n\nAny class can be used in a pattern matching `case`, if it implements `unapply`.", "id": "dalsmrk"}, {"comment": "That is for the next part. See the last paragraph:\n\n>We've only covered the basics of pattern matching with this article. In the next articles we will look to extractor patterns, xml patterns, matching on arrays and lists, matching on regular expressions and more.", "id": "dalsvow"}, {"comment": "huh, I searched 'extractor', but I must have typo'ed it because I saw no matches.", "id": "dalsyud"}], [{"comment": "Hey, just to let you know - as I was clicking around your blog I noticed that the performance was pretty slow (30+ seconds per page load).\n\nCould be because of Reddit traffic, but you may want to invest in a beefier hosting set up if you'll be posting here often.", "id": "daly9vj"}, {"comment": "I use the cheapest Bluehost hosting service, I also noticed the bad performance. I'll check with their support, the traffic is not so high. Thanks.", "id": "dam3muz"}, {"comment": "This shouldn't be a question of beefiness - even the cheapest host should be able to handle a blog these days, even with reddit-level traffic. It'll be an algorithmically bad software platform that's the issue, not cheap hosting.", "id": "dam1mpk"}]]], "5fq9vs": ["Great Developer Podcasts For Your Commute", "2016-11-30 18:46:10", 10, "http://rion.io/2016/11/30/great-developer-podcasts-for-your-commute/", [[4, "I try my best to decipher actual lectures during my commute, usually I'll listen to it while driving, then read the associated notes during my lunch break. Finally at home I'll fill in any gaps of understanding. \n\nIt's been working fairly well for data structures and algorithms; I also feel like my visualization skills are strengthening. \n\nI was inspired to do this by a blind CS classmate I went to school with. "], [2, "This list is missing Embedded.fm and Programming Throwdown"]], [[{"comment": "I try my best to decipher actual lectures during my commute, usually I'll listen to it while driving, then read the associated notes during my lunch break. Finally at home I'll fill in any gaps of understanding. \n\nIt's been working fairly well for data structures and algorithms; I also feel like my visualization skills are strengthening. \n\nI was inspired to do this by a blind CS classmate I went to school with. ", "id": "damg73x"}, {"comment": "Links?", "id": "danbmpi"}], [{"comment": "This list is missing Embedded.fm and Programming Throwdown", "id": "dam6dg1"}, {"comment": "also stackshare has a sick podcast ", "id": "damn2t0"}, {"comment": "Thanks Chris, I'll have to check those out. \n\nAs I mention my commute is extremely short, so there are only so many I can catch. Additionally, with such a huge number of dev-related podcasts, I was sure there would be some that I would miss. ", "id": "dam78pg"}]]], "5fqw52": ["How I pieced together production-grade infrastructure for less than $200/month", "2016-11-30 20:32:36", 3, "https://medium.freecodecamp.com/how-your-startup-can-leverage-production-grade-infrastructure-for-less-than-200-month-15c3724038b4#.d1kwn9pab", [[1, "You could cross-post this over to /r/startups too."], [1, "Good info. Thanks"]], [[{"comment": "You could cross-post this over to /r/startups too.", "id": "damfy6y"}], [{"comment": "Good info. Thanks", "id": "dammjhu"}]]], "5fifm6": ["A curious case of memory leak in a node.js app", "2016-11-29 15:45:24", 188, "https://www.future-processing.pl/blog/a-curious-case-of-memory-leak-in-a-node-js-app/", [[146, "I'll never understand why developers insist on modifying how I scroll."], [19, "I love solving bugs like this, seemingly impossible, in the end the reason is generally simple, and the fix satisfying."], [13, "Is the bug the gigantic web font preventing me from reading this article?"], [8, "This is really cool. Ive been dealing with a memory problem in nodejs the last couple week. Not an easy problem to fix. Heap snapshots feel like they're not usable in the dev tools. But I didn't notice you can use them the way it mentioned in the article.\n\nIn the article it says valgrind's Memcheck replaces malloc with its own function. I might not be totally right but I don't think v8 uses this? I noticed during garbage collections munmap gets called. I never saw free or those. Does valgrind's memcheck also modify mmap and munmap? Does v8 actually use malloc and im just wrong?\n\n"], [5, "I literally can not scroll down with my scroll wheel on this site... Up works fine."], [3, "I'm not really familiar with the tooling around node.js, but couldn't this be resolved by taking a core dump of the whole process at the moment of the crash, and exploring the memory to see which objects take up space on the heap?"], [2, "I think I am missing something: would someone explain me why they put \n\n    return  scope.Close(Undefined());\n\nin void functions in the first place?"], [2, "What a shitty website design."], [1, "Is there a TL;DR; ?"]], [[{"comment": "I'll never understand why developers insist on modifying how I scroll.", "id": "dakiyfb"}, {"comment": "I feel this too. I can't understand what's the reason to do this. I also often experience these sites as lagging on my mid-2013\" Macbook Pro Retina running Chrome.\n\nWhy on earth would you augment scrolling? It would be like forcing the keyboard to write \u00e1 instead of a, everytime you typed on the website because you think it's prettier. It's not like styling a button, it's really messing with the interaction of the site.\n\nIf I see a website with \"smooth scrolling\" (not!), I instantly close it because I don't even want to bother. As the other guy said down in the comments, I vote with my ad revenue. \n\nI often look at templates on Themeforest and pages like these for commercial projects (where we buy the full $1000 commercial license) and if I see a theme, no matter how perfect for the current project, with \"smooth scrolling\", I instantly see the developer as a douchebag and questions his knowledge about computers and usability, and pick another theme... \n\nI sound so harsh and butthurt, but it's true. If a developer thinks smooth scroll is a great idea, I can't imagine what horrors lie in their Javascript and cross-browser HTML/CSS. Also closely related to the \"smooth scrolling\" is the \"snappy scrolling\" which I despise even more. You scroll a little, and these SPA's (Single Page Application / One Page websites) say \"Oh you want to SCROLL A LITTLE? HERE LET ME CANCEL THAT AND JUMP TO THE NEXT SECTION AND LOCK YOU IN PLACE.\".\n\nApple promotions are often a sinner here, but if you scroll back, they kinda say \"Oh okay, fuck it\" and detaches from your scrolling which is fine. ", "id": "daksub2"}, {"comment": "> I also often experience these sites as lagging on my mid-2013\" Macbook Pro Retina running Chrome.\n\nI have desktop i7 5820k and it still lags when I scroll on sites like this. Seriously people say _js is fast_, but it's ridiculous how slow and unresponsive these effects can get.", "id": "dal1uqi"}, {"comment": "I honestly thought it might be my Mac getting \"old\"... Not that it is an excuse for this JS, but you know, like a PC not being able to run the latest crazy games.\n\nWhat do these developers develop on then? Because I can't possibly imagine they experience this lag, otherwise they wouldn't be so stupid as to implement it............", "id": "dalskxx"}, {"comment": "> I honestly thought it might be my Mac getting \"old\"... Not that it is an excuse for this JS, but you know, like a PC not being able to run the latest crazy games.\n\nMy PC can run latest crazy games, but still lags when opens up sites like this with loads of JS effects.\n\n> What do these developers develop on then? Because I can't possibly imagine they experience this lag, otherwise they wouldn't be so stupid as to implement it............\n\nMaybe it's just because I tend to have lots of tabs open, and people develop this with a single tab in safari and test on iPads. But yeah, I'd like to see what kind of setup one needs for these things to run fluently.", "id": "dalss2h"}, {"comment": "If written in the native world sure it wouldn't be slow.\nBut if you're doing that you know what the platform it is running on and more importantly can actually optimise it.\n\nBut no matter how many millions of dollars you throw at a JS engine, its still JS. It is simply not designed to be fast or used for anything more than a little bit of hacky interaction scripting and people need to accept this.", "id": "dalsnck"}, {"comment": "Probably left in from when the \"parallax\" fad was still going.", "id": "dalwa20"}, {"comment": "> ERE LET ME CANCEL THAT AND JUMP TO THE NEXT SECTION AND LOCK YOU IN PLACE\n\n*cough* LinkedIn ioS app *cough*", "id": "dakw60w"}, {"comment": "Smooth scrolling? Like, when you scroll by pixel instead of by line?", "id": "dalgvlc"}, {"comment": "It's still scrolling by line, but slower, so your eyes can easily follow the flow.  Firefox does it automatically anyway, to an extent, so sites shouldn't be messing with it.", "id": "dalsmom"}, {"comment": "Depends, some mice support per-pixel scrolling. You know when in one browser it does that and all other browsers and apps still scroll by line after you've turned it around twice.", "id": "dalulgy"}, {"comment": "Not devs, bosses.", "id": "dakk340"}, {"comment": "[deleted]", "id": "daklrwb"}, {"comment": "Devs implement, because if they don't they wont have a job.  \nI'm sure there a lot of devs that do that, but I would argue majority is from a boss that wan'ts the newest coolest thing, even if no one else wants it.", "id": "daklviy"}, {"comment": "Can confirm.  I hate popovers with a passion.  But if the CEO wants it, marketing approves and the UX folks are okay with it, then _fuck_, I guess I have to reluctantly implement it.", "id": "dalsnp5"}, {"comment": "Maybe your boss sees it from a different perspective. Try talking to them about why you think it's not a good idea, perhaps you'll learn something you didn't and understand why the feature is needed or they will learn why implementing it is not a good idea. ", "id": "daknb8c"}, {"comment": "I already know everything in life, it's ok.", "id": "dakngv1"}, {"comment": "Thanks Donald Trump.  Please tell us more.", "id": "dalinzj"}, {"comment": "Ahh, you must be a dev. Or a boss. Hmmm... ", "id": "daktm5r"}, {"comment": "Thanks to my ego, I'm both!", "id": "dakvdc7"}, {"comment": "Glad I scanned the comments before clicking the link. Thanks for the heads up!", "id": "dakjq4p"}, {"comment": "Nerds won't read anything on a site that doesn't measure up.  We must have standards.", "id": "dakmpwo"}, {"comment": "I think of it as voting with my (ad revenue) wallet. If I continue to consume content from sites that I think give a poor user experience, then I'm not giving those site owners any reason to make improvements.", "id": "daks84r"}, {"comment": "Thanks to that, `ctrl+scroll` to zoom doesn't work. It's great when people decide to reinvent the [scroll]wheel and end up missing standard features.\n\nWeirdly it also seems to scroll further when going up than when going down, if you try scroll up by 1 then down by 1, you end up at a different place...", "id": "dal2gfc"}, {"comment": "> Thanks to that, ctrl+scroll to zoom doesn't work\n\n'Cause fuck people with eyesight problems!", "id": "dalmuhr"}, {"comment": "The direction you scroll first doesn't matter. It is about the speed at which you scroll in the opposite direction. It causes the new movement to happen when the old one isn't done yet, and thus it arrives at a spot that is before your starting point.", "id": "dal44i0"}, {"comment": "As a bonus these sites also tend to disable the OSX \"two finger to the right\" back button as they seem to catch ALL \"scroll\" events. (In Chrome at least).", "id": "dalsnah"}, {"comment": "Scroll is completely broken for me lol.", "id": "dal9kns"}, {"comment": "I can't even scroll at all without using the scrollbar.", "id": "dakzytk"}, {"comment": "What's the problem? I opened it on Chrome and Firefox and neither had any weird scrolling behavior (that I can tell)", "id": "dakl6hq"}, {"comment": "Chrome here. I could feel it.", "id": "daklc9w"}, {"comment": "Okay.... A little description would be helpful, I think", "id": "dakmgfz"}, {"comment": "I use 2-finger scroll on OS X. The page scrolled at about twice the speed that I'm used to, which made reading more difficult than usual. I've no idea what the purpose of modifying page scrolling can even be.", "id": "daknl5v"}, {"comment": "I'm seeing the same on chrome on os x.\nIf a site is going to make it hard for me to read it, I'm not going to bother.", "id": "dakppbv"}, {"comment": "It's weird to explain, but when I scroll on Reddit for example, it's very responsive and brute, in the sense that, it quickly stops and starts scrolling when I turn the mouse wheel. \n\nIt's not that breaking like other websites, but I can def. feel it. ", "id": "dakpu0d"}, {"comment": "Scrolling on reddit is instant and happens in chunks. i.e. I move my scroll wheel one click and the site instantly scrolls down ~7 lines. No accel/decel or anything fancy.\n\nScrolling on this website has sort of a weird acceleration/deceleration to it. Instead of being an instant stop, the page 'slows down' instead of an abrupt stop.\n\nIn this particular case, it is not overly bad, but it still interferes with my ability to quickly skip through the article as it is very hard to read when there is movement of the text, so I have to wait an extra half second every time I scroll before I can start reading again as I have to wait for the scrolling to completely stop.", "id": "dal1tx6"}, {"comment": "What's the modification here?  Is it still there?", "id": "dakybxn"}], [{"comment": "I love solving bugs like this, seemingly impossible, in the end the reason is generally simple, and the fix satisfying.", "id": "dakgt82"}, {"comment": "Yeah, it truly is a great feeling to solve a bug like that, albeit a tad bittersweet when the reason turns out to be something you didn't pay much attention to because you were certain you understood what it did and that it couldn't be important.", "id": "dakhgba"}, {"comment": "That feeling when that arr[1] was a arr[l] the whole time after debugging for hours. ", "id": "dal09jz"}, {"comment": "A similar bug once cost me *two weeks* on a uni project. That mix of disbelief, happiness and self-loathing once I finally saw the mistake is a feeling I will never forget... I might have actually gone through all five stages of grief in a matter of seconds.", "id": "dalfy0u"}, {"comment": "Nope. Were opposites on that regard. I find myself saying \"you motherfucker\" quite a bit. ", "id": "dal078t"}], [{"comment": "Is the bug the gigantic web font preventing me from reading this article?", "id": "daktgdq"}], [{"comment": "This is really cool. Ive been dealing with a memory problem in nodejs the last couple week. Not an easy problem to fix. Heap snapshots feel like they're not usable in the dev tools. But I didn't notice you can use them the way it mentioned in the article.\n\nIn the article it says valgrind's Memcheck replaces malloc with its own function. I might not be totally right but I don't think v8 uses this? I noticed during garbage collections munmap gets called. I never saw free or those. Does valgrind's memcheck also modify mmap and munmap? Does v8 actually use malloc and im just wrong?\n\n", "id": "dakmss1"}], [{"comment": "I literally can not scroll down with my scroll wheel on this site... Up works fine.", "id": "dal5b3t"}, {"comment": "Ironically the site looks fine and scrolls fine with NoScript. Usually I'm in the minority because NoScript breaks the \"modern\" web for me (and I'm fine with that), for once it makes a site usable.", "id": "damatue"}, {"comment": "Well, I think that scroll hijacking is the one area where NoScript would help.", "id": "damdbne"}], [{"comment": "I'm not really familiar with the tooling around node.js, but couldn't this be resolved by taking a core dump of the whole process at the moment of the crash, and exploring the memory to see which objects take up space on the heap?", "id": "dal1xgb"}], [{"comment": "I think I am missing something: would someone explain me why they put \n\n    return  scope.Close(Undefined());\n\nin void functions in the first place?", "id": "dalt53h"}, {"comment": "There weren't any `return`s in those functions in the library causing the problem, just `scope.Close(Undefined());`. The mistake was the assumption that scope needs to be closed explicitly with some value.", "id": "daltjwd"}, {"comment": "I think I get it now - they thought that HandleScope should be explicitly closed in order to sweep all locals/handles within this scope  and forgot entirely about HandleScope destructor. And because Close function needs to be provided with some handle they chose Undefined. Am I right?", "id": "damcgof"}, {"comment": "Yep, that's exactly the case.", "id": "damexgq"}], [{"comment": "What a shitty website design.", "id": "daltyf9"}], [{"comment": "Is there a TL;DR; ?", "id": "dalwjfg"}]]], "5fuic0": ["The Cookbook Method of Learning Programming Languages (x-post from /r/learnprogramming)", "2016-12-01 07:09:18", 0, "https://youtu.be/8vmUTz6it5A", [], []], "5g1mfc": ["Dolphin Progress Report: November 2016", "2016-12-02 08:32:44", 239, "https://dolphin-emu.org/blog/2016/12/01/dolphin-progress-report-november-2016/", [[41, "Those extremely high resolution screenshots are very very cool. Love reading these every month despite having never used the software.\ud83d\ude03"], [2, "> removed the anti-emulation hooks\n\nWhat techniques did the Homebrew Channel use here?  I looked through the public commit history and didn't notice it."], [-11, "They need to change the name, the Dolphin Smalltalk environment came first."], [-10, "I'm not sure if this is *just me* but I don't think /r/programming needs an update every month of changes in dolphin. It's nice once in a while but it seems that each month, it's a race to who can get the inevitable karma first instead of \"hey this might actually have something super interesting in it\"\n\nCould be wrong though.\n"]], [[{"comment": "Those extremely high resolution screenshots are very very cool. Love reading these every month despite having never used the software.\ud83d\ude03", "id": "daowi8z"}, {"comment": ">29929x16368\n\nYou weren't kidding about high-res.", "id": "daoxjbt"}, {"comment": "Wait, reddit has now smiles?\n", "id": "daoxtmu"}, {"comment": "Not reddit... unicode \ud83d\ude40\n\nView source and you'll see it there too. I can't wait for the first emoticon based programming language (just kidding i'll kill myself \ud83d\udc4d)", "id": "daoxwms"}, {"comment": "[better get the noose ready](http://www.emojicode.org/)", "id": "daoxyk6"}, {"comment": "goodbye, reddit", "id": "daoy7kp"}, {"comment": "Holy fuck I want to learn this language now", "id": "dap4mqn"}, {"comment": "RIP", "id": "daprjjf"}, {"comment": "Oh, I thought this was going to be [HeartForth](http://neilk.net/blog/2015/02/14/heartforth/).", "id": "dapuhnh"}, {"comment": "[Close (and more stupid) enough?](https://github.com/LtHummus/KappaLang)", "id": "dap06ll"}, {"comment": "Well there already was a social network only in emoji, called [Emojili.](https://www.youtube.com/watch?v=iyybPvRsEuY)", "id": "dap0nee"}, {"comment": "Not Reddit. Computers. ", "id": "dap198b"}, {"comment": "Whatever, i don't recall seeing yellow faces before.", "id": "dap1gwq"}, {"comment": "Whatever, then you weren't typing them. It's just Unicode. Your browser takes care of displaying it. No different than:\n\n* diacritical marks (e.g. accents) \u094d \u0d4d \u0c4d \u0dca \u0ccd\n* hugs from Canada! \ud83c\udde8\ud83c\udde6\n* \u0287x\u01dd\u0287 u\u028dop \u01ddp\u0131sdn\n* dingbats and emoji \ud83d\ude97\ud83d\udebd\ud83d\ude21\ud83d\ude1c\ud83d\ude4a\ud83d\ude33\n\n\n* .\n\n\n\n* Z\u0328\u0322\u0321\u0322\u0320\u0319\u0353\u032b\u0333\u033f\u0309\u0302\u0300\u0305\u034c\u0305\u030f\u0342\u0360\u0345\u0105\u0327\u031b\u034d\u0319\u034e\u031c\u0330\u0329\u033b\u031d\u0314\u030c\u0300\u0350\u0313\u0352\u0311\u031a\u031a\u013c\u0347\u0323\u031c\u031d\u0353\u0329\u034d\u0339\u0350\u033f\u0306\u0313\u0312\u0304\u0308\u0301\u0313\u0314\u0360\u0345g\u0328\u0321\u0322\u0327\u0320\u0329\u031e\u0317\u0359\u0355\u0351\u030e\u035b\u030a\u0308\u0301\u0313\u033e\u0300\u030d\u030co\u0321\u031d\u0353\u032c\u0331\u0325\u033a\u0333\u031f\u031c\u033f\u0301\u0346\u0309\u035b\u035b\u0302\u033d\u033e\u031a \u0321\u031b\u0347\u0329\u0333\u034e\u0317\u0359\u0339\u0319\u033c\u034b\u0313\u0308\u0301\u0308\u0301\u0308\u0301\u033d\u0358\u031a\u035dt\u0328\u033c\u0353\u0325\u032f\u0331\u0320\u031d\u031c\u0339\u0352\u030e\u034b\u033d\u030d\u034c\u0357\u030d\u030d\u0313\u00e9\u0321\u031b\u031f\u032a\u0320\u0354\u0349\u033b\u033c\u0339\u034d\u030f\u030c\u035b\u0314\u0300\u0310\u0308\u0301\u0305x\u0326\u0348\u035a\u035a\u034e\u0317\u0316\u034d\u0319\u0310\u033d\u0308\u0314\u0301\u0308\u0304\u0350\u0313\u0302\u035ct\u0321\u0328\u034d\u0329\u0320\u034e\u033a\u0319\u033c\u0320\u0352\u0300\u033e\u0351\u035b\u0303\u0303\u033e\u030c\u0352 \u0328\u0322\u0318\u0318\u0326\u0318\u031d\u0317\u0319\u0313\u0303\u0301\u0309\u0357\u033e\u0352\u030b\u0305\u031a\u0345a\u0353\u031e\u031d\u033c\u034e\u0323\u0323\u033c\u031e\u0346\u030f\u0301\u034c\u0308\u0300\u0313\u031a\u035c\u035d\u0360n\u031b\u031f\u0324\u0348\u0332\u033a\u0320\u034d\u0330\u0318\u031e\u0308\u0301\u0300\u0351\u030b\u0306\u030a\u0311\u0358\u035dd\u032a\u0324\u0325\u0355\u0318\u035a\u0359\u0331\u0333\u032e\u034b\u033d\u034b\u0346\u0307\u0300\u0313\u0300\u034b\u031a \u0330\u0359\u0347\u033b\u032e\u0318\u032c\u0348\u032b\u0302\u030b\u034b\u0306\u0350\u030a\u0342\u030e\u0315\u0315\u0345\u01eb\u031b\u0326\u0347\u032b\u0318\u0353\u0324\u0333\u031f\u033a\u0309\u0357\u0308\u0301\u0313\u0309\u0346\u034a\u030d\u0351\u1e97\u0356\u0317\u032d\u031c\u0330\u032f\u0318\u032c\u0309\u030a\u0309\u0304\u0351\u034c\u0306\u034b\u0300\u035c\u0345h\u034e\u0324\u033c\u0354\u032c\u033a\u0347\u0355\u0317\u034d\u030e\u0307\u030f\u033d\u030d\u034b\u0308\u0301\u0311\u0315\u035d\u0229\u034d\u0349\u0324\u032c\u0319\u0331\u032a\u0355\u0355\u034c\u030e\u035b\u034c\u0342\u0300\u030b\u0304\u034a\u031ar\u0318\u034e\u0356\u035a\u034e\u0320\u0326\u033c\u031f\u0350\u0300\u034b\u030c\u0314\u030f\u0306\u0309\u0308\u0301\u0358\u0345 \u0321\u034d\u032d\u0333\u0333\u032b\u0318\u034e\u0323\u0348\u0311\u0300\u0300\u0313\u0350\u034c\u030d\u033f\u0315\u035d\u0163\u0329\u0320\u0353\u0349\u032d\u034d\u0318\u032f\u0342\u0306\u0346\u0352\u0309\u030a\u0346\u031a\u035c\u035d\u0360\u1e29\u031c\u0333\u032f\u032c\u0318\u0326\u0349\u034e\u0347\u0302\u030d\u0302\u0311\u033f\u030b\u0312\u0300\u031a\u0315i\u0327\u0353\u0354\u032f\u0326\u031c\u034e\u0318\u0325\u033c\u034c\u0313\u0351\u030e\u0314\u030b\u035b\u0313\u0315\u035dn\u031b\u0325\u034e\u032c\u0349\u0316\u033c\u0316\u034d\u0354\u0314\u030b\u0306\u034b\u033e\u033e\u0314\u0358\u035c\u035dg\u032e\u0319\u0326\u0359\u033c\u0332\u0348\u0355\u030a\u0313\u033d\u0306\u0352\u0352\u0310\u0305\u031a\u0358\u0345\u0345s\u0321\u031c\u0326\u032f\u0347\u0329\u032d\u0324\u0330\u0320\u0300\u033f\u033e\u0306\u030f\u030e\u0300\u030c\u035d\u035d", "id": "dapecbk"}, {"comment": "Firefox 50 has added a color emoji font", "id": "dapeqmz"}, {"comment": "Thanks, that explain it.", "id": "dapk5ju"}], [{"comment": "> removed the anti-emulation hooks\n\nWhat techniques did the Homebrew Channel use here?  I looked through the public commit history and didn't notice it.", "id": "daq0gkz"}], [{"comment": "They need to change the name, the Dolphin Smalltalk environment came first.", "id": "dapl48q"}, {"comment": "I think the animal came first", "id": "dapnjot"}, {"comment": "Dolphin is the codename for the GameCube.  Nintendo has a lot of Dolphin stuff from the GameCube era; Delfino Island in Super Mario Sunshine for one example.  \n\nThat is why it's named Dolphin Emulator.", "id": "dapts2g"}, {"comment": "Ah, makes sense. I just got so excited to see a new version of Dolphin, only to find out it's NOT the smalltalk environment I used to code in.", "id": "daqba63"}, {"comment": "Ah, sorry :(\n\nI think maybe we'll change the link to say \"Dolphin Emulator Progress Report\" or something... but, I'd have to get everyone to agree to that!", "id": "daqfld7"}, {"comment": "Did it though? The dolphin emulator came out in 2003. \n\nIts hard to find the exact start date of \"Dolphin Smalltalk\" but the best I can find is that version 3 came out around 2012.", "id": "dapqfqt"}, {"comment": "I was using it in 2001 ;). I see some papers on their site that go back to 1999.", "id": "daqb9br"}], [{"comment": "I'm not sure if this is *just me* but I don't think /r/programming needs an update every month of changes in dolphin. It's nice once in a while but it seems that each month, it's a race to who can get the inevitable karma first instead of \"hey this might actually have something super interesting in it\"\n\nCould be wrong though.\n", "id": "daoum8o"}, {"comment": "I kinda agree with you, but on the other hand its more interesting and more programming related than most of the shit that's posted to this sub.", "id": "daovrvo"}, {"comment": "Agreed.", "id": "daowym7"}, {"comment": "A month. Once a MONTH.", "id": "daoxd5c"}, {"comment": "I think dolphin is the best open source project I have EVER seen when it comes to communication. Their testing is insane, and I love to read about it. The technique they employ is an inspiration. I think I learn something from every report, and this is certainly not the sort of work I do. In short, I'm not ever bothered to see these posts.", "id": "dap0ie4"}, {"comment": "Seriously. Im surprised so many major projects dont handle these things as well as Dolphin. ", "id": "daphqr4"}, {"comment": "No, the annoying thing is that every single month the top comment is \"i dont do anything related to dolhpin or games but DAE luv reeadin these reports <33\"", "id": "daox3x8"}, {"comment": "S-sorry \n..but they are very fancy.", "id": "dap2joc"}, {"comment": "We need to get these low-energy posts outta here so they stop taking karma from the REAL articles like the \"Why JS is bad\" medium articles and \"Announcing ____\" links to github projets with no tests that are posted daily. MAKE /R/PROGRAMMING GREAT AGAIN.", "id": "dap3sb8"}, {"comment": "I think those suck too. Actually I don't think the dolphin posts suck but it's not like the title is \"check out this awesome bug dolphin managed to solve!\"\n\nIt's generally \"here's dolphin, yet again. Maybe I didn't even read the article. Maybe there's something remarkable in here. Maybe it's just the same ol' same ol'\"\n\nWhich just sounds like OP is just dumping the post rather than trying to contribute to the /r/programming conversation in a meaningful way.", "id": "dap4rq4"}, {"comment": "True. OP just wants those sweet, sweet internet points.\n\nBut I'd prefer they keep posting. Let up/downvotes do the judging. \n\nOne of my favorite things about reddit is that a seemingly mundane post can blossom over some info OP missed (ie: didn't read, but someone else did) in the article or some tangential conversation in the comments section. If we had less content being submitted or the standard of quality for a post title was higher we'd miss opportunities to unearth gems.\n\nAgain, if its truly shit and there's nothing to talk about downvotes on the house. But upvotes for the interesting stuff and interesting content regardless of OP's intentions.\n\nYou miss 100% of the internet arguments never posted.", "id": "dap53dv"}, {"comment": "All fair points but we both know that upvotes/downvotes aren't the best system for judging. Just look at the recent \"awesome list of interview questions\" posts on here a couple days ago. That list was not well curated at all and the comments reflected that yet it still hit the front page. \n\n", "id": "dap7mwl"}, {"comment": "I think it's posted here because it's an open source program and you can see the code behind every change.  There's not really any super interesting \"how someone tackled programming challenge x\" in this report, though.\n\nThe programming challenge of Dolphin that'll probably get the most actual attention (since it affects most modern emulators to some degree,) is how to handle shader generation in games where we don't know what shaders are going to be needed.  There's no (known) perfect solution, even assuming infinite programming skill/time.  When one of the solutions hit, I expect it to be more popular in the programming circles than the standard monthly reports.", "id": "daoy3ag"}, {"comment": "Once per month is once in a while.  Sorry if it seems too predictable to you.", "id": "daoy7wk"}, {"comment": "Its one post a month. If you dont like it downvote and move on. ", "id": "daphnwg"}, {"comment": "I think it's a bit frequent/spammy myself. Imagine if *every* programming project did this ... :-o\n\nBut the score suggests it is reasonably well received here. \u00af\\\\\\_(\u30c4)\\_\\/\u00af ", "id": "daoy1p7"}, {"comment": "If every programming project did this with that level of dedication I'd read these dev blogs more often.", "id": "daoz8w1"}, {"comment": "Absolutely. We all know where /r/emulation is when we want to check up on different emulators and their progression(or lack of).", "id": "daoz7ap"}]]], "5gbp24": ["Learning to See - machine learning and artificial intelligence", "2016-12-03 23:58:30", 15, "https://www.youtube.com/watch?v=i8D90DkCLhI&index=1&list=PLiaHhY2iBX9ihLasvE8BKnS2Xg8AhY6iV", [[2, "Cross posted from /r/artificial\n\nhttps://www.reddit.com/r/artificial/comments/5gapmf/learning_to_see_machine_learning_and_artificial/"]], [[{"comment": "Cross posted from /r/artificial\n\nhttps://www.reddit.com/r/artificial/comments/5gapmf/learning_to_see_machine_learning_and_artificial/", "id": "daqy10c"}]]], "5fyc39": ["I made a little script as a hobby project. It automates the setting up of a Ubuntu server.", "2016-12-01 21:48:27", 0, "https://github.com/jasonheecs/ubuntu-server-setup", [[-14, "So you wrote this instead of using one of the tens of thousands of pre-existing solutions (puppet, chef, ansible, etc) to provision a machine AND it hardcodes stuff like timezone to singapore (is not configurable without editing the setup.sh)? This is junk and you should feel bad for writing it."]], [[{"comment": "So you wrote this instead of using one of the tens of thousands of pre-existing solutions (puppet, chef, ansible, etc) to provision a machine AND it hardcodes stuff like timezone to singapore (is not configurable without editing the setup.sh)? This is junk and you should feel bad for writing it.", "id": "daoe6ij"}, {"comment": "You may not have a use for it, but it certainly isn't junk. Everything starts somewhere. ", "id": "daogfi3"}, {"comment": "For home or hobby use I think those options are complicated. Also, and I may be wrong, but those don't install an SSH key. You could use this after the initial install then use your favorite Chef Puppets.", "id": "dap0vui"}]]], "5fq4d9": ["Google's new public NTP servers provide smeared time", "2016-11-30 18:17:46", 1106, "https://cloudplatform.googleblog.com/2016/11/making-every-leap-second-count-with-our-new-public-NTP-servers.html", [[270, "Ah yeah, this. Just a few days ago I found myself going through the timezone data on my system, and to my surprise none of the files appeared to contain any leap seconds. Turns out real-world \"unix timestamps\" are much more hairy than the common definition suggests. Here's a good read on the subject:\n\nhttp://www.madore.org/~david/computers/unix-leap-seconds.html"], [119, "When time changes slightly during NTP sync, Windows actually accelerates/decelerates clock to adjust to the new time instead of resetting the clock abruptly (and as a result, for example, expire a lot of timers and potentially break application). It's been doing it for years.\n\nSo if NTP simply returned the same time during the leap secret interval, twice in the consecutive seconds, Windows would have handled it correctly."], [74, "\"Smeared time\" almost sounds like a bug rather than desirable behavior."], [17, "Can anyone comment on how this will interact with non-smeared NTP or GPS time sources?\n\nIt was fine and dandy when they did it as part of a closed system, but this looks like a public service that could use some standards group discussion before being dumped on the public (and time-naive) Internet.\n\n(And because its Google, you can bet a some decent % of networks will take this up, only to discover next leap second that some synchronization-sensitive thing got impacted)\n\nI can't actually think of any time-dependent service that would be sensitive to desynchronization across a WAN on the order of a second, but I'd be surprised if no such service or protocol existed. The kind of thing I'm thinking about is something like HOTP or Kerberos, where both parties must agree on current time. However neither of those protocols would be sensitive to a change of one second "], [18, "Does anyone care to guess what unexpected problems *time smearing* will cause?\n\nI won't be surprised if certain NTP consumers start to break a trust with the server."], [13, "Considering Reddit crashed due to a leap second bug, this can only be a good thing."], [7, "**Smeared Time**: very clever solution -- but that's what I have come to expect from Google."], [6, "So, just out of curiousity...time1.google.com through time4.google.com all resolve to public IP addresses that are fairly close together.  At least, from where I am, using 8.8.8.8 as the DNS server.  \n\n216.239.35.0, .4, .8, and .12.\n\nBut looking at the IPv6 addresses, they are\n\n\n\nFQDN| IPv4 | IPv6\n---|---|----\ntime1.google.com| 216.239.35.0| 2001:4860:4806::\ntime2.google.com| 216.239.35.4| 2001:4860:4806:4::\ntime3.google.com| 216.239.35.8| 2001:4860:4806:8::\ntime4.google.com| 216.239.35.12| 2001:4860:4806:c::\n\nAre they actually putting these in an IPv6 /24?  That seems like an awfully large subnet to be using."], [8, "I'll just quote [Larry Osterman's blog post on time smearing in Windows](https://blogs.msdn.microsoft.com/larryosterman/2004/04/02/one-in-a-million-redux/):\n\n> Time on a PC is kept via counting the number of clock interrupts that have occurred.  Every PC contains a crystal that operates a clock chip that interrupts the CPU approximately every 10 milliseconds. So NT increments the system time by 10 milliseconds every time it receives a hardware interrupt.\n> \n> But the problem is that the crystals used internally in the system have a failure rate of as high as 100ppm \u2013 in other words, 100 times every million clock ticks, the clock chip won\u2019t actually generate an interrupt.  For most applications, this isn\u2019t a significant problem \u2013 instead of the system context switching every 10 milliseconds, every once in a while, the system context switches in 20 milliseconds.\n> \n> But for time, this is an utter disaster.  Given a 10 millisecond timer, there are 8,640,000 clock ticks per day.  If 100 per million clock ticks are missed, then that means that the system misses 864,000 clock ticks, which is about 864 seconds.  That\u2019s over fourteen minutes per day!\n> \n> Now, in practice, the amount of drift is actually much lower, but still it can be quite significant.\n> \n> So how does NT fix this?  Well, back in NT 3.1, once an hour, NT would interrogate the on-board real time clock chip (the hardware that keeps your date and time up-to-date even when your computer is powered off).  If the system time differed from the real time clock chip, then it would simply reset the system time to match the time on the RTC.  Which meant that time could jump forward or backwards significantly \u2013 so it was possible for the assert to fire in the following code:\n> \n>     GetFileTime(&time1);\n>     GetFileTime(&time2);\n>     ASSERT(CompareFileTime(&time1, &time2) < 0);\n> \n> Clearly this was an unacceptable situation, so something had to be done to fix it.  The fix (in NT 3.5) was to change how time was accounted for in the system.  In the old system, every clock interrupt bumped the time by 10 milliseconds.  With the change, when the system measured the time from the RTC, instead of applying the new time immediately, it calculated an adjustment to the 10 millisecond amount.  If the clock was behind, each tick might count as 11 or 12 milliseconds.  If the clock was head, each tick might count for 8 or 9 milliseconds.\n> \n> This is actually pretty cool (ok, I think it\u2019s amazingly clever), but again, there can be problems.  What if you\u2019re using the current time and some high performance counter (like [**QueryPerformanceCounter**](https://msdn.microsoft.com/en-us/library/windows/desktop/ms644904.aspx))?  Then the clock drift will cause your measurements to be skewed from the real time measurements.  We actually ran into this problem in the SCP project \u2013 our clock tests were showing that the clock on the SCP chips was drifting, but we couldn\u2019t see why it was happening \u2013 it turned out that the SCP chip clock wasn\u2019t drifting, it was the PC\u2019s clock that was drifting.\n> \n> To allow people to compensate for this drift, a new API was added: [**GetSystemTimeAdjustment**](https://msdn.microsoft.com/en-us/library/windows/desktop/ms724394.aspx).  The **GetSystemTimeAdjustment** API allows you to determine the clock interrupt frequency (that\u2019s the **lpTimeIncrement** parameter), and the adjustment that\u2019s applied to each tick (that\u2019s the **lpTimeAdjustment** parameter)."], [5, "ITT: people with no goddamn clue how clocks work.\n\nComputers measure time by jiggling rocks. These rocks jiggle pretty okay, but not great, so they regularly resynchronize.\n\nThe time smear is on the order of 1/100th the error that end user devices already have.\n\nIf you have timekeeping needs that this smear breaks, but you're using a standard crystal oscillator clock, you're either stupid, wrong, or lying.\n\nTimekeeping is a hard problem. Many of you nits are being anti-vaxxers about it. Cut it out."], [3, "Is google prepared to grow the capacity of time.google.com as needed to keep up with everyone in the world switching to it for convenience?\n\nThe same way many of us are using 8.8.8.8 as DNS that *just works* where ever we are."], [4, "ELI5 anyone ?"], [3, "    struct tm {\n            int     tm_sec;         /* seconds after the minute [0-60] */\n    [\u2026]\n\ntime.h\n"], [4, "I'm laughing at this immensely.  And not just a chuckly.  A real good, hilarious laugh.  Here's why:\n\nI spent 15 years a a professional timekeeper in motorsport.\n\nAnd many of the modern decoders used for timing - they synchronize, and they don't account for this.\n\nNow, I know about this.  And my systems to.  But it's hilarious when you come across a system that doesn't.  And here's why.\n\nLet's say you're running a qualifying session, and everyones doing lap times around 1:02.0000.  And you have a leap-second that's going to occurr at 3:59:59pm.  Annnnd... the system doesn't know about it.  Now in the hardware I use this was never a problem.  We set a clock once, and never re-synchronize it until told, time is taken from a delta to that original time.  But there's a major system in use around the world which doesn't.  In fact they keep resyncing to GPS.  Constantly.\n\nNow depending on your implementation - like, say, if you just subtracted unixtime from unixtime, well... maybe you have everyone who did a lap across that boundary doing a lap a second longer.\n\nOr maybe the leap second is duplicated... and now everyone's setting qualifying lap records.\n\nFun times.  I've seen this happen :)"], [2, "But why does the leap second have to be while we're supposed to be kissing someone at new years? Now we have to be upgrading linux... ugh.    (joking! you knew that...)"], [2, "NTP should have used TAI. UTC should be for display / storage, not synchronisation."], [1, "I'm still surprised we borked this up so badly. In the 90s we got leapnseconds much more frequently and things worked. \n\nNow we crash the internet with a leap second!"], [1, "Or they could have just made the last second of the year be two seconds. At least only one timestamp will be wrong then, and not all of them; and a data spike (or whatever you are doing) at the last second of the year is way more obviously a special case.\n\nI guess they would argue the 0.00sth% deviance is not much; but by the end of the year, the clocks will be a full second behind - and will have been for close to a second for some time.\n\nIt\u2019s probably not as bad as this counter-argumentation makes it out to be though\u2026 \u00af\\_(\u30c4)_/\u00af"], [1, "Someone please explain, why this would not work(psedocode/obviously implemented better):\n\n    If (leapsecond == true && seconds == 30){\n\n            Seconds = seconds -1;\n\n           leapsecond = false;\n\n    }"], [1, "How did I not know Google had public NTP servers. Of course they do. "], [1, "I get that there's something interesting about that approach, but that seems like it might not be the best plan. Also I though NTP was supposed to be centralized so everyone has the same time, so having different big providers especially ones with modified time keeping seems counter-productive."], [1, "If all the clocks are using smeared time how do we know we actually used it and they didn't just lie to us?"], [1, "Somehow it bothers me that the smearing window is 10h before and after, instead of 12h which would make a nice round day."], [1, "My cloud backup started overwriting the files on my computer every time I made a change. I think its due to some kind of timezone fuckup at their place."], [1, "Sounds good that the servers are available, but considering that one of the main reasons to use a time server is to be in sync *with other people*,  it might be a reason to avoid them around the 1st.\n"]], [[{"comment": "Ah yeah, this. Just a few days ago I found myself going through the timezone data on my system, and to my surprise none of the files appeared to contain any leap seconds. Turns out real-world \"unix timestamps\" are much more hairy than the common definition suggests. Here's a good read on the subject:\n\nhttp://www.madore.org/~david/computers/unix-leap-seconds.html", "id": "dam9lmj"}, {"comment": "Ho. Lee. Shit.", "id": "damkmk0"}, {"comment": "[Yeah](https://www.youtube.com/watch?v=Uqjg8Kk1HXo)", "id": "damnea6"}, {"comment": "I thought I knew at least the scope of all the problems of timekeeping, but no, there's even more horrors. \n\nBut honestly, why do we even need leap seconds, or even leap days? How many devices (and/or humans) actually need both that kind of accuracy and that incessant synchronization with our planet's position relative the sun? ", "id": "dampce5"}, {"comment": "> How many devices (and/or humans) actually need both that kind of accuracy and that incessant synchronization with our planet's position relative the sun? \n\nHistorically, we've always needed accuracy to roughly a day for agriculture: Being able to determine the start of seasons is a very handy way to know when to start planting/harvesting stuff. Around that evolved religious rituals tied to specific dates in specific, so even more stuff was tied to syncing calendars to Earth's position ([like Easter](https://en.wikipedia.org/wiki/Computus)) and leap days as well as [bigger calendar reforms](https://en.wikipedia.org/wiki/Gregorian_calendar) were thrown in where necessary.\n\nLeap seconds are a whole different problem: Earth's rotation around its own axis is irregular, so days are differently long. A few seconds won't hurt, but over time it would drift apart until it's minutes (enough to fuck with things depending on solar/star alignment) or hours (enough to fuck with everything), so leap seconds were picked because they're the most harmless to mess with.", "id": "damqlhk"}, {"comment": "Couldn't we just eliminate leap seconds and just switch our UTC offsets after a few centuries if they've added up enough? Applications that need it like astronomy can keep track of the seconds the earth's rotation is off by as an offset.", "id": "damx6rv"}, {"comment": "If we accumulate a large error, everyone is going to want to procrastinate on dealing with it. They will think, \"Why should we be the generation that has to pay the cost of making a 15 minute jump, when we can just leave a 15.01 minute jump for the next generation, which is not any harder to solve?\" If you do it that way, who knows when it will ever get corrected because the cost of waiting is so low in comparison to the cost of taking action.\n\nBy doing it this way, humanity has to deal with the issue much more often, but each time it is very manageable and within what people will tolerate without saying no to it.", "id": "damxlx8"}, {"comment": "> \"Why should we be the generation that has to pay the cost of making a 15 minute jump, when we can just leave a 15.01 minute jump for the next generation, which is not any harder to solve?\"\n\nAnd this is how we ended up needing to subtract ten whole days from October 1582.", "id": "dan885u"}, {"comment": "While that was the case for updating the calendar for the leap second case we are talking about 20mins for the next couple of millenia.", "id": "danegst"}, {"comment": "Since you're speaking English, that should be September, 1752.", "id": "danm75p"}, {"comment": "what the?! I've read this far, and now I'm afraid to ask.", "id": "dansanf"}, {"comment": "OK so people started realizing the Julian calendar was getting out of sync with the seasons (particularly the vernal equinox used to celebrate Easter) which basically fucked with the Catholics. The Julian calendar was \"close enough\" for Romans but the slight difference in year length (somewhere in the order for 10 minutes) over a millenia starts to add up.\n\nEnter a guy named Christopher Clavius who realized the year was slightly shorter than we thought. He did the math, realized the leap years were wrong presented it to the church and Pope Gregory XIII went \"yep, that solves everything now\". But then to truly fix the issue they had to wind the changes to account for the extra 10 minutes ALLLLLL the way back to the third century when all this shit was figured out. That ended up being 10 days. So the Catholics all went to the Gregorian calendar and things got fucked up.\n\nNow about sixty years before this comes Henry the Eighth I am I am and I'm here to fuck up your calendars. Not deliberately. But a little something called the protestant reformation happened which split the church with English ruled countries heading Protestant while staying Julian and the rest of the continent staying Catholic (for now! Hi Luther!). But then the Protestants eventually realized that the Catholics were right when the shit started getting even more out of whack with the equinox. So the Protestants want to start getting in on this shit. But they don't until 1752 and by then they have to delete TWELVE days. And the Eastern Orthodox guys and then finally, the Coptic Christians fell into line.\n\nNot all fell in line equally mind you. Some kept the Julian dates and just transposed them directly but fixed onto the Gregorian calendar (which is why Russia celebrates Christmas on January 7th and Armenia on the 6th), some of them let Julian dates slide moving them on the Gregorian calendar when necessary (The Armenian Patriarchate of Jerusalem celebrates the Theophany as Christmas on January 19), and some wound the dates back to their approximate \"proper\" dates.\n\nIsn't time a really fun yet fucked up thing?", "id": "dany42e"}, {"comment": "And since we're on proggit: this is why SQL Server's minimum value for `datetime` is January 1st, 1753.", "id": "dao266e"}, {"comment": "I'm suddenly less annoyed by DST...wow. just wow. thank you for the generous history lesson, btw", "id": "dao3m6v"}, {"comment": "> So the Protestants want to start getting in on this shit. But they don't until 1752\n\nGreat Britain was later than most of the other Protestant countries -- the Netherlands and most states in Germany and Scandinavia had already switched over by that point.\n\n> And the Eastern Orthodox guys \n\nWell, eventually:  Russia adopted the Gregorian calendar in 1918.\n\nFinland apparently switched over along with Sweden in the 18th century, but was later annexed to Russia, so both the Gregorian and Julian calendars were in official use in Finland during the 19th century.", "id": "dao7o9s"}, {"comment": "Also known as the answer to the question, why I should write small changes to production and deploy often.  It's the same solution to the same psychological inputs.", "id": "dan27mo"}, {"comment": "Why even have offsets? It's all abstract anyway. The morning doesn't stop being the morning because the clock happens to read 22:00 vs 06:00", "id": "dan6kqi"}, {"comment": "I'm quite conflicted.  On the one hand a day divided by 100 would suit me quite well.   On the other hand banks and airports need a little more ticks in their tock.", "id": "dana98o"}, {"comment": "There's a lot of convenience that people see to having the date transition happen when the sun isn't up and a lot of people aren't working. I don't think it would be too hard for people to get used to it though. There's already a lot of 24-hour operations that deal with this without too much trouble.", "id": "danzrxl"}, {"comment": "No, but the utility of knowing the time of day would be destroyed. 12pm is around the middle of the day everywhere on earth, 6am is an inappropriate time to call someone no matter where they are.", "id": "dao74oy"}, {"comment": "I can see that, but trying to figure out times zones doesn't seem any more or less efficient. Especially since time zones are not consistent and change monthly. If we didn't have offsets, the only thing you'd need to know is the position of the sun in the sky.", "id": "daoahmv"}, {"comment": "You are very far from alone with your opinion: http://spectrum.ieee.org/tech-talk/computing/networks/leap-second-heads-into-fierce-debate", "id": "dan5adm"}, {"comment": "For example, GPS doesn't use leap seconds.", "id": "dangh49"}, {"comment": ">How many devices (and/or humans) actually need both that kind of accuracy\n\nyou either know the time or you don't. time is a construct (a device) that we use to track our procession through the universe. turns out that procession is not a consistent rate, so do you ... ignore it and let your device fall out of \"tune\" or do you knock it back on the rail when it starts coming of?\n\nif it comes off by 1000ms, we've collectively decided it's time to apply maintenance, and we ALL have to do it together, otherwise you end up fragmenting the time keeping populations (like [happened in 1752](http://mentalfloss.com/article/51370/why-our-calendars-skipped-11-days-1752) when we removed 11 days from the calendars. it took awhile for that news to spread everywhere)", "id": "damr2tx"}, {"comment": "> you either know the time or you don't. \n\nSo so not true. There is not one true time, which is exactly what makes this all so hard. ", "id": "damu7m2"}, {"comment": "1752 wasn't the beginning of the fragmentation problem, but the beginning of its end. A big ol chunk of Europe had already made the change 170 years earlier, and we were playing catch up. We weren't the last to switch (see e.g. Russia, 20th century), but we were pretty late to the party.", "id": "dan443n"}, {"comment": ">  turns out that procession is not a consistent rate, so do you ... ignore it and let your device fall out of \"tune\" or do you knock it back on the rail when it starts coming of?\n\nFrom what I learned of that article, we do both, and the most common solution (UTC) is a messy compromise. \n\nWhat I mean is, have we actually really *solved* the problem of timekeeping or are we just adding more complexity to it with little practical benefit? ", "id": "damrjvw"}, {"comment": "The point is that there is *no* solution. We like things to be nice and orderly, but the universe doesn't really care. As far as it's concerned, if we wanted that kind of accuracy, we should have evolved around a pulsar. There's no answer to uniform time when the time scales themselves aren't uniform.", "id": "damssz4"}, {"comment": "It's arbitrary how we do any offsets. You could just stop doing the leap seconds and then keep track of solar time separately. ... which would be a good idea anyway as that would mean we could get rid of the stupidity of time zones and do the solar time accurately.", "id": "damw77s"}, {"comment": "But that's the point, solar time is constantly changing. No matter how you slice it, you're never going to measure two years that are *exactly* the same length.", "id": "damwlch"}, {"comment": "But if you keep track of solar time separately it doesn't matter exactly how long the solar year is. For the calendar stuff we already have a leap day we can't really avoid anyway.\n\nBTW, Having a separate solar time means we can have all the advantages of daylight savings time without the disadvantages just by deciding to, say, show up at work an hour after sunrise. It's just been ugly hack piled on ugly hack. The leap second is just the newest ugly hack.", "id": "damxpx2"}, {"comment": "> BTW, Having a separate solar time means we can have all the advantages of daylight savings time without the disadvantages just by deciding to, say, show up at work an hour after sunrise.\n\nYes, that's going to go over well at higher latitudes. \"Time to call it a day, everyone. See you tomorrow, in ... February 13th\".\n", "id": "dan4klc"}, {"comment": "Actually, solar time would work better at higher latitudes (I live at such a latitude). As it is here we would be better off in the summer with double DST (two hours ahead).\n\nYes, if the sun never came up people would have to do something else (which they pretty much have to do anyway).", "id": "danhpez"}, {"comment": "I think you're missing the point here. Computers need consistency, and the universe does not provide it. You're *never* going to get a consistent, regular unit of measurement for large time scales. ", "id": "damxw38"}, {"comment": "Ah, yes, fix the complexity by introducing an additional time keeping system.", "id": "dan3fuy"}, {"comment": "No complexity. The time would be the same all over the world...", "id": "danhsyx"}, {"comment": "That's not going to happen,  so any system interfacing with humans would still need the facility to convert to conventional time keeping. ", "id": "daniohd"}, {"comment": "UTC is the worst of both worlds though. It's not useful for \"local human time\" (1 local day isn't always 1 UTC day due to e.g. DST changes), and it's not useful for \"consistent machine time\" because of leap seconds.", "id": "danfcxu"}, {"comment": "UTC and DST are two entirely separate issues, UTC has no requirement for DST and I wish we'd just be rid of it. DST does nothing but cause confusion, especially when no two countries can agree on what DST should be. Get rid of that, and look at time zones and reassign those assholes who think they're special enough to be 15 minutes off, and UTC becomes quite simply that: the current time in Greenwich. There's nothing inherently wrong with UTC, it's humans that have screwed up the clock around it.", "id": "dano2u9"}, {"comment": "The point is you can't use UTC for humans because it doesn't change for DST (which Greenwich has, FTR). But you can't use it for computers either because it does change for leap seconds. So it's the worst of both worlds.", "id": "danpqr9"}, {"comment": "Yeah but we can get rid of DST because it doesn't serve nearly as much of a purpose in the digital age as it did in the age of candles. So one of those flaws is by no means necessary, we just have to collectively agree that we're all tired of it.", "id": "danqb66"}, {"comment": "Collective action is always a hard problem. Different business hours for winter and summer does make sense, and while it's kind of crazy that the easiest way to coordinate that is to change the clocks, well, here we are. ", "id": "dao3fei"}, {"comment": "We want the following properties in our timekeeping:\n\n1. Always moves forward\n2. One second always describes the same interval\n3. Makes sense to us meatbags\n\nThese are all important properties, but it's impossible to have all three at the same time, only two.\n\nUTC chooses (2) and (3). TAI chooses (1) and (2). Google chooses ~~(2)~~(1) and (3).", "id": "dan5ksn"}, {"comment": "Doesn't google do 1 and 3? Since the length of s second may change?", "id": "danb8mr"}, {"comment": "Yes. Fixed, thanks.", "id": "dandand"}, {"comment": "Not having a consistent time measurement makes secured distributed computing less viable. Seeing that this underpins almost every digital  service operating at scale then there is a fair argument that there is a vast practical benefit. ", "id": "damsuk9"}, {"comment": "You need to do this if you want July to stay hot and midnight to stay dark over the centuries.", "id": "dan1xp9"}, {"comment": "July is cold over here. (I get your point tho ;)", "id": "dan42cg"}, {"comment": "Thats just nuts.  You guys need to fix your calendar!", "id": "dan8dw5"}, {"comment": "Timezones and daylight saving aren't enough. We need datezones.", "id": "danf79m"}, {"comment": "I've never been in a datezone, always been in a friendzone at most.", "id": "danfrm2"}, {"comment": "If datezones were introduced, that could change.", "id": "dap1pt6"}, {"comment": "Leap days? Because you could seriously fuck with the calendar over time. The leap day was introduced specifically to fix that", "id": "dan0sfb"}, {"comment": "I started programming in the eighties. The horrors go on and on when it comes to keeping time.", "id": "dan5zax"}, {"comment": "Astronomers, primarily.", "id": "dan62sz"}, {"comment": "Not so much that, more is that the devices are in sync with each other.   Might as well make the original source as accurate as possible if it's possible. \n\nFor example, I collect logs from devices all over campus.  We sync them against a local NTP server so they are accurate to the millisecond.   Since we also do scientific research, having an accurate time source at that scale has other uses.", "id": "dan69pr"}, {"comment": "Leap days are fine, everyone knows about them, everyone knows to test them.\n\nLeap seconds do more harm than good. There is a proposal to eliminate them scheduled for discussion in 2017 AIUI. One issue is that some countries have a legal/constitutional requirement for official time to be based on solar time.", "id": "danfbgi"}, {"comment": "Banking and accounting", "id": "dan47xs"}, {"comment": "GPS needs it, which is perhaps why GPS feeds can constitute a stratum 0 time service.", "id": "dan48g7"}, {"comment": "It's literally the opposite. GPS time is based on atomic clocks and doesn't use/need leap seconds. You have to tell your NTP server how many leap seconds there are if you're using a GPS input device.", "id": "danef33"}, {"comment": "Cool.\nThis particular line caught my eye in reference to the original post: \"...One possibility is that resynchronization will be achieved by slowing the clock by a few dozen parts per million, thus effectively diluting the error caused by leap second into a few hours or perhaps a day. This is a common view of things (and perhaps desirable, see the suggestion about\u00a0CLOCK_UTS\u00a0below), but I am uncertain whether any real-life system (typically a Unix system + an\u00a0NTP\u00a0implementation or some other timekeeping device) actually does this...\" \n\nIt seems like that's almost exactly what Google's attempting to do, albeit over an even longer period of time.", "id": "dan7jc0"}, {"comment": "Unix timestamps are really simplistic, which causes issues around leap seconds: contrary to what most people think a unix timestamps is not the number of seconds since the epoch, it's the number of days * 86400 + number of seconds since midnight, so it just defines a day as 86400 seconds period end of the story.\n\nThat makes it very easy to map to calendars, but it leads to the oddities around leap seconds.\n\nAn alternative would have been TAI or counting \"true\" UTC seconds (rather than UTC days), but now you have to keep leap seconds around to get calendar dates, and thus effectively can't convert to future dates with any precision futher than ~6 months in advance.", "id": "dang6je"}, {"comment": "That broke my brain. On the plus side I have some code to fix now. ", "id": "dan4ncv"}, {"comment": "any way to read that on mobile without that horrible background color?", "id": "damt01h"}, {"comment": "try reader view?", "id": "damy04t"}, {"comment": "Paste this in your browser's address bar when you're on the site.\n\n    javascript:document.body.style.backgroundColor='white';void(0);", "id": "damvf24"}, {"comment": "https://support.mozilla.org/en-US/kb/view-articles-reader-view-firefox-android", "id": "danbxl8"}, {"comment": "I honestly don't see why leap seconds were considered as part of unix timestamp.\n\nLeap seconds should be a timezone issue, not a recording issue. But no...", "id": "danhheq"}], [{"comment": "When time changes slightly during NTP sync, Windows actually accelerates/decelerates clock to adjust to the new time instead of resetting the clock abruptly (and as a result, for example, expire a lot of timers and potentially break application). It's been doing it for years.\n\nSo if NTP simply returned the same time during the leap secret interval, twice in the consecutive seconds, Windows would have handled it correctly.", "id": "dameqyg"}, {"comment": "FWIW, this is also how ntpd on linux works, it makes small adjustments towards the reference clock.", "id": "damo3v8"}, {"comment": "Indeed, but if your clock is too fucked up you can tell it to just set it to the proper value, otherwise it might take years to slowly align.", "id": "dampj0o"}, {"comment": "This is fairly sane logic (although slightly less sane if setting the clock backwards), although it's not enabled by default on many distros because it can seriously fuck with apps that aren't expecting the massive jump. NTP will simply do nothing unless manually told to sync in this case.\n\n\nIf you expect have a network connection on boot, you can get NTP to do a blocking sync before any system apps run. This will go ahead and set the clock to the correct value regardless of current system time difference. It's good behaviour for stuff like the Raspberry Pi which ships without a hardware RTC.", "id": "damu79w"}, {"comment": "Can you link to some instructions on how to set that up? Would love it on my pi's", "id": "dan2eqi"}, {"comment": "    $ cat /etc/default/ntp\n    NTPD_OPTS='-g'", "id": "dan3kbs"}, {"comment": "Yep, pretty much this.\n\nMore info here:\n\nhttp://doc.ntp.org/4.1.0/ntpd.htm\n\n>Normally, ntpd exits if the offset exceeds the sanity limit, which is 1000s by default. If the sanity limit is set to zero, no sanity checking is performed and any offset is acceptable. This option overrides the limit and allows the time to be set to any value without restriction; however, this can happen only once. After that, ntpd will exit if the limit is exceeded. This option can be used with the -q option.\n\nIf you're wondering what -q does:\n\n>Exit the ntpd just after the first time the clock is set. This behavior mimics that of the ntpdate program, which is to be retired. The -g and -x options can be used with this option.\n\nYou can also use it with -n to stop it forking, so if you use -g -q -n, it'll block boot (need to configure init or systemd to wait for it), sync time, and then exit. I recommend just using -g though since it'll keep the Pi in sync as long as it's on.\n\nEDIT: Also as an aside, you have to love how the official docs literally say\n\n>-P: Override the priority limit set by the operating system. Not recommended for sissies.\n\nI wonder if sissies is an official computing term :P", "id": "dan4nl5"}, {"comment": "NTP is a protocol, it doesn't \"do\" anything.", "id": "dandvfl"}, {"comment": "ntpd*", "id": "danebh0"}, {"comment": "I've had Windows say it \"failed to sync\" with internet time many times when the clock is really far gone (like if your CMOS gets reset). Oddly enough, if you get the clock close and sync again it suddenly works fine. Definitely confusing to the end user.", "id": "danff6y"}, {"comment": "I believe linux NTPD would actually cause a clock step to take place. Time slewing (the official term for NTPD's mechanism) only occurs for time differences under 128ms by default, which is obviously smaller than a leap second.\n\n> As the result of this behavior, once the clock has been set, it very rarely strays more than 128 ms, even under extreme cases of network path congestion and jitter. Sometimes, in particular when ntpd is first started, the error might exceed 128 ms. This may on occasion cause the clock to be set backwards if the local clock time is more than 128 ms in the future relative to the server. In some applications, this behavior may be unacceptable. If the -x option is included on the command line, the clock will never be stepped and only slew corrections will be used.\n\n> The issues should be carefully explored before deciding to use the -x option. The maximum slew rate possible is limited to 500 parts-per-million (PPM) as a consequence of the correctness principles on which the NTP protocol and algorithm design are based. As a result, the local clock can take a long time to converge to an acceptable offset, about 2,000 s for each second the clock is outside the acceptable range. During this interval the local clock will not be consistent with any other network clock and the system cannot be used for distributed applications that require correctly synchronized network time.", "id": "danp0kf"}, {"comment": "If that's an issue maybe wall time isn't appropriate and a monotonic clock would be more suitable.", "id": "damncdp"}, {"comment": "It would be handled correctly in the sense that the clock syncing software can continue to function and stay in a synced state. However, smearing the time change at the server side seems to offer several advantages:\n\n* You can lengthen the smearing interval beyond what Windows would normally do to catch up. If you're using the clock to measure anything (benchmarks, timeouts, etc.) during that time, you get less error.\n* You can ensure that different clients (versions of Windows, other operating systems) all skew their clock together at the same rate. Let's say (making up arbitrary numbers) that Windows cranks the clock to 101% of normal rate when it needs to catch up and Linux cranks the clock to 100.5%. Then there will come a point when Windows is done and Linux is 0.5 seconds behind.\n* The above problem is probably exacerbated by the fact that clients are not polling the server on the same schedule. If you poll once an hour and it only takes 20 minutes to catch up, then clocks could differ by a full second, as one is finished catching up before the other even knows to start catching up.", "id": "damxxud"}, {"comment": "I think google's smearing works on their NTP server. This way your system gets adjusted time regardless of OS you are running. On low level (server) it's business as usual. Server runs NTP time check over established period, correcting itself to real-clock time. Are you assuming that windows default NTP servers sends extra data other than time and tells the machine to slow down(speed up) time locally? ", "id": "dan0sl1"}, {"comment": "I don't know how the Windows client works, but on the traditional Unix/Linux NTP, the machine just talks to NTP servers, finds out that its local clock is off, and then it decides on its own whether to adjust the time (by tweaking the rate) or step the time (by setting a new value).\n\nMy main point is, if you leave it up to the individual client how to respond, clients will all respond different ways, depending on their implementation. If the server dictates the terms, then clients all respond in (almost) the same way because they all follow the server, together.", "id": "dan1814"}], [{"comment": "\"Smeared time\" almost sounds like a bug rather than desirable behavior.", "id": "damfba2"}, {"comment": "The \"bug\" is really in the spec, because we have conflicting requirements. People want time of a consistent rate, but they also want time that matches the inconsistencies in the wobbly movements of orbiting chunks of rock.\n\nIt can't really be fixed without substantial *orbital*-engineering.", "id": "damgh3o"}, {"comment": "/u/Terr_, we will rely on you to write that Jira ticket. ", "id": "damhkuf"}, {"comment": "No problem, that's the easy part. Based on a lot of the ones that go my way, it'll be something like: \n\n> The field is reporting that times are incorrect. Every day must be precisely 24 hours, and years must be either 365 days or 366, depending on whether they are leap-years or not. \n\n> Please investigate and resolve this issue. \n\nAnd later:\n\n> The field is having trouble with the average of 365.25 days per year, since it causes some confusion almost every 4th year. It would help sales if it were more consistent. Please change all years to 365 precisely. \n\nNote that in the second case, we'd need to change the orbit of the Earth since the first ticket would have locked us in to a specific rate of rotation. However, the change is smaller than the current aphelion/perihelion swing, so any negative effects wouldn't be immediately apparent. Implementation would need to be phased in, however.\n", "id": "damofs3"}, {"comment": "> Implementation would need to be phased in\n\nJust strap a rocket engine to the side of the planet. Marking this issue as trivial.", "id": "damu4ed"}, {"comment": "You're gonna need more rockets.  -- The Kerbal Way", "id": "dan1n6a"}, {"comment": "With a gas-planet it's even easier: You could use a \"fusion candle\", a tube-like megastructure, which uses energy to take in atmosphere at the center and spew mass out of both ends. Balance the thrusts correctly, and it'll \"hover\" in the planet's atmosphere while pushing it along.\n\n[Just be careful driving.](http://www.schlockmercenary.com/2003-08-03)\n", "id": "danfddj"}, {"comment": "Wow, you are a lucky duck, this would be the ticket I would get\n\n> The time is wrong\n\nand then that would be it.\n", "id": "damvw14"}, {"comment": "Fortunately for me that's a different queue. The stupid tickets I get are more in the \"we shouldn't even be *doing* that, let alone streamlining it or making it automatic\" category.", "id": "dan5i8p"}, {"comment": ">  average of 365.25 days per year\n\nIn the Gregorian calendar the average is 365.2425 days per year, but even that doesn't match Earth's year exactly.\n\n", "id": "damuvfp"}, {"comment": "Hence \"*almost* every 4th year\". :)", "id": "dan5iz8"}, {"comment": "*due date:* 4 years away\n\nHehe I'll have changed contracts at least 4 times by then... ", "id": "damsx14"}, {"comment": "Sorry, that's not written in the form of a user story. I'm gonna need you to fix that, and until then it'll be marked \"wontfix\".", "id": "dan6tba"}, {"comment": "The way my company does it is: \n\n> *As a user*, I want {$REINSERT_CONTENT_HERE}\n\nThat's only like, 10% joke.", "id": "danf87s"}, {"comment": "> as a user, I want \"shits broke\".\n\nThanks.", "id": "danl4bu"}, {"comment": "Jira? What's a Jira?\n\n*Sobs into Salesforce login page*", "id": "dan6rtp"}, {"comment": "WAI, use GPS time.", "id": "damvpkj"}, {"comment": "There was a post recently saying that the [water displacement in the 3 Gorges Dam in China had effects on the earth rotation](https://www.reddit.com/r/todayilearned/comments/5fib6o/til_the_three_gorges_dam_in_china_holds_back_so/). \n\nSo, we indeed *can* fix the problem in hardware.\n\n", "id": "damknfz"}, {"comment": "Actually, the top voted comment says,\n\n> The heading is pointless.  Every dam will slow the rotation of the earth in the same way.  They're not even claiming that the Three Gorges Dam will be special in that the amount of slowing will be measurable, because it won't be.", "id": "dammi3l"}, {"comment": "Couldn't we make the Unix timestamp linear, and then change the time calculation that sits on top of it to take into account leap seconds? The issue seems to be that the spec assumes fixed, non-varying days. There could be a table that documents leap seconds and allows altered calculation of the real date time based off a linear underlying timestamp, similar to the way in which time zones are handled. Aka, second X is a leap second, give the minute 61 seconds.\n\nOf course this is quite complicated and could break a lot of applications, and the spec is old as time so it's never changing. Still, smearing the timestamp seems less than desirable.", "id": "damul56"}, {"comment": "Ultimately the problem is that we are assuming a universal monotonic time, which is not how reality actually works.", "id": "dan24q7"}, {"comment": "That is a separate issue really. Even if you were traveling at relativistic speeds, the days on earth and the years would not be aligned. From all perspectives, if you want a daysInYear % day == 0.0, some adjustment has to be made. ", "id": "dannna8"}, {"comment": "You could, but yes, it would break lots of code. The assumptions that time-of-day = unixtime % 86400, and number-of-days = unixtime / 86400 are *everywhere*.", "id": "dan9srs"}, {"comment": "Then create atomictime, which is exact seconds since the epoch, and implement a lib that can convert atomictime to UTC/GMT/Whatever. Keep the messy bits out of the part that represent the truth.", "id": "danekou"}, {"comment": "That already exists: [International Atomic Time (TAI)](https://en.wikipedia.org/wiki/International_Atomic_Time)\n", "id": "danerro"}, {"comment": "So this is where I think there should be a monotonic timescale for computers and things that depend on it but adjustments for human time via something like the tz file. Basically that EST would become UTC -500:01 or -459:59 after a leap second (technically a second can be added or removed). ", "id": "damr0tr"}, {"comment": "That monotonic uniform scale goes by the name TAI. Every day is 86400 seconds long, no exceptions.", "id": "damu4n4"}, {"comment": "And the adjustment is UT1", "id": "dan4e7i"}, {"comment": "would a tall tower or space elevator change the rate of rotation?", "id": "damt4nb"}, {"comment": "The earthquake that happened near Indonesia several years ago that caused a tsunami had a measurable affect of the earth's rotation (speeding it up since the crust collapsed down towards the center).", "id": "dan3uzp"}, {"comment": "but we could do the same thing with a manmade structure.\n\nthe mass of the object doesn't matter much, it just has to withstand the stress of rotation. We could build two towers half as tall on each side of the earth, instead of one large tower.\n\na space elevator would be ideal, as the cable would be suspended by inertia.", "id": "dan431o"}, {"comment": "Not an expert, but I'm going with yes due to answers I've heard on the related topic of mass scale wind farms. \n\nI don't believe it would be measurable though. ", "id": "damy7m3"}, {"comment": "It's time to convert the Solar System into a Dyson Sphere.", "id": "dan6jiz"}, {"comment": "http://www.leapsecond.com/museum/earth/", "id": "dan9t6n"}, {"comment": "Well of course it looks bad, he's measuring rotation rather than revolution :P\n\nGranted, the larger oscillator requires a drastically larger amount of mass in the middle, so it's not nearly as portable.", "id": "danf9xo"}, {"comment": "Yup, I came in with my pitchfork ready, and am left with a greater knowledge of NTP.", "id": "damsvsy"}], [{"comment": "Can anyone comment on how this will interact with non-smeared NTP or GPS time sources?\n\nIt was fine and dandy when they did it as part of a closed system, but this looks like a public service that could use some standards group discussion before being dumped on the public (and time-naive) Internet.\n\n(And because its Google, you can bet a some decent % of networks will take this up, only to discover next leap second that some synchronization-sensitive thing got impacted)\n\nI can't actually think of any time-dependent service that would be sensitive to desynchronization across a WAN on the order of a second, but I'd be surprised if no such service or protocol existed. The kind of thing I'm thinking about is something like HOTP or Kerberos, where both parties must agree on current time. However neither of those protocols would be sensitive to a change of one second ", "id": "dame5d1"}, {"comment": "From the [linked docs](https://developers.google.com/time/smear) (regarding a 24hr smear, which is slightly different than the 20hr smear they will be using this year, but not by much):\n\n>This smear combines the features that experience has shown to work well for many distributed computing applications:\n\n> The long duration keeps the frequency change small. The change for the smear is about 11.6 ppm. This is within the manufacturing and thermal errors of most machines' quartz oscillators, and well under NTP's 500 ppm maximum slew rate.\n\n> Centering the smear on the leap second, instead of having it begin or end at the leap second, minimizes the maximum offset.\nCompared to a cosine smear, the linear smear is simpler, easier to calculate, and minimizes the maximum frequency change.\n\n> The 24-hour duration has been widely adopted by others implementing smears. We plan to change from our 20-hour duration to align with this more popular noon-to-noon interval.", "id": "damevoq"}, {"comment": "> We plan to change from our 20-hour duration to align with this more popular noon-to-noon interval.\n\nWait what?", "id": "dan1kyj"}, {"comment": "Smear over 24 hours instead of over (their own defined) 20 hours default.", "id": "dan4nvm"}, {"comment": "Oh, I read they were switching the other way.", "id": "dan6cvq"}], [{"comment": "Does anyone care to guess what unexpected problems *time smearing* will cause?\n\nI won't be surprised if certain NTP consumers start to break a trust with the server.", "id": "damdgnc"}, {"comment": "[According to the doc they linked](https://developers.google.com/time/smear), the smear they will use in 2018 is less than NTP's maximum slew rate by almost two orders of magnitude. The one they are using this year is going to be a bit larger, but not by much. ", "id": "damshj1"}, {"comment": "And that's why, in new programs, you should be using `clock_gettime(CLOCK_MONOTONIC, &tm)` if you care.", "id": "damlcae"}, {"comment": "NTP rate adjustments affect `CLOCK_MONOTONIC`.", "id": "damy1sk"}, {"comment": "> CLOCK_MONOTONIC\n\n`CLOCK_MONOTONIC_RAW` perhaps?\n\nHowever that will be *less* accurate on most hardware than the NTP-corrected one, except (perhaps?) during time smearing events.", "id": "danbe15"}, {"comment": "Not always an option. E.g. http://pubs.opengroup.org/onlinepubs/9699919799/functions/sem_timedwait.html", "id": "damyypw"}, {"comment": "They did caution that you should either rely entirely on smeared or entirely on non-smeared servers and not mix the two.\n\nIf all the servers smear together more or less exactly, then presumably a client (or next tier of server) will see this as their own oscillator being off, because every reliable source they have is in agreement about that. So presumably it would doubt itself rather than the servers, even though its oscillator is actually not wrong.\n\nEven if it did happen, assuming the local oscillator is decent enough, presumably the client would resume trusting the servers after the smearing is over.", "id": "damy4w9"}, {"comment": "I am going to guess for certain applications smeared time is not going to work very well. Two that I can think of: \n\n* high frequency trading\n* GPS/satellite/instrument calibration\n\nBasically anything that requires high performance timekeeping that has interval of more than a day, but you probably shouldn't use Unix-time for those applications anyway. \n", "id": "danc3rc"}, {"comment": "> GPS/satellite/instrument calibration\n\nThey don't use UTC anyways but TAI, which does't have leap seconds.\n\n>high frequency trading\n\nA lot of these systems are shutdown during the leap second.", "id": "danezpa"}], [{"comment": "Considering Reddit crashed due to a leap second bug, this can only be a good thing.", "id": "dam45v3"}, {"comment": "> Considering Reddit crashed due to a leap second bug, this can only be a good thing.\n\nSo rather than fixing bugs we should work around them?", "id": "danatay"}, {"comment": "When the spec is hard to implement correctly, sometimes it's a sign that you should simplify the spec.", "id": "danfff0"}, {"comment": "When you're dealing with potentially thousands of legacy systems that could break due to the change, sometimes it's just easier to work around the issue. And this workaround is a pretty good one, minimal side-effects.", "id": "danc0f3"}, {"comment": "This is how we wind up with an avalanche of workarounds that wind up making new, supposedly pristine systems violate the principle of least surprise. ", "id": "dancsqs"}, {"comment": "Legacy systems that predate the leap second introduction in 1972?", "id": "danduus"}], [{"comment": "**Smeared Time**: very clever solution -- but that's what I have come to expect from Google.", "id": "damcn0i"}, {"comment": "They didn't really invent it, since it was already a wellknown, suggested solution to the leap problem. I mean it's not really that unobvious to just \"smear\" the time instead of skipping or repeating seconds anyways. The spec and implementation on the other hand are probably the hard part\n\nOne of the easier to find proposals is [UTC-SLS](https://tools.ietf.org/html/draft-kuhn-leapsecond-00) btw.", "id": "damqimr"}, {"comment": "Problem is many ntp server may see this and ignore it down the line. This is google once again jumping the gun and artificially gaining acceptance by usage to layer force an industry standard with its clout. ", "id": "damz57d"}, {"comment": "You don't have to use their servers.", "id": "danells"}, {"comment": "But people will. and then I'll need to sync extremely time sensitive logging with them and we will be all kinds of fucked. yay. (this will probably never happen and if it did, wouldn't really matter, but it could). As I said somewhere else, I'm not against this approach from a technical standpoint. but how google forces \"standards\" is a problem. but oh well.", "id": "daoef53"}, {"comment": "The standards body was originally supposed to discuss this in 2015, then they put it off for two years. I think Google is right to force the issue.", "id": "danfgs7"}, {"comment": "Wrong way to do it. I don't even disagree with the technical approach, but this will force this usage to more groups the wrong way. Oh well.", "id": "daoeg34"}, {"comment": "If only we could do that for leapyears. But I don't mid the extra day.\n\nIf only we could do this for daylight saving time... But that one we should just stop doing.", "id": "damuyc7"}], [{"comment": "So, just out of curiousity...time1.google.com through time4.google.com all resolve to public IP addresses that are fairly close together.  At least, from where I am, using 8.8.8.8 as the DNS server.  \n\n216.239.35.0, .4, .8, and .12.\n\nBut looking at the IPv6 addresses, they are\n\n\n\nFQDN| IPv4 | IPv6\n---|---|----\ntime1.google.com| 216.239.35.0| 2001:4860:4806::\ntime2.google.com| 216.239.35.4| 2001:4860:4806:4::\ntime3.google.com| 216.239.35.8| 2001:4860:4806:8::\ntime4.google.com| 216.239.35.12| 2001:4860:4806:c::\n\nAre they actually putting these in an IPv6 /24?  That seems like an awfully large subnet to be using.", "id": "damn1jn"}, {"comment": "Those address aren't entire subnets. A DNS AAAA only points to a single address. They're /128s. It just looks like it might be a subnet because IPv6 allows you to replaces 0 parts with just a ::.", "id": "dan01kh"}, {"comment": "> Are they actually putting these in an IPv6 /24? That seems like an awfully large subnet to be using.\n\nIt's not like Google doesn't have [enough IPv6 networks](https://whois.arin.net/rest/org/GOGL/nets). (Actually it looks like an /48.)", "id": "damp54k"}, {"comment": "My terminology may be rusty but those IPs are probably anycasted:\n\n    Sprint Source: Anaheim, CA (sl-crs3-ana) \n    User-defined destination: 216.239.35.4\n    Performing: ICMP Traceroute\n    IP Version: IPv4\n    Tracing the route to time2.google.com (216.239.35.4)\n    \n     1  144.232.22.88 7 msec  6 msec  5 msec \n     2  72.14.243.15 0 msec  3 msec  2 msec \n     3  209.85.248.187 1 msec  4 msec \n        209.85.248.185 3 msec \n     4  209.85.253.29 [MPLS: Label 721251 Exp 4] 2 msec \n        209.85.248.125 1 msec  20 msec \n     5  216.239.49.15 [MPLS: Label 24401 Exp 4] 51 msec  51 msec \n        209.85.143.221 51 msec \n     6  209.85.251.138 [MPLS: Label 34095 Exp 4] 51 msec  51 msec  51 msec \n         7  216.239.43.217 51 msec \n    72.14.233.163 51 msec  51 msec \n         9  216.239.35.4 [time2.google.com] 50 msec  50 msec  51             Completed - Wed Nov 30 21:07:15 EST 2016\n\n    Sprint Source: Ashburn, VA (sl-mst20-ash) \n    User-defined destination: 216.239.35.4\n    Performing: ICMP Traceroute\n    IP Version: IPv4\n    Tracing the route to time2.google.com (216.239.35.4)\n    \n     1  144.232.18.229 7 msec  12 msec  7 msec \n     2  144.232.7.191 4 msec  7 msec  6 msec \n     3  144.232.15.174 7 msec  6 msec  10 msec \n     4  72.14.208.66 30 msec  7 msec  7 msec \n     5  216.239.62.139 4 msec  4 msec \n        216.58.215.46 9 msec \n     6  72.14.236.148 [MPLS: Label 443061 Exp 4] 12 msec  38 msec \n    216.239.48.101 7 msec \n     7  108.170.237.42 [MPLS: Label 314534 Exp 4] 20 msec \n    209.85.143.166 63 msec  37 msec \n     8  209.85.247.5 [MPLS: Label 31727 Exp 4] 33 msec \n    209.85.143.103 29 msec \n    209.85.247.5 33 msec \n     9  216.239.46.191 29 msec \n    216.239.41.58 47 msec \n    216.239.46.191 30 msec \n     10  *  *  * \n     11 216.239.35.4 [time2.google.com] 31 msec  28 msec  28 msec \n", "id": "dan0d6m"}, {"comment": "Seems like they are using IPv6 incorrectly. the :: ending means it's all 0's which means they use the network designation IPv6 as main address. This might break some applications. (it's like using 192.168.0.0 instead of 192.168.0.1 etc)\n\nDid not think google is that cheap on sysadmins", "id": "dandv4p"}], [{"comment": "I'll just quote [Larry Osterman's blog post on time smearing in Windows](https://blogs.msdn.microsoft.com/larryosterman/2004/04/02/one-in-a-million-redux/):\n\n> Time on a PC is kept via counting the number of clock interrupts that have occurred.  Every PC contains a crystal that operates a clock chip that interrupts the CPU approximately every 10 milliseconds. So NT increments the system time by 10 milliseconds every time it receives a hardware interrupt.\n> \n> But the problem is that the crystals used internally in the system have a failure rate of as high as 100ppm \u2013 in other words, 100 times every million clock ticks, the clock chip won\u2019t actually generate an interrupt.  For most applications, this isn\u2019t a significant problem \u2013 instead of the system context switching every 10 milliseconds, every once in a while, the system context switches in 20 milliseconds.\n> \n> But for time, this is an utter disaster.  Given a 10 millisecond timer, there are 8,640,000 clock ticks per day.  If 100 per million clock ticks are missed, then that means that the system misses 864,000 clock ticks, which is about 864 seconds.  That\u2019s over fourteen minutes per day!\n> \n> Now, in practice, the amount of drift is actually much lower, but still it can be quite significant.\n> \n> So how does NT fix this?  Well, back in NT 3.1, once an hour, NT would interrogate the on-board real time clock chip (the hardware that keeps your date and time up-to-date even when your computer is powered off).  If the system time differed from the real time clock chip, then it would simply reset the system time to match the time on the RTC.  Which meant that time could jump forward or backwards significantly \u2013 so it was possible for the assert to fire in the following code:\n> \n>     GetFileTime(&time1);\n>     GetFileTime(&time2);\n>     ASSERT(CompareFileTime(&time1, &time2) < 0);\n> \n> Clearly this was an unacceptable situation, so something had to be done to fix it.  The fix (in NT 3.5) was to change how time was accounted for in the system.  In the old system, every clock interrupt bumped the time by 10 milliseconds.  With the change, when the system measured the time from the RTC, instead of applying the new time immediately, it calculated an adjustment to the 10 millisecond amount.  If the clock was behind, each tick might count as 11 or 12 milliseconds.  If the clock was head, each tick might count for 8 or 9 milliseconds.\n> \n> This is actually pretty cool (ok, I think it\u2019s amazingly clever), but again, there can be problems.  What if you\u2019re using the current time and some high performance counter (like [**QueryPerformanceCounter**](https://msdn.microsoft.com/en-us/library/windows/desktop/ms644904.aspx))?  Then the clock drift will cause your measurements to be skewed from the real time measurements.  We actually ran into this problem in the SCP project \u2013 our clock tests were showing that the clock on the SCP chips was drifting, but we couldn\u2019t see why it was happening \u2013 it turned out that the SCP chip clock wasn\u2019t drifting, it was the PC\u2019s clock that was drifting.\n> \n> To allow people to compensate for this drift, a new API was added: [**GetSystemTimeAdjustment**](https://msdn.microsoft.com/en-us/library/windows/desktop/ms724394.aspx).  The **GetSystemTimeAdjustment** API allows you to determine the clock interrupt frequency (that\u2019s the **lpTimeIncrement** parameter), and the adjustment that\u2019s applied to each tick (that\u2019s the **lpTimeAdjustment** parameter).", "id": "damxoca"}, {"comment": ">But for time, this is an utter disaster. Given a 10 millisecond timer, there are 8,640,000 clock ticks per day. If 100 per million clock ticks are missed, then that means that the system misses 864,000 clock ticks, which is about 864 seconds. That\u2019s over fourteen minutes per day!\n\nDid you mean 86,400 missed clock ticks? I just wanted to be sure I'm not doing my math wrong. This whole time keeping thing is more complicated than I imagined.", "id": "dao0ra3"}, {"comment": "I don't think this \"100 ppm\" typical error is meaningfully described as a \"failure rate\" of \"up to 100 missing ticks.\" The 100 ppm error is the (maximum) difference in the *tick rate* between the crystal and a tick rate derived from a perfect time source. The ticks happen, just not exactly at the right rate. Which, over time, causes *drift* of the clock time compared to a more accurate source. Your clock is running fast or slow. It isn't \"failing\" to tick.", "id": "dar8d9j"}], [{"comment": "ITT: people with no goddamn clue how clocks work.\n\nComputers measure time by jiggling rocks. These rocks jiggle pretty okay, but not great, so they regularly resynchronize.\n\nThe time smear is on the order of 1/100th the error that end user devices already have.\n\nIf you have timekeeping needs that this smear breaks, but you're using a standard crystal oscillator clock, you're either stupid, wrong, or lying.\n\nTimekeeping is a hard problem. Many of you nits are being anti-vaxxers about it. Cut it out.", "id": "danhs1w"}], [{"comment": "Is google prepared to grow the capacity of time.google.com as needed to keep up with everyone in the world switching to it for convenience?\n\nThe same way many of us are using 8.8.8.8 as DNS that *just works* where ever we are.", "id": "dan5wr5"}], [{"comment": "ELI5 anyone ?", "id": "dan4oz6"}, {"comment": "**Leap seconds**\n\nOur orbit around the sun is not exactly a year. The orbit is closer to 365.24 days. If we didn't account for this, our months and days would start drifting away from our orbit and we'd soon have hot days in February and cold days in July.\n\nOne way we \"catch up\" is by having leap days every 4 years. But it's not that simple. Because it's .24 and not .25, we *don't* have a leap year on the 100th year. (Except on the 400th year, in which case we DO!)\n\nSimilarly, the Earth's rotation is not exactly 24 hours. And not only that, it is not stable but changing all the time (mostly slowing down) due to global events like the tide or earthquakes. So we add in leap seconds. The slowing is irregular, so the leap seconds are added as needed- we don't know more than a few months in advance!\n\n**Smeared time**\n\nNTP, [Network Time Protocol](https://en.wikipedia.org/wiki/Network_Time_Protocol), is a way to synchronize clocks to a reference server. That's how your phone can set its time automatically.\n\nBut, many operating systems and some software in general, [don't do well with the added leap seconds](https://www.wired.com/2012/07/leap-second-bug-wreaks-havoc-with-java-linux/). Leap years are already difficult to get right and we know exactly what years they are supposed to happen. Leap seconds can cause bugs and crashes. One way to deal with the leap second, which Google is adopting for its NTP servers, is to \"smear time\" around the leap second. For the 20 hours around the coming December 2016 leap second (10 hours before and 10 hours after), Google will purposefully run their NTP clock slower than actual seconds, thus inserting a second's worth of time across 20 hours.\n\nThis is an elegant solution because instead of forcing software to deal with the special case of an extra second, all NTP clients already have to deal with speeding up or slowing down slightly to match the reference clock. To clients of Google's NTP servers, it will just look like the clients keep drifting ahead and for 20 hours they will keep slowing down to sync back up to the NTP server. At the end of 20 hours, the clients will have gained a second without the possibility of choking on a double last second of the year (there will have been 60 seconds in every minute, as God intended).\n\nEDIT: Corrected 3rd paragraph per /u/sickofthisshit's comment.", "id": "dan9cly"}, {"comment": "> there will have been 60 seconds in every minute, as God intended\n\nPraise the Lord", "id": "dandcsb"}, {"comment": "PTL4NTP", "id": "dandjke"}, {"comment": "The orbit of the Earth is not responsible for leap seconds, the *rotation* of the Earth on its axis is.", "id": "dar864r"}, {"comment": "You're right. I thought leap seconds were also used to account for the drift to the solar year, but they are for the solar day.\n\nSo a better first half of my post would have been: just like we have leap days for the year, we have leap seconds for the day.\n\nI guess I'll edit my post.", "id": "dari88i"}, {"comment": "Thanks a lot", "id": "dandddi"}], [{"comment": "    struct tm {\n            int     tm_sec;         /* seconds after the minute [0-60] */\n    [\u2026]\n\ntime.h\n", "id": "dan6gfj"}], [{"comment": "I'm laughing at this immensely.  And not just a chuckly.  A real good, hilarious laugh.  Here's why:\n\nI spent 15 years a a professional timekeeper in motorsport.\n\nAnd many of the modern decoders used for timing - they synchronize, and they don't account for this.\n\nNow, I know about this.  And my systems to.  But it's hilarious when you come across a system that doesn't.  And here's why.\n\nLet's say you're running a qualifying session, and everyones doing lap times around 1:02.0000.  And you have a leap-second that's going to occurr at 3:59:59pm.  Annnnd... the system doesn't know about it.  Now in the hardware I use this was never a problem.  We set a clock once, and never re-synchronize it until told, time is taken from a delta to that original time.  But there's a major system in use around the world which doesn't.  In fact they keep resyncing to GPS.  Constantly.\n\nNow depending on your implementation - like, say, if you just subtracted unixtime from unixtime, well... maybe you have everyone who did a lap across that boundary doing a lap a second longer.\n\nOr maybe the leap second is duplicated... and now everyone's setting qualifying lap records.\n\nFun times.  I've seen this happen :)", "id": "dan89bx"}, {"comment": ">  In fact they keep resyncing to GPS. Constantly.\n\nGPS time is a strict TAI offset (19 seconds), it's monotonic, continuous, highly stable (as it's a weighted average of hundreds of atomic clocks, the weighting is to compensate for gravitational time dilation) and has no concept of leap seconds, leap seconds are applied when converting from GPS time to UNIX timestamps or UTC.\n\nIf they *only ever* use GPS time, they're perfectly fine.", "id": "dangauf"}, {"comment": "Just use `CLOCK_MONOTONIC_RAW` rather than `CLOCK_MONOTONIC` for that sort of thing.", "id": "danvo0f"}], [{"comment": "But why does the leap second have to be while we're supposed to be kissing someone at new years? Now we have to be upgrading linux... ugh.    (joking! you knew that...)", "id": "dan9w2n"}, {"comment": "People kissing on new year's & people this invested in timekeeping == 0\n\nSource: care about timekeeping", "id": "danhmk8"}, {"comment": "Ha! Glad you saw my humor :)", "id": "daouwx0"}, {"comment": "Only a problem for New Year's revelers close to GMT. It only happens at midnight UTC.", "id": "dar83pu"}, {"comment": "oh yes, good point! wonder how many kisses you just rescued", "id": "darl47s"}], [{"comment": "NTP should have used TAI. UTC should be for display / storage, not synchronisation.", "id": "danejz9"}], [{"comment": "I'm still surprised we borked this up so badly. In the 90s we got leapnseconds much more frequently and things worked. \n\nNow we crash the internet with a leap second!", "id": "damr57h"}, {"comment": "Things are a lot more connected now, so the exposed surface is substantially larger than it was in 90s.", "id": "daneo4w"}], [{"comment": "Or they could have just made the last second of the year be two seconds. At least only one timestamp will be wrong then, and not all of them; and a data spike (or whatever you are doing) at the last second of the year is way more obviously a special case.\n\nI guess they would argue the 0.00sth% deviance is not much; but by the end of the year, the clocks will be a full second behind - and will have been for close to a second for some time.\n\nIt\u2019s probably not as bad as this counter-argumentation makes it out to be though\u2026 \u00af\\_(\u30c4)_/\u00af", "id": "damtlck"}, {"comment": "It's not worth losing arm for a leap second, take it easy.", "id": "damuep1"}, {"comment": "But now during that whole second, minute, hour, and perhaps even day will be off.\n\nSomething that needs to run at 1hz is completely fucked that second, stuff running every 30 seconds will now be off by a second forever, things happening hourly now happen one second before they should.\n\nOr even worse, a program asks for the time at the last ms of the leap second, does some work, then asks for the time again.\n\nDid you return that that second has 2000 ms in it? Do you just \"smear\" for the duration of that one second? Do you start back over at 0ms and repeat that second? \n\nCan every program on your system handle a second with 2000ms? What about a millisecond that lasts twice as long? Can it handle hitting the same time more than once?\n\nThis shit is really fucking hard.", "id": "dan6d7q"}], [{"comment": "Someone please explain, why this would not work(psedocode/obviously implemented better):\n\n    If (leapsecond == true && seconds == 30){\n\n            Seconds = seconds -1;\n\n           leapsecond = false;\n\n    }", "id": "damxmcf"}, {"comment": "Some software simply doesn't expect time to ever go backwards, and doesn't handle it correctly. Others try to handle leap seconds properly, but are buggy.\n\nIn general, leap seconds are relatively rare, and tend to exercise untested code paths. Hitting an untested and potentially broken codepath in isolation might be bad; having every system in the world with a synced clock do so at the exact same moment is just asking for trouble.\n\nBack in 2012 we had a good demonstration of this: both [the Linux kernel and Java](http://www.theregister.co.uk/2012/07/02/leap_second_crashes_airlines/) hit major issues, impacting everything from Reddit to airline operations.\n\nLeap second smearing is really a risk mitigation exercise. Lots of problem domains don't actually care that the clocks are up to half a second off, so if you're working in one of those areas just side-stepping the issue entirely makes sense.", "id": "damzh3n"}, {"comment": "It's always \"airline operations.\"\n\nNobody ever considers the impact that this has on sewage treatment plants. Those guys are the real heroes here. After all, not everyone needs to fly, but everyone needs to take a shit every now and then.", "id": "dan6ftp"}, {"comment": "You dropped an entire second over the span of a second. Pretty abrupt adjustment.", "id": "dan09nk"}], [{"comment": "How did I not know Google had public NTP servers. Of course they do. ", "id": "damyw46"}, {"comment": "As far as I'm aware, they didn't until now.", "id": "dan1vis"}, {"comment": "Jesus, I even missed it and it's right there.\n\nFor anyone else who can't read today, Google's NTP servers are just now public. They've of course been running their own for some time and using what they've learned they're providing a public NTP server. Not surprising considering their cloud platform. ", "id": "dan4aqb"}], [{"comment": "I get that there's something interesting about that approach, but that seems like it might not be the best plan. Also I though NTP was supposed to be centralized so everyone has the same time, so having different big providers especially ones with modified time keeping seems counter-productive.", "id": "dan84ot"}, {"comment": "Indeed, but Google is taking the reasonable approach here. Systems that sync with a NTP server already know how to handle skew. So why force them to handle leap seconds as well, when that can just be handled by code that is already implemented?", "id": "danep84"}], [{"comment": "If all the clocks are using smeared time how do we know we actually used it and they didn't just lie to us?", "id": "dana7x2"}], [{"comment": "Somehow it bothers me that the smearing window is 10h before and after, instead of 12h which would make a nice round day.", "id": "danfcrh"}, {"comment": "Google will switch to a 24-hour smear for the next leap second.\n\n> We would like to propose to the community, as the best practice for leap seconds in the future, a 24-hour linear smear from noon to noon UTC. We plan to use this smear starting from leap second #38, which is likely to be in 2018.\n\nvia https://developers.google.com/time/smear", "id": "danxpps"}], [{"comment": "My cloud backup started overwriting the files on my computer every time I made a change. I think its due to some kind of timezone fuckup at their place.", "id": "dangm8k"}], [{"comment": "Sounds good that the servers are available, but considering that one of the main reasons to use a time server is to be in sync *with other people*,  it might be a reason to avoid them around the 1st.\n", "id": "dao5qwp"}]]], "5funm7": ["College launched GetCors.com, a simple CORS proxy for developers! Please send feedback!", "2016-12-01 07:39:45", 0, "http://getcors.com/", [[1, "Link to [Git Hub](https://github.com/tlrasor/getcors.com)\n\n\nLink to [twitter](https://twitter.com/tlrasor/status/804165472581193729)"], [1, "I'd be careful with something like that, could be abused. noble cause as CORS can be really awesome though"]], [[{"comment": "Link to [Git Hub](https://github.com/tlrasor/getcors.com)\n\n\nLink to [twitter](https://twitter.com/tlrasor/status/804165472581193729)", "id": "dan6sxn"}], [{"comment": "I'd be careful with something like that, could be abused. noble cause as CORS can be really awesome though", "id": "danrrlu"}]]], "5fpw7l": ["Code Reviews Are Awesome... Sometimes", "2016-11-30 17:33:32", 5, "http://blog.professorbeekums.com/2016/11/code-reviews-are-awesome-sometimes.html", [[2, "a few peer reviews in my career have been valuable, but i've stopped proceeding from the assumption that the peer reviewer is right"], [1, "I understand the need for code reviews, in pretty much any other job role you a peer reviewed (maybe not always in such a structured way but it happens) and development shouldn't be any different IMO.\n\nThe problem comes when its a small fix in a huge monolithic project, although it could catch basic, obvious errors that an IDE, testing framework or continuous integration system should catch anyway its unlikely to catch anything serious "], [1, "Having design reviews is not an alternative, but IMO a necessity if the work is known to be more substantial than some limit, e.g. 3-5 days. For complex features, both should be mandatory."], [-2, "A code review shouldn't be an opinion. If 90% of code reviews can't be automated by a linter or static analysis on a CI platform then they are just opinions AKA bureaucracy. "]], [[{"comment": "a few peer reviews in my career have been valuable, but i've stopped proceeding from the assumption that the peer reviewer is right", "id": "damdo78"}], [{"comment": "I understand the need for code reviews, in pretty much any other job role you a peer reviewed (maybe not always in such a structured way but it happens) and development shouldn't be any different IMO.\n\nThe problem comes when its a small fix in a huge monolithic project, although it could catch basic, obvious errors that an IDE, testing framework or continuous integration system should catch anyway its unlikely to catch anything serious ", "id": "dam6t6i"}], [{"comment": "Having design reviews is not an alternative, but IMO a necessity if the work is known to be more substantial than some limit, e.g. 3-5 days. For complex features, both should be mandatory.", "id": "damkl3f"}], [{"comment": "A code review shouldn't be an opinion. If 90% of code reviews can't be automated by a linter or static analysis on a CI platform then they are just opinions AKA bureaucracy. ", "id": "damcuc2"}, {"comment": "Yeah, cause it's never happened that one developer knew something about a subject that another didn't.", "id": "damei61"}, {"comment": "I said 90% , not 100% . Code review is bureaucracy anyway.", "id": "damepdz"}]]], "5fp5vy": ["01 The History of Standard ML: Ideas, Principles, Culture", "2016-11-30 14:41:52", 26, "https://www.youtube.com/watch?v=NVEgyJCTee4", [[8, "Standard ML is an underappreciated gem of a little language. I think of it as the typed equivalent of Scheme, in essence. There are also very nice free implementations, like [PolyML](http://polyml.org/), that are nevertheless industrial strength. Recommended!"], [2, "The audio/slide size make it a little difficult to follow along. If you're interested in Standard ML, which truly is a gem of a language, with an astonishingly small syntax, I highly recommend checking out Prof. Dan Grossman's MOOC on Coursera (Programming Languages, Part A). As the name indicates, it's an introduction to programming concepts. It just happens to use functional programming in Standard ML as the starter vehicle."], [1, "can anyone hearthis? the audio is really bad for me"]], [[{"comment": "Standard ML is an underappreciated gem of a little language. I think of it as the typed equivalent of Scheme, in essence. There are also very nice free implementations, like [PolyML](http://polyml.org/), that are nevertheless industrial strength. Recommended!", "id": "dameeyw"}, {"comment": "It even made me rethink my sexp fetish. As an emacs user and lisp lover, it takes a special syntax to unbolt that ;).", "id": "dameh7g"}, {"comment": "I had a class in college where we used [Standard ML of New Jersey](http://www.smlnj.org/). It was a delight program in.", "id": "damywri"}], [{"comment": "The audio/slide size make it a little difficult to follow along. If you're interested in Standard ML, which truly is a gem of a language, with an astonishingly small syntax, I highly recommend checking out Prof. Dan Grossman's MOOC on Coursera (Programming Languages, Part A). As the name indicates, it's an introduction to programming concepts. It just happens to use functional programming in Standard ML as the starter vehicle.", "id": "dan0jxw"}, {"comment": "Took the first run, it was pretty interesting. Dan Grossman's website also lists the following, non MOOC, classes he teaches; for the curious.", "id": "dan8glc"}], [{"comment": "can anyone hearthis? the audio is really bad for me", "id": "damzj7o"}, {"comment": "I only had one channel but no other issues listening or understanding the speaker, even at 1.5x.\n\nIf you know mpv you can try `mpv --af=drc=2:0.25 --ytdl <URL>` it may help enhance the \"volume\".", "id": "dan8flo"}]]], "5g4o5c": ["Writing Go assembly functions with PeachPy", "2016-12-02 20:56:48", 8, "https://blog.gopheracademy.com/advent-2016/peachpy/", [], []], "5frk8b": ["Do you like Scala? Give Haskell a try! :: FP Complete", "2016-11-30 22:24:00", 5, "https://www.fpcomplete.com/blog/2016/11/comparison-scala-and-haskell", [], []], "5fq30a": ["New movie coming soon - The Regex from HELL", "2016-11-30 18:10:53", 0, "https://www.linkedin.com/pulse/regex-from-hell-dave-barter?published=t", [], []], "5fpz0z": ["Solutions to multiple inheritance in Kotlin", "2016-11-30 17:49:26", 2, "https://sites.google.com/a/athaydes.com/renato-athaydes/posts/solutionstomultipleinheritanceinkotlin", [], []], "5fu7ba": ["Javascript exploit actively used against TorBrowser", "2016-12-01 06:08:08", 1, "https://lists.torproject.org/pipermail/tor-talk/2016-November/042639.html", [], []], "5gey5y": ["Firebird 3 by default in LibreOffice 5.4 (Base)", "2016-12-04 13:52:32", 1, "http://www.firebirdnews.org/firebird-3-by-default-in-libreoffice-5-4-base/", [], []], "5g3bwy": ["Ruby Day 2016", "2016-12-02 16:48:32", 0, "http://dev.mikamai.com/post/153943325949/ruby-days", [], []], "5fwc2u": ["Webgl particles morph experiment", "2016-12-01 15:36:54", 1, "http://oos.moxiecode.com/js_webgl/particles_morph/", [[2, "Ah man, I love OutsideOfSociety, he changed Flash game development years ago by making the first tile-based scrolling system. Awesome to see him still making awesome stuff (even if his blog never gets updated)!"], [1, "That's really cool effect! One bug I noticed is that when my mouse goes onto my second screen it doesn't seem to respond to the mouse input anymore (for the rotation)\n"]], [[{"comment": "Ah man, I love OutsideOfSociety, he changed Flash game development years ago by making the first tile-based scrolling system. Awesome to see him still making awesome stuff (even if his blog never gets updated)!", "id": "danqu0j"}, {"comment": "I'm a fan of him too.", "id": "dap72kp"}], [{"comment": "That's really cool effect! One bug I noticed is that when my mouse goes onto my second screen it doesn't seem to respond to the mouse input anymore (for the rotation)\n", "id": "danjdlw"}]]], "5gdfot": ["Dear Product Managers \u2026 (From: Your Team)", "2016-12-04 06:07:48", 1, "https://hackernoon.com/dear-product-managers-c488ba6386ea#.l04r4dz4b", [[1, "Totally agree. We are also starting to measure our work in term of outcomes for the customers. Until now we were measured on those useless velocity metrics and so forth you mention."]], [[{"comment": "Totally agree. We are also starting to measure our work in term of outcomes for the customers. Until now we were measured on those useless velocity metrics and so forth you mention.", "id": "darp19p"}]]], "5ga0pa": ["3D experiment with flat image", "2016-12-03 18:28:00", 0, "http://lab.aerotwist.com/webgl/surface/?de", [[2, "doesn't work on chrome, win 10, surface book."], [1, "doesn't load in firefox with uMatrix and uBLockOrigin"], [0, "k"]], [[{"comment": "doesn't work on chrome, win 10, surface book.", "id": "daqqepq"}], [{"comment": "doesn't load in firefox with uMatrix and uBLockOrigin", "id": "daqwq3q"}], [{"comment": "k", "id": "daqni92"}]]], "5fs3r5": ["Programming Blogging", "2016-11-30 23:53:13", 0, "https://emptysqua.re/blog/resources-for-writing-about-programming/", [], []], "5g62y9": ["Camille Fournier\u2014Building and Motivating Engineering Teams", "2016-12-03 01:02:07", 0, "http://www.elidedbranches.com/2016/11/building-and-motivating-engineering.html?spref=tw", [], []], "5fs4ow": ["[Java] nbvcxz: password strength estimator - initial release", "2016-11-30 23:57:29", 0, "https://github.com/GoSimpleLLC/nbvcxz", [[3, "Nice try NSA..."], [1, "I've been working on this library on and off for a while now, and have been using it internally at my company for the past ~6 months.  It uses a lot of the same password matching methods as the zxcvbn library from Dropbox, as that was the inspiration for this library.\n\nI just spent the past few days cleaning up the code, adding any comments wherever necessary, getting things set up to release to maven central, etc.\n\nWould love to hear any feedback you may have."]], [[{"comment": "Nice try NSA...", "id": "damotrs"}, {"comment": "You can check the code yourself.  There is a good reason software like this must be released with source code available.\n\nThat is actually the reason I didn't set up a \"demo\" site like is available for zxcvbn (which is client side only)... there is no way for a user to ensure nothing nefarious is going on and I felt it would seem shady even with the best intentions. So instead of an online demo, I made sure it was usable as a console program.", "id": "damp2lb"}, {"comment": "I gotchu fam. Thanks for making it open source, might give it a try when I get home tonight :)\n\nKeep up the good work!", "id": "dampc20"}], [{"comment": "I've been working on this library on and off for a while now, and have been using it internally at my company for the past ~6 months.  It uses a lot of the same password matching methods as the zxcvbn library from Dropbox, as that was the inspiration for this library.\n\nI just spent the past few days cleaning up the code, adding any comments wherever necessary, getting things set up to release to maven central, etc.\n\nWould love to hear any feedback you may have.", "id": "dammbs2"}]]], "5g2ml7": ["Automating Jenkins management with Job DSL", "2016-12-02 13:36:13", 1, "http://www.appliscale.io/blog/jenkins-job-dsl-automate-jenkins/", [], []], "5g42xg": ["How were bugs reported for compilers that shipped on and were installed via floppy disks?", "2016-12-02 19:15:19", 4, "http://retrocomputing.stackexchange.com/q/1818/621", [], []], "5ftju6": ["An unassuming F# study plan", "2016-12-01 04:04:05", 24, "http://biarity.me/2016/11/30/An-unassuming-F-study-plan/", [[8, "Whish it was seen as a top prioritised language by Microsoft and that it would work flawlessly in .net core . It would be nice if intellij started f# support as well"], [5, "Great, I think this is a good starting guide for F#."], [2, "I like the 10 reasons to learn F# and the way you structured the various levels of experience with good recommendations for starting out. Time to get to work!"], [2, "I'd really love to know what other companies besides Jet are using F#.\n\nAlso, nice blog! I like the design and the articles so far."], [1, "I wish f# had an interface like Ipython, it's such a powerful way to explore what's available.. f#'s repl is pretty bad. Xamarin studio (and now vs for Mac) has a better repl window than the one built into visual studio"]], [[{"comment": "Whish it was seen as a top prioritised language by Microsoft and that it would work flawlessly in .net core . It would be nice if intellij started f# support as well", "id": "danb2jq"}, {"comment": "Agreed, would probably make for sense to jetbrains to support f# in project rider rather than intellij but they've expressed that even that isn't a priority for them :(", "id": "dane519"}, {"comment": "Help it become supported by voting: https://youtrack.jetbrains.com/issue/RIDER-574.", "id": "danebir"}], [{"comment": "Great, I think this is a good starting guide for F#.", "id": "dan19rp"}], [{"comment": "I like the 10 reasons to learn F# and the way you structured the various levels of experience with good recommendations for starting out. Time to get to work!", "id": "dan6o4v"}, {"comment": "Thanks! I tried reflecting on what I would've wanted when first starting out. Good luck on your learning endeavour!", "id": "dan7bvi"}], [{"comment": "I'd really love to know what other companies besides Jet are using F#.\n\nAlso, nice blog! I like the design and the articles so far.", "id": "danvkmx"}], [{"comment": "I wish f# had an interface like Ipython, it's such a powerful way to explore what's available.. f#'s repl is pretty bad. Xamarin studio (and now vs for Mac) has a better repl window than the one built into visual studio", "id": "daprnio"}, {"comment": "See [IfSharp](http://fsprojects.github.io/IfSharp/).", "id": "daqz4kz"}]]], "5g2gpf": ["CHL - A Library for writing web applications in C [FastCGI]", "2016-12-02 12:44:13", 12, "https://github.com/it4e/CHL", [[19, "> What makes CHL uniqe is the support for executing functions inside HTML files, much like PHP using the <?php ?> syntax\n\nGreat! Now we can have the elegance and consistency of PHP, combined with the safety and ease of use of C!"]], [[{"comment": "> What makes CHL uniqe is the support for executing functions inside HTML files, much like PHP using the <?php ?> syntax\n\nGreat! Now we can have the elegance and consistency of PHP, combined with the safety and ease of use of C!", "id": "daoyx34"}, {"comment": "This really segfaulted my PHP script.", "id": "dap7g11"}, {"comment": "What?", "id": "daqi7at"}]]], "5ft38p": ["Mobile App Developers: share your experience & help us improve it!", "2016-12-01 02:40:50", 0, "https://umdsurvey.umd.edu/SE/?SID=SV_5aHC5jcIlFOk2bz", [[1, "Hi! I hope this is welcome on this sub, but if not, please let me know and I'll take it down.\n\nIf there are any of you who are as enthused about privacy and development as I am, I hope you'll consider sharing this link with other mobile devs you know! The survey is a bit long, so we are offering a reward: we're raffling 10 $50 Amazon GCs. We're only planning to recruit ~100 participants this way, so there's a decent chance in the raffle :) \n\nHere's the text we told the IRB we would use to recruit :) :\n\nMake your experience heard! We are researchers at the University of Maryland studying the hard problem of privacy in mobile software development. Lots has been written about this topic, but missing is the perspective of the people developing mobile apps. Whether you are developing independently, for clients, on contract, or full-time for a company, your experience and insight is key.\n\nWe estimate this survey will take less than 30 minutes of your time, and you will be entered to win one of 10 $50 amazon gift cards. Your ideas and insights are essential to our understanding and improving the experience of software developers. To participate, you must be 18 or older. If you have any questions before participating in the study, please contact Karen at klboyd@umd.edu.\n\nIf the link above fails, here's the URL: https://umdsurvey.umd.edu/SE/?SID=SV_5aHC5jcIlFOk2bz\n"]], [[{"comment": "Hi! I hope this is welcome on this sub, but if not, please let me know and I'll take it down.\n\nIf there are any of you who are as enthused about privacy and development as I am, I hope you'll consider sharing this link with other mobile devs you know! The survey is a bit long, so we are offering a reward: we're raffling 10 $50 Amazon GCs. We're only planning to recruit ~100 participants this way, so there's a decent chance in the raffle :) \n\nHere's the text we told the IRB we would use to recruit :) :\n\nMake your experience heard! We are researchers at the University of Maryland studying the hard problem of privacy in mobile software development. Lots has been written about this topic, but missing is the perspective of the people developing mobile apps. Whether you are developing independently, for clients, on contract, or full-time for a company, your experience and insight is key.\n\nWe estimate this survey will take less than 30 minutes of your time, and you will be entered to win one of 10 $50 amazon gift cards. Your ideas and insights are essential to our understanding and improving the experience of software developers. To participate, you must be 18 or older. If you have any questions before participating in the study, please contact Karen at klboyd@umd.edu.\n\nIf the link above fails, here's the URL: https://umdsurvey.umd.edu/SE/?SID=SV_5aHC5jcIlFOk2bz\n", "id": "damtn4e"}]]], "5g6v8z": ["Steering Behaviors For Autonomous Characters", "2016-12-03 03:32:57", 5, "http://www.red3d.com/cwr/steer/gdc99/", [[2, "I have worked with boids on multiple occasions in the past. The results are always impressive. Also very useful for controlling NPC vehicles on a 2D plane. I've written a racing game based on boids, and the collision avoidance looked so natural.\n\nThe secret behind implementing a good collision avoidance is prediction. Basically, each agent needs to predict the position of other agents in the future and make collision avoidance decisions based on that future position. Pursuit behaviour is pretty much the same, except the predator agent uses an attraction strategy, as opposed to avoidance."]], [[{"comment": "I have worked with boids on multiple occasions in the past. The results are always impressive. Also very useful for controlling NPC vehicles on a 2D plane. I've written a racing game based on boids, and the collision avoidance looked so natural.\n\nThe secret behind implementing a good collision avoidance is prediction. Basically, each agent needs to predict the position of other agents in the future and make collision avoidance decisions based on that future position. Pursuit behaviour is pretty much the same, except the predator agent uses an attraction strategy, as opposed to avoidance.", "id": "daq64vz"}]]], "5g5zy5": ["George Hotz is giving away the code behind his self-driving car project", "2016-12-03 00:46:48", 0, "http://www.theverge.com/2016/11/30/13779336/comma-ai-autopilot-canceled-autonomous-car-software-free", [], []], "5fwgex": ["2016 Software Engineering Internship Amazon Interview Experience", "2016-12-01 16:07:05", 115, "https://rajk.me/amazon-interview-experience/", [[86, "What the fuck?"], [51, "Question 8: are you willing spend 20 hours each day in a cubicle while being subjected to bullying from executives?"], [14, "Sounds like you dodged a bullet there. Why are you not allowed to move your head ? Whats to stop you have another machine on a KVM ?"], [12, ">I have refused to continue with the next step due to strong privacy considerations.\n\nIt's to deter cheating.\n\nI've done code tests with applicants. One tab we have a Hangouts open, and in the other tab we have the coding problem. \n\nYou can tell by watching their eyes if they are opening a new tab. You can then see/hear if they are typing, but no code is going into the test tab. \n\nI'm assuming this isn't proctored live, they probably want video/audio so they can see if an applicant is looking up things on their phone/another machine/somebody else in the room, etc.\n"], [8, "These remind me of the logic questions for OkCupid profiles. "], [6, "So what I really want to know is: Wth is the answer to [this one](https://i.imgur.com/OnOMJgr.png):\n\n    27 : 24 :: 64 : ?\n    \u2610 62\n    \u2610 63\n    \u2610 60\n    \u2610 46\n\n24 = \u221b27 * 8, \u221b64 * 8 = 32... nope\n\n24 = \u219427 / 3, \u219464 / 3 \u2209 \u2124... nope (\u2194 reversing the digits)\n\n24 = 27 - 3, 64 - 3 = 61... nope\n\n24 = 27 * \u2078/\u2089, 64 * \u2078/\u2089 \u2209 \u2124... nope "], [2, "> It is true that it'd be pretty easy to circumvent the tracking, by placing paper over the webcam\n\nIf it detects that you have a webcam but it can't see anything then that would probably be an automatic failure. "], [2, "> Before the exam starts, put on the Google Glass that you received from us by mail. Keep wearing them for the full 8 hours after which the timer automatically unlocks the titanium latch.\n\nNooooo way!!!!"], [2, "So, are you a replicant?"], [1, "I've been a bit surprised that very few people voiced any concern about the obvious IQ test questions, even with it being mentioned in the submission.\n\nAre these sort of questions less rare than I expect? I thought they were borderline illegal, or at best actively discouraged during technical interviews since they don't prove anything. I think Google came out right and said there was no correlation between being good at such questions and being a good programmer."], [1, "The first question looks like copied directly from a generic B2 English comprehension test."], [1, "As everyone else is pointing out, this sounds creepy but it's to see what resources you use and how you solve the problems. They'll watch if you write down everything down on paper or on screen, and listen to you explain your processes. Google will do the same but will be on the line and literally watch you do it live. It's really no different than doing the interview test in their office with someone watching.\n\nAs for your criticism of the strange questions, it's like an IQ test. Your performance isn't really a determinant factor in getting hired, but it helps them gauge your potential. It's all mostly simple reasoning and math skills that geniuses will generally perform better at. It's a common sort of test at tech companies and I assume others too."], [0, "> Hopefully these should convince you that this test has absolutely nothing to do with programming skill. \n\nThis does nothing of the sort. If a correlation exists, as far as Amazon is concerned, with doing well on such a test and performing well at programming, then they can test you in whatever way they see fit. Personally, I also think there would be a correlation.\n\nAnd I mean... What is programming if not analysis and logic? What did you want them to test you on? The arcane intricacies of the `printf` function?\n"], [1, "Anyone know the answer to the 27:24 :: 64 : ?\n\n These 4 numbers are the choices, i cant figure it out: 62 63 60 46"], [1, "I had a straightforward process applying for a Summer 2016 internship with Amazon for the Seattle office. First a HackerRank-like coding challenge (no one observed me), and then a technical interview with an employee over a shared document.\n\nLet's hope Amazon doesn't start following [Epic's](http://www.epic.com/) footsteps."], [1, "I always hate questions like these.  They want the answer they want, when there may be several right answers.  Like the \"Four Options\" one.  POM is the only one with a vowel in the second position.  The answer they probably want is UVS because it's not read backward with the second letter dropped out.\n"], [1, "I interned at Amazon last summer and blogged my interview experience here (http://isaacjordan.me/blog/2016/03/amazon-development-centre-interview-experience/). There was nothing like this, although I was in the UK."], [0, "The Proctorio is pretty common for if you want to for example Microsoft examinations at home.\n\nIt just means your microphone and webcam will be pointed at you at the time of the exam. Honestly not a really big deal IMO."], [0, "Meh, you are better off without them"], [-3, "How did you 'refuse to continue' at the disclaimer screen, while still answering all of the questions? That's impossible, isn't it? The disclaimer is the first page you hit, meaning you must have consented to it, and gone through all of the coding questions - no? You said you hit that in the second assessment, but I'm 99% sure you would have gone through that screen for the 7 programming questions from the first assessment."]], [[{"comment": "What the fuck?", "id": "dann25j"}, {"comment": "Seriously. There are far better-paying and rewarding jobs than working at Amazon as a friggin' intern that don't require this level of crap to get.", "id": "dao83vd"}, {"comment": "There are enough people who want Amazon on their resume and will jump through any hoop to get it. Amazon doesn't care what people think of their interview practices because they don't have to.", "id": "daodov2"}, {"comment": "Better paying for an intern? Probably not. I applied for and got an internship at Amazon Robotics and they pay $35/hour, which is damn good for an undergraduate internship. Although, I turned it down, because like you said, there are way more rewarding jobs.\n\nThe interview process for Amazon Robotics was also way less shit - just a single, in person interview. The worst part about that was a single white boarding question, although at least it wasn't fizzbuzz.", "id": "daoutuy"}, {"comment": "There's nothing wrong with any of this as long as it's done with consent (which it is). If you're building a product and you can't analyze people on site then using their webcam is as close as you can get to seeing their reaction to various parts of what you're building, which will help you improve the product. The same applies for an interview process. In this case it also serves as an anti-cheating measure.\n\n", "id": "dao7v49"}, {"comment": "Why stop there? Just because they are giving consent doesn't mean they can do whatever they want. ", "id": "dap2ee6"}, {"comment": "Actually it does mean they can do whatever you agree to. If you don't agree with it just get a job somewhere else, like the guy in this article did. But there's nothing wrong with they're doing.", "id": "dap446n"}, {"comment": "I'm not sure why most people are freaking out here. These are purely for anti-cheating measures, and for simple data analysis when it comes to what is collected (does this work? should be change x or y? etc...). They want to reach more people, and streamlining the interview process I would guess accomplishes that.\n\nOn a serious note, if you have a fresh browser window open and you're in a room with nothing but a wall in the background - what can possibly be collected? I don't know, this isn't any worse than having a Facebook account. I say that, because you're aware that you're being interviewed and for a timed period. Additionally, you've already submitted your personal information. It's an interview, not a questionnaire :s. ", "id": "dao8wr0"}], [{"comment": "Question 8: are you willing spend 20 hours each day in a cubicle while being subjected to bullying from executives?", "id": "dano16t"}, {"comment": "Amazon interns a treated amazingly well. Every other weekend will be some bit event, all paid for. Get you in the door that way.", "id": "dao369x"}, {"comment": "Of the people I know that interned at Amazon, all have said that it was a sweatshop.  One even took a semester off because he was so burned out from it.", "id": "daoce28"}, {"comment": "I interned at Amazon, and I only met 1 intern who had a bad experience.", "id": "daog3q2"}, {"comment": "Damn. That's new then. Good though, they used to treat them with kid gloves, hoping to snare them for the sweat shop for longer.", "id": "daod3xc"}, {"comment": "Almost everyone I know that is FTE at Amazon talks about hazing the interns, so no, that is probably not true. Amazon is a brutal place to work for everyone involved, and I'd imagine the lower you go the worse it gets.", "id": "daof1sr"}], [{"comment": "Sounds like you dodged a bullet there. Why are you not allowed to move your head ? Whats to stop you have another machine on a KVM ?", "id": "danqku5"}, {"comment": "You are allowed to move your head.", "id": "daoyxne"}], [{"comment": ">I have refused to continue with the next step due to strong privacy considerations.\n\nIt's to deter cheating.\n\nI've done code tests with applicants. One tab we have a Hangouts open, and in the other tab we have the coding problem. \n\nYou can tell by watching their eyes if they are opening a new tab. You can then see/hear if they are typing, but no code is going into the test tab. \n\nI'm assuming this isn't proctored live, they probably want video/audio so they can see if an applicant is looking up things on their phone/another machine/somebody else in the room, etc.\n", "id": "dans99i"}, {"comment": "In one sense -- I'd call that cheating.  In another I'd call that modern day programming.  We all use stackoverflow/etc to lookup and code problems now.  Maybe timing how quickly they can accomplish this is a better test of skill...", "id": "dant38q"}, {"comment": "The web has replaced piles of books at your desk, I don't see why it's frowned upon.", "id": "danukeh"}, {"comment": "I literally have told people that they are free to google up the standard functions and how they work if they can't remember (like regex), but I just need to know that they are doing so.", "id": "dao9dl6"}, {"comment": "Alternatively since Amazon is a big company they could have all the answers online so someone could just google it and get the answer right away", "id": "danuvby"}, {"comment": "Also, they could get a one-time help from a friend or something. A friend can help you get a job with cheating but he won't be there to do the job for you once you are hired.", "id": "danzzt5"}, {"comment": "If you're getting hired from a virtual tech test and no on-site, they've got larger problems.", "id": "dao8pzi"}, {"comment": "Sure, but that doesn't help you assess the candidate:\n\n_\"How would you implement a binary search?\"_\n\n_\"I'd google it and copy paste the answer\"_\n\nNow what? Are you going to hire that person?\n\nI've had candidates give me this kind of glib answer. I usually smile, say \"Sure, I would do that myself and it's perfectly acceptable, but now, how would you implement it yourself?\".\n", "id": "daobsd5"}, {"comment": "Ideally you would never ask a candidate to code something that well known.", "id": "daoc4zi"}, {"comment": "A binary tree is pretty basic. If you can't build that then how can you build something less known?", "id": "daon9ck"}, {"comment": "Well he was talking about binary search, which isn't exactly the same thing as a tree.  But the assumption for a lot of these interviews is that people have studied these common algorithms extensively, and if you really want to gauge how the person solves something they haven't seen you need to give them a more obscure problem.  ", "id": "dapig9w"}, {"comment": "Yes it is so basic that \n    Array.BinarySearch()\nwould do it trivially. ", "id": "daot5gv"}, {"comment": "You'd be surprised how effective it is to filter out candidates, especially on the phone.\n\nThe number of candidates who have no idea how a hash map is implemented is terrifying.\n", "id": "daod5a1"}, {"comment": "Do you even know how the hashmap is implemented in that language std library, except from textbook hashing theory.", "id": "daot7no"}, {"comment": "Why? You write hashmaps often?", "id": "daoq348"}, {"comment": "Never, why?\n", "id": "daoupzh"}, {"comment": "So not knowing how a hashmap is implemented is terrifying why?", "id": "dap4jhx"}, {"comment": "Right. Ocassionally we'd call people out on opening tabs, etc, and if they were honest \"I can't remember exactly how to do this and I want to do it so it's X correct\" I wouldn't hold it against them.\n\nIf they were like \"Even though I told you I'm an expert in this, I have no idea what it is, so I'm looking it up on the sly\" or \"I'm not looking it up\" then that was a strike in my book.\n\nLeading with \"I don't know, can I look that up?\" was also fine by me. Nothing wrong with saying \"I don't know\" and then taking the initiative to learn about it.\n\n (we only did this with a handful of applicants, and it was like three years ago, so my memories are a bit fuzzy)", "id": "danz092"}, {"comment": "Either way, you should say up front whether they can look things up and when looking things up, you should probably explain what you're looking up. Being mostly unfamiliar with JS in one of my first interviews, I looked up a confirmation that JS strings were immutable after running into weird behaviour while testing the code. The interviewer saw me go through the process of writing some code, testing it, finding a bug, and figuring out something I didn't know about the language in order to fix it.", "id": "daoepwj"}, {"comment": "In still another sense, if you're interviewing for a python job and you can't solve a relatively simple python coding task without googling then I don't want to hire you.\n\nI'm a teacher, and for the AP exam my *high school* students have to write Java solutions under time pressure on *paper* with no computer in sight and virtually no reference materials.\n\nI'd hope a job interview would have higher standards for coding skill, not lower.", "id": "dao0ue9"}, {"comment": "The way AP CS is taught in high schools is baffling and harmful to actually teaching people to program.  Expecting someone to memorize Java syntax isn't useful when every software engineer in industry is using an IDE.  It's much better to spend that time learning Big O or math than to penalize someone for writing a for loop wrong.", "id": "daohq6c"}, {"comment": "I've been teaching high school students how to code for nearly twenty years. My program is very strong; I now have former students that work at Microsoft, Rooster Teeth, Dropbox and Google.\n\nThey also learn Big-O (it's tested on the AP exam) and math and I promise you students only lose a tiny amount of points for getting a minor detail of a `for` loop wrong on the AP exam.\n\nIs [my book](https://learnjavathehardway.org/) also harmful to teaching people how to program? My [assignments](http://programmingbydoing.com/)?\n\nHow do *you* teach AP CS in high school?", "id": "daojdxv"}, {"comment": "So having a student in Microsoft/Google is proof of teaching skill.", "id": "daotcqp"}, {"comment": "My classes give students an extremely strong foundation. Because their skill level at age 18 is stronger than their peers, they are sometimes able to get into elite university programs. (I currently have a few former students in UT's [Turing Scholars](http://www.cs.utexas.edu/turing-scholars) program, for example.)\n\nAnd once they make it through programs like that, they can pretty much work wherever they want, including places like Microsoft or Google.\n\nWith a different high school teacher, it's much less likely that even these strong students would have made it into a program like Turing Scholars and that limits their attractiveness to certain employers down the road.\n\nObviously people with terrible high-school teachers get hired all the time, but usually strong candidates were helped by a strong education along the way.", "id": "dap5zw6"}, {"comment": "Do Microsoft / Google hire full-time developers straight out of high-school...?", "id": "daow136"}, {"comment": "Probably not often. My students went to college first.", "id": "dap5efy"}, {"comment": "It doesn't make a lot of sense to me.\n\nI've coded in everything from ASM to Python and C++ but unless I've been using a language day in and out for months I will almost certainly be looking up up how to properly call in-built functions.\n\nPersonally, I would be more interested in how a candidate does with resources for a language they have little experience in than how they do with no resources for a language they are super experienced in. It tells you more about their abilitly to learn and deal with adverse situations.", "id": "dao7q33"}, {"comment": "For an in-person interview that makes a lot of sense, because you can be sure they're not cheating.\n\nBut I don't think it's unreasonable to expect a certain level of memorized skill in a language *the person is interviewing for*.\n\nThis is a first-tier screen that's looking for a minimum level of competence. OP said they were looking for a \"software engineering\" job at Amazon. This is a highly skilled position, and the job listing probably even listed the programming language they needed to know.\n\nIf you're applying to be a software engineer and the listing says you need to be highly skilled in, say, Java, then I'm not even going to waste my time with an in-person interview if you can't code something simple in Java with no references. Like, if you can't do [Project Euler Problem #4]( https://projecteuler.net/problem=4) in 20-30 minutes in the language of your choice with no references, then I'd argue you don't actually know how to code well enough to get a job as a software engineer.\n\nThen, once you've proven you can code at all you get a face-to-face interview where they can test those other things. Make you do pseudo code on a tougher problem. Test your ability to learn something new quickly.\n\nBut basic coding ability is required to get your foot in the door.", "id": "daofs5f"}, {"comment": "It's funny, because when I was in college my professors told us not to waste time with jobs asking you to know any specific **languages**.", "id": "daotuxl"}, {"comment": "I agree with that 100%. But once you've applied for one of those jobs (like OP), you'd better actually *know* that language well.", "id": "dap4xbj"}, {"comment": "Companies generally don't hire you because you know a specific programming language, they do it because you know how to solve problems or develop a product, and sometimes knowing a specific language is a helpful tool to make you productive at those tasks faster. It's far more important to know how to solve a problem than it is to know syntax trivia for a particular language. It's quite easy to look up \"how to open a file in <language>\" and quite difficult to look up what is causing some customer purchases to not go through, let alone how to fix it.", "id": "daovw6m"}, {"comment": "I agree with you 100%. I'm just saying: don't apply for a job that's looking for specific coding language skill unless you *actually* can code in that language well enough to do a lot of things without Google.", "id": "dap4zaw"}, {"comment": "I'm a software developer with 20 years experience of coding and a good deal experience of hiring other developers. I look for people who can code. In an interview I'm not worried about the basic syntax. (Obsessing over syntax and be a red flag in it's self...)", "id": "daow3i6"}, {"comment": "So basically, Amazon automated an on-site in person interview and they can review you at their leisure.\n\nThis is.... unpleasant. If for nothing else then the fact that I HAVE to install spyware on my personal computer in order to give their test. ", "id": "dantmn9"}, {"comment": "Of course it's to deter cheating, I don't think anyone's confused about their goal. But if my high school had put cameras in the bathrooms to make sure people weren't checking answer keys during exams, I would've had privacy concerns about that too", "id": "danyc0t"}], [{"comment": "These remind me of the logic questions for OkCupid profiles. ", "id": "daodmr2"}], [{"comment": "So what I really want to know is: Wth is the answer to [this one](https://i.imgur.com/OnOMJgr.png):\n\n    27 : 24 :: 64 : ?\n    \u2610 62\n    \u2610 63\n    \u2610 60\n    \u2610 46\n\n24 = \u221b27 * 8, \u221b64 * 8 = 32... nope\n\n24 = \u219427 / 3, \u219464 / 3 \u2209 \u2124... nope (\u2194 reversing the digits)\n\n24 = 27 - 3, 64 - 3 = 61... nope\n\n24 = 27 * \u2078/\u2089, 64 * \u2078/\u2089 \u2209 \u2124... nope ", "id": "daofbdx"}, {"comment": "I went backwards and looked at the choices to see which one I could make a consistent rule for. With `27 : 24 :: 64 : 60`, you have `n : n - \u221bn` on each side of the `::`. Don't know if it's the right answer.", "id": "daog1jj"}, {"comment": "Oh, good point. I was close with the cube root, but that was probably it. Recognizing both numbers as perfect cubes is pretty quick.", "id": "daogiye"}, {"comment": "60 is my guess without any real work to show  as well.  I'm far to removed from these equations :(\n\n    9 : 8 :: 16 : 15", "id": "daoilss"}, {"comment": "The left side of single colon is n^3 while the right side of single colon is n*((n^2) - 1)", "id": "daov9iq"}, {"comment": "n\\^3 : (n-1)\\*n\\*(n+1) :: 27 : 24 :: 64 : 60\n\nbut the problem is that there multiple solutions so even if you find one, you can be never sure that there is no other simpler", "id": "dap36t3"}, {"comment": "I love how these solutions people are giving get progressively more and more factored.", "id": "dapcqb2"}], [{"comment": "> It is true that it'd be pretty easy to circumvent the tracking, by placing paper over the webcam\n\nIf it detects that you have a webcam but it can't see anything then that would probably be an automatic failure. ", "id": "dannz5p"}, {"comment": "Doesn't this open Amazon to lawsuits?\n\n\"You didn't hire me based on my race\"\n\n\"You discriminated against me based on my appearance\"\n", "id": "dao1zss"}, {"comment": "In that respect it's no different from an on-site interview", "id": "daoan6u"}, {"comment": "\"No, we didn't. You just were not a fit for that position\".\n\nHow are you going to prove your case?\n", "id": "daobu9c"}, {"comment": "It's weird that I have less a problem with taking video than mouth and eye tracking, even though having video allows you to do that analysis. It's \"nice\" that we get to know they are taking that data but it's creepy. I wonder if they are trying to take in data from interview through employment to see if they can identify good workers from body language or other features.", "id": "danq4lo"}, {"comment": "Hirevue does this.", "id": "daovx5j"}, {"comment": "Does the test fail if you disable the webcam? Why put paper over it?", "id": "dao04dc"}, {"comment": "The test requires a microphone and webcam.", "id": "dao5a3j"}], [{"comment": "> Before the exam starts, put on the Google Glass that you received from us by mail. Keep wearing them for the full 8 hours after which the timer automatically unlocks the titanium latch.\n\nNooooo way!!!!", "id": "daokpih"}], [{"comment": "So, are you a replicant?", "id": "daot8mq"}], [{"comment": "I've been a bit surprised that very few people voiced any concern about the obvious IQ test questions, even with it being mentioned in the submission.\n\nAre these sort of questions less rare than I expect? I thought they were borderline illegal, or at best actively discouraged during technical interviews since they don't prove anything. I think Google came out right and said there was no correlation between being good at such questions and being a good programmer.", "id": "dao78b3"}, {"comment": "That's incentive for the company to not use them, not a reason for them to be illegal. If s company chooses to use interview questions that have been found to not predict future employee success that's their prerogative. Maybe Amazon has found different results than Google with these sorts of questions.", "id": "daow066"}, {"comment": "> That's incentive for the company to not use them, not a reason for them to be illegal.\n\nThey're borderline illegal because it is illegal to give candidates an IQ test. Of course companies can do whatever they want, and will get away with it as long as it's not handed out as an IQ test but instead a \"programming quiz\" that has nothing to do with programming.", "id": "dapiua9"}], [{"comment": "The first question looks like copied directly from a generic B2 English comprehension test.", "id": "dao8nb1"}], [{"comment": "As everyone else is pointing out, this sounds creepy but it's to see what resources you use and how you solve the problems. They'll watch if you write down everything down on paper or on screen, and listen to you explain your processes. Google will do the same but will be on the line and literally watch you do it live. It's really no different than doing the interview test in their office with someone watching.\n\nAs for your criticism of the strange questions, it's like an IQ test. Your performance isn't really a determinant factor in getting hired, but it helps them gauge your potential. It's all mostly simple reasoning and math skills that geniuses will generally perform better at. It's a common sort of test at tech companies and I assume others too.", "id": "daocnju"}, {"comment": ">  It's really no different than doing the interview test in their office with someone watching.\n\nIt's the difference between you going down to the station to give a statement to the police, and the police insisting on coming into your bedroom to take your statement.", "id": "daouv7h"}, {"comment": "You don't have to do it in your bedroom... You can go somewhere else like a library to do it. So no it's not like that.", "id": "dap4nl6"}], [{"comment": "> Hopefully these should convince you that this test has absolutely nothing to do with programming skill. \n\nThis does nothing of the sort. If a correlation exists, as far as Amazon is concerned, with doing well on such a test and performing well at programming, then they can test you in whatever way they see fit. Personally, I also think there would be a correlation.\n\nAnd I mean... What is programming if not analysis and logic? What did you want them to test you on? The arcane intricacies of the `printf` function?\n", "id": "daoe1cv"}], [{"comment": "Anyone know the answer to the 27:24 :: 64 : ?\n\n These 4 numbers are the choices, i cant figure it out: 62 63 60 46", "id": "daofe3p"}, {"comment": "I got an answer: https://www.reddit.com/r/programming/comments/5fwgex/2016_software_engineering_internship_amazon/daog1jj/", "id": "daogja3"}], [{"comment": "I had a straightforward process applying for a Summer 2016 internship with Amazon for the Seattle office. First a HackerRank-like coding challenge (no one observed me), and then a technical interview with an employee over a shared document.\n\nLet's hope Amazon doesn't start following [Epic's](http://www.epic.com/) footsteps.", "id": "daoopes"}, {"comment": "What does Epic do?", "id": "daov2c6"}, {"comment": "Here's a summary of someone's experience interviewing with Epic: https://news.ycombinator.com/item?id=13076386", "id": "dapexgy"}, {"comment": "Sounds pretty close to the Amazon interview, just live proctored instead of proctorio or whatever. Still pretty shit though, jesus.", "id": "daphv73"}], [{"comment": "I always hate questions like these.  They want the answer they want, when there may be several right answers.  Like the \"Four Options\" one.  POM is the only one with a vowel in the second position.  The answer they probably want is UVS because it's not read backward with the second letter dropped out.\n", "id": "daoqca3"}, {"comment": "Could you explain what you mean by \"it's not read backward with the second letter dropped out\"?", "id": "dap0bz7"}, {"comment": "Read in reverse alphabetical order, and missing a letter in between the sequence.\n\n- POM = M[N]OP\n- KJH = H[I]JK\n- TSQ = Q[R]ST\n- USV = should have been YXV to match the other 3 ( V[W]XY )\n\n", "id": "dap1yf7"}, {"comment": "Ah thanks", "id": "dap2gzl"}], [{"comment": "I interned at Amazon last summer and blogged my interview experience here (http://isaacjordan.me/blog/2016/03/amazon-development-centre-interview-experience/). There was nothing like this, although I was in the UK.", "id": "dap2w8n"}], [{"comment": "The Proctorio is pretty common for if you want to for example Microsoft examinations at home.\n\nIt just means your microphone and webcam will be pointed at you at the time of the exam. Honestly not a really big deal IMO.", "id": "daoi3d5"}], [{"comment": "Meh, you are better off without them", "id": "daojb7p"}], [{"comment": "How did you 'refuse to continue' at the disclaimer screen, while still answering all of the questions? That's impossible, isn't it? The disclaimer is the first page you hit, meaning you must have consented to it, and gone through all of the coding questions - no? You said you hit that in the second assessment, but I'm 99% sure you would have gone through that screen for the 7 programming questions from the first assessment.", "id": "dao90kh"}, {"comment": "They were separate exams.", "id": "daockpr"}, {"comment": "The first one requires the same disclaimer, word-for-word. I've done it myself.", "id": "daodop1"}, {"comment": "Nope, the first exam is done through AMCAT, the second is through Proctorio. I was able to do the first one with Firefox without installing any extensions too.", "id": "daoueqb"}]]], "5g4mgn": ["Using Alexa (Amazon Echo) to Preheat my Renault ZOE and check Battery Status", "2016-12-02 20:48:18", 0, "https://blog.dantup.com/2016/12/using-alexa-to-preheat-the-car-and-check-battery-status/", [], []], "5gae9m": ["Come back, RubyMonk!", "2016-12-03 19:49:32", 3, "https://fahrenhei7.github.io/2016/12/03/rubymonk-comeback.html", [], []], "5fxbjy": ["How Do Software Developers in New York, San Francisco, London and Bangalore Differ?", "2016-12-01 19:01:08", 55, "http://stackoverflow.blog/2016/11/How-Do-Developers-in-New-York-San-Francisco-London-and-Bangalore-Differ/", [[32, "In Bangalore, every line of code is recorded as YouTube video tutorials, which are then posted in /r/php"], [9, "In Bangalore, to curry a function has a completely different meaning."], [5, "this became /r/programmingcirclejerk real quick"], [4, "In Bangalore, they work a lot more hours. We are a European fab, and we see all the emails, east coast, west coast, Singapore, Japan, Korea. Asians never leave work."], [2, "Is PHP not listed because:\n\n1) It's not popularly used\n\nor\n\n2) It's got the best self-help docs: php.net, so you don't bother going to stackoverflow for questions.\n\nYes, I'm \"old\" & used PHP for the last 10 years, & used stack-overflow for C++, Objective-C, Android, iOS stuff, but never for PHP."], [0, "income."], [-9, "**closed as not constructive**"]], [[{"comment": "In Bangalore, every line of code is recorded as YouTube video tutorials, which are then posted in /r/php", "id": "daoad67"}], [{"comment": "In Bangalore, to curry a function has a completely different meaning.", "id": "daokm0l"}], [{"comment": "this became /r/programmingcirclejerk real quick", "id": "daot5cw"}, {"comment": "Probably related to the joke of a question itself, OP should do his own research and not rely on being spoonfed.", "id": "daq3m0o"}], [{"comment": "In Bangalore, they work a lot more hours. We are a European fab, and we see all the emails, east coast, west coast, Singapore, Japan, Korea. Asians never leave work.", "id": "dao7fi6"}, {"comment": "Idle time. Ass in chair is highly valued in Asian work cultures. ", "id": "daock9y"}, {"comment": "Asia is kinda big. I don't think work culture is the same in, say, India, China and Japan.", "id": "daoggli"}, {"comment": "Not everywhere", "id": "dao9ze2"}], [{"comment": "Is PHP not listed because:\n\n1) It's not popularly used\n\nor\n\n2) It's got the best self-help docs: php.net, so you don't bother going to stackoverflow for questions.\n\nYes, I'm \"old\" & used PHP for the last 10 years, & used stack-overflow for C++, Objective-C, Android, iOS stuff, but never for PHP.", "id": "daoouj2"}], [{"comment": "income.", "id": "daoi50c"}], [{"comment": "**closed as not constructive**", "id": "dao17k2"}, {"comment": "Your ~~mom~~ comment is not constructive!", "id": "daozsfz"}]]], "5g2l25": ["JSON API user registration won't send notification with activation code", "2016-12-02 13:22:25", 0, "http://stackoverflow.com/q/40929521/5324723", [[3, "Please don't send confidential information (passwords) over GET. URLs get stored in webserver logs."]], [[{"comment": "Please don't send confidential information (passwords) over GET. URLs get stored in webserver logs.", "id": "dap1rt3"}]]], "5gaw25": ["Installing web apps on phones (for real): the Progress of Progressive Web Apps", "2016-12-03 21:24:26", 19, "https://joreteg.com/blog/installing-web-apps-for-real", [[7, "The progress of PWAs: stalled with Safari."], [3, "I endorse any technology that allows programming an app in a multiplatform way, working for Android, iOS, WindowsPhone in one codebase (like Xamarin for C#, Toga for Python, ReactNative for Javascript...)\n\nI just wanted to have another option that is not Javascript, fortunately WebAssembly (wasm) will probably allow that in the future.  "], [3, "What is your guys' preferred way to write JavaScript / HTML apps on iPhone and Android?\n\nI've got experience making websites, but not much server stuff - but I have done some Windows Store apps with WinJS and I really enjoy it. What's the right way to go right now for me, for mobile apps with JS/HTML?"], [1, "I'll treat this like I treat pre-order games: not gonna buy into it before it's actually ready, because promises are cheap and present reality is king."]], [[{"comment": "The progress of PWAs: stalled with Safari.", "id": "dardd55"}], [{"comment": "I endorse any technology that allows programming an app in a multiplatform way, working for Android, iOS, WindowsPhone in one codebase (like Xamarin for C#, Toga for Python, ReactNative for Javascript...)\n\nI just wanted to have another option that is not Javascript, fortunately WebAssembly (wasm) will probably allow that in the future.  ", "id": "daqrojg"}, {"comment": "> Installing web apps\n\n> multiplatform way\n\n> WebAssembly\n\nWe've gone full circle (almost): almost reinvented a multiplatform language, almost reinvented asm. Now just need to fix this mess, and it'll be on par with what we had 20 years ago.", "id": "dar6whc"}, {"comment": "> almost reinvented asm\n\nWebassembly is not asm at all though, it's (hopefully) what the JVM should/could have been!", "id": "darpnd3"}, {"comment": "It's a tough sell when a lot of the devs who are building web apps are already JS programmers. ", "id": "daqt021"}, {"comment": "Typescript is fine. So are a bunch of other compile-to-JS options. Some people get hung up on the idea that it's compiled to JS instead of bytes, but really, who cares.", "id": "dardis6"}], [{"comment": "What is your guys' preferred way to write JavaScript / HTML apps on iPhone and Android?\n\nI've got experience making websites, but not much server stuff - but I have done some Windows Store apps with WinJS and I really enjoy it. What's the right way to go right now for me, for mobile apps with JS/HTML?", "id": "dar2dkv"}, {"comment": "react-native", "id": "darmprk"}], [{"comment": "I'll treat this like I treat pre-order games: not gonna buy into it before it's actually ready, because promises are cheap and present reality is king.", "id": "darklaw"}]]], "5fos29": ["How to calculate similarities?", "2016-11-30 12:43:02", 61, "http://indexoutofrange.com/How_I_calculate_similarities_in_cookit/", [[5, "This looks a lot like classic text similarity. You're more-or-less doing a specialized version of building unigrams with TF-IDF weighting. From there you'll find a number of neat ways to compute similarity. You could compute a cosine angle, a Jaccard index, a norm-based metric, etc..."], [1, "Good article, but make sure to proof read it. Found a few stupid mistakes."], [0, "Linked site does not work *AT ALL* on my mobile phone."]], [[{"comment": "This looks a lot like classic text similarity. You're more-or-less doing a specialized version of building unigrams with TF-IDF weighting. From there you'll find a number of neat ways to compute similarity. You could compute a cosine angle, a Jaccard index, a norm-based metric, etc...", "id": "dam5hbs"}, {"comment": "> like classic text similarity. You're more-or-less doing a specialized version of building unigrams with TF-IDF weighting. From there you'll find a number of neat ways to compute similarity. You could compute a cosine angle, a Jaccard index, a norm-based metric, etc...\n\nYou are right to some extend. The parsing part rejects some ingredients that are doubles or different names.\nThe another thing is that I have weight assign to each ingredient. This could not be done with simple text comparison. But yes it's quite simple but gives quite good results. My point was more on the  point how to model similarity on real life objects.", "id": "dama0cp"}, {"comment": "It's a neat article, well-written and self-contained! \n\n(If you're the original author:) I think highlighting the similarity to standard metrics could give novices another jumping-off point to the deeper world of ML similarity and ranking, and hint to more experienced folks that you're aware that stuff exists and feel there's a novel contribution here worth talking about (e.g. look! you can take this kind of generic algorithm and graft it to a specific application and get even better results!) instead of dismissing the article as \"another developer discovers text mining independently and blogs about it.\"", "id": "dame6jk"}, {"comment": "Thanks :)\n\nI am.\nThe article was meant as a start for another one about optimizing calculations on matrixes. I've just sliced it into two parts because it was too long. I wasn't expecting such a great reception of it. As for text mining I've bean doing it for some time now, but I must admit calculating similarities was most often using some well know algorithm.", "id": "danrmrj"}], [{"comment": "Good article, but make sure to proof read it. Found a few stupid mistakes.", "id": "dam7iwv"}, {"comment": "Yeah. I know. I'm looking for someone to proofread everything I write (not a native English speaker). Thanks", "id": "damb4dz"}], [{"comment": "Linked site does not work *AT ALL* on my mobile phone.", "id": "dalzlaa"}, {"comment": "Could You provide me with a screenshot and some info what phone are You using?", "id": "dam0vrh"}, {"comment": "[This](http://imgur.com/a/lR0tg) is all I can see. I've tried zooming in and out but this is all I ever see.\n\nI am using an iPhone 5 with Safari.\n\nEdit: I investigated a bit more now. I can scroll down and the bar on the left changes color, then I reach the footer. This is where I stopped scrolling but actually the content is beneath that. So actually the site is not unusable, it is just difficult to reach the content. I think most people would stop scrolling at the footer or not scroll at all.", "id": "dam9842"}]]], "5ftnc1": ["Fully visualized ARM1 simulation", "2016-12-01 04:22:02", 56, "http://visual6502.org/sim/varm/armgl.html", [[7, "Just found this while researching 6502 opcodes and had to share. It blows my mind that people do this. Here's the full site: http://visual6502.org/ "]], [[{"comment": "Just found this while researching 6502 opcodes and had to share. It blows my mind that people do this. Here's the full site: http://visual6502.org/ ", "id": "damy5c4"}]]], "5ge476": ["Jukedeck and two neural networks: one generates a song, and the other converts it to audio, e.g. Piano", "2016-12-04 09:01:48", 18, "https://research.jukedeck.com/audio-synthesis-at-jukedeck-788239d65494#.6kbqv6zbd", [], []], "5fuqbt": ["15 Years of Concurrency", "2016-12-01 07:56:47", 92, "http://joeduffyblog.com/2016/11/30/15-years-of-concurrency/", [[17, "> We don\u2019t run PCs with 1,024 traditional cores, although our GPUs have blown way past that number, \n\nNo they haven't. A GPU processing element (streaming processor or CUDA \u2018core\u2019) is much closer to a CPU SIMD lane than it is to a full blown core. The GPU equivalent of a CPU core is the multiprocessor (so in the order of the tens), or at best the streaming processor cluster (which is something like 4 per multiprocessor in most current GPUs), so at best a GPU has maybe a few hundred cores, even if the cores are much wider than the CPU ones (32 or 64 lanes versus at most 16 lanes) "], [6, "I like the ending\n\n\"Out of the bunch, Rust has impressed me the most. They have delivered on much of what we set out to deliver with Midori, but actually shipped it (whereas we did not).\""], [3, "I personally think Rust may be about as much as someone might want from the language angle.  I think when trying to do too much in language design the concurrency solutions are much too granular. If dealing with concurrency at the expression level you can easily end up with very little done relative to the amount of synchronization needed."], [1, "Amazing article, I have a question though:\n\n\"and that the reference could not convert to the so-called \u201ctop\u201d permission, readonly.\" in no leaky constructors. Shouldn't the top permission be \"mutable\". I mean, I can't see how forbidding `this` becoming `readonly` would help anything.\n\nOn the other hand, forbidding it to became `mutable` also doesn't make much sense (how would you initialize the object, then) unless `this` in init was `isolated`. Then, it would make perfect sense :)."], [-5, "15 Years and we're still fighting over the details."]], [[{"comment": "> We don\u2019t run PCs with 1,024 traditional cores, although our GPUs have blown way past that number, \n\nNo they haven't. A GPU processing element (streaming processor or CUDA \u2018core\u2019) is much closer to a CPU SIMD lane than it is to a full blown core. The GPU equivalent of a CPU core is the multiprocessor (so in the order of the tens), or at best the streaming processor cluster (which is something like 4 per multiprocessor in most current GPUs), so at best a GPU has maybe a few hundred cores, even if the cores are much wider than the CPU ones (32 or 64 lanes versus at most 16 lanes) ", "id": "dand76y"}], [{"comment": "I like the ending\n\n\"Out of the bunch, Rust has impressed me the most. They have delivered on much of what we set out to deliver with Midori, but actually shipped it (whereas we did not).\"", "id": "dao2s2l"}], [{"comment": "I personally think Rust may be about as much as someone might want from the language angle.  I think when trying to do too much in language design the concurrency solutions are much too granular. If dealing with concurrency at the expression level you can easily end up with very little done relative to the amount of synchronization needed.", "id": "dao77xs"}, {"comment": "I wrote a long comment on the HN thread for this article about Rust's situation here. TL;DR: rust doesn't really build in concurrency so much as it builds in aliasing detection, turns out that that also solves concurrency https://news.ycombinator.com/item?id=13079360", "id": "daoakbf"}], [{"comment": "Amazing article, I have a question though:\n\n\"and that the reference could not convert to the so-called \u201ctop\u201d permission, readonly.\" in no leaky constructors. Shouldn't the top permission be \"mutable\". I mean, I can't see how forbidding `this` becoming `readonly` would help anything.\n\nOn the other hand, forbidding it to became `mutable` also doesn't make much sense (how would you initialize the object, then) unless `this` in init was `isolated`. Then, it would make perfect sense :).", "id": "dape860"}], [{"comment": "15 Years and we're still fighting over the details.", "id": "danhlni"}, {"comment": "I don't think we are. The solutions are well established, and we see the emergence of more and more languages that bake them deep into their paradigm.", "id": "daoanjy"}, {"comment": "Are you referring to traditional locks, Software Transaction Memory, message passing, etc.?", "id": "dapswmm"}, {"comment": "Basically. \"Message passing\" itself is probably the oldest technique there is, and is the basis of all the actor/channel implementations we seen in modern distributed architectures and languages. \n\nThe ideas are very old, they even predate computing itself, but many of them have been waved away or disregarded, because there were simpler more convenient models for programming personal computing in the 80 and 90s. Now that we're back to massive concurrency, both at the computer level, and between computers... the old ideas are back.", "id": "daptemc"}]]], "5fy4e2": ["Untangling Macros in C", "2016-12-01 21:13:47", 3, "https://www.linux.com/blog/Holberton/untangling-macros-c", [], []], "5g0y7u": ["Announcing OSS-Fuzz: Continuous Fuzzing for Open Source Software", "2016-12-02 06:05:24", 16, "https://security.googleblog.com/2016/12/announcing-oss-fuzz-continuous-fuzzing.html", [], []], "5fshft": ["Functional Programming &amp; Haskell - Computerphile", "2016-12-01 00:56:41", 11, "https://www.youtube.com/watch?v=LnX3B9oaKzw", [[1, "I struggled to find anything in the description that he gave of functional programming languages that didn't describe languages like Python. "]], [[{"comment": "I struggled to find anything in the description that he gave of functional programming languages that didn't describe languages like Python. ", "id": "dan6evk"}, {"comment": "FP isn't magic, you can apply the principal to almost any language, just the same way that you can apply the principals of OO programming in just about any language, even if it's not a language made for OO programming. What languages like Haskell and Scala do is that they provide built in language structures (and often restrictions) and collections that make FP easier to reason about and implement. For example, Scala provides a pattern matching structure that looks like [this](http://fruzenshtein.com/wp-content/uploads/2016/07/pattern-matching-syntax.png), it's essentially a very flexible switch, but without it FP would be a much less simple proposition in Scala. Likewise, features like currying enable you to create very modular functions that you can partially apply and reuse instead of writing lots of samey code.", "id": "dan7t7b"}, {"comment": "Computerphile videos are typically a general introduction to topics in computer science for non programmers. So this video seems to do that just fine.\n\nTo answer your question, take this Java code for example. My python is not too good...\n\n```\nint max(int a, int b) {...}\n```\n\nThe logical thing for it to do is return either a or b. You never know for sure until you read the code though. It could be logging the values somewhere. It could be calling a random number generator somewhere.\n\nOn the other hand, Haskell in specific doesn't allow such side effects to go unnoticed. Like Java requires method to declare exceptions, Haskell requires the signature of methods to declare side effects. Even when you let the compiler infer types.\n\nThe most wide side effect would be IO. There are other kinds of side effects too.\n\n```\nmax :: Int -> Int -> Int\n\n\nmaxThatLogs :: Int -> Int -> IO Int\n```\n\nI spent a few weeks learning Haskell and don't use it professionally.", "id": "danb9up"}, {"comment": "So it forces the programmer to use best practices that they should be using regardless of language. Fair enough. ", "id": "danctlu"}, {"comment": "Yeah, \"dirty\" code is kind of \"confined\". At the beginning is just a pain in the ass, especially when you just want to log a value for debugging purposes, but the long term benefit is massive: you really can trust the signatures of your functions.", "id": "dang29l"}, {"comment": "You can use `trace` for printing values during debugging. Like so:\n\n`add a b = trace \"Hello, World\" $ a + b`\n\nThe important part here is the `$` as that allows the chaining of the right-hand expression. \nNow when you run this in a terminal, \"Hello, World\" will be printed and the result `a + b` will be returned. ", "id": "danj0so"}, {"comment": "> you just want to log a value for debugging purposes\n\nShouldn't a good debugger and REPL make this unnecessary?", "id": "danhp9e"}, {"comment": "In general you are right, but sometimes is more useful just to dump a bunch of values and see what is going on.", "id": "dani23w"}, {"comment": "The example I like to use is this\n\n    void addToList(List l, Object o)\n\nThat's not functional because it modifies the list. It returns nothing so everything it does is a side effect.\n\n    List addToList(List l, Object o) {\n      List newList = new ArrayList(l);\n      newList.insert(o);\n      return newList;\n    }\n\nThat is functional because it doesn't modify l.", "id": "dap1aot"}, {"comment": "While it is functional, it's also (probably) inefficient since it's copying the whole list; a functional `ArrayList` would define its `insert` method as:\n\n    List<T> insert(T o) {\n        return new Link<T>(o, this);\n    }\n\nSince nothing is mutable, sharing state is trivial.", "id": "dar0f4v"}]]], "5fipg8": ["Towards Idris Version 1.0", "2016-11-29 16:45:29", 115, "http://www.idris-lang.org/towards-version-1-0/", [[29, "i love Idris, its the best way to move Haskell forward...break compatibility but keep the inspiration"], [12, "Can't wait! I've been meaning to give \"Type-Driven Development in Idris\" a whirl.\n\nIt's only a matter of time before true dependent types are industry capable tools :) what Haskell already has is pretty good...but compared to Idris it's so crude!"], [6, "Idris' interactive proving of type is better than GHC's black magic of type inference. Idris makes me clear what I actually need to do with minimal messages while GHC's type inference sometimes go crazy and take me hours to overcome."], [3, "er... what is Idris?\n\nThe link doesn't help in explaining what it is."], [-27, "[deleted]"]], [[{"comment": "i love Idris, its the best way to move Haskell forward...break compatibility but keep the inspiration", "id": "dakou8m"}, {"comment": "Yeah I spent a while last year trying to use Haskell's dependent-ish types, and found it pretty frustrating. Going right to dependent types was far less painful. The dependant types make parsers *really* nice to write.", "id": "dakr61o"}, {"comment": "It's amazing the things you can prove with singletons and type families in Haskell. This makes Idris all the more impressive to me: It's like jumping from type-level asm to type-level, well, Idris ;)", "id": "dakzaa3"}, {"comment": "I'd love to learn more about using dependent types for parsers. Any examples or resources?", "id": "dalh49z"}, {"comment": "It's just in the Idris book, I believe.", "id": "dalhfo8"}], [{"comment": "Can't wait! I've been meaning to give \"Type-Driven Development in Idris\" a whirl.\n\nIt's only a matter of time before true dependent types are industry capable tools :) what Haskell already has is pretty good...but compared to Idris it's so crude!", "id": "dakowkl"}], [{"comment": "Idris' interactive proving of type is better than GHC's black magic of type inference. Idris makes me clear what I actually need to do with minimal messages while GHC's type inference sometimes go crazy and take me hours to overcome.", "id": "dalyx0j"}], [{"comment": "er... what is Idris?\n\nThe link doesn't help in explaining what it is.", "id": "dalis7n"}, {"comment": "A dependently-typed functional programming language. Going to the homepage of the link will give you a general overview of the language.", "id": "dalkmx3"}], [{"comment": "[deleted]", "id": "dakkad4"}, {"comment": "This is a pretty small variation from common functional programming notation.  In fact, if you turn the single colons into double colons, I think this might be valid Haskell GADT syntax, which is not that alien.\n\nI don't think C's syntax can be easily extended to describe algebratic data types in a natural way.", "id": "dakkp5i"}, {"comment": "Also, if you know the lambda calculus it's pretty easy to see how code will be evaluated.", "id": "dakkyj6"}, {"comment": "Do Rust/Swift enums not do it for you? Granted, using the \"enum\" keyword is weird, but otherwise they work for me.", "id": "dakyj8s"}, {"comment": "Can you create GADTs in Rust and Swift?\n\nI know that this:\n\n    type 'a option =\n      | Some of 'a\n      | None\n\nwould become this in Rust:\n\n    enum Option<T> {\n        Some(T),\n        None,\n    }\n\nBut how would you express this?:\n\n    type 'a number =\n      | Int   : int -> int number\n      | Float : float -> float number ", "id": "dakyw5k"}, {"comment": "I use Rust for most of my personal projects, and I would be the first to admit that the syntax is ugly (so much `}}}}` and `<<>>`). It would be especially bad for curried, pure functional programming with interesting dependent type signatures.", "id": "dal5x9z"}, {"comment": "[deleted]", "id": "dakl4qe"}, {"comment": "> The worst kind of operators are -> or ::\n\nAnd to me the worst kind of operators are & or *. We've really elevated the debate here...", "id": "dakljcj"}, {"comment": "[deleted]", "id": "daklmpu"}, {"comment": "Fine, then to me the worst kind of operators are `:=` and `;`. Now what?", "id": "daklqg8"}, {"comment": "[deleted]", "id": "daklugf"}, {"comment": "Your assumption that keywords are more readable than operators 100% of the time is just plain wrong. `->` is a perfect example here: it very clearly indicates the input and output of a function. I can't possibly imagine a purely keyword-based syntax that would be more readable.", "id": "dakm7kc"}, {"comment": "I think part of the problem is that C insists on using the \"by-use\" syntax for describing types, which leads to confusing \"inside-out\" type signatures like `int *(*[3])(double)(long)` when it could be more clearly written as `Array 3 (Ptr (Double -> Long -> Ptr Int))`.", "id": "daklgzf"}, {"comment": "Prefix this by saying I'm a proponent of FP\n\nUsing the arrow for functions is much clearer IMO than using something like C-family syntax for function composition, plus it allows the right-association of functions to be more apparent in declarations.\n\nUsing C#/D-like function/delegate syntax (because C's function pointers are ugly on top of verbose), a function like `foldr` would need to be rewritten as \n\n    <F<_> extends Foldable, A,B> B foldr((B function(B)) function (A) f, B init, F<A> foldable);\n\ninstead of\n\n     foldr : Foldable f => (a -> b -> b) -> b -> f a -> b\n\nCurrying in general makes annotating types as (return type) op (arg type) end up ugly, as everything must stack on the left hand side, and even with left-associative operators for expressing function types we end up with the type being read from right to left with respect to function order (e.g. `f : a -> b -> c -> d` is called with `f a b c d`, but `f : d function c function b function a` would need to be called as `f a b c d` too, unnecessarily flipping the argument order).\n\nUsing : for type and :: for cons (or vice versa) makes sense from the point of view of running out of separators: spaces (like Lisp) are application in lambda calculus, commas are taken by tuples, and there isn't much else that would intuitively convey 'followed by' better than '::' (if ':' is taken as 'has the type') (; is used for escaping whitespace sensitivity in many functional languages, as they also support C-family curly braces and semicolons). ':' for 'has type' also makes sense as again application must be avoided, which prevents things like 'int x' (which is syntactically hard to discern from type applications like 'List x'). Having types on the right hand side also makes sense considering that types are usually longer than variable names.\n\nHowever, they do have the downside of being ungooglable. I wish google wouldn't interpret them as whitespace, as it makes finding the meanings of certain code impossible (Haskell has Hoogle to alleviate this, although all I know about for Scala is to use 'operator names', like 'the spaceship operator' [which to know, I would already also know what it did]).", "id": "dakn12f"}, {"comment": "Missing some backticks there (around the type of `foldr`).", "id": "dal3mr1"}, {"comment": "Fixed, ta", "id": "dal55pg"}, {"comment": "You only find C syntax more readable because you're used to it. You learned it. I learned it too, but I also learned this, and I find both equally readable.", "id": "dakl562"}, {"comment": "Counterpoint: I have learned both and find C-style syntax eminently more readable. The combination of heavy use of operators (some custom), pointfree style, and generally high syntactic flexibility (e.g. `$`) make Haskell-like programs much harder for me to read.", "id": "dal6e39"}, {"comment": "It's true that some people abuse operators to the point of being hard to read. But to me that's not an inherent issue of the syntax, but those people's approach. It's easy to make C hard to read too.", "id": "dal7u5t"}, {"comment": "> But to me that's not an inherent issue of the syntax, but those people's approach.\n\nI think it's inherent in the language.  First, the language's syntax and semantics allow for easy operator creation - they're just functions with special names, after all.  Second, the (sensible!) inability to overload existing operators to mean new things means that places one might have reached for overloading elsewhere instead gives you new operators in Haskell.\n\nThis shows up in libraries that are widely used and generally considered good quality, such as the streaming and lens libraries.\n\n> It's easy to make C hard to read too.\n\nI'll take Haskell with its operator soup over C with its systemic shared mutable data, and C++ with its overload fetish, yes.", "id": "dal990u"}, {"comment": "Considering the core classes like Monad are defined in terms of symbolic type constructors, it's unfair to blame developers. In general, high flexibility in the syntax leads to more variability among programs, which reduces readability. ", "id": "dal8vbs"}, {"comment": "It's an extension of the lambda calculus, which been around significantly longer than C syntax. It's also covered in most CS programs that I'm aware of.", "id": "dakl1cv"}, {"comment": "[deleted]", "id": "daklpgb"}, {"comment": "What *exactly* do you think constitutes a syntax or programming language?", "id": "dakm3hb"}, {"comment": "Lambda calculus is Turing complete. It could be a programming language, but raw lambda calculus is hard to work with. So functional language designers add in data types and primitives to work with!", "id": "dakmks0"}, {"comment": "It's just GADT notation.\n\nThe C comparison doesn't make sense since C can't even get close to expressing most things you'd express in GADT notation...", "id": "dakos6v"}, {"comment": "The person you replied to is talking about C-*like* languages, not C specifically.\n\nIn which case, here's how you'd express GADTs in a (fairly) C-like language, Scala!\n\n    sealed trait Foo[A]\n    case class Bar(x: Int) extends Foo[Int]\n    case class Baz(x: String) extends Foo[String]\n    case object Qux extends Foo[Nothing]\n\nWow! How readable! I'm completely enthralled by its simplicity and ease of understanding.\n\nNow the equivalent in yucky Idris:\n\n    data Foo : Type -> Type where\n        Bar : Int -> Foo Int\n        Baz : String -> Foo String\n        Qux : Foo _|_\n\nMan, that's gross. I sure am glad Scala had all of those informative keywords telling me what was going on. This Idris looks like *shit* in comparison.\n\n^^^/s, ^^^obviously", "id": "dakug55"}, {"comment": "Hah! You got me!\n\nFor some reason I didn't even consider using Scala as an example of C-like GADTs..even though I just spent 2 years writing it professionally! For some reason it doesn't fall in \"C-like\" in my head. Maybe I just got too used to the syntax '-'", "id": "dakz73d"}, {"comment": "Yeah, that's why I said *fairly* C-like. If you're new to the language and you use it like an improved Java, it seems more C-like. If you're experienced in the language, it seems more ML-like, because you use features like higher kinded types, algebraic data types and implicits more often. ", "id": "dakzmwo"}, {"comment": "What is `_|_`? More importantly, how would I look it up if I didn't know what it was? Searching \"Scala sealed trait\" or \"Scala case object\" works perfectly.  \n\nPlus, in your example, the names of the fields in the ADTs lack useful names whereas in real-world code they aid in understanding. Maybe it's just me, but \n\n    case class User(id: String, name: String, hashword: String) \n      extends Record[String]\n    \nis a lot more readable than\n\n    User : String -> String -> String -> Record String\n", "id": "dal540n"}, {"comment": "/u/dacjames I can understand your frustration in not being intuitively comfortable with languages that you are not familiar with. Especially, if you are moving from one language family to another. Things will be different, but with a little patience you can hopefully see beyond the differences and appreciate the pros and cons of both language families.\n\nOne of the things we do in Idris is to provide a means to interact with the language in much the same way you can through an IDE. However, we have internalised such functionlality within the compiler to provide an `ide-engine`. This engine allows use to provide plugins to many IDEs and editors automatically, if the editor can learn how to communicate with the engine.. A lot of the functionality is also available at the REPL. For example, learning about items in the language such as:\n\n+ `:doc` to show documentation \n+ `:search` for type based search\n+ `:type` to show the type of something\n+ `:browse` to browse a module's namespace.\n+ `:apropos` for a catch all search\n\nAt lot of these actions you can do with IDEs for over C-style languages, we just take a different approach.\n\nSadly we don't have the traction yet such that 'searching' for Idris related material might not give as good a set fo results as with Scala. Give us time. \n\nIn the meantime drop by #idris on freenode, or ask questions in /r/idris, or on our mailing list. We are happy to take questions, and help iron out any differences or confusion. More so, the more we practise explaining the better we can improve explaining things..", "id": "dalumls"}, {"comment": "> What is _|_? More importantly, how would I look it up if I didn't know what it was?\n\nSimple: you shouldn't look it up before you learn some basics of Idris (read idris-tutorial, it's quite short since the language is rather small). And if you read the tutorial you already know what is `_|_`. Moreover, if you know some type theory you already know what is `_|_`. And if you don't know any type theory you should learn it first before getting into Idris.", "id": "dalj3yr"}, {"comment": "`_|_` has been renamed to `Void` in October 2014, so that code fragment is no longer valid idris.\n\n\n", "id": "daltqcn"}, {"comment": "You don't really need to to learn 'type-theory' prior to using Idris. As you suggested [reading the tutorial](http://idris.readthedocs.io/en/latest/tutorial/index.html) is always a good start.", "id": "dalufln"}, {"comment": "You probably don't *need* but you *should*. Just highly recommended, since it's not yet another Algol-68, there are some important concepts from type theory that need to be understood in order to understand Idris fully.", "id": "dan86gx"}, {"comment": "> And if you don't know any type theory you should learn it first before getting into Idris.\n\nEh, no.  How about just learning Idris first...\n\nFun fact: Rust supports types like `_|_`, for example the `Void` type from the [`rust-void` crate](https://github.com/reem/rust-void), defined like this:\n\n    /// The empty type for cases which can't occur.\n    #[derive(Copy)]\n    pub enum Void { }\n\n    /// A safe version of `intrinsincs::unreachable`.\n    ///\n    /// If this typechecks, anything that causes this to run is unreachable code.\n    pub fn unreachable(x: Void) -> ! {\n        match x {}\n    }\n\nAnd those comments are a reasonably intuitive explanation for one of the uses of bottom types.", "id": "daltmrd"}, {"comment": "You're essentially saying one should never need external references and only use Idris once you have fully internalized all of its features (and all of the supporting theory). That is basically the definition of unreadable and it's completely impractical in the professional world.", "id": "dalp79i"}, {"comment": "\u041b\u044e\u0431\u043e\u0439 \u043d\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043d\u044b\u0439 \u0442\u0435\u0431\u0435 \u044f\u0437\u044b\u043a \u043d\u0435\u0447\u0438\u0442\u0430\u0435\u043c.\n\nAny language you don't know is unreadable. That's how languages work. You learn them, then you use them, not the other way around. Maybe using without learning you call professional, but I don't.", "id": "dalrouy"}, {"comment": "[deleted]", "id": "dalsoag"}, {"comment": "Sure, Java belongs to a large family of languages that are all quite similar to each other, that makes them \"readable\" if you know some of them. That's just basic familiarity. It's like Spanish, French and English, they share alphabet and a lot of words and this makes them \"readable\". You see French \"la table\" and you can guess it's a table. But does it mean Chinese or Thai languages are unreadable? Do they need to be changed and be more like English? Does math need to be changed to look more like Java because Java doesn't have all those fancy symbols? You don't complain about \u2205, you just learn what it means in math. Well, in type theory and category theory there are some symbols too like \u22a5, and you just learn and use them, these are just parts of math. Idris then just happens to reuse some of those symbols and concepts. Yes, it's not Java, it belongs to another family of languages, just like Chinese belongs to a different family than French. For programmers familiar with ML or Haskell, Idris should be quite readable.", "id": "daltf8y"}, {"comment": "> You're essentially saying one should never need external references and only use Idris once you have fully internalized all of its features (and all of the supporting theory).\n\nHow on earth do you get that from:\n\n\"(read idris-tutorial, it's quite short since the language is rather small). And if you read the tutorial you already know what is \\_|\\_.\"\n\n> That is basically the definition of unreadable and it's completely impractical in the professional world.\n\nWhat's impractical in the professional world is not having _any_ basis in the theory underlying the tool you call \"practical\" today that will be obsolete in two years. In particular, type theory is type theory, regardless of language you use. Want to thoroughly understand why making `null` the subtype of all types is a [Billion Dollar Mistake](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare)? You'll need to understand what `_|_` (\"Bottom\") is. Thankfully, there's a _lot_ of good material explaining it out there.", "id": "dalpvir"}, {"comment": "The fact that `_|_` is ascii-art of the bottom type symbol is not at all obvious, especially considering the completely unrelated use of `|` on the same line. It could just as easily mean \"unnamed variable or unnamed variable.\"\n\n> And if you read the tutorial you already know what is `_|_`\n\nOnly true if you have fully internalized everything you learned from that tutorial, which, practically speaking, you will not. Maybe the bottom type is so commonly used in Idris that this is a silly example, but it is just an example of how using symbols (and single letters like `Z`, for that matter) over words hurts readability.\n\nIf there was any concern for readability, `_|_` would be spelled `Bottom` (or `BottomType`), `Z` spelled `Zero`, and so on. The difference does not sink in until you're spending more time reading old, often third-party code than writing new code. In that context, the flexibility, density, and heavy symbol use of Haskell-like syntax becomes a liability.", "id": "dals5t3"}, {"comment": "It's been called \"Void\" since 2014. You can get documentation at the REPL by typing \":doc Void\".", "id": "dalu7c7"}, {"comment": "Yeah, `_|_` is the only thing there I'll admit is a wart. It should really be called `Empty` or something, because it's the empty type (nothing exists with the type `_|_`). Scala's name for it (`Nothing`) isn't very descriptive either, though. Makes it sound like it's related to `null`.\n\n>    User : String -> String -> String -> Record String\n\nThis is something you'd use records for in a language like Idris. Not sure how you'd do it in Idris - I don't have a very in-depth knowledge of it - but here's an example in OCaml, which works similarly:\n\n    type 'a foo =\n      | Bar : { x : int; y : int } -> int foo\n      | Baz : { name : string; age : int } -> string foo   ", "id": "dal8w20"}, {"comment": "They removed `_|_` as a built in declaration and renamed it to `Void` in October.", "id": "daltros"}, {"comment": "October 2014, in fact :)", "id": "dalu7jj"}, {"comment": "What about:\n\n    data Record : Type -> Type where\n       User : (id : String) ->\n              (name : String) ->\n\t          (hashword : String) ->\n\t          Record String\n\n\nYou're free to give names to parameters in idris (after all, if you couldn't, how could you use them in type that depends on them?).\n", "id": "dalvy4f"}, {"comment": ":-) Here Scala looks to Idris like how Ada looks to C.", "id": "dakz6rh"}, {"comment": "You're making it sound like it's a reaction to C syntax. That's like saying that Finnish is just a reactionary revolt against English.", "id": "dakz290"}, {"comment": "If one has a clean slate to design a new programming language without any prejudice. This is the best syntax I can think of. Minimal, clear, extensible.", "id": "dakns0i"}, {"comment": "    -- `::` is an infix operator that associates to the right, and has\n    -- precedence level of 5 (higher is tighter).\n    infixr 5 ::\n\n    -- `Vect` is declared as a data type with two parameters:\n    --\n    -- 1. A `Nat`ural number (the size of the vector);\n    -- 2. A `Type` (the element type).\n    data Vect : Nat -> Type -> Type where\n        -- The `Vect` type has two data constructors:\n\n        -- 1. A nullary constructor called `Nil`, which constructs an\n        --    empty vector (length `Z`ero) of any element type `a`.\n        Nil  : Vect Z a\n\n        -- 2. A binary constructor `::` which takes an element of\n        --    type `a`, a vector of length `k` and element type `a`,\n        --    and yields a vector of length `S k` (successor of `k`,\n        --    i.e. the next highest natural number) and element type\n        --    `a`.\n        (::) : a -> Vect k a -> Vect (S k) a\n\nSo it's a data type declaration for a singly linked list, but whose type parameters include not only the generic element type, but also the length of the list.", "id": "daltrim"}, {"comment": "> Yet no replies saying that they actually find the syntax to be more readable.\n\nWhat? Most of the comments are doing this exactly.\n\nIn fact, the C syntax for the *function type* is anything but \"readable\". Or, for any data type. Types are by far the most retarded part of the C syntax.", "id": "dalulfr"}, {"comment": "Yes it's far more readable, but difficult question to ask! I've been using syntax like this for well over a decade, my eyes expect it. That's why people are complaining about new syntax to known syntax. \n\nOnce you understand what these things are, then this makes perfect sense to you and only takes a quick glance to understand what the codes doing.\n\nAlso this is Idris, which has a type system most languages do not have and types can be predicated on values, so you need to expect to have some confusion of whats going on when looking at the code initially. \n\nAnother thing is, \"new operators\", these are just functions; in fact just ignore the symbols all together and just look at the types, nothing else really matters.\n\nI suppose that is why people feel frustrated by your question, it's like comparing space rocks to universes.\n", "id": "dam2mqy"}]]], "5fs2ut": ["The Emacs dumper dispute", "2016-11-30 23:49:00", 119, "https://lwn.net/SubscriberLink/707615/286fbe1405669d74/", [[23, "Emacs' unexec is one of the last of the glorious, yet utterly terrible, hacks that have hung around since the pre-desktop era and are still in production use.\n\nI'm both appalled by and oddly fond of it."], [7, "What they really need is an emacs daemon that runs when the system starts up. and can cache the elisp VM globally."], [2, "> > All those problems will be absent for the portable dumper, which\n> > will make its maintenance much easier.\n\n> Easier: yes.  Easy enough: no, not IMO.\n\nAs far as I can tell this emacs dev believes that this patch makes emacs better, but not perfect, and so doesn't want to do it. I'm confused. Why isn't \"Easier: yes.\" the end of the conversation"], [-8, "This is why I use vi clones.\n\nActually, it's totally unrelated. I took some classes with Professor Eggert, and I value his opinions."]], [[{"comment": "Emacs' unexec is one of the last of the glorious, yet utterly terrible, hacks that have hung around since the pre-desktop era and are still in production use.\n\nI'm both appalled by and oddly fond of it.", "id": "danet4h"}], [{"comment": "What they really need is an emacs daemon that runs when the system starts up. and can cache the elisp VM globally.", "id": "danmjdz"}, {"comment": "You can already run emacs in daemon mode.", "id": "danngfm"}, {"comment": "I was being facetious, but I should not be surprised. ", "id": "dannpn0"}, {"comment": "It is actually pretty great feature all things considered. Opens files faster than vim once it starts running and you can have multiple windows, both text and graphical, using same daemon.", "id": "danv6cu"}, {"comment": "Oh...Well, English isn't my first language. Sometimes I can't tell if people are being serious or not.", "id": "danopc4"}, {"comment": "We just need to port it to JVM/Clojure and wait till [caching compiled code](http://hg.openjdk.java.net/jep/jeps/rev/a16daa94ba0f) will get implemented", "id": "danv0z5"}], [{"comment": "> > All those problems will be absent for the portable dumper, which\n> > will make its maintenance much easier.\n\n> Easier: yes.  Easy enough: no, not IMO.\n\nAs far as I can tell this emacs dev believes that this patch makes emacs better, but not perfect, and so doesn't want to do it. I'm confused. Why isn't \"Easier: yes.\" the end of the conversation", "id": "dapjydt"}, {"comment": "Because \"good enough\" is the enemy of \"much better\"", "id": "daqjoqp"}, {"comment": "Er. The saying you're referring to is \"the perfect is the enemy of the good\", and it refers to exactly the situation I'm talking about -- refusing to improve something because the improved version isn't perfect, even though everyone agrees it's better. It's particularly crazy when the improved version *already exists* and you're just talking about switching to it", "id": "daqr3qi"}, {"comment": "I know, and fwiw I tend to think the patch should be merged, but that doesn't mean that I cannot understand the argument of the maintainer. ", "id": "daqrt28"}], [{"comment": "This is why I use vi clones.\n\nActually, it's totally unrelated. I took some classes with Professor Eggert, and I value his opinions.", "id": "dangkud"}, {"comment": "I am not sure what he worries about. Right note Emacs disables ASLR completely as far as I understand, I am not sure how enabling it for assembly code but not Elisp bytecode is problematic.", "id": "dangts6"}]]], "5fqla6": ["Announcing Project E3DB: The End-to-End Encrypted Database", "2016-11-30 19:41:22", 5, "https://tozny.com/blog/announcing-project-e3db-the-end-to-end-encrypted-database/", [], []], "5fnxfs": ["Problems on Algorithms [Ian Parberry] - good collection of exercises and problems.", "2016-11-30 08:35:30", 4, "https://larc.unt.edu/ian/books/free/poa.pdf", [[3, "To get more books that have been made free by the author, you can visit the hompage - https://larc.unt.edu/ian/books/free/"]], [[{"comment": "To get more books that have been made free by the author, you can visit the hompage - https://larc.unt.edu/ian/books/free/", "id": "dalotos"}]]], "5ft4oh": ["Two ways to keep auth keys and other sensitive data from git history", "2016-12-01 02:48:21", 1, "https://medium.com/policygenius-engineering/two-ways-to-keep-secret-keys-out-of-your-git-history-6b95193cb07b#.ixo9cidtb", [[4, "Can't you just you know not commit any environment dependent stuff to your repository using the git ignore file?"]], [[{"comment": "Can't you just you know not commit any environment dependent stuff to your repository using the git ignore file?", "id": "dane1gv"}, {"comment": "I like to commit default values for private keys, because my code relies on some of them in dev mode. Plus, its nice to have documentation of what keys exist.", "id": "dannye4"}]]], "5g5jh5": ["How to make a program that will run a coordinate system", "2016-12-02 23:25:38", 0, "http://www.dreamincode.net/forums/topic/399576-how-can-i-make-a-program-that-will-run-a-coordinate-system/", [[1, "If you want the easy way, look in to libraries like python's scipy and pyplot. If you want to make something from scratch then there are a lotttt of considerations. Just to draw a dot to the screen is pretty daunting if you're looking at using native drawing libraries. Libraries like SDL, SFML etc, make graphics programming a little easier, but you're still going to have to learn a lot to start there. I'd suggest going with an out of the box solution. Python is not my favorite language, but scipy has tons of stuff along these lines."], [1, "I never really got why Dream In Code calls people _D.I.C. Heads_.\n\nSounds like you want to project from screen space to another coordinate space."]], [[{"comment": "If you want the easy way, look in to libraries like python's scipy and pyplot. If you want to make something from scratch then there are a lotttt of considerations. Just to draw a dot to the screen is pretty daunting if you're looking at using native drawing libraries. Libraries like SDL, SFML etc, make graphics programming a little easier, but you're still going to have to learn a lot to start there. I'd suggest going with an out of the box solution. Python is not my favorite language, but scipy has tons of stuff along these lines.", "id": "dapnsnp"}, {"comment": "I will check it out thanks :)", "id": "dapp0fd"}], [{"comment": "I never really got why Dream In Code calls people _D.I.C. Heads_.\n\nSounds like you want to project from screen space to another coordinate space.", "id": "daqhdx1"}]]], "5g5brq": ["ARMageddon: How Your Smartphone CPU Breaks Software-Level Security and Privacy", "2016-12-02 22:48:30", 20, "https://www.youtube.com/watch?v=9KsnFWejpQg", [[10, "Can someone do a tl;dw? I prefer reading than watching videos."], [1, "If you want to see just what they can do with this hack go to 22m47s. Basically they say it can beat sandboxing using collusion.\n\nWhile this is technically original research it is far from new research. This kind of thing is talked about a lot lately in some papers. This continues to be the case because the industry by and large doesn't seem as concerned with this kind of sidechannel attack as they are with the kind of performance loss it would take to prevent it."]], [[{"comment": "Can someone do a tl;dw? I prefer reading than watching videos.", "id": "dapt9d0"}, {"comment": "I am not expert but seems that they found a way to exploit cache lines based on cycle counters in order to know if some data is in the cache. Knowing this you can modify the data you want. On x86 there is a cflush instruction to flush the cache lines to avoid this but in ARM there is not any for user space so funky tricks needs to be implemented.\n\nPlease correct me if I am wrong, I would like to learn more about this.", "id": "daptms4"}, {"comment": "I had had a conversation with the Bionic (Android's libc) team about syscalls to flush the cache.  The only thing I recall was some disagreement about whether there were separate params for icache vs dcache and if those syscalls survived the transition from ARMv7 to ARMv8.  Can't remember the answers though! Aargh\n\nedit: see `__builtin___clear_cache` [for clearing icache](https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html).  I think this is only implemented for ARMv7, but will try to find more info.\n\nTODO: read https://community.arm.com/groups/processors/blog/2010/02/17/caches-and-self-modifying-code", "id": "dapx8sj"}, {"comment": "Thanks for the info, I'll check it out!", "id": "dapy13p"}, {"comment": "I don't know if it's the same thing, but the TruSpy paper explains one side channel vulnerability. Before the \"victim\" program executes, you saturate the cache with your own data, and after a time slice, you come back and check which memory from your process takes longer to load than if it was still cached. The timing informs you of which cache lines the victim process had to flush, and that can tell you if specific branches were taken or not.", "id": "daq926i"}], [{"comment": "If you want to see just what they can do with this hack go to 22m47s. Basically they say it can beat sandboxing using collusion.\n\nWhile this is technically original research it is far from new research. This kind of thing is talked about a lot lately in some papers. This continues to be the case because the industry by and large doesn't seem as concerned with this kind of sidechannel attack as they are with the kind of performance loss it would take to prevent it.", "id": "daqp20c"}, {"comment": "Talked about lately on *x86*. The video itself says that they were demonstrating that ARM was vulnerable, which most modern papers doubted.  Your comment is not adding anything to the discussion--are you just here for karma?\n\nThere was much more than the covert-channel implementation in this video. Perhaps you should watch it again.", "id": "daqshjn"}, {"comment": "> Talked about lately on x86. \n\nTalked about lately everywhere. For many years now.\n\nThere is no reason to think it wouldn't work on ARM, it just took the effort to write a paper about it. They made up five obstacles which weren't difficult to overcome and then overcame them.\n\n> Your comment is not adding anything to the discussion--are you just here for karma?\n\nAnd your comment is adding what?\n\n> There was much more than the covert-channel implementation in this video. Perhaps you should watch it again.\n\nIf you're just here to show off how much you know about what I did and didn't watch, don't bother. It isn't something you are expert on.\n\nI'm not sure why you are so upset. This is how papers are written. It's how the game is played. They didn't set out to do it thinking it can't be done.", "id": "dar3jro"}, {"comment": "Many years, *as stated in the fucking video*.\n\nThere _is_ reason to think it would not work on ARM, *because of the reasons presented in the fucking video*.  They did not make them up--they were specifically listed as obstacles by other attackers.\n\nYou are everything wrong with reddit.  Stop scanning to spout; try to bring some fucking substance with you next time.  They never said they did not think it was impossible; that's not what a fucking obstacle is. \"Doubt\" doesn't mean \"thought impossible,\" either.", "id": "dar8rds"}, {"comment": "> Many years, as stated in the fucking video.\n\nAgreed. That's what I said too. So why the anger directed at me?\n\n> There is reason to think it would not work on ARM, because of the reasons presented in the fucking video.\n\nNo, again, that's the way the paper game is played. Others didn't go after that part, they didn't need to. But there is no reason to think that changes in cache configuration do anything but make things a little harder. And given their listed error rate, isn't that what they found?\n\nAs I said before, the industry is not concerned about this enough to give up the performance that would be lost by fixing it. The only way to have what the previous thread of execution did not affect your cache hit rates is to make *all memory operations after a thread switch slow* and the industry just isn't interested in that. It's well known and has been for a long time. You can go back to the design of UNIX and see they were not concerned about side channels.\n\n> You are everything wrong with reddit. Stop scanning to spout; try to bring some fucking substance with you next time.\n\nOh, I'm everything that's wrong with reddit. I don't say anything of substance. What are you bringing other than curse words?\n\n> They never said they did not think it was impossible\n\nAgreed. That's what I said too. So why the anger directed at me?", "id": "darahim"}, {"comment": "That is not what you said, whatsoever. You made the same trite comment that everyone in /r/programming simply has to make to sate their keep their membership to the cool kid club.\n\nAgain, saying what you're saying with 20/20 hindsight doesn't fucking help your case. You're saying it was possible--we know it was fucking possible. It was just doubted that, with the obstacles available, that it was going to be a worthwhile implementation that could produce a result.\n\nThere is no fucking industry around side-channel attacks. You're fucking delusional, as I already stated.\n\nYou're talking out of your ass.  Nut up or shut the fuck up.  I'm not even angry.", "id": "dargk5e"}, {"comment": "No, it's what I said.\n\nI said papers had been talking about this for years. I said they didn't think it was impossible. You say the same thing but attack me for it. Odd.\n\n> Again, saying what you're saying with 20/20 hindsight doesn't fucking help your case.\n\nJust because you just came across this doesn't mean it's hindsight for me. Do you have trouble believing others understand how caches work?\n\n> It was just doubted that, with the obstacles available, that it was going to be a worthwhile implementation that could produce a result.\n\nI would suggest it is still doubted. They showed beyond a shadow of a doubt it is possible. Whether it's worthwhile is still a bit more up in the air.\n\n> There is no fucking industry around side-channel attacks. You're fucking delusional, as I already stated.\n\nI'm not sure what you are talking about there. It seems to come from a massive misunderstanding of what I posted. I said the industry (meaning hardware, OS makers, etc.) is not sufficiently concerned with cache-based side channel attacks to take the steps it would require to stop them. They value the speed ups of caches more than the security against sidechannels than invalidating caches across contexts (either in HW or SW) which would bring along slowdowns.\n\n> You're talking out of your ass. Nut up or shut the fuck up. I'm not even angry.\n\nYou tell people you aren't angry at to shut the fuck up, eh? Got a lot of friends?", "id": "darj6mb"}]]], "5g31wk": ["Ruby\u2019s do block in NGS experiment - adapting Ruby's do blocks and thoughts behind this.", "2016-12-02 15:42:08", 2, "https://ilya-sher.org/2016/12/02/rubys-do-block-in-ngs-experiment/", [], []], "5fyod8": ["What is __wchar_t (with the leading double underscores) and why am I getting errors about it?", "2016-12-01 22:44:30", 13, "https://blogs.msdn.microsoft.com/oldnewthing/20161201-00/?p=94836", [], []], "5g76qb": ["What technical details should a programmer of a web application consider before making the site public?", "2016-12-03 04:40:41", 1, "http://softwareengineering.stackexchange.com/questions/46716/what-technical-details-should-a-programmer-of-a-web-application-consider-before", [[0, "Assuming the site is already good and front-end. Then developer only needs 2 things to watch-out for, security and scalability."], [0, "Think about security and stability as mentioned. But more importantly, look at sustainability: build tools to handle the growth, log management, db backups, reports and restarts.\n\nIf your site requires constant updates, organize it well."]], [[{"comment": "Assuming the site is already good and front-end. Then developer only needs 2 things to watch-out for, security and scalability.", "id": "daq1frq"}], [{"comment": "Think about security and stability as mentioned. But more importantly, look at sustainability: build tools to handle the growth, log management, db backups, reports and restarts.\n\nIf your site requires constant updates, organize it well.", "id": "daqgcvo"}]]], "5fmrzj": ["Span<T>", "2016-11-30 04:39:30", 9, "https://github.com/dotnet/corefxlab/blob/master/docs/presentations/SpanOfT.pdf", [[1, "I might be missing (after all it's still morning here) something but I don't understand a few things...:\n\n1) Why (and in what way) is Span<T> stack-only? \n\n2) How is Memory<T> more heap friendly?\n\n"]], [[{"comment": "I might be missing (after all it's still morning here) something but I don't understand a few things...:\n\n1) Why (and in what way) is Span<T> stack-only? \n\n2) How is Memory<T> more heap friendly?\n\n", "id": "dalvfxz"}, {"comment": "I'm not 100% sure, but I sure they are trying to defend against the ghost (garbage collector) they summoned.\n\n1a) Like buffer magic in C but more type safe.\n\n1b) `ref T`fields are a new thing in C# 7. You can define methods returning values by reference. And to keep the language sound they cannot occur as class field types (even indirectly). Therefore they can only be on the stack. See [Ref returns and locals - Msdn Dotnet Blog]\n(https://blogs.msdn.microsoft.com/dotnet/2016/08/24/whats-new-in-csharp-7-0/)\n\n2) Allocating for every small span would result in heap fragmentation and you can more or less implement your own garbage collector ontop of it.", "id": "dalyj99"}, {"comment": "If angels are ghosts, then the GC is indeed a ghost. :-)\nAnd more seriously, Span<T> is stack only to avoid struct tearing issues, to make its lifetime deterministic (it ends when the stack unwinds), and to avoid regressions in GC performance. Since Span<T> can point to a middle of an array, the GC needs to know about such interior pointers and adjust them when it moves the array. This is much cheaper to do for interior pointers on the stack vs the whole heap. Ref fields are such relatively cheap way to scan interior pointers.\nMemory<T> is heap friendly because it does not contain a ref field, and is not subject to memory corruption then it is torn.", "id": "damhrr2"}, {"comment": "thx for the better explanation", "id": "damil35"}, {"comment": "BTW, all of this is described in more detail int eh Span<T> design document starting with the following section: https://github.com/dotnet/corefxlab/blob/master/docs/specs/span.md#struct-tearing", "id": "damjklc"}]]], "5g6b7r": ["I made an extension for VSCode that lets you quickly peek and edit CSS code (like Brackets)", "2016-12-03 01:43:38", 32, "https://www.reddit.com/r/vscode/comments/5g25c8/i_made_an_extension_that_lets_you_quickly_peek/", [], []], "5fp5qi": ["Fundamental Concepts In Programming Languages - C Strachey [1967]", "2016-11-30 14:40:39", 2, "http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.332.3161&rep=rep1&type=pdf", [], []], "5gbpd6": ["VPS on AWS", "2016-12-04 00:00:15", 0, "https://amazonlightsail.com", [], []], "5fvrsm": ["How the Singapore Circle Line rogue train was caught with data", "2016-12-01 12:48:51", 1802, "https://blog.data.gov.sg/how-we-caught-the-circle-line-rogue-train-with-data-79405c86ab6a", [[214, "I'd be intrigued to know what this 'rogue train' was doing to interfere with the other trains."], [146, "> We felt we were on the right track.\n\nHehe"], [100, "Damn, I wish my country have this kind of blog."], [81, "Nice story! And gotta love the humility:\n\n> Note: The code here was written on November 5, 2016\u200a\u2014\u200athe actual day when we were working on SMRT data to identify the cause of the Circle Line incidents. We acknowledge that there could be inefficiencies. You may download a copy of our Jupyter Notebook here.\n"], [66, "Love stuff like this!"], [58, "I was half hoping from the title that someone had smuggled an unauthorized train onto the Circle Line.\n\nBy the way, this analysis would have been helpful to the characters in Judas Unchained by Peter F. Hamilton (sequel to Pandora's Star).  "], [22, "TIL there is a place in Singapore called \"Dhoby Ghaut\"...just in case the Indian programmers on here missed it!"], [15, "Interesting writeup, but feels like Maslow's hammer in the hands of data nerds... \n\nI wonder how would have a detective go about solving this?\nWouldn't a simpler, old-school investigation had revealed the problem with less effort? E.g. signal disruptions started on day X. What changed between X and X-1 (i.e. new trains or trains with repairs)? Then take it from there.\n\nAlso on the data-driven investigation track: wouldn't a map of the railway along with the actual position of incidents have been an easier way to grasp what / when it's going on?\n"], [15, "Nice to see a shout out to E. Tufte.\n\nData visualization is a complex topic and can be very powerful when used well, or poorly."], [12, "Good work.  \nLevel 1 completed.\n\nLevel 2.\nFind MH370.\n\nEDIT: No disrespect intended, it would be a noble goal, and as /u/lapinrigolo indicates, this team has the right skills."], [10, "Spoiler/TL;DR: One train, PV46, had 'hardware problems' - found by data sleuthing, and confirmed by process of elimination. "], [6, "Wait! I read all that and there was NO answer. What was the problem with the rogue train!"], [4, "Interesting anecdote. Have a mate with a certain form of Schizophrenia which enables him to see patterns better than most.\n\nOnce debugged a set-top-box issue which was causing a whole network to crash. By scrolling through the raw logs he was able to spot a single misbehaving box which was causing the issue."], [4, "This post gave me an enormous data boner. Excellent write-up."], [3, "Beautiful detective work and very well written. "], [2, "\"Rogue train\"?  Like in Sherlock?"], [2, "The last graphic seems rather anti-climactic.\n\nhttps://cdn-images-1.medium.com/max/1600/1*LoBiYQBBVqRynqUSmyY9lA.png\n\nI feel like I'd have checked for that correlation really early in the process. \"Is there any train that's usually in or out of service when the problem happens?\" is going to be a very easy question to answer given the data set."], [2, "Can someone say more about Jupyter?  Seems like an intriguing tool.\n\nEDIT: Found some relevant information [here](https://www.reddit.com/r/fsharp/comments/5fxjiy/jupyter_for_f/)."], [1, "Neat!  Interesting visualizations."], [1, "Great write up!"], [1, "If they'd looked at the videos first they would have spotted the recurrence of PV46. It's not like their code and visualizations didn't also rely on heuristics. "], [-1, "[deleted]"], [-9, "I feel better about data scientists and big data now- not a threat to my job.\n\nThe first third of the excursion is easily accomplished via excel, I would hesitate portions of the rest are as well, and the conclusion was reached not by any of the programming, but via actual observation.\n\nDon't get me wrong, I enjoyed the article and it's thrust. But there is a certain hype surrounding big data and how software is going to save, change, and then devour everything. And this shows we are a long, long way off.\n"]], [[{"comment": "I'd be intrigued to know what this 'rogue train' was doing to interfere with the other trains.", "id": "danhws6"}, {"comment": "The press release linked in the OP indicates a signal transmitter (radio, not train) was erroneously emitting signals it wasn't supposed to (in addition to the correct signals). The underlying cause of this intermittent failure on one unique specimen among the fleetwide deployment of such hardware was not known at the time, though presumably they know a bit more now.", "id": "dani3vl"}, {"comment": "That's way less interesting than the *renegade train with nothing to lose and everything to prove traveling the wrong way down the tracks because he just can't live without her* that I was imagining.", "id": "danmi1w"}, {"comment": "I read it thinking that it was going to be a malicious guy who planted a device on the rogue train which would deliberately disrupt trains travelling in the opposite direction.", "id": "dannrhh"}, {"comment": "I was rooting for the idea that someone had commandeered a train to steal fares while running on the same tracks as real trains...", "id": "dao28mo"}, {"comment": "That's what I was hoping for too. Somehow he braked all of the other trains just enough to fit one additional train in on the loop", "id": "dao3t6j"}, {"comment": "And in the end, a noisy radio causing the control systems and/or other vehicles to lose confidence in their status. \n\n(**E**mergency **B**rake usually serves as the base \"Shits happening\" response when nothing else is there to intercept the fault.)", "id": "daodgqq"}, {"comment": "This is the most succinct and accurate summary.\n\nSource: was very tangentially involved. I want my Sunday back.", "id": "daohlpd"}, {"comment": "I thought it was a train that wasn't authorized for use of the railway, but somehow it was being run and they couldn't figure out where or how or who.", "id": "daobnk5"}, {"comment": "I think you're thinking of a *Runaway train never going back. Wrong way on a one way track. Seems like I should be getting somewhere. Somehow I'm neither here nor there*", "id": "danrbdj"}, {"comment": "I wrote a song for you:\n\n---------------------\n\n##Rogue Goddamn Train\n\n*(To the tune of: [\"Runaway Train\"](https://www.youtube.com/watch?v=NRtvqT_wMeY) by Soul Asylum)*\n\n^^^^.\n\nStop you dead in the middle of a ride\n\nLike a [Chucky](https://en.wikipedia.org/wiki/Chucky_(Child%27s_Play\\)) without a [bride](http://www.imdb.com/title/tt0144120/?ref_=fn_al_tt_1)\n\nYou were there with a radio faultin'\n\nI'm late again, and now my boss is rantin'\n\n^^^^.\n\nSo mad, help, my job I need to keep\n\nMy stress levels, a hill too steep\n\nPromised myself I wouldn't weep\n\nOne more promise I couldn't keep\n\n^^^^.\n\nIt seems no one can help me now\n\nI'm late again, it's all your fault\n\nThis time you have again stopped my train\n\n^^^^.\n\nRogue goddamn train, on a two-way track\n\nYou do deserve a big whack\n\nOh God, I should be get-ting to work\n\nAnd now I'm late again, you big jerk! [BASS BREAK]\n\n^^^^.\n\nWhen I find you, dismember you to scrap\n\nThough I'm always a calm chill chap\n\nFor your sins, I will use vi-o-lence\n\nYour mech-a-nics are such cretins\n\n^^^^.\n\nI will go where you don't want me to\n\nEnd your life, accursed choo-choo\n\nSmash you up, your controls, your cabin\n\nNo green signal for a rogue goddamn train\n\n^^^^.\n\nBe-lieve me that I hate you\n\nYour ra-dio circuit's through\n\nI will stop you dead, believe it!\n\n^^^^.\n\nRogue goddamn train, on a two-way track\n\nYou do deserve a big whack\n\nOh God, I should be getting to work\n\nAnd now I'm late again, you big jerk!\n\n^^^^.\n\n[INSTRUMENTAL INTERLUDE]\n\n^^^^.\n\nFound the bugger, fuckin rogue goddamn train!\n\nIn a siding sheltered from the rain\n\nHammer? Nah fuck it, start up the [crane](https://upload.wikimedia.org/wikipedia/commons/8/85/A-9111_on_crane.jpg)\n\nWe'll raise him high, then drop that damn shitstain\n\n^^^^.\n\nRogue goddamn train never comin' back\n\nSmashed to small bits, that's pay-back!\n\nMaybe now I can reach work on time\n\nSomehow, I don't re-gret my crime\n\n^^^^.\n\nRogue goddamn train never comin' back\n\nRogue goddamn train, not even a plaque\n\nRogue goddamn train's inter-fer-ence\n\nHere's to its long wished for disap-pearance\n\n^^^^.\n\n[INSTRUMENTAL FADE OUT]\n\n^^^^.\n\n------------------\n\n**:-)**\n\n^(*Edit:* changed \"rogue damn train\" to \"rogue goddamn train\", and other changes to fix the scansion and meter.)\n\n\n", "id": "daonukc"}, {"comment": "Eh, I think a rogue train with a split personality because half of it wants to be a passenger train, half of it wants to be a motorbike is plenty exciting enough.", "id": "dao51jj"}, {"comment": "And in the finale it jumps the tracks like free willy jumped the wall to ride the road like a bike, but kills a bunch of people because trains shouldn't jump tracks.", "id": "dao6jfl"}, {"comment": "I'd watch the hell out of that movie. ", "id": "danrbq7"}, {"comment": "Starring Jan Michael Vincent?", "id": "daog1g3"}, {"comment": "Thomas.", "id": "daohms7"}, {"comment": "ShinyTime Station:NY\n\nI'm Thomas and this is my town. These are my rails. This is their story. ", "id": "daoaep4"}, {"comment": "Ah, awesome - thanks for taking the time to reply :)", "id": "danifct"}, {"comment": "It most likely had a transmitter which did not meet specifications for Adjacent Channel Interference. Maybe it was using too much power or had a defective amplifier, causing RFI. That specific train was able to communicate properly as it didn't have an abnormally high number of stoppages. As other trains passed it by, the malfunctioning transmitter \"wiped them out\" (desense) and the other trains were unable to form the connection to the radio system.", "id": "dansxsw"}, {"comment": "What surprises me is that none of the drivers made this connection.\n\n\"My train broke down 5 times... each time while passing another train. After the 3rd time, I began to pay notice and it was the same one each time.\"", "id": "daosi42"}, {"comment": "The Circle Line uses fully automated trains, and since it's fully underground, you can't see the train coming in the opposite direction either. ", "id": "daotz3e"}, {"comment": "The frequency of the trains can be as high as 2 mins, passing another train wouldn't be notable ", "id": "dap1241"}, {"comment": "Right?!  Whats the deal with PV46?", "id": "dannqg4"}, {"comment": "A *sneak attack*, obviously.", "id": "danvazg"}, {"comment": "Probably beating them up and taking their lunch money", "id": "danok20"}], [{"comment": "> We felt we were on the right track.\n\nHehe", "id": "dankgb0"}], [{"comment": "Damn, I wish my country have this kind of blog.", "id": "danhprf"}, {"comment": "Right? Stealler work.", "id": "danorbh"}, {"comment": "Also their public data site is [pretty damn cool](https://data.gov.sg/). Probably easier since they have fewer citizens than many large American cities, but impressive nonetheless.", "id": "daoandf"}, {"comment": "Nah, aside from NYC, Singapore outnubers them mostly. ", "id": "daoiq4h"}, {"comment": "Yeah, you're right. idk why I thought there were a few over 10M in population. Maybe I was thinking of states.", "id": "daol86n"}], [{"comment": "Nice story! And gotta love the humility:\n\n> Note: The code here was written on November 5, 2016\u200a\u2014\u200athe actual day when we were working on SMRT data to identify the cause of the Circle Line incidents. We acknowledge that there could be inefficiencies. You may download a copy of our Jupyter Notebook here.\n", "id": "danki7x"}, {"comment": "More like, anticipating the armchair programmers.", "id": "danvork"}, {"comment": "Why not both?", "id": "danz2s3"}, {"comment": "I find myself apologizing for production code as well. I think it's a bit unnecessary and I'd like to break the habit. We should be proud of our code when it accomplishes the original goals. Also, everyone quickly realizes that production code is ugly without refactoring (multiple times, probably). So really, we are apologizing for not refactoring.", "id": "danz7gk"}, {"comment": "You know what they say about beauty and the eye of the beholder. At some point you gotta let go -- if it works, passes them tests, is not criminally slow -- move on, nothing to see here. Especially if you've got other stuff to do. Somebody doesn't like *how it feels*? \"Well I'm sorry you suck\", which might get lost in translation to the office-lingo: \"OK, fine.\"", "id": "dao02ik"}, {"comment": "The worst part: I work by myself with nobody inspecting my code and I *still* cringe regularly when checking out my own packages.", "id": "dao0smg"}, {"comment": "That's why programming can be considered art. You're never happy with past work.  ", "id": "daora3g"}, {"comment": "To be fair, code that you only ever run once isn't quite the same as what most people describe as \"production code\".", "id": "dao6ow7"}, {"comment": "Yeah that's what they all say until the damn trains break down again.", "id": "daox5ax"}, {"comment": "I think there's value in signaling \"here may lie dragons\", undermining silly assumptions like \"this code's been in production for so long that *surely* it's not the source of my bug...\"\n\nBut I do so shamelessly.\n\n    // FIXME: This is O(scary)", "id": "dap0edu"}], [{"comment": "Love stuff like this!", "id": "danfifq"}], [{"comment": "I was half hoping from the title that someone had smuggled an unauthorized train onto the Circle Line.\n\nBy the way, this analysis would have been helpful to the characters in Judas Unchained by Peter F. Hamilton (sequel to Pandora's Star).  ", "id": "danr0y2"}, {"comment": "Yeah, but that was over _decades_. Also, [spoiler](/several of the guys who would be looking were actually working for the Starflyer).", "id": "danuhi3"}, {"comment": "I can't decide whether I actually want to recommend those books to people.  There are some really cool topics brought up and some great action sequences, but the Ozzie plot in the first book confused and enraged me.  That cliffhanger was so cruel.\n\nSo I'm okay with spoiling it a tiny little bit, especially since I don't think it would be obvious why this analysis would be helpful until it comes up naturally.", "id": "danvgwc"}, {"comment": "Usually I recommend the Night's Dawn trilogy of his, but the continuation of the 'Pandora' universe (the Void trilogy and so on) are (to me) really quite good.", "id": "danvkgk"}, {"comment": "Your're the second recommendation I've seen for Void trilogy.  I've probably been away from Hamilton long enough to give him another shot.", "id": "danwy4i"}, {"comment": "I'd recommend them.  There are certainly some \"ok, how the hell does that relate to anything\" moments but overall I've enjoyed them.\n\nMorningLightMountain4Life\n", "id": "danzeuc"}, {"comment": "> There are certainly some \"ok, how the hell does that relate to anything\" moments but overall I've enjoyed them.\n\nHamilton puts a whole lot of effort into worldbuilding. Half the books are basically irrelevant to the stories he's telling (you could strip so much stuff) but they construct the world around the story and that's the bit I find fascinating. ", "id": "daoppjs"}, {"comment": "Absolutely.  It feels very real and lived in.", "id": "daor3n2"}, {"comment": "Enzyme-bonded concrete", "id": "danzsbg"}, {"comment": "> I was half hoping from the title that someone had smuggled an unauthorized train onto the Circle Line.\n\n[A silver one?](https://en.wikipedia.org/wiki/Silverpilen)", "id": "daosbdz"}, {"comment": "TIL about the silver ghost train", "id": "daosmjg"}, {"comment": "Is this [Simple English Wikipedia](https://simple.wikipedia.org) all of a sudden?", "id": "daoxsb8"}], [{"comment": "TIL there is a place in Singapore called \"Dhoby Ghaut\"...just in case the Indian programmers on here missed it!", "id": "danifx6"}, {"comment": "Singapore is a mix of chinese, british, malay and indian cultures. It's like a gateway between east and west.\n\nWarning - Opinionated comment follows: It's a nice place to visit but a shit place to live as the whole country is basically a benevolent dictator's social experiment.", "id": "danj001"}, {"comment": "Counterpoint: Just look at the stupid things people vote for in open democracies.\n\nFor a scale model country in a little bottle Singapore is actually a very livable place. A bustling, high tech, harmonious and peaceful multicultural city with great food at all hours. Dogs and cats, hindus and christians and muslims living side by side. Roti prata and kopi-o at 2am. $60 tickets to Bangkok. $150 to Hong Kong. $250 to Tokyo. A great base for exploring SE Asia. Everything just works here. \n\nSince I graduated from school I've lived and worked in five different countries (including Singapore) plus several US states. I'm old enough to have seen first hand the slow decline of the US, UK, EU, even beautiful Scandinavia where the sometime widely admired social democratic great society maintained fine and free hospitals; these have withered to the point where non-emergency procedures can have 2-3 year waiting lists. The old people get almost no help from the government anymore, and retirement homes looks like prisons or refugee camps. \n\n My Danish uncle was in hospital for a minor malady and lost a leg to sepsis that he got from the perpetually soggy, moldy and bacteria-laden carpet in his hospital room. They closed down most of the regional hospitals in the country so now ambulances have to ferry patients up to 60 kilometers for the nearest emergency room.\n\nThere are things about Singapore I find absurdly regressive, like their conservative anti-LGBT policies and media censorship, and so on. But Singapore takes care of its own, with great efficiency. Their hospitals are second to none. Citizens get subsidies, and even if you have no medical insurance (which is cheap), procedures and examinations cost only a fraction here of US prices, and there is no waiting. There are virtually no homeless people here. The needy will receive public housing. They don't sequester the old into retirement ghettos; they live side by side with younger couples and remain part of society. I could go on. \n", "id": "danosrm"}, {"comment": "> decline of the US, UK, EU, even beautiful Scandinavia\n\nAccording to the [WHO ranking](http://thepatientfactor.com/canadian-health-care-information/world-health-organizations-ranking-of-the-worlds-health-systems/) France and Italy still beat Singapore health care, even in decline. But you're right in that health care in Denmark is worst out of all Scandinavian countries.", "id": "daovii8"}, {"comment": "The old people get almost no help from the government anymore, and retirement homes looks like prisons or refugee camps.\n\n\nWhat? What country are you taking about? Because in the UK almost all welfare spending goes to them, they are the richest cohort by far", "id": "daox0g0"}, {"comment": ">  I'm old enough to have seen first hand the slow decline of the US, UK, EU, even beautiful Scandinavia\n\nSorry, this bit is hilarious.\n\n> anti-LGBT policies and media censorship\n\nOh ok, it all makes sense.", "id": "daokdmy"}, {"comment": "AFAIK Scandinavian healthcare is better than ever. Sure other nations have caught up and some has even passed us but it's not like his uncle would have had better care a decade or two earlier.", "id": "daow48t"}, {"comment": "I live in Denmark, and the healthcare system is under a tremendous strain at the moment. My wife is a nurse, and they are all being asked to do more with less. Aging population, higher costs across the board, and a conservative government that is implementing austerity measures means that the quality is going down across the board. \n\nHowever, there is still excellent treatment for serious health problems with a quick turnaround. My friend was diagnosed with early stage cervical cancer, and had her hysterectomy within 10 days, and got comprehensive followup treatment and 6 paid weeks off of work.  ", "id": "daoxpw1"}, {"comment": "Disneyland with the death penalty.\n\nSource: https://www.wired.com/1993/04/gibson-2/", "id": "daok4aq"}, {"comment": "> https://www.wired.com/1993/04/gibson-2/\n\nThat essay by Gibson interprets things that others would find neutral or positive as a negative, and it is also very dated. Many policies and many aspects of Singapore's society has changed since then.", "id": "daozxwm"}, {"comment": "Oh, I wasn't referencing his article as a point of fact but rather giving credit to the phrase \"Disneyland with the death penalty\". \n\nSingapore will forever be polarizing. It can be best summed by their first leader, Mr. Lee Kuan Yew who said \"with few exceptions, democracy has not brought good government to new developing countries...What Asians value may not necessarily be what Americans or Europeans value. Westerners value the freedoms and liberties of the individual. As an Asian of Chinese cultural background, my values are for a government which is honest, effective and efficient\".\n\nSource: His speech entitled \"Democracy, Human Rights and the Realities\", Tokyo, Nov 10, 1992\n\n", "id": "dap17v5"}, {"comment": ">  their conservative anti-LGBT policies and media censorship, and so on. But Singapore takes care of its own...\n\nUnless you're gay or like to have access to information.", "id": "dapie5y"}, {"comment": "I love python tho ", "id": "danlk8a"}, {"comment": "Yeah, but when I get elected benevolent experimental dictator for life, we're all going with Perl, OK?", "id": "danmu29"}, {"comment": "If you're sometimes a tiny bit malevolent and could be talked into outlawing syntactically significant whitespace, I'm backing you all the way.", "id": "danoy6r"}, {"comment": "Perl would classify you as \"malevolent experimental dictator for life.\"", "id": "dano9zj"}, {"comment": "Yaaaay!\n\nIs 'use strict;' a requirement?", "id": "dansug8"}, {"comment": "Yeah dude, totally. Those Singaporean losers must wish they had America's new president amirite?", "id": "danv41b"}, {"comment": "> the whole country is basically a benevolent dictator's social experiment.\n\nWell, it seems to be working. Europe stagnates because representative democracy prevents anything from happening, and the US just elected that orange thing as a president.", "id": "daosfi6"}, {"comment": "I thought Singapore was a democracy?", "id": "danncte"}, {"comment": "A democracy where the ruling party has won 14 consecutive terms in office and usually has well over a supermajority of seats in parliament.", "id": "dannocx"}, {"comment": "[Wikipedia](https://en.wikipedia.org/wiki/People's_Action_Party#Ideology) says they're claim to be a Socialist Party. I think looking at their specific policies enacted would be more productive than labeling them one or two words like right/left/center/socialist/liberal etc.", "id": "dap00eb"}, {"comment": "uh, I don't quite understand your point (or at least why you're replying to me)? \n\nA party's claim to socialism bears no relation to their commitment to democracy.", "id": "dap0gqy"}, {"comment": "ah yeah, my comment is not a reply to your comment. but just wanted to link wikipedia\n\n> A party's claim to socialism bears no relation to their commitment to democracy.\n\nI fully agree", "id": "dapebg6"}, {"comment": "A democracy where districts get services prioritized by how many votes the ruling party got on the last election.\n\nOh and where \"editors don't censor journalistic stories, they just get replaced with other editors if they run stories the government dislikes.\" (A Singapore Straits Times journalist who asked not to be named.)\n\nSingapore is just Malaysia in a suit.", "id": "danox4k"}, {"comment": "Nah, in Malaysia they'd get accused of sodomy and imprisoned.", "id": "danp870"}, {"comment": "Er. Electricity service is more than a bit of an exaggeration. It's no slum. You hit the way the news is run on the head though. ", "id": "danp5p2"}, {"comment": "Garbage service then? The people I interviewed said that community services were prioritized. I'll edit my post.", "id": "danpruw"}, {"comment": "It's just things like fresh paint on building facades, upgrades to elevators and general maintenance work to public areas that's held back. Everyone gets to have their electricity and water services, they get to continue to go to school and work and live life like every other Singaporean, they just live in slightly less prettier buildings and have to periodically climb the stairs. ", "id": "dantk9i"}, {"comment": "I think they meant upgrading service for their houses and surrounding area. Basic stuff is still taken care. Just that any benefit and advantage, the districts that voted the opposition will get it slowly or never get it. ", "id": "dans72f"}, {"comment": "Yes it is, albeit a [flawed democracy](https://en.wikipedia.org/wiki/Democracy_Index) (ranked 74).", "id": "danvbhf"}, {"comment": "It means the place where people go to wash their clothes, right?", "id": "danio3o"}, {"comment": "You are right.\n\nIn the older day, Indian men washed their clothes near a river in that area (the river is no longer existed).", "id": "danscad"}], [{"comment": "Interesting writeup, but feels like Maslow's hammer in the hands of data nerds... \n\nI wonder how would have a detective go about solving this?\nWouldn't a simpler, old-school investigation had revealed the problem with less effort? E.g. signal disruptions started on day X. What changed between X and X-1 (i.e. new trains or trains with repairs)? Then take it from there.\n\nAlso on the data-driven investigation track: wouldn't a map of the railway along with the actual position of incidents have been an easier way to grasp what / when it's going on?\n", "id": "danqnq8"}, {"comment": "Not really...the method you describe is similar to what happened, except that data science can leverage huge amounts of data. The Jupyter workbook was used to reduce effort, not increase it. Also the train causing interference had been in service for a year before it suddenly developed these problems, rather than a brand new train being introduced and instantly causing interference. \n\nI think a detective would've solved this in almost exactly the same way. Look at the incidents, plot them in different ways, group the incidents that seem related and try to discover the commonalities. It would've taken longer on pen and paper, if that's what you mean.  ", "id": "dansg68"}, {"comment": "> What changed between X and X-1 (i.e. new trains or trains with repairs)?\n\nIt's very possible, maybe even likely, that no new trains or repairs led to the hardware failure. Sometimes hardware just fails randomly, like a light bulb burning out. In such cases, this method of investigation will not lead to the cause because it isn't time-correlated (or is, but very weakly).", "id": "dao19zv"}, {"comment": "This is a circular line. It's essentially 1-dimensional. They did map the incidents, they just projected it on a single axis instead of a basemap. ", "id": "dao7qh3"}, {"comment": "Singapore's Circle Line is not actually a circle (yet - there are plans to make it one). ", "id": "daodvh9"}, {"comment": "Ah - so that's why there are distinct return journeys. I was wondering why the route had to be reversed like that. ", "id": "daogckk"}, {"comment": "Even if it was a full loop it could still be run both directions to save time. If you got A->B then need to return you don't want to go through CDEFGHIJKLMONPQSTUVWXYZ just to get back to A", "id": "daoo1lf"}, {"comment": "Absolutely. But why not just have separate trains doing loops in each direction?", "id": "daopa3s"}, {"comment": "closed loop circle lines are very tough to manage - if a train is late leaving the platform, then the next train may have to slow down/wait at red signal briefly, which will cascade, as an ever-increasing [phantom traffic jam](https://en.wikipedia.org/wiki/Traffic_wave). In addition to this, when staff have to change the changeover has to be at a normal station in a normal station's dwell time, which is obviously an easy point at which delays can happen. \n\nThe solution is to have a distinct end-point, where there can be a longer dwell time to act as a buffer to absorb delays/irregularities in the schedule and give chance for the staff to changeover and clean the train.\n\nIf you're interested, the authoritative blog on london transport, London Reconnections, did a great but very in-depth look at the Circle line (now a spiral line) on the London Underground:\n\nhttp://www.londonreconnections.com/2013/uncircling-circle-part-1/   \nhttp://www.londonreconnections.com/2013/uncircling-circle-part-2/", "id": "daoyrm0"}, {"comment": "I think you missed station R", "id": "dapt4yc"}, {"comment": "Station R is like 13th floor in hotels", "id": "daqah3a"}, {"comment": "The heisenbug-like nature of this issue made it pretty damn difficult to pinpoint. They did try empirical methods - even disabling cell coverage in affected stations for an entire day. Public discontent grew. They brought in the nerds.", "id": "daohyf6"}], [{"comment": "Nice to see a shout out to E. Tufte.\n\nData visualization is a complex topic and can be very powerful when used well, or poorly.", "id": "danja7s"}], [{"comment": "Good work.  \nLevel 1 completed.\n\nLevel 2.\nFind MH370.\n\nEDIT: No disrespect intended, it would be a noble goal, and as /u/lapinrigolo indicates, this team has the right skills.", "id": "danhmpq"}, {"comment": "Wrong country.", "id": "danjrru"}, {"comment": "Right skills.", "id": "danjzun"}, {"comment": "close enough, lor", "id": "danm7md"}, {"comment": "Must still be too soon", "id": "dank7a4"}, {"comment": "Seriously?", "id": "dankv75"}], [{"comment": "Spoiler/TL;DR: One train, PV46, had 'hardware problems' - found by data sleuthing, and confirmed by process of elimination. ", "id": "dani5sl"}, {"comment": "This summary doesn't do this amazing writeup justice. Everyone: just read it.", "id": "danoz1c"}], [{"comment": "Wait! I read all that and there was NO answer. What was the problem with the rogue train!", "id": "danw8fu"}, {"comment": "Onboard transmitter broadcasting incorrect / malformed signals causing a failure in the signal system which led to automatic emergency braking on the train.", "id": "dao3om8"}], [{"comment": "Interesting anecdote. Have a mate with a certain form of Schizophrenia which enables him to see patterns better than most.\n\nOnce debugged a set-top-box issue which was causing a whole network to crash. By scrolling through the raw logs he was able to spot a single misbehaving box which was causing the issue.", "id": "dao8a8q"}], [{"comment": "This post gave me an enormous data boner. Excellent write-up.", "id": "dao8n6p"}], [{"comment": "Beautiful detective work and very well written. ", "id": "daoco24"}], [{"comment": "\"Rogue train\"?  Like in Sherlock?", "id": "dano2l7"}, {"comment": "Rogue One, PV46", "id": "danz6ap"}], [{"comment": "The last graphic seems rather anti-climactic.\n\nhttps://cdn-images-1.medium.com/max/1600/1*LoBiYQBBVqRynqUSmyY9lA.png\n\nI feel like I'd have checked for that correlation really early in the process. \"Is there any train that's usually in or out of service when the problem happens?\" is going to be a very easy question to answer given the data set.", "id": "dao6nqh"}, {"comment": "Their original data set couldn't have answered that question.   The data set they were provided listed only incidents.  It didn't include data as to which trains were in service at which times.", "id": "dao9eu7"}, {"comment": "A train is in service when it experiences an incident, and they have at least four incidents for the train in question.\n\nAlso, they said they just got impatient waiting for the train schedule data, after requesting it late in the process. Someone could have requested that far earlier.", "id": "daoa9in"}, {"comment": "> A train is in service when it experiences an incident, and they have at least four incidents for the train in question.\n\nExcept that, as the article mentions: \"We also observed that the unidentified \u201crogue train\u201d itself did not seem to encounter any signalling issues, as it did not appear on our scatter plots.\"\n\nAlso, it's easy to look in hindsight and say they should have gotten the train schedules and correlated to it earlier; but as the article also mentions: they didn't go into this knowing the problem was related to any specific train.  The \"rogue train\" hypothesis didn't even arise until they saw that the incidents seemed to be lining up along with some other train.  They were looking for location and time correlations first.  And they *still* found the guilty train in the same day.", "id": "daoantz"}, {"comment": "Yes, these guys worked fast. I just can't imagine how the failures didn't get cross referenced to trains in service weeks earlier.", "id": "daoapgp"}, {"comment": "Not really... the point is that the previous data allowed them to hypothesize that a train was the cause, as opposed to a million other possible causes.\n\nIf it was something like a broken signal light, then you'd ask \"why didn't they request signal light data\" or if it was a television station, you'd ask \"why didn't they request television programming data\". Sewer construction, wifi, the transmitters in the trains going out of tune over time, cosmic radiation. It could have been anything.", "id": "daos5ni"}, {"comment": "> If it was something like a broken signal light, then you'd ask \"why didn't they request signal light data\" or if it was a television station, you'd ask \"why didn't they request television programming data\"\n\nNo, I wouldn't.", "id": "daosdft"}], [{"comment": "Can someone say more about Jupyter?  Seems like an intriguing tool.\n\nEDIT: Found some relevant information [here](https://www.reddit.com/r/fsharp/comments/5fxjiy/jupyter_for_f/).", "id": "daopior"}], [{"comment": "Neat!  Interesting visualizations.", "id": "danmjr4"}], [{"comment": "Great write up!", "id": "danq0io"}], [{"comment": "If they'd looked at the videos first they would have spotted the recurrence of PV46. It's not like their code and visualizations didn't also rely on heuristics. ", "id": "danyjzy"}], [{"comment": "[deleted]", "id": "daowwpn"}, {"comment": "Dont be a dick", "id": "dap23ek"}], [{"comment": "I feel better about data scientists and big data now- not a threat to my job.\n\nThe first third of the excursion is easily accomplished via excel, I would hesitate portions of the rest are as well, and the conclusion was reached not by any of the programming, but via actual observation.\n\nDon't get me wrong, I enjoyed the article and it's thrust. But there is a certain hype surrounding big data and how software is going to save, change, and then devour everything. And this shows we are a long, long way off.\n", "id": "dant0xx"}, {"comment": "What are you talking about? This isn't big data. This isn't even medium data. Rule of thumb: if you can fit the dataset in your laptop's RAM, it isn't big data.\n\nOf course you could do this in excel! Hell, their initial dataset was an excel spreadsheet! I'm sure python was chosen because they were proficient in python, but not as proficient in excel. Why does it matter?", "id": "danudca"}, {"comment": "A lot of data science CAN be done in excel.  Even \"big data\" can have samples of it to find useful stuff like this.  It's usually \"big\" because it covers a large population and can find the trends. \n\nWith some more work, this group probably could have had it automatically detected the pattern of the rogue train, but they spotted it soon enough and shortcutted past it.", "id": "dao5rzp"}, {"comment": "I think the idea that they spotted the train before more work could be done is true, but very weak on their part. I mean, without completing the work there are people (read: me) who now think that this method is actually a dead-end, because the researchers themselves gave up on it. \n\n\nWhat makes this better than an afternoon tooling around in Excel? It certainly wouldn't be the results ;)\n", "id": "daoh7hq"}, {"comment": "Using big data effectively has the same primary constraint as using small data effectively:  a requirement of being curious and using your data creatively.  Besides that it's mostly best practices and sound engineering.  \n\nThis project did a good job demonstrating those most important first traits.  And approaches of this type could be applied to much larger problems that are economically unsolvable without data to first winnow the effort down with.", "id": "daoazkg"}, {"comment": "I respect your view but disagree with it; imho big data's sizzle is being able to be creative and curious with the copious data on-hand, while conversely the constraints of small data amounts simply do not afford that approach. Put another way- you can only do so many things with so many data points; the more data points, the more possibilities.\n\nAnd this is where I think my point is made; there was a big-data attempt at a small-data problem and the predictable occurred- no answered could be attained, and it was ultimately good ole direct observation ftw. At least intellectual honesty prevailed here and there was no attempt to cover-up the findings; there was, however, decent p.r. work done to obscure it, again that's just my take.\n\nThe article and all the comments here make it sound like there was some sort of resounding success; I don't see it. There was this unstated but seeming need to break away from excel and show the superiority of Python and 'coding' over it; ultimately, it failed, and the graphs arguably weren't even prettier. Was there a \"Wright Brothers\" moment I missed while flying my kite on the same beach?\n\nWhat I find insulting is that there was no run-down of the classic Excel approach, with pivot tables. Sounds so archaic here, doesn't it? But I think that's because there's a base level of snobbery here when comparing Excel to actual programming. At the least it would've shown the necessity of the approach, if there really was any.", "id": "daogyth"}, {"comment": "Unfortunately, your point doesn't apply here:  at no point in the article did the authors claim that their project involved \"big data\".   They just clearly demonstrated how data made the investigation easier.   \n\nYour points about excel are also misplaced - since they did start with simple histograms.   Hardly invented by excel, but definitely possible with a spreadsheet.  They proceeded into more sophisticated analysis after determining that the simplest approach didn't pan out.   \n", "id": "dap8z9j"}, {"comment": "The approach was a la big-data, where there was a hope that something in the data would show some promise because... data. \n\nThe proceeded into more sophisticated analysis not after determining the simplest approach didn't pan out- they skipped over trying to solve it in Excel without even mentioning they had.\n\nAnd when the more sophisticated, obviously useless approach showed no promise, either, they went to old physical observation and the answer was obvious.\n\nNone of that sounds like success to me.", "id": "dapo7sn"}, {"comment": "Big data starts at double or triple digit terabytes.", "id": "dao3hv9"}, {"comment": "I think the best definition is that \"big data\" starts when you can't perform your analysis quickly enough on a single server.\n\nWhich could involve running hundreds of complex queries concurrently against just a single TB of data. ", "id": "dapsdml"}, {"comment": "I should've been more articulate, I mean the approach. This smacks of big-data methodology and philosophy. And it failed.", "id": "daoh8us"}]]], "5fwzd2": ["Harser \u2014 Easy way for HTML parsing and building XPath", "2016-12-01 17:59:41", 0, "https://github.com/sihaelov/harser", [], []], "5g4cpl": ["Angular 2 is terrible (not my opinion)", "2016-12-02 20:02:46", 102, "https://meebleforp.com/blog/36/angular-2-is-terrible?platform=hootsuite", [[29, "I agree with some of these, in particular the Observables. Both because of the issues with Rx being in beta as well as the fact that I don't see much of an improvement over Promises in return for the complexity introduced. I'd love to learn more about using Rx for actual data streams, and I understand how it's being used to abstract web app design into a stream of actions and whatnot, but I have yet to actually see a concrete way in which that translates to a better development experience.\n\nHowever, complaining about domain specific terminology for Angular 2 is silly considering that it's a complete MVC framework, *and* that many of the terms are used elsewhere.\n\n>Angular replaces the DOM with its own grotesque mutation of HTML, the browser history and location API with its own routing and location service, and XHR and websocket with its HTTP client.\n\nAgain, it seems like this dude just doesn't want a full fledged MVC framework. Or that somehow he's able to tolerate all the jargon and functionality with vue.js but not Angular 2.\n\nI'll agree that it's silly that the JavaScript documentation still hasn't been done, but honestly I think Angular 2 should just go full TypeScript anyway, since using JavaScript for it is such a pain.\n\nThe rest of his complaints mostly boil down to it being too complex and looking icky. \u00af\\\\\\_(\u30c4)_/\u00af Matter of opinion I guess. As for the speed, it seems to perform [in the middle of the pack](https://auth0.com/blog/more-benchmarks-virtual-dom-vs-angular-12-vs-mithril-js-vs-the-rest/). [Here's another benchmark](http://www.stefankrause.net/wp/?p=316). Vue, especially Vue 2.0, seems to have a slight performance edge, but it doesn't seem to be even remotely large enough to warrant disregarding Angular 2. I wish I could comment on development efficiency differences for large applications between the two, but I haven't used Vue much."], [18, "I've upgraded my application to Angular 2. \n\nAll I have to say is that I love it and won't be looking back anytime soon. "], [20, "It's not terrible. But i'd argue its complexity VS benefits is not a good ratio, especially for those who update from v1 which just works. I also hate the fact that it's trying to be everything and anything, that I have to learn Rx.js on top of that ... \n\nObviously v1 has problems but they are not irredeemable and they didn't need a full rewrite to be solved.\n\nSome people want JEE in the client, good for them. Others want a slightly better backbone that is easy to use, because most apps don't need client side JEE. To the latter Angular v1, Vue.js or React is a better alternative."], [17, "I like it. But it definitely took me more than two weeks to learn. It's also definitely a framework and definitely \"something to learn\". It's new, and it's more heavyweight than most other front end frameworks I've used.\n\nI'm using it for a moderate-sized application right now and it's exactly what I need. The Typescript is almost nicer than the framework itself but that the Docs and the community all speak typescript is central to its ease of use."], [10, "Im in no way an angular 2 expert, but 2 weeks ago i wanted to give it a try, proceeded to angular 2 documentation to build the \"HelloWorld\", im coming from angular 1, imagine my surprise, hellow world took over 8 files to be completed, thats fkin bull.\n\nEdit: sintax"], [10, "> Angular 2 stable is built on experimental language features (TypeScript decorators, based on a Stage 1 TC39 draft proposal) and beta libraries (Rx.js 5.0).\n\nThat's a good thing, since it's probably first time in javascript history someone is maintaining proper versioning and release process, so Rx beta is probably more stable than rightpad v30.21.11\n\nIt's not like there are many non-shit libs to pick from."], [7, "> while there is only one JVM, there are half a dozen JavaScript engines, \n\n?! There's more than one JVM, and for JS there's WebKit, Gecko and... Chakra?"], [5, "why use ang over react?"], [4, "Oh he's only used it for 2 weeks. I'm dying to hear what this person has to say and what their opinion is of the javascript framework ecosystem."], [4, "A lot of these points apply some extent to other frameworks as well, but the reason I dislike Angular 2 is the documentation. Even the TypeScript documentation makes it difficult to do some common things. For example, last time I tried Angular 2 (shortly after it went stable), I never was able to figure out how to retrieve a route parameter for use in a component. This combined with the fact that many other simple things took up to a half hour to figure out made me drop Angular 2 like a brick."], [3, "Angular 2 is great representative of [\"second-system effect\"](https://en.wikipedia.org/wiki/Second-system_effect). But it's definitely not terrible. Just, they made it much different from V1 and that upset lots of people."], [3, "Have been using ng2 at work for a couple of months now - it has it's problems but it's a good library. Especially nice in an enterprise setting where most devs are familiar with WPF or similar OO methodologies.\n\nThe worst part about Angular 2 is the build/package management/tooling - webpack/karma/npm are just immature crap barely cobbled together from even worse crap and only barely runs in the best case scenario, and worst case is you spend days figuring out why obvious features are broken.\n\nFrom a purely developer standpoin angular 2 with dart has been the best dev expirience I've seen on the front end with regards to tooling integration and framework completeness. "], [2, "One way to combat really insane profiling flame graphs is to use an alternate flamegraph representation (e.g. http://www.brendangregg.com/flamegraphs.html). this works for cpuprofile files from chrome: http://cmdcolin.github.io/flamegraph/web/ \n"], [2, "I've no experience with Angular2, Typescript or RxJS (beta), but I felt like this comment was silly:\n\n> the framework claims to be more stable than its dependency and the language it is built on.\n\nIt's certainly questionable, but presuming the right abstraction that is **exactly** what you want. A good framework will choose the best options at the time and protect you from those changing, providing you with the benefits.\n\nImo this is true of any \"new\" framework, though I'll often still choose the old one (strictly due to a cost/benefit/time to learn standpoint) since my goal is to deliver value, not keep up with the insane ecosystem of JS (I frankly don't even try)."], [2, "The problem with Angular 2 is that it is complex. People walks over hot coals in order to learn it. Simplicity is a feature. There will be less chance to be confused with a feature or mis-configure it.\n\nYou can pick up vue in a day or two. The same with Ractive.js. \n\nPeople keep repeating that certain js frameworks are better for LARGE teams. That is bull. Your success or failure working with a large team depends on other things than just simply a choice of a js framework."], [1, "I'm completly OK with TypeScript. I've even built a vanilla-TS application and it was a great experience.\n\nHowever I was really excited when Angular 2 was released but after two project now I believe it's exactly like most movie seqels: it sucks.\n\nI also don't understand how that tons of dependencies make my app mobile friendly if I have to make a new HTTP request per each. Sure bundle it, now I have a 2MB bundle of a single todo app, also good luck writing your configs.\n\nI managed to make a workflow with rollup and ngc in a gulp pipeline which produces a ~500kb bundle (it's still bigger then the whole backend and sass alltogether), but it takes at least 30s to compile on my PC. Guess at least I can remove browsersync from my dev dependencies ...\n\n*(And it's not Angular's fault at all, but don't forget about all the outdated tutorials of beta and RC versions)*"], [1, "The learning curve is steep, but once you get it, it just flows, not gonna lie, it took me a few weeks to learn, used this course which covers it all from A to Z: https://www.udemy.com/the-complete-guide-to-angular-2/learn/v4/overview. \n\nI like it a lot, we use it for big web projects and right now our agency is experimenting it on mobile with nativescript: https://www.nativescript.org\n\nAlso TS is a blessing. I don't regret learning any of those."], [1, "Having now done two large-scale production products with CLJS/Reagent/re-frame, I have to agree.\n\nWhen I switched back to our (now-upgraded) Angular 2 product... ew.  They actually made the state management problem worse!\n\nAngular 2 is like the JSF of the twenty teens.  And I mean that in a good and bad way."], [1, "This is really sad for me because I enjoyed ionic and angular for mobile app and web design.  I have been enjoying full mean stack development at work.  I thought it could only get better.  I read the Ionic Native/ionic 2 and I was getting really excited to see all the new framework designs,  powerful tools,  etc.  \n\nLike anyone else I was happy it looked cool but after reading this article I am sad. \n\nI'm sad that ionic also using angular 2 because ionic is cool and I don't want it using a toxic framework.  Maybe I'll look into it more... "], [1, "Christ. That flame graph is going to give me nightmares. \n\nI wish people who don't like dealing with HTML would find other things to do instead of trying to abstract the browser out of the browser.  Less and Sass work because the transformations are straightforward, predictable, effective and efficient. \n\nSounds like Angular 2 is 0 for 4. "], [-1, "I can implement in jQuery what others do in Angular2 in half the time.\n\n\"But you need those abstractions to scale\". Fuck no, I don't. It's super abstracted to begin with."], [-3, "Obviously, the author is wrong about the TypeScript stuff. He doesn't know about using strictNullChecks. Also, the any keyword is part of the language that doesn't not need to be used. It just gives you the option to use it."]], [[{"comment": "I agree with some of these, in particular the Observables. Both because of the issues with Rx being in beta as well as the fact that I don't see much of an improvement over Promises in return for the complexity introduced. I'd love to learn more about using Rx for actual data streams, and I understand how it's being used to abstract web app design into a stream of actions and whatnot, but I have yet to actually see a concrete way in which that translates to a better development experience.\n\nHowever, complaining about domain specific terminology for Angular 2 is silly considering that it's a complete MVC framework, *and* that many of the terms are used elsewhere.\n\n>Angular replaces the DOM with its own grotesque mutation of HTML, the browser history and location API with its own routing and location service, and XHR and websocket with its HTTP client.\n\nAgain, it seems like this dude just doesn't want a full fledged MVC framework. Or that somehow he's able to tolerate all the jargon and functionality with vue.js but not Angular 2.\n\nI'll agree that it's silly that the JavaScript documentation still hasn't been done, but honestly I think Angular 2 should just go full TypeScript anyway, since using JavaScript for it is such a pain.\n\nThe rest of his complaints mostly boil down to it being too complex and looking icky. \u00af\\\\\\_(\u30c4)_/\u00af Matter of opinion I guess. As for the speed, it seems to perform [in the middle of the pack](https://auth0.com/blog/more-benchmarks-virtual-dom-vs-angular-12-vs-mithril-js-vs-the-rest/). [Here's another benchmark](http://www.stefankrause.net/wp/?p=316). Vue, especially Vue 2.0, seems to have a slight performance edge, but it doesn't seem to be even remotely large enough to warrant disregarding Angular 2. I wish I could comment on development efficiency differences for large applications between the two, but I haven't used Vue much.", "id": "dapma5b"}, {"comment": "Author here. \n\n> However, complaining about domain specific terminology for Angular 2 is silly considering that it's a complete MVC framework, and that many of the terms are used elsewhere.\n\n> Again, it seems like this dude just doesn't want a full fledged MVC framework. Or that somehow he's able to tolerate all the jargon and functionality with vue.js but not Angular 2.\n\nI have used many MVC frameworks - Laravel and Django on the server side and Vue on the client side (Vue technically speaking isn't really MVC, but then again by that definition neither is Angular). \n\nTwo problems with with Angular's use of terminology: first, they have a penchant for misappropriating terms. Angular's models aren't actually models you see in most other MVC frameworks. Their pipes are not like Unix pipes at all, but more like filters you see in template systems like Twig, Django templates and Vue templates. Their services are... uh, models, actually? \n\nSecond, the above would be tolerable if their documentation is actually good. But it's not. Trying to understand the concepts Angular brings to the table is far harder than it should be. I cannot emphasize enough how bad Angular's docs are. \n\nThe point about performance is not just about the app's runtime performance, but also about its build performance. I suspect this may be down to build misconfiguration, but our finished Vue app builds itself faster than the skeleton \"Hello World\" Angular app does in development mode. ", "id": "daq1y53"}, {"comment": "haven't looked at the docs for Angular2 but I assume the advantage over promises is that you can unsubscribe/cancel an rx observable which will in turn abort any pending xhr requests.   I think promises will get that feature eventually  https://github.com/tc39/proposal-cancelable-promises", "id": "dapudit"}, {"comment": "observable.toPromise()\n\ndone.", "id": "dapy7ga"}, {"comment": "This is what I've been doing too...IMO that's probably a framework code smell.  :-/", "id": "daq69e8"}, {"comment": "The issue is that things like http.get return a single event. You're not going to get two or zero http response. So that should return a promise, not an observable.\n", "id": "daqed5l"}, {"comment": "I think conceptually you would make a stream out of an endpoint/resource instead of the actual http calls. Then the endpoint can emit events over time.", "id": "daqxm0i"}, {"comment": "literally if your api is accessible through websockets, but that's a really rare use-case", "id": "dar5sn1"}, {"comment": "No, that would be pretty inconvenient to use in the general case.", "id": "dar439y"}, {"comment": "I would think observable is more for streams even can be used to replace promise ", "id": "daqdyyo"}, {"comment": ">Again, it seems like this dude just doesn't want a full fledged MVC framework. \n\nYeah, and if and when he has a complex project, he'll develop his own home-brew complete MVC framework, and it will suck.", "id": "daqeucg"}, {"comment": ">  As for the speed, it seems to perform in the middle of the pack. Here's another benchmark. Vue, especially Vue 2.0, seems to have a slight performance edge\n\nThose results actually look pretty bad to me for ng2 with vue2 having a pretty large edge.\n\nOf course that probably doesn't matter for those cases where you don't actually need to work with thousands of rows ;)", "id": "dapwct6"}, {"comment": "also, MVC is starting to go out of favor (again)", "id": "dapviwf"}], [{"comment": "I've upgraded my application to Angular 2. \n\nAll I have to say is that I love it and won't be looking back anytime soon. ", "id": "dapk7kx"}, {"comment": "Yep I agree.  Coming from Angular it kind of is frustrating how much they changed that you have to learn, but if you judge it on its own it's a pretty good dev experience.", "id": "daqk9af"}, {"comment": "It is frustrating, but it's actually commendable that they re did the entire framework.\n\nThere were blaring architectural problems with angular.  It became unmanageable for the team, and was to cumbersome to fix.\n\nAs a result, they made something designed much much better.  \n\nMy project suffered from the same issues.  A lot of companies won't make the switch because it's hard to justify to the business that it's worth it.  These companies will suffer for that decision.\n\nBut the right move is to redo you're entire angular application, because the future benefit cannot be understated.  ", "id": "daqkscb"}, {"comment": "good for you. smart people don't do that, since there's absolutely no need for it.", "id": "dapvjam"}, {"comment": "Code itself must be scalable.\n\nA JavaScript application is impossible to scale.  At some point, your js application becomes so big that it will take you 10x as long to implement something new.  It's complexity will be impossible to manage.\n\nWith angular 2, I reduced my code base by half, while improving consistency, performance, and maintain ability.\n\nDebugging typescript is awesome.  The ide support is awesome.  I develop 5x as fast.\n\nIt was worth three times as much as it cost to do and I will only continue to benefit from this upgrade.\n\n", "id": "dapvsik"}, {"comment": ">  At some point, your js application becomes so big \n\nAnd that's where the problem lies. The JS application, in the fucking browser, should never ever become big. Is a dummy user interface. It displays data and allows the user to change that data. Has no brain whatsoever. Every single decision, every single logic point **has** to be on the server.\n\nJS was written for 100 lines scripts, not for millions of lines of \"frameworks\". Fucking shit. When will you these \"web developers\" get this into your thick skull? There is no big JS application. If it becomes big, you're doing it wrong.", "id": "dapwmek"}, {"comment": "Yeah, and the browser shouldn't have become an operating system.\n\nBut it did, so it makes sense to write a portable application.", "id": "dapx80p"}, {"comment": "It didn't. It may in the future, but at least as of today , December 2nd, 2016, it is certainly not an OS in and of itself. And it doesn't look to become one in the foreseeable future. ", "id": "daq7zlc"}, {"comment": "Well it might not be yet, but [maybe by the time 2035](https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript) rolls around you'll change your mind.", "id": "daqb41o"}, {"comment": "hahahaha. uh. ... no. no, i won't change my mind.", "id": "daqcqqt"}, {"comment": "I don't understand why you can't have JS applications? I mean there are downsides with client side processing and data usage and all that but it also can make user interfaces much more interactive by avoiding page loads and some round trips to the server and just overall gives you freedom to make a better UI. People use frameworks sometimes when a static site would be way easier but saying that the trade off should never be made or that everyone is doing it wrong just seems naive to me.", "id": "daq13jt"}, {"comment": "From an efficiency perspective, it makes sense to offload as much work onto the client.  Client machines are powerful now a days.  It's more efficient and cost effective to send templates that are rendered on the client, that then talks to an API.  \n\nYou also reduce the complexity of your application since there's no need to do server side rendering, which was the predominant model 10 years ago.  ", "id": "daq18qx"}, {"comment": "Of course you can. The guy you are replying to is incompetent.", "id": "daq9js1"}, {"comment": "You can have JS applications. You certainly **should** have JS applications nowadays. But it should not have logic built inside them, that's all. The Angular2 MVC framework has no place in a modern JS application. It is too bloated and it tries to do too much for a JS application. All that a JS application should do is display data and allow user to change said data. Everything else (button disabled if you dont have permissions) is just gravy, certainly not required for the application to function.\n\nActually, the only thing required for the application to function is the data that is has to display and send to the server for update. Everything else is on the server. ", "id": "daq4odk"}, {"comment": "If you introduce the latency of a server request every time your user enters a value in a field which requires validation you will likely have a bad experience.\n\n\n", "id": "daq9hjn"}, {"comment": "validation != frameworks\n\nIs just  a fucking stupid validation. validate it and go on your merry way. anything more than that, you're wrong.", "id": "daqa743"}, {"comment": "I like how you are not dogmatic about the issue. How many large line-of-business apps have you shipped to tens of thousands of paying customers the last year?", "id": "daqb76z"}, {"comment": "> I like how you are not dogmatic about the issue. How many large line-of-business apps have you shipped to tens of thousands of paying customers the last year?\n\nlast year? 1 app. in the last 5 years? 3 apps.  last 15 years? lost count, though i shouldn't have. probably around 10. last 25 years? no idea. i shipped a bunch though no clue how/if they ever got monetized. at least 3 i know they died a long and painful death in the hands of bureaucracy. \n\nquestions? are you judging my worth on how many lines of code i wrote????? I can write more lines of code per minute than you can dream in a decade. if that metric alone means anything to you ... hahaha, holy shit, i have some london bridges i'd like to sell to you. I'm dogmatic because i know wtf i'm talking about. You and your friends certainly have no fucking clue as you come to my conclusions sooner or later (later than needed for sure).", "id": "daqch31"}, {"comment": "Yes, JavaScript wasn't designed for that, but there's nothing wrong with the idea of a client-heavy application. Developers have tried creating other client-side web languages but none of them have stuck. Until then, the only way to be part of the modern web and scale is through frameworks.", "id": "daqa2ws"}, {"comment": "> but there's nothing wrong with the idea of a client-heavy application\n\nThere is everything wrong with that. Earlier, 10 years or so ago it was my experience that said everything is wrong with that. Today ... we have data. \n\nyepee. you're wrong and I'm right. what can be more awesome than that? And more, when you call me to come and fix your shitty app and I charge 500% because you're JS? Awesome. thank you. You get monkeys to write your app for you? sure ... I'll fix that for you. You pay through the nose though. It's a 200% bonus just because you're retarded (psst ... and I can ... )", "id": "daqc9t6"}, {"comment": "You sound high and / or manic. Bipolar?", "id": "daqmlxr"}, {"comment": "Can I see that data? I do this for a living so I'd love to see it.", "id": "daqrudr"}, {"comment": "being able to use a typed language versus javascipt makes it worth a million times, especially in the long term.", "id": "dapy1m4"}, {"comment": "It really is night and day.  It's essentially just a sane rules engine, which was js's biggest design flaw.  Python is the same way; failing at runtime is just a waist of time.", "id": "daq1asa"}, {"comment": "that is certainly correct. however it is a short-hand view of the problem. \n\n   Q: Why do you need a \"strong typed\" language? \n    A: Because you write complex applications in JS that run in the browser.\n    Q: Isn't then a strong typed language preferable?\n    A: It would be if writing complex JS applications in the browser would be something sane. Since writing complex JS applications in the browser is insane and only done by insane people, having a strongly typed language to write those applications in is useless.\n\n  Therefore TS by itself is useless, as demonstrated above.", "id": "daq52kv"}, {"comment": "Well, the. What do you think about web assembly?  \n\nIt's literally meant for heavy client side applications with native support over the web.  WebGl is another.  The web is moving to client side applications, removing any server side rendering.  It kind of destroys your point, because apparently the industry doesn't agree with you.\n\nTypescript will be able to compile to this eventually.  It's use cannot be understated.", "id": "daql1us"}, {"comment": "Web assembly is a different can of worms. Different usage altogether. Its main purpose is to run your c/c++ app in the browser. But you don't write it by hand. You write and maintain your nice c++ application/game/whatever and you compile it for the browser. Different shit. And even then, the performance is about half of the native app.", "id": "daqszpe"}, {"comment": "> Its main purpose is to run your c/c++ app in the browser.\n\nYou literally just said you shouldn't be running applications on the client.  This is the use case for webassembly.  \n\n>You write and maintain your nice c++ \n\nIf i remember correctly, it has an LLVM compiler, which means it can take multiple languages.  ", "id": "daqzqqj"}, {"comment": "> You literally just said you shouldn't be running applications on the client. This is the use case for webassembly. \n\nYou're wrong. I said you should keep your applications small, to be easy to maintain. Since it's JS we're talking here, maintaining that shit is a nightmare. Keeping it small avoids that nightmare. With webassembly you don't write a line of JS, you generate it. You don't maintain generated code.\n\n> If i remember correctly, it has an LLVM compiler, which means it can take multiple languages. \n\nYes, emscripten is an LLVM backend, you can have your frontend be anything, however clang is probably the most popular frontend for LLVM.", "id": "dar159i"}], [{"comment": "It's not terrible. But i'd argue its complexity VS benefits is not a good ratio, especially for those who update from v1 which just works. I also hate the fact that it's trying to be everything and anything, that I have to learn Rx.js on top of that ... \n\nObviously v1 has problems but they are not irredeemable and they didn't need a full rewrite to be solved.\n\nSome people want JEE in the client, good for them. Others want a slightly better backbone that is easy to use, because most apps don't need client side JEE. To the latter Angular v1, Vue.js or React is a better alternative.", "id": "dapoemt"}], [{"comment": "I like it. But it definitely took me more than two weeks to learn. It's also definitely a framework and definitely \"something to learn\". It's new, and it's more heavyweight than most other front end frameworks I've used.\n\nI'm using it for a moderate-sized application right now and it's exactly what I need. The Typescript is almost nicer than the framework itself but that the Docs and the community all speak typescript is central to its ease of use.", "id": "daptqzp"}, {"comment": "I love TypeScript. I have been updating a lot of JavaScript to TypeScript. But... I feel like JQuery, BootStrap and TypeScript get the job done without the overhead and complexity. ", "id": "dapvwl7"}, {"comment": "But then you start adding libraries right? Or do you implement all stuff which is required in big applications yourself from scratch?\n\nIm thinking aboyt routing, accessability helpers, possibly data binding, good input support for different device types, maybe internationllization if jquerys version is not enough, unit test framework, unit test runner, bundling and minification, treeshaking etc etc.", "id": "daq9iwn"}, {"comment": "Usually when I'm doing frontend work on the job, I have a work item that I've budgeted a day or two toward. When it's done, there will be weeks before the next time I need to do frontend work, and then I'll be in the same situation with that next work item.\n\n\"More than two weeks to learn\" is a nonstarter. I don't want to spend that much time to learn a UI framework for the browser, and my manager doesn't want me to either. And by the time I come back to it, I'll have forgotten half of what I learned today.\n\nI'll stick with jQuery.", "id": "daq6uam"}, {"comment": "Sounds like a big framework might not fit your use case.\n\nYour manager, though, is locked into short-term thinking. Find a job where they allow you some time every day to develop your skills. Your present job seems to operate on a \"use 'em up, throw 'em out, get some new ones\" staffing paradigm.", "id": "daqeq5b"}, {"comment": "> Sounds like a big framework might not fit your use case.\n\nIf you pointed me at a Qt C++ application and told me to add a specific feature, that would probably be faster and easier for me to handle than an Angular2 application of similar size -- and I'm already proficient with javascript.\n\nI used ExtJS. It wasn't hard to learn. I could learn it piecemeal. It does less than Angular2, granted, but the lack didn't hurt us.\n\n> Your manager, though, is locked into short-term thinking.\n\nI can ask to spend more than two weeks learning a framework so I can make a change that should only take a day *now*, and then do the same thing once per quarter going forward. That should pay off in...oh...three or four years. Assuming I don't forget anything.\n\n> Your present job seems to operate on a \"use 'em up, throw 'em out, get some new ones\" staffing paradigm.\n\nWell, no, not really. They messed up on the \"get some new ones\" step. I started working there in April and there were a hundred people working there. I quit a few weeks ago and there were maybe forty.\n\nRegardless, that's not relevant to this problem.", "id": "daqlqyu"}], [{"comment": "Im in no way an angular 2 expert, but 2 weeks ago i wanted to give it a try, proceeded to angular 2 documentation to build the \"HelloWorld\", im coming from angular 1, imagine my surprise, hellow world took over 8 files to be completed, thats fkin bull.\n\nEdit: sintax", "id": "dapnd36"}, {"comment": "What exactly were in those 8 files? I've not yet dove into 2.x yet so I'm honestly curious.\n\nI do, however, use Angular 1.x a lot and I feel the point of the framework is that everything is modular so you may include as few or many files as you want.\n\nWant to define your config, components, services, filters, etc in a single file? You can technically do that...but it's going to be much harder to maintain as the size of your project grows.\n\nBest practices, especially opinionated guides like John Papa's define a structure for files since you'll tend to end up with multiple of each in large projects (specifically components, services, directives, and to some degree filters).\n\nThis modular structure is a godsend for large projects, which frameworks like this are intended, but can feel like a lot of boilerplate for small projects. Just saying, you may want to take that into account.", "id": "dapo2hj"}, {"comment": "Ng1 and ng2 are very different, especially tooling which didn't exist years ago. Also compilation requirement wasn't needed in ng1. Typescript is useful. Ng2 as a framework is very complete. For smaller projects, how to reduce dependences, I have not yet figured out. Not sure tree shaking is enough. The change is significant. Whether it is worth to use it really depends ", "id": "daqe5f6"}, {"comment": "I've always tended to be one to apply the \"Hello World\" test to new things as a test for complexity and what not until recently.\n\nI think what we need to remember here is that Angular 2 (and 1) aren't really meant to be used for things as simple as Hello World. You can do that in one line of VanillaJS, PHP, etc etc. Angular is meant to be used as a scalable framework for large projects (think the size of Facebook, or Reddit, or NYT, etc). And for large projects, having things broken up into multiple different files, while increasing the learning curve, tends to be more maintainable in the long run, and that's what you want for large projects - maintainability. ", "id": "daq0t27"}, {"comment": "angular is not made to just create hello worlds, it's for big and complex projects where code must be easily maintainable and scalable.", "id": "daqh0qj"}, {"comment": "You could write it all in one file if you wanted.  They use more files to get you used to the structure required to keep a large app manageable when you aren't writing hello world.", "id": "daqkdf0"}], [{"comment": "> Angular 2 stable is built on experimental language features (TypeScript decorators, based on a Stage 1 TC39 draft proposal) and beta libraries (Rx.js 5.0).\n\nThat's a good thing, since it's probably first time in javascript history someone is maintaining proper versioning and release process, so Rx beta is probably more stable than rightpad v30.21.11\n\nIt's not like there are many non-shit libs to pick from.", "id": "dapo5w3"}], [{"comment": "> while there is only one JVM, there are half a dozen JavaScript engines, \n\n?! There's more than one JVM, and for JS there's WebKit, Gecko and... Chakra?", "id": "daqaigr"}, {"comment": "Webkit and Gecko aren't JS engines they're browser engines. I think you mean V8, Nitro, SpiderMonkey, and Chakra.\n\n[Wikipedia has a list of all active projects](https://en.wikipedia.org/wiki/JavaScript_engine#Active_projects)", "id": "daqdljw"}, {"comment": "Did you forget about V8?", "id": "daqcen3"}, {"comment": "No, but i thought this is not powering currently going browsers?", "id": "daqcs31"}, {"comment": "Chrome is V8..", "id": "daqd546"}, {"comment": "And Node, though that's besides the point in a discussion on front-end frameworks.", "id": "daqf9np"}], [{"comment": "why use ang over react?", "id": "dapvr3z"}, {"comment": "That's an apples to oranges comparison.  Angular v1 (and presumably 2?) is a full framework. React is effectively just a foundation library for constructing view components. And when used the way FB intended, is not designed with MVC in mind at all.  Personally, I *love* React.  I chose it over an Angular + Node stack for a work project specifically because it's not a full stack. React for a frontend, a Python microframework on the backend (I chose CherryPy, but since then Flask basically \"won\" that space). ", "id": "daq5i8b"}, {"comment": "Because it's an \"over reaction\". ;)", "id": "daqgp7r"}, {"comment": "http://i.imgur.com/OLJKfiN.jpg", "id": "daqgp93"}], [{"comment": "Oh he's only used it for 2 weeks. I'm dying to hear what this person has to say and what their opinion is of the javascript framework ecosystem.", "id": "daq3oiq"}, {"comment": "Well 2 weeks is long enough to see at least 2 fads in the JS world.", "id": "daqahxb"}], [{"comment": "A lot of these points apply some extent to other frameworks as well, but the reason I dislike Angular 2 is the documentation. Even the TypeScript documentation makes it difficult to do some common things. For example, last time I tried Angular 2 (shortly after it went stable), I never was able to figure out how to retrieve a route parameter for use in a component. This combined with the fact that many other simple things took up to a half hour to figure out made me drop Angular 2 like a brick.", "id": "dapq40g"}], [{"comment": "Angular 2 is great representative of [\"second-system effect\"](https://en.wikipedia.org/wiki/Second-system_effect). But it's definitely not terrible. Just, they made it much different from V1 and that upset lots of people.", "id": "daqdjhw"}], [{"comment": "Have been using ng2 at work for a couple of months now - it has it's problems but it's a good library. Especially nice in an enterprise setting where most devs are familiar with WPF or similar OO methodologies.\n\nThe worst part about Angular 2 is the build/package management/tooling - webpack/karma/npm are just immature crap barely cobbled together from even worse crap and only barely runs in the best case scenario, and worst case is you spend days figuring out why obvious features are broken.\n\nFrom a purely developer standpoin angular 2 with dart has been the best dev expirience I've seen on the front end with regards to tooling integration and framework completeness. ", "id": "daqfgxm"}], [{"comment": "One way to combat really insane profiling flame graphs is to use an alternate flamegraph representation (e.g. http://www.brendangregg.com/flamegraphs.html). this works for cpuprofile files from chrome: http://cmdcolin.github.io/flamegraph/web/ \n", "id": "dapoekv"}], [{"comment": "I've no experience with Angular2, Typescript or RxJS (beta), but I felt like this comment was silly:\n\n> the framework claims to be more stable than its dependency and the language it is built on.\n\nIt's certainly questionable, but presuming the right abstraction that is **exactly** what you want. A good framework will choose the best options at the time and protect you from those changing, providing you with the benefits.\n\nImo this is true of any \"new\" framework, though I'll often still choose the old one (strictly due to a cost/benefit/time to learn standpoint) since my goal is to deliver value, not keep up with the insane ecosystem of JS (I frankly don't even try).", "id": "daq7tjd"}], [{"comment": "The problem with Angular 2 is that it is complex. People walks over hot coals in order to learn it. Simplicity is a feature. There will be less chance to be confused with a feature or mis-configure it.\n\nYou can pick up vue in a day or two. The same with Ractive.js. \n\nPeople keep repeating that certain js frameworks are better for LARGE teams. That is bull. Your success or failure working with a large team depends on other things than just simply a choice of a js framework.", "id": "daqaelz"}], [{"comment": "I'm completly OK with TypeScript. I've even built a vanilla-TS application and it was a great experience.\n\nHowever I was really excited when Angular 2 was released but after two project now I believe it's exactly like most movie seqels: it sucks.\n\nI also don't understand how that tons of dependencies make my app mobile friendly if I have to make a new HTTP request per each. Sure bundle it, now I have a 2MB bundle of a single todo app, also good luck writing your configs.\n\nI managed to make a workflow with rollup and ngc in a gulp pipeline which produces a ~500kb bundle (it's still bigger then the whole backend and sass alltogether), but it takes at least 30s to compile on my PC. Guess at least I can remove browsersync from my dev dependencies ...\n\n*(And it's not Angular's fault at all, but don't forget about all the outdated tutorials of beta and RC versions)*", "id": "daqbzte"}], [{"comment": "The learning curve is steep, but once you get it, it just flows, not gonna lie, it took me a few weeks to learn, used this course which covers it all from A to Z: https://www.udemy.com/the-complete-guide-to-angular-2/learn/v4/overview. \n\nI like it a lot, we use it for big web projects and right now our agency is experimenting it on mobile with nativescript: https://www.nativescript.org\n\nAlso TS is a blessing. I don't regret learning any of those.", "id": "daqgv6q"}, {"comment": "I love TypeScript. I am the architect at work. So, we have one main application that is at least 12 years old. It .net 4.6. New stuff uses webApi controllers, old is webforms. So devs already need to know server side code, web forms, mvc, JQuery, KendoUI, BootStrap TypeScript. Does it really makes sense to try and pile on another framework. In my mind, no. But if I were making a brand new site, I might use it.", "id": "daqjrhc"}], [{"comment": "Having now done two large-scale production products with CLJS/Reagent/re-frame, I have to agree.\n\nWhen I switched back to our (now-upgraded) Angular 2 product... ew.  They actually made the state management problem worse!\n\nAngular 2 is like the JSF of the twenty teens.  And I mean that in a good and bad way.", "id": "dara9p5"}], [{"comment": "This is really sad for me because I enjoyed ionic and angular for mobile app and web design.  I have been enjoying full mean stack development at work.  I thought it could only get better.  I read the Ionic Native/ionic 2 and I was getting really excited to see all the new framework designs,  powerful tools,  etc.  \n\nLike anyone else I was happy it looked cool but after reading this article I am sad. \n\nI'm sad that ionic also using angular 2 because ionic is cool and I don't want it using a toxic framework.  Maybe I'll look into it more... ", "id": "darm0vb"}], [{"comment": "Christ. That flame graph is going to give me nightmares. \n\nI wish people who don't like dealing with HTML would find other things to do instead of trying to abstract the browser out of the browser.  Less and Sass work because the transformations are straightforward, predictable, effective and efficient. \n\nSounds like Angular 2 is 0 for 4. ", "id": "darm42z"}], [{"comment": "I can implement in jQuery what others do in Angular2 in half the time.\n\n\"But you need those abstractions to scale\". Fuck no, I don't. It's super abstracted to begin with.", "id": "dapv7nr"}, {"comment": "We use JQuery, TypeScript, Twitter BootStrap and KendoUI. Our core application is 12 years old. The server side code is up to .net 4.6. But, considering all the legacy code and that developers need to know ASP.Net MVC and Web forms (new stuff uses webApi controllers) old stuff is webforms. It is too much to ask to learn Angular as well. Especially, considering we could never re-write the entire code base.", "id": "dapvsrc"}, {"comment": "Just because you don't have a business case to rewrite a project does not mean it wouldn't benefit from it. I would be careful with that attitude, if you stagnate in this industry you will be left behind when your project is end of life.", "id": "daq4djg"}, {"comment": "Meh, not really.  Some developers have better things to do than rewrite their entire web frontend every 3 months in pursuit of the new hotness.  I bet you use at least a web page a day that's cobbled together perl scripts and definitely some LAMP based stuff.  Strong fundamentals, learning ability and people skills go a lot further towards making you employable as a developer in general than being able to keep up with the masturbatory mess that modern web dev has become.", "id": "daq63hf"}, {"comment": "Yeah, two devs on my team. Our Asana tasks are always being updated. Sure, we'll just take two years off to re-write our application and by the time were done, some new hotness will be out and we'll have to start all over. The entire company and customers use our application to run the business... You have to implement new technologies with great care, every time you pile on a framework the complexity grows.", "id": "daqk5cm"}, {"comment": "I have a 12 year old application. We have kept it up to date. I just said, it uses JQuery, TypeScript etc... There are about 250 .aspx files. 50 + controllers classes. You can't just rewrite it. There are two developers. Also, the business has work for us to in the meantime. New features, new integration etc... I have been coding for 20 years. I'm at the top of the pay scale and I know how keep learning. Web front end technologies are constantly changing...", "id": "daqjzou"}, {"comment": "No you can't. Angular enables large teams to collaborate on complex SPAs in a maintainable fashion. \n\n\nYou don't have to use Angular for everything but once you understand it's power you will quickly reject JQuery even for small projects you previously would have used it on.\n", "id": "daq4b0v"}, {"comment": "How long does it take to understand its power, roughly speaking?", "id": "daq6xk3"}, {"comment": ">How long does it take to understand its power, roughly speaking?  \n\nAbout the time it takes for them to announce a new (non-backwards compatible) version. ", "id": "daq7u1a"}, {"comment": "This... I'm sure the devs of Angular2 are already thinking about trashing it for Angular3", "id": "daqqw54"}, {"comment": ">  Angular enables large teams to collaborate on complex SPAs in a maintainable fashion.\n\nlook who found a silver bullet here", "id": "daqab7x"}, {"comment": "Where \"silver bullet\" means \"actually using the same development practices we've employed for three decades\"?", "id": "daql39p"}, {"comment": "I worked on a team that build a reasonably large SPA (~20k lines) on a team of 10 using nothing but jquery, bootstrap, and a front end template system. IMO the code was perfectly manageable and it was easy getting new devs up to speed since they didn't need to learn about some massive framework.", "id": "daq8zrq"}], [{"comment": "Obviously, the author is wrong about the TypeScript stuff. He doesn't know about using strictNullChecks. Also, the any keyword is part of the language that doesn't not need to be used. It just gives you the option to use it.", "id": "dapcdd2"}, {"comment": "It was mentioned in the comments. Unfortunately, strictNullChecks can't be used because Angular2 does unsafe null-related things internally, at least, according to commenters.", "id": "dapedoz"}, {"comment": "Doesn't seem obvious to me.  Angular 2 isn't strictNullCheck compatible. Also we don't know the time frame during which he used Typescript maybe it was before strictNullChecks was added, it is a fairly recent addition.  \n\nBut yeah complaining about any seems stupid.", "id": "dapi0qr"}, {"comment": "You are right. It is pretty new.", "id": "dapjfkn"}, {"comment": "does that negate the rest of his points?.", "id": "dape4f6"}, {"comment": "Nope.", "id": "dapezog"}, {"comment": "And decorators are stable TypeScript feature even if they are not yet stable in JavaScript. The latter doesn't matter since you are transpiling to downlevel JS anyway so even if the feature is dropped from JS it can still be transpiled the same way.", "id": "dapuupa"}, {"comment": "They are not https://www.typescriptlang.org/docs/handbook/decorators.html\n\n> NOTE\u2003 Decorators are an experimental feature that may change in future releases.", "id": "daq0zg2"}, {"comment": "Well... I stand corrected", "id": "daqadyv"}]]], "5fsdn8": ["I wrote an end-to-end encrypted chat app using Elixir/Phoenix and Vue.js", "2016-12-01 00:39:09", 6, "https://1op.eu", [[5, "I'll assume this is just for fun rather than real use (otherwise, imagine a stern lecture about never rolling your own crypto).\n\nThe basic idea of distributing RSA keys to each party that wants to communicate is sound, but it's not really clear what your principle threat was.\n\nIgnoring the key distribution for now, I'll try to focus on your main goal rather than all the other weird edge-cases that go into production end-to-end encryption. The main benefit of the actual communication protocol you've designed over simply AESing everything seems to be that compromising the password won't allow reading old messages. This is related to the [forward secrecy](https://en.wikipedia.org/wiki/Forward_secrecy) that other end-to-end systems guarantee, but weaker. Compromising a client (with its RSA key) would still allow you to decrypt all past messages sent to that client (say, if you'd been recording them).\n\nOn the distribution side, you seem to have been trying to solve an authentication problem (should Eve be allowed to join this room?) rather than any MitM attack. Against an eavesdropper, the security seems to rest on being unable to derive the password from its SHA; that might be reasonable for strong passwords, but not weak ones.\n\nIt would be reasonable for either the clients or the server to do the authentication, but I'd pick one. And either look up a standard protocol or think about what information an eavesdropper has available for brute-force."], [3, "I'd like to share an app i wrote recently using Phoenix and Vue.js. It's an encrypted end-to-end quick-to-use websocket-chat app, which can be used to share secret messages between users. It uses AES to encrypt JS-generated RSA-2048 public keys shared between users which will be used to encrypt messages for each user separately. I'd love to hear some feedback from more experienced programmers than I am. Please don't bite. :)\n\ntechnical overview here: http://gladecki.pl/2016/11/23/1op/"]], [[{"comment": "I'll assume this is just for fun rather than real use (otherwise, imagine a stern lecture about never rolling your own crypto).\n\nThe basic idea of distributing RSA keys to each party that wants to communicate is sound, but it's not really clear what your principle threat was.\n\nIgnoring the key distribution for now, I'll try to focus on your main goal rather than all the other weird edge-cases that go into production end-to-end encryption. The main benefit of the actual communication protocol you've designed over simply AESing everything seems to be that compromising the password won't allow reading old messages. This is related to the [forward secrecy](https://en.wikipedia.org/wiki/Forward_secrecy) that other end-to-end systems guarantee, but weaker. Compromising a client (with its RSA key) would still allow you to decrypt all past messages sent to that client (say, if you'd been recording them).\n\nOn the distribution side, you seem to have been trying to solve an authentication problem (should Eve be allowed to join this room?) rather than any MitM attack. Against an eavesdropper, the security seems to rest on being unable to derive the password from its SHA; that might be reasonable for strong passwords, but not weak ones.\n\nIt would be reasonable for either the clients or the server to do the authentication, but I'd pick one. And either look up a standard protocol or think about what information an eavesdropper has available for brute-force.", "id": "damzc96"}, {"comment": "Thank you very much for your response! I really appreciate that. Allow me to retort. :)\n\n> Compromising a client (with its RSA key) would still allow you to decrypt all past messages sent to that client (say, if you'd been recording them)\n\nThis is exactly what I've been trying to avoid! Generated private key vanish with a page closure or a refresh and I believe that decrypting messages would be extremely hard when dealing with RSA-2048 used here. Even with a cracked password and acquired RSA public key.\n\nThe second problem I've been trying to avoid is a middleman interference in public key transfer. I think that users won't be reading a bunch of random characters and comparing them with other chatroom members. That's why I used AES to store RSA public keys on the server-side. This way users can be sure that members are indeed legitimate members and they are sending messages encrypted with their keys (or password has been cracked BEFORE establishing a connection). When SHA-512 gets cracked afterwards every member will notice an additional one.\n\n> This is related to the forward secrecy that other end-to-end systems guarantee, but weaker. \n\nwhy weaker? :<\n\ninb4 i did not use Double Ratchet Algorithm as I don't understand it yet. :(", "id": "danj42w"}], [{"comment": "I'd like to share an app i wrote recently using Phoenix and Vue.js. It's an encrypted end-to-end quick-to-use websocket-chat app, which can be used to share secret messages between users. It uses AES to encrypt JS-generated RSA-2048 public keys shared between users which will be used to encrypt messages for each user separately. I'd love to hear some feedback from more experienced programmers than I am. Please don't bite. :)\n\ntechnical overview here: http://gladecki.pl/2016/11/23/1op/", "id": "damnhe3"}]]], "5fsmhv": ["A book about repetitive structures in Social Networks", "2016-12-01 01:19:03", 1, "http://weall.com/book/chapter?name=Social%20Networking%20Patterns%20Launching%20Soon", [], []], "5g9rco": ["Gransk - Document processing for investigations", "2016-12-03 17:24:22", 42, "https://gransk.com/", [[3, "remind me not to contact any people on shady.org, they seem untrustwothy"]], [[{"comment": "remind me not to contact any people on shady.org, they seem untrustwothy", "id": "dards8a"}]]], "5fzhib": ["Muut IO \u2014 The community development platform", "2016-12-02 01:01:11", 0, "https://muut.io/", [[2, "Not programming."], [1, "I'd totally use something like this if it were open source and not SaaS."]], [[{"comment": "Not programming.", "id": "daoh5ty"}], [{"comment": "I'd totally use something like this if it were open source and not SaaS.", "id": "daopnj1"}]]], "5gbn6y": ["This AI Boom will also burst", "2016-12-03 23:48:18", 0, "http://www.overcomingbias.com/2016/12/this-ai-boom-will-also-bust.html", [[9, "Bay area is full of \"deep learning\" startups full of PhDs that only know python and don't understand software development. It's not sustainable. "], [1, "No. Areas where these methods are being applied are in security, recommendation engines, image processing, robotics, driving etc. Business are not trying to apply deep learning to small business data sets. "]], [[{"comment": "Bay area is full of \"deep learning\" startups full of PhDs that only know python and don't understand software development. It's not sustainable. ", "id": "dar0o64"}], [{"comment": "No. Areas where these methods are being applied are in security, recommendation engines, image processing, robotics, driving etc. Business are not trying to apply deep learning to small business data sets. ", "id": "darkke2"}, {"comment": "Yes, that's what the writer tried to express with the big pipe / small pipe analogy.", "id": "darq3da"}]]], "5gakph": ["The Practice of Code Review", "2016-12-03 20:24:40", 715, "https://zerohour-productions.net/?q=node/242", [[242, "I always stress to our junior developers that code review isn't just to find bugs someone else made. It's also the time to learn the incremental changes in a large code base and ask questions.\n\nIt's your chance to understand another component or area and expand your expertise as well. \n\nThe more you understand other components the better so take the time to learn and ask questions while the developer is available. "], [233, "I'm currently unemployed. Last week I had an interview with a new startup. One of the questions was, \"Do you do code review?\"  \n\nI replied, \"Well unfortunately I've never worked at a company that uses code reviews. I think code reviews are a good idea though and I would like to do them if I got the job here.\"  \nHe repeated the question. I said, \"Well at the moment I'm just working on a couple of personal projects by myself, so I haven't been able to-\"  \n\n\"Yeah, but, do you do code review?\"  \n\n\"...Yes, I do code review.\""], [97, ">Do you use nondescript variable names like a, b, c?\n\nDo people really do this? I would lose my shit."], [36, "I highly recommend using a code review tool for a team. In person reviews suck, and usually are counterproductive. We use crucible, but there are others out there just as good or better. It lets us defer reviews until we have time, have comment threads, refer to issues or documentation inline, provide code examples, etc. It integrates with our version control so we get diffs instead of large blocks of code. Without crucible I did about 3 serious reviews a year. With crucible I've done about 150 in the last year, either having my code reviewed or reviewing others' code. It's improved our code quality dramatically."], [12, "Paired programming and TDD....may sound awkward at first but the number of times you end up going over something, it's like having multiple code reviews a day.\n\nHave seen devs grow faster here than anywhere else in this environment.  \n\nConstant training, constant communication, very clear transparency of where your skills as well as others abilities are at.  The code ends up speaking for itself."], [6, "I wanted to add my two-cents to all of the other posts. I'm still trying to grow in this area, so forgive anything that I might've said that comes across as naive. "], [6, "I think newbie programmers like code reviews more than experienced developers. I worked for a company once that did code mandatory reviews. Some of the newbies would post hideously broken code reviews in hopes that a more experienced developer would do the work for them. Usually this works, so the newbie walks away loving them.\n\nThe more experienced developer will hate them because rarely any useful feedback comes from them. There was a co-worker I had one time who we'll call the \"float nazi\", who had this belief that floats are evil and decimals are the saviors of all that is holy. Any time he found a float in my code he's go off on a tirade about how any instance of float in the code is a bug and the only way to fix it is to change it to a decimal. No matter how politely I try to explain that in that particular situation the shortcomings of floats don't come into play, it doesn't matter. \"Float nazi\" held a higher ranking than I did at that company, so I was forced to always use Decimal. I should be free to write my code however I want, since I'm ultimately responsible for that code's performance. Code reviews in a way forces design by committee by allowing other people to force my code to be a different than the way I wrote it.\n\nIf this post doesn't get to -50 by the time I wake up I will be disappointed."], [4, "When I join a new team, I want to get on a code review as soon as possible.\n\nSeeing how management handles a code review tells you everything you want to know about being on that team.\n\nWhat? Finding bugs? Yeah, sometimes it helps with that... make me better? Um.. occasionally."], [1, "Anyone know where to buy an ebook copy of the book recommended at Coding Horror (Peer Reviews in Software: A Practical Guide)?\n\nIn the author's website there's a sample of chapter 3 in PDF so I'm assuming it must be available somewhere... I just can't find it."], [1, "This is from clean code by Robert Martin?  Good book. I didn't agree with everything he says,  like he doesn't like switch statements.\nBut lots of it is good sense.\n\nShould also check out dependency injection by Mark Seemenn. \n"], [1, "... morning, do you do code review?\n\n true\n\nHIRED!!"], [1, "We do code review before all pull requests are merged in my office and I have to say I love the practice because it forces you to look at your code through a more objective lens, fixing things you didn't think to change before.\n\nI think it also helps you improve as a developer overall because you get to take direct feedback on your code and then hopefully next time you do a pull request, there are less issues with your code during code review.\n\nIn my experience, code review is more a time to clean up and polish the code than it is to correct and change course. Maybe we suggest you write a few extra tests to account for a case that wasn't considered initially, or maybe there's some duplication that can get cleaned up...it's never a judgmental process as long as whoever is being reviewed is open to the suggestions and changes."], [1, "Code review is the most frustrating thing you can do, yet the most important one as well. Even a single pass of review will catch a lot of bugs and shortcomings. Not doing a first pass of review is neglectance."], [2, "Movie reviewers have opinions. It's hard to please them all, especially when you're given two weeks to produce something.\n\nIt's okay to do early, pre-production _reivews_ often with your teammates. But, each of you don't have to believe your sense of aesthetics is canon. And no, not all movies have to be oscar worthy. There are different genres and styles. And yes, genre mixing and crashing is totally fine in a single movie.\n"], [-1, "My first codd reviews let me know very bluntly where my weaknesses were and with enkugh tutilage from my reviewers, also about how to fix them.\n\nNitpicking however haha I do drive some of my team nuts when im nitpicking their contributions to my projects, but i do it with the best of intentions to help improve the up front quality of code written before submissio, and in some cases suggest or introduce altnernative approaches to an implementation. In my expectation I fully expect them to return the favour, and they do. "]], [[{"comment": "I always stress to our junior developers that code review isn't just to find bugs someone else made. It's also the time to learn the incremental changes in a large code base and ask questions.\n\nIt's your chance to understand another component or area and expand your expertise as well. \n\nThe more you understand other components the better so take the time to learn and ask questions while the developer is available. ", "id": "daqvrzx"}, {"comment": "I really want our junior developers doing code review for just this reason, but management is convinced it's a waste of time and you need ~3 years of experience before you're on the code review list.  Any tips for changing their minds?", "id": "daqxgb0"}, {"comment": "Junior people can bring in a fresh viewpoint. Without as much context of the system in their minds, they will ask simpler questions that more experienced devs don't think about anymore because they might have just always been doing it that way.", "id": "daqyi69"}, {"comment": "Basically it's a way of preventing [what Dan Luu relates Julia Evans as describing](https://danluu.com/wat/): \n\n> new person joins\n> \n> new person: WTF WTF WTF WTF WTF\n> \n> old hands: yeah we know we\u2019re concerned about it\n> \n> new person: WTF WTF wTF wtf wtf w\u2026\n> \n> new person gets used to it\n> \n> new person #2 joins\n> \n> new person #2: WTF WTF WTF WTF\n> \n> new person: yeah we know. we\u2019re concerned about it.", "id": "darjobn"}, {"comment": "In my opinion having someone junior look at a change, ask questions, and even participate in an in-person review is good.  Having that junior person actually approve or sign off on the change is probably risky and where you want a senior person involved as well.", "id": "daqxwm4"}, {"comment": "You could have your pass criterion be something like \"two sign-offs, at least one senior\".", "id": "dar72lq"}, {"comment": "Sure, absolutely.", "id": "dara5q4"}, {"comment": "In practice, the policy should be \"code must be signed off by someone sufficiently expert in that area to understand it, other than the author of the checkin.\"  A junior engineer who is good and is an expert in a small area is going to be a better quality gate than a Senior engineer from an unrelated project.\n\nHaving actual checkin blockers that enforce more than just \"X number of approvers from Y team\" is usually not worth it, though, unless you're dealing with official compliance rules.  Or if code review is your only halfway acceptable quality gate and you lack the ability to test it properly after checkin.", "id": "darnhuc"}, {"comment": "If your team is \"not small\", you should always have two or more people reviewing code.  A nice idea is to have a fairly junior engineer start the review, and then a senior engineer come in and review both the code, and the review.", "id": "darcfl0"}, {"comment": "That's a bizarre reason, of all developers' time a juniors is the least valuable, furthermore a junior has seen very little production level code, so they are in extreme need of carefully reviewing the code of more senior people.", "id": "dar33sl"}, {"comment": "plus as a junior developer, we are more eager to show are merits/worth", "id": "darlu2d"}, {"comment": "Yes, you have to make it part of the process. Developers own quality, but if you try and tack code reviews on as an afterthought, you'll constantly never have enough time to do it, or will be rushing through and \"green-lighting\" code.\n\nWhen I first started working where I currently work, code reviews didn't have \"teeth\" to them.  You committed code, the code was integrated into trunk (SVN) and you made a code review that *might* get reviewed... eventually.  That's no good.  What we found was everyone was always spending time on their own stuff.\n\nBut, that makes sense in a way.  Why should you be able to understand someone else's code?  That shit takes a lot of time, especially when you aren't the one that wrote it.\n\nSo what did we do?  After I was made team-lead, I made a couple of changes.  First off, we moved to Git.  Second, we locked down master, gated on code reviews.  If your code isn't approved by at least two other people, it doesn't get integrated.  Period.  **NOW** code reviews have *teeth*.\n\nBut how do you get around the problem of finding the time?  Simple.  You *have* to put it on the calendar.  If you don't *make* the time, then it will get filled with other work.  So every Tuesday and Thursday, we have two hours set aside for group code reviews.  And during these reviews, **the person that wrote the code** walks the group through their changes.  This way, **everyone** is part of the process.  Even \"newbie\" developers.\n\nSo, everyone has a chance to see the reviews before the meeting (if they have time) but one way or another they *will* learn about what is going on.  We normally don't use up anywhere *near* the two hours, which is fine.  If it only takes 30 minutes, well you just got an hour and a half of coding time back.  Hooray.\n\nReview is an essential part of the development process.  It is in the best interest of the business that all devs on a team understand how the various parts work, otherwise you start developing silos of knowledge and put the business at risk of \"hit-by-a-bus\" scenarios.", "id": "dar9vh8"}, {"comment": "You only review the code during those two slots? How do you keep the whole team focused on the job? Personally I wouldn't be able to focus on details when in a meeting room filled with people. For me a code review is often similar to coding itself. I often end up openning the branch in my IDE, stepping through the changes, running some tests/fiddling with code to see if it can be improved.", "id": "darfzhy"}, {"comment": "> You only review the code during those two slots?\n\nYou may have missed this:\n\n> everyone has a chance to see the reviews before the meeting\n", "id": "darjgkw"}, {"comment": "Yes, I read this. But does this mean the developer is expected to make changes before this meeting? Can you, as a reviewer, leave comments before? Is it expected from everyone in your team to review the code before? I'm genuinely curious how does it work in practice. ", "id": "darl6bo"}, {"comment": "How it works in practice: \n\n* Developer creates pull request on Monday.  All developers on the team are auto-added to the PR (senior, junior, doesn't matter. if you're on the team, you're on the PR).\n* Team have opportunity to take a look at PR before next CR meeting.  Pull request has comments section, where you can add comments to the code by line, class, or by PR.\n* If one or two developers don't get a chance to look at the code (TL;DCR) then no worries, there are other developers on the team that did.\n* If an issue is discovered before Tuesday, and the issue isn't fixed by the CR, no worries.  There will be another review on Thursday.\n* **ALL** devs must attend code review meeting.\n* CR meeting is run by the devs, for the devs.  No Product people, no Scrum masters, nobody but devs.\n* Each PR is gone through by the person that wrote it, file by file, change by change.  If issues are discovered, pull request is put on hold until change is made.  No worries, because another review is just two days away.\n\nThis way everyone *must* learn the code, and everyone *must* teach the code.  This is the fastest way to do CRs.  And if issues are found, no problem.  Another CR is just around the bend, so you don't have to worry about pull requests sitting in limbo on a feature branch forever.  You can reintegrate next code review (probably... provided you fixed the issue!)  This way we can keep development moving along.\n\nThe real revelation was two pretty simple points: #1 Put the code review on the calendar; #2 The dev that makes the pull request is the one that explains their work.", "id": "darpb02"}, {"comment": "We did something similar, except we don't have time slots, have adjusted focus factor to account for the fact that we expect ALL members of a team to review anything before it gets merged unless it's a hot fix. \n\nWhat ends up happening is that each individual member will focus on whatever their strengths ( offering suggestions or demanding changes)  and weaknesses ( asking questions as to how or why something works) are. \n\nTypically, you'll have in a team the person who optimises a lot, the person who focuses on readability, the guy that really tries to have a big picture understanding and everything in between. Me? As SM, I focus on a) does the PR have a detailed description so if need be we can look at it in a few months and remember what was done? B) does it do what it says on the tin? C) Are the tests properly done or more of an afterthought. \n\nIt's \"slow\"  but we hardly have any real problems besides sometimes having to politely ask whoever hasn't taken a look to take a look.\n\nOn our last retro, someone suggested having a fixed period of checking PRs every day, we'll give that a go next. ", "id": "darpkag"}, {"comment": "Maybe sell it as a skill that needs to be practiced and cultivated.  It's also useful for team cohesion and sharing info across the team/project.\n\nMaybe suggest a rotating slot on the review list that is specifically for juniors.", "id": "daqymgw"}, {"comment": "They learn faster (read: will be better developers) by being exposed to and reviewing code more senior developers have written.", "id": "dar0y48"}, {"comment": "I'm struggling to give much advice just because the benefits seem so obvious that they shouldn't need convincing.\n\nYou could always offer to hire me as a consultant to speak to them about the benefits \ud83e\udd23", "id": "daqztyl"}, {"comment": "Wow I would not want to work at your company. Why do they let non engineers manage an engineering team? If those are engineers..... it sounds your managers are interns.", "id": "darcfer"}, {"comment": "What is your org and review like? We send reviews to everyone in our team (20-40 depending) as optional reviewers and there are a select set of experienced members that are set as required reviewers.\n\nSo I don't have any explicit managerial support for this, I just mentor developers to take advantage of the opportunities presented.\n", "id": "daqzcs2"}, {"comment": "O would tell management that reviewing people's code is a different skill from receiving a review. You can only learn by doing. They need to learn by doing. When a senior developer asks a junior developer to review their code, it is an opportunity to teach the junior how to review code.\n\nThe other benefit is that if the junior can't understand the code as written, the senior needs to understand this and fix it. ", "id": "dar7oaq"}, {"comment": "In my company we have a \"democratic\" code review process in place, everyone code reviews everyone. Junior programmers (or programmers that are new to the code base) review senior programmers primarily to learn and ask questions. Senior programmers review juniors to find bugs and to see what parts of the code base or business the the junior programmer is struggling with.", "id": "daqzrkr"}, {"comment": "The team building aspects of having new team members engaged in the code review process is invaluable. They learn a lot by being involved, and sometimes a dev team can become an echo chamber so having a new and fresh perspective can point can lead to all kinds of improvements.", "id": "dar3ebn"}, {"comment": "< 3 years is junior?", "id": "dar69rc"}, {"comment": "That sounds about right, although it depends on the experience.  Also it sounds like he meant management requires 3 years experience for a developer to be a reviewer which doesn't make sense.  Everyone should be reviewing code.  It is just as important as writing code.", "id": "dar821p"}, {"comment": "You have a young person's perspective of time.  \n\nI've been doing software engineering for over thirty years (and I often say that I've only really got the hang of it in the last five years... :-D )", "id": "darcjta"}, {"comment": "My point exactly.  A firm that thinks 3 years is part junior level...don't want to think about what their code looks like.", "id": "darenjb"}, {"comment": "Code reviewing is also a skill that benefits from practice, that's another good reason to get juniors doing them - so they can learn to be good at code reviewing.\n\nAlso, it's just fair.", "id": "darco48"}, {"comment": "Set up mandatory code review before code is in a repo, a la gerrit. Leave management out of the loop.", "id": "darlhvs"}, {"comment": "I think its also important to praise code in reviews too. It instills confidence and let's them know when they've used good practice so they start to build a base of good patterns.", "id": "daro0i7"}], [{"comment": "I'm currently unemployed. Last week I had an interview with a new startup. One of the questions was, \"Do you do code review?\"  \n\nI replied, \"Well unfortunately I've never worked at a company that uses code reviews. I think code reviews are a good idea though and I would like to do them if I got the job here.\"  \nHe repeated the question. I said, \"Well at the moment I'm just working on a couple of personal projects by myself, so I haven't been able to-\"  \n\n\"Yeah, but, do you do code review?\"  \n\n\"...Yes, I do code review.\"", "id": "daqveuk"}, {"comment": "He wanted you to say yes. ", "id": "daqyef5"}, {"comment": "It is like his boss said to him, make sure the person is comfortable with code reviews.", "id": "daqzshx"}, {"comment": "Yeah there is a lot of BS questions in corporate, was probably mandated that if they didn't answer yes he couldn't moved forward. Sounded like the phone screen liked him and was trying to get him to give the correct \"legal\" answer.", "id": "dar3ily"}, {"comment": "This wasn't corporate, it was a start-up. It's, like, right there in the text.", "id": "darbkvi"}, {"comment": "\"Are you comfortable with code review\" != \"Do you do code review\"", "id": "dar8xo8"}, {"comment": "Sure, but it sounds like the interviewer really liked this guy, and wanted to push him in the right direction for the answers he needed. I have had it before, and you can easily learn this stuff on the job.", "id": "dar92lf"}, {"comment": "lol wtf", "id": "daqxfns"}, {"comment": "I do 'code review' on all my own code, even for personal projects with no other contributors. I open PRs, look at diffs, do everything I would do if I was reviewing someone else's code. Hell, I even leave comments on my own PRs that no one will ever read but me, noting design patterns I didn't like, possible future issues, etc. I've even looked at the PR and declared it shit and taken a different approach. I'm probably more critical of my own code than other people's code.\n\nFor me this process catches a lot of bad design choices, bugs, poor test coverage, wonkiness, etc. If you're adding a non-trivial feature to any codebase it's very easy to lose track of the big picture of what the commit/PR will look like when finished or become so focused on 'making it work' that you lose track of how shitty the code you're writing is. Code review is the opportunity to take a step back and see how it all works together in the context of the existing code, it doesn't require that more than one person is involved. \n\nThat said, the interviewer could have just been a helmet too.", "id": "daqy8h9"}, {"comment": "Some people become absolute assholes in interviews. Several people I know deliberately fluster candidates or neg them to get \"the best rates\".\n\nHonestly I'm not sure code-reviewing your own code would leave many people to think of what they have done wrong, and it assumes they can spot a mistake vs a preference.", "id": "daqzirs"}, {"comment": "> Some people become absolute assholes in interviews.\n\nNo doubt. If the interviewee has the luxury, I'd recommend they exclude such companies. People whom are assholes in interviews are often assholes in other contentious environments. You don't want to be working with an asshole when something breaks or when you're debating what 'APIv2' looks like. \n\n> Honestly I'm not sure code-reviewing your own code would leave many people to think of what they have done wrong, and it assumes they can spot a mistake vs a preference.\n\nI agree and that is why it can be a good interview topic assuming the discussion is framed correctly. Self introspection, the knowledge to identify 'mistake vs preference', and being able to characterize multiple sides of a preference is certainly a set of traits I look for when interviewing people. \n\n", "id": "dar0hg2"}, {"comment": "> If the interviewee has the luxury, I'd recommend they exclude such companies.\n\nI Actually have never interviewed anyone formally as part of a hiring process and believe heavily in a really relaxed conversational style and it being a two-way street of me deciding if I am to \"work with\" them also. I Think people tend to become dis-empowered through the general authoritative role of education and standards bodies, governments, heck even parents. People I've worked with tend to see it as a \"we work together\" and that is great for combating:\n \n * Cutting out \"not my job\" people\n * Not falling for qualifications, hiring someone made to write books\n * Really honest working environment\n * Really interesting work situations\n * Supportive people\n\n> I agree and that is why it can be a good interview topic assuming the discussion is framed correctly.\n\n100%; I Honestly couldn't care less about what someone used to do for X, Y & Z, or why they didn't work or worked as someone else, or how much I can upset them by asking them to write code in front of me (hilariously I never got this was stressful until someone did it to me on something I hadn't decided to show). \n\nI actually do ask about projects and what tech people like to work with, or their favourite device, because I think that is more substantive than giving me a warm fuzzy word cloud about their past job and unless they are a writer, I don't give a hoot! I just want to know what we can do together, where they fit in and that I won't be casting resin whilst they build a nice wicker house. \n\nSomething recently important to me is having experience with failure or not measuring up, because I think it really helps me to get an idea of a person. Lastly and would like to work together vs having to (which sucks, but not the person hiring / working with problem).\n\nOf all the things that bothers me most is the fixation on recorded history, why they left X, that they like to watch volleyball at the weekends, their convictions, their sexuality, their religion or view of a religion etc... It falls into \"my constellation of things I don't give a shit about, and wonder why you would either.\"", "id": "dar8yq7"}, {"comment": "> Some people\n\nIt's becoming many more than some. I go to interviews for the fun of... going to interviews. The attitudes and hazing I'm seeing, and hearing about, is way beyond what I've ever experienced in the last 25 years. It's to the point that I'm starting to think it's irreversible and we are in a new era where people in the development community are just assholes. ", "id": "dar3h6t"}, {"comment": "I think you're replying to the wrong post but:\n\n> I go to interviews for the fun of... going to interviews\n\nSeems to indicate selection bias. ", "id": "dar3vu4"}, {"comment": "Thanks, yes I did.\n\n> selection bias.\n\nMaybe.\n\n\n", "id": "dar443f"}, {"comment": "For one thing, if you're interviewing for the fun of it, you're probably not burning your personal connections to get those interviews.  That's going to skew your experience towards companies looking for random people off the job market.\n\nAlso, if you are getting lots of interviews like that, it probably means you have a very good resume.  That really brings out the asshole in insecure people who want to prove they're smarter than you.", "id": "darnn4u"}, {"comment": "Yeah I fear this would be my issue. We don't do code reviews at my office currently, but I've been pushing for them. But one of the guys on my team is a pretty lousy developer (even worse, he thinks he's actually really good). He's already not very social, easy to rile up, and he and I generally don't get along great especially when it comes to code and design issues. \n\nHe or I reviewing each other's code would be very... Testing. We've flat out acknowledged we have \"very different coding styles\" (aka I write against interfaces, write unit tests, load data from configuration files, etc, all things he considers \"over engineering\" and bad). I'm convinced he'd spend so much time nitpicking things he dislikes he'd never bother looking for actual design or logic issues. \n\nIn this specific case, it's a personnel issue, but I'm curious how in the more general sense developers try to address the ego problem when it comes to reviews.", "id": "dar4bbb"}, {"comment": "Oh you write what you feel is correct and get hauled over to \"talk about it\" if it's silly, and not just by developers. That guy would be changing, or out on his ass so fast because there would be a record of his general incompetence & unpleasantness from the description you've just given.\n\nThe push-back from management will always be \"but we want to move at 1000mph\", so strategically keep a log of times when that leads to problems and in the nicest, most conciliatory way plead your case.\n\nOf course it won't actually improve coding overnight, or very fast at all. The thing about programming is it's a long-haul flight for an entire life-time so you'll probably develop ideas and hunches against your own code and situations over time; maybe make a few tough calls or experiment with other styles.\n\nOn coding to an interface always, if your code is throw-away or < 6 months, this is an organisational problem, not a coder problem. I do a lot of projects that are PoC where we just smash code together, use tuples instead of formal data structures, the whole thing is a marvel of pipe-cleaners and wonderglue. The \"Talent\" is knowing when to make a high-school science-fair project and when it will hurt a business and your reputation to do so.", "id": "dar7mds"}, {"comment": "Oh absolutely. Some of our code is PoC and for that, sure, spaghetti code away. But when we're working on a major project for a big client that will involve multiple endpoints, high performance computing, mass data inhalation and processing, etc. A little bit of protecting against changes in the future is warranted.\n\n But he, and I'm direct quoting here, thinks \"you don't know the future so it's pointless to try and guess what it might be and design for it\". ", "id": "dar8qc3"}, {"comment": "Search YouTube for \"Karl Pilkington\" and tell me if they are related.\nThen read this [Dunning-Kruger Effect](https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect)\n\nCongratulations. You have found a moron. Like a morlock they like cold damp places, can be prone to violence and are best suited to carting heavy objects around. \n\nYou should totally secretly film sayings from them and put them on YT for my and others enjoyment. There has to be 100 million coders. 20% of whom know enough to laugh and 40% of whom I hope will know more enough to laugh in a few years or so", "id": "dar9at6"}, {"comment": "> But he, and I'm direct quoting here, thinks \"you don't know the future so it's pointless to try and guess what it might be and design for it\".\n\nHe sounds like a moron from everything else he's said - _but_ this part is somewhat true, and indeed, a tenet of so-called \"extreme programming\".  \n\nThis was something of a revelation to me at a certain point, but XP says that \"designing for generality\" is usually bad _unless_ you have already spec'ed out exactly the \"generality\" you are expecting to face - because half the time you never use it, and half the remaining time, you have designed for the _wrong_ generality.\n\nThis is also bound up with the Minimum Viable Product idea - where you don't bother to do any design past that MVP point because that's where you need to stop and see what people actually do with your program before you go on.\n\nI'm not 100% committed to this idea, but it has aspects of truth, and needs to be considered.  I've seen more projects killed by under-design than over-design - but only by roughly a 2:1 ratio.", "id": "darczfx"}, {"comment": "I definitely agree there's something to be said for not overengineering, but I'm talking about things like situations where we've talked about, WITH THE CLIENT, \"It's likely we'll need a feature like <x> in the future, or something along those lines yadayada\", and then this guy will push back against ensuring his design could accommodate a feature in that realm without a major design overhaul \"because it's not currently in scope\". \n\nBut yes, overengineering for the sake of it can be just as painful, especially depending on what your onboarding/offboarding of developers rates are like. A place with a lot of churn will find the ramp-up time on an overengineered project is a lot higher for new devs, which can be very painful indeed.", "id": "dard37e"}, {"comment": "Also https://www.youtube.com/watch?v=DngAZyWMGR0. This has pretty pictures so it might help them to understand the trade-off", "id": "dara3i2"}, {"comment": "> In this specific case, it's a personnel issue, but I'm curious how in the more general sense developers try to address the ego problem when it comes to reviews.\n\nWhichever person is unable or unwilling to match the style and standards agreed upon by the lead must leave or be pushed out.\n\nIf you have high standards and the lead is unwilling to or ineffectual at enforcing them on your peers, then you should leave.\n\nI don't agree with my current lead's coding style preferences (using _ prefix for private/protected variables and never using `this.` for member variables), but he's a fucking genius and otherwise nice to work with, so I use his style for this codebase.", "id": "darnpvo"}, {"comment": ">Some people become absolute assholes in interviews.\n\nWhen I was first out of school I interviewed for GE. I had previosuly done a year-long internship at a vendor that did work for GE, so I knew about them and they knew a little bit about me. I also knew that GE was an incredibly stressful and adversarial place to work, in comparison to their competitors, whom I'd also had some contact with.\n\nI passed the HR interview including the psych questions. During the technical phone interview, at the end they asked me to describe a conflict I'd had with a coworker. I said I couldn't really think of a conflict. They pressed me, accusing me of lying, saying it would be impossible to work for the (short) length of time I had without having a workplace conflict. \n\nRemember, this is the *technical* interview. \n\nThey (two of them, managers) hammered me for probably 5 minutes on this question: \"So a boss had never asked you to do something unethical?\" \"No\" \"A coworker has never tried to undercut you?\" \"No\".  I think they were actually yelling at me before *I* ended the interview. \n\nTo this day I'm not sure if they were intentionally trying to wind me up (which would have occurred in the psycho interview, not the tech  one), but I sure am glad I never took that job. ", "id": "darh05j"}, {"comment": "I call that coding. Code Review necessarily needs a second party.", "id": "dar18se"}, {"comment": "I get your point and we may be bike-shedding terminology here. But, a lot of developers do not review their own code, they 'make it work' and write some tests (maybe) and call it good. I'm just pointing out that the process of 'self code review', or whatever you wish to call it, is a differentiating factor in developer quality in my experience. In other words: it's awesome that you consider this process so core to your workflow that it's simply part of 'coding', but many people are not like that. Identifying this trait is certainly fair game in an interview in my opinion.", "id": "dar30zu"}, {"comment": "Friggen brilliant idea.  Will steal. ", "id": "darclg1"}, {"comment": "You can do some code review on some of my personal projects if you'd like.", "id": "daqxh9x"}, {"comment": "I don't understand how something like that can happen. Was he a robot? Was he testing to see how quickly you start flipping tables? Did you answer in Swahili? Was it just a dream?\n\nI'm missing the punch line here.", "id": "daqzid7"}, {"comment": "Perhaps they liked the candidate for the job but this was a \"needs a yes\" question so he was prompting them to reword their answer. ", "id": "dar1wdw"}, {"comment": "Exactly thus", "id": "dar3dco"}, {"comment": "As having played the phone screen role and actual hiring manager role, this seems like the most likely scenario given that he repeatedly asked the same question.", "id": "dar3kbu"}, {"comment": "I don\u2019t even get why this was a question for the applicant, and not the other way around.", "id": "darqjcc"}, {"comment": "Well, I do have a rather heavy accent, maybe he didn't quite catch what I was saying!", "id": "dar2p66"}, {"comment": "https://www.youtube.com/watch?v=GSZbOCr08lM", "id": "darpkqy"}, {"comment": "I actually review my code before submitting a PR at work. I look at the diff in bitbucket (for some reason it helps not looking at it in my IDE) and go line by line through all of my changes as if I was the reviewer. I usually catch a few mistakes during the process.", "id": "dar3tj4"}, {"comment": "Isn't this what everyone does? ", "id": "dar7lp7"}, {"comment": "Unfortunately, no.", "id": "dar8yb0"}, {"comment": "Contribute to open source", "id": "dar2xld"}, {"comment": "Maybe they were asking if you run tests? Unit testing and integration testing maybe?", "id": "dar6kqn"}, {"comment": "If at all, *meant* to be asking. They definitely did not ask that from his description.", "id": "darqi53"}, {"comment": "Non-technical person on the other end doing screening with prepared questions? Sucks.", "id": "darqhcy"}, {"comment": "Wow, the interviewer sounds like a jackass.", "id": "dar0u4k"}, {"comment": "Honestly, I don't think he was a jackass. I think /u/ashagari and /u/RedPandaIsBestPanda are right, he was just looking for yes/no answers. He didn't seem to mind when I felt I couldn't answer questions in enough detail.", "id": "dar2mvu"}, {"comment": "Standard uneducated hr. He probably didn't even know what code review is.", "id": "darev1z"}], [{"comment": ">Do you use nondescript variable names like a, b, c?\n\nDo people really do this? I would lose my shit.", "id": "daqu99p"}, {"comment": "Maybe only an i for a loop index, but that's as ingrown as using foo and bar for test data.", "id": "daquubk"}, {"comment": "I often use a and b for comparators.\n\n    array.sort((a,b) => a-b)", "id": "daqxdo2"}, {"comment": "You monster", "id": "daqyalv"}, {"comment": "well usually the name of the container is what's descriptive.\n\n    movies.sort((a,b) => a.rating - b.rating)\n\nor\n\n    redditors.sort((a,b) => {\n        if(a.name === 'trylist') {\n            return 1;\n        }\n        if(b.name === 'trylist') {\n            return -1;\n        }\n        //like i care what order you guys are in\n        return 0;\n    })", "id": "dar7nvf"}, {"comment": "Agreed, i was just chirping you.\n\n", "id": "dar7ql4"}, {"comment": "Similar, but I always use `l` and `r` for comparator parameters.", "id": "daqzayh"}, {"comment": "How hard is it really to type \"left\" and \"right\"? :)", "id": "dar60u3"}, {"comment": "How helpful is it really to type \"left\" and \"right\"?", "id": "dar7vx5"}, {"comment": "If you're trying to do a single line lambda it matters, plus using `l` and `r` aren't really ambiguous like `a` `b` or `c`. ", "id": "dar66gw"}, {"comment": "Lowercase L is a pretty poor choice of variable name though, too easy to confuse with i, I or 1.", "id": "dar9664"}, {"comment": "That sounds more like a font issue than anything else.", "id": "darbb0a"}, {"comment": "The only important thing is that they have an implicit order. 'a' and 'b', 'left' and 'right', 'first' and 'second', 'top' and 'bottom'. You need to know which is which in a comparator. That's why I like 'a' and 'b', they are naturally short and have an implied order. You know 'b' is the second parameter. Just like you know 'right' is after 'left'.", "id": "dard6yc"}, {"comment": "`l` and `r` are unambiguous, they refer to absolute position.  Ordered parameters could mean different things depending on localisation.", "id": "darozba"}, {"comment": "    for (Product p : productsList) {\n        someStuff(p.serialNumber);\n    }\n\nIs this really not descriptive?\n", "id": "daqx823"}, {"comment": "Of course it's not. Why would you think it is? Your code is immediately clearer by renaming `p` to `product`.", "id": "daqxhu7"}, {"comment": "`theCurrentProductAndNotSomeOtherProductAndDefintelyNotJustP`", "id": "daqxz0u"}, {"comment": "I see you write Objective-C as well.", "id": "dar30r9"}, {"comment": "I think this depends strongly on the reader.  If you are mathematically inclined, and used to using single-character variables, or perhaps subscripted variables (within a reasonably narrow scope of use, of course), then using such a thing in code is actually clearer and easier to read.  It also encourages the writer and reader to make generic code, whether based on C++ templates, functional polymorphism, object-oriented polymorphism, or whatever.\n\nUnfortunately this flies in the face of programmers that find this kind of naming indirection difficult to follow.  Or programmers who have a hard time with math.  Or those who like math, but don't like the typical mathematical syntax.  Or those who prefer to write monomorphic code.\n\nSo no, it is not rendered immediately clearer for all readers.  Its something that needs to be decided at the project level by all stakeholders.", "id": "daqyov5"}, {"comment": "For me, if I see `for (Product product: productList)`, it bugs me because there's so many \"products\" there that it's not worth the additional clarity that `product.serialNumber` has vs `p.serialNumber`.\n\nHowever, if it's not a for loop and I'm going to use `p` more than, say, 10 lines away from where I declared it, then I'd probably get over how stupid looking `Product product` feels to me because the additional clarity of `product.serialNumber` is a lot more helpful when you can no longer see where `product` was defined.", "id": "dar5cim"}, {"comment": "For me, it's consistency. If there's a scenario where you might use the full 'Product product', while there might not be a benefit for doing it all for-each loops, you then have the same sort of notation regardless of usage. ", "id": "darjovx"}, {"comment": "That's definitely a strong consideration. If I'm working in a large codebase over a semi long period of time, being able to cut through visual unnecessary stuff quicker requires consistency as much as possible. I can see myself liking a strict \"no meaningless variables\" rule in that case. ", "id": "darnil3"}, {"comment": "you're kidding, right? single-letter variables versus descriptive variables should be a decided at *all* levels with input from *all* stakeholders?", "id": "dar4dn9"}, {"comment": "Not kidding.  This is a decision to made at the level of the team's coding standard.  \"The descriptiveness of identifiers should be inversely proportional to their scope of visibility.  The narrowest scopes may even use single-character identifiers.\"  is a very different policy than \"Identifiers at any scope should be descriptive.  Even at the narrowest scope, identifiers should be composed of complete English words.\"", "id": "dar5d83"}, {"comment": "What if a narrow scope grows in size, or vice-versa ? Does this mean its identifiers have to be renamed then ?  \nI'm not arguing for the sake of arguing here, it's just that single-letter identifiers can sometimes trigger legacy-code-themed ptsd :)", "id": "dar76k4"}, {"comment": "Sure, what's wrong with renaming identifiers? Your tooling does have refactoring support or typechecker-based rename support, right?", "id": "dardik3"}, {"comment": "What about your blame history? Given how willing you are to clobber it with pointless refractors, yours may not be that valuable, but keeping it mostly accurate has a lot of value. Being able to drill down to a change that actually introduced a line of code, vs. one that just does some renames helps tremendously in seeing what the original intent was. Polluting changes and blame history with renames destroys much of that value.", "id": "dargjdq"}, {"comment": "That's all great in theory, but a codebase needs upkeep, and that upkeep means constant small refactorings along with the day-to-day features, bugfixes, and whatnot. Otherwise you'll find yourself with one giant ugly heap of a codebase one day and no one is going to want to touch that. But the blame will tell you exactly how you got there, so congrats.", "id": "darixwu"}, {"comment": "You're right about preserving history, but there has to be a balance between that and readability. Just renaming a variable is easily (granted, not trivially)  abstracted away when looking for that particular change, it's a small thing.\n\nWhat about bigger refactorings, where whole chunks are extracted out into different functions, files, even? Those usually have good value, but should we drop them for the sake of preserving history?", "id": "darjuxg"}, {"comment": "> What if a narrow scope grows in size, or vice-versa ? Does this mean its identifiers have to be renamed then ?\n\nIt's a judgement call (forget \"have to\"), but why not?!", "id": "darjq7o"}, {"comment": "Since the narrowest scopes are by definition very isolated you should be able to rename them freely.", "id": "darg8yb"}, {"comment": "so which is it? all stakeholders or just the team?", "id": "darlu6e"}, {"comment": "Well, there is always this terse/descriptive trade-off and it's probably down to personal/team preference.\n\nFor the example above or something slightly longer, I'd prefer *p* as the variable name (even when reading someone else's code :-), as it makes it easier to mentally parse shorter lines for a small block of code.\n\nIf the code block was more than, say, half a screen tall, I'd prefer a \"proper\" variable name, like *product*, since I don't need to remember what does *p* stand for after two dozen lines of code.", "id": "daqzx9e"}, {"comment": "> I'd prefer p as the variable name\n\n\nSame.  Especially for small specialized functions.\n\nLike one of my projects I was working on today has a function:\n\n\n    static inline uint16_t r16be(uint8_t **ptr) {\n      uint8_t *p = *ptr;\n      uint16_t r = *p++ << 8;\n      r |= *p++;\n      *ptr = p;\n      return r;\n    }\n\nThat's 2 single-letter variable names, and a terse function name.  On top of that, I don't do any bounds checking, you're expected to do that before calling.\n\nThe dogmatic people still in school who believe in verbosity and training wheels would have a conniption.", "id": "darp246"}, {"comment": "OMFG, so many products around!", "id": "darjw00"}, {"comment": "I guess common sense isn't that common.", "id": "dar5s6t"}, {"comment": "Certainly less so than \n\n    for (auto product : productsList) {\n      someStuff(product.serialNumber);\n    }\n\nEspecially if the body ever grows beyond one line.\n", "id": "dar2bgp"}, {"comment": "What? This is much worse. It's no longer clear what the type is from local information. The original was also checked to actually be a Product at compile time, but your version would compile no matter what you called the variable.", "id": "darnzfh"}, {"comment": "If is a killer in development. \n\nIf it changes then change the name.", "id": "darcuuq"}, {"comment": "There is no if here. It's better in the current case, it's better in the future case, it's better all around.\n\nAt what point do you propose changing the name? When it gets to 2 uses? To 3? To 5? 10? How do you guarantee it becomes readable before you start touching too many unrelated lines?\n\nAnd don't discount the value of an accurate line-based blame, especially when you have multiple people working in a codebase.", "id": "dargevx"}, {"comment": ">It's better in the current case\n\nMay be, that's not what I was arguing. My point was that arguments in the form of \"let's do this in case this happens in the future\" are bad. They are bad because it inevitably dirties up your codebase with irrelevant things. I'd call it a code smell.\n\n>At what point do you propose changing the name?\n\nThat's up to the programmer's best judgement. This is why it's an art not a science.\n\n>How do you guarantee it becomes readable before you start touching too many unrelated lines?\n>And don't discount the value of an accurate line-based blame, especially when you have multiple people working in a codebase.\n\nI'm not sure what this means?\n", "id": "darjzc9"}, {"comment": "    foreach(var product in productsList)\n    {\n        SomeStuff(product.serialNumber);\n    }\n\nHow I would probably do it in C#. I think the snippet you posted is Java though...I'd probably just change p to product anyway because it makes any line with the loop variable easier to read, even if you only have to search up a single line to figure out what kind of object it is.", "id": "dara7yv"}, {"comment": "Only one liners probably not a big deal. To be honest, I probably should stop doing this with my one liner lambdas. :|", "id": "dar7a64"}, {"comment": "Nah, it's ok for what it is (very short). You can rename it later if it becomes long. Good thing is, things who do get longer tend to become even more long later, so you are less likely to churn between a short and a long name.\n\nHeck, even \"productList\" is better being just \"products\" here.", "id": "dark17g"}, {"comment": "Yes people do it all the time.\n\n\"There are only two hard things in Computer Science: cache invalidation and naming things.\" -- Phil Karlton", "id": "daqz3a9"}, {"comment": "You mean,\n\n'There are only two hard things in Computer Science: cache invalidation, naming things, and off-by-one errors'.", "id": "daqzeu6"}, {"comment": "That's four.", "id": "dar27fc"}, {"comment": "I count 2", "id": "dar66v7"}, {"comment": "\"There are only three hard things in Computer Science: cache invalidation, naming things, off-by-one errors, and mlutithr-aednig\"", "id": "darafjj"}, {"comment": "> mlutithr-aednig\n\nI wonder how long it would take, on average, for the algorithm that produced that to produce the correct output.", "id": "dargsq2"}, {"comment": "For a really naive implantation (something like C's pthreads. not sure if modern threads use better schemes), it's probably like [bogosort](https://en.wikipedia.org/wiki/Bogosort), so it'd take O((n+1)!) on average.", "id": "darml9y"}, {"comment": "I would usually do it for generic variables, e.g. `def swap[A, B](ab: Tuple2[A, B]): Tuple2[B, A] = ab match { case (a, b) => (b, a) }`.", "id": "daqwnhr"}, {"comment": "https://twitter.com/jamesiry/status/598547781515485184\n\n> Functional programmer: (noun) One who names variables \"x\", names functions \"f\", and names code patterns \"zygohistomorphic prepromorphism\"", "id": "dar6711"}, {"comment": "Hey, don't blame me. I'd use the proper Greek letters if they weren't so annoying to type.", "id": "dar9nln"}, {"comment": "Also names generic types T and U.", "id": "darlyco"}, {"comment": "Wouldn't 'first' and 'second' instead of 'a' and 'b' make it more clear what the function is doing?", "id": "daqzdx7"}, {"comment": "'first' and 'second' hold no semantic value to \"swap\" either though.", "id": "dar36p4"}, {"comment": "The function is called 'swap' and literally is one of the most common functions in existence. ", "id": "dar14ru"}, {"comment": "Imho the types make it quite clear what the function is doing.", "id": "dar5dln"}, {"comment": "`def swap[A, B](ab: Tuple2[A, B]): Tuple2[B, A] = launchMissiles(); return swap(ab);`", "id": "dar7oew"}, {"comment": "    swap :: (a, b) -> (b, a)\n    swap (a, b) =\n      unsafePerformIO launchMissiles -- or even `undefined`\n      (b, a)\n\nIf you don't use a type system with discipline ... `\u00af\\_(\u30c4)_/\u00af`", "id": "dar8dvh"}, {"comment": "**TL;DR:**  Type in \u00af\\\\\\\\\\\\\\_(\u30c4)\\_/\u00af for proper formatting\n\nActual reply:\n\nFor the \n\n    \u00af\\_(\u30c4)_/\u00af \n\nlike you were trying for you need three backslashes, so it should look like this when you type it out\n\n    \u00af\\\\\\_(\u30c4)_/\u00af \n\nwhich will turn out like this\n\n\u00af\\\\\\_(\u30c4)\\_/\u00af \n\nThe reason for this is that the underscore character (this one \\_ ) is used to italicize words just like an asterisk does (this guy \\* ).  Since the \"face\" of the emoticon has an underscore on each side it naturally wants to italicize the \"face\" (this guy (\u30c4) ).  The backslash is reddit's escape character (basically a character used to say that you don't want to use a special character in order to format, but rather you just want it to display).  So your first \"\\\\_\" is just saying \"hey, I don't want to italicize (\u30c4)\" so it keeps the underscore but gets rid of the backslash since it's just an escape character.  After this you still want the arm, so you have to add two more backslashes (two, not one, since backslash is an escape character, so you need an escape character for your escape character to display--confusing, I know).  Anyways, I guess that's my lesson for the day on reddit formatting lol\n\n***CAUTION: Probably very boring edit as to why you don't need to escape the second underscore, read only if you're super bored or need to fall asleep.***\n\nEdit: The reason you only need an escape character for the first underscore and not the second is because the second underscore (which doesn't have an escape character) doesn't have another underscore with which to italicize.  Reddit's formatting works in that you need a special character to indicate how you want to format text, then you put the text you want to format, then you put the character again.  For example, you would type \\_italicize\\_ or \\*italicize\\* in order to get _italicize_.  Since we put an escape character we have \\\\\\_italicize\\_ and don't need to escape the second underscore since there's not another non-escaped underscore with which to italicize something in between them.  So technically you could have written \u00af\\\\\\\\\\\\\\_(\u30c4)\\\\\\_/\u00af but you don't need to since there's not a second non-escaped underscore.  You ***would*** need to escape the second underscore if you planned on using another underscore in the same line (but not if you used a line break, aka pressed enter twice).  If you used an asterisk later though on the same line it would not work with the non-escaped underscore to italicize.  To show you this, you can type _italicize* and it should not be italicized.", "id": "dar8dy7"}, {"comment": "just look at a Go codebase , yes you'd loose your shit.", "id": "dar8e9u"}, {"comment": "How about i,j,k? I see nothing wrong with using single letter variables names that have become de facto practice. But I would probably throw a copy of Code Complete at you if you ever use a, b, c as an index or loop counter. Use single letter variables as a parameter name or within a function that's even slightly non-descript and to the point, yes I'm going to say something.\n\n", "id": "dar3ydy"}, {"comment": "Even if they're just loop counters, though, three anonymous variables is about where I lose track. How would you feel about e.g. `client_i`, `request_i`, and `item_i` instead of `i`, `j`, and `k`?", "id": "darpxjv"}, {"comment": "I use them for super generic things where naming them wouldn't actually help. For example:\n\n    flip :: (a -> b -> c) -> (b -> a -> c)\n    flip f x y = f y x\n\nSure, I could do this instead:\n\n    flip function firstArgument secondArgument = function secondArgument firstArgument\n\nBut that barely makes the code any clearer. If anything, it makes a really simple line of code look needlessly complicated.\n\nI also use names like `xs` and `ys` for lists, such as in:\n\n    merge :: (Ord a) => [a] -> [a] -> [a]\n    merge xs [] = xs\n    merge [] ys = ys\n    merge (x : xs) (y : ys) =\n        if x < y then\n            x : merge xs (y : ys)\n        else\n            y : merge (x : xs) ys\n\nSure, I could do this instead:\n\n    merge (head0 : tail0) (head1 : tail1) = ...\n\nBut unless your understanding of what `(:)` means in Haskell is poor - in which case, you're probably not writing it professionally anyway - it doesn't make the code any easier to understand.", "id": "darkilw"}, {"comment": "Not only that, but I've seen it in tutorial code, with the explicit justification of making it \"easier to read\".  I have no idea how they came to that conclusion.\n\nAlso, anybody who learned how to code with FORTRAN77, and its limit of 8-characters in a variable name, and never updated their coding habits since.", "id": "dar7jkh"}, {"comment": "I do this for simple Linq statements. Usually for things like\n\n    list.Where(x => x.Foo == \"bar\");\n\nAnd then maybe for loop iterators as well, but in general I like to err on the side of a slightly longer variable name if it makes the code demonstrably more readable.", "id": "dara3st"}, {"comment": ">     Do you use nondescript variable names like a, b, c?\n> \n> \n> \n> Do people really do this? I would lose my shit.\n\nIt's generally considered okay as long as the vertical distance between where the variable is declared and where it is used is very short. For instance, initializing a counter variable in a for loop or something similar.\n\nThe farther the variable is used from where it is declared, the more important it is for a variable name to be very descriptive.", "id": "daremuh"}], [{"comment": "I highly recommend using a code review tool for a team. In person reviews suck, and usually are counterproductive. We use crucible, but there are others out there just as good or better. It lets us defer reviews until we have time, have comment threads, refer to issues or documentation inline, provide code examples, etc. It integrates with our version control so we get diffs instead of large blocks of code. Without crucible I did about 3 serious reviews a year. With crucible I've done about 150 in the last year, either having my code reviewed or reviewing others' code. It's improved our code quality dramatically.", "id": "daqvok5"}, {"comment": "Don't most repo management webapps nowadays have code review built-in? I know Atlassian's Bitbucket Server (n\u00e9e Stash) does.", "id": "daqwrhx"}, {"comment": "Our instance of github just got it a month or so ago.", "id": "daqxppt"}, {"comment": "Surely you're talking about the new 'Review' tool in GitHub EE. Previously, one would just leave comments. This just makes that a bit more pleasant, but you could still review in the old difftool.", "id": "daqyye2"}, {"comment": "It's not just for enterprise any more, I code as a hobby and have been using it.", "id": "dar7dk4"}, {"comment": "GitHub has lagged for a while. They thought that PR comments were good enough.", "id": "daqz5ne"}, {"comment": "GitLab does too, and we're working on improving it.", "id": "dark3q1"}, {"comment": "The majority of web repos do have code review implementations, but they are often lacking in comparison to dedicated code review platforms. Things like disappearing comments on code updates are still common place for bitbucket and alike. Solutions like Crucible, Preenly and Reviewable add much more functionality for a minimal price (free in the case of Preenly)", "id": "darmx7e"}, {"comment": "This is a great point, I really like having my code reviewed, and improve on it, but I def feel the whole talking through it is a bit inneficient.", "id": "daqyd7w"}, {"comment": "I also really like having my code reviewed but I'm the only one in the office that writes code :'(", "id": "dar6wbe"}, {"comment": "Just as an FYI, if you have sections of your code that you aren't confident about, Stack Exchange has a code review [community](http://codereview.stackexchange.com/). \n\nObviously not good for huge change sets and you would probably have to rename your (namespace, variable, method) names to be agnostic enough if you have any confidentiality or IP agreement. But it would probably still be better than feeling around in the dark!", "id": "darmfpp"}, {"comment": "We use code climate, that tool is amazing ", "id": "darazo5"}, {"comment": "> In person reviews suck, and usually are counterproductive. \n\nThis kind of depends on the code being reviewed. For some things, I'll totally advocate an over the shoulder review - generally smaller changesets and things of that sort.\n\nHowever, for most of the rest of it, yes, using a tool is a much better option. Though I feel for you if you're trying to do it in TFS (especially the older versions). Then you're stuck putting everything in shelvesets for ease of review. That makes puppies sad.", "id": "daretqf"}], [{"comment": "Paired programming and TDD....may sound awkward at first but the number of times you end up going over something, it's like having multiple code reviews a day.\n\nHave seen devs grow faster here than anywhere else in this environment.  \n\nConstant training, constant communication, very clear transparency of where your skills as well as others abilities are at.  The code ends up speaking for itself.", "id": "daqxuf5"}, {"comment": "I just did my first project with (almost) TDD. I can't believe the confidence that I have in that application that I've never had in any other app. ", "id": "dar7wgr"}, {"comment": "When I started working on an existing project, the tests were horrible, using cryptic fixtures, terrible names, and generally you just had no idea if a feature was regression-proof or tested or whatever. When I learned about test-driven development I completely discredited it, because I didn't see HOW it could be useful to write these shit-awful tests before the feature.\n\nNow I'm way more experienced and have replaced most of the tests with actual useful tests, and TDD seems way more sensible to me now.\n\nThere are still parts about it I'm unsure of (how do you predict edge case scenarios without having the system in place to see how they work out?), but having your features backed up with tests gives me so much more confidence.", "id": "dar99jj"}, {"comment": "Well now that makes me nervous that I've actually done a shit job :) I use fixtures because I chose, whether right or wrong, to always start from scratch with the DB every time the tests run. The issue with actually running through the entire app is that\n\n1) I currently don't know Selenium\n2) So much is taking place after an OAuth with a third-party service that I'm needing to use fixtures to fake the process. ", "id": "darawwk"}, {"comment": "Starting with a fresh DB from scratch every time is correct, but the problem with fixtures is that they are separated from your code, and are brittle and hard to change.\n\nFor example, in rails you used to have fixture files that described a user instance for your User model in yaml. \n\n    user_admin:\n      role: 1\n      username: Admin User\n      password: Whatever\n      thing_necessary_for_validation: Valid\n\nNow I can't see at a glance what role '1' is, I need to go check the Role fixture file. And I had to include some bullshit 'Valid' criteria because every user has to have one, even though it's entirely irrelevant to this particular test. This last issue is probably the biggest, though: your fixture file will be fucking HUGE if you have 1 fixture per test, and if you reuse fixtures, that's extremely brittle in the future.\n\nNow, we use FactoryGirl and factories (forgive me if the syntax is wrong, haven't looked at it in a bit):\n    \n    factory(:user) do \n      role: { Role.find_by(name: 'Guest') }\n      username: \"User Name\"\n      password: \"Pass123!\"\n      thing_necessary_for_validation: \"valid\"\n    end\n    \n    \nAnd in my test:\n\n    describe Users do\n      context \"who are admins\" do\n       let(:admin) { create(:user, role: 'Admin') }\n    \n        it \"can do admin-y things\"\n          expect(admin).to have_privledges # or something\n        end \n      end\n    end\n    \nNow if my User validation changes I don't have to fix every fucking fixture, I just change the 1 line in the factory. AND I have a custom-built object that does EXACTLY what it needs to, and NO MORE, for the test it's in.", "id": "dard203"}, {"comment": "This is very smart. Going to fix it tomorrow!", "id": "dardb9t"}, {"comment": "Yea. I am in the process of moving my whole team (and eventually department) to paired programming and TDD. We have another department that does it and results have been amazing. I have been working on a team in that department for the past 6 months and it's awesome. Starting next year, my department (much larger, 100+ developers) will be doing the same over time starting with my teams. \n\nIt has been awesome and the code is miles better than it was with code reviews. With rotated paired programming and test driven development, you really don't need code reviews. ", "id": "dar6rh3"}, {"comment": "Yes, you really do. Even in pairs, developers grow blinders about their code and miss things that someone not involved would catch.", "id": "dard55l"}, {"comment": "In typical paired programming, you do not pair with the same developer everyday. You partner with a new person, meaning everyone will end up touching all the code at some point. This is a constant code review in place.", "id": "darfvdv"}, {"comment": "I enjoy paired programming when I get to do it. All of those delayed discussions are immediate. Haven't gotten into TDD yet. ", "id": "dar3glx"}, {"comment": "I once had the opportunity to ask Kent Beck (name drop!) what was the best thing i could do as a developer to improve, he said without hesitation: write unit tests.", "id": "darcu76"}, {"comment": "Michael Feathers agrees. I got the chance to meet him in the last year.\n\nIn fact, a lot of the more well known people in the field are of similar opinions.", "id": "darf1fp"}, {"comment": "It is the future, especially for large enterprises. Code goes out quicker, deployments are safer and faster, code quality is 10x better...\n\nIt's just hard to convince the business side how much better it is considering the paradigm change it requires and cost it will take to transition. But after a year, the company will be saving 10x as much money as the year before. All the whole you will be super attractive to talented devs. ", "id": "dar6vea"}], [{"comment": "I wanted to add my two-cents to all of the other posts. I'm still trying to grow in this area, so forgive anything that I might've said that comes across as naive. ", "id": "daqp6ul"}, {"comment": "Take a look at the relevant sections in Rapid Development by Steve McConnell", "id": "daqtzn7"}], [{"comment": "I think newbie programmers like code reviews more than experienced developers. I worked for a company once that did code mandatory reviews. Some of the newbies would post hideously broken code reviews in hopes that a more experienced developer would do the work for them. Usually this works, so the newbie walks away loving them.\n\nThe more experienced developer will hate them because rarely any useful feedback comes from them. There was a co-worker I had one time who we'll call the \"float nazi\", who had this belief that floats are evil and decimals are the saviors of all that is holy. Any time he found a float in my code he's go off on a tirade about how any instance of float in the code is a bug and the only way to fix it is to change it to a decimal. No matter how politely I try to explain that in that particular situation the shortcomings of floats don't come into play, it doesn't matter. \"Float nazi\" held a higher ranking than I did at that company, so I was forced to always use Decimal. I should be free to write my code however I want, since I'm ultimately responsible for that code's performance. Code reviews in a way forces design by committee by allowing other people to force my code to be a different than the way I wrote it.\n\nIf this post doesn't get to -50 by the time I wake up I will be disappointed.", "id": "dardvvi"}, {"comment": "> I worked for a company once that did code mandatory reviews.\n\nI've worked for several.\n\n>Some of the newbies would post hideously broken code reviews in hopes that a more experienced developer would do the work for them. Usually this works, so the newbie walks away loving them.\n\nThat's a sign that the junior dev in question needs to be coached and, if needed, let go. This is not an issue that is inherent to code reviews. It is an issue with hiring unmotivated people.\n\n> The more experienced developer will hate them because rarely any useful feedback comes from them. \n\nThis is only true in places that don't really care about code reviews but only want to say that they've done them. Code reviews of code by senior devs in places I've worked with are often as enlightening for both parties as code reviews of jr dev code.\n\n>No matter how politely I try to explain that in that particular situation the shortcomings of floats don't come into play, it doesn't matter. \n\nYou could also use the performance issues suffered by using decimal as an argument in your favor. Decimal, while it has much better precision, is a heck of a lot slower.\n\n>\"Float nazi\" held a higher ranking than I did at that company, so I was forced to always use Decimal.\n\nAgain, this is the sign of a broken org, not something inherently wrong with code reviews.\n\n> I should be free to write my code however I want, since I'm ultimately responsible for that code's performance.\n\nDisagree. You write code to the standards decided upon by the team. This is often part of the team agreement. And the performance isn't just your responsibility, it is the responsibility of your team. This is another thing that code reviews are useful in catching.\n\n>Code reviews in a way forces design by committee by allowing other people to force my code to be a different than the way I wrote it.\n\nNo, code reviews are, among other things, a way to teach you how to be better at your craft. Treat them as a learning experience. You are not always the smartest person in the room, and if you are, you bloody well need to find a different room.", "id": "darfhw5"}, {"comment": "That's not a problem with code reviews, that's a problem with your coworkers. Your juniors were lazy and your senior was too stubborn.\n\nIf you didn't have code review, those juniors would have committed broken code to the repo. And your senior wouldn't missed out on the opportunity to not be a float nazi (even if they still are).", "id": "darmq1h"}, {"comment": "It does not matter whether you like floating or the other guy fixed point numbers, what matters is the context of the use.\n\nDecimal is prominent e.g. in monetary calculations, with good reasons.", "id": "darjl1j"}], [{"comment": "When I join a new team, I want to get on a code review as soon as possible.\n\nSeeing how management handles a code review tells you everything you want to know about being on that team.\n\nWhat? Finding bugs? Yeah, sometimes it helps with that... make me better? Um.. occasionally.", "id": "dar4vop"}, {"comment": "> When I join a new team, I want to get on a code review as soon as possible.\n\n\"We don't do many of those. Everyone here is senior so there's no real point\" \n\nRun now. Of course, they also said they don't do TDD because it takes too long to set up and they have deadlines. Fun stuff", "id": "darf3rf"}, {"comment": "Having done non TDD and very TDD it is very, very clear to me just how nice it is to \"Do what to the Schema? OK... *2 days later of rewiring everything*: And run tests, oh, missed those 3 things, patch, and now it all works! Yay! Done! PR, release, no problems.\" \n\nvs... \n\nI dunno... it *looks* like I did it right and a basic run through shows it works, so let's push it out aaaand... nope, bug fix, more code merging, check in... Aaaand that.... and that. OK, now it's working. Damn, that sucked.", "id": "dargn28"}], [{"comment": "Anyone know where to buy an ebook copy of the book recommended at Coding Horror (Peer Reviews in Software: A Practical Guide)?\n\nIn the author's website there's a sample of chapter 3 in PDF so I'm assuming it must be available somewhere... I just can't find it.", "id": "dar2cvz"}, {"comment": "[If you have a Kindle](https://www.amazon.com/Effective-Programming-More-Than-Writing-ebook/dp/B008HUMTO0)", "id": "dar6yqo"}], [{"comment": "This is from clean code by Robert Martin?  Good book. I didn't agree with everything he says,  like he doesn't like switch statements.\nBut lots of it is good sense.\n\nShould also check out dependency injection by Mark Seemenn. \n", "id": "dar7326"}], [{"comment": "... morning, do you do code review?\n\n true\n\nHIRED!!", "id": "dar875q"}], [{"comment": "We do code review before all pull requests are merged in my office and I have to say I love the practice because it forces you to look at your code through a more objective lens, fixing things you didn't think to change before.\n\nI think it also helps you improve as a developer overall because you get to take direct feedback on your code and then hopefully next time you do a pull request, there are less issues with your code during code review.\n\nIn my experience, code review is more a time to clean up and polish the code than it is to correct and change course. Maybe we suggest you write a few extra tests to account for a case that wasn't considered initially, or maybe there's some duplication that can get cleaned up...it's never a judgmental process as long as whoever is being reviewed is open to the suggestions and changes.", "id": "darae58"}], [{"comment": "Code review is the most frustrating thing you can do, yet the most important one as well. Even a single pass of review will catch a lot of bugs and shortcomings. Not doing a first pass of review is neglectance.", "id": "darqg8w"}], [{"comment": "Movie reviewers have opinions. It's hard to please them all, especially when you're given two weeks to produce something.\n\nIt's okay to do early, pre-production _reivews_ often with your teammates. But, each of you don't have to believe your sense of aesthetics is canon. And no, not all movies have to be oscar worthy. There are different genres and styles. And yes, genre mixing and crashing is totally fine in a single movie.\n", "id": "daqvnhn"}, {"comment": "Well code reviews need to be un-opinionated by being based on standards. Most all companies have standards, and that is what the reviews should be held on. If something catches the eye of a developer while doing a code review or having their code reviewed, then it should be brought up among all the devs to talk about in terms of best practice. \n\nNot all standards fit for all applications, but standards do make code consistent and readable. ", "id": "dar727k"}, {"comment": "> Most all companies have standards\n\nha\n\nha\n\nha\n\nan example standards to share?", "id": "darb8si"}, {"comment": "Well the past 3 places I worked had them...it is something i ask (assumingly) in my interviews too. If a company does not not have standards, I question their legitimacy. ", "id": "darcec7"}, {"comment": "Oh I see. only standards I've seen is half complete markdown files on github. and most of them could be easily enforcable by using custom linter/formatter.\n", "id": "darcz1c"}, {"comment": "> Well code reviews need to be un-opinionated by being based on standards.\n\nI don't see how it's possible to completely eliminate opinion from all possible points of discussion.", "id": "darhsj6"}, {"comment": "The review itself isn't based on opinion. Also, standards should be peer driven, meaning all the developers have input. Think democratic.", "id": "darifjq"}, {"comment": "> The review itself isn't based on opinion.\n\nI'm not quite sure what you mean by this.\n\n> Also, standards should be peer driven, meaning all the developers have input. Think democratic.\n\nSure, I don't have an issue with that.", "id": "darihnh"}, {"comment": "The review would only be based on the standards and not what the reviewer thinks. Since the standards are peer driven, that means that the reviewer should only comment on the issues that are against the peer reviewed standards. If there is a dissagreement with the review (which should be based on the standards), then the developer should bring the argument up with the other peers. After discussion, the standard will either be changed or remain the same based on the decision of the peers. All further reviews would follow the new standard.\n\nEasy peasy lemon breasy. However, I am still more for having standards and doing paired programming with TDD.", "id": "darlpma"}, {"comment": "> The review would only be based on the standards and not what the reviewer thinks.\n\nThat sounds like it would take a ton of potential discussion off of the table, as covering every potential topic of discussion in some sort of written standard doesn't sound feasible to me. Maybe you're OK with that, but I'd prefer a more open format to code review, I think.", "id": "darlxtk"}], [{"comment": "My first codd reviews let me know very bluntly where my weaknesses were and with enkugh tutilage from my reviewers, also about how to fix them.\n\nNitpicking however haha I do drive some of my team nuts when im nitpicking their contributions to my projects, but i do it with the best of intentions to help improve the up front quality of code written before submissio, and in some cases suggest or introduce altnernative approaches to an implementation. In my expectation I fully expect them to return the favour, and they do. ", "id": "darb0b2"}]]], "5fxio6": ["Bro, do you even map? MapReduce demystified", "2016-12-01 19:34:43", 5, "https://dev.to/aurelherve/bro-do-you-even-map-mapreduce-demystified", [[24, "This article is about the map and reduce functions provided by most modern languages.  It is not about MapReduce."], [7, "> We will use typescript for even more readability\n\nHahaha. cry."], [5, "Good article. One critique - you should state what programming language your examples are using. The 1st example took me a second to realize it was javascript - the boolean operation confused me until I realized it was JS and a zero is equivalent to false in an if statement.\n\nIf anyone wants a [Ruby map/reduce example](https://github.com/pgibler/map_reduce_expenditures), I have one in my github repo you can try out :) ."], [1, "Any thoughts on the first example taking only 5 iterations of a list, whereas the 2nd is 11 (I assume)."]], [[{"comment": "This article is about the map and reduce functions provided by most modern languages.  It is not about MapReduce.", "id": "danuaxn"}, {"comment": "The programming model is roughly the same, or at least the terminology has been borrowed.  Yet I agree, that is click bait.   \n\nWhen you say \"MapReduce\", we're talking parallel/distributed functions manipulating data in a cluster, which comes with far more steps and terminology than simply writing Javascript filter/map/reduce functions.  The former you could spend a day just getting set up, the latter as this article has shown, can be written in 2 minutes.\n\nShould have just called it \"Functional Programming demystified\".  Even then, it says nothing on the topics of mutability, state... *sigh*", "id": "dao0pd1"}], [{"comment": "> We will use typescript for even more readability\n\nHahaha. cry.", "id": "danw2ct"}, {"comment": "I liked the article, but in this case, at least, typescript just added a bunch of noise ...", "id": "dao229w"}], [{"comment": "Good article. One critique - you should state what programming language your examples are using. The 1st example took me a second to realize it was javascript - the boolean operation confused me until I realized it was JS and a zero is equivalent to false in an if statement.\n\nIf anyone wants a [Ruby map/reduce example](https://github.com/pgibler/map_reduce_expenditures), I have one in my github repo you can try out :) .", "id": "dantqj4"}], [{"comment": "Any thoughts on the first example taking only 5 iterations of a list, whereas the 2nd is 11 (I assume).", "id": "dany6v6"}, {"comment": "Unoptimized, yes the first is way faster. Languages with strong FP can optimize things like this pretty easily though.\n\nScala offers streams that given a large chain of map/filter/fold/whatever functions, will only be traversed once when called.", "id": "dao0rbx"}, {"comment": "purefunctional languages will most likely lazily evaluate and iterate once. JS isn't one of those languages. I believe c# does something like that with linq but I'm not sure, even though c# isn't purely functional.", "id": "dao8apr"}]]], "5fiq6n": ["do {...} while (0) in macros", "2016-11-29 16:50:05", 1368, "http://www.pixelstech.net/article/1390482950-do-%7B-%7D-while-%280%29-in-macros", [[198, "Is the while(0) something that gets optimized away by the compiler or is the resulting code still doing some kind of test?"], [122, "Note that this is the ONLY non-insane usage of do {...} while (0).\n\nAt a previous job, I had a coworker who would have nearly his entire function (in C++ mind you, but this is almost as insane in C) bodies wrapped in a do-while-false loop so that his failure conditions could just do a 'break' to get to the 'exit' condition.\n\nIn C, the 'goto fail' is significantly more readable, and in C++ RAII exists for a reason :)"], [74, "... But then why not first make a macro MACRO like:\n\n    #define MACRO(macro) do { macro } while (0)\n\nSo you could use it while defining other macros?"], [59, "also this forces the user to add a semicolon on the end."], [41, "It's worth noting that \n\n    #define foo(x)  if(1){ bar(x); baz(x); }\n\nwould not work either, because it can mess up nested if blocks, as well as the potential syntax error from bare braces.\n\n    if (test1) \n        foo (10);\n    else\n        do_stuff();\n\nwould become\n\n    if (test1) {\n        if (1) {\n            bar(10); \n            baz(10);\n        };\n        else\n            do_stuff();\n    }\n\nEdit: missed semicolon (important!) \n"], [32, "Why would you use a macro instead of a function (probably with inline) in this way?"], [20, "If you are using GCC or Clang exclusively (many other compilers probably support them, though it is a non-standard feature), \"statement expressions\" can be very handy especially when you need function-like macros which return a value:\n\n    #define maxint(a, b) ({ \\\n        int _a = (a), _b = (b); \\\n        _a > _b ? _a : _b; \\\n    })"], [22, "Can you avoid braceless `if`s instead?"], [22, "\\**disgusted head-shaking**"], [15, "I was kinda surprised to see this on front page.  Anyone who's done C professionally for any length of time has run into this trick."], [10, "This is a risky idea. What if, for some reason, the macro expansion produces a *break* statement? In that case, the *do{}while(0)* will change the meaning of it. Just wrapping it in an *if{}* has the problems described, but you can extend that to work correctly with *if{}else((void0)*.\n\nA real-world example from my current codebase:\n\n    #if NDEBUG\n        #define WARN_AND_FIX(condition, fix) \\\n            if (condition) { \\\n                fix; \\\n            } else ((void)0)\n    #else   \n        #define WARN_AND_FIX(condition, fix) \\\n            if (condition) { \\\n                WriteWarningMessage(#condition, __FILE__, __LINE__); \\\n                fix; \\\n            } else ((void)0)\n    #endif\n\nAnd with that, you can safely write (excuse the trivial example):\n\n    for (int i = 0; i < 10; ++i) {\n        WARN_AND_FIX(i > maxAllowable, break);\n    }\n\nThat still works with semicolons. It still doesn't mess with other surrounding *if* statements. But with if{}else((void)0)* the *break* works as expected whereas *do{}while(0)* turns the *break* into a no-op.\n\nEdit: formatting"], [9, "Looks like a cool trick. Can you make it into npm package?"], [7, "nice article, I really like how people find interesting \"loopholes\" in programming languages, just so they can code better"], [6, "For related fun: https://gustedt.wordpress.com/2011/02/02/handling-control-flow-inside-macros/"], [3, "Why use do {...} while (0) instead of if (1) {...}?"], [2, "Note, this is for C, not C++. Don't do this shit in C++, and you should think twice before using it in C.\n\nIn C++, don't use custom marcos except to exclude code. (Like header guards, or OS specific code) Don't write a function into a macro. Don't define constants in macros.\n\nWhy?\n\nYou don't get handles to debug things in macros, [if it can be done in code] you can't do anything more efficiently in macros than you can in code. Use a const. Use an inline function. These will be just as efficient, and you can actually step through to see what is happening.\n\nCase in point?\n\nDownload [this shit](http://www.cs.utexas.edu/users/cart/code/ss-ppc-big.tgz), build it (good luck), and step the debugger through this part of sim-cache.c in sim_main()\n\n \n\t\tswitch (op)\n\t\t{\n\t#define DEFINST(OP,MSK,NAME,OPFORM,RES,FLAGS,O1,O2,I1,I2,I3,O3,O4,O5,I4,I5)\\\n\t\t\tcase OP:\t\t\t\t\t\t\t\\\n         \t\t\tSYMCAT(OP,_IMPL);\t\t\t\t\t\t\\\n          \t\t\tbreak;\n\t#define DEFLINK(OP,MSK,NAME,SHIFT,MASK1,MASK2) \\\n        \t\tcase OP:\t\t\t\t\t\t\t\\\n        \t\t\tpanic(\"attempted to execute a linking opcode\");\n\t#define CONNECT(OP)\n\t#define DECLARE_FAULT(FAULT)\t\t\t\t\t\t\\\n\t\t\t{ fault = (FAULT); printf(\"inst %x pc %x\\n\", inst, regs.regs_PC); break; }\n\t#include \"machine.def\"\n\t\t\tdefault:\n        \t\t\tpanic(\"attempted to execute a bogus opcode %x %x\", regs.regs_PC, inst);\n\t\t}\n\nI had to modify this shit for a class project once. The idea was to cache [basic blocks](https://en.wikipedia.org/wiki/Basic_block) to attempt to improve processor performance. Turned out to be a real pain because of the macro expansion.  (and we found caching basic blocks to be a really bad idea if anyone is curious) \n\n----\n\nEdit: Added [if it can be done in code]."], [2, "All the examples seem like simple expressions.  Is there an advantage to using do..while and forcing it to be a statement rather dan just using a comma and some extra brackets in these cases?  This is the way I would have done those:\n\n    #define __set_task_state(tsk, state_value)      \\\n        ((tsk)->state = (state_value))\n\nand\n\n    #define foo(x)  (bar(x), baz(x))"], [2, "At that point I'd generally go with a function call. I understand macros may help performance but I'm not too fond of them and their indirection and readability issues."], [2, "This is the kind of thing the GNU Statement Expression extension is great for."], [2, "I thought nost people knew this already "], [2, "I wish they would support this pattern in the language. Whenever you need to resort to a hack to solve a common problem, it indicates a defect or at least omission in the language. "], [2, "Long time C/C++ programmer, I thought basically knew everything there is to know \u2192 Still learning ! \n\nThank you reddit for making me humbler and better !"], [1, "This is a little over my head. Is there a good reason to use this in other languages like Java or C#?"], [1, "Damn, that's a very cool trick!"], [1, "There is a lot of stuff missing from C that is mandatory for any decent level of a metaprogramming. And I'm not talking about the preprocessor only. This stuff is useful in any kind of a generated code.\n\nOne is this, a simple block statement. `do ... while(0)` sort of solves it, but it's dirty. \n\nAnother one is a statement in place of an expression - there is a lot of cases where you might want to do it, especially in a generated code. \n\nAnd my favourite construct that is missing from most of the languages - *lifting* a statement, a struct/class member or a top level statement from some nested level up to where it belongs. Is not it handy to have a macro expanding into an expression which *defines a function* in your top-level context if it is needed?"], [1, "the other thing about macros is to put a ( ) around all uses of a macro parameter: like \n\n          #define UTIL_TEST_BIT(bitMask, bitIdx) ((bitMask)[ (bitIdx) >> 3 ] & ( 1 << ( (bitIdx) & 7) ) )\n\nThis way you will not be surprised if somebody puts in an expression when the macro is used.\n\nthe do..while thing is needed when the macro spans multiple statements; \nin this case \n\n           if (...) MACRO_WITH_MULTIPLE_STATEMENTS\n\nwill have only the first statement of the macro conditioned by the if, in most cases this will not have been your intention. With the do-while thing you can also have local variables in the macro - without fearing that these will clash with variables defined in the calling code.\n\nIn most cases an inline function will be better than a macro - much less posibilities to break things (unless you need token pasting or some even more ugly stuff).  Gcc has \\_\\_inline\\_\\_ for C , in C++ you have standard inline keyword.  The Linux kernel has some really ugly macro stuff - like this here http://stackoverflow.com/questions/9229601/what-is-in-c-code"]], [[{"comment": "Is the while(0) something that gets optimized away by the compiler or is the resulting code still doing some kind of test?", "id": "dakltx0"}, {"comment": "Yes, the while(0) is optimized away. No test is executed in the final code", "id": "dakmbfx"}, {"comment": "It's a very trivial optimisation, so yes.", "id": "dakmzl3"}, {"comment": "C (and C++ and probably any other language where you'd be able to make use of this) doesn't specify what optimizations will be made in the language spec. Whether or not this will be optimized away is an implementation detail.\n\nThat said, it's a very trivial optimization, so virtually any non-toy compiler made in the last 20 years will remove the test in the generated code.", "id": "dal932z"}, {"comment": "> (and C++ and probably any other language where you'd be able to make use of this) \n\nExcept for (N)RVO, which is required for standard compliance IIRC.", "id": "dalcd6a"}, {"comment": "Guaranteed copy elision is only in C++17 (which is still technically draft) and doesn't include NRVO.", "id": "dalf2mv"}, {"comment": "It is true, though, that (N)RVO is allowed by the standard to alter observable behavior, which is pretty unique among allowed optimizations.", "id": "dalmo2k"}, {"comment": "You can test this (with a specific version of GCC or clang) here: https://godbolt.org/g/LVR0Bc -- note that the output for square1 (with the `do...while (0)`) and square2 (without it) is identical.", "id": "dakt11q"}, {"comment": "[Dead Code Elimination](https://en.wikipedia.org/wiki/Dead_code_elimination)", "id": "dakw744"}, {"comment": "I don't understand the if (0) debug print example. I get that the optimized version will just eliminate the statement, but the non optimized version will never execute the printf either.", "id": "dalonu9"}, {"comment": "You're right.\n\nChances are this block would have been generated by some macro like like DEBUG(printf(...)), which executes the argument for debug builds and wraps the statement in if (0) for release builds. ", "id": "dalq94w"}, {"comment": "As I understand it if you're debugging you'd turn it into `if (1) \u2026` and recompile.", "id": "dalp7vw"}], [{"comment": "Note that this is the ONLY non-insane usage of do {...} while (0).\n\nAt a previous job, I had a coworker who would have nearly his entire function (in C++ mind you, but this is almost as insane in C) bodies wrapped in a do-while-false loop so that his failure conditions could just do a 'break' to get to the 'exit' condition.\n\nIn C, the 'goto fail' is significantly more readable, and in C++ RAII exists for a reason :)", "id": "dakt8bv"}, {"comment": ">In C, the 'goto fail' is significantly more readable\n\nI don't really agree with this. At the very least, I don't consider it insane.\n\nFor those following along, parent is talking about code like this:\n\n    do {\n      int rv = foobar(x, y, z);\n      if (rv < 0) break;\n\n      rv = barfoo(a, b, c);\n      if (rv < 0) break;\n\n      // continue with non-error logic\n    } while (0);\n    // clean up\n\nvs\n\n    int rv = foobar(x, y, z);\n    if (rv < 0) goto FAIL;\n\n    rv = barfoo(a, b, c);\n    if (rv < 0) goto FAIL;\n\n    // continue with non-error logic\n\n    FAIL:\n    // clean up\n\nThe version with `break` has some advantages, IMO:\n\n* You don't have to worry about correlation of the label use. (E.g., you can use the construct twice in the same function without having to come up with different \"FAIL\" labels.)\n* Where the jump goes is clear through lexical scoping. With goto, it could possibly jump backwards, but break cannot do that.\n* The loop requires a lexical scope, so variables defined within it cannot be used outside it. This is especially useful in C90, where variables can't be declared mid-scope.", "id": "dakvjyi"}, {"comment": "But the `while`/`break` way has significant *dis*advantages.\n\n* First, consider your argument that variables defined within the loop can't be used after. But that comes with a flip side: that means you must declare anything you need to clean up outside the loop, otherwise you can't clean it up. And while I understand that this is a lot less idiomatic (and a lot less important!) in C than in C++, that means you can't declare at point of first-use. (Actually that's not even a good argument in the first place because you can always put in a random block and still use `goto` if that's what you want.)\n* You can't have multiple fail points. (In other words, I think your first point is an argument against, not in favor.)\n* Put those together, and that way will sometimes (maybe even always) be slower because you'll have to (i) initialize all your resources with a dummy value and (ii) check them at the fail point to see if you need to clean them.\n* I hope nothing in a loop can fail.", "id": "dakw522"}, {"comment": ">that means you must declare anything you need to clean up outside the loop\n\nIn C90, that's a huge boon because you aren't polluting the larger scope unless you want to. In C99, defining them just above the loop is trivial, and avoiding the possibility of jumping over an initialization is an even bigger boon.\n\n>You can't have multiple fail points.\n\nThat's a feature. Seriously, if your fail labels are order-dependent (which they probably are if you need multiples), I hate you.\n\n>Put those together, and that way will sometimes (maybe even always) be slower because you'll have to (i) initialize all your resources with a dummy value and (ii) check them at the fail point to see if you need to clean them.\n\nYou usually have to do this with goto FAIL anyway. E.g.,\n\n    int *mem = 0;\n    int bytes = get_size();\n\n    if (bytes < 0) goto FAIL;\n    mem = malloc(bytes);\n\n    if (!mem) goto FAIL;\n\n    // use mem\n\n    FAIL:\n    free(mem);\n\nIf we skipped the initialization of `mem` to 0, we get undefined behavior when `get_size` fails.", "id": "dakwwja"}, {"comment": "> That's a feature. Seriously, if your fail labels are order-dependent (which they probably are if you need multiples), I hate you.\n> \n\n\nI'm sorry but this statement belies your experience with C. The following is an extremely common idiom (pardon the indentation because reddit sucks):\n\n\n        int load_firmware() {\n        if (enable_regulators())\n                goto regulator_failed;\n\n        if (enable_clocks())\n                goto clocks_failed;\n\n        ptr = malloc(something large);\n        if (!ptr)\n                goto alloc_failed;\n\n        if (something)\n                something_failed;\n        return 0;\n\n        something_failed:\n                free(ptr);\n        alloc_failed:\n                disable_clocks();\n        clocks_failed:\n                disable_regulators();\n         regulators_failed:\n\n        return -1;\n        }\n\nIt's a completely elegant way of \"unwinding\" the order of operations (which is really the point of using `goto`s).   If you don't want order to matter, you'd need to copy/paste error handling code multiple times.\n\nI'd be interested in seeing how you'd preserve the logic above without gotos (for the goto haters lurking in this thread) or without the order of labels mattering.", "id": "dal28l1"}, {"comment": "\"Belies\" doesn't mean what you think it means.\n\n> 1. (of an appearance) fail to give a true notion or impression of (something); disguise or contradict.\n\"his lively alert manner belied his years\"", "id": "dalbl87"}, {"comment": "It looks like acceptable usage to me. GP was saying that my statement contradicted my implicit claim of experience in C. It follows the same semantic pattern as the example you quoted.", "id": "dam1czp"}, {"comment": "Is there a good reason to use something like this rather than have a function to load each, which then tries to load the next part and takes care of it's own cleanup if something fails?", "id": "dalhwaz"}, {"comment": "You mean chain the function calls?  That'd reduce the usefulness of the functions wouldn't it? For instance you might want to enable or disable clocks somewhere else where you don't want to allocate memory.", "id": "daljq4j"}, {"comment": "As-is you only have one function that does everything anyways. ", "id": "dalt3wc"}, {"comment": ">I'm sorry but this statement belies your experience with C.\n\nIt does nothing of the sort. I didn't say it's not used, I said I don't like it. And I don't.\n\nI don't like it because it's brittle. Changes to the order of initialization have to be synchronized with order of cleanup. That isn't \"elegant\", it's poor engineering.\n\n>If you don't want order to matter, you'd need to copy/paste error handling code multiple times.\n\nNo, you just need to keep track of what's been initialized and what hasn't.", "id": "dal3iod"}, {"comment": ">No, you just need to keep track of what's been initialized and what hasn't.\n\nWith more variables?  That'd work but having more variables means having more state, which just translates to having more bugs.", "id": "dal3reb"}, {"comment": ">With more variables?\n\nIf necessary, yes.\n\n>That'd work but having more variables means having more state\n\nYou already have that state, its just implicitly encoded in the sequence of the code rather than explicit. Any time you rearrange your code, you have to a) be aware that this implicit state even exists and b) worry about how it changed that implicit state.", "id": "dal3xxs"}, {"comment": "I'll chime in and say that you're trading state for code paths. You get a whole lot more potential branches to follow if your setup/teardown is buggy. That's no better than keeping state, although it's not necessarily worse, either. Depends on the situation.", "id": "dalbs5v"}, {"comment": "Your argument has boiled down to \"Hitting yourself in the head with a hammer is the wrong way to do it, you should use a cast iron skillet instead\"", "id": "dalp6q2"}, {"comment": "It's C++ if it doesn't feel like you're hitting yourself with something you're doing it wrong.", "id": "dalqegu"}, {"comment": "I really don't understand your point. I guess you're saying that both techniques are wrong. So what technique do *you* use for resource cleanup in C?", "id": "dam0az8"}, {"comment": "To add on to /r/mcur's correction, it's likely you were thinking of the verb phrase \"to give lie [to]\" instead of \"to belie\". \"This statement gives lie to your experience with C\" means what you appear to have meant to mean.  ", "id": "dalc3he"}, {"comment": "You'd just nest the loops. The depth of nesting shows the scope and control flow in a way that the 'nested' gotos don't.", "id": "dallh95"}, {"comment": "> In C90, that's a huge boon because you aren't polluting the larger scope unless you want to. In C99, defining them just above the loop is trivial, and avoiding the possibility of jumping over an initialization is an even bigger boon.\n\nIf you think it's better, you can still do it without somewhat-funky and misleading abuses of `break`:\n\n    void frob_the_thing() {\n        int * mem = 0;\n        {\n            int bytes = get_bytes();\n            if (bytes < 0) goto fail;\n            ....\n        }\n        fail:\n        free(mem);\n    }\n\n> You usually have to do this with goto FAIL anyway. If we skipped the initialization of mem to 0, we get undefined behavior when get_size fails.\n\n... unless you skip the cleanup of `mem` when `get_size` fails, though admittedly this does put me into the \"I hate you\" case. :-)", "id": "dakx6pq"}, {"comment": ">without somewhat-funky and misleading abuses of `break`\n\nI think this is the main issue. I really don't see it as an abuse of `break`. I always saw it as a restricted `goto` even before I saw anyone use this technique. (The inability to `break` upwards *alone* is enough to reasonably justify its use, IMO, the rest is all gravy.)\n\nWould using `continue` (which has the exact same effect) not bother you as much?\n\nDespite my tone, I'm not really sure I prefer one method to the other. I see them both having strengths and weaknesses. I'm only arguing because you said pretty strongly that one should *never* use `break` for this, and I see valid arguments both ways.", "id": "dakxqaa"}, {"comment": "I think I could have said my argument about the abuse better -- I'm actually less concerned about it abusing *break* and more about abusing *do-while*.\n\nIf I start looking at a function and see `do` sitting there, I'm going to start expecting a loop, and reading it in that context; seeing the `while(0)` at the bottom of the loop would require a brief reevaluation. Even if I know I'm working on a code base that uses this idiom, now I'd have to check each time I see a loop \"is this a *loop* loop, or a fake-error-handling 'loop'?\" (I guess it's not every loop, and ~do~ loops are the least common of the three, but still.)\n\nThis isn't exactly *hard* to do, but I think it's the same sort of \"reducing surprise\" argument that justifies a lot of coding conventions.\n\nWhat I can't decide is whether I would like\n\n    #define ERROR_LOOP do   // or maybe even TRY_LOOP\n    #define END_ERROR_LOOP while(0)\n    #define FAIL_BREAK break\n\nor something like that. I think it would alleviate most of my problems with it because there'd be no confusion with real loops, but this is the kind of thing where I think the cure might be worse than the disease. :-)\n\nNow that said, I don't exactly have a dog in the game either; I try to do as little C programming as I can get away with. I would use C++ in basically any scenario where I have a C++ compiler. So maybe my objection wouldn't be as... real in practice as I would fear. And it's not that I think there are *no* arguments for `break`, just that I think the arguments against are better.", "id": "dakyhsb"}, {"comment": ">more about abusing do-while\n\nOK, good point. It just occurred to me that you could actually use a switch for this rather than a do loop, which makes it a little more natural. A quick search shows some talk about this on SO, so I'm not the first to think of it (of course).\n\n    switch(0) default: {\n      if (!initialize()) break;\n      // etc\n    }\n    // cleanup", "id": "dam3kc5"}, {"comment": "> First, consider your argument that variables defined within the loop can't be used after\n\nThat is inherently risky because of the possibility of missing an initialization by accident. This is why you can't skip over a nontrivial constructor or VLA with a goto.\n\n*Personally* if I think a better solution is to not use either the do while trick or gotos, but to refactor the block into its own function and use `return` to exit early.", "id": "dal7yfw"}, {"comment": "Well OP is talking about c++. I'd consider acceptable for c code but not c++. ", "id": "daldzjd"}, {"comment": "In C++, you should use RAII", "id": "dalkwms"}, {"comment": "Precisely. ", "id": "dalqaxp"}, {"comment": "> The loop requires a lexical scope, so variables defined within it cannot be used outside it. This is especially useful in C90, where variables can't be declared mid-scope.\n\nYou give good arguments, but I don't agree with this one. Since the subscope is merely *required* by the loop rather than allowed because of the loop, you can use the the subscope without the loop if you have a need for it - so this is hardly an advantage over not using the loop.", "id": "dalvzbd"}, {"comment": "But goto is evil and should never be used.\n\n/s", "id": "dakw3yr"}, {"comment": "Ah the Sith approach to programming: dealing only in absolutes!", "id": "dal0bs2"}, {"comment": "Ugh. At my work team decided some day, that they will \"consider goto harmful\". Now they use GCC's nested functions for cleanup. No standards compliance, broken static analyzers, but - yeah! - no goto.", "id": "daldbwr"}, {"comment": "I like nested functions for some things[1], but that's disgusting.\n\n[1] Where the alternatives are endless cut and pastes, macro's or helper functions that are only used by one function.\n\n", "id": "dalue7n"}, {"comment": "That's what I always called the practice of do while 0 with breaks an example of letter of the law versus spirit of the law. Letter of the law says don't use goto. The spirit of that law was \"avoid code with lots of early exits and jumps.\" do while 0 does not avoid early exits and jumps, so it violates the spirit of the law.", "id": "dakza3q"}, {"comment": "The point of using break in a do loop isn't to avoid goto for the sake of avoiding goto. (At least to me it's not, maybe it is to some people.) The point is that a break is less powerful than a goto (because it can only jump down, never up), so it reduces the cognitive overhead of figuring out would the statement could do. (It also avoids the overhead of having to maintain non-conflicting label names.)\n\nI'm not saying that one should never use goto and should use do/break instead, I'm saying that there are trade-offs and valid reasons to use either.", "id": "dam3874"}, {"comment": "Exactly!  You don't want to be the one to blame when the raptors come now, do you?", "id": "dald98j"}, {"comment": "That's what you get for irrationally bashing into people's heads that gotos are, without exception, haram.", "id": "dalitoj"}, {"comment": "While I'm fond of the 'goto fail;' idiom (haven't had occasion to use it or see it used in the wild, however), I think I like the `do {...} while(0)` idiom as well. The reasons /u/curien give are compelling, for one. I can see reasons for both idioms -- `goto fail` would work well if there are multiple failure cases to consider (e.g. depending on current state), for instance. ", "id": "dakw2yv"}, {"comment": "I wrote an emulator program for a 2d laser scanner that is used to run a different brand of scanner on a legacy system. \n\nIt's kind of a state machine - the legacy code sets up numerous parameters on the old scanner, which get translated to the new scanner's control codes and each one has to succeed (with a corresponding return packet to the system) before you can progress onwards. After all of that setup is done, it's a simple loop that takes data from the new scanner, converts data types and constructs packets to send to the old system. But any failure of the setup sequence - and the loop - has to be dealt with in the same way (closing sockets, resetting the scanner, sending an error/reset packet to the old system), so if there's a problem in the setup sequence (which is 6 or 7 steps, from memory) I use gotos to hop to the failure block down below the conversion loop and the state is reset back to the starting point. \n\nThis basically makes the whole setup and loop function about a hundred lines long - with about 20 lines of that being the failure section.\nI looked at other ways of doing it, and they all seemed to involve either a lot of code duplication, or spreading that 100 line block out all over the place - which to me, looked like it would be a mess to debug. So gotos looked like the best way forward there.\n\n", "id": "dal66z6"}, {"comment": "Sounds like a good use of `goto` to me. ", "id": "dal7qgf"}, {"comment": "I think that most projects that use `goto fail` (like the linux kernel) will not use multiple labels. Don't quote me on that though", "id": "dalme5x"}, {"comment": "> I think that most projects that use `goto fail` (like the linux kernel) will not use multiple labels. Don't quote me on that though\n\n~ */u/StripTheFlesh*", "id": "dalmebz"}, {"comment": "May you never pass the turing test you snarky bot", "id": "dalmgec"}, {"comment": "I don't have any evidence to support nor refute your statement. I can certainly conceive circumstances where multiple labels are appropriate. Somewhere else in this thread, the example of unwinding an initialization sequence was mentioned. ", "id": "dalnid3"}, {"comment": "Sometimes you have an 'opps' condition and an actual error where something terrible has happened.\n    \n    if(/*opps*/)\n       goto nope;\n    \n    if(/*horrid*/)\n       goto fuck_me;\n", "id": "daluiqb"}, {"comment": "Of course, there's another option. Write more functions. =P", "id": "dan8k4a"}, {"comment": "I've never done this to an entire function, but I'm guilty of occasionally writing a \"do if { /* ... */ } while (false);\" instead of using goto if I'm going to need to escape the if statement in multiple places. ", "id": "dam04o2"}], [{"comment": "... But then why not first make a macro MACRO like:\n\n    #define MACRO(macro) do { macro } while (0)\n\nSo you could use it while defining other macros?", "id": "dakqvek"}, {"comment": "You could. `MACRO` is probably a bad name, since you don't want this for *all* macros\\*. So you get a name like `STATEMENT_MACRO` or something like that. But now it's longer than the raw construct, and the raw construct is so common that it could seem like obfuscation rather than helpful abstraction.\n\n\\* The reason we don't want this for all macros is because it prevents using the macro as a non-statement expression. For example, `if (BIT_SET(x, 3))`is a syntax error if the `BIT_SET` macro uses the `do...while` construct.", "id": "daksjdm"}, {"comment": "Check out [GCC statement-expressions](https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html). Your macro can be ({ thing1(); thing2(); }) and it can be used as either a statement or an expression. \n\nEDIT: clang supports them too.", "id": "dalttwg"}, {"comment": "This is a style choice, so you're free to disagree with me, but I don't think that it's valuable to make that macro for a few reasons.\n\nFirst, it's an easy pattern to remember. This is so common that I would consider it idiomatic for the C preprocessor, and a C/C++ programmer should strive to understand it better/use it more if it's not second nature.\n\nSecond, it's an abstraction for the sake of an abstraction. You ultimately save a little typing if you use it a few times, but you obscure a clear behavior that is unlikely to change in the future. It's probably been in wide-spread use for forty years.\n\nThird, the name isn't accurate. Since not all macros want to use it, it should be named something besides \"MACRO.\" Maybe \"VOID_FN_MOCK_MACRO\" is better? Not really saving typing anymore...", "id": "daksy23"}, {"comment": "Abstraction for the sake of abstraction must be one of the most harmful behaviors programmers can engage in when it comes to bug count, maintainability, and frequently performance.  Really, *really* terrible habit.\n\nEdit (to elaborate): The problem isn't abstraction, it's this kind of intellectual laziness or frustration that sometimes motivates it.  Then it's not so much a tool to encapsulate complexity and present a simpler face to the consumer, but rather that the programmer struggled to understand the complexity in the first place and hoped the problem would simply go away by definition if it was hidden.  Almost without fail, that leads to a terrible, leaky abstraction with gotchas that the consumer can only ever hope to understand and avoid by keeping in mind the implementation; kind of defeating the point of abstraction in the first place.\n\nOr sometimes you get the idea people were just bored.  It wasn't enough to solve the problem; we need to leave behind the tools that could equally be used to rebuild the pyramids or convert css selectors into html-matching regexes - you never know! Kind of the opposite cause, but not exactly a much better outcome.", "id": "daku74i"}, {"comment": "A more forgiving way of looking at the problem is that figuring out the correct \"fault lines\" at which to introduce an abstraction layer tends to be *really* hard, and often only evident in hindsight.\n\nIt's like finding a best-fit line for a dataset. An abstraction layer which over-fits the underlying API is abstraction for the sake of abstraction. One which under-fits isn't useful, and ends up needing holes punched in it to actually get anything done- which, of course, also makes it seem like abstraction for the sake of abstraction! And of course, if those holes are patched by adding surface area to the abstraction, you end up with the worst of both worlds: haphazard overfitting for specific use cases, and useless underfitting for everything else.", "id": "dalkce7"}, {"comment": "It's not a style choice, that macro would break if there is a `,` anywhere in the code: http://codepad.org/5HZhar0Z", "id": "dal13d1"}, {"comment": "That's exactly what I do. I define `MULTI_STATEMENT_MACRO` and then never use it directly, but only use it inside other macros. I find it much easier to grok and more self-documenting than the `do ... while (0)` idiom. Examples below.\n\nDefinition:\n\n    #define  MULTI_STATEMENT_MACRO(x)  do { x } while (0)\n\nAnd using it in a \"swap the contents of two variables\" macro:\n\n    #define  SWAP(x,y)  MULTI_STATEMENT_MACRO( const typeof(x) t = x; x = y; y = t; )\n\nAnd in a branchless integer square root function:\n\n    uint32 uint64_sqrt_branchless_binsearch(const uint64 n)\n    {\n      uint64 a = 0, a2 = 0, b2;\n\n      #define  BIT(i)  MULTI_STATEMENT_MACRO(                                 \\\n                         b2 = a2 + (a << (i + 1)) + ((uint64)1 << (i << 1));  \\\n                         a2 += (b2 - a2) & -(uint64)(n >= b2);                \\\n                         a += (uint64)(n >= b2) << i; )\n\n      BIT(31); BIT(30); BIT(29); BIT(28); BIT(27); BIT(26); BIT(25); BIT(24);\n      BIT(23); BIT(22); BIT(21); BIT(20); BIT(19); BIT(18); BIT(17); BIT(16);\n      BIT(15); BIT(14); BIT(13); BIT(12); BIT(11); BIT(10); BIT(9);  BIT(8);\n      BIT(7);  BIT(6);  BIT(5);  BIT(4);  BIT(3);  BIT(2);  BIT(1);  BIT(0);\n\n      #undef   BIT\n\n      assert(uint64_verify_sqrt(n, (uint32)a));\n      return (uint32)a;\n    }\n\nAnd in a stack-memory-allocation macro:\n\n    #define  STACK_ALLOC_COPY_RAW(p,q,c)                              \\\n      MULTI_STATEMENT_MACRO(                                          \\\n        assert((p) != NULL);                                          \\\n        assert(*(p) == NULL);                                         \\\n        assert((q) != NULL);                                          \\\n        *(p) = alloca(clampmin(c,1));                                 \\\n        assert(*(p) != NULL);                                         \\\n        assert((uintptr_t)(*(p)) % STACK_ALLOC_ALIGNMENT == 0);       \\\n        memcpy(*(p), (q), (c));                                       \\\n      )", "id": "daktldr"}, {"comment": "That's super.  Can I ask what the context of this code is?  Not generally speaking, but what are you using it in?  Some OS stuff for an embedded thing I'm sure, right?", "id": "dakwys5"}, {"comment": "Certainly! It is for some non-embedded numerical stuff.\n\nThe branchless square root was just a test of an idea I had. It works, but I don't actually use it in my production code. It's actually pretty fast on x64 and ARM64 for large values, but is relatively slower than other methods for smaller values since it always runs in constant time.\n\nThe stack-allocation macros (of which one is shown above) are used inside another macro that does variable-size struct allocation on the stack, which I benchmark at being 100 times faster than heap allocation of small blocks. But it's not the speed so much that I want (although it's nice) as the benefits of not contributing to heap fragmentation in a multithreaded environment. That is, allocating on the stack using `alloca()` is guaranteed not to fragment the heap because it doesn't allocate on the heap. It's really great for small, short-lived, temporary data of up to a few KB.", "id": "dakylgn"}, {"comment": "Are you a quant? Because this sounds like the type of stuff quants care about.", "id": "dal0d6u"}, {"comment": "Nope, just interested in integer number theory. :)", "id": "dalpxqq"}, {"comment": "Commas may screw things up, e.g. `MACRO (a = b, c)` won't work.", "id": "daksmgz"}, {"comment": "I don't think this macro is a good idea in general, but I think you might be able to work around that with a [variadic macro](https://gcc.gnu.org/onlinedocs/cpp/Variadic-Macros.html) :\n\n     #define MACRO_WRAPPER(...) do { __VA_ARGS__ } while (0)", "id": "dakyrkc"}, {"comment": "But when would you ever write `a = b, c` by itself anyway?", "id": "daktuar"}, {"comment": "That's probably not a great example, but `MACRO(int x, y; ... use x & y ...)` has the same problem.", "id": "daku5gh"}, {"comment": "Ah yes.", "id": "dakue6b"}, {"comment": "A more realistic example in C++:\n\n    MACRO(some_template_t<int, char> x; \u2026)\n", "id": "dakutaa"}, {"comment": "You can work around it with an `using` type alias, although that adds another line of code and type definition that can make the source file slightly more complex, but I guess the bigger issue lies on using macros in C++ where proper language constructs would be more befitting, like for example, a constexpr function.", "id": "dal0tow"}, {"comment": "Try compiling `MACRO(int a = 0, b = 0; a++; b++;)`: http://codepad.org/5HZhar0Z\n\nYou can probably avoid the resulting compilation error with some clever `__VA_ARGS__` but honestly not worth the effort.", "id": "dal11t8"}, {"comment": "declaring a variable *inside* a macro?!  Oh, wait.  it goes out of scope, right?", "id": "dal5pky"}, {"comment": "We have to go deeper.", "id": "dalc6wt"}], [{"comment": "also this forces the user to add a semicolon on the end.", "id": "dakl7cl"}], [{"comment": "It's worth noting that \n\n    #define foo(x)  if(1){ bar(x); baz(x); }\n\nwould not work either, because it can mess up nested if blocks, as well as the potential syntax error from bare braces.\n\n    if (test1) \n        foo (10);\n    else\n        do_stuff();\n\nwould become\n\n    if (test1) {\n        if (1) {\n            bar(10); \n            baz(10);\n        };\n        else\n            do_stuff();\n    }\n\nEdit: missed semicolon (important!) \n", "id": "dakpsx9"}, {"comment": "But this...\n\n    #define foo(x)  if(1) { bar(x); baz(x); } else ((void)0)\n\n...will work just dandy.\n\nAnd what's more, if the macro expansion includes a *break* statement for some reason, wrapping it an a *while* will change the meaning of that *break*, but wrapping it in the *if+else* will preserve it.", "id": "daks9fq"}, {"comment": "Cool! So, why `else ((void)0)` instead of just `else 0` or `else {;}`?", "id": "daktcnf"}, {"comment": "Compilers often give warnings about a constant as a standalone expression and possibly also about empty expressions.\n\n`((void)0)` is generally recognised as a deliberate no-op.", "id": "daku4to"}, {"comment": "I might\n\n    #define DELIBERATE_NO_OP ((void)0)\n\nthen. :)", "id": "dakud4q"}, {"comment": "Have you learned nothing?\n\n    #define DELIBERATE_NO_OP do { ((void)0); } while (0)", "id": "dakva3j"}, {"comment": "I think we just came full circle.", "id": "dakvzcv"}, {"comment": "This made my day.", "id": "daky4ku"}, {"comment": "> (void) variable;\n\nis a pretty common expansion of the UNUSED(variable) macro that is widely portable (gcc and msvc have annotations for this, but other compilers don't) - this prevents many different kinds of warnings when building with -Werror (set-but-not-used, code unreachable, etc).", "id": "daky5c8"}, {"comment": "Ah, cool \u2014 good to know!", "id": "dakubg7"}, {"comment": "Nice! The `do {...} while(0)` is shorter, but I'd guess that most (at least most of the less experienced) would find the `if(1) {...} else ((void)0)` to be more obvious. \n\nAny downsides of this compared to the `do ... while` form? ", "id": "daksoz6"}, {"comment": "`do ... while` is very common already, so the `if` version wouldn't save anyone from having to learn the existing version, it would just add another idiom for beginners to learn.\n\nI'm also not convinced that the `if` version is actually clearer, but that may just be because I'm used to the `do ... while` version.\n\nI can agree that it sounds useful if you have a macro expansion with a break statement. I'm having trouble thinking of any good reason to do that, but given the number of weird things that the preprocessor is used for, I suppose someone has come up probably come up with something that requires this at some point.", "id": "daktu3s"}, {"comment": ">I can agree that it sounds useful if you have a macro expansion with a break statement.\n\nActually that brings to mind a good point. With `do...while`, you can use `break` within the macro for early exit (like you'd use `return` in a void function). There's no equivalent for the `if...else` version.", "id": "dakuyoe"}, {"comment": "So, what you're saying is, that the `break` behavior is either a useful feature, or a limitation, depending on how it needs to be used. ", "id": "dakw9m9"}, {"comment": "*Sigh* now we need two `foo(x)` macros...", "id": "dal2usc"}, {"comment": "I'll say useful feature. I'm with Linus on this one - having macros that alter the flow control of the block they're in is a terrible idea.", "id": "daltxtx"}, {"comment": "It's interesting that the article so confidently declares that do-while is the *only* way to achieve statement-like macros, when there's another simple solution like this one.", "id": "dal7xbv"}, {"comment": "Am I misunderstanding how macro expansion works? Seems like it would result in this:\n\n    if (test1)\n        if (1) {\n            bar(10); \n            baz(10);\n        };\n    else\n        do_stuff();\n    ", "id": "dakz59e"}, {"comment": "Don't let the formatting fool you. The `else` binds to the most recent `if` (generally -- braces and such effect this). When I take your code and put it through a code formatter (vim, specifically), I get:\n\n    if (test1)\n        if (1) {\n            bar(10);\n            baz(10);\n        };\n        else\n            do_stuff();\n\n\nTo get what you're expecting, you need an extra pair of braces:\n\n    if (test1)\n    {\n        if (1) {\n            bar(10);\n            baz(10);\n        };\n    }\n    else\n        do_stuff();\n\n", "id": "dal1u44"}, {"comment": "> you need an extra pair of braces:\n\nAnd that's one of many reasons why I always put braces for my for/while/if/else/else if/etc. statements. You never know when that kind of thing will happen.", "id": "dall13v"}, {"comment": "Same here, I don't care if it's a few extra lines", "id": "dalovws"}, {"comment": "Thanks. I wasn't sure if the semicolon after the if block made a difference. Sounds like it is optional and doesn't change the meaning either way.", "id": "dal2qrf"}, {"comment": "Actually, thank you! I didn't realize that I'd missed the semicolon after the if block in my example. It's important (causes a syntax error). ", "id": "dal2w7f"}, {"comment": "yes, but the else is now attached to the second if, which is probably not what's wanted ", "id": "dal5hbe"}], [{"comment": "Why would you use a macro instead of a function (probably with inline) in this way?", "id": "dakl7jb"}, {"comment": "In C it might be to provide a \"generic\" function, and in both C and C++ it might be to do things only the preprocessor can do, e.g. stringization:\n\n    #define assert(EXPR) \\\n        do { if(!(EXPR)) { puts(\"assertion failed: \" #EXPR); abort(); } } while(0)\n\nHere `#EXPR` expands to a string literal containing the source tokens passed to `assert`, e.g. `assert(2 + 2 == 5);` expands into `do { if(!(2 + 2 == 5)) { puts(\"assertion failed: \" \"2 + 2 == 5\"); abort(); } while(0);`.", "id": "daklrlh"}, {"comment": "woa, that's cool! ", "id": "daks16j"}, {"comment": "> Why would you use a macro instead of a function (probably with inline) in this way?\n\nIn these simple examples, you probably shouldn't. But occasionally macros do weird things that can't be as easily done in a function (ie weird string concatenation to \"dynamically\" build symbol names in an almost-reflection-like type of manner), so they are sometimes useful.", "id": "dakloxi"}, {"comment": "To access compile-time variables such as \\_\\_LINE\\_\\_ and \\_\\_FUNCTION\\_\\_, but there are other uses in C. Maybe in C++ as well..", "id": "daklmqp"}, {"comment": "I don't think C++ adds anything to the preprocessor and most C++ advice is to avoid macros unless absolutely necessary.  That said, the only times I've used macros in C++ is to enable some quicker logging syntax to embed the filename and line number of the warning.", "id": "daktutg"}, {"comment": "I was rather thinking some things you might do in C, such as OO-emulation that might hide casts, or type-safe containers. You wouldn't do those in C++, but perhaps there are still some use cases left beyond debug loggers and assert-macros.", "id": "daku0sn"}, {"comment": "To be totally fair... debug loggers and asserts are quite useful.", "id": "dalqrhw"}, {"comment": "That and class factories. Can't create class instances from strings otherwise AFAIK.", "id": "dal3zmx"}, {"comment": "C++ will probably have [source_location](http://en.cppreference.com/w/cpp/experimental/source_location) as part of the language.", "id": "daktgcf"}, {"comment": "Seems interesting! But will it be possible to use that in a nice way without macros? Implicitly construct it at the call site for some template or function?-o", "id": "daku7gv"}, {"comment": "Suppose you construct an exception, and you want the exception to store source_location information for where it was constructed. It would make sense to pass something like `std::source_location::current_location()` as an argument to the constructor of that exception. And to avoid having to type that over and over again, you'd let it be a default argument, something like:\n\n    MyException(std::string message, std::source_location location = std::source_location::current_location())\n    {...}\n\nAnd then simply:\n\n    throw MyException(\"All is lost!\");\n\nAt least that's how I imagine it would work. I can't see it really mitigating the need for macros otherwise.", "id": "dakwqhy"}, {"comment": "That's how it works in C#, so it would be a sensible implementation for C++ too.\n\nhttp://www.kunal-chowdhury.com/2012/07/whats-new-in-csharp-50-callerlinenumber.html#LBPffH2u1ij2iYUr.97", "id": "dal2iox"}, {"comment": "> But will it be possible to use that in a nice way without macros?\n\nI thought that was the intention of this future feature?\n\n> Implicitly construct it at the call site for some template or function?-o\n\nwhat?", "id": "dakvt2h"}, {"comment": "I think the question is: how would an `assert` function using `source_location` work?\n\nIt's not clear how you'd actually use that to implement a macroless `assert` unless you know another fact: if you say `assert(bool c, source_location l = source_location::current())` and then call it with `assert(true)`, the location you'll get is that of the call site, and not of the definition of the default argument. (That is actually true; see [n4519](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4519.pdf) page 2 para 9.)\n\nOf course, that still doesn't solve how you stringize the expression, so I don't see it helping get rid of `assert` in many cases (especially unit test assert macros).", "id": "dakwpbn"}, {"comment": "I was going to write this exact thing. As far as really function-like macros that would be \"called\" at run time, I honestly cannot think of another use case in C++. The existence of templates sees to that. My list of uses for macros in C++:\n\n - the poor man's module system (`#include`)\n - to normalize compiler specific pragma and directives (like forcing inlining, for example)\n - to simulate reflection\n - to import information directly from the build system based on whether or not a macro was defined (although I would convert this to a constexpr global enum/bool immediately)\n\nI think that's all I got, and none of these are really anything like calling a runtime function.", "id": "daktxif"}, {"comment": "There are some others; `assert` is of course a classic example and, IMO, doesn't fall into any of your categories. (I guess you could argue that it's simulating reflection, but I wouldn't agree.) Or take the usual `DEFINE_TEST(...) {...}` thing for auto-registering test cases (you'd have a better case that this falls into simulating reflection).", "id": "dakuddg"}, {"comment": "assert falls into your original example; the reason why assert is a macro is to access the line number and file name (to be clear, my list was supposed to be in addition to what you originally suggested). Otherwise you could just have a function that takes a bool and calls `std::abort` if true. More broadly this is why defensive programming libraries use macros extensively (I know, I wrote one from scratch; simulating default arguments with macros, fun fun).\n\nAs far as testing goes, I suppose I did miss a category: syntactic sugar. I've also used very simple macros for things like e.g. factory registration. Testing falls into both syntactic sugar and reflection; the name of the test is typically collected and stored as a string literal so that you can use regular expressions to filter which tests to run (e.g. in gtest).\n\nEdit: I suppose the other reason why `assert` macros are macros are to print the expression directly. I can see why you disagree that this is reflection, it's obviously not typically supported by reflection in languages like Java or Python. I think it is still reflection in some sense, but either way point taken.", "id": "dakvxuk"}, {"comment": "I'm guessing because in C you'd need a different `__set_task_state` function signature (and name) for each argument type used for `tsk`. The macro alleviates that redundancy.\n\nIn C++, this is not a problem, because you can use templates, or function overloading and/or specialisation.", "id": "dakltzd"}, {"comment": "Inline doesn't *mean* you'll inline. It *suggests* inlining. For bit twiddling stuff like error code, detection, flag setting, ensuring those things are lined is nice. Inline also only attempts to inline if the functions are in the same translation unit. So if you try to inline across libraries you can be SOL depending on your make file config. ", "id": "dakpfea"}, {"comment": "This on its own is no reason to use macros.\n\nFirst off, functions can actually be inlined across translation units with LTO. But even leaving that aside: macros can also only be *used* in the same translation unit. Macros have to be defined in header files and included directly. So if you're going to include a file with macro definitions, you can just include a header file with function definitions. \n\nSecond, with or without `inline`, compilers decide when it makes sense to inline, in the subset of cases they are capable. Most very short functions will always be inlined, because the inlined code is the same length or less as calling the function. E.g. a function that has one line setting a flag, will basically always be inlined. For the majority of your code, the compiler's heuristics are good enough and you can easily do more harm than good writing long macros and causing code bloat.\n\nThird, if you're in a particular situation where you know something absolutely has to be inlined and you don't trust the compiler, you still shouldn't write a macro. Use a compiler directive. Every major compiler supports these. At most you may need to write a macro that expands to the correct directive for different platforms, if writing cross platform code. But at least you are still calling a function and not a macro, with all of the fun edge cases that entails.", "id": "daktdzk"}, {"comment": "Another idiom is to put a static inline in the header, just like a macro. This solves the translation unit issue (or use an LTO compiler as mentioned by another comment). One downside to this is the temptation to build more and more complex \"macros\" until you've defeated the purpose and should really be making a normal function.\n\nRelevant quote from the GCC manual \"Static inline is as fast as a macro\"\nSee: https://gcc.gnu.org/onlinedocs/gcc/Inline.html", "id": "daljqxx"}, {"comment": "To save space with repetitive constructs without having to pass local state as arguments.", "id": "dakp8rg"}, {"comment": "If you're writing using a very old compiler (that won't do well with inline), it's not always bad to use a macro.", "id": "dakquii"}, {"comment": "Macros are the only portable way to force inlining, and also can access variables in the parent scope. The latter is also possible with nested functions, but those are only available in GNU C.", "id": "dalh54c"}], [{"comment": "If you are using GCC or Clang exclusively (many other compilers probably support them, though it is a non-standard feature), \"statement expressions\" can be very handy especially when you need function-like macros which return a value:\n\n    #define maxint(a, b) ({ \\\n        int _a = (a), _b = (b); \\\n        _a > _b ? _a : _b; \\\n    })", "id": "dakn0iw"}, {"comment": "I think the benefit of statement expressions over vanilla macros wrapped with `do { ... } while(0)` besides increased clarity is that you only evaluate the arguments once.", "id": "dakskmg"}, {"comment": "There's not really a difference. You can evaluate arguments multiple times in statement expressions just as easily as you can in `do { ... } while(0)` macros.", "id": "dalcwsy"}, {"comment": "That's true, but macros that do not use statement expressions do not make it easy to evaluate arguments exactly once.\n\nThe GCC documentation has a good example with the `max` function.\n\n      #define max(a,b) ((a) > (b) ? (a) : (b))\n\nIf `a` or `b` is an expression with side-effects, the `max` macro could have unexpected results.\n\nhttps://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html\n\nThis also points out a weakness of statement expressions that I didn't remember, namely that you commit yourself to a single concrete type if you use a temporary variable inside a statement expression (just like all variables in C).", "id": "dalh0du"}, {"comment": "My point is that do-while statements and statement expressions are pretty much identical when it comes to using temporaries:\n\n    #define maxint(a,b) ({ \\\n        int _a = (a), _b = (b); \\\n        _a > _b ? _a : _b; \\\n    })\n\n    #define print_maxint(a,b) do { \\\n        int _a = (a), _b = (b); \\\n        printf(\"%d\", _a > _b ? _a : _b); \\\n    } while(0)\n\nThe difference between them is not \"increased clarity is that you only evaluated the arguments once\", it's that one expands into an expression and the other expands into a statement.", "id": "dall4gc"}, {"comment": "Oh. Yes. That's a really good point.", "id": "dals5b5"}, {"comment": "> This also points out a weakness of statement expressions that I didn't remember, namely that you commit yourself to a single concrete type if you use a temporary variable inside a statement expression (just like all variables in C).\n\nIf you're already going with non-standard extensions, just use `typeof`:\n\n    #define max(a, b) ({ \\\n        typeof(a) _a = (a); \\\n        typeof(b) _b = (b); \\\n        _a > _b ? _a : _b; \\\n    })", "id": "dalu07e"}, {"comment": "Does that result in evaluating `a` twice?\n\n`typeof` and `__auto_type` (https://gcc.gnu.org/onlinedocs/gcc/Typeof.html) have some impressively subtle tradeoffs.", "id": "damf10m"}, {"comment": "Only if `typeof(a)` is a variably-sized type (a VLA, or a struct containing one). That's only because in that case, `typeof(a)` can actually change at runtime, so the expression would need to be actually evaluated at runtime in order to determine the type. In that case, it's best to use `__auto_type` and throw portability to the wind (clang doesn't support `__auto_type` AFAIK, but it does support `typeof`). \n\nFor ordinary C types, though, it's like `sizeof` - the expression isn't evaluated at runtime, and `typeof(a)` becomes the known compile-time type of the expression `(a)`. ", "id": "damfj7a"}, {"comment": "statement expressions are a gnu extension", "id": "dal00qq"}], [{"comment": "Can you avoid braceless `if`s instead?", "id": "dakx0p0"}, {"comment": "You can certainly make that part of your coding standard, but the compiler won't enforce it for you.  So if some junior programmer working in your large shared codebase decides to drop a braceless `if`in his patch, he might end up with a non-obvious bug on his hands, as demonstrated in the examples in the article.\n\nWhat's more, if you're writing some sort of library, perhaps you don't control the coding standards of the projects your macros might be invoked in?\n\nThere's a lot to be said for having your macros be relatively foolproof.", "id": "dakz14k"}, {"comment": "This. This is why [Allman style](https://en.wikipedia.org/wiki/Indent_style#Allman_style) is the only correct indent style.\n\nhttp://www.terminally-incoherent.com/blog/2009/04/10/the-only-correct-indent-style/", "id": "dalsgo7"}, {"comment": "Using that much whitespace is for heretics!", "id": "dalujko"}, {"comment": "Since the opening brace is all by its glorious self, it makes it obvious when it's missing, as opposed to K&R where it's way out in right field.\n\nThe closing brace gives a place for a closing comment, which makes scanning the code easier.  Example\n\n    if (condition)\n    {\n        blah\n        blah\n        blah\n    } // condition\n    else // ! condition\n    {\n       blah\n       blah\n    } // ! condition\n", "id": "dalzxfz"}], [{"comment": "\\**disgusted head-shaking**", "id": "dakqtr8"}, {"comment": "I don't know, I'm not a C programmer so this does kinda make me shake my head but simultaneously I can't argue that its not a neat solution.", "id": "dakrs62"}, {"comment": "For what it's worth, this is standard C macrology stuff. C macros are evil and terrifying, but if you're already in that world, then the do/while(0) trick is the usual way to solve this particular problem.", "id": "daksr55"}, {"comment": "As a c++ programmer I can see the benefit since generic code like templates didn't exist yet, and being able to catch as many possibly problematic use cases is nice.  But this is pretty useless in c++ except for, as someone else mentions, string interpolation as I've heard it called (the comment that mentions it calls it stringization). [Link for reference.](https://www.reddit.com/r/programming/comments/5fiq6n/do_while_0_in_macros/daklrlh/?context=1)", "id": "dakt862"}, {"comment": "> string interpolation as I've heard it called (the comment that mentions it calls it stringization).\n\nThat's not really string interpolation, at least as I've ever heard that term. String interpolation to me means you get some format string like `\"abc $var def\"` or `\"abc %s def\"` and then you provide it (perhaps implicitly from the surrounding environment) some variables to put into place.\n\nStringizing syntax is totally different.", "id": "daku2es"}, {"comment": "I understand they're different, but a lot of people in this sub may come from backgrounds where the term stringization doesn't mean anything to them, so calling it string interpolation brings it to where they're at.  I had to read the code snippet from the linked comment a few times to understand fully what was happening. I figured someone who has never seen C or C++ would be incredibly confused. ", "id": "dakv6en"}, {"comment": "Care to explain? \n\n*It may not be pretty, but it's sure ugly.*", "id": "daksv0h"}, {"comment": "I'm not OP, but I'm just disgusted that this is a thing due to C macros being so horribly implemented (They shouldn't even be called macros IMO).\n\nIf the C macro system were sane, you wouldn't have to do any of this.  The fact that they are essentially find/replace with a crappy meta language makes them really dangerous.  It means you end up making these weird tricks.\n\nIt is literally relying on syntax quirks in order to get desired behaviors.  What would C programmers do if do {} while wasn't valid?", "id": "dalczlr"}, {"comment": "I understand. This is why many experienced C programmers suggest avoiding macros, and limiting their use to as well defined, constrained, areas as possible. Macros are an old tool, and non-trivial use can be tricky. ", "id": "dalf337"}], [{"comment": "I was kinda surprised to see this on front page.  Anyone who's done C professionally for any length of time has run into this trick.", "id": "dakv5nu"}, {"comment": "Yeah, I learned this in my introductory programming course at university. But some folks here are probably new to C and not taking a formal course in it, so I can see why they'd find this interesting.", "id": "dakx9s6"}, {"comment": "That's actually fairly impressive for an intro level course. My professors never really discussed preprocessor stuff beyond the basics #include and recursive include guards.  Then again, I never actually took classes taught in C, just C++98 and Java.", "id": "dal1bsn"}, {"comment": "I did take the version of the course for people with some programming experience, so it's possible the other version of the course didn't mention it.\n\nBut I suspect they did, because both versions of the course were taught in C and I believe both used K.N. King's _C Programming: A Modern Approach_ as the textbook. The text was very good about pointing out and explaining idioms.\n\nWe did move to C++ for the second semester course on algorithms and data structures.", "id": "dal2h5d"}, {"comment": "Totally missed it for years.. although in my defense it's mostly C++ that I use.", "id": "dal4bai"}], [{"comment": "This is a risky idea. What if, for some reason, the macro expansion produces a *break* statement? In that case, the *do{}while(0)* will change the meaning of it. Just wrapping it in an *if{}* has the problems described, but you can extend that to work correctly with *if{}else((void0)*.\n\nA real-world example from my current codebase:\n\n    #if NDEBUG\n        #define WARN_AND_FIX(condition, fix) \\\n            if (condition) { \\\n                fix; \\\n            } else ((void)0)\n    #else   \n        #define WARN_AND_FIX(condition, fix) \\\n            if (condition) { \\\n                WriteWarningMessage(#condition, __FILE__, __LINE__); \\\n                fix; \\\n            } else ((void)0)\n    #endif\n\nAnd with that, you can safely write (excuse the trivial example):\n\n    for (int i = 0; i < 10; ++i) {\n        WARN_AND_FIX(i > maxAllowable, break);\n    }\n\nThat still works with semicolons. It still doesn't mess with other surrounding *if* statements. But with if{}else((void)0)* the *break* works as expected whereas *do{}while(0)* turns the *break* into a no-op.\n\nEdit: formatting", "id": "daksqya"}, {"comment": "I don't think `do{}while(0)` is intended to be a one-size-fits-all tool. As discussed in https://www.reddit.com/r/programming/comments/5fiq6n/do_while_0_in_macros/daks9fq/, there are advantages and disadvantages of `do{}while(0)`verses `if{}else((void)0)`. ", "id": "dakwj4y"}, {"comment": "So plainly this works for you, but I think personally I'd much rather avoid putting flow control statements in macro parameters. I don't think this is something that most macros need to support.\n\nIf I were setting up a check that prints a warning, I think I'd do something more like this (warning, totally untested):\n\n    #if NDEBUG\n      #define WARN(condition) ((condition) != 0)\n    #else\n      #define WARN(condition) (((condition) != 0) && (WriteWarningMessage(#condition, __FILE__, __LINE__), 1))\n    #endif\n    \n    ...\n    \n    for  (int i = 0; i < 10; ++i) {\n      if ( WARN(i > maxAllowable) ) {\n        break;\n      }\n    }\n\nThis is longer, but to my eye it's also clearer. In general I think needing to support break statements in macro expansion may be a sign that rethinking the macro might be beneficial, rather than a sign that a widely used idiom that doesn't support this is bad.\n\nBut again, clearly what you have is working for you, so that's good. And it's certainly true that once you've decided to support break statements in macro expansions like this, the standard `do{...}while(0)` wrapper won't work for you.\n\n(Edit: Fixed mistake in macro)", "id": "dakz8nk"}, {"comment": "What about\n\n    switch(1) {\n      default:\n        WARN_AND_FIX(i > maxAllowable, break);\n        somethingElse();\n    }\n\n?", "id": "dakw1o4"}], [{"comment": "Looks like a cool trick. Can you make it into npm package?", "id": "dald66l"}], [{"comment": "nice article, I really like how people find interesting \"loopholes\" in programming languages, just so they can code better", "id": "dakkrip"}, {"comment": "Not everyone would agree it is better.", "id": "dal1htz"}], [{"comment": "For related fun: https://gustedt.wordpress.com/2011/02/02/handling-control-flow-inside-macros/", "id": "dakopk2"}, {"comment": "This is the first I've heard of P99. Looks pretty useful. Thanks for the link. ", "id": "dakwag4"}], [{"comment": "Why use do {...} while (0) instead of if (1) {...}?", "id": "dakpgnu"}, {"comment": "Because semicolons wouldn't work.", "id": "dakplk5"}, {"comment": "https://www.reddit.com/r/programming/comments/5fiq6n/do_while_0_in_macros/dakpsx9/", "id": "dakr2uf"}, {"comment": "They describe in the article why using only curly braces don't work and it looks like if(1){...} would fall into the same trap. in the middle of code if you call macro(); then you'll be left with if(1){...}; in the code and that is a syntax error.", "id": "dakw7f1"}, {"comment": "Actually that's not really true.\n\nFirst, `if(1){...};` [is actually *legal*](https://godbolt.org/g/zJY8Db); it's just an `if` followed by an empty statement.\n\nThe two problems are (i) you can easily wind up with `else`'s being associated with the wrong `if` and (ii) `if (...) mymacro(); else thing();` expands to `if (...) if(1) {...}; else thing();` and *that's not* legal.", "id": "dal8fjm"}, {"comment": "Thank you for explaining that to me. Moreover thank you for showing me that website.", "id": "dal8yra"}], [{"comment": "Note, this is for C, not C++. Don't do this shit in C++, and you should think twice before using it in C.\n\nIn C++, don't use custom marcos except to exclude code. (Like header guards, or OS specific code) Don't write a function into a macro. Don't define constants in macros.\n\nWhy?\n\nYou don't get handles to debug things in macros, [if it can be done in code] you can't do anything more efficiently in macros than you can in code. Use a const. Use an inline function. These will be just as efficient, and you can actually step through to see what is happening.\n\nCase in point?\n\nDownload [this shit](http://www.cs.utexas.edu/users/cart/code/ss-ppc-big.tgz), build it (good luck), and step the debugger through this part of sim-cache.c in sim_main()\n\n \n\t\tswitch (op)\n\t\t{\n\t#define DEFINST(OP,MSK,NAME,OPFORM,RES,FLAGS,O1,O2,I1,I2,I3,O3,O4,O5,I4,I5)\\\n\t\t\tcase OP:\t\t\t\t\t\t\t\\\n         \t\t\tSYMCAT(OP,_IMPL);\t\t\t\t\t\t\\\n          \t\t\tbreak;\n\t#define DEFLINK(OP,MSK,NAME,SHIFT,MASK1,MASK2) \\\n        \t\tcase OP:\t\t\t\t\t\t\t\\\n        \t\t\tpanic(\"attempted to execute a linking opcode\");\n\t#define CONNECT(OP)\n\t#define DECLARE_FAULT(FAULT)\t\t\t\t\t\t\\\n\t\t\t{ fault = (FAULT); printf(\"inst %x pc %x\\n\", inst, regs.regs_PC); break; }\n\t#include \"machine.def\"\n\t\t\tdefault:\n        \t\t\tpanic(\"attempted to execute a bogus opcode %x %x\", regs.regs_PC, inst);\n\t\t}\n\nI had to modify this shit for a class project once. The idea was to cache [basic blocks](https://en.wikipedia.org/wiki/Basic_block) to attempt to improve processor performance. Turned out to be a real pain because of the macro expansion.  (and we found caching basic blocks to be a really bad idea if anyone is curious) \n\n----\n\nEdit: Added [if it can be done in code].", "id": "dakwe0z"}, {"comment": "> you can't do anything more efficiently in macros you can in code. \n\nCan we stop with the cargo cult blanket statements? Sure, **most** things are better done with functions and constants except, well, [those that are impossible](https://www.reddit.com/r/programming/comments/5fiq6n/do_while_0_in_macros/daklrlh/)", "id": "dal1q12"}], [{"comment": "All the examples seem like simple expressions.  Is there an advantage to using do..while and forcing it to be a statement rather dan just using a comma and some extra brackets in these cases?  This is the way I would have done those:\n\n    #define __set_task_state(tsk, state_value)      \\\n        ((tsk)->state = (state_value))\n\nand\n\n    #define foo(x)  (bar(x), baz(x))", "id": "dakukqj"}, {"comment": "My perspective: yes and no.\n\nTo me, this is basically the same question as the following: \"Is there an advantage to (if you were to write these as functions) returning `void` rather than `int`?\" In other words, if you were to write `__set_task_state` as a function, would you write:\n\n    void __set_task_state(task, value) { task->state = value; }\n\nor\n\n    whatever __set_task_state(task, value) { return task->state = value; }\n\nexcept where the extra syntactic burden is switched to the other case.\n\nThe former is (arguably) better not only because it's less typing, but because it better reflects the intention. E.g., what does `__set_task_state` return if it returns something? As I've written it -- and as *you've* written it -- it returns the new state, but if I were to look at just the function signature and you forced me to make a guess at what it returns, I'd guess it returns the *old* one. (APIs to set the value of something and return the old one are, of course, not uncommon.)\n\nSo making the function `void` -- or making it not an expression -- makes it clearer what's going on, makes it less likely to be misused, and provides a narrower contract so you can change things later. (E.g. imagine if you later was like \"hey I *do* want it to be an expression, but to evaluate to the old value.)\n\nI don't see this as a terribly compelling argument, but for something where you don't expect it to be used in an expression context it's probably enough to make me think it's the better option.", "id": "dakv7zw"}], [{"comment": "At that point I'd generally go with a function call. I understand macros may help performance but I'm not too fond of them and their indirection and readability issues.", "id": "dakwcaf"}, {"comment": "IMO, there are few good excuses for macros.  The only thing you are getting is forced inlining vs compiler inlining.", "id": "dald5mf"}, {"comment": "> At that point I'd generally go with a function call.\n\nMe too. The only reason I have found to use code like this was because the rest of the team considered it a best practice for C (and at that point, it's a mindset problem and a matter of consistency).", "id": "dalu61f"}], [{"comment": "This is the kind of thing the GNU Statement Expression extension is great for.", "id": "dal8wjr"}], [{"comment": "I thought nost people knew this already ", "id": "dalbgtz"}], [{"comment": "I wish they would support this pattern in the language. Whenever you need to resort to a hack to solve a common problem, it indicates a defect or at least omission in the language. ", "id": "dalu78b"}], [{"comment": "Long time C/C++ programmer, I thought basically knew everything there is to know \u2192 Still learning ! \n\nThank you reddit for making me humbler and better !", "id": "daluir2"}], [{"comment": "This is a little over my head. Is there a good reason to use this in other languages like Java or C#?", "id": "dalawf5"}, {"comment": "> Is there a good reason to use this in other languages like Java or C#?\n\nNo. The C macro language was created as a quick-n-dirty hack in the first versions of C, then kept along because there was already code using it ( actually, I don't know if any of that is true, but it's crappy enough that it sounds possible :) ).\n\nLanguages like Java and C# were created much later than C and many of the design choices for these languages were made on the basis of \"let's avoid the problem created in C++ by this feature\" (C++ macros are C macros).", "id": "dalualc"}, {"comment": "Those languages don't have C style macros as far as I know. Although, if you really want to use C style macros in those languages, you could use the C preprocessing facility of GCC and pass the result to javac or csc.", "id": "dalfuds"}, {"comment": "Ah - I think I understand the difference now. The C# preprocessor is really limited to simple if/else blocks I think. I haven't seen it used for anything else.", "id": "dalgowl"}], [{"comment": "Damn, that's a very cool trick!", "id": "dalu38y"}], [{"comment": "There is a lot of stuff missing from C that is mandatory for any decent level of a metaprogramming. And I'm not talking about the preprocessor only. This stuff is useful in any kind of a generated code.\n\nOne is this, a simple block statement. `do ... while(0)` sort of solves it, but it's dirty. \n\nAnother one is a statement in place of an expression - there is a lot of cases where you might want to do it, especially in a generated code. \n\nAnd my favourite construct that is missing from most of the languages - *lifting* a statement, a struct/class member or a top level statement from some nested level up to where it belongs. Is not it handy to have a macro expanding into an expression which *defines a function* in your top-level context if it is needed?", "id": "dalucgd"}], [{"comment": "the other thing about macros is to put a ( ) around all uses of a macro parameter: like \n\n          #define UTIL_TEST_BIT(bitMask, bitIdx) ((bitMask)[ (bitIdx) >> 3 ] & ( 1 << ( (bitIdx) & 7) ) )\n\nThis way you will not be surprised if somebody puts in an expression when the macro is used.\n\nthe do..while thing is needed when the macro spans multiple statements; \nin this case \n\n           if (...) MACRO_WITH_MULTIPLE_STATEMENTS\n\nwill have only the first statement of the macro conditioned by the if, in most cases this will not have been your intention. With the do-while thing you can also have local variables in the macro - without fearing that these will clash with variables defined in the calling code.\n\nIn most cases an inline function will be better than a macro - much less posibilities to break things (unless you need token pasting or some even more ugly stuff).  Gcc has \\_\\_inline\\_\\_ for C , in C++ you have standard inline keyword.  The Linux kernel has some really ugly macro stuff - like this here http://stackoverflow.com/questions/9229601/what-is-in-c-code", "id": "dam13yr"}]]], "5gf38q": ["Lock your Node.js project into an executable", "2016-12-04 14:45:04", 0, "https://github.com/DavidCai1993/lock.js", [], []], "5fwzvk": ["Capsule, Package and Deploy JVM Applications", "2016-12-01 18:02:31", 0, "http://www.capsule.io/", [], []], "5g9m89": ["Core components for a Social Network featured as Microservice components", "2016-12-03 16:46:56", 0, "http://weall.com/book/chapter?name=SOCIAL NETWORKING PATTERNS AS MICROSERVICES", [[2, "Some awful designed website requires me to login/register for this.\n\nAnd the console 11 JavaScript errors."]], [[{"comment": "Some awful designed website requires me to login/register for this.\n\nAnd the console 11 JavaScript errors.", "id": "daqk2cm"}]]], "5g7mkl": ["Code reviews vs. unit tests \u2014 fight!", "2016-12-03 06:23:59", 0, "https://medium.com/@david.gilbertson/code-reviews-vs-unit-tests-fight-bea122b37614#.hywbsf6fi", [[5, "If you have to choose one of them, you are in wrong place"], [3, "Both. \n\n"], [2, "> (The zoo has four otters which I have named z-index, webpack, npm shrinkwrap and indexeddb API. They take their abuse with valiant dignity.)\n\nFrom the names of those otters, it sounds like they are gang members. You should not hang around the likes of those; they have driven many a programmer crazy."]], [[{"comment": "If you have to choose one of them, you are in wrong place", "id": "daq5fhu"}, {"comment": "[deleted]", "id": "daq5nym"}, {"comment": "The only reason to not do code reviews is that you are working solo. Otherwise it is a huge time saver.", "id": "daqr6o9"}, {"comment": "I left it out of the article, but when I was working solo in my startup I actually had a weekly beer/peer review session where I would go through my code with a mate and vice versa, it was really useful.", "id": "dar3ber"}], [{"comment": "Both. \n\n", "id": "daq71bu"}], [{"comment": "> (The zoo has four otters which I have named z-index, webpack, npm shrinkwrap and indexeddb API. They take their abuse with valiant dignity.)\n\nFrom the names of those otters, it sounds like they are gang members. You should not hang around the likes of those; they have driven many a programmer crazy.", "id": "daqi6u0"}]]], "5g6h35": ["CSS Waves of colors (relaxing)", "2016-12-03 02:14:02", 2, "http://soundtocalm.com/?colors", [[1, "Did not test in firefox, apparently."]], [[{"comment": "Did not test in firefox, apparently.", "id": "dapxjqc"}, {"comment": "What issues were you having? No problems using Firefox 52.0a2 Linux.\nCool concept, are you just starting out in development? ", "id": "daquk6e"}, {"comment": "It was stuttering heavily in firefox 49.0.2.", "id": "daqx7wo"}, {"comment": "u still use firefox? mozilla discontinued development time to switch to chrome", "id": "dapyveq"}, {"comment": ">  mozilla discontinued development\n\nLol, What?", "id": "daqiyfm"}]]], "5g6zsb": ["Make an Amazing Tensorflow Chatbot Easily", "2016-12-03 03:59:08", 0, "https://youtu.be/SJDEOWLHYVo", [], []], "5ga6mf": ["List of Consistency Models for Cloud Storage Services", "2016-12-03 19:04:43", 16, "https://cloudrail.com/compare-consistency-models-of-cloud-storage-services/", [], []], "5g8hxv": ["emacs-jit: Emacs with an Emacs Lisp JIT compiler using libjit.", "2016-12-03 10:22:40", 56, "https://github.com/burtonsamograd/emacs-jit", [[21, "The absolute madman"], [8, "If you have any questions about the implementation, I'm here to answer them."], [-5, "Obligatory \"emacs would be a great OS if only it had a decent text editor.\""]], [[{"comment": "The absolute madman", "id": "daqc7n8"}], [{"comment": "If you have any questions about the implementation, I'm here to answer them.", "id": "daqrbs4"}, {"comment": "Is libjit still being maintained these days?", "id": "daqwet3"}, {"comment": "To be honest, I'm not entirely positive.  I wrote this about 4 years ago with libjit 1.2, which didn't compile on my more modern system.  I tried with the git version and it worked without a snag, so it seems to be more up to date than the official release.", "id": "dar2mr8"}, {"comment": "Now that emacs introduced a native plugin/extension/addon/whatever system, do you think there is still enough slow legacy code that a JIT for elisp makes sense?", "id": "darp4df"}], [{"comment": "Obligatory \"emacs would be a great OS if only it had a decent text editor.\"", "id": "daqvi9e"}, {"comment": "With spacemacs, Emacs now has the best text editor! (vim)", "id": "dar0mz8"}]]], "5fx7l5": ["I used MS-Office to connect to Google Vision and identify NSFW images and more. Code in article.", "2016-12-01 18:41:27", 6, "http://www.filmphotoacademy.com/blog/ai-vision", [[1, "Actually it does more than this.  It interrogates both Microsoft Vision and Google Vision and gets the following information:\n\nIs it NSFW\nWhat text tags do they apply to the image\nWhat caption should the image have\nWhere is the face in the image\n\nThe article discusses the results and how I used this information to automatically censor and redact images.\n\nCode for you to try is linked from the article as a plain text file - should work in any part of Microsoft Office though I was using Microsoft Access.   The code is in VBA, should convert to vbscript really easily if you want to try on a web server\n\n"]], [[{"comment": "Actually it does more than this.  It interrogates both Microsoft Vision and Google Vision and gets the following information:\n\nIs it NSFW\nWhat text tags do they apply to the image\nWhat caption should the image have\nWhere is the face in the image\n\nThe article discusses the results and how I used this information to automatically censor and redact images.\n\nCode for you to try is linked from the article as a plain text file - should work in any part of Microsoft Office though I was using Microsoft Access.   The code is in VBA, should convert to vbscript really easily if you want to try on a web server\n\n", "id": "danousk"}]]], "5fprzd": ["No excuses, write unit tests", "2016-11-30 17:09:29", 203, "https://dev.to/jackmarchant/no-excuses-write-unit-tests", [[239, "Very tired of posts about testing using tests for a calculator as the example. It's so artificial to the point of being harmful. No one is going to disagree with writing tests for a calculator because they are incredibly simple to write, run instantly, and will never have a false positive. There are no tradeoffs that need to be made.\n\nLet's see some examples of tests for an application that exposes a REST API to do some CRUD on a database. The type of applications that most people actually write. Then we can have a real discussion about whether the tradeoffs made are worth it or not."], [115, "Eh. Don't adopt dogmatic development practices. Unit tests have a time and place. I prefer code that's correct by construction, code heavy with asserts that maintain invariants, and building things in a way such that they can't have errors. Do all of that and your testing requirements go down dramatically. It's all domain-specific..."], [85, "I have a set of libraries that I don't write unit tests for.  Instead, I have to manually test them extensively before putting them into production.  These aren't your standard wrapper around a web API or do some calculations libraries though.  I have to write code that interfaces with incredibly advanced and complex electrical lab equipment over outdated ports using an ASCII based API (SCPI).  There are thousands of commands with many different possible responses for most of them, and sending one command will change the outputs of future commands.  This isn't a case where I can simulate the target system, these instruments are complex enough to need a few teams of phds to design them.  I can mock out my code, but it's simply not feasible to mock out the underlying hardware.\n\nUnless anyone has a good suggestion for how I could go about testing this code more extensively, then I'm all ears.  I have entertained the idea of recording commands and their responses, then playing that back, but it's incredibly fragile since pretty much any change to the API will result in a different sequence of commands, so playback won't really work."], [59, "Or better, don't start unit testing, start automatic testing - in whatever form works for you - which may include unit testing\n\nunit testing is not the silver bullet people make it out to be and often introduces a climate of \"well my tests pass it must be perfect\"\n\nfigure out what tests work for you, for web code for example web browser automation is often much more useful than unit tests, write something that clicks around and breaks things. for low level hardware build code that will just automate running against test hardware. \n\ndo what works for you and don't listen to anyone who says there is one true way."], [38, "I hate those stupid text book examples. Yes, testing an *add* function is easy. But most code doesn't look that way. The really hard part is not unit testing, it is making your code unit testable. That is the interesting stuff."], [28, "Here's an excuse: As a game developer, especially with gameplay, there tends to be a lot of interconnected components that work together in various ways. It depends a lot on input and on chains of actions and on large data sets. Everything changes continuously. \n\nI've recently started working on a hobby project: Developing vehicle AI. Each AI currently consists of six components that talk to each other (though data does tend to move in one direction). It's still work in progress and I tend to refactor things all the time. Having tests for that would only slow me down, or worse, cause me to not refactor so as to not have to rewrite tests.\n\nI did write a few unit tests for my containers (array and queue and set), and they did find a couple of bugs for me, but are most people really writing code that is no more complex than containers?\n\nAre not all decently complex applications in a lot of flux - is it just game development? Or are people writing and maintaining tests for this type of code? \n\nPersonally I feel like smoketesting is a much wiser strategy for game devs."], [28, "Make me!"], [19, "I'd say the fact there's still no proof that unit testing has any benefit whatsoever is a pretty good excuse."], [17, "What about this excuse: I write graphics engines for a living.  Should I spend months writing a software rasterizer to validate the results?  Maybe code up some neural networks to validate that the object is what it should be?\n\nWhy, in 2016, in the field of software engineering, are people still saying that certain things should be or not be done 100% of the time?  Can we just accept that there are no absolutes, and that there is always an exception to the \"rule\"?\n\nEdit: In fairness, I do know of one company that spent months creating a software rasterizer to validate the results of the hardware renderer.  They went out of business - their game looked terrible and they probably should have spent their unit-testing time building a more valuable product."], [13, "Laudable intenti0ns, but the author is **way** too optimistic with the idea that unit testing will save him from production bugs.\n\nIt is really not hard to have all green 100% code coverage tests *and* bugs.\n\nThen, unit tests are generally not used to test for code quality issues like memory/resource leaks, deadlocks and race conditions in multithreading scenarios.\n\nThey are quite useless for performance considerations as well.\n\nSure, unit tests are needed for some ALM aspects, but are **nowhere near** enough.\n\n You need other test kinds as well, and, depending on the nature of your code, they might be leaps and bounds more important than unit tests."], [10, "Why would I spend half an hour fixing unit test every time I change something instead of running the program with a few sample files?"], [9, "Its great for testing basic functions that involve heavy math computations, risky type conversions, security related functions and so forth. Beyond that, the scheme heads towards diminishing returns very quickly. "], [10, "The people in here saying that unit tests introduce a massive maintenance burden are off base. Your unit test is for verifying that your function fits it's intended behavior. If you are finding that you are consistently breaking your unit tests, you either wrote your test poorly, wrote your functions too large, or have a horribly defined API. \n\nYour unit tests are only there to test that a logical piece of code does what it's supposed to. That's all a unit test is. In a contrived example it can be something like an `add()` or to give a more real life example it can be a function that returns checks if a user has made a purchase on their account or if two users in a dating app have matched. \n\nI've seen a lot of users here claiming that unit tests are not relevant for them because their codebase is too hard to test in that fashion. Maybe in some cases this is true, but I can't help but feel that some people have written functions that are way too big and therefore can't figure out how to unit test them properly. Your functions should do *one thing* and *one thing only*. Yes, sometimes by necessity you'll need larger functions that rely on many smaller functions to produce a result, but those smaller functions should all be doing *one thing* and therefore make it easy to reduce the larger function to essentially doing *one thing* itself. When your functions are small, they are generally easy to unit test.\n\nFinally, refactoring a function should not fundamentally change it's behavior once the API has been defined and released. This is Software Engineering 101. If this is happening to you, you are either working on a product in v0.X or you don't know what you're doing. Yes, real life makes it difficult to reach the ideal practices of software engineering, but it's horrible practice to consistently release breaking changes in what is supposed to be a stable product. Client developers will despise you and replace your product over time. \n\nSure, unit testing is no silver bullet and might not be worth the effort in every case and 100% code coverage is probably unrealistic in large projects. When you understand a) how to test and, more importantly, b) how to write *software* not just code, you find there are a lot of benefits to these \"best practices\"."], [7, "I can name at least 20 reasons not to write unit tests."], [7, "Unit tests are useless. No excuses not to use strong type systems and not to write proper *integration* tests."], [5, "Nah."], [5, "Here they go again with the 'adding numbers' unit tests..."], [4, "the article doesn't really address the time problem, though he mentions it explicitly in the first paragraph:\n\n\"There\u2019s fear unit testing will take time your team doesn\u2019t have\"\n\noften my team finds that writing tests will take valuable engineering time away from projects that will immediately drive revenue. many small companies don't have the luxury of a long runway to afford even a couple of hours doing anything off-roadmap like writing test code.\n\nwhat is this communities' advice?"], [4, "You'll only get to unit test my code over my cold, dead body.\n\nAll my code is only perfect and unit tests introduce all imperfection."], [4, "Nah, I won't."], [4, "Think of the coolest operating system, application, game, etc. that you've ever used.  Did the developers write unit tests?\n"], [3, "I've found a happy medium where I only unit test the complicated things that aren't obviously correct. I've gotten into many arguments over this with people who insist higher code coverage is always better. I used to be one of them until I realized I was inflating my estimates by 50-75% to account for all the tests that were going to break when I had to change any code. Too many tests results in brittle code bases."], [2, "Late to the party, but oh well.\n\nI'm lead-developer of a small team of 10 junior/medior software engineers and have been programming (starting out with a simple PHP and MySQL powered website) for almost 18 years now. I'm now a 'full stack'  .NET developer. I would be what you call a 'late adapter'; I stay away from all the hip and trendy languages, techniques and methods that are supposed to be the replacement for something that is still working just fine. Like when about 5 years ago Ruby (on Rails) was supposed to be THE replacement for PHP and .NET, and was supposed to be growing tremendously in popularity. It's still an awkward and pretty uncommon language today.\n\nOften I will get developers or senior software engineers ask me if I use testing library X, framework Y or Agile method Z, and act all surprised when I flat out tell them I don't. Unit testing is one of those terms I often hear fly by from these developers. I don't apply Agile or SCRUM to every project. I don't constantly switch to the newest and hippest Javascript framework/library. And I sure as hell don't forcibly Unit test all my code.\n\nWhy? Because it makes our code, which is very clean and easy to understand, more complex than it should be, and you'll have yet another thing that you'll have to maintain, aside from the code which you already should be taking care of. The majority of the articles I read that are evangelizing Unit Testing have ideal situations to apply them to, such as a simple calculator. It's not always that straightforward in the real world, where you'll have complex API's, Services or Interopable tools where not only Unit Testing can't be applied the way it's always advertised it should, it's also a lot of work and hours you have to reserve purely for implementing (and afterwards maintaining) tests.\n\nKeep it simple, just write maintainable, easy to understand code and have a testing procedure ready to validate your applications. There's nothing wrong with automating repetitive tasks or tests, but implementing unit tests all over your code just because you 'should' is ridiculous. The software we write is far less 'buggy' than the software some of my 'colleagues' in other companies make, who dogmatically unit test everything."], [3, "In an interview with Kent Beck published today in [Java Magazine](http://www.javamagazine.mozaicreader.com/#&pageSet=38&page=0), he moves away from the views expressed here about the mandatory-ness of unit tests: \"So there\u2019s a variable that I didn\u2019t know existed at that time [when Beck viewed tests as mandatory], which is really important for the trade-off about when automated testing is valuable. It is the half-life of the line of code. If you\u2019re in exploration mode and you\u2019re just trying to figure out what a program might do and most of your experiments are going to be failures and be deleted in a matter of hours or perhaps days, then most of the benefits of TDD don\u2019t kick in, and it slows down the experimentation.\""], [2, "No,  if your general purpose languages don't have a type cheker nor contracts,  drop it."], [1, "Yes, no excuses not to write unit tests. Thinking on one of my previous projects that didn't have any tests, these are the three lessons I've learned:\n\n- firstly, write tests!\n\n- secondly, don't neglect the quality of the code when writing tests, testing code is as important as production code, many times the tests can be seen as the documentation of the production code\n\n- and finally, tests should be fast, write many unit tests (fast tests), some integration tests and few UI/ end to end tests (slowest ones); respect the test pyramid\n\nFull story: http://www.softwaredevelopmentstuff.com/2016/10/16/code-testing/\n"], [2, "Well my excuse is I don't get paid for writing unit tests and my superiors told testing is a waste of time.\n\nWhich basically means I am not allowed to write unit tests."], [2, "Don't tell me what to do!"], [2, "Capitalistically speaking, the more time in development, the more opportunity cost. Profit wise, it is better to get the product out early with bugs rather than be late. You can still make $$$, you can have 'senior devs' wake up at night to fix the bugs. Generally speaking.\n\nIt is of course, different if profit is not the goal, e.g. not-for-profit FOSS projects."], [1, "No excuses, budget time in my project to write unit tests.  \n\nYes it might take me about 20 hours to actually add that feature.  It can take 10 - 20 hours to write a worthwhile unit test for it, depending on whether it introduces a new pattern or not.\n\nIf you're okay with that, I promise no excuses, in fact I would much prefer to write unit tests than not."], [1, "I am working on a robotics project for which I don't write unit tests. If anyone can point out how to emulate xbox controller inputs and I2C communication, I would be more than happy to write the tests. "]], [[{"comment": "Very tired of posts about testing using tests for a calculator as the example. It's so artificial to the point of being harmful. No one is going to disagree with writing tests for a calculator because they are incredibly simple to write, run instantly, and will never have a false positive. There are no tradeoffs that need to be made.\n\nLet's see some examples of tests for an application that exposes a REST API to do some CRUD on a database. The type of applications that most people actually write. Then we can have a real discussion about whether the tradeoffs made are worth it or not.", "id": "dam8dxg"}, {"comment": "Or something interfacing a decade old SOAP API by some third-party vendor who has a billion times your budget and refuses to give you an ounce more documentation than he has to. \n\nI'd *love* to write tests for this particular project, because it needs them, but\u2026 I can't.", "id": "dam96xt"}, {"comment": "I do write tests for that. On paper it is to verify my assumptions about how his system works, but in reality it is to detect breaking changes that he makes on a bi-weekly basis.", "id": "damhqki"}, {"comment": "That one's easy. Isolate the soap api behind an interface and add tests cases as you find weird behavior. The test cases are a great place to put documentation about how it really works.", "id": "damnk7m"}, {"comment": "I'm trying to, but, of course, there's no test environment by the vendor (there is, technically, but it's several years obsolete and has a completely incompatible API at this point), nor any other way to do mock requests, so each test needs to be cleared with them and leaves a paper trail that needs to be manually corrected at the next monthly settlement. \n\nIt's a *fun* project.", "id": "damo94i"}, {"comment": "You can create your own interface, IShittySoapService, and then two implementations of it. The first is the real one, which simply calls through to the current real implementation. The second is the fake one that can be used for development, testing and in integration tests.\n\nThe interface can also be mocked in unit tests.\n\nIf you're using dependency injection simply change the implementation at startup, otherwise create a static factory to return the correct one.", "id": "dampyco"}, {"comment": "> You can create your own interface, IShittySoapService, and then two implementations of it. The first is the real one, which simply calls through to the current real implementation. The second is the fake one that can be used for development, testing and in integration tests.\n\nGreat! It's only 50 WSDL files with several hundred methods and classes each, I'll get *right* to it. Maybe I'll even be finished before the vendor releases a new version.\n\nIt's a really, really massive, opaque blob, and not even the vendor's own support staff understands it. How am I supposed to write *actually accurate* unit tests for a Rube Goldberg machine?", "id": "damqp5o"}, {"comment": "That question is answered with the same answer to \"Well how did/do you write a program against that interface *at all* then?\"", "id": "damz4rh"}, {"comment": "Expensive trial and error. ", "id": "dandms2"}, {"comment": "It's a good idea to at least write down what you figured out at such expense. A simulator/test implementation of their WSDL is the formalized way to record it.", "id": "danguxk"}, {"comment": "\\^this...sick and tired of examples that aren't useful to anyone wanting to learn the real value of the subject matter itself.", "id": "dan3v9o"}, {"comment": "If it's straight REST to CRUD, I'd not bother writing any test. Honestly, I try to avoid writing  tests that need any part of a web framework because you generally have to go through all the pomp and circumstance to get a request context and then run the whole thing through. \n\nI'd much rather test some business logic than write another \"assert it called the thing with x, y, z\" -- especially if it's solely to appease the line coverage gods. ", "id": "damv26n"}, {"comment": "It doesn't have to be straight REST to CRUD. There could be validation or some other logic going on. The point is to use an example application that is similar to what a large portion of developers are actually facing every day.\n\nNow you say you would avoid writing tests that need any web framework. I don't want to argue the details here but I disagree: I think for a REST webapp the \"input\" for tests should be a real HTTP request(or something very similar, for example Spring has functionality for mocking a real request that speeds things up a decent amount). I find that those tests find more bugs and are less fragile than traditional unit tests.\n\nI understand that many people disagree with that opinion and that's fine. But the question \"What should testing look like for a web application that has dependencies on a database and/or external services?\" is an open question with no agreed upon answer. \n\nThe question \"What should testing look like for a calculator app?\" has an obvious answer and we don't need to see it again.", "id": "damxlww"}, {"comment": "Unit tests are supposed to be testing the logic of an isolated part of the code. For this purpose,calculator unit test is an excellent example. \n\nREST to CRUD tests represent integration tests. Integration tests are cool and should be written, but there are several drawbacks. They are slow, not 100% reliable and difficult to cover every scenario. Therefore I can imagine it's annoying to write integration tests in a unit test way. \n", "id": "dantdjf"}, {"comment": "The very least I can think of are tests of the request validators (which can be unit tests), maybe response validation as well if you have some sensitive stuff in responses, and functional tests for the actual behaviour (as an authenticated user when I order a dildo i want to receive order details for dildo, as an authenticated user who ordered a dildo I want to see a dildo when I list the products I bought).", "id": "dam9wjj"}], [{"comment": "Eh. Don't adopt dogmatic development practices. Unit tests have a time and place. I prefer code that's correct by construction, code heavy with asserts that maintain invariants, and building things in a way such that they can't have errors. Do all of that and your testing requirements go down dramatically. It's all domain-specific...", "id": "dam5a4x"}, {"comment": "Unfortunately, \"use common sense\" doesn't sell books or attract clicks. It's just like diets.", "id": "dam5seh"}, {"comment": "Ain't that the truth, common sense isn't so common sometimes! It's hard to gain the broad understanding to be able to say \"do the right thing when it's right\". I think the adage goes \"professionals learn all the rules and follow them rigorously to a tee, masters know when to break them.\" \n\nThe more interesting question is this- unit testing isn't needed for a lot of things, but for certain things its absolutely the right tool and does help catch mistakes. Given that a dev shop will have programmers at different stages of their career, some who can  reliably tell the difference and deliver high-quality code with a greater cadance when not being forced into rigid rules, and others who will produce better results if told to *always* author unit tests, is a blanket rule like this going to be a net gain or loss of productivity?\n\nPersonally, I think it's dependent on the shop. If you're in a company that attracts top talent and software is their main business, you're going to have enough high-end talent and you're going to have a culture that values individual development and letting developers learn, guiding them with suggestions but not rules, is going to work best. If you're in a \"lines per dollar\" place, go ahead and enforce the unit test rule. ", "id": "dam6uaj"}, {"comment": "Or you can use the more experienced developers to guide the less experienced developers.\n\nI know it's a crazy idea, but you know...", "id": "damnep2"}, {"comment": "Nah, it's much better to hire entire fleets of coders straight out of college, all the better to indoctrinate them into your broken development process.", "id": "damus44"}, {"comment": "I upvoted you for your first sentence. But \"building things in a way such that they can't have errors.\" is just wrong. It is not constructive. We humans are flawed, we make mistakes every minute. Saying \"do not make mistakes\" does not help. But using the tools that automate our jobs, leaving us less to do and therefore less chance to make a mistake is the right approach and a constructive advise.\n\nThe biggest impact on minimizing my own mistakes was due to moving to haskell as my programming language. Better, smarter compilers that do more work for us is really the only way to reliably eliminate most of human errors.\n", "id": "dam6sbh"}, {"comment": "> But \"building things in a way such that they can't have errors.\" is just wrong.\n\nIs it?\n\nYou can eliminate quite a number of bug classes by construction. If you do not use pointers, you cannot have null-pointer dereferences. If your threads communicate with asynchronous queues and have no shared data, you cannot have data races or deadlocks.", "id": "dam9dn4"}, {"comment": "Except you cannot enforce that. So armies of developers keep using pointers, keep accessing global shared state everywhere etc. This is why progress in the direction of purely functional and very strict with global state compilers like haskell is so important.\n\nThis is why GC in mainstream languages (java, c#) was so groundbreaking. You cannot just tell developers \"oh, do not forget to free the allocated memory\"", "id": "dam9twq"}, {"comment": "Sure you can enforce that.\n\nEither by using a restricted language (e.g. Rust). Or by using static analysis to restrict a standard language: if it finds you instantiating a Mutex object, that's an error. If it finds you accessing pointer `p` outside an `if (p != NULL)` block, that's an error.", "id": "damapxo"}, {"comment": "In other words, use tools to automate your job, as i said, THE ONLY way to reliably eliminate human errors.\n", "id": "damatuo"}, {"comment": "This is begging the question, because computers are by definition tools that automate your job.  The problem is that they need to be programmed to do anything, which takes *work* and introduces human error *at every level of abstraction*.  If an automated tool could really solve our problems, we would be out of a job.", "id": "damvzjh"}, {"comment": "Using `if` clauses for stuff that is not actually a logical condition causes a lot of visual noise though. Use assertions instead.", "id": "damhdzr"}, {"comment": "Using assertions means my program crashes if it fails, or: back to square one.\n\nIf you have a pointer, you either have a true logical condition where the pointer can be null (\"is this the end of my linked list?\"). Or the pointer cannot be null, then you should be using a language construct expressing this (in C++, for example, a reference or a smart pointer that cannot be initialized from a null pointer). The syntactic rule should encourage you to find such solutions to avoid the visual noise.\n\nAssertions are good, but not having to use assert is better.", "id": "damj98g"}, {"comment": "> Using assertions means my program crashes if it fails, or: back to square one.\n\nSo this is going to be rude, but if you sit up and listen you may be better for it.\n\nA program \"crashing\" is the safe thing to do.  Ask a user or company if they'd rather software to \"crash\" or corrupt their data silently for months or years.\n\nIf your response is \"well you can do that with exceptions!\", my answer is who gives a fuck.  The important point is that the software detects a problem and kills itself as a result.", "id": "damnmth"}, {"comment": "This is going to be rude, but survivability is more important than errors at least half of the time.  Whether you are trying to land a space capsule on the moon or writing an email with an unsaved draft, your user is not going to be happy with you if you throw your hands up and crash their shit.  Even a moderately \"simple\" website is going to have multiple more error states than a game of chess and it will try to provide fall-back modes to try to render the page even if it couldn't pull all of its resources, if the markup is mal-formed, if the code throws an error, or even if the user is completely disabled code execution on their machine.  Modern development only begins to pick up where your trusty assert crashes your code.  For better or worse it is programming from within an error state from the first line of code that you write.  It's the bane of our lives but also what we get paid for.\n", "id": "damwooq"}, {"comment": ">then you should be using a language construct expressing this\n\nI'd love to, but I've worked on codebases that conflate null pointers for optional values and `if` clauses that are just here to avoid null pointer dereferencing. It's very easy to silently end up in an invalid state like that.", "id": "damjxnn"}, {"comment": "Sophisticated type systems can eliminate entire classes of difficult to identify and repair bugs just by making it impossible to model an errored state.\n\nOne example:\nhttps://www.youtube.com/watch?v=IcgmSRJHu_8", "id": "damkjek"}, {"comment": "While certain classes of problems can be fixed by better tools and architecture, many can't and the article's point stands.", "id": "damxqe4"}, {"comment": "That's what I meant! Building something in Haskell is exactly building it in a way such that it can't have errors. By using a stricter language you've eliminated entire classes of errors.", "id": "dam6yan"}, {"comment": "I had no idea it was impossible to make software that doesn't work right in Haskell. I guess I should learn it and skip testing.", "id": "damxs97"}, {"comment": "> But \"building things in a way such that they can't have errors.\" is just wrong. It is not constructive. We humans are flawed, we make mistakes every minute\n\nThat's why you should write code that can't have errors.\n\nNote that he didn't say \"doesn't have errors\", he said \"can't have errors\".\n\nExamples of this include:\n\n* Using immutables to ensure that data can't change unexpectedly\n* Using foreach instead of for to avoid off by one errors\n* Using LINQ instead of rolling your own sorting routines\n* Cranking up static analysis to high\n* Using strong parameter validation in library functions instead of relying on the app developer to not pass in bad data \n* Use static typing instead of reflection or dynamic typing\n\n\nIf you use patterns and techniques so that most of your code can't have errors, then you have more time to focus on testing the really hard stuff.", "id": "damgttf"}, {"comment": "You upvoted him  for \"Eh.\" !?!?", "id": "damcrqp"}, {"comment": "Well said. Simple and correct is better than bloated but kinda correct and with a million unit tests.", "id": "damqbmy"}, {"comment": "I like the idea of unit tests. But it's like people are selling them as the savior of our code bases. It's not like that if you have unit tests, your code can never fail.", "id": "danffwz"}, {"comment": "No excuses...unless that excuse is a nasty dependency.  Then write functional tests!", "id": "damgaik"}], [{"comment": "I have a set of libraries that I don't write unit tests for.  Instead, I have to manually test them extensively before putting them into production.  These aren't your standard wrapper around a web API or do some calculations libraries though.  I have to write code that interfaces with incredibly advanced and complex electrical lab equipment over outdated ports using an ASCII based API (SCPI).  There are thousands of commands with many different possible responses for most of them, and sending one command will change the outputs of future commands.  This isn't a case where I can simulate the target system, these instruments are complex enough to need a few teams of phds to design them.  I can mock out my code, but it's simply not feasible to mock out the underlying hardware.\n\nUnless anyone has a good suggestion for how I could go about testing this code more extensively, then I'm all ears.  I have entertained the idea of recording commands and their responses, then playing that back, but it's incredibly fragile since pretty much any change to the API will result in a different sequence of commands, so playback won't really work.", "id": "dam3ar5"}, {"comment": "Yeah people who are really dogmatic about unit testing often haven't worked with legacy code or code that touches the real world a lot.\n\nNot all of software development are web services with nice clean interfaces and small amounts of state.", "id": "dam57cs"}, {"comment": "Well, they advocate TDD which means tests first, code second. Hard to do that with legacy. ", "id": "dam9xip"}, {"comment": "> Hard to do that with legacy. \n\nWhy? Write a test that exhibits the current behavior, then make your change, then fix the broken test.", "id": "damnyg7"}, {"comment": "legacy code is already designed so you can't write tests before designing it without a time machine.", "id": "damxcou"}, {"comment": "A unit being legacy doesn't mean you can't write tests for it.", "id": "damxtkv"}, {"comment": "Problem is that a \"unit\" isn't always a \"unit\" in poor code, if an app has zero tests then it's likely imho that the code is going to be a little spaghetti like anyway. Instantiating one small \"unit\" often means bringing the whole app up. Abandon all hope when ye is the one adding junit.jar to the classpath in a five year old app. ", "id": "damz9bc"}, {"comment": "testing code unit has changed a lot, long time ago, it was just some code of lines that you wanted to test, it even don't necessary have to be whole function, just complicated stuff in the middle that you want to be sure behaves as it should.\nthese days unit is whole class or even whole lib..", "id": "danc9bm"}, {"comment": "I've worked with a lot of legacy code and code that touches the real world a lot, however I'm not sure I'd describe myself as dogmatic about unit testing. Definitely enthusiastic. Sometimes I just don't know how to test something well. But I always feel like I'm doing something wrong. Multiple times I discovered later that it was a lack of imagination on my part.\n\nWriting good tests is _hard_.", "id": "dama32c"}, {"comment": "\"Working Effectively with Legacy Code\" is an _amazing_ book on this topic.", "id": "damgi5i"}, {"comment": "> Not all of software development are web services with nice clean interfaces and small amounts of state.\n\nTypically you can separate your business logic from your interfacing components, which would allow you to test the business logic separately from the hardware you interface with.\n\nI'm not religious about unit testing, but it's an example where the mere thought about \"how would I test this\" could give a good splitting point for the responsibilities you code takes on.", "id": "damh7lu"}, {"comment": "But at least you can test everything around it, so the next time something weird happens you can eliminate some error sources. I would say that, in general, 100% coverage is probably as bad as 0%. Test what you can and you feel is worth it (very important classes/methods etc)\n\nA big black box part in the systen that can't be tested, well don't then but make a note of it to help yourself or the next maintainer in the future", "id": "dam9xpc"}, {"comment": "> I would say that, in general, 100% coverage is probably as bad as 0%.\n\n? Why?", "id": "damciku"}, {"comment": "For one reason, because getting to 100% coverage usually means removing defensive code that guards against things that should 'never happen' but is there in case something changes in the future or someone introduces a bug outside of the component, etc. Those code paths that never get hit make your coverage percentage lower...so you remove such code so you can say you got to 100% code coverage. Congratulations, you just made your code less robust so you could hit a stupid number and pat yourself on the back.\n\nCode coverage in general is a terrible metric for judging quality. I've seen code with 90% plus code coverage and hundreds of unit tests that was terribly written and full of bugs.", "id": "damesu0"}, {"comment": ">Code coverage in general is a terrible metric for judging quality.\n\nThat's definitely true, but that's not the same as saying \"100% == 0%\"", "id": "damgk4j"}, {"comment": "But can't I just add a unit test that calls me method with those buggy inputs? That would raise the test coverage without removing guards. \n\nCould you show a small example where this isn't possible? ", "id": "damg3f0"}, {"comment": "It's pretty simple.\n\nSay you are doing a complex calculation, the result of which will be an offset into some data structure. You validate in your code before using the offset that it isn't negative. If the offset ever becomes negative it means there is a bug in the code that calculated it.\n\nYou have some code that does something (throws an exception, fails the call, logs an error, terminates the process, whatever) if the offset ever becomes negative. This code is handling the fact that a bug has been introduced in the code that does the calculation. This is a good practice.\n\nThat code will never execute until you later introduce a bug in your code that calculates the offset. Therefore, you will never hit 100% code coverage unless you introduce a bug in your code.\n\nSo you can decide to remove your defensive coding checks that ensure you don't have bugs, or you can live with less-than-100% code coverage.", "id": "dammdhk"}, {"comment": "https://docs.python.org/2/library/unittest.html#unittest.TestCase.assertRaises\n\nFairly certain there is an equivalent for every programming language.", "id": "damo3gw"}, {"comment": "How does that help if the condition that the assert is protecting against cannot happen until a bug is introduced in the code?\n\nFor instance:\n\n    int[] vector = GetValues();\n    int index = ComputeIndex(vector);\n    if (index < 0) { // raise an exception }\n\nThe basic block represented by '// raise an exception' will never be hit unless ComputeIndex is changed to contain a bug. There is no parameter you can pass to ComputeIndex that will cause it to return a negative value unless it is internally incorrect. Could you use some form of injection to somehow mock away the internal ComputeIndex method to replace it with a version that computes an incorrect result just so you can force your defensive code to execute and achieve 100% code coverage? With enough effort, anything is possible in the service of patting yourself on the back, but it doesn't make it any less stupid.", "id": "damqu6r"}, {"comment": "> usually means removing defensive code that guards against things that should 'never happen'\n\nYou can just tell the scanner to ignore those lines, I'm guilty of that from time to time. Test the code, not the boilerplate. If the boilerplate is broken then it'll usually be patently obvious within two seconds of firing it up. \n\n> I've seen code with 90% plus code coverage and hundreds of unit tests that was terribly written and full of bugs.\n\nAgree, lots of tests purely to walk the code & not check results, adding very little value over what the compiler does. But there is some value in highlighting things that may be forgotten *and* for keeping an eye on junior devs output. ", "id": "damzkoo"}, {"comment": "The article on how sqlite is tested talks about how defensive code interacts with coverage metrics. https://www.sqlite.org/testing.html#coverage_testing_of_defensive_code\n\nThey have two macros `ALWAYS` and `NEVER` that are compiled out in release builds and when measuring code coverage. The SQLite project uses branch coverage though and appears to commit itself to 100% branch coverage, which I think is uncommon for most software.\n\nFor more Python/Ruby/JavaScript-like languages where unit tests are popular, it seems like it wouldn't be that hard to come up with some kind of marker/annotation/control comment to specifically indicate defensive stuff and exempt it from coverage metrics. I'm not totally convinced that's a good idea since the temptation to boost your stats by marking stuff as defensive might be too great.", "id": "dan40kv"}, {"comment": "A few reasons, law of diminishing returns mostly. To get 100%(*) (or very close to it) you have to test everything (or very close to everything). That takes a lot of time and as soon as you change anything, you have to redo the tests, which takes even more time.\n\nI try to identify the important parts of each component (class, program, etc depending on the setup) and test those thoroughly. The rest will get some tests here and there (mostly with handling invalid data), but I don't feel that getting that 100% test coverage is anywhere near worth the effort it takes. Of course, deciding what \"an important part\" is subjective. Maybe one class really is super important and will have 100% coverage. Cool. But there are probably other classes that don't need 100%.\n\n\n(*): Also you have to define what coverage is, or rather which coverage metric you're going to use. There's a big difference in the amount of tests you probably need to do between 100% function coverage and 100% branch.", "id": "damwcia"}, {"comment": "Set up a testing framework (which usually just means getting junit to run on your build server or something), then start writing tests for new code.\n\nYou don't need to refactor everything immediately, you can start writing unit tests for new code today, though. ", "id": "damchg2"}, {"comment": "I did that once. Then the MD heard we now had \"unit tests\" and told the world we'd embraced Agile. He then considered reassigning the QA team. It was about then I left. ", "id": "damzt48"}, {"comment": "But cant you still write unit tests for the parts of the codebase that don't interface with the lab equipment?", "id": "dam3j2u"}, {"comment": "I'm sure he does. He's just talking about a set of libraries he doesn't write unit tests for.", "id": "dam3v66"}, {"comment": "I have libraries with more tests and documentation than the actual library itself.  I've written extensive tests in some cases where I have to limit the test cases generated so that the test will complete in a reasonable amount of time (2 minutes versus 2 hours).  This is not one of those libraries.  Instead it just has about a 1:1 docs to code line count.", "id": "dam9fsm"}, {"comment": "I have been working on a Linux from scratch install and one of the compiles has maybe 10 seconds of compiling followed by what seemed like an hour for the testing of it.", "id": "damekq4"}, {"comment": "First of all, unit tests only work on things that are unitary themselves. Things that are interface will almost always need integration testing.\n\nNotice that there's nothing wrong with integration, or even end-to-end  tests. They are just expensive, hard to manage and require maintenance on a level that unit tests do not.\n\nSo lets start by chipping away the few places where unit tests make sense. These mostly are making sure that whatever things are defined by standards that won't change on either side soon (such as SCPI) at least is right on your side.\n\nWhat is the value of these tests, if they won't catch bugs in the system you ask? Well they help when there's an integration problem. If your integration/e2e tests find an error that is due to not adhering to the SCPI protocols but the unit tests show that your code is fine, then you can start suspecting and inspecting something outside your code.\n\nYou may also test any internal stuff to your code, but probably, because your code is mostly interface code, you'll want to move on to integration tests.\n\nIntegration tests are the next step. Basically you need to create some sandboxes where you have the specific hardware you are testing and then hardware that mocks everything out. The mocks work with a replay system, I'll tell your recordings come from later. Again the purpose of this is to make it clearer which parts you should focus on, if it's the direct relationship between your library and a piece of hardware, or if it's a more roundabout, weird bug that happens because of changes in multiple areas.\n\nFinally you have the E2E tests, which are basically run the integration tests against the full system (and this is where you record). It also runs your manual tests in a somewhat automated fashion. These tests may break falsely a lot, but using the previous data and manually seeing them you should be able to decide if the breakage was on the test side, or an actual system problem.\n\nNotice that unit tests don't make sense without integration and e2e tests. Their purpose isn't to \"find\" the bug, but to allow you to know which areas the bug certainly isn't on. A unit test that passes when an integration or e2e test fails is proof that your code is correct, but your assumptions weren't (which sadly should be the most common case very quickly by your description).", "id": "damgs1g"}, {"comment": "I've built tests in somewhat similar scenarios in the following way. This may work for you as well, provided that your lab equipment can be set to a known start state after which all future behavior is deterministic or within known boundaries:\n\n1- Create a set of classes whose sole purpose is to call to your lab equipment. Imagine you're designing an API for the lab equipment, within your own code. Put interfaces in front of all of them which can be mocked.\n\n2- Create test double implementations of these interfaces which do not call out to the lab equipment, but instead read from a database, persistent Redis cache, or a JSON file on the disk which acts as a cache. The keys in the cache should be hashes of your inputs to the interface, the values should be the expected responses. If a call to the API is not the first call, denote that when generating the cache key. For example if you call a method with argument X, then call it again with argument Y, your cached values will be:\n\n{ hash(X) : result(X),\n\n (hash(X) + hash(Y)) : result(Y-after-X) }\n\n3- Create another set of implementations of the interfaces, these will call out to the lab equipment, but will also act as a read-through-cache and update the cached values in the file/DB so that the next time the implementations in #2 are executed, they will behave exactly as the lab equipment does during this test run. You can save time here by reusing the implementations designed in step 1 and just adding the cache-writing code to the new classes.\n\n4- Create a set of implementations of the interfaces which simulate expected failure scenarios in the lab equipment, such as connection failures, hardware failures, power outages, etc. These will be used for sad-path testing to ensure that your error handling is correct. Either simulate the failures by causing them, or if they are not something you can cause, use extensive logging to capture the behavior of the lab equipment during failure scenarios to make these classes more robust.\n\nOnce you have these four sets of classes set up, you can use #1 in production, #2 for all Unit/Integration testing in which you expect the lab equipment to behave as it did during your last \"live\" test and do not wish to interact with the lab equipment. #3 for \"live\" System testing with the actual equipment itself, which will also build up the cache that is used for #2. #4 can be used to simulate failures in the lab equipment without having to plug/unplug the actual hardware.\n\nEssentially, #2 and 4 allow you to simulate the behavior of the lab equipment in known happy/sad scenarios without needing access to the lab equipment at all. And when your tests or your equipment change, #3 lets you restore the cached data needed to keep #2 working correctly.\n\nThis is a *lot* of work to build out a set of classes like this for a complex system, but depending on your level of failure tolerance and how much time you're already spending doing manual testing, it may save you time/bugs in the long run. I'll leave that to your discretion. Hope this helps.", "id": "daml9ek"}, {"comment": "That's actually a very well written solution for how to test hardware.\n\nOne thing still bugging me is what to do in a similar situation but when the state of the hardware has \"hidden varables\" - things you can't see or even know exist. ", "id": "dan5i5r"}, {"comment": "If you've written your API in step 1 correctly, then as long as the hardware's behavior is deterministic, any internals of it should be transparent to your code, and are therefore outside the scope of what you should be testing. The hardware is a black box from the perspective of both your software and your testing apparatus. It has a finite range of ways it can be interacted with, and a finite range of possible outputs. The only danger to testing is if the system is nondeterministic.\n\nIf the \"hidden variables\" cause nondeterminism in the system, then I don't know of any way to test a nondeterministic system except for statistical strategies like Monte Carlo testing. \"Run the test 1,000 times. 98% of test results should be within the range X, 2% of the results may be outliers\" and such.\n\nBut testing with the live system in these cases is often prohibitively slow. if the lab equipment has mechanical parts, a series of thousands of tests could easily take hours or days. Likewise, capturing the test results may not be valuable. You can use a test double implementation similar to a Chaos Monkey which uses a PRNG to emulate the observed behavior of the system, but if you emulate it incorrectly, then your tests may be asserting things which aren't really true.\n\nConversely, if the \"hidden variable\" is deterministic, but only exposes itself in edge cases, then once you've isolated it, you can also write tests for the edge cases which cause it to manifest itself.", "id": "danrey1"}, {"comment": "This should go in a book or flyer or something.", "id": "danardl"}, {"comment": "You can make a test script which combines the manual executions and verifies the results its receiving. For example when calling this function of the equipment with these parameters I expect this result. If you need to verify actual graphical output on a screen (or other irl output) it is much more difficult.   ", "id": "dam4kfo"}, {"comment": "Yeah but that's not unit testing by definition, that's integration testing. That's not what the article is about.", "id": "dam59mc"}, {"comment": "OK, but comment's author only wants to automate his work.", "id": "dam5j7w"}, {"comment": "Unit tests integration and end-to-end tests are just tools, the goal is test automation. As with any tool its about choosing the right tool for the job.\n\nUnit tests and quicker and easier to run, so if its possible to write a unit test for the thing you are trying to verify, then its normally the best choice. Integration tests exist to verify the things that can't be reliably verified by unit tests (e.g. database access, DI configuration, deployment process etc...)\n\nI don't see the point in getting caught up on the definition of unit test vs integration test - unless you are extremely lucky you are going to need both to get comprehensive test coverage.", "id": "damenzs"}, {"comment": "I don't think there as any rigid definition on what 'unit testing' specifically entails. But I do agree that my proposed solution will rarely if ever be called a 'unit test'. In any case bheklilr was searching for a specific answer on his problem.\n\nI don't think in his case there is any use for unit testing in the strict sense. If I understand correctly he interfaces with externally created equipment and similarly to how you don't unit test the database you are using, you will not unit test this system you are using.\n\nIf his code is part of the system, and he is developing the interface code, then there might be some value in having unit tests where the instrument is mocked to verify the correct calls are made.", "id": "dam6oy6"}, {"comment": "Unit testing as per Wikipedia :\n\n> unit testing is a software testing method by which individual units of source code, sets of one or more computer program modules together with associated control data, usage procedures, and operating procedures, are tested to determine whether they are fit for use... Substitutes such as method stubs, mock objects,[5] fakes, and test harnesses can be used to assist testing a module in isolation\n\nTo my mind, isolation from other systems, **including the system in which the code runs**, is what defines a unit test.", "id": "damd9c6"}, {"comment": "You should always have a mix of unit and integration testing, for exactly the reasons this guy doesn't write unit tests. Some things need to be glued together to see if they work.", "id": "damdsdz"}, {"comment": "Is this lab equipment still being developed on, such that its API is still changing? Or is it old and frozen?\n", "id": "dama0vp"}, {"comment": "It's old and frozen, but massive and with sometimes inaccurate docs.  Writing a library to interface with it to do everything we need took about a month and a half.  That was with documentation, testing, and review with old, gross code as reference.  An accurate and useful simulation would probably be a year long endeavor, if I'm lucky.  There are so many more important and profitable things for me to work on.", "id": "damaok9"}, {"comment": "> There are so many more important and profitable things for me to work on.\n\nThats the kicker! ", "id": "damdrqf"}, {"comment": "Even 'Uncle Bob', the biggest advocate of TDD, concedes that there are times when TDD is not appropriate. Sounds like you have such a case. ", "id": "damcdof"}, {"comment": "Wouldn't it benefit you in the long run to actually do the relatively complex mocking? My experience of people manually testing complex systems is that they miss most of the bugs anyway, or in the case of having complex formal procedures it just costs a huge amount of time/money. If the legacy system isn't changing much and sticking around forever, better to start automating early.", "id": "damf1xi"}, {"comment": "In this case, no. This particular piece of equipment isn't heavily used in production. We have another type of instrument that is simpler, faster, and can reach higher speeds (50 GHz vs 12 GHz) that we use for the majority of our production test systems. That one I would consider mocking out because I'd only need to handle about 50 commands and the nature of the data makes it much easier to generate or load from disk. \n\nThis particularly annoying type of instrument is mainly used by our lab for specialized tests. We still need to be able to automate it, it's just not as mission critical.", "id": "damybeg"}], [{"comment": "Or better, don't start unit testing, start automatic testing - in whatever form works for you - which may include unit testing\n\nunit testing is not the silver bullet people make it out to be and often introduces a climate of \"well my tests pass it must be perfect\"\n\nfigure out what tests work for you, for web code for example web browser automation is often much more useful than unit tests, write something that clicks around and breaks things. for low level hardware build code that will just automate running against test hardware. \n\ndo what works for you and don't listen to anyone who says there is one true way.", "id": "dam5daq"}, {"comment": "Functional tests are slow, though, and often don't test all the possible code execution paths. I can run 10 000 unit tests in the time it takes to start our automated tests suite (the application takes a minute to connect and authenticate to all the fancy endpoints in our test environment). It's the combination of tests that works quite well.\n\nFor example on my last project we had unit tests for things which had some logic (validators, translators, various algorithms - in general very localized business logic), integration tests to check if contracts between various components were satisfied (for example to check if there were no credit card number leaks from the finance processing module, or if the services called validators on the input), and then on top of that there were functional tests following use case scenarios, both positive and negative. From these we designated some for purpose of smoke tests, too.\n\nWhen you pushed your changes on the feature branch, a build would be triggered. This would run static analysis tools, unit and integration tests related to the modules you just changed, and then would integrate them with the previously built modules and run smoke tests. If all of these passed and your changes went through review and were accepted by at least two other people - you could merge your changes. The acceptance tests would run during nigh builds, and if you fucked something up it would show up as a regression in the morning and you'd have to fix it.\n\nThere were also manual tests, mostly to check proper display of GUIs (automated tests just clicked through workflows and verified that the correct data was displayed, not that it was displayed nicely).\n\nThat system has worked pretty well for me in the past. Various kinds of tests found different errors you could make, from shitty code style (reviews, checkstyle, pmd) through simple logic errors (unit and integration tests) to major fuckups (like incorrect translation of requirements into code - functional tests were always written by another person). What I liked the most was that the feedback for most of the errors was nearly instant (failed CI job).", "id": "dam6v6j"}, {"comment": "Unit tests bind your implementation.  Tests should never care about \"every execution path\" because if they do every change to that execution path requires that you make changes to the tests which instantly negate any value they provided.  How do you know your code works as it did if you had to change the test?  It's like changing the question to make your answer correct.\n\nUnit tests can be very bad.  I have had to delete huge swaths of them because of small architectural changes and there is this false notion I keep seeing that devs assume the whole of the software works as intended based on the fact that the pieces that make it up do.  But that is wrong for the same reason the pieces of a car can be tested to work, but it explodes when you put them together.  The tests tell you nothing, but give you a false sense of security and burden you with worthless maintainance.\n\nThey are definitely not a replacement for feature tests.", "id": "dama9zq"}, {"comment": "I didn't mean execution path in but rather equivalence class of inputs in term of the algorithm. When it's implementation of topological sorting I likely wouldn't write functional tests to check sorting empty graph, graph with a cycle, a tree etc.  This can't be replicated at the level of functional tests because these things are too low level. I would check that in unit tests. \n\nAs to writing tests to interface that's where integration tests come up. I sure as hell want to see that algorithm working properly, even though the interface does not indicate the type of algorithm (there are other strategies for that particular piece of functionality, heuristics and whatnot).\n\nI never indicated that unit tests are replacement for functional tests, but they sure as hell are convenient. They are cheap to write, easily disposable should we need that (as you indicated in your post). Integration and functional tests catch most of the remaining issues. Customers catch the rest. They are simply a nice addition.", "id": "damb226"}, {"comment": "I can agree with that, to some extent.  Caveat being that these unit tests, whilst cheap and convenient, also have very little value and the potential for a massive amount of cost.  They don't tell you if your changes broke the product.  They do increase the test maintainance burden.  They do encourage increasingly complex code to create the micro-testable units.  They create a false sense of security and distort the testing philosophy.  IMO ", "id": "dambyt4"}, {"comment": "which is why i said start testing in whatever form works for you, if that worked for you, great", "id": "dam7rf8"}, {"comment": "This sincerely sounds great. It's hard to imagine a more thorough testing strategy than what you described. In particular the idea of functional tests being written by someone other than implementor is an inspired idea.\n\nBut your system is not possible for many developers, even if we wish it was. There just isn't always time to go to that degree of unit/integration/functional/smoke/manual tests. Sometimes something has to be cut, and I'd argue that unit tests should be the first to go because they have the worst ratio of time spent writing/maintaining them to legitimate regressions identified. ", "id": "damblm7"}, {"comment": "I would generally agree, although there would be pieces of code where I would not allow unit tests to be skipped. Usually the kind of algorithms that are not easy to understand at first glance (be it because they are complicated by nature or due to sloppy writing due to lack of time) and input validation. These are two things which aren't feasible to be thoroughly tested by functional tests, but can lead to big problems in production (I hate writing hotfixes to some very specific algorithms which were based off scientific publications or weird textbooks).", "id": "dambsv3"}, {"comment": "Yeah we've been replying to each other in different comment threads and I think at the end of the day we don't really disagree, we just have different constraints we are working under.\n\nI do agree that there are some specific situations where unit tests are the most valuable form of tests. Definitely any place where you are implementing an algorithm should be unit tested.", "id": "damddl4"}], [{"comment": "I hate those stupid text book examples. Yes, testing an *add* function is easy. But most code doesn't look that way. The really hard part is not unit testing, it is making your code unit testable. That is the interesting stuff.", "id": "dam6f8b"}, {"comment": "Isn't it true that even if you made code unit testable that the units would only be correct but the whole would be wrong?  I see a lot of ideas about trying to make everything unit testable and consider it to be naive.  There is no assurance in Unit tests that when I hit the pedal the car moves forward, even assuming that the carborator is tested and the fuel injection is tested.  In fact, on multiple occasions in multiple projects with ridiculous quantities of unit tests, I have pressed the pedal and the car blows up.", "id": "damb2d1"}, {"comment": "This is why you also have integration tests", "id": "damrx4t"}], [{"comment": "Here's an excuse: As a game developer, especially with gameplay, there tends to be a lot of interconnected components that work together in various ways. It depends a lot on input and on chains of actions and on large data sets. Everything changes continuously. \n\nI've recently started working on a hobby project: Developing vehicle AI. Each AI currently consists of six components that talk to each other (though data does tend to move in one direction). It's still work in progress and I tend to refactor things all the time. Having tests for that would only slow me down, or worse, cause me to not refactor so as to not have to rewrite tests.\n\nI did write a few unit tests for my containers (array and queue and set), and they did find a couple of bugs for me, but are most people really writing code that is no more complex than containers?\n\nAre not all decently complex applications in a lot of flux - is it just game development? Or are people writing and maintaining tests for this type of code? \n\nPersonally I feel like smoketesting is a much wiser strategy for game devs.", "id": "dam5ndr"}, {"comment": "You cannot unit test everything, especially not in gaming. But you can surely test more than just containers.\n\nInstantiate your World class and destroy it immediately. Instantiate your World class, load a level file, shut down. Instantiate your World class, load a level file, attach a renderer, shut down. This is probably not a unit test as defined by the book, but it finds bugs like \"whoops, I destroy this sub-object while the other one still has a pointer to it\", which often goes unnoticed.\n\nInstantiate a simple universe, define a random seed, perform some scripted interaction (\"fire weapon at enemy\"), record the outcome. This gives you a regression test that fires when you accidentally made an incompatible change (aka \"players of version 1.2 and players of version 1.3 cannot play in the same multiplayer game\").", "id": "dam97cb"}, {"comment": "Sure these tests are possible, but do they actually safe time? Making the engine run without a display, adding a complex scripting system and predicting outcomes takes is a lot of work. You already have to do thorough manual testing for most of the features, so is the additional effort really worth it?", "id": "damn44a"}, {"comment": "Unit testing saves you loads of time when you go to make a change later. You'll notice very quickly when an interface is broken.", "id": "damrvr5"}, {"comment": "Yeah, but do I need a unit test or could I just compile and run the program?", "id": "damsy8w"}, {"comment": "are you guaranteed to hit that code path every execution or do you have to remember to look into some obscure path and aim to hit it? Could also be something that takes a while to hit. Do you feel like sitting there for 8 hours until it triggers?", "id": "damt5yp"}, {"comment": "No, but it's mostly new projects and hobby projects that have lots of churn. Over time projects tend to mature and interfaces stabilize enough to make proper testing worth the time. I find proper testing very valuable for games as well once they've matured a bit. Also, unit testing the logic is easy and can cut down on smoke testing significantly.", "id": "dam6hky"}, {"comment": "A lot of games don't mature to a point where most of the codebase is stable and a biz team is adding features to keep the product fresh.  Instead they're shrink wrapped and shipped (even if its just to the app store).\n\nGames also have a ton of QA because you need to test gameplay as well so you already have an automated test structure in place.\n\nEdit: spelling", "id": "dam8xvw"}, {"comment": "If you're coding in C++, you could try using clion. It does a pretty good job of supporting unit tests so when you refactor, it refactors both your app code and unit tests simultaneously (assuming you're using clion's refactoring tools and not doing it manually of course).", "id": "dam952n"}, {"comment": "IntelliJ's suites are mad good in general. ", "id": "damhsfg"}, {"comment": "Sorry, I didn't mean refactor as in renaming things and turning variable accesses into functions. I mean rewriting how systems work, how they store data, their interface, how they push data and what the data looks like. It's hard to automate that. (right?)", "id": "dana9vm"}], [{"comment": "Make me!", "id": "dam46lk"}], [{"comment": "I'd say the fact there's still no proof that unit testing has any benefit whatsoever is a pretty good excuse.", "id": "dam2nym"}, {"comment": "What kind of bullshit is that?\n\nInstantly provides regression assurance from now until the test is removed: Check.  \nForces developer to *focus* and *think* about the problem at hand - more so than just asking them to fix it: Check.\n\n", "id": "dam3m9i"}, {"comment": "Instantly halves your velocity\n\nInstantly doubles or more the code you  have to maintain", "id": "dam4ri0"}, {"comment": "Unit tests are there so when future you or someone else changes how a public function works (optimization, etc), running the test will show you if the function when viewed as a black box, still works as it was expected to before you changed it. \n\nIf you find yourself changing what a function does often, then it's probably not written well.\n\nIf writing a test is too complex, that means the function is also too complex and should be broken down into smaller functions that can be tested, then the smaller functions can be Mocked out in the unit test for the larger function. \n\n\nSo while yes it does increase your code base size, that's not a bad thing if you separate your test code from your code being tested. ", "id": "dam56ki"}, {"comment": "> Unit tests are there so when future you or someone else changes how a public function works (optimization, etc), running the test will show you if the function when viewed as a black box, still works as it was expected to before you changed it.\n\nAnd then you find that never happens so you paid the cost for the test, but never reaped the value in any practical form.", "id": "damodj3"}, {"comment": "I don't know what kind of stuff you write but my unit tests are much simpler than the code they test. They take nowhere near half the time it takes to design and code the actual code. They require maintenance only when you change behaviour of your code, which is again the primary reason why you want them - to avoid doing that unintentionally.", "id": "dam5qf6"}, {"comment": "This is the fundamental issue: I don't want tests that let me know when I modify code. I already know I modified the code. I want tests that let me know if I actually broke something in the process of modifying that code. \n\nIf I write a test and it ever fails there should be one of two reasons: \n\n1) Someone actually broke functionality that the test was verifying in the process of modifying code. They need to fix the application, not the test.\n\n2) Requirements for the application have changed in such a way that the functionality the test was verifying is no longer valid. The test can be deleted because it isn't valid anymore. This should be rare.", "id": "dam7594"}, {"comment": "The second case can be extended to when you actually intentionally change behaviour. I, for example, sometimes add new fields to be passed to the client. This requires me to add things to the output validator (it does not like extra fields which could indicate information leaks) and a new field to be added to the translator between internal model and the external model (that's an additive change, though). These are pieces of code that I did intentionally design to be extended, and the tests were designed to prevent accidental addition of new stuff (again, security reasons). I also don't like code mutations, but in this case it's probably the most sane method of keeping this code in check. ", "id": "dam7lff"}, {"comment": "Yeah I would say that fits in to the second case, although if doing perfect TDD the test would have been modified first to start failing because the new functionality hasn't been added. \n\nMy issue is more about the level of testing: It sounds like in your example you have both a translator and a validator. Having those two things separated is probably a good design decision. \n\nI don't think having separate tests for them is a good decision though. There should be tests at a higher level that doesn't know that a translator or validator even exist. Here's why: \n\nLet's say that for whatever reason I come along and decide that having a translator and validator as separate things was actually a bad design decision. Who knows why I decided that. Maybe I have some legitimate reason or maybe I'm just a bad developer, but either way I've decided I'm going to combine them. \n\nIf there are separate tests that specifically test the validator and other tests that test the translator, at least one half of those those tests are going to start failing because I moved the validator into the translator. That doesn't mean I actually broke anything, it's possible I refactored the code just fine and as far as any client can tell everything is working perfectly. It's also possible that I really am a bad developer and I unintentionally broke several things for the client. Either way the tests aren't helping me anymore because they weren't verifying actual functionality exposed to a client, they were verifying an implementation detail that now has changed.", "id": "dam9yp5"}, {"comment": "Oh these pieces of code are tested at multiple levels.\n\nUnit tests cover base functionality. Then there are integration tests which make sure that the input is verified before being passed to translator. It uses mocks for both, 10 lines with all the java bloat in total (cheap to write, cheap to remoev). Then there are functional tests which push some representative inputs, both correct and incorrect, through, and validate the response.\n\nYour change is going to affect the lower two levels of these tests, just as you want, and if you fucked something up you'd be on the wall of shame the next morning after functional tests are run on the night build.", "id": "dambdkb"}, {"comment": "I think what you're advocating isn't pure unit testing, but integration/functional tests, which are also important.  But yeah, unit tests tend to hate structural refactors, which IMO helps because refactors should have justification outside of personal projects.  I'd be more worried if I made a public-facing change to a module and no tests broke, because that means the tests we have don't cover the code I changed, or the tests are just there to provide a false sense of confidence.", "id": "damdbeg"}, {"comment": "> my unit tests are much simpler than the code they test\n\nThen there's no way they comprehensively test every case that needs to be tested to ensure that you're notified when it breaks.", "id": "damrst8"}, {"comment": "There's plenty of reasons not to test, but if testing is halving your velocity, then your test suite sucks or your code was going to introduce tons of bugs.  Something is not well-designed if writing tests doubles the size of your codebase, and you consider it a maintenance burden.\n\nTests should need almost no maintenance.  Tests should check for regressions on previous bugs, and ensuring proper side effects at the public boundaries of the unit under test.  Go further if the code is used downstream by other developers (such as a library or framework) or if the code is business critical by ensuring proper manifestation of error conditions when unexpected input is encountered, but simple regression tests prevent tons of errors, increase confidence without extensive manual testing, and tighten your development loop by allowing you to verify code without bringing the whole platform up.", "id": "damcc06"}, {"comment": "[On the Effectiveness of Unit Test Automation at Microsoft](http://collaboration.csc.ncsu.edu/laurie/Papers/Unit_testing_cameraReady.pdf)\n\n> After a period of one year of utilizing this\nautomated unit testing practice on Version 2 of a\nproduct, the team realized a 20.9% decrease in test\ndefects. Additionally, customer-reported defects\nduring the first two years of field use increased by\n2.9X while the customer base increased by 10X,\nindicating a relative decrease in customer-reported\ndefects. This quality increase came at a cost of\napproximately 30% more development time.\nComparatively, other teams at Microsoft and IBM have\nrealized larger decreases in defects (62% to 91% )\nwhen automated unit tests are written incrementally\nwith TDD, for a similar time increase. The TDD\nteams had a higher test LOC to source LOC ratio and\nhigher test coverage. These results indicate\nautomated unit testing is beneficial. However,\nincreased quality improvements may result if the unit\ntests are written more incrementally.\n\nIn my experience it really depends on the quality of the tests being written. I have seen many developers test *implementation* (e.g. \"When I have called this function, this other function should have been called as well.\") and  that's just a giant waste of time.", "id": "dam4ejk"}, {"comment": ">After a period of one year of utilizing this automated unit testing practice on Version 2 of a product, the team realized a 20.9% decrease in test defects.\n\nThe team got better at using tests after a year of using tests.\n\n>Additionally, customer-reported defects during the first two years of field use increased by 2.9X while the customer base increased by 10X, indicating a relative decrease in customer-reported defects.\n\nAbsolute nonsense. A larger customer base just means more eyes on the same bugs. You can't double the size of your programmer team and expect to ship in half the time. You can't double the size of your QA team and expect to find double the bugs. There are diminishing returns. A 3x increase in reported bugs seems high: where is the comparison to the control (non-TDD) team?\n\n>other teams at Microsoft and IBM have realized larger decreases in defects (62% to 91% ) when automated unit tests are written incrementally with TDD\n\nKey word here being **automated**, not *unit*. Testing and automation are the cornerstone of programming. Unit tests are a fad.", "id": "damp9rw"}, {"comment": "You're certainly going to do *some* kind of testing, and if you can catch errors automatically, so much the better.\n\nI wonder if you're thinking of [studies like this one](http://dl.acm.org/citation.cfm?doid=2961111.2962592), which actually compare Test First vs Test Last (and found no difference, in this case). Most of the academic literature these days seems to focus on *when* to write automated tests. The question of whether or not you *should* write automated tests is settled.", "id": "dam3m7f"}, {"comment": ">You're certainly going to do some kind of testing\n\nIntegration testing, for damned certain. Because those are useful. My code doesn't run in a silo, what benefit do I get by testing it in said silo?", "id": "dam3sjq"}, {"comment": "Debugging. Once you've identified a problem in your integration tests, unit tests can exercise the smallest amount of code that has the problem. Which makes it much easier to narrow down where the problem is.", "id": "dam4hgx"}, {"comment": "And when the problem isn't in your code? \n\n>Which makes it much easier to narrow down where the problem is.\n\nNow, my opinion, but no. GDB makes it easier to narrow down the problem. Unit tests just tell me there is one.", "id": "dam9bu6"}, {"comment": "The two are complementary. Unit tests provide predictable exercising of the bug (in most cases) and narrow the range of code to check. Then you work the debugger on that test to find the actual problem.", "id": "dam9yul"}, {"comment": "That's mostly just the case in languages like Javascript, were most typos are a bug that needs to be discovered at runtime. If your compiler/interpreter does some basic sanity checks the utility of unit tests goes down a lot.\n\nThere you need to introduce lots of bugs and be really bad at using a debugger if writing and maintaining unit tests is more efficient than occasional debugging.", "id": "dam6ku2"}, {"comment": "I think you stepped on some JS toes there, but I agree. GDB trumps unit tests. Actual debuggers beat out inspection everytime. No unit test is going to show you your stack or your runtime. It will create one for you.\n\nMuch like an integration test would", "id": "dam9e70"}, {"comment": "Good luck testing every single possible code execution path using integration tests.  Integration tests are only good for testing seams between your units.", "id": "dam5aw8"}, {"comment": ">Good luck testing every single possible code execution path using integration tests\n\nThat's kind of how it works in prod, so that's how it should be tested. But you're not going to test all of your *actual* code paths (including those libraries you mocked out) with unit tests. That's a fallacy.\n\n>Integration tests are only good for testing seams between your units\n\n*Poor* integration tests will do that. Great integration tests actually check that components *integrate*. That includes error handling. Unit testing leads to testing imaginary scenarios that **can't** happen because of the way your code integrates. \n\nQED: pointless.", "id": "dam8zqs"}, {"comment": "No, you will barely scratch the surface of your code base if you're only relying on integration tests.  Here's a simple example - for the sake of argument, let's assume that each execution path within a unit requires one unit test.\n\nIf I have 1 unit with 10 execution paths, I will need 10 unit tests for full coverage.  If I have 2 units with 10 execution paths each, I will need 20 unit tests total (10 for each unit), and so on.\n\nThe problem is when I connect those two units together.  If I would only rely on integration tests, in order to fully test all possible combinations, I'd end up not with 20, but 100 tests (because each execution path in first unit, can take one of 10 execution paths in the 2nd unit).\n\nWhat happens when I bring a 3rd unit into the mix?  Yup 1000 integration tests for complete coverage are required, as opposed to 30 if we test all code paths in isolation, plus a couple integration tests to ensure that all units are connected properly.\n\n\n\n> But you're not going to test all of your actual code paths (including those libraries you mocked out) with unit tests. That's a fallacy.\n\nI'm not sure what kind of software you work on, and maybe not testing all code paths is fine in your domain, but it's completely unacceptable in mine.\nWhen it comes to business logic, I absolutely have every path covered (TDD FTW).  And anything that's not under my control, gets abstracted to an interface and mocked, so at least I know my outputs are correct.\n\n\n", "id": "damauy7"}, {"comment": ">The problem is when I connect those two units together. If I would only rely on integration tests, in order to fully test all possible combinations, I'd end up not with 20, but 100 tests (because each execution path in first unit, can take one of 10 execution paths in the 2nd unit).\n\nIdiotic rubbish. It's very likely almost all of those combinations of paths are mutually exclusive.", "id": "damf454"}, {"comment": "I hear you (see my comment else-thread), but the comment about the coarseness of integration tests is good. It's not easy to use them to exercise random scenarios.\n\nProblem with them is also having much of the complete system available, for testing, which is more expensive.", "id": "damcm1k"}, {"comment": "I'm 100% guessing here, but it sounds like units you work with are pretty \"shallow\", in the sense that there's not much actual code happening under API. Maybe it's different kind of system that most people work in. Maybe in your case, testing integration between all components is easier than unit testing.\n\nBut I would also ask myself a question - aren't my APIs too big? Maybe I should redesign my system, to form bigger units with simpler interfaces?\n\nOf course, if you have microservices, then maybe it's intentional and has advantages, I'm not outright criticizing.", "id": "dambah5"}, {"comment": "I suppose they fix regressions when you update said functions but I'm sure integration tests can catch these errors as well. ", "id": "dam4may"}, {"comment": "There's no need to be dogmatic. Isolation, particularly when bug hunting, is an extremely valuable thing. Likewise when designing and developing something for the first time - which is also where \"Unit Testing\" became a thing in the world of software, and even had the proviso of \"Don't focus on it being a *test* but on a design tool\" (to paraphrase)", "id": "dam4mwn"}, {"comment": "> There's no need to be dogmatic.\n\nI agree.\n\n> No excuses, write unit tests\n\nHmm, who's being dogmatic?\n\nYou're right, isolation is valuable.  Write unit tests where you find them most useful, and don't write them where they are least useful.  I don't think the anti-unit-testing crowd is particularly dogmatic, they're just unconvinced.", "id": "dam5xan"}, {"comment": "> Hmm, who's being dogmatic?\n\n/u/Smokey_Circles is very dogmatic about not writing unit tests.", "id": "dam60f6"}, {"comment": "That I am.\n\nI understand that I am not wrong or right per se, this is not about proving I'm smarter than the rest of my industry (I was an arrogant teen once but I promise I grew up a while ago), but I still do not see the value in isolated testing that, in my personal experience, generally runs code that will just simply never be run in prod.\n\nIntegration tests are far more valuable. I disagree with the notion of unit testing for debugging, that seems to be contrary to the point of unit testing and is a far less powerful tool than an actual debugger.\n\nThat being said, the work I do is very small in comparison to the entirety of the field and does not (and cannot) apply to every aspect out there.", "id": "dam8ewg"}, {"comment": "You continue to assume unit testing is mutually exclusive to any and all other tools. Why? Nobody is asserting this. Who said to use unit testing instead of a debugger? Use it in conjunction with it. During debugging, it is useful that upon finding something, you write a small (aka unit) test around that something so that you can repeat it easily and as frequently as you need to, without having to (potentially) step through a load of other arbitrary steps to get there.\n\nLike wise integration tests. They are not mutually exclusive to unit tests. And integration test gives you value for the integration of components, unit tests give you value for small parts of functionality. It is sometimes useful to know if part A is doing its bit correctly, regardless of what part B is doing.\n", "id": "dam9dr9"}, {"comment": "I never once stated that unit testing was mutually exclusive. I'm stating they're redundant and pointless.\n\nIt might be my proficiency in debugging, but I don't need a test to tell me what I already know: Something doesn't work over here -> [stack trace]. \n\n9/10, that something originates from elsewhere. Your unit test has become an integration test.", "id": "dam9jdc"}, {"comment": "Skipping entirely the point about repeatability and isolation to suit your narrative, I see. Good day.", "id": "dam9rif"}, {"comment": "I'm not being dogmatic (though fair enough it comes across like that), this is just my opinion.\n\nThe idea that code architecture will evolve from tests just doesn't gel with me, I have yet to see that happen. I know that people who can already design code can do this, but that's because they already know how to design code. Your design isn't going to magically appear (again, my opinion).\n\nIsolation is a good point, but what about the bugs that crop up in the libraries you mocked out? Furthermore, unit tests are not a debugging tool. At all. They're meant to prevent bugs from occurring, so this feels like a moot concept (still my opinion). \n\nAn actual debugger will trump any unit test any day. Using a unit test *alongside* a debugger is alright, so I can agree that it's not an entirely lost venture", "id": "dam99v8"}, {"comment": "https://www.reddit.com/r/programming/comments/5fprzd/no_excuses_write_unit_tests/dam9dr9/\n\n> You continue to assume unit testing is mutually exclusive to any and all other tools. Why? Nobody is asserting this. Who said to use unit testing instead of a debugger? Use it in conjunction with it. During debugging, it is useful that upon finding something, you write a small (aka unit) test around that something so that you can repeat it easily and as frequently as you need to, without having to (potentially) step through a load of other arbitrary steps to get there.  \nLike wise integration tests. They are not mutually exclusive to unit tests. And integration test gives you value for the integration of components, unit tests give you value for small parts of functionality. It is sometimes useful to know if part A is doing its bit correctly, regardless of what part B is doing.", "id": "dam9jpu"}, {"comment": "My favourite benefit of tests is that I can run single command and check if I haven't broke anything.\n\nMaybe you can avoid unit tests altogether, but can you integration-test all situations that actually happen / run most of your code, even some special cases? If no, then I would be afraid to introduce any changes, because I never know if I haven't broke something.\n\nMaybe it's different when you don't need to introduce changes into existing components very often.", "id": "dam5qsk"}, {"comment": "I agree with this sentiment, but I don't see how *unit* tests add value to that.\n\nA testless system is about as useless as a test to try up your coverage. Without a doubt. \n\nBut I rarely see a unit test that actually adds value and entirely covers you.\n\nFor example:\n\nI write a DAO. This DAO gets called remotely by some client (RMI/RPC/REST w/e). I test the component that's doing the remote call, all good. I test the dao using mocking (or maybe even an in-memory DB) and all good.\n\nI haven't tested that they can actually *speak* to each other.\n\nBut there's more. Those DAO tests are pointless. Your prod code isn't mocked, and it's likely not an in-memory DB. It's an actual instance of something **completely** different to what you tested. Are you *really* certain your DAO is working?\n\nAn integration test is the only way to test that logic. I flatly refuse to accept the value of business logic testing. Not because I don't make mistakes, I do, but because those tests are generally *useless* to the prod stack. This one is harder to demonstrate but what I've seen in my career is how people write tests for \"setSomeState(obj someState)\" or \"testSomeExceptionThatIsActuallyImpossibleToReachBecauseItsCaughtBeforeItGetsHereAndImWastingMyTime()\"\n\nWhilst I know that's not what you're *supposed* to do, that's invariably what ends up happening: Testing code in a manner that is an invalid prod scenario (potentially wasting time trying to fix that nonsense) or is simply outright pointless.\n\nIt can be done, but when all you have is a hammer...", "id": "dam8vcn"}, {"comment": "> But there's more. Those DAO tests are pointless. Your prod code isn't mocked, and it's likely not an in-memory DB. It's an actual instance of something completely different to what you tested. Are you really certain your DAO is working?\n\nNo, I don't. I have tests for DAO, which check its functionality (note - I mean ACTUAL functionality, not \"theoretical\"/\"dead\" - it's important), but those tests don't invoke other components. Then I test that two components communicate with each other, but this time, don't go deep into specifics. Just to check that those two components actually communicate.\n\nDisclaimer: I'm not sure if it's perfect approach to subject, it's just how I do it right now. I would like to learn more too.\n\nAlso, I would ask myself if I really want to test that DAO alone. If it's too small, maybe I shouldn't think about it as an \"unit\". Maybe I should test it as a part of bigger thing. It's a matter of code organisation, so that no component is too small and too big.\n\n> This one is harder to demonstrate but what I've seen in my career is how people write tests for \"setSomeState(obj someState)\" or \"testSomeExceptionThatIsActuallyImpossibleToReachBecauseItsCaughtBeforeItGetsHereAndImWastingMyTime()\"\n\nI was there (actually, I still am struggling with it), and I came to the conclusion that it's a matter of writing good \"units\" (compoents) - not too big, not to small, and with as simple interfaces as possible. You test only those units, not their internals.\n\n> Testing code in a manner that is an invalid prod scenario (potentially wasting time trying to fix that nonsense) or is simply outright pointless.\n\nIt's easy to fail into this pitfail, yeah. If some scenario is not used in prod, then it's \"dead functionality\" and maybe it's time to delete some code :)", "id": "dam9uxl"}, {"comment": "What do you mean by \"business logic\" in the context of DAOs?", "id": "damemz2"}, {"comment": "I'm curious.  If it's settled, then where is the study that settles it?  ", "id": "dam44qt"}, {"comment": "ITT: People confusing unit tests and automated tests.", "id": "dam4ppp"}, {"comment": "Which is so common that we might as well combine the two in practice. The tools to write automated unit tests are often the same ones used to write integration tests. Non-developers conflate the two all the time, and unlike other things, there's not much of a backlash of developers trying to correct them.", "id": "dam50qm"}, {"comment": "Anecdotally, our testing suite has caught a small number of cases where a breaking change or regression was made and would have been accidentally pushed out or caught in a production system otherwise.\n\nSo echoing others, I'd love to see a study saying there is no evidence testing works. \n\nDon't get me wrong, I find writing tests incredibly tedious... but I don't see anything inherently wrong with TDD...  ", "id": "dam3rjw"}], [{"comment": "What about this excuse: I write graphics engines for a living.  Should I spend months writing a software rasterizer to validate the results?  Maybe code up some neural networks to validate that the object is what it should be?\n\nWhy, in 2016, in the field of software engineering, are people still saying that certain things should be or not be done 100% of the time?  Can we just accept that there are no absolutes, and that there is always an exception to the \"rule\"?\n\nEdit: In fairness, I do know of one company that spent months creating a software rasterizer to validate the results of the hardware renderer.  They went out of business - their game looked terrible and they probably should have spent their unit-testing time building a more valuable product.", "id": "dampwso"}, {"comment": "Why do you have to write a software rasterizer? I don't know a ton about state of the art for engines, but my understanding was that the goal was to emit API instructions. So I would imagine unit tests for a graphics engine would *mostly* be about performing some operations and validating that the correct instructions were issued.\n\nUnit tests don't have to be about validating the very final work product. Usually they end where some system boundary you don't control is involved.", "id": "danaz7o"}, {"comment": "The way something looks on screen is effectively driven by a hardware state vector that is composed of:\n\n1.) one or more vertex data (geometry) inputs that describe your mesh.\n2.) one or more texture inputs that define how something looks.\n3.) one or more buffer inputs that send arbitrary parameters to shaders.\n4.) one or more output render targets in which rasterization should occur.\n5.) one or more \"shaders\" (small programs that run on the GPU) that transform, tessellate, deform, and/or shade objects.\n6.) one or more buffers that may be written to by shaders.\n\nSure you can validate your API calls, which is often done, but beyond that, you simply have data and shaders.  You can unit test your shaders to some degree, but then you end up having to write filtering code for sampling textures (mipmap selection and blending, isotropic filtering, anisotropic filtering, and perspective correct interpolation to understand the outputs from the geometry stages - if you have multiple passes, things can get much worse).  At that point, you would end up writing a software rasterizer to validate all of that.\n\nIn short, how something looks isn't just, \"Hey DirectX, draw this for me.\"  It's more of a sequence of disjoint stages and inputs that all have to be combined on the GPU to produce the final result.  If you unit test your API calls, you'll have written only a handful of unit tests, and that often won't help you because the problem isn't that you failed to make the right API call(s) - it's that your data is invalid or being interpreted incorrectly due to a collection of loosely related states.", "id": "daofmxz"}], [{"comment": "Laudable intenti0ns, but the author is **way** too optimistic with the idea that unit testing will save him from production bugs.\n\nIt is really not hard to have all green 100% code coverage tests *and* bugs.\n\nThen, unit tests are generally not used to test for code quality issues like memory/resource leaks, deadlocks and race conditions in multithreading scenarios.\n\nThey are quite useless for performance considerations as well.\n\nSure, unit tests are needed for some ALM aspects, but are **nowhere near** enough.\n\n You need other test kinds as well, and, depending on the nature of your code, they might be leaps and bounds more important than unit tests.", "id": "dambo9o"}], [{"comment": "Why would I spend half an hour fixing unit test every time I change something instead of running the program with a few sample files?", "id": "dam6h7v"}, {"comment": "Why would you spend half an hour running the program with a few example files *after every change* if you could spend one or two hours *once* to codify the expectations in an automatic test? Why would you poke around in the dark after finding a bug if you could have a tireless integration server that runs these tests all the time and tells you when a seemingly unrelated change breaks your test?\n\n(The point is having automatic tests, not having something that someone classifies as \"unit test\".)", "id": "dam8of4"}], [{"comment": "Its great for testing basic functions that involve heavy math computations, risky type conversions, security related functions and so forth. Beyond that, the scheme heads towards diminishing returns very quickly. ", "id": "dam6pcx"}], [{"comment": "The people in here saying that unit tests introduce a massive maintenance burden are off base. Your unit test is for verifying that your function fits it's intended behavior. If you are finding that you are consistently breaking your unit tests, you either wrote your test poorly, wrote your functions too large, or have a horribly defined API. \n\nYour unit tests are only there to test that a logical piece of code does what it's supposed to. That's all a unit test is. In a contrived example it can be something like an `add()` or to give a more real life example it can be a function that returns checks if a user has made a purchase on their account or if two users in a dating app have matched. \n\nI've seen a lot of users here claiming that unit tests are not relevant for them because their codebase is too hard to test in that fashion. Maybe in some cases this is true, but I can't help but feel that some people have written functions that are way too big and therefore can't figure out how to unit test them properly. Your functions should do *one thing* and *one thing only*. Yes, sometimes by necessity you'll need larger functions that rely on many smaller functions to produce a result, but those smaller functions should all be doing *one thing* and therefore make it easy to reduce the larger function to essentially doing *one thing* itself. When your functions are small, they are generally easy to unit test.\n\nFinally, refactoring a function should not fundamentally change it's behavior once the API has been defined and released. This is Software Engineering 101. If this is happening to you, you are either working on a product in v0.X or you don't know what you're doing. Yes, real life makes it difficult to reach the ideal practices of software engineering, but it's horrible practice to consistently release breaking changes in what is supposed to be a stable product. Client developers will despise you and replace your product over time. \n\nSure, unit testing is no silver bullet and might not be worth the effort in every case and 100% code coverage is probably unrealistic in large projects. When you understand a) how to test and, more importantly, b) how to write *software* not just code, you find there are a lot of benefits to these \"best practices\".", "id": "damfbbi"}], [{"comment": "I can name at least 20 reasons not to write unit tests.", "id": "damnuth"}, {"comment": "Go for it", "id": "damo7zn"}, {"comment": "I was bluffing, I can name two at best.", "id": "damoa84"}, {"comment": "If you would have unit tested that first post, you'd have known that it's returning 2 instead of 20.", "id": "damovgb"}], [{"comment": "Unit tests are useless. No excuses not to use strong type systems and not to write proper *integration* tests.", "id": "dam6fq0"}, {"comment": "Strong type systems are not a magic bullet, either (and neither are unit tests, for that matter). Getting it to that level would require solving the Halting Problem.\n\nNor are languages interchangeable pieces. They're an ecosystem of frameworks, tools, and community knowledge. Slapping strong typing onto an old language is only going to cause problems. Slapping unit tests onto an existing code base can be done with some effort.", "id": "damcp35"}, {"comment": "I agree, but I just want to clear up a common misconception about the halting problem. The halting problem only says that given an _arbitrary_ program and an _arbitrary_ input we cannot determine if the program will terminate. The thing is that our programs and our input are often far from arbitrary.\n\nIt's easy to get carried away and think that just because we cannot solve something universally it means we cannot solve it effectively.", "id": "damnbmh"}, {"comment": "How about the time it takes to run that integration test? How about the fact that Integration tests have a smaller code coverage? How about the missing possibility for mutation tests to detect unexpected edgecases? How about the fact that the system I have to extend already uses a given language? \n\n", "id": "damajec"}, {"comment": "> How about the time it takes to run that integration test?\n\nIt is a CI time, not your time. \n\n> How about the fact that Integration tests have a smaller code coverage?\n\n1) It should not.\n\n2) Code coverage on its own is a meaningless parameter.\n\n> How about the missing possibility for mutation tests to detect unexpected edgecases? \n\nDo this with your type system.\n\n> How about the fact that the system I have to extend already uses a given language?\n\nHow about the fact tests are missing from such a code base anyway?", "id": "dambwub"}, {"comment": "> It is a CI time, not your time. \n\nIf i want to know now if something is breaking something it is not CI time. If I need to wait for the CI to finish at some random time in the future and potentially revisit my stuff it delays the process.\n\n> 1) It should not.\n\nI yet have to meet a system where that is the case, but fine\n\n> Do this with your type system.\n\nWhat? That's in no way answering the question. A mutation test tells you that your test isn't breaking if you change something (e.g. >= to >) and thus that you have to write a test that hits this edge case. Doing that means you are explicitly documenting what you expect it to do in this case. That's not something a type system can do.\n\n> How about the fact tests are missing from such a code base anyway?\n\nYeah but my new part can use tests, it can't change the type system.", "id": "damdxzj"}, {"comment": "In my experience integration tests results in smaller code coverage, but it is instead more relevant code coverage. Integration testing is really good at ensuring that you wont deploy a broken version of the application because your tests should cover all the main paths of all your features, while unit tests does not make the same guarantees. To me this is where the value of integration tests lie. I can move fast, with changing requirements and major code refactoring without breaking the application.\n\nI agree with you that unit tests are better at testing the edge cases and getting code coverage, but I personally think that edge cases are better handled with monitoring, fuzz testing, and changing how you write code to reduce the number of edge cases.", "id": "dan2g8q"}], [{"comment": "Nah.", "id": "damn1v5"}], [{"comment": "Here they go again with the 'adding numbers' unit tests...", "id": "damznf1"}], [{"comment": "the article doesn't really address the time problem, though he mentions it explicitly in the first paragraph:\n\n\"There\u2019s fear unit testing will take time your team doesn\u2019t have\"\n\noften my team finds that writing tests will take valuable engineering time away from projects that will immediately drive revenue. many small companies don't have the luxury of a long runway to afford even a couple of hours doing anything off-roadmap like writing test code.\n\nwhat is this communities' advice?", "id": "dam9ik7"}, {"comment": "I think a code base that was developed with unit tests is less error prone and easier and (in the long run) cheaper to maintain.\n\nSkipping them due to business pressures is a kind of technical debt.\n\nA choice between taking on technical debt and going out of business is not really a choice at all.", "id": "damoshm"}, {"comment": "Business needs do drive development priorities.  If you're part of a younger company dealing with explosive growth with lots of change, and especially if you haven't established strong revenue, unit testing is less valuable and shouldn't be prioritized.\n\nHowever, once you have something bringing in revenue, and that something will be around a while to grow, you should start writing tests for that sucker.  Start with writing tests (if it's not burdensome) for any bugs that crop up or are reported by users.  Since code changes frequently, test at module boundaries that verify side-effects rather then implementation which will change and break tests.\n\nWrite tests for any common libraries shared throughout the team/company.  The more it's used, the better the candidate for testing.\n\nWrite tests at the module boundary before a refactor (assuming you have the time :| ). Refactor internally, then verify the tests pass.  You can refactor incrementally in this way while continuously releasing, as priority shifts and your team pivots to meet other opportunities.\n\nBefore tests though, I'd ensure that you have some cheaper, \"softer\" quality control methods in place, such as CI builds on each commit, linting, a bare bones style guide, and versioning using semver: http://semver.org/, followed by analytics on all the things (but especially errors) and logs.\n\nAnother important consideration is testing is dependent on the organization as well as the team.  It takes some time for people to find comfortable and fruitful testing patterns, and lots of devs are only familiar with a single testing methodology, if that.  Find what works for you, and realize that velocity will go up as devs get more comfortable with tests, and you begin to reap the rewards of fewer bugs interrupting day-to-day development.", "id": "damf6z1"}], [{"comment": "You'll only get to unit test my code over my cold, dead body.\n\nAll my code is only perfect and unit tests introduce all imperfection.", "id": "damhf27"}], [{"comment": "Nah, I won't.", "id": "damku3q"}], [{"comment": "Think of the coolest operating system, application, game, etc. that you've ever used.  Did the developers write unit tests?\n", "id": "damoz9h"}, {"comment": "https://github.com/reddit/reddit/tree/master/r2/r2/tests/unit", "id": "damzrgs"}], [{"comment": "I've found a happy medium where I only unit test the complicated things that aren't obviously correct. I've gotten into many arguments over this with people who insist higher code coverage is always better. I used to be one of them until I realized I was inflating my estimates by 50-75% to account for all the tests that were going to break when I had to change any code. Too many tests results in brittle code bases.", "id": "dan0xuo"}], [{"comment": "Late to the party, but oh well.\n\nI'm lead-developer of a small team of 10 junior/medior software engineers and have been programming (starting out with a simple PHP and MySQL powered website) for almost 18 years now. I'm now a 'full stack'  .NET developer. I would be what you call a 'late adapter'; I stay away from all the hip and trendy languages, techniques and methods that are supposed to be the replacement for something that is still working just fine. Like when about 5 years ago Ruby (on Rails) was supposed to be THE replacement for PHP and .NET, and was supposed to be growing tremendously in popularity. It's still an awkward and pretty uncommon language today.\n\nOften I will get developers or senior software engineers ask me if I use testing library X, framework Y or Agile method Z, and act all surprised when I flat out tell them I don't. Unit testing is one of those terms I often hear fly by from these developers. I don't apply Agile or SCRUM to every project. I don't constantly switch to the newest and hippest Javascript framework/library. And I sure as hell don't forcibly Unit test all my code.\n\nWhy? Because it makes our code, which is very clean and easy to understand, more complex than it should be, and you'll have yet another thing that you'll have to maintain, aside from the code which you already should be taking care of. The majority of the articles I read that are evangelizing Unit Testing have ideal situations to apply them to, such as a simple calculator. It's not always that straightforward in the real world, where you'll have complex API's, Services or Interopable tools where not only Unit Testing can't be applied the way it's always advertised it should, it's also a lot of work and hours you have to reserve purely for implementing (and afterwards maintaining) tests.\n\nKeep it simple, just write maintainable, easy to understand code and have a testing procedure ready to validate your applications. There's nothing wrong with automating repetitive tasks or tests, but implementing unit tests all over your code just because you 'should' is ridiculous. The software we write is far less 'buggy' than the software some of my 'colleagues' in other companies make, who dogmatically unit test everything.", "id": "danehpn"}], [{"comment": "In an interview with Kent Beck published today in [Java Magazine](http://www.javamagazine.mozaicreader.com/#&pageSet=38&page=0), he moves away from the views expressed here about the mandatory-ness of unit tests: \"So there\u2019s a variable that I didn\u2019t know existed at that time [when Beck viewed tests as mandatory], which is really important for the trade-off about when automated testing is valuable. It is the half-life of the line of code. If you\u2019re in exploration mode and you\u2019re just trying to figure out what a program might do and most of your experiments are going to be failures and be deleted in a matter of hours or perhaps days, then most of the benefits of TDD don\u2019t kick in, and it slows down the experimentation.\"", "id": "danepxa"}], [{"comment": "No,  if your general purpose languages don't have a type cheker nor contracts,  drop it.", "id": "dam5en6"}], [{"comment": "Yes, no excuses not to write unit tests. Thinking on one of my previous projects that didn't have any tests, these are the three lessons I've learned:\n\n- firstly, write tests!\n\n- secondly, don't neglect the quality of the code when writing tests, testing code is as important as production code, many times the tests can be seen as the documentation of the production code\n\n- and finally, tests should be fast, write many unit tests (fast tests), some integration tests and few UI/ end to end tests (slowest ones); respect the test pyramid\n\nFull story: http://www.softwaredevelopmentstuff.com/2016/10/16/code-testing/\n", "id": "damosbq"}], [{"comment": "Well my excuse is I don't get paid for writing unit tests and my superiors told testing is a waste of time.\n\nWhich basically means I am not allowed to write unit tests.", "id": "danctlv"}], [{"comment": "Don't tell me what to do!", "id": "danfwit"}], [{"comment": "Capitalistically speaking, the more time in development, the more opportunity cost. Profit wise, it is better to get the product out early with bugs rather than be late. You can still make $$$, you can have 'senior devs' wake up at night to fix the bugs. Generally speaking.\n\nIt is of course, different if profit is not the goal, e.g. not-for-profit FOSS projects.", "id": "dang3c2"}], [{"comment": "No excuses, budget time in my project to write unit tests.  \n\nYes it might take me about 20 hours to actually add that feature.  It can take 10 - 20 hours to write a worthwhile unit test for it, depending on whether it introduces a new pattern or not.\n\nIf you're okay with that, I promise no excuses, in fact I would much prefer to write unit tests than not.", "id": "damie8y"}, {"comment": "20 hrs for feature - does it also include fixing bugs & regressions later? :-)", "id": "damk2k7"}], [{"comment": "I am working on a robotics project for which I don't write unit tests. If anyone can point out how to emulate xbox controller inputs and I2C communication, I would be more than happy to write the tests. ", "id": "damivx0"}]]], "5foj41": ["An alternative take on what's new in Git 2.11", "2016-11-30 11:19:25", 40, "http://blog.deveo.com/whats-new-in-git-2-11/", [[6, "Nice article, but man are those ligatures distracting:\n\n    git-\ufb01lter\n    git di\ufb00\n    .gitcon\ufb01g (OK that one isn't so bad)\n\nIt's so weird to have a fixed-width font with ligatures. "]], [[{"comment": "Nice article, but man are those ligatures distracting:\n\n    git-\ufb01lter\n    git di\ufb00\n    .gitcon\ufb01g (OK that one isn't so bad)\n\nIt's so weird to have a fixed-width font with ligatures. ", "id": "dam12l0"}, {"comment": "There is [FiraCode](https://github.com/tonsky/FiraCode)", "id": "dambfib"}, {"comment": "+1 for this font, I use this in all my tools. ", "id": "damcmeu"}, {"comment": "I only installed it a few days ago. The enhanced legibility this font brings is amazing. ", "id": "damd1hp"}, {"comment": "Honestly I don't even understand, is it just a font?", "id": "damtvxt"}, {"comment": "Sure. With ligatures. ", "id": "dan7ywe"}, {"comment": "There is way more to fonts than just a set of glyphs. There are all sets of rules embedded into the font that allows different representation based on different character combinations. In non-monospaced fonts, different letter combinations have different kerning, so words look more natural.\n\nType 1 Postscript fonts blew everyones minds when they were first introduced.", "id": "danog14"}, {"comment": "So these somehow add all the fancy => characters? Is that even a standard though? It would surely be more widely used if it was.", "id": "danoi3q"}, {"comment": "Completely standard. Fonts can do all sorts of things.", "id": "danrdxg"}, {"comment": "I had the exact same thing happening to me in omnigraffle it was so annoying. ", "id": "dam4s23"}, {"comment": "What has been seen cannot be unseen! I have to admit, I haven't paid that much attention to the styles as I'm editing the posts in markdown with ghost. I'll pass this information with the appropriate screenshots to our UX/UI guy.\n\nThanks for pointing this out! Most definitely an eye opener.", "id": "danbd2r"}]]], "5fyxw7": ["Smalltalk and protein programming", "2016-12-01 23:28:24", 9, "https://hackernoon.com/smalltalk-and-protein-programming-4da245ac93e2", [], []], "5g3mhu": ["[Video] How to explore creativity as a programmer", "2016-12-02 17:50:32", 0, "http://blog.testdouble.com/posts/2016-12-01-a-creativity-talk.html", [[1, "This is a talk I did earlier this fall. It's a little hard to explain other than to say it's a discussion on how to practice creativity to improve yourself even if you don't consider yourself a \"creative type\""]], [[{"comment": "This is a talk I did earlier this fall. It's a little hard to explain other than to say it's a discussion on how to practice creativity to improve yourself even if you don't consider yourself a \"creative type\"", "id": "dap5pz3"}]]], "5g1wsz": ["Amazon Lex \u2013 Build Conversational Voice and Text Interfaces", "2016-12-02 09:48:07", 40, "https://aws.amazon.com/blogs/aws/amazon-lex-build-conversational-voice-text-interfaces/", [], []], "5frj4h": ["masterkey: secure interactive password manager using NACL and Go [X-Post /r/golang]", "2016-11-30 22:18:49", 1, "https://github.com/johnathanhowell/masterkey", [[1, "X-Post referenced from [/r/golang](http://np.reddit.com/r/golang) by /u/fighterjet-biceps  \n[masterkey: secure interactive password manager using NACL and Go](http://np.reddit.com/r/golang/comments/5f1a27/masterkey_secure_interactive_password_manager/)\n*****  \n  \n^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)"]], [[{"comment": "X-Post referenced from [/r/golang](http://np.reddit.com/r/golang) by /u/fighterjet-biceps  \n[masterkey: secure interactive password manager using NACL and Go](http://np.reddit.com/r/golang/comments/5f1a27/masterkey_secure_interactive_password_manager/)\n*****  \n  \n^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)", "id": "damfv3n"}]]], "5fksj3": ["Always check your new IP addresses", "2016-11-29 22:47:28", 46, "https://varaneckas.com/blog/check-your-ip/", [[18, "While I do feel sorry for the OP, I think he drew the wrong lesson.\n\nHis project, his *livelihood*, were hurt because he depended on huge corporation allowing him to work with them, and they were too lazy to not rely on IP blacklisting. Simply put, they have way too much power, and way too little responsibility.\n\nThis over-centralization of the internet must stop. I want the right and the ability to host my server at home.  I don't want to need YouTube, Facebook, or Gmail. But I do, because my ISP didn't gave me enough upload power, because I'm not allowed to host a server, because they block some ports, or because lazy mega-corps flag all residential IP as filthy spammers.\n\nChecking your new IP address? Sure. But never forget this is only a stopgap measure. The endgame is much bigger.\n"], [16, "How does one \"check\" an IP address?"], [7, "So how did Tom Warr get a new personal account merged with an old blocked account? With a different name and birthday?"], [4, "What if IP banning just isn't effective? Most troublemakers know that they'll most likely get a new IP if they power cycle their modem. \n\nTeaching my mom A: what an IP is, B: how to find out what hers is, and C: how to \"check it\" is just a ridiculous thought."], [2, "IPv6 solves this (ipwise) ... or makes it worse (spamwise)"], [-1, "Well, you know -- if you open up a luxury hotel in a ghetto, don't expect the fine customers to just find their way to you and book your rooms and stuff. The notion of undesireable addresses translates well into the information technology realm."]], [[{"comment": "While I do feel sorry for the OP, I think he drew the wrong lesson.\n\nHis project, his *livelihood*, were hurt because he depended on huge corporation allowing him to work with them, and they were too lazy to not rely on IP blacklisting. Simply put, they have way too much power, and way too little responsibility.\n\nThis over-centralization of the internet must stop. I want the right and the ability to host my server at home.  I don't want to need YouTube, Facebook, or Gmail. But I do, because my ISP didn't gave me enough upload power, because I'm not allowed to host a server, because they block some ports, or because lazy mega-corps flag all residential IP as filthy spammers.\n\nChecking your new IP address? Sure. But never forget this is only a stopgap measure. The endgame is much bigger.\n", "id": "dal5pym"}, {"comment": "\nI moved a mail server 3-4 months ago. It was suddenly blocked by hotmail / gmail and various other large providers. So I left it and asked the users of hotmail / gmail etc... to complain that they could not get email from me. There was a few large groups / clubs (not internet related) basically raised tickets at their end because they were not getting club updated and the problem was resolved by the receivers not by the senders.\n\nThe sad thing is that I checked the ip address against blacklists as soon as I knew what it was... But it was the subnet that was blacklisted since it was a cheap vm hosted machine and had been used as a spam source in the past. However the hosting company does action abuse complaints and does kick its users for spamming very quickly but it still doesn't seem to help things.", "id": "dalag91"}, {"comment": "As the admin, you are supposed to contact Hotmail and Gmail directly to ask to be unblocked.  I've had a few servers that were blocked by them when we got them, and we were able to have them unblocked.", "id": "daldiio"}, {"comment": "\nWhich is basically absolutely pointless as the OP pointed out. While they might accept your email's it will still place it in junk. Since most people's junk box contains so many messages nobody really bother to fill it out any more.\n\nThe issue here is that is exactly the same thing that the bulk email providers are also going to be doing. So how can hotmail / gmail possibly act on these requests?\n\n\n", "id": "dalukog"}, {"comment": "> Which is basically absolutely pointless as the OP pointed out. While they might accept your email's it will still place it in junk.\n\nI am not sure what you are sending, but the emails we send are not going to junk folders.\n\n> The issue here is that is exactly the same thing that the bulk email providers are also going to be doing. So how can hotmail / gmail possibly act on these requests?\n\nThey filter the content of the emails to see if there is a pattern of them being junk?  The check if you are a repeat offender?  And, for the bulk senders like Amazon SES, Mandrill, and others, they actually penalize you if you have high bounce rates, because then it leads to them having their IPs blocked, and they have to fight it, so the good bulk senders will deal with issues, and the bad ones won't.  \n\nI mean... how would you deal with any of this on a personal email server to avoid junk?", "id": "dam4d9d"}, {"comment": "\nNo they don't filter on just the content. They score them on the headers as well. Have a look at how really common software like that works you know like spamassasin....\n\nFor me personally the only thing that actually changed from emails not being junked by somebody like hotmail was the ip address of the server. The domain, contents, messages, recipients basically didn't change pattern very much as they were normal conversations. The messages and things being sent didn't contain attachments, links, images or any other crap. It was more thing like a list of meeting dates for some local clubs.\n\nSo the solution to this was to have the recipients raise support with their email providers for false positive junking of emails. You should also be aware that other mail providers (the majority) made up of various isp's and other companies etc.. were not blocking / junking these emails. That makes it a receivers problem not the senders. Especially when companies like hotmail won't actually respond to the sending side in a timely fashion or just give you fob off genetic response.", "id": "dam7144"}, {"comment": "> No they don't filter on just the content. They score them on the headers as well. Have a look at how really common software like that works you know like spamassasin....\n\nBut if they unblock your IPs, and you set your proper headers, they would filter based on the content of the email.  That was my point.  You asked how they would handle it, that's how they would handle it.\n\n> For me personally the only thing that actually changed from emails not being junked by somebody like hotmail was the ip address of the server. \n\nYep, I get that, so request the IP address be unblocked.  Every major email host has a process for doing it.  Most recently, I had to do it for AT&T.\n\n> So the solution to this was to have the recipients raise support with their email providers for false positive junking of emails.\n\nNope, the solution is for you to contact them and go through their process of getting your server address of their black list.\n\n> You should also be aware that other mail providers (the majority) made up of various isp's and other companies etc.. were not blocking / junking these emails.\n\nYep, everyone chooses what to block differently, and again, as the person sending the email, it is your job to contact them and find out why they are blocking you, resolving the situation (if there is one), and requesting that you be removed from the black list.\n\n> That makes it a receivers problem not the senders. \n\nIt's not their problem though.  It's yours.  You are the one sending emails, you are the one that wants the recipients to see the email, so it's your problem, not theirs.\n\n> Especially when companies like hotmail won't actually respond to the sending side in a timely fashion or just give you fob off genetic response.\n\nAre you contacting their support team for general users, or are you contacting them via this?\n\nhttps://support.microsoft.com/en-us/getsupport?oaspworkflow=start_1.0.0.0&wfname=capsub&productkey=edfsmsbl3&ccsid=635688189955348624&wa=wsignin1", "id": "dam8h57"}, {"comment": "\nYpu I did that as well to start with. It went no where because hotmail doesn't have enough support staff to deal with outside admins. I was met with automated messages and was required to sign up to a live account and all sort of stupid things to actually get anywhere with them step which I did follow. Which still didn't actually get me anywhere.\n\nWhat I am actually telling you here is what actually happened and the step that did eventually work to resolve the situation. Which was for their users to contact the support of their email provider and say it was junking / filtering valid emails.\n\nI am well aware it was their choice to block / filter however they want but its also their job to support their users and their users complained so they supported their users just like any provider should.", "id": "damc7sq"}, {"comment": "Consumers have weak upload because it's a lot cheaper to shortchange consumer upload and spend that extra money on datacenters with huge upload", "id": "dala7ow"}, {"comment": "Consumers have weak upload because the frequency spectrum on the cable was once chosen that way when consumers did mostly download stuff.\n\nFor fiber internet, at least here in the netherlands, most have synchronous upload and download speeds.", "id": "dalaso9"}, {"comment": "Here in France, many internet providers tend to keep it asymmetric, even with the fibre, where the cheapest bulk offer is symmetric Gb/s. I'm not sure why.\n", "id": "dalh3hq"}], [{"comment": "How does one \"check\" an IP address?", "id": "dalmkml"}, {"comment": "Yeah I feel like that's the missing piece of this post. I'm not really sure what I would do to check an IP address.\n\nI suppose you could try to contact all the services you think you'll be using for your project, but that's likely going to change as you develop.\n\nI feel like the bigger takeaway for me is that DigitalOcean droplets are so cheap, spammers use them. If you choose to use one, you should be aware that the IP space they own likely has a larger percentage of banned addresses compared to other services, and it's possible that you'll end up with one.", "id": "dalnj2m"}, {"comment": "Internet has ton of tools for this. http://rbls.org for example.", "id": "dalogzt"}, {"comment": ">Spamhaus  \nBAD listed in PBL\n\nInteresting, I wonder why my IP is on that list..\n\n>The Spamhaus PBL is a DNSBL database of end-user IP address ranges which should not be delivering unauthenticated SMTP email to any Internet mail server except those provided for specifically by an ISP for that customer's use. The PBL helps networks enforce their Acceptable Use Policy for dynamic and non-MTA customer IP ranges.\n\nUh, so if I understand this, my ISP put me on the list?", "id": "dalr5yj"}, {"comment": "Exactly.", "id": "dalsfgz"}, {"comment": "If it's your home IP, it's standard by consumer ISPs to blacklist the consumer IP ranges to prevent spam and stuff like that, as consumer IPs are a common source of spam thanks to viruses/kids/etc. It's nothing to worry about (except when you want to actually send legit stuff from your home).", "id": "dama18o"}, {"comment": "Not exactly.  The fact that you have a \"residential\" (Comcast, Verizon, etc) ISP and you shouldn't be delivering mail directly put you on that list.  Spamhaus did it unilaterally since you \"shouldn't\".", "id": "dama4tv"}], [{"comment": "So how did Tom Warr get a new personal account merged with an old blocked account? With a different name and birthday?", "id": "daliqck"}, {"comment": "Apparently because I was registering new Facebook account from same IP address that my old account was using. Or they used my browser fingerprint. I cleared the cookies before registering.", "id": "dalobyi"}], [{"comment": "What if IP banning just isn't effective? Most troublemakers know that they'll most likely get a new IP if they power cycle their modem. \n\nTeaching my mom A: what an IP is, B: how to find out what hers is, and C: how to \"check it\" is just a ridiculous thought.", "id": "dakym94"}, {"comment": "It's about new server IP addresses, not about banning troublemakers by IP.", "id": "dakyx6h"}, {"comment": "It says always.\n\nAnd the article is about an IP having been banned by someone else (probably a troublemaker), and you inheriting it. \n\nI'm looking at the root of the problem: The common practice of IP banning. ", "id": "dakyy0b"}, {"comment": "> I'm looking at the root of the problem: The common practice of IP banning.\n\nYes, amen to that.", "id": "dakz3o1"}, {"comment": "\nIP banning isn't effective in the long run. It only works in the short run because spammers / scammers / abusers will have a new ip address the next day. Then some poor guy get the old ip and nothing works. The back lists need to be easy on / easy off...\n\nI keep a months worth of blocks for ssh.... I have a count of 500 or so blocks in it currently which is based of auth failures (4-5 required to be listed). The thing is if i were to actually do a whois and send the logs to the abuse complaint. Nothing... Absolutely nothing will actually happen. I will continue to see connect attempts for days / weeks afterwards. This is what really need sorted....\n\n", "id": "dalb1a1"}], [{"comment": "IPv6 solves this (ipwise) ... or makes it worse (spamwise)", "id": "dal0bfp"}, {"comment": "\nI don't really see the difference in ipv6 spam wise. I mean whats really going to happen is instead of banning the unique ip. Once you see a bunch from the same prefix it will just get the prefix banned. Then keep stretching the bitmask....", "id": "dala8vl"}], [{"comment": "Well, you know -- if you open up a luxury hotel in a ghetto, don't expect the fine customers to just find their way to you and book your rooms and stuff. The notion of undesireable addresses translates well into the information technology realm.", "id": "daltyet"}, {"comment": "So you are saying that a personal blog or small project that doesn't need top hardware and can run perfectly well on $5 VM by utilizing cache and CDN still has to be treated like shit because of low operational expenses?", "id": "dalu8ko"}, {"comment": "Well, IPv4 space is scarce, isn't it? What did you expect? Internet-wide police force cleaning up in the address space by sifting through white- and black-lists? That would be nice, but we don't have it. It's more like Wild West out there currently. I just wanted to be realistic, hence my original comment.\n\nI also wished Internet, at least the IPv4 layer of it, wouldn't be such a \"wild\" place. That bullies like Google and Facebook etc, wouldn't just do pretty much what they please, blacklisting entire networks because of what THEY consider spamworthy traffic or whatever. I really am against that kind of Internet. So I am principally not objecting to the points author of the article makes, quite on the contrary.\n\nBut I like to use analogies from real world, and I think the address analogy applies well.", "id": "dandovi"}]]], "5fqh8v": ["Why I Wrote a Book About Interpreters", "2016-11-30 19:22:12", 89, "http://thorstenball.com/blog/2016/11/30/why-i-wrote-a-book-about-interpreters/", [[18, "Great work. I also wrote a lexer, parser and interpreter for a small imperative language, completely disregarding any overly-abstract academic literature, third-party tools and stupid articles about parsing a lispy language (because S-expressions are really trivial to parse and it is utterly stupid to pretend that such parsers illustrate parsing in general).\n\nThe complete implementation is about 1300 lines of C11 code without relying on anything but the standard library: https://github.com/bbu/simple-interpreter. Could be of great educational value, IMO."], [9, "> you need to know to build an interpreter from scratch, including your own lexer, your own parser and your own evaluation step. No skipping of anything!\n\nFor what it's worth, I wish fewer articles described how to write parsers because this part is not just heavily documented everywhere, it's actually supported by a great deal of actual science and mathematics. Parsing is a solved problem and writing a manual parser these days makes as much sense as cooking a pie by starting by building a kitchen from scratch.\n\nWhat the world needs is more articles on the hard parts of writing a compiler:\n\n- Code generation.\n- Error reporting.\n- Error recovery.\n- Plug-in API so that tools can be written on top of it (e.g. IDE's).\n\n"], [6, "> And you don\u2019t need to be well versed in mathematical notation either! It should be a book any programmer can read and understand.\n\nIt's generally a good idea to understand mathematical notation. It's well worth learning. Most things can be expressed and thusly understood very easily and elegantly using mathematical notation. Also most correctness proofs are heavy on mathematical notation as are many papers."], [3, "You can take [Stanford's Compilers course](https://lagunita.stanford.edu/courses/Engineering/Compilers/Fall2014/about) for free. "], [2, "> What a lexer, a parser and an Abstract Syntax Tree (AST) are and how to build your own\n\nThis is of particular interest since I've seen a lot of books/ tutorials that show you how to use them and not to build them (or you build a lexer, which is dead easy, but then use yacc et al)"], [2, "I'll have to check out your book! I was also inspired by the meta-circular evaluator in SICP and made a non-GC implementation of it in under 1000 lines of C with a recursive descent parser. It's amazing how simple yet powerful s-expressions are. \n\nIn case anyone wants to take a look, [heres the code](https://github.com/lazear/microlisp)"]], [[{"comment": "Great work. I also wrote a lexer, parser and interpreter for a small imperative language, completely disregarding any overly-abstract academic literature, third-party tools and stupid articles about parsing a lispy language (because S-expressions are really trivial to parse and it is utterly stupid to pretend that such parsers illustrate parsing in general).\n\nThe complete implementation is about 1300 lines of C11 code without relying on anything but the standard library: https://github.com/bbu/simple-interpreter. Could be of great educational value, IMO.", "id": "dambf98"}, {"comment": "What an amazing project! Thanks for posting it.\n\nI also think that you made an excellent point regarding s-exps. Never thought about it that way.", "id": "damc4xz"}, {"comment": "If only you people who do such projects really wanted to disregard all the Dragon Book-style bullshit. Yet, all of you fall for the same thing - you implement lexers. In 21st century. *Lexers*!!!\n\nPlease, please, stop doing this. Lexerless parsing is far better.", "id": "damdmff"}, {"comment": "What's wrong with lexing, which is essentially parsing in two passes?\n\nOptimizing compilers make many passes from AST to IR to code generation, so using multiple passes seems like a good technique to limit complexity in general.", "id": "damsnui"}, {"comment": "> parsing in two passes\n\nThis is exactly what's wrong with it. It means you're supposed to have the same set of tokens in all the contexts. Everywhere. Inside your interpolated strings. Inside the regular expression literals. Inside the comments. Inside annotations. \n\nIt means you cannot safely embed one language into another, cannot mix the languages. \n\n> Optimizing compilers make many passes from AST to IR to code generation\n\nAnd almost all the passes all the way down are on *trees*.\n\nLexer is different. It screws up any possible context and spits out a *flat list* of tokens.", "id": "damteij"}, {"comment": "If you want to embed another language, you could treat it as a single token and pass it on to the next stage.  Actually, embedded languages are an argument *for* multi-stage parsers, because it would be trivial to compose multiple parsers as multiple passes.", "id": "daogcue"}, {"comment": "> treat it as a single token \n\nYou do realise it's an exceptionally stupid limitation? Think of the interpolated strings again - there is a fallback to the host language expression syntax. Which may contain another interpolated strings. How many times you're expecting to re-run your parser?\n\n>  because it would be trivial to compose multiple parsers as multiple passes.\n\nIt's idiotic and it will not work (see above). Composing lexerless parsers is far easier than this abomination.", "id": "daowaqa"}, {"comment": "Besides web stuff, what language embeds another language?", "id": "dan77nd"}, {"comment": "All sorts of stuff.\n\nIt's super common in Ruby and Python for instance; especially in Chef/Puppet contexts.", "id": "dan7l0t"}, {"comment": "Inline asm in C, C++ and D. Regular expressions. QML in Qt and DML in [DlangUI](https://github.com/buggins/dlangui). Grammars in [Pegged](https://github.com/PhilippeSigaud/Pegged). And so on...", "id": "danhre3"}, {"comment": "Ah that's right, but I feel like inline asm tokens aren't as different as C lang tokens, especially inline syntaxes that do not support expression trees.", "id": "dani0sz"}, {"comment": "All the languages *must* be able to embed the other languages. Those that don't are worthless.\n", "id": "daney34"}, {"comment": "I'm convinced. Do you know of any good resources about lexerless parsing?", "id": "danmfl9"}, {"comment": "http://bford.info/packrat/\n\nhttps://en.wikipedia.org/wiki/GLR_parser\n\n", "id": "dann7gp"}, {"comment": "I agree. I've always disliked the literature doing this. It isn't necessary.", "id": "danagra"}, {"comment": "Why the mbase tutorial includes a lexer then,  hmm? Pretty much promoting such outdated practice and render itself useless.", "id": "damii7a"}, {"comment": "Tutorial itself is outdated. But introducing PEG straight away would have been too harsh.", "id": "damikt1"}, {"comment": "That's ok. I was being sarcastic.", "id": "damir4j"}, {"comment": "Anyway, thanks for a reminder to get rid of an over 10 years old tutorial.", "id": "damja4v"}, {"comment": "Np.", "id": "damkdzw"}, {"comment": "> because S-expressions are really trivial to parse and it is utterly stupid to pretend that such parsers illustrate parsing in general\n\nIt's a bit arrogant to consider oneself to good for \"lisp parsing\". Someone also could look at your project and say \"it's utterly stupid to pretend it's worth anything\". There will always be a developer smarter than you that will judge your work as trivial and not worth of interest. Furthermore plenty of pro devs out there have never written a parser in their lives. You don't need to know how to write a parser to write an application. \n\nAnd now here is a free tutorial about implementing a lisp like language in javascript :\n\nhttp://lisperator.net/pltut/\n\nAnd remember folks, you'll always be outsmarted by someone else.", "id": "damci69"}, {"comment": "I think his point is that writing a parser for s-expressions is significantly simpler than writing one for the types of expressions you'd see in most languages. He's not saying he's too good for lisp; he's saying that if you really want to learn about parsing you might learn more from something other than s-expressions.", "id": "damo01x"}], [{"comment": "> you need to know to build an interpreter from scratch, including your own lexer, your own parser and your own evaluation step. No skipping of anything!\n\nFor what it's worth, I wish fewer articles described how to write parsers because this part is not just heavily documented everywhere, it's actually supported by a great deal of actual science and mathematics. Parsing is a solved problem and writing a manual parser these days makes as much sense as cooking a pie by starting by building a kitchen from scratch.\n\nWhat the world needs is more articles on the hard parts of writing a compiler:\n\n- Code generation.\n- Error reporting.\n- Error recovery.\n- Plug-in API so that tools can be written on top of it (e.g. IDE's).\n\n", "id": "damjlps"}, {"comment": "I'm of the opinion that it's a worthwhile goal to write your own parser at least once. Yes, it's a solved problem and yes, if you need a parser in a production environment, by all means, use a parser generator.\n\nBut I think if you want to learn how they work it makes sense to at least try to implement one yourself.", "id": "damkqxd"}, {"comment": "Sure, it's always worthwhile to reinvent the wheel if your goal is to learn how to make wheels.\n", "id": "daml280"}, {"comment": "Some people actually enjoy coming up with fresh, nontraditional solutions to \"solved problems\". The new solution could be more straightforward and better suited for a particular purpose than the overly-generic academic approach.", "id": "damm6x9"}, {"comment": "Ha! Very well put. I will use this in the future.", "id": "daml7p8"}, {"comment": "For what it\u2019s worth I completely agree *but* I also remember that people were stating the exact same thing just before PEG was published. \u201cParsing is solved\u201d\u00a0\u2014\u00a0*boom*, along comes a completely new, practically relevant formalism.", "id": "dams9x8"}, {"comment": "> Code generation.\n\nSo much this, I've literally never found ANY material on the \"we have the AST now we make the machine code/byte code/IL\" part. To me the conversion of something simple like a switch into various opcodes is a mystery. Sure, I could do it by hand, but I'm referring to things such as:\n\n * Converting a large switch into a jump table (how C# and probably C/C++ do it) (optimizations)\n * Knowing which opcodes are available for a given architecture assuming you are compiling to machine code, or in the case of IL, how does the JIT know what opcodes to use? Do they have a giant list of opcodes available for specific architectures and pick the highest common denominator, that kind of thing?\n * Where and how do you even begin to deal with opcode specifics, such as ordering operands correctly, Instruction Set Architectures.\n * Vectorization which ties into the above.\n * The specification of the language and it's contexts. By this I mean things such as type systems, oop, inheritance. All that sort of thing. For example, how do you design the language itself? I don't know how C# internally figures out things like casting, checking if a type implements an interface, etc etc.\n\nThe whole thing is a fucking black box.\n\n> Plug-in API so that tools can be written on top of it (e.g. IDE's).\n\nRosyln (the new C#/VB.NET compiler platform) is a great example of this with an open API. It's really very impressive.", "id": "damrw40"}, {"comment": "I'd recommend reading this (unfinished) book: http://ssabook.gforge.inria.fr/latest/book.pdf\n\nIt's more about middle layers, not the final code generation, but still quite useful.\n\nFor the final instruction selection I cannot think of any introductory book or set of papers.\n\n> Knowing which opcodes are available for a given architecture assuming you are compiling to machine code\n\nThere is no magic in it. Most practical compilers are doing instruction selection in an ad hoc way, guided by some trivial pattern matching. See the TableGen language in LLVM for example.\n\nA more advanced but yet very experimental approach is something like LISA, or stuff like this: \n\nhttp://drops.dagstuhl.de/opus/volltexte/2011/3065/pdf/9.pdf\n\n\n\n> Vectorization which ties into the above.\n\nIt is done much earlier, on an SSA level. See the SLP vectoriser in LLVM, it's surprisingly simple and readable, and for a more advanced stuff read on the Polyhedral model. \n\n> such as ordering operands correctly\n\nThe very last moment, usually. Keep your instructions abstract in your selection DAG until you're ready to schedule and encode them.\n\n> By this I mean things such as type systems\n\nIt's a totally different side, a front-end. There are tons of papers written on type systems. I suspect, more than on all the other topics combined.\n\n>  oop, inheritance. \n\nJust a kind advice - stay away from this.\n\n> how do you design the language itself?\n\nThis is the most under-researched area. And it is far beyond a mere trivial computer science. It needs an interdisciplinary approach, including social anthropology, psychology, a mixture of engineering disciplines, and only then a bit of computer science. Do not expect to find any introductory level material on this topic.\n\n> I don't know how C# internally figures out things like casting, checking if a type implements an interface, etc etc.\n\nThat's the most trivial form of typing. Read on a *type propagation*.\n\n\n\n", "id": "damt51d"}, {"comment": "> Error reporting.\n\nI thought this was why people wrote their own parsers, because it's easier than adding error massages to an existing one?", "id": "damvqx6"}, {"comment": "It used to be the case. Now, with the PEG-based parsers it is easy to add error recovery and smart error reporting to a generated parser.", "id": "danf01i"}], [{"comment": "> And you don\u2019t need to be well versed in mathematical notation either! It should be a book any programmer can read and understand.\n\nIt's generally a good idea to understand mathematical notation. It's well worth learning. Most things can be expressed and thusly understood very easily and elegantly using mathematical notation. Also most correctness proofs are heavy on mathematical notation as are many papers.", "id": "damj4cn"}], [{"comment": "You can take [Stanford's Compilers course](https://lagunita.stanford.edu/courses/Engineering/Compilers/Fall2014/about) for free. ", "id": "damrp3n"}], [{"comment": "> What a lexer, a parser and an Abstract Syntax Tree (AST) are and how to build your own\n\nThis is of particular interest since I've seen a lot of books/ tutorials that show you how to use them and not to build them (or you build a lexer, which is dead easy, but then use yacc et al)", "id": "damooef"}], [{"comment": "I'll have to check out your book! I was also inspired by the meta-circular evaluator in SICP and made a non-GC implementation of it in under 1000 lines of C with a recursive descent parser. It's amazing how simple yet powerful s-expressions are. \n\nIn case anyone wants to take a look, [heres the code](https://github.com/lazear/microlisp)", "id": "danqc5a"}]]], "5g2maq": ["Trapped by an amend, saved by a reflog", "2016-12-02 13:33:33", 9, "http://tech.sparkfabrik.com/2016/11/29/trapped-by-amend-saved-by-reflog/", [[1, "Doing `git reset --soft HEAD@{1}` should have done the same thing, too, with the benefit of not having to manually copy\\type a hash."]], [[{"comment": "Doing `git reset --soft HEAD@{1}` should have done the same thing, too, with the benefit of not having to manually copy\\type a hash.", "id": "daq0i4n"}]]], "5g4yve": ["KS: Open Source Forum, Already funded, stretch goals: add electronJS desktop app, build react-native clients for ios and andriod, build a blog engine. Help fund a learn along at dailydrip!!", "2016-12-02 21:47:29", 0, "https://www.kickstarter.com/projects/1003377429/firestorm-an-open-source-forum-in-phoenix-from-eli", [], []], "5fr4qj": ["Amazon Rekognition - Deep learning-based image recognition. Search, verify, and organize millions of images", "2016-11-30 21:12:30", 7, "https://aws.amazon.com/rekognition/", [[1, "I want something like this that also allows you to train it with your own tagged images. "], [1, "ok this is dope AF. this is what i've been waiting for. why should we have to train our classifiers locally, thanks Amazon"], [1, "> Rekognition enables you to find similar faces in a large collection of images.\n\nThis is scary:\n\nCrawl facebook. Film a protest. \n\nFind their identity."]], [[{"comment": "I want something like this that also allows you to train it with your own tagged images. ", "id": "damgi50"}, {"comment": "One example of is [show and tell](https://github.com/yunjey/show-attend-and-tell-tensorflow) which uses Google's machine learning library [Tensorflow](https://www.tensorflow.org/) which can run machine models on CPU or GPU, but GPU is much faster. You can also run it on AWS GPU instances to make it run much faster, but then you know what is sent and received. [Article](https://medium.com/@lherrera/how-to-fake-it-as-an-artist-with-docker-aws-and-deep-learning-6d42f4acd890#.oh5kn6mno) about running Tensorflow on AWS and faking it as an artist.\n\nOther [awesome tensorflow](https://github.com/jtoy/awesome-tensorflow) stuff.", "id": "danqz84"}], [{"comment": "ok this is dope AF. this is what i've been waiting for. why should we have to train our classifiers locally, thanks Amazon", "id": "damn3mw"}], [{"comment": "> Rekognition enables you to find similar faces in a large collection of images.\n\nThis is scary:\n\nCrawl facebook. Film a protest. \n\nFind their identity.", "id": "damrlkp"}, {"comment": "Facebook is already doing this whether they expose it or not. ", "id": "danabwq"}]]], "5frkwq": ["Ladder of Functional Programming", "2016-11-30 22:27:09", 2, "http://lambdaconf.us/downloads/documents/lambdaconf_slfp.pdf", [[1, "I'm an advanced begginer :)"], [1, "A nice addendum would be a list of resources to explain and provide exercises for each level."]], [[{"comment": "I'm an advanced begginer :)", "id": "damg6cv"}], [{"comment": "A nice addendum would be a list of resources to explain and provide exercises for each level.", "id": "dan55yf"}, {"comment": "I agree", "id": "danihdv"}]]], "5g45rk": ["Stuck on a problem? Here's when to ask for help", "2016-12-02 19:28:56", 2, "https://codewithoutrules.com/2016/03/02/asking-for-help/", [[2, " I like this line:\n\n>If you're a novice in the area it's best to get an estimate from an expert; ask them to estimate how long it would take them, then quadruple the estimate.\n\nI feel like that's a pretty good starting point. I always felt dumb when I just started if I didn't fix things as fast as they thought for themselves. Better to be correct than fast when starting out. "]], [[{"comment": " I like this line:\n\n>If you're a novice in the area it's best to get an estimate from an expert; ask them to estimate how long it would take them, then quadruple the estimate.\n\nI feel like that's a pretty good starting point. I always felt dumb when I just started if I didn't fix things as fast as they thought for themselves. Better to be correct than fast when starting out. ", "id": "daq7tsq"}]]], "5galcc": ["Phoenix GraphQL Tutorial with Phoenix: Add CRUD Using Mutations - Ryan Swapp", "2016-12-03 20:28:02", 4, "https://ryanswapp.com/2016/12/03/phoenix-graphql-tutorial-with-phoenix-add-crud-using-mutations/", [], []], "5g28u8": ["ES6 - What's New", "2016-12-02 11:30:27", 6, "http://www.discoversdk.com/blog/es6--whats-new", [[1, "Not so new.. but good examples in post."]], [[{"comment": "Not so new.. but good examples in post.", "id": "dap7w8p"}]]], "5g674a": ["Composed Method Pattern explained", "2016-12-03 01:22:19", 0, "http://farenda.com/patterns/composed-method-pattern/", [[1, "I believe the worst case of this pattern is when a developer pulls out chunks of logic that will never have any use case outside of the calling method only for the sake of making the calling method seem cleaner.  In that situation, I believe the overhead of method calls is not worth the composite pattern."]], [[{"comment": "I believe the worst case of this pattern is when a developer pulls out chunks of logic that will never have any use case outside of the calling method only for the sake of making the calling method seem cleaner.  In that situation, I believe the overhead of method calls is not worth the composite pattern.", "id": "daq47b2"}, {"comment": "It depends on languages and their runtimes. For example JVM can inline such code, so from runtime perspective it would be like one method.\nFrankly, maybe there's some cost of method call and in some cases maybe people worry about it, but the cost of unmaintainable code is real and in most cases costs much more money than method call overhead.", "id": "daqddwr"}]]], "5fq686": ["Docker for AWS Public Beta", "2016-11-30 18:27:42", 3, "http://dockr.ly/2fIntln", [], []], "5fwc75": ["Introduction to strace | The Road to Elysium", "2016-12-01 15:37:44", 6, "https://jorge.fbarr.net/2014/01/19/introduction-to-strace/", [], []], "5g4a84": ["Agile has failed. A peek at the future of programming", "2016-12-02 19:50:42", 0, "https://www.codingame.com/blog/agile-failed-peek-future-programming/", [[7, "tl;dr: [DISCIPLINE!](https://www.youtube.com/watch?v=jNOyy1PbjQU)\n\nDoes anybody still take \"uncle bob\" seriously?"], [5, "Well that's a click bait title if I've ever seen one."], [4, "Bullshit"], [-1, "Agile is not a failure."]], [[{"comment": "tl;dr: [DISCIPLINE!](https://www.youtube.com/watch?v=jNOyy1PbjQU)\n\nDoes anybody still take \"uncle bob\" seriously?", "id": "dapdmnt"}, {"comment": "Like many outspoken Developers/Engineers/Architects I find him controversial, interesting, and taken with a grain of salt. Discipline is the key. As a side note I have successfully used basic big 'A' Agile processes for a long time and yeah, Discipline is why it works better than most other processes I have worked under or with in the past.  ", "id": "dapdtdy"}], [{"comment": "Well that's a click bait title if I've ever seen one.", "id": "dapjcqd"}], [{"comment": "Bullshit", "id": "dapcpd4"}], [{"comment": "Agile is not a failure.", "id": "dapfd9x"}]]], "5gesrd": ["How a single indexing mistake nearly cost us a boat-load of money", "2016-12-04 12:56:29", 4, "https://medium.freecodecamp.com/how-a-single-indexing-mistake-nearly-cost-us-a-boat-load-of-money-642263d193f6", [[5, "The problem here is incompetence on a completely different level. Your management sucks and should be fired. If I were the client and I would read this, I would think that I should get away from you people as soon as possible. Your company is a liability in my mind, not an asset. "], [1, "Talk about drinking from the firehose"]], [[{"comment": "The problem here is incompetence on a completely different level. Your management sucks and should be fired. If I were the client and I would read this, I would think that I should get away from you people as soon as possible. Your company is a liability in my mind, not an asset. ", "id": "daroo1d"}], [{"comment": "Talk about drinking from the firehose", "id": "darpezm"}]]], "5fv94p": ["A Problem with Type Checking (in Python and oil shell)", "2016-12-01 10:04:44", 1, "http://www.oilshell.org/blog/2016/11/30.html", [[4, "Hello /u/oilshell,\n\nYou only seem to post links referencing your own blog. Please take note of the Reddit rules regarding self-promotion: https://www.reddit.com/wiki/selfpromotion\n\n> \"It's perfectly fine to be a redditor with a website, it's not okay to be a website with a reddit account.\" - Confucius"], [3, "This is a shortcoming of the MyPy type system (and that of most pre-existing languages)\n\nThere has been advanced in recent years on [flow-sensitive typing](https://en.wikipedia.org/wiki/Flow-sensitive_typing) which would allow this. There are a number of academic paper on this that can be easily googled as well. \n\nAlso to thoroughly support type-checking dynamic types, the type system might also need to support some advanced type features like [tagged union](https://en.wikipedia.org/wiki/Tagged_union), because a variable could be polymorphic at one point of a function, but monomorphic at another point. "], [1, "Would the mypy errors go away if instead of using direct instance variable access you called `getattr` instead to retrieve their values?"], [1, "Discussion of original article: \nhttps://www.reddit.com/r/programming/comments/d7qwo/typechecking_a_dynamic_language/"]], [[{"comment": "Hello /u/oilshell,\n\nYou only seem to post links referencing your own blog. Please take note of the Reddit rules regarding self-promotion: https://www.reddit.com/wiki/selfpromotion\n\n> \"It's perfectly fine to be a redditor with a website, it's not okay to be a website with a reddit account.\" - Confucius", "id": "danbns1"}, {"comment": "OK, point taken.  I've contributed to reddit since probably 2007 but I made a new account for this new project.  I can submit some of other people's content that I link to on my blog which is quite interesting.\n", "id": "danc7wa"}], [{"comment": "This is a shortcoming of the MyPy type system (and that of most pre-existing languages)\n\nThere has been advanced in recent years on [flow-sensitive typing](https://en.wikipedia.org/wiki/Flow-sensitive_typing) which would allow this. There are a number of academic paper on this that can be easily googled as well. \n\nAlso to thoroughly support type-checking dynamic types, the type system might also need to support some advanced type features like [tagged union](https://en.wikipedia.org/wiki/Tagged_union), because a variable could be polymorphic at one point of a function, but monomorphic at another point. ", "id": "dancpkc"}], [{"comment": "Would the mypy errors go away if instead of using direct instance variable access you called `getattr` instead to retrieve their values?", "id": "dand9dx"}, {"comment": "I don't think so, because the syntax you use doesn't change whether mypy knows about the name or not.  I think the core issue is that mypy works on a \"static\" parse tree, but you have to execute a little bit of the program to know about those dynamically generated names.\n\nAs far as I undesrtand, mypy is totally separate from the Python interpreter.  It actually CAN'T execute Python code for this reason and thus can't know about the names I've generated.  It would have to say something statically about a dynamic program which gets you into the territory of the halting problem yet again...\n", "id": "danfeno"}, {"comment": "> I don't think so, because the syntax you use doesn't change whether mypy knows about the name or not. I think the core issue is that mypy works on a \"static\" parse tree, but you have to execute a little bit of the program to know about those dynamically generated names.\n\nI would expect the `getattr` to return a generic _parent object_, like Java's Object class (python's C documentation talks about PyObjects), which then you cast to a more specific type. The [mypy cast documentation](http://mypy.readthedocs.io/en/latest/casts.html) doesn't make much sense to me though.", "id": "dao2kti"}], [{"comment": "Discussion of original article: \nhttps://www.reddit.com/r/programming/comments/d7qwo/typechecking_a_dynamic_language/", "id": "danur0n"}]]], "5gbccw": ["Comment rendre les algorithmes responsables ?", "2016-12-03 22:49:53", 0, "http://internetactu.blog.lemonde.fr/2016/12/03/comment-rendre-les-algorithmes-responsables/", [], []], "5fszvw": ["Get ready for Advent of Code!! :)", "2016-12-01 02:23:34", 214, "http://adventofcode.com/", [[18, "/r/adventofcode - really enjoyed last year, looking forward to this years puzzles!"], [3, "Yay, I get reminded of this before Christmas this year!"], [3, "Hooray! I loved last year's challenges. "], [2, "Wow, I forgot I didn't complete all puzzles from previous year. Time to jump into :)"], [2, "Just finished the challenges from lasts year. I really enjoyed them, can't wait to see this year's puzzles! "], [2, "I never got around to doing all of these from 2015, so I'm doing them now. For anybody else who didn't do the 2015 tree it is still there in it's entirety if you click on \"Events\"."], [1, "Noted..."], [1, "Just did the first day's challenges, this looks like it could be really fun! "], [1, "The second puzzle of the first day got really interesting... "], [1, "Wow, that\u2019s cool! Thanks for the author for the effort!\n\nNow, I have a solution that passes all 3 examples, debug output looks fine, but it says the solution is wrong. Time to search my error :-/"], [1, "nice puzzles!"]], [[{"comment": "/r/adventofcode - really enjoyed last year, looking forward to this years puzzles!", "id": "damw5zo"}], [{"comment": "Yay, I get reminded of this before Christmas this year!", "id": "dan3ju5"}], [{"comment": "Hooray! I loved last year's challenges. ", "id": "dana5hk"}], [{"comment": "Wow, I forgot I didn't complete all puzzles from previous year. Time to jump into :)", "id": "danes7k"}], [{"comment": "Just finished the challenges from lasts year. I really enjoyed them, can't wait to see this year's puzzles! ", "id": "danntim"}], [{"comment": "I never got around to doing all of these from 2015, so I'm doing them now. For anybody else who didn't do the 2015 tree it is still there in it's entirety if you click on \"Events\".", "id": "danq9gw"}], [{"comment": "Noted...", "id": "dan9b1x"}], [{"comment": "Just did the first day's challenges, this looks like it could be really fun! ", "id": "danbb5e"}], [{"comment": "The second puzzle of the first day got really interesting... ", "id": "danfy6v"}], [{"comment": "Wow, that\u2019s cool! Thanks for the author for the effort!\n\nNow, I have a solution that passes all 3 examples, debug output looks fine, but it says the solution is wrong. Time to search my error :-/", "id": "danlk0c"}, {"comment": "Same happened to me. I assumed that a command is one letter and one number, but there are command like `L290` \n\nmaybe you already figured it out, cheers :)", "id": "daovtnw"}], [{"comment": "nice puzzles!", "id": "dap5owa"}]]], "5fxz2d": ["A bluescreen of death caused by visiting a page that uses WebGL, using the Chrome browser", "2016-12-01 20:49:49", 142, "https://medium.com/@afd_icl/first-stop-amd-bluescreen-via-webgl-and-more-ba3eaf76c5fb", [[51, "So you're saying that giving random web pages low level access might be a bad idea?"], [21, "not sure why everyone thinks putting everthing in the browser is good idea.."], [17, "Pfft,\n\nFirefox on linux was -wwaaay- ahead of the curve there, kernel panics from browsers was cool in 2012.  https://bugzilla.redhat.com/show_bug.cgi?id=845704"], [6, "Any old timers on windows surely remember the days of <img src=\"C:\\con\\con\">"], [4, "We'll get WebVulkan someday; just wait."], [5, "What's the state of graphics APIs and video driver/kernel relation in current systems?\n\nDrivers are in the kernel, right?\n\nWell, that's it then, the risk is real."], [3, "Neat article. I still love WebGL and absolutely think it's an amazing tool, but things like this shouldn't be possible - especially since WebGL doesn't require secure context or any permissions at all really to run. I'd chalk this up as a fallacy with graphics drivers well before I spit on WebGL, though.\n\nEDIT: It's a shame that things like this are possible, not a good thing. It makes a great deal of sense that giving such low-level access would result in bugs, especially with something as tricky as GLSL compilation. The intention of that statement was not clear in the original post."], [4, "The [GLSL sandbox](http://glslsandbox.com/) (linked in the article) has some really neat scripts. I've never run across this before."]], [[{"comment": "So you're saying that giving random web pages low level access might be a bad idea?", "id": "dao68x5"}, {"comment": "not sure how you get this conclusion from the situation.\n\nfrom skimming the article the issue seems to not lay in the broswer or WebGL at all. The issue is the AMD driver.", "id": "daoaq78"}, {"comment": "The bug is in the driver but the trigger can be in any random website. That's a problem.\n\nEdit - you shouldn't be down voted, you aren't wrong and you're contributing to the conversation.", "id": "daobbn0"}, {"comment": "What is exactly the reason Microsoft initially opposed webgl. \n\n> [WebGL considered harmful](https://blogs.technet.microsoft.com/srd/2011/06/16/webgl-considered-harmful/)\n\n> We believe that WebGL will likely become an ongoing source of hard-to-fix vulnerabilities. In its current form, WebGL is not a technology Microsoft can endorse from a security perspective.\n>\n> We recognize the need to provide solutions in this space however it is our goal that all such solutions are secure by design, secure by default, and secure in deployment.\n\nSo yes, providing direct access to low-level hardware is a bad idea. Because bugs in the underlying video card drivers are a risk.", "id": "daoov0g"}, {"comment": "As a graphics programmer, I love WebGL, but I tend to agree with Microsoft's concern. It has been already demonstrated that WebGL can be used as a form of denial of service attack on a client machine.", "id": "dap34ee"}, {"comment": "Device drivers care about:\n\n1) Performance\n\n2) Features\n\n3) What's for lunch today?\n\n4) I wonder if it will snow next week?\n\n...\n\n182) Security.\n\nSo yes it's a bit... courageous to give any ol' web page the ability to poke at massive drivers that have thus far been written to support co-operative applications (apps try very hard not to crash, after all) rather than harden against adversaries.", "id": "daol6bf"}, {"comment": "> So yes it's a bit... courageous to give any ol' web page the ability to poke at massive drivers\n\nTo be fair, WebGL passes through a validation layer (which has a non-negligible performance penalty, over the hit already incurred by using JS anyway.)", "id": "daozva6"}, {"comment": "The validation is just to prevent things that are known to be dangerous \"by design\". It's not there to prevent a web page from exploiting an obscure driver bug (of which there are thousands).\n\nAgain, remember that graphics drivers have spent the last 20 years living in a pretty privileged position of not having to worry about malicious users. If there's a graphics driver bug, they could more or less rely on games implementing workarounds to avoid hitting it rather than having to worry about some app exploiting it to crash the machine. \n\nIMO it will take a *looong* time for drivers to be anywhere near the level of security that would make WebGL \"safe\". As I mentioned below, I think probably a better option is to try to virtualize the GPUs so that each process effectively gets its own driver (that can be killed if it misbehaves without affecting the system) and virtual view of the GPU, rather than try to make a single shared driver robust to attacks.", "id": "dapjkyw"}, {"comment": "The driver issue *is* an issue with WebGL, it's exactly what critics said would happen.  Given the sorry state of OpenGL drivers, it's really not a surprise and this won't be the last I'm sure.", "id": "dap1yzv"}], [{"comment": "not sure why everyone thinks putting everthing in the browser is good idea..", "id": "daoknim"}, {"comment": "why don't we make the browser the OS!\n\nhttps://en.wikipedia.org/wiki/Chrome_OS\n", "id": "daokqt6"}, {"comment": "What could possibly go wrong?\n\nJust think! Javascript. Javascript everywhere.\n\n^(Oh god JS is horible)", "id": "daokv7a"}, {"comment": "> Oh god JS is horible\n\n[Yep](http://i.imgur.com/t3ZYFkl.png)", "id": "daov2fi"}, {"comment": "I have honestly no idea how JavaScript interpreters any of that to give those results.", "id": "dap7d1p"}, {"comment": "Type coercion. Honestly I gave up trying to fully understand it; it's not really useful for anything other than esoteric language trivia and maybe code golf. Just don't try to do nonsensical things like get the sum of an object and an array, always use strict equality, and you'll be fine.", "id": "dapbcnv"}, {"comment": "I get that it's type coercion, I just can't fathom the underlying logic working here. Perhaps the designers of JavaScript are merely trolling us.", "id": "dapbhrp"}, {"comment": "Yeah, I don't really remember all the details, but I believe the rules actually are pretty consistent and make sense on a low-level. (See [Truth, Equality and JavaScript](https://javascriptweblog.wordpress.com/2011/02/07/truth-equality-and-javascript/)) From the programmer's perspective though yeah, they're complete nonsense.", "id": "dapbv3n"}, {"comment": "I analyzed this behavior in the past: https://www.reddit.com/r/programming/comments/5c8v8l/some_guy_named_marc_andreessen_was_convinced_that/d9v9jto/", "id": "dapebfa"}, {"comment": "[Not that bad](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKkAAAB4CAYAAACJt9KlAAAABHNCSVQICAgIfAhkiAAAABl0RVh0U29mdHdhcmUAZ25vbWUtc2NyZWVuc2hvdO8Dvz4AAA+zSURBVHic7d15fFNV2sDx301ukjZt6QK0pVbaAooLqCNKkUUGAQERlF0REJDhBSmM+IoOvKOA8uIy7wiCKIgoL/IZBMEREcFlQBQEeXFlFNna0rK1FErXpFnfP0ojtemW3LQn5Xz/Iufce3LOzcNp7s2591HcbrcbYP78+Xgzd+5cr+WS1FB0jd0BSaqNDFJJeEIH6b7939Kz7xCGjnqE4+mZleoeGDuFPveM5I1V79S73U8/38XwBycx7pHpnrKFLy3h/hETfGpPCiy1sTtQm7Ypybz1xqIq5e++s5zFr670qc216zYybcoEevXs5imb8+QM8vIucN+I8Tw8ZhQmk9HXLksaE3omDZTCwmJaxcdWKW/RIgZVVSksKmqEXknVqXeQWiwWXluxkrKyshrLGtvQUY+Qey7Pa53T6URRvA9dp1NwOV2B7JpUT/UO0gPffc/mDz/iuYUv4nA4qy0T1YmskxQUFhHbsoXX+rjYlnz/478buFdSTeodpD26dWXmjDT+78C3LFj4Ak6n02uZiJ57fhEPjpvKQw8MJTo60us206ZM4L9ffIURoyc3cO+k6vj0nbR/v75MmTyJr/d9w8uLl+J2u72WNbR1Gz5gwODRDBg8mtxz5xg7cToDBo9m3oL/AeDp2TNZtfxl1m34gJKSUq9tvPW/63gs7U+89483GrLrUg18Prsfct8gLBYLq9esJTo6ikkTx3sta0j33duP3r26AzD50Vm8sGAOMTHRmEwmzzbXX3cNZnMoZ87m0q5tcpU2srJPcUdqp4bqslQHfl2Cslgs5Y2oao1lDcVsDsVsDgVAp9MRExPt9bunQVVxOOxe23A4nKgG4a/MXVF8/jTefGs1Gza+z4jhQxk/bky1ZY1lzOhhhIeFea3T6RRcLu9fR9xuN3rdFXllTlg+fRorLwXjoIEDmDTh4WrL/GVQDZzLO88DY6eQkZlVqW7cI9P5YtfXhISEeN136H33eGbV34uJiebosfQq5ekZJ1AUaNYswv/OS5qp90y6Zes23tv4Pj17dGfa1P9AURSvZVrodOtNbHl/jde6NauW+tzunyY+xPKVa9j0wVZPOwtfWsJPB38hbepEDAaDz21L2qt3kPbo1pVTp04xaeIEdJf+LHorE1mXzp3o0rnyydGcJ2c0Um+k2tQ7SKOiIpkyeVKtZZKkFfGnPemKJ4NUEp4MUkl4Mkgl4ckglYQng1QSXtAGacmx7Rx91kTGomTKcg7WaZ+MRclYTx+ocZsLuxaQs2WKFl0MCNHGkLmkPccWNiPvX38N2HsIG6Rul4Mjc8t/ucpa2YXSzC+qbGOK60jKzExMcR01e1/zNf2J6PiAZu35EjD2/HSyV/Xg6HMhZC69jtKMHfXavyHHkDzjMJF/mFilvC6fX13J5T6/E5JwW2N3gTObxmCK7UDC6M0U/Xs9p98dRpvHT6AzNavT/iKMQUt+B6nd4WDX7n1063IbodUs9mhI9vx0cjZPwnrmOwyRrYm9ZymhyT099cW/bubU2oEoqokWvRfS7Oby1Volh7eQ+/F0nNYCIjqMIm7Qcs8+zuIccremUZq5E11INC3vfonw64d46gsOrCB/7yIcRacxxnYgYeQGHMVnObN+OE5rAbgclB7bDkBy2i8oBnO1/XcUnsSavZeEURvRh8YQdftULnz1PCVHtxPRYWRQjEFrfgWpy+Vi89bPyDiRjUE10LN7qlb9QlH0xA0uv2U55s45GJu3r9N+ZzaNwZzUg6vGfkLJkY84/e5QUmZmeGYha/ZeUh5Lx5Z7kOzVvTEn34ka2Zqw9oNIaT+IC7sWYC88WbnN9x7AGHsDbf7zFLbzhzm5ujchCZ1QI1tT9PN7nP9yIVeN/hBTbAcs2XtwO+2EJNxGysxMT3uXB0xNbHmHUQyhqBEJnjJjdFts5w97Xos+BvD98/PG5++kLpeLzR9/TsaJbNq3a8Od3Tr73AmvFIXITuXrAcLbD0aNaFXrLs6SXKzZe4nu/hSK3kD49UPQh8dhOfGlZ5uo1DR0xjBCErsQmtiFkqPba2zTnp+OJXsPLfq+hKKaMMXdhLnd3Z79Cr9/m+g7ZmKKvxl0ekKT7sQQneLzsN32UnRq5SWGiiEUt604aMZQ3un6f37V8Xkm3f6vLzmWnklKUiID+92l2fI8fzhKclH0BvShMZ4yNTweR9HZ316HxXn+rQ+Pw1mSW3ObBdkAZK34bdWUy1aCKe4mT70hOlmL7gOgGMy4HJZKZW67BcUY7nkt+hi05lOQ7trzDT8fOgJAxomTvLzszSrbzJrR8HdbqmGxuJ12nJYLnkB1FJ9FDf/tQ3UU/xawzuIc9Cm9am4z8mp0xgiS0w6Bl/+IauTV2PMzq29A0QF1vynR2Pxa3HYLjqIzntnHln+cyOZTg2YMWvPpz70Is6Y3+rBYQhJTyd/9Im6nneJD/8RRdJrQpB6ebS7uX4bLVoL15D4sJ/cRds2AGts0RLfBGNuBvJ3P4LZbcDttlKZ/jv3CcQCa3TKe/L0vU5bzE7hdWLL2YM/P8OyvRrTClvsLuOp2m7caeTUhiamc/2I+Tks+BQdW4CorJKxdv6AZg9Z8mknv7NqZsjIbPxz8hataxTP8vgEYjWKsZo8f+g65H07m+IstMES2JmHURnQhUZ76kMQuZCxug6KaiB+8ErVZYq1tthq5nnPb/kz6oiTPCUXFSUREh5E4S/M4s35E+ZlxXEcSRqz37Bt+wzAKf1zL8b9fhaJTSZlxpNYz41bD1nL2/YdJ/1s8hqjkS2P47TkBwTAGLSm+PkTX7Xaz9dOdHDp8jMSEeIYNbthALc3YwdmND6ELiSRh1CaMsTdq0u75nfNwWi4Qe88STdprDA05hhOv3YzTcoGozo8S02N2QN7D5xMnRVEY0OePWCxWMrNOsuPLr+nfp2ftO2rEnHIXbWad0bZRlxNL1p5K1w+DTgOPIenRHwP+Hn5dJ9Xrddw/8G6+2L2Prqm3atWnRpGxuC3OkhxCW3en2S3jGrs7PmkKY/DG71+cDAaVvpeeGhLMUh473thd8FtTGIM3wi4wkaQKMkgl4ckglYQng1QSngxSSXgySCXhCR+kWudcClRuKClwhL99JBA5lwKRG0oKHOFnUplzSRI+j5OvOZdqyuMkBReh8zjJnEsSCJzHSeZckioIm8fJl5xLteVxkoKT0Hmc6ptzqS55nKTgI3wep/rkXKprHicpuAifx8nXnEs15XGSgovQeZzA95xL1eVx8ic3lNQ4hM7jBNrnXApUbigpcITP4yRzLkkyj5MkPOF/u5ckGaSS8GSQSsKTQSoJTwapJDwZpJLwZJBKwhP2HqeCAnj9DTh8BOLiYPIj0MbPx7hLwUnYmfTtNRBmhmWvQNdUeOVV0GAttRSE/A5Su8PB51/sxmK1atEfAGw2+P4HGHQvmM1wzwAoLoajxzR7CymI+BWkFXmcvv/pF/Yf0O5hqufyymfNVvGwYROUlEBcLJw5W/u+UtMjZB6nsjLQ6coD9avdkHsOQkJAw8laCiJC5nEymcDlAoMBll56hoPVWh6o0pVHyDxOLVuAXg+nTkNyUvmMmnuu/M+/dOURMo+T0Qh/uAW2flw+g277pPxM/5p2AX1bSVDC5nEaP7b8OunUtPLrpDPSymdX6crj83fSPn/sRpnNxqHDx9j04TbN8zhFRcHsJzVrTgpiPp/dV+RxSm6dyMnTZ9nx5dda9kuSPPy6TlqRx+mWjjfQo+vtWvVJkiqReZwk4Qn7270kVZBBKglPBqkkPBmkkvBkkErCk0EqCU/4IG3KeZwC1Retj1ljE/YepwpNPY9TIPoSiGPWmISfSWUep/prasdM5nEKUjWNz9djJiqZx6mJaYrHzKeH6M6ckcaiJa+yYOELPP1ff/Fapvdz8edzzy9i2yc7eHjMyBrzOM155nlWrV7nSZOjtXUbPmDN2g1VylM730r7a9v5VDfvr08EpK+iHDOt+XTi1L9fXyxWK6+vWMnLi5fyxON/9lrmzwr+p2fPZPiQe5k64y+MeXAYYWHmKttU5HEaNmQgUDmgioqLGTtxOjpF8SswLk+7czmTyYRBVX2q81Vt4/PlmAUDmcepFh9s2c7qNeurlHdJvZXr2l/jU92zz/i2mrsu46vvMQsGMo9TLe4f1J8+d/WoUl4xW/pS56u6jq8+xywYyDxOtbg8MKqr96XOXzWNz9djJiqZx+kyDZ3HyZ++VDc+8P2YiUpxX8pUO3/+fK8bzJ07t9LrLVu3sXTZ6/Ts0Z3ZTz2BTqfzWqaVffu/ZfnKNbhcrip5nIYNGciIoYM0e6+moqkds3oH6cWLBby74T0mTZyAquqrLZMkrcg8TpLwgusbtHRFkkEqCU8GqSQ8GaSS8GSQSsKTQSoJT/ggLVv3Gfl3TCL/tvE4fjha47buYgsXe00j/45JFI6d1zAdlAJO7JUGThelL64h8qO/o0usejvE7ynhoUTtXIbtk31Y125vgA5KDUHomdSVX4jb6apTgEpNl98zqd3hYNfufXTrchuhGi7MKBw7D1dWDtjsXOw1DYDwpY+jdmiL9c3NWNd9hju/CF1SPObZ4zB0vrHWNl1ZORTPfg3nkSwUo4ppdD9Cpw0vr8sroPTZVdi/+RldZBihs8Zg7KtdRhXJd34FaUUep4wT2RhUAz27p2rVL5q9Mw/X2fNc7DuDqJ3LKtUpzcKJeHMO+qRW2D7fT/GUl4ja8wZKaM1rNUuXbkC9qR3N1s7DXWrF+esJT13JzMXo2iUS/dVynBmnKXz4WdQb26BL8G89quQ/IfM41cY0sjf6lATQKRjvTgWjiiur9kxkik6H6+x5XDkXUMJCUTtdB4ArOwf7d79ifnIMGA3o2ydh6H4z9q9+CPRQpDoQMo9TbWyf7ce6cjOucxcBcBeW4K7DXaqhT4zGsuhdCofNBpMB86wxGAfcgevMeQAKhzzl2dZtKUNtnxSYAUj1ImQep5q48goombWUiHfmoXZsC0D+7RPAfdlKdIMKXu4t17WMJmzhVABs2/dSMmc5xv5d0LVqjhIWSuS2RdCA/9mkuhEyj1ONSq2g6tG3vQoA27a9uAtLKm2iT0nAeewk7ouVn9Rh23EA17n88heqimIOAUVBd3Uc+muvxrJkA26rDewO7F8fLD9xkxqdsHmcqqNrHUfI+IEUDp+NLr45aoe26Fo1r7SNPiUB08jeXOwzHRxOor5agRJhxnnwOKXPrMRtsaJLaEnY39I8+4Qvnknpgre52OtRcDhRO7QhbH5g/hpI9VPvlfkV3G43Wz/dyaHDx0hMiNc8j5MkVZB5nCThyTxOkvBkHidJeEL/di9JIINUCgJKZmam9+exSJIg/h8UmcAkHTymaAAAAABJRU5ErkJggg==)\n", "id": "dap76l0"}, {"comment": "nice try", "id": "daql173"}, {"comment": "TIL our lord and savior Javascript shares some syntax with weird old languages called C++ and Java. Not much is known about these archaic and lost arts.\n\n/s", "id": "daol2fl"}, {"comment": "Gotta seek out the Elders for that knowledge.", "id": "daottx6"}, {"comment": "ChromeOS is actually pretty good for the end-user. I can give a Chromebook to a technically illiterate user, they can Facebook and GoogleDocs to their heart's content, and I will receive practically zero support requests.", "id": "daoyxeh"}, {"comment": "https://node-os.com/", "id": "daoyhcf"}, {"comment": "Easy installation and use?", "id": "daoy43l"}, {"comment": "I've managed this long with easy installation of native things...and easy to use so... hard to see where you're going on that one", "id": "dap4erp"}, {"comment": "Because web apps are amazing.\n\nNot only are they way easier to [\"install\"](https://xkcd.com/1367/) than native apps, but they're also sandboxed by default, feature a standard permissions system, and are cross-platform.\n\nNot to mention they come with a consistent user interface for handling common operations like going back to the previous screen, selecting text, saving images, printing, spell checking text input, zooming, auto-filling personal information, and finding text on a particular screen. They also support deep links to specific sections of the app and let you bookmark those links so you can get back to them easily. You can even share those links with other people to allow them to get to the same screen that you're on.\n\nOh, and it's all based on open standards which have multiple competing implementations, several of which are themselves open-source.\n\nAs far as I'm concerned, the more we can do with web apps, the better.", "id": "dapacpb"}, {"comment": "not all browsers feature those things; and in some apps back button is a hindrance, in fact at one point chrome was going to do away with it.. and the links don't always work like that, i've been in many situations where people try to share links and it does not take you where you want to go... \n\nthe more we do more with web apps the more we just turn them into native apps, wasm, EME etc and this is all going to come at a glacial pace, especially because how long it takes browser vendors to implement all this, in most scenarios we just turn the \"open web\" into \"i hope your using chrome lolol\"\n\nI'm not saying the web is useless, but what's the point of making browser basically your OS? we already have competing OS's today, that is what browsers are turning into! ", "id": "dape87h"}, {"comment": "All *major* browsers support those features AFAIK. (Well, except maybe IE.) And if your browser doesn't, you can usually switch to one that does pretty easily.\n\nAnd sure, there are some terrible sites which break basic functionality of the web (like the back button, or the ability to share links) but they're fairly uncommon in my experience, and they're really no different from a poorly designed native app in that regard.\n\n> I'm not saying the web is useless, but what's the point of making browser basically your OS?\n\nThe point is to get all of the features and security advantages I mentioned in my previous comment.\n\nPersonally I'd love to see the web get feature parity with modern desktop operating systems. Ideally we'll end up with the best of both worlds; all the features of modern desktop apps, but with the added security and usability advantages of the web. See also [The Birth & Death of JavaScript](https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript).", "id": "dapgopi"}, {"comment": "every year at pwn2own all major browsers are exploited.. hell firefox wasn't even included this year because it was too easy a target. so I'm waiting for my security advantages! \nOn top of that better usability sounds like a handwave.. but I suppose that's a subjective thing such as most usability topics.\n\nAnyway I'm still not buying it, but i suppose we can just agree to disagree. At least I will", "id": "dapjse1"}, {"comment": "Even remote code execution exploits (which despite their prevalence in yearly hacking competitions are actually pretty rare in the wild) only get the attacker the same privileges that they would have had by default if instead of using their web app you had installed their native application (at least on desktop). So yes, that's still a very big security improvement. (Also, no new exploits were demonstrated against Chrome at this year's Pwn2Own, so there's that.)\n\n\"Better usability\" refers to all the things listed in the third paragraph of [my original comment](https://www.reddit.com/r/programming/comments/5fxz2d/a_bluescreen_of_death_caused_by_visiting_a_page/dapacpb/). No hand waving going on here.", "id": "dapl8rc"}, {"comment": "Agreed. It's a free cross-platform guarantee, with the only dependency being on something people already need for their Facebook and YouTube already.", "id": "dapbo2x"}], [{"comment": "Pfft,\n\nFirefox on linux was -wwaaay- ahead of the curve there, kernel panics from browsers was cool in 2012.  https://bugzilla.redhat.com/show_bug.cgi?id=845704", "id": "daok3um"}], [{"comment": "Any old timers on windows surely remember the days of <img src=\"C:\\con\\con\">", "id": "daoxh0e"}], [{"comment": "We'll get WebVulkan someday; just wait.", "id": "dap9h4d"}, {"comment": "The drivers are a lot simpler for Vulkan, I'd like to see that. I don't know if Apple will ever get on board that train though.", "id": "dapbr9n"}], [{"comment": "What's the state of graphics APIs and video driver/kernel relation in current systems?\n\nDrivers are in the kernel, right?\n\nWell, that's it then, the risk is real.", "id": "daorq8t"}, {"comment": "If I remember in Windows as of Vista, some types of drivers were moved to a less privileged ring of the kernel? But even if I'm remembering right, there's always the risk of an elevation bug bridging the gap.\n\nedit: Obviously still a risk even if it didn't ... letting webpages muck around with hardware", "id": "daosvzw"}, {"comment": "Yes, Vista introduced the WDDM, you can read all about it [here](https://msdn.microsoft.com/en-us/library/windows/hardware/ff567754\\(v=vs.85\\).aspx). More code moved to user mode. Sometimes if you have a crappy (usually NVIDIA) driver you'll see \"driver crashed but recovered\", like [this](http://www.drivethelife.com/uploadfiles/20150707/display-driver-stopped-responding.jpg), this would be a crash in user mode. In the old XDDM days that would have been a BSOD.", "id": "daowua3"}], [{"comment": "Neat article. I still love WebGL and absolutely think it's an amazing tool, but things like this shouldn't be possible - especially since WebGL doesn't require secure context or any permissions at all really to run. I'd chalk this up as a fallacy with graphics drivers well before I spit on WebGL, though.\n\nEDIT: It's a shame that things like this are possible, not a good thing. It makes a great deal of sense that giving such low-level access would result in bugs, especially with something as tricky as GLSL compilation. The intention of that statement was not clear in the original post.", "id": "daoamlw"}, {"comment": "I don't know how we're going to let webpages have access to hardware with buggy drivers while simultaneously preventing all of the driver bugs when the hardware is used from a webpage.", "id": "daoe1q7"}, {"comment": "I think we'll have to get GPUs that support full virtualization...", "id": "daola4r"}, {"comment": "Modern GPUs already have virtual memory and preemption.", "id": "daox6lc"}, {"comment": "They have some, yes, but not enough to protect it against a malicious driver (due to code injection). They'll presumably continue to get more and more features to improve safety and isolation between apps, and even the driver itself.", "id": "daoxtuq"}, {"comment": "Uh, there is nothing that can protect against a malicious driver. A malicious driver can completely wipe your hard drive. The problem is that GPU drivers are generally shitty and have an unnecessarily huge attack surface for historical reasons. The hardware itself does allow secure shared access, but the drivers are not there yet. We're in the Windows 95 era.", "id": "dapip2j"}, {"comment": "> Uh, there is nothing that can protect against a malicious driver.\n\nExcept... virtualization!\n\nThe point is that even the userland driver (which windows already uses for most things for the graphics stack), which is prevented from screwing with your system (e.g. deleting your hard drive), can still cause the actual HW to fail. After all, it must somehow talk to the HW somehow, that's its whole purpose. If you can take control over this driver you may not be able to do much to the user's system (because it's a userland driver) but you probably can find a way to make the GPU hang. \n\nThe way to fix that is to have some kind of virtualization across *all* the state and resources on the GPU. One way for this to work would be for each process to effectively have its own driver, with a thin \"Hyper visor\" like layer underneath that just does resource multiplexing. ", "id": "dapj91r"}, {"comment": "Or, you know, run drivers in userland.", "id": "daor01q"}, {"comment": "No, that's not at all enough. If you manage to convince the driver to misbehave, you could easily cause the GPU to just hang and need power-cycling. You need some way to be able to protect the actual GPU hardware from getting into an unrecoverable state like that (some way which doesn't rely on bullet proof driver code, userland or no).\n\nSome moral equivalent of an independent thread of execution that can be swapped in and out (and killed if it misbehaves), with virtual memory, pre-emption etc. Much like we handle this on CPUs.", "id": "daosteu"}, {"comment": "Agreed!", "id": "dap4llw"}, {"comment": "Short of the browsers implementing GLSL compilation themselves (a feature not feasible for OpenGL implementations of WebGL) it's really not. Vulkan and Direct3D compile to an intermediate format which at least offers _some_ protection against buggy binaries, but yeah if we want WebGL the OpenGL driver issues are going to come with it.", "id": "dapc0cl"}], [{"comment": "The [GLSL sandbox](http://glslsandbox.com/) (linked in the article) has some really neat scripts. I've never run across this before.", "id": "daopdrz"}, {"comment": "[Shader Toy](https://www.shadertoy.com/results?query=&sort=popular&filter=) has always had cooler examples but damn near crashes the browser every time you go to browse the site since it thinks loading 12 projects at once for preview is a good idea. Chrome has gotten a lot better over time, at least I can browse the site now. ", "id": "dap4rmj"}, {"comment": "I love shadertoy but you have to goto your profile and enable the setting \"use previews\"", "id": "daprgvj"}]]], "5gdd8y": ["Saw an intriguing talk about mob programming, anyone have opinions on their experience?", "2016-12-04 05:51:41", 0, "http://mobprogramming.org", [], []], "5fq1lz": ["Decoding Thought Vectors", "2016-11-30 18:03:34", 3, "http://gabgoh.github.io/ThoughtVectors/", [], []], "5fygry": ["China Files A Million Patents In A Year, As Government Plans To Increase Patentability Of Software", "2016-12-01 22:10:22", 0, "https://www.techdirt.com/articles/20161128/09462736144/china-files-million-patents-year-as-government-plans-to-increase-patentability-software.shtml", [[2, "isn't that a bit hypocritical coming from china"]], [[{"comment": "isn't that a bit hypocritical coming from china", "id": "dao8eqy"}, {"comment": "It's not hypocritical.  China's middle-class is rapidly expanding and it's only a matter of time before they have to transition away from an undercutting economic model as its neighbors start providing cheaper labor and production.  This is just getting ready for that transition.  By the sounds of it this is a top-down scheme designed to provide them a dominant patent portfolio.  The US could take a similar approach by knocking down patent barriers, but the US enforces parents internally while China will certainly not.  ", "id": "daopmyk"}, {"comment": "It's also not hypocritical, because China has been very open about them taking in technology to modernize their economy. And can you blame them? Technologically hey have been behind the West for at least 150 years and Mao really fucked chinese science & technology over even more. Not long ago 90% of the Chinese population was dirt-poor farmers. Now it's \"only\" 50% IIRC. \n\nAnd China's gains have been great for us as well. An economy is not a zero sum game, it can grown just by doing well. China has been the motor at the heart of the global economy for two decades now.", "id": "daow5ih"}]]], "5fskpj": ["Code is Ephemeral, Concepts are Eternal", "2016-12-01 01:10:53", 0, "https://www.exceptionnotfound.net/code-is-ephemeral-concepts-are-eternal/", [], []], "5fwgrb": ["Amazon is eating the software (which is eating the world)", "2016-12-01 16:09:22", 2, "http://blog.gardeviance.org/2016/11/amazon-is-eating-software-which-is.html", [[2, "Not so sure about this. If you have a massive market of user-provided lambda functions, don't you run the risk of going the way of NPM? -- A massive set of libraries, to be sure, but many of them low-quality or unsupported. What's the difference between using a lambda as part of a serverless flow and using a library? Either it's well-tested and stable but so general it needs programmers to integrate it, or its overly-specific and it'll need to be customized (or debugged!) to fit the organization's needs. One way or another, you'll have a lot of complexity and need some way to manage it. If we try to compose everything out of lambda functions, another part of our job will be to learn to manage a complex graph of lambda functions."], [1, "I'm not sure if this should upset me or not. I'm optimistic, but at the same time I don't have enough information to form a real opinion about this potential future. That was an interesting article, although something about it strikes me as overly idealistic.\n\nBookmarked either way."]], [[{"comment": "Not so sure about this. If you have a massive market of user-provided lambda functions, don't you run the risk of going the way of NPM? -- A massive set of libraries, to be sure, but many of them low-quality or unsupported. What's the difference between using a lambda as part of a serverless flow and using a library? Either it's well-tested and stable but so general it needs programmers to integrate it, or its overly-specific and it'll need to be customized (or debugged!) to fit the organization's needs. One way or another, you'll have a lot of complexity and need some way to manage it. If we try to compose everything out of lambda functions, another part of our job will be to learn to manage a complex graph of lambda functions.", "id": "daoc9i6"}], [{"comment": "I'm not sure if this should upset me or not. I'm optimistic, but at the same time I don't have enough information to form a real opinion about this potential future. That was an interesting article, although something about it strikes me as overly idealistic.\n\nBookmarked either way.", "id": "dao7mqe"}]]], "5g7fw6": ["Skov - A visual programming environment", "2016-12-03 05:40:04", 52, "http://skov.software/en/", [[20, "> Go to Wikipedia to see these functions written in traditional mathematical notation and compare them to the Skov code. Do you agree that this code is a more beautiful representation of these functions than mathematical notation?\n\nYeah... no... sorry. Not by a long shot."], [7, "I love this project.\n\nIt might not be the best tool for \"real\" programming because it does not seem to scale well to support huge programs but I might be mistaken.\n\nBut because learning syntax is the source of a lot of frustration for beginners and it drives away many people from programming before they see the beauty of it, I think this can be a **tremendously useful tool for teaching the basics of coding**.\n\nThe design is also beautifully polished which makes it immediately attractive to people who would be repulsed by source code that looks too much like math.\n\n**EDIT:** there's a small error in the tutorial. The UI does not allow me to enter the word `>upper`."], [3, "It seems pretty interesting. I felt there was one small issue reading even the small examples shown.\n\nThere was a lot of need for eye movement tracing up and down the lines to really understand what was going on. It seems like you could get used to some of this but as programs grow I'm not sure how well this would hold up. Having to scroll up and down to understand complicated processes feels like it would be a pretty flow breaking experience.\n\nI'll be curious to see how/if future versions might try to deal with this problem. Maybe the solution is to stick to small pieces or less complicated problems which is not necessarily a bad thing."], [2, "I'm seeing a lot of similarities to [LabVIEW](http://www.calpoly.edu/~fowen/images/PIDPositionControl.jpg), with it's dataflow programming. The multiple branching codepaths and blocking function calls really fit with parallel programming patterns, which are notoriously hard to wrap your head around in a text-based language. \n\nI always thought the concept of LabVIEW was nice, but the implementation was rather extremely terrible. (Seriously, the IDE itself requires at least a dozen services to run at boot, and don't get me started on the runtime.) Hopefully this will be a nice option to fill in the void of a language for easy parallel programming. (Even better if you can get Factor compiling to the GPU.)"], [2, "This is kind of neat. I'll bookmark this and read more into it later"], [1, "I like it! I see great merit in exploring these types of programming paradigms.  "], [1, "I like the idea but the UI here (which is surely the whole point of this) is terrible. Hidden buttons whose name can only be seen on the status bar? Ugh.\n\nIt seems the workflow is heavily vi-style, based around pressing keys to perform commands, but there's no visible feedback to indicate whether you're in text editing mode or command mode.\n\nI followed the tutorial as far as placing the \"add\" command, and then it asked me to choose whether I wanted the \"math add\" or \"scratchpad add\" command, which is not mentioned in the tutorial (I guess they added a new namespace later?). I can work out how to navigate between the choices (arrow keys), but not how to confirm a choice. (Mouse click? No. Pressing enter? No. Right arrow? No. Ctrl? No. Pressing X? Brings up an error message, so probably not. Oh, wait, I can drag the output handle of the proposed \"math add\" command to my display command... oh, that gives another error. Now the whole thing seems to be broken.)"], [0, "Cool idea. I also suggest Python as a language conducive to learning. I find it to be elegant in its presentation."]], [[{"comment": "> Go to Wikipedia to see these functions written in traditional mathematical notation and compare them to the Skov code. Do you agree that this code is a more beautiful representation of these functions than mathematical notation?\n\nYeah... no... sorry. Not by a long shot.", "id": "daqjjn9"}, {"comment": "I feel like the same people who like visual programming are the same people who like articles on Medium. ", "id": "daqv0b3"}, {"comment": "I think the code is more intuitive than traditional mathematical notation. It takes some getting used to but it accounts for the operational hierarchy without having to memorize the arbitrary \"PEMDAS\". It's main shortcoming is that it's far from concise.", "id": "daqulap"}, {"comment": "Well, in this particular case, no memorization of rules [should be necessary](https://wikimedia.org/api/rest_v1/media/math/render/svg/0411fb914c2b6b4f5622048b44883d346d5af1e0). The way division is written makes it rather obvious what's going on.\n\nOf course you can always make an argument for \"well, once you're used to it, it's not so bad...\", and sure, traditional notation already has the advantage there (I think pretty much everyone has PEMDAS internalized) -- that's just what a new notation will have to be up against.\n\nBut I think even then, I think there are some inherent issues with this; it doesn't scale so well (imagine the spaghetti for a more complex equation), my eyes have to do a lot of seeking around to understand how the quantities are flowing in the equation, and since it's an inherently 2D representation, it won't be easy or elegant to embed this into linear text.", "id": "daqvysy"}], [{"comment": "I love this project.\n\nIt might not be the best tool for \"real\" programming because it does not seem to scale well to support huge programs but I might be mistaken.\n\nBut because learning syntax is the source of a lot of frustration for beginners and it drives away many people from programming before they see the beauty of it, I think this can be a **tremendously useful tool for teaching the basics of coding**.\n\nThe design is also beautifully polished which makes it immediately attractive to people who would be repulsed by source code that looks too much like math.\n\n**EDIT:** there's a small error in the tutorial. The UI does not allow me to enter the word `>upper`.", "id": "daqd4f2"}, {"comment": "The Minecraft mod [Psi](http://psi.vazkii.us/), by Vazkii, has a similar visual style that's useful to try to get people into logic.\n\nIt has the advantage of letting you make tangible cool things happen in game with your programs.", "id": "daqetn9"}], [{"comment": "It seems pretty interesting. I felt there was one small issue reading even the small examples shown.\n\nThere was a lot of need for eye movement tracing up and down the lines to really understand what was going on. It seems like you could get used to some of this but as programs grow I'm not sure how well this would hold up. Having to scroll up and down to understand complicated processes feels like it would be a pretty flow breaking experience.\n\nI'll be curious to see how/if future versions might try to deal with this problem. Maybe the solution is to stick to small pieces or less complicated problems which is not necessarily a bad thing.", "id": "daqeunt"}], [{"comment": "I'm seeing a lot of similarities to [LabVIEW](http://www.calpoly.edu/~fowen/images/PIDPositionControl.jpg), with it's dataflow programming. The multiple branching codepaths and blocking function calls really fit with parallel programming patterns, which are notoriously hard to wrap your head around in a text-based language. \n\nI always thought the concept of LabVIEW was nice, but the implementation was rather extremely terrible. (Seriously, the IDE itself requires at least a dozen services to run at boot, and don't get me started on the runtime.) Hopefully this will be a nice option to fill in the void of a language for easy parallel programming. (Even better if you can get Factor compiling to the GPU.)", "id": "daq4yxh"}, {"comment": "Skov's implementation also looks a bit weird. Squeak looked strange too.\n\nI dunno if this is just my perception or if there is something REALLY weird about all of these virtual thingies.\n\nThe ideas are pretty cool, I still want something like Squeak for ruby as an add-on working on the whole OS level - but I always have to scratch my head about some of the GUI parts.", "id": "daqemit"}, {"comment": "[Max/MSP](https://www.youtube.com/watch?v=o412npUqvcM) is maybe a more polished implementation of a visual programming language.", "id": "daqw4g5"}], [{"comment": "This is kind of neat. I'll bookmark this and read more into it later", "id": "daq9kuh"}, {"comment": "Lying to yourself is an unhealthy habit.", "id": "daql0ci"}, {"comment": "Like how Pocket failed, because no one ever used it.", "id": "daqngta"}], [{"comment": "I like it! I see great merit in exploring these types of programming paradigms.  ", "id": "daqc5nu"}], [{"comment": "I like the idea but the UI here (which is surely the whole point of this) is terrible. Hidden buttons whose name can only be seen on the status bar? Ugh.\n\nIt seems the workflow is heavily vi-style, based around pressing keys to perform commands, but there's no visible feedback to indicate whether you're in text editing mode or command mode.\n\nI followed the tutorial as far as placing the \"add\" command, and then it asked me to choose whether I wanted the \"math add\" or \"scratchpad add\" command, which is not mentioned in the tutorial (I guess they added a new namespace later?). I can work out how to navigate between the choices (arrow keys), but not how to confirm a choice. (Mouse click? No. Pressing enter? No. Right arrow? No. Ctrl? No. Pressing X? Brings up an error message, so probably not. Oh, wait, I can drag the output handle of the proposed \"math add\" command to my display command... oh, that gives another error. Now the whole thing seems to be broken.)", "id": "daqmao0"}], [{"comment": "Cool idea. I also suggest Python as a language conducive to learning. I find it to be elegant in its presentation.", "id": "daqpbbw"}]]], "5g2ep1": ["Pure - A configuration file format that sucks less than other configuration file formats", "2016-12-02 12:24:59", 90, "https://github.com/pureconfig/pureconfig", [[45, "A good start, but the devil is in the details. The provided examples are not sufficient to define what is allowed and what not.\n\nWhat about key defined multiple times? if => is a token, how to define a value of '>foo'\nWhat about whitespace, is \"a=b\" the same as \"a = b\" and \"a   =   b\"? How can I enter a value that contains whitespace? Using hyphens? How are they escaped? What about multi-line values? What about tabs? what's the value of $FOO when foo is not defined? What about Windows paths? How is the parser supposed to know which is the \"proper\" system path, if the parser does not know where the parsed values will be used? As someone else mentioned, can vars be forward-referenced? What about reference cycles (a key referencing itself or one of it's parents? How to define null vs the empty String? what characters are allowed for keys? How to Escape $FOO as a value?\n\nAnd so on. And once all these questions have found a solution, see if that result is any better than JSON, YAML, or other existing projects."], [34, "SameOldShit - A configuration file format that says it sucks less than other configuration file formats but really it sucks just as much."], [26, "It is asinine to think that this format will be any better than so many other formats. It is very easy to pretend that your format is better when you have barely specified it. Do you think everyone that has invented a configuration format has done so with the intent of it being terrible? There are so many decisions to make that aren't straightforward which will inevitably end with the format not being quite as nice as you had imagined it. \n\nJust reading through the comments, it seems you can't even remain consistent. While I applaud the effort, I think it is rather arrogant that you think can just whip up a nice format in an evening that will beat all others. If not arrogant, then naive. But I look forward to seeing the result when you have specified it fully, and evidence backing up why it is superior to others at that point in time. "], [22, "I'm not sure what's the great benefit of this over YAML. Pure seems easy to fuck up too."], [20, "Definitely agree on JSON not being great for configuration for a lot of reasons. I've defaulted to using TOML when I've had a choice. Interested in how this compares. I don't think TOML reads environment variables. That sounds like a useful feature"], [16, "As I read the title, I was more like [\"Haven't we been here before?\"](https://xkcd.com/927/), but after reading the Github readme: \"I want that!\""], [14, "Congrats, you made something more complex and ambiguous than YAML. Mission accomplished, I guess.\n"], [13, "This isn't defined formally enough by a long shot.\n\nHow are characters escaped in strings? Does it allow multi-line strings? Can you escape characters that don't need to be escaped? Do you support octal or hexidecimal notation? Single quotes or double quotes? What type of literals are allowed to construct the floats? Can we have 'keys' with spaces in them? If not, what characters are excluded? Is this UTF8? \n\n>A formal specification, although the informal description above should be enough to write a parser.\n\nNo the informal description is enough to write a million parsers, that don't actually agree on what they will and will not parse.\n\nThe ratio of arrogance/competence is completely off base. Way too arrogant, for being this incompetent.\n\nYou haven't defined a file format. Not even close. You haven't even picked a character encoding you dumb fuck. Tone it down and work harder. For now. Or at the very least, start actually defining a file format and provide at least the first implementation.\n\n\n\n\n"], [9, "Looks fairly similar to TOML, except with environmental variable support and definitions, but lacking arrays.\n\nEDIT: It looks like support for arrays was added since I made this comment. \n\nI can't find any reference to what indentation characters are used though (Tabs? Spaces? A mix? This is one of the pain points of YAML). It also needs a reference implementation and test cases before it's useful as a spec, IMO."], [6, "Any chance we'll see an EBNF grammar? Should be fairly easy to generate a parser for most languages."], [6, "In what way is this format much easier to configure than HOCON?"], [3, "Needs include file and include subdirectory functionality. As a standard, not as \"if maybe developer implements it as extra\"\n\nIt helps a lot when making automation for anything, especially configuration management for more complicated apps. If say app can have multiple backends, ability to have file per backend makes it much easier and readable to handle.\n\n\nAlso it'd need few clarifications. Like can I put more complicated things than \"a string\" into array ?\n"], [5, "Whitespace has already doomed you.\n\nAlso, the concept of \"=>\" is nice for the programmer-user, but would be hell to implement for the programmer-implementer.\n\nThe other thing you're not considering (because of \"=>\") is that both XML and JSON can be parsed using the \"SAX\" method, which treats each tag / object like an \"event\", meaning you never actually have to load the entirety of the the XML file or JSON object into memory, but can handle it \"as you parse.\"\n\nSure, a good percentage of us that deal with XML / JSON load the entire object into memory, but for those who don't, this is a required feature you can't implement."], [4, "My work uses JSON for configs and hit 3 of the points here:\n\n * You can't have comments.\n * Parsers won't do any type checking for you.\n * There is no easy way to say this config is exactly like that one except override one field.\n\nSo this looks great! One thing I would want from an implementation is a code generator for statically typed languages so you can pass around strongly typed objects representing the config with right types."], [4, "It doesn't look like this offers anything over [TypeSafe Config](https://github.com/typesafehub/config), which is already well specified, other than exchanging braces for mandatory indentation."], [4, "Why use this over TOML?"], [4, "> The worst formats to ask people to edit (programmers included) is by far YAML and JSON.\n\nI find YAML readable now, but it took a while. It requires a bit of explaining though, for noobs.\n\nI like this new format."], [3, "Seems like a lot of sensible ideas but I'm not sure about the indentation. Do end users really understand the tab key and indentation? Would you just use the dot format for end-user-facing config files?"], [3, "What's wrong with INI format?"], [3, "I like plenty about it, though I hate other things about it.  I like the references and the flexible nesting.  I don't like the indentation-based grouping (though that's just a personal preference, and not based in any sort of logic).  I do like the \"include\" directive, but there has to be some specification about how relative includes are handled (Relative to the current file?  Some include path?  The program's CWD?).  100% agreed on the comments.\n\n* One thing that's awful is the \"parser *must* replace environment variables\".  That assumes that the user that is reading the config file is the same user that the config file should be in effect for, making that functionality useless for a daemon, unless you drop into the user profile and re-parse for each invocation.  It also will trip up end-users who might not expect it (Trying something like $USD as a field value for example).  Leave the environment variable thing alone and let the programmer handle it themselves (or make it opt-in only).\n* Call the \"format definition\" a schema.  Schema is the term that everybody is already used to.  If you want to support schemas for a format, you probably should support them in the format itself.  There's a good reason JSON schemas are expressed in JSON itself, and why XML schemas are expressed in XML.  There's no reason for this to have a disparate format for just the schema itself.\n* A lot is left unspecified.  What if you mix the dot notation with indent notation?  What if you have a \"database\" section with a \"data.path\" field?  You say quotes are optional, but what about quotes that don't fully surround a field, like `fo\"o`, or `\"fo\"o`? What about `fo\"o`?  `\"foo`?\n* Is the data interpreted as a type, or is it always a string when the programmer gets it?  If you have a format definition, is the type of the read value different?  What if you have a format definition specifying a field as a string type which then gets a value of 500?  This is especially important for strongly-typed dynamic languages like Python.\n* What is that block in \"Lists of things/arrays\" supposed to be?  Is it a list of hashmaps?  Is it a list with a single hashmap?  It doesn't look like the brackets are necessary at all there, given that you have servers.app-1.log.level afterwards.  Is that a mistake or a redundant syntax?\n\nI noticed that you never mentioned TOML, which is an effective fix to the problems you mentioned about INI."], [2, "Yay, cool that it supports references, very useful. Does other formats support this out of the box? I guess XML can refer to other nodes, using xpath, but too ugly (other ways?)"], [2, "This seems pretty cool.  Is there a C++ implementation?"], [2, "This is a really nice format IMO. Unfortunately, the \"sucks less than other...\" title is going to cause this to get downvoted.\n\nAnyway, I hope other formats picks up the requirement to expand env variables. Great idea."], [2, "I can see myself using this. Please submit the link again when there are parsers available!"], [2, "Clearly invented by a python developer."], [2, "I started reading this thinking \"Ugh why do we need yet another format\" and ended it wondering how quickly I could implement it! Sure, it needs some fleshing out, and format spec, but it looks really good. Nice work!\n\nOne thing I'd consider is how to write this out from an API as well as read it, while preserving the structure of the original file as much as possible. I guess that's more down to implementations to do a good (as well as just \"correct\") job than it is the spec though"], [2, "Looks similar to HOCON which already has parsers in different languages."], [2, "Personally i use a simple file format for more than a decade. It is very simple to edit *and* parse and looks like this:\n\n    foo=bar\n    moo=\"cow\"\n    bell\n    {\n        no=yes { actually=maybe } # go figure\n    }\n\nI've written a bunch of parsers and generators for variations of this format in C, C++, Java, Free Pascal, HaXe and others. [Here is a C++ one](http://pastebin.com/yYCVKx4U) that keeps the key-value tree in memory and can save/load from disk files (note that the code needs a bunch of extra classes but it should be obvious what it does from the comments and names).\n\nSometimes i try other formats (especially if they come with some framework i'm using), but generally i end up using this format since it can be used for both configuration and as a general storage format."], [2, "Yet I prefer XML for one reason: an XSD schema for your config grammar enables Intellisense in MS DevStudio. Hunting down stupid typo's cost a lot more time than verbose format.\n"], [2, "I think the indentation structure is a bad idea. A programmer can get used to this quickly, but how does this satisfy a non-technical end user who copy and pastes some config from the web, and can't understand why the program is not working because they messed up the paste, and don't know it matters?\n\nI think your dot notation is much better. I am not concerned with repetitiveness in a config file. In fact, I would prefer it because it makes it extremely clear what setting I am making. \n\n"], [2, "I get that you don't want to dictate the filename, but I recommend defining a canonical file extension to make things like editor auto detection easier.\n\nOther than that, it seems useful! You might want to draw a stronger line on what separates this from YAML, since the end product feels very similar. 100% with you on JSON being rubbish for configuration."], [2, "I'm not really sure which issues with config files this is supposed to eliminate. A lot of the suggestions which would solve certain issues also introduce others. \n\nI really don't get why repeated prefixes are such a bad thing. We have invented the clipboard centuries ago, it's your friend. And that is completely disregarding that writing a config file from scratch almost never happens. I will ALWAYS prefer an easily adjustable and readable config file over something that is easy to create. Repeated prefixes have several advantages. For me two of the most important ones are: Auto-completion in editors (almost every editor understands those even if they don't know how to handle schema failes) and, far more important: Settings are easy to find. Searching for \"server.log\" will give me exactly what I need; Good luck finding exactly the setting you want if it's just \"log\" on one line and \"server\" somewhere above. That would require a regex that even people who use it more than just once a year will find annoying to construct. Nesting being optional makes it even worse. Now I have to go through the \"server\" group AND make sure that something isn't overwritten somewhere at the end of the file with the \"server.\" notation. The prefixes also allow for something that I admittedly don't use often but has come in handy every now and then: Being able to alphabetically sort config files by option. Especially when comparing different config files from a program this helps a lot.\n\nAnd don't get me started on indenting things. Typing the full prefix is almost impossible to get wrong whereas improperly indenting a line happens even to the most seasoned coders. \n\nThe real issue with hierarchies and prefixes isn't how they are handled in config files; The problem are programs that don't name their options properly. It really doesn't matter how you format the config file if the options themselves don't have unique names. No config spec will fix this, developers have to. \n\nI also strongly disagree that references add to readability. Yes, it will remove some redundancy in config files but having to manually \"parse\" a config file just to understand what it actually contains is a much bigger problem than having duplicate settings.\n\nI'm also not a fan of using environment variables in config files. I open the config file just to find out I have to quit the editor to first check the contents of the variable? Meh. Also, this can easily ruin portability. Even when using variables that are sure to exist on every system it's still not clear what value the config file holds without doing a manual check first.\n\nIf you ask me, this spec introduces features that might be convenient when writing a config file from scratch but readability goes out the window. That's not a tradeoff that I am willing to take because for every new config file I have to write I have to read/edit a hundred that are already there.\n\nThe point is: I see config files as an important part of any documentation and thus they should be as precise as possible. I should be able to know exactly what a line does just by looking at that single line only. And for that this spec is just as bad as many others."], [2, "Why is everyone so much against normal, common config formats? I get why XML sucks, but it's a solid format to represent plain config objects. And what happened to properties? It's a format so simple, you just can't fuck it up, and it can still represent most simple to medium configs. Instead everyone insists on making up cross-referencing, indent-sensitive, arcane formats that serve NO. DAMN. PURPOSE."], [1, "I really like the graph idea/syntax, hard to get cyclic graphs down to JSON"], [1, "You don't specify this explicitly, but I assume I can reference properties before they are defined (textually)?"], [1, "I like the idea of pseudoinfinite nesting and keeping things rather plaintext. Let's wait and see what the language support is for this first."], [1, "I did something like that already: https://www.reddit.com/r/programming/comments/4v6chu/why_json_doesnt_support_comments_douglas_crockford/d5w343r/\n\nConverts any sort of binary data into an easy to read and edit text file"], [1, "If you want to use something that's already implemented:\n\n* http://jsonnet.org\n* https://github.com/typesafehub/config\n\nYes, they both use braces.\n\nFor \"format definitions\" just map the configuration files to something well defined, for example, Protocol Buffers. So, for example, you can use Jsonnet in a language agnostic way by writing a build rule that validates a Jsonnet configuration file against a Protocol Buffer definition while parsing, and then outputs the configuration as a serialized Proto message. Your program can then just use the Proto message as its configuration. Since Protocol Buffers are available for many languages, it means that you can now use Jsonnet indirectly from all of those same languages. Of course, you can decide to use something other than Protocol Buffers instead (Cap N'Proto, Thrift, Avro, etc)."], [1, "Worth while to also throw [SDL](http://sdlang.org/) into the mix as well of other formats.\n\nWhat happens for multiline strings?\nHow about what constitutes an indent? Tab versus number of spaces ext.\n\nI might write a quick D parser and emitter tomorrow, looks like fun."], [1, "Read the whole thing. Great stuff."], [1, "I think the best configuration file format is the language you're using.   \nFor example LISP in Lisp  \nJavascript in Json   \nElixir in Elixir   \nand so on\u2026"], [1, "How should the parsed file be represented in memory?\n\nMaybe a lazy data structure is the best, as it avoids the problem of whether `=>` should copy or not."], [1, "There is a bit of a name clash between this and the [Pure language](http://purelang.bitbucket.org/)."], [1, "The referencing behaviour is nice but if I understand it correctly I feel it's pretty dangerous. I could easily see something like this happening ...\n\n    payment_provider = paypal\n\n    paypal\n        id = \"abc123\"\n        sandbox = true\n\nDo I mean the paypal structure, or the string `\"paypal\"`?\n\nAdding a new property may affect unrelated properties. For me that's dangerous."], [1, ">whitespace indenting based\n\nToo feeble to end users.\n\nOtherwise 8/10 would prefer to the other formats mentioned."], [1, "How do you define a schema for config file?  Or otherwise, is there some way for a person to verify that their config is \"valid\" according to whoever originally created the file?\n\nFor example, I was working with LiquiBase recently which uses XML for defining how to setup your database tables/data/etc.  I find the autocomplete and validation features afforded by XML to be incredibly useful.\n\nAs a counter-example:\n\n    shared\n        log\n            filename = server.log\n            rolling = true\n            keep-count = 10\n            max-size = 50MB\n\nIs there a way for an editor to know that \"max-size\" is one of the option I can put under \"log\"?  If you have a proper schema and a decent editor, then you could just have your cursor one  a new line and hit \"ctrl\"+\"space\" to get a list of valid fields that can appear there.\n\nI can see where a lot of people might say this is only useful when you're making a config file for someone else to actually config, or in other words that this is overkill for your own config for your own app.  However, even on your own project, I take the view that you should always write code as if you're writing for someone else.  Even if that \"someone else\" is just the future version of you.  Because future you is going to be so thankful that past you made the config so easy to work with.\n\nNow in the article it was pointed out that XML is not so easy to edit by hand for a human.  However, I would argue that this is an issue of using a proper editor.  A proper XML editor makes it incredibly easy to ensure your changes are entered correctly, and that your document as a whole is correctly formatted and valid."], [1, "so... YML?"], [1, "A massive part of how useful a config file format is is parsing speed tho. Json may not be amazing from a human-readability point of view, but it's easy and extremely fast to parse, given it's a LL(1) grammar. I haven't looked at Pure enough to judge, but I don't think parser design has had much consideration here"], [1, "Clearly you hit a nerve - A pull request and 60 GitHub stars in 12 hours, lol."], [1, "This is a great idea, but:\n\n>quantity            An integer followed by a unit,\n\nNOOO -- Do NOT require an integer followed by a unit; floating-point numbers should be allowed."]], [[{"comment": "A good start, but the devil is in the details. The provided examples are not sufficient to define what is allowed and what not.\n\nWhat about key defined multiple times? if => is a token, how to define a value of '>foo'\nWhat about whitespace, is \"a=b\" the same as \"a = b\" and \"a   =   b\"? How can I enter a value that contains whitespace? Using hyphens? How are they escaped? What about multi-line values? What about tabs? what's the value of $FOO when foo is not defined? What about Windows paths? How is the parser supposed to know which is the \"proper\" system path, if the parser does not know where the parsed values will be used? As someone else mentioned, can vars be forward-referenced? What about reference cycles (a key referencing itself or one of it's parents? How to define null vs the empty String? what characters are allowed for keys? How to Escape $FOO as a value?\n\nAnd so on. And once all these questions have found a solution, see if that result is any better than JSON, YAML, or other existing projects.", "id": "dap13n6"}, {"comment": "These are all good points, and a *formal spec* is the next step.\n\nI literally came up with Pure last night and more work needs to be done to iron out the gremlins.\n\n> What about key defined multiple times? \n\nParser error\n\n> if => is a token, how to define a value of '>foo' \n\nBy quoting, as you did\n\n> Tabs\n\nSpaces only, the parser is required to fail on indenting tabs. The parser can easily\nfigure out the multiple.\n\n> What about whitespace, is \"a=b\" the same as \"a = b\" and \"a = b\"?\n\nYes\n \n> As someone else mentioned, can vars be forward-referenced?\n\nYes\n\n> what's the value of $FOO when foo is not defined? \n\nThe empty string, with default values for respective types when using the typed API (bool => false, int => 0, and so on)\n\n> What about multi-line values? \n\nActual newlines in values in a config file is insane. The app would need to expand, say, \\n to newlines. Or whatever works for a specific app.\n\n> How to Escape $FOO as a value?\n\nThe only possible data type for that value is a string, so quote it.\n\nThe followup question would be, how to expand env vars in a string?\n\nWell, no problems, since unquoted values not inferred to be other types is a string. So\n  \n    logname = production-$APPNAME.log\n\njust works.\n\n> How to define null vs the empty String?\n\nIf the key isn't present, the value is null. If the key is present, but empty, it's an empty string (or if typed, the default value for that type)", "id": "dap1iut"}, {"comment": "> > How to Escape $FOO as a value?\n> \n> The only possible data type for that value is a string, so quote it.\n> The followup question would be, how to expand env vars in a string?\n> Well, no problems, since unquoted values not inferred to be other types is a string. So\n> \n>     logname = production-$APPNAME.log\n> \n> just works.\n\nBut what if you wanted to have a string that contains both / and expanded env var? Also what about\n\n    a = $NAMEsomestring\n\nthe simple solution is for example ${NAME} but it is still not free of problems because we introduce { and } as kind of special characters.\n\nWith env variable substitution we are one step before general string interpolation (like `a = \"http://${server.name}/api\"`) and so on.", "id": "dap29hs"}, {"comment": "> a = $NAMEsomestring\n\nSubstitution would work here, the parser is required to expand the longest matching string.\n\nSo what if you have both $HOST and $HOSTNAME and you use\n\n    server = $HOSTNAME\n\nbut you actually want $HOST followed by \"NAME\"\n\nAlternate syntax to rescue:\n\n    server = ${HOST}NAME\n\n> the simple solution is for example ${NAME} but it is still not free of problems because we introduce { and } as kind of special characters.\n\nRight.\n\nIn real life, both syntaxes must be supported exactly for this reason. Simple syntax for the 99% cases, {} supported to disambiguate.\n", "id": "dap2iou"}, {"comment": "I think adding more syntax for environment variables is a bad idea. Next, you'll want to remove parts of the env variable, and soon you'll have a whole shell scripting language.", "id": "dap68oj"}, {"comment": "Ooo we can add backtick quotes for full shell execution.\n\n    foo = `echo $HOST`NAME\n\nfor all sorts of fun!", "id": "dapkgls"}, {"comment": "Wouldn't `server = $HOST\"NAME\"` work as well, without any need for additional syntax?", "id": "dapdm70"}, {"comment": "> If the key isn't present, the value is null. If the key is present, but empty, it's an empty string (or if typed, the default value for that type)\n\nThis would make it unsuitable for me. I require all my configurations to be explicit. It should be null? Then define it null. A missing value means someone forgot to configure it.", "id": "dapg9ct"}, {"comment": "This makes no sense.\n\nI have systems supporting 250+ config settings, all with reasonable defaults. If the key is not there, it means I want to use the default.\n\nAre you saying I should put 250+ config settings in my config file instead of the 5 I want to change?\n", "id": "dapgcpa"}, {"comment": "It's use case depending. See my answer to /u/atrak9.", "id": "dapglja"}, {"comment": "But surely you noticed you can define formats :) Your format definition could make all settings non-optional. Then you would also get strong typing.", "id": "dapgqks"}, {"comment": "Which does not answer the initial question: How to differ null from empty string?", "id": "dapgtvv"}, {"comment": "By leaving out the key, as mentioned in the README.\n\nA key with no value is the *empty value*, which is an empty string, or - for typed API's - the default value for that type (0 for ints, false for booleans, etc)\n\nIf explicit null is a valid use case, I'm open to offer a syntax for it (in general, this is a really really bad idea, because your users have no idea about the difference between a null value and the empty value - fix your config logic)\n", "id": "daph5oi"}, {"comment": "> By leaving out the key, as mentioned in the README.\n\nSo we're back to a circle and none the wiser.\n\n> If explicit null is a valid use case, I'm open to offer a syntax for it\n\nSo with \"Pure\" it would (according to the current design) simply not possible. That's an answer.\n\n> because your users have no idea about the difference between a null value and the empty value - fix your config logic\n\nIf it's documented it's known. It's not an issue with the \"config logic\". There's nothing to fix.", "id": "daphgdf"}, {"comment": "> There's nothing to fix.\n\nYes there is. Just accept the fact that you deal with empty values, not null values. That's just silly.\n\nIn any sensible config API, null means \"key not there\". \n", "id": "daphl6z"}, {"comment": "> If the key is not there, it means I want to use the default.\n\nBut you just said the value is null if they key isn't present. If you're talking about *inheriting* the default from the spec, that's fine. I think /u/AngularBeginner is talking about when the spec *doesn't* contain a default for the key - it should throw an error rather than assume the \"un\"reasonable default of null.\n\nIf you *do* want null  as the default, there should be a null literal in your format grammar to use in the spec.", "id": "dapqpo6"}, {"comment": "Uh, what? I don't think I've ever seen an application require all settings to be specified. That's what defaults are for!", "id": "dapgemx"}, {"comment": "It's use case depending. In this case we use it as configurations for our own applications, which can be overridden with different environments and tenants. But I configured it that way that if a value is uninitialized, it is an error. It happens way too often that a value was forgotten.\n\nBasically inheritance with an error if there's no default fallback value.", "id": "dapgkc5"}, {"comment": "> Actual newlines in values in a config file is insane.\n\nIt's not. It is entirely possible to write a very small script that, say, makes parts of an email message configurable. It's ugly design for a big system, but for a one off script it might be just what is needed.\n\nIt should be supported IMO, even if you can't directly think of a use case (because there likely is for some weird edge case, and you are defining a format) ", "id": "dapk7y9"}, {"comment": "> Actual newlines in values in a config file is insane.\n\nThey have their use, though.\nFor example, you can put ascii character levels for games into them and indent them and let the game handle the whitespace/unused newlines:\n\nFor example:\n\n    width = 12\n    height = 6\n\n    map = \"\"\"************\n             *..*....*.E*\n             *.......*..*\n             *..*.......*\n             *P.*....*..*\n             ************\"\"\"\n        ", "id": "dapfw93"}, {"comment": "> > what's the value of $FOO when foo is not defined?\n> \n> The empty string, with default values for respective types when using the typed API (bool => false, int => 0, and so on)\n\nHmm, many people will want a parser error in such cases. As an option, maybe?\n", "id": "dapbmd7"}, {"comment": "There's also the problem of placeholders that you want an external modifier to change.  cmake's @@ system for configuration is one of these.", "id": "dapel22"}, {"comment": "Could you elaborate more on character escaping?\n\nSpecifically, what if you have a string like:\n\n> $foo = \"That's all folks\"\n\nBut you put $foo in another string like this:\n\n> $bar = 'The brown cow said \"$foo\"'\n\nWill the single apostrophe in $foo get automatically escaped, or will it close the string in $bar before the second double quote and apostrophe?\n\nWhat about:\n> $fooTwo = \"Example name => 'Example value'\"\n\n> $barTwo = 'Example usage: \"$fooTwo\"'\n\nDo you escape characters with a backslash? ", "id": "dapbypm"}, {"comment": "> if => is a token, how to define a value of '>foo'\n> By quoting, as you did\n\nWhy not just have > or some other single character operator for cross referencing? I think the benefit of forgoing quotes entirely would be beneficial, and it's not like you're writing boolean operations in your config.", "id": "dapldz8"}, {"comment": "You've glossed over this question:\n\n> What about Windows paths?\n\nand from my experience platform differences is **the** major source of trouble for config file writers.\n\nGiven that it is possible to use \"\\\" in filenames on Unix (to define escape sequences), you may want to consider the cross-breed notation we've been using in our compilers since 1990s:\n\n    [ <drive-letter> \":\" ] <unix-pathname>\n\nThis way, *relative* pathnames are the same on DOS/Windows and Unix, and *absolute* pathnames often differ even among flavors of Unix anyway. The latter means you may need conditional sections or some other mechanism to make the same config file work on, say, Linux and FreeBSD, or even on Red Hat and Ubuntu.\n\nBut filenames are just a tip of the iceberg. File permissions on Windows and *ix are quite different, Windows has services, Unices have daemons, and so on. And note that so far I've been pretending that nothing exists beside Windows and *ix.\n\nSo how do you propose to address these issues?", "id": "daqd68s"}, {"comment": "I was not giving an exhaustive list, just the problems obvious at a glance.\nPeople already mentioned TOML and HOCON, but there is bound to be more, variants of both json and yaml. Like this:\nhttp://hjson.org/\n", "id": "daqge95"}, {"comment": "> if => is a token, how to define a value of '>foo' What about whitespace, is \"a=b\" the same as \"a = b\" and \"a = b\"? \n\n> How to define null vs the empty String?\n\nI think given the stated goals, it would be ok for Pure to basically just ignore these issues. A general data serialization format should support serializing values like \" foo\" or \">foo\", for sure, but for a config format, I think \"well, just don't do that\" is an acceptable answer. \n\nThis also harmonizes with the use-case of making this an end-user friendly format -- you wouldn't want to force your users to insert confusing values like that. If you have full control over the parser of your config format, you can just decide how the format works semantically, and I doubt for a config format you need to be able to distinguish between null and the empty string. If you do, maybe you would actually be better served by either using a proper data serialization format, or by doing something else, like instead of the JSON\n\n    {\n        \"name\": null // name can be any string, or null to indicate this entity is anonymous\n    }\n\ninto Pure like this\n\n    entity.name = \n    entity.anonymous = true // now the value given to entity.name doesn't matter, and it's more self-documenting\n\n(assuming that you REALLY need to be able to name entities ANY string, and you can't have one string value represent the \"anonymous\" value)", "id": "dap5w2u"}, {"comment": "MarkDown anyone?", "id": "dapgdcm"}, {"comment": "No", "id": "dapgjc9"}, {"comment": "What about it?  Markdown for a configuration file?  How would you do that?", "id": "daptrod"}, {"comment": "What I meant was: /u/tkruse is right. Without a better spec, Pure will go the way of markdown: dozens of different implementations, only useful for the bare minimum.", "id": "daqbjdq"}, {"comment": "Ah, you're right there.  That's part of what makes Markdown so obnoxious to use, because there are so many flavors, it's hard to even call markdown a format, rather than just an idea.", "id": "daqokeb"}], [{"comment": "SameOldShit - A configuration file format that says it sucks less than other configuration file formats but really it sucks just as much.", "id": "dap50w7"}, {"comment": "Yep -- this reminds me of YAML in its infancy.  We all know how that ended up...", "id": "dapl73v"}], [{"comment": "It is asinine to think that this format will be any better than so many other formats. It is very easy to pretend that your format is better when you have barely specified it. Do you think everyone that has invented a configuration format has done so with the intent of it being terrible? There are so many decisions to make that aren't straightforward which will inevitably end with the format not being quite as nice as you had imagined it. \n\nJust reading through the comments, it seems you can't even remain consistent. While I applaud the effort, I think it is rather arrogant that you think can just whip up a nice format in an evening that will beat all others. If not arrogant, then naive. But I look forward to seeing the result when you have specified it fully, and evidence backing up why it is superior to others at that point in time. ", "id": "dapbtvl"}], [{"comment": "I'm not sure what's the great benefit of this over YAML. Pure seems easy to fuck up too.", "id": "daoyuvy"}, {"comment": "Personally, I enjoy YAML, but it is, as claimed in the link, that YAML is hard to explain to people not familiar with it. Lots of special characters. \n\nPure seems basically as simple as possible from a readability standpoint.", "id": "daoyxss"}, {"comment": "YAML just needs to be supported by editor you're using or else you *will* make mistakes even if you know it. Still better than fucking JSON tho.\n\nFrom functionality YAML is pretty okay, lack of includes is a pretty big drawback but ability to reference other part came in handy multiple time for us", "id": "dap14zz"}, {"comment": "YAML isn't acceptable as a configuration format because whitespace matters.", "id": "dap8zpl"}, {"comment": "The format demonstrated here has the same issue.", "id": "dapa1rd"}, {"comment": "That's not for me to say, I was just pointing out why YAML isn't acceptable.  I personally have not found a format that's more consistent and easier to use than INI.", "id": "dapaloa"}, {"comment": "Check out TOML. It's kinda like INI 2.0", "id": "dapfxqi"}, {"comment": "No, Pure white spaces only matter for indentation, where inconsistent use will cause an error. Looks good to me.\n\nI don't know YAML and what the problems are.", "id": "dapatdo"}, {"comment": "YAML has EXACTLY the same, which is exactly why it sucks as a configuration file format.", "id": "dapdkjo"}, {"comment": "Python also has the same issue.", "id": "dapenkx"}, {"comment": "It's overall a non-issue when you have one level of indentation (typical for config)", "id": "dapf26m"}, {"comment": "If you just have one level, go with established formats like INI, TOML, or YAML. There's almost no difference between them when you only have one level of indentation.", "id": "daph4oy"}, {"comment": "YAML isn't acceptable as a configuration format because of all the \"unpure\" data supported (serialization of language-specific types with !!classname)", "id": "daq1zd7"}, {"comment": "If Yaml allowed you to include files.", "id": "daq9p3l"}], [{"comment": "Definitely agree on JSON not being great for configuration for a lot of reasons. I've defaulted to using TOML when I've had a choice. Interested in how this compares. I don't think TOML reads environment variables. That sounds like a useful feature", "id": "daoyh2l"}, {"comment": "> I don't think TOML reads environment variables. That sounds like a useful feature\n\nUnless any part of the config is 'user input' in which case it's just the biggest security hole on your box.", "id": "dap1y9n"}, {"comment": "A lot of unixy config files support expanding env variables. It's a non-issue in practice.", "id": "dap2lro"}, {"comment": "Yes. But people don't generally use them in place of 'json' or 'yaml' .. \n\nIf this is part of the file format it excluses very many use-cases. Use-cases that don't use the arcane old unixy config files you refer to either, because well, it's too unsafe.", "id": "dap2pzk"}, {"comment": "How about adding an option to the parser that forbids environment variables? No more vulnerabilities.\n", "id": "dapbeb1"}, {"comment": "Sounds reasonable", "id": "daphnyz"}, {"comment": "[deleted]", "id": "dapbk98"}, {"comment": "Irrelevant. Bugs like that affects everything. Heck, shellshock made QMail processing dangerous. Yet, nobody claimed it was QMail's fault, because it wasn't.", "id": "dapg7qd"}, {"comment": "My hope is that the parser doesn't literally read the system's environment variables but a map of variables passed to the parser.\n\nGranted, this could still cause problems for one of my care abouts: round tripping.  There is value in config files targetted at humans but machines will still need to be able to do mutations on them.  As long as there is a way to get the literal values then I'm fine.\n\nI personally think TOML is already a good enough base.  I wonder if it'd be better to just add the features to TOML.", "id": "dap7p6u"}, {"comment": "The environment comes from the parent process, which the user already completely controls anyway. There's no security problem here unless somehow the environment is updated with values obtained from untrusted user input. And that doesn't seem to be the case here.", "id": "daqci3h"}, {"comment": "Was JSON ever supposed to be a configuration file format? As a data transfer format it's doing its job just fine. ", "id": "dape1m8"}, {"comment": "[Yes](https://plus.google.com/+DouglasCrockfordEsq/posts/RK8qyGVaGSr)\n\nDon't trust that man.", "id": "dapf6gc"}], [{"comment": "As I read the title, I was more like [\"Haven't we been here before?\"](https://xkcd.com/927/), but after reading the Github readme: \"I want that!\"", "id": "daozztk"}, {"comment": "Me too! Damn, really annoying that there are no parsers yet in the repo. ", "id": "dap0291"}, {"comment": "How could there be a parser? What character encoding does this use? What characters are legal as key names? Can strings be multiline? Can we escape unicode? What is legal range of the int and float values? What are the legal input formats of the ints and floats? \n\nThere is nothing here. Based on this page, you can have a million parsers that all do something completely different. ", "id": "dap2091"}, {"comment": "Wow, I didn't even notice it was just a design document. As someone posted elsewhere, \"the devil's in the details\"...", "id": "dapqwom"}, {"comment": "Hmm.. I liked it, may try to write basic parses for C# when I get home. ", "id": "dap2l5h"}, {"comment": "Send the author a PM or pull request if you do so!", "id": "daphqgp"}], [{"comment": "Congrats, you made something more complex and ambiguous than YAML. Mission accomplished, I guess.\n", "id": "dapefpx"}, {"comment": "Am I the only one who finds YAML to be the most error-prone syntax I've ever used? ", "id": "daqcmy9"}], [{"comment": "This isn't defined formally enough by a long shot.\n\nHow are characters escaped in strings? Does it allow multi-line strings? Can you escape characters that don't need to be escaped? Do you support octal or hexidecimal notation? Single quotes or double quotes? What type of literals are allowed to construct the floats? Can we have 'keys' with spaces in them? If not, what characters are excluded? Is this UTF8? \n\n>A formal specification, although the informal description above should be enough to write a parser.\n\nNo the informal description is enough to write a million parsers, that don't actually agree on what they will and will not parse.\n\nThe ratio of arrogance/competence is completely off base. Way too arrogant, for being this incompetent.\n\nYou haven't defined a file format. Not even close. You haven't even picked a character encoding you dumb fuck. Tone it down and work harder. For now. Or at the very least, start actually defining a file format and provide at least the first implementation.\n\n\n\n\n", "id": "dap1sxl"}, {"comment": "Of course this needs to specified. Work in progress.\n\n> Is this UTF8? \n\nYes.\n\n> What type of literals are allowed to construct the floats?\n\nDecimals and scientific notation.\n\n> Can we have 'keys' with spaces in them? If not, what characters are excluded?\n\nValid identifiers Unicode letters, no spaces allowed. I'll specify what is meant by \"Unicode letters\" in great detail in the spec.\n\nThe rest of your points are answered in a different comment with dupe questions.\n\n> You haven't defined a file format. Not even close. \n\nNo claim of a spec was made. Work in progress.\n\n> Downvote.\n\nUpvote.\n\n", "id": "dap23xz"}], [{"comment": "Looks fairly similar to TOML, except with environmental variable support and definitions, but lacking arrays.\n\nEDIT: It looks like support for arrays was added since I made this comment. \n\nI can't find any reference to what indentation characters are used though (Tabs? Spaces? A mix? This is one of the pain points of YAML). It also needs a reference implementation and test cases before it's useful as a spec, IMO.", "id": "dap0kbu"}, {"comment": "Arrays/lists are supported using the usual [a,b,c] syntax, with nesting allowed.\n\n> Tabs? Spaces? A mix?\n\nSpaces only, set your editor to expand to N spaces. Moreover, all indentation must be a multiple of N.\n\nThe parser is required to fail on input with indenting tabs, and indentation not a multiple of N.\n\nFinding the multiple is easy for the parser, the very first time you see a space on the first line, that's the first indentation.\n\nIMO, this is the *only* robust way to do indentation without bracketing.", "id": "dap13t1"}, {"comment": "> More over, all indentation must be a multiple of N.\n> The parser is required to fail on input with indenting tabs, and indentation not a multiple of N.\n\nRather than going through the extra effort of verifying that each indentation level uses the same number of spaces, why not just use tabs? 1 tab character = 1 level of indentation. It seems like the better option.", "id": "dap9lyi"}, {"comment": "> set your editor to expand to N spaces\n\nThat's going to trip your users up. Someone's going to open the config file, tab out to the right level (using whatever they've got their editor set to), and write something. Then it's going to break because their editor chose the wrong sort of whitespace.\n\nThis is a pain point with YAML, and the reason I don't use it. You're not making yourself attractive to disgruntled YAML users...", "id": "dapdfgi"}, {"comment": "uhhh... Python has the same issue basically.", "id": "daq20a2"}, {"comment": "It's a bit different. In Python, the programmer sets their editor up, and then writes a lot of code with the same editor settings. There's a ramp-up time when you join the project (making sure your settings match the project's), but after that it's plain sailing.\n\nWith a config file, someone unrelated to the project opens up the file (without setting up their editor first), and edits it. There's an assumption that there's no ramp-up time to editing a config file.\n\nRemember that this format is supposed to be simple and is presumably aimed at non-programmers: people who won't know what their editor's whitespace settings are necessarily, and won't know to check.\n\nEven for programmers, they'll have to remember to check what whitespace the file uses, and set their editor up accordingly. It's a bit like a python project where every file uses a different number of spaces, or some use tabs.", "id": "daqerfr"}, {"comment": "> Spaces only\n\nThis is my biggest, perhaps only, complaint with YAML.  Tabs for indentation, they're the one true way.", "id": "dapbovu"}, {"comment": "> IMO, this is the only robust way to do indentation without bracketing.\n\nIf you are making this for normal people, I think that implies you should do bracketing.", "id": "dapq973"}], [{"comment": "Any chance we'll see an EBNF grammar? Should be fairly easy to generate a parser for most languages.", "id": "daoztsn"}, {"comment": "You'd be surprised.", "id": "daqdw87"}], [{"comment": "In what way is this format much easier to configure than HOCON?", "id": "dap0f7z"}, {"comment": "HOCON  is ugly as fucks and non-technical people get lost in braces\n\n    bar : { a : ${foo.d}, b : 1 }", "id": "dap16tk"}, {"comment": "I'm not sure what defines ugly, but this is valid HOCON as well:\n\n    bar.a=${foo.d}\n    bar.b=1\n\nand requires little explanation.\n ", "id": "dap2p0q"}, {"comment": "The scala community has been successfully using HOCON as their preferred config spec for quite a while now. So I would definitely be interested in finding out what improvements the Pure config file format may bring. ", "id": "dapkob9"}], [{"comment": "Needs include file and include subdirectory functionality. As a standard, not as \"if maybe developer implements it as extra\"\n\nIt helps a lot when making automation for anything, especially configuration management for more complicated apps. If say app can have multiple backends, ability to have file per backend makes it much easier and readable to handle.\n\n\nAlso it'd need few clarifications. Like can I put more complicated things than \"a string\" into array ?\n", "id": "dap13m0"}, {"comment": "> Needs include file and include subdirectory functionality. As a standard, not as \"if maybe developer implements it as extra\"\n\nThis is a really good idea. I agree requiring this is a good idea. Do you have a syntax in mind?\n\n> Like can I put more complicated things than \"a string\" into array ?\n\nYes, arbitrary values / nested groups / arrays.\n", "id": "dap25vl"}, {"comment": "How do you imagine syntax for nested groups? Lets say I would like to have an array of servers and each of them has name, address, and port.\n\nReferencing other properties using => is nice but I don't see how to reference property as an array element. It seems that you need a different syntax.", "id": "dap34yg"}, {"comment": "Please, if you provide include file support allow for some mechanism to specify parameters for the included file (in addition to environment parameters).", "id": "dap5dn5"}, {"comment": "As for passing parameters, excellent idea. I think the clean thing to do is just reuse the env syntax. However, the environment variables are just visible to the parser, and wouldn't affect other processes.\n\n    $SOMEPARAM = ./data\n    %include other.conf\n\n... where other.conf access the \"parameter\" just like any other environment variable.\n\nNeat, yes?", "id": "dap920f"}, {"comment": "No, that stinks.\n\n    $OLDSOMEPARAM = $SOMEPARAM\n    $SOMEPARAM = ./data\n    %include other.conf\n    $SOMEPARAM = $OLDSOMEPARM\n\nWelcome to the joy of `#include` in C. I sure hope your parser-writers are on the ball.", "id": "dapdy03"}, {"comment": "It was mentioned elsewhere that it will support including files. Awesome.", "id": "dap5fte"}, {"comment": "> This is a really good idea. I agree requiring this is a good idea. Do you have a syntax in mind?\n\nI'd just pick a symbol meaning \"configuration parser directive\" (like `$` or %) and put anything special under it, for example `%include /file/name` or  `$include /etc/something/conf.d/*conf`\n\n", "id": "dap8jpw"}, {"comment": "I think I agree. Thanks for the input. (Globbing includes is both neat and really dangerous I think... but maybe)", "id": "dap8vap"}, {"comment": "Some systems also exclude \"common editor backup files\" (like filename~) but I think that is overkill (and kind of \"hidden suprise\" behaviour which I dont like). As long as you glob by extension (so `*.conf`, `*.cfg` etc.) there is very little it could break.\n\nOne \"gotcha\" is \"order of loading\", good practice is to sort result from glob output so that behaviour also would have to be into specification.\n\nIt is only really a problem if you support overriding the same key in a config, which can be tricky thing, but occasionally useful (so for example you can just use default config file of application and just put that one or two variables you need to change into app's `conf.d/` dir.\n\nOverriding can get messy, my personal view is that any case of two same key assignments in one files should trigger error but between files should be only a warning (so you can notice it if you need it, but can also override that one var in other file if needed)", "id": "dapa1d5"}, {"comment": "> Overriding can get messy, my personal view is that any case of two same key assignments in one files should trigger error but between files should be only a warning\n\nSounds reasonable. Of course, I know how to fail parsing. Not sure how to emit warnings in a consistent manner across languages and platforms (cannot assume a log file, for instance). Maybe just stderr?", "id": "dapahli"}, {"comment": "Hook for language, let dev take care of the logging. \nJust give list of warnings (with line + file), if they chose to ignore it so be it.\n\nDepending on language you can even do something like check if config object/struct has a method to emit warnings and use that (\nIn [tiny lib](https://github.com/XANi/go-yamlcfg#getting-loaded-config-name) I've made I just checked if struct had method and passed data to it if it existed).\n\nThat way from dev perspective he prepares object/struct, gives it method like ConfigWarning(line int, char int, message string) and does whatever he wants with it.\n\nIt really is language dependent so \"standard\" should probably just say \"passes warnings about duplicates with file, line and character of error\"\n", "id": "dapbech"}], [{"comment": "Whitespace has already doomed you.\n\nAlso, the concept of \"=>\" is nice for the programmer-user, but would be hell to implement for the programmer-implementer.\n\nThe other thing you're not considering (because of \"=>\") is that both XML and JSON can be parsed using the \"SAX\" method, which treats each tag / object like an \"event\", meaning you never actually have to load the entirety of the the XML file or JSON object into memory, but can handle it \"as you parse.\"\n\nSure, a good percentage of us that deal with XML / JSON load the entire object into memory, but for those who don't, this is a required feature you can't implement.", "id": "daph59d"}, {"comment": "You are wrong. Even SAX parsers needs to deal with \"=>\" like constructs, namely to deal with tag references, which may be circular. One example of a library supporting this is *xstream*.\n\n> but for those who don't, this is a required feature you can't implement.\n\nSure you can, I've done it multiple times. The operative word in the solution is \"placeholder\". \n", "id": "daphh6b"}, {"comment": "Yep.\nBut I don't think, the loading entire object into memory is an issue if we are just talking about config files. Anyway, you will likely want all config values stored in memory for use so '=>' doesn't cause more memory usage. It just makes config loading more complex...", "id": "dapr9sp"}], [{"comment": "My work uses JSON for configs and hit 3 of the points here:\n\n * You can't have comments.\n * Parsers won't do any type checking for you.\n * There is no easy way to say this config is exactly like that one except override one field.\n\nSo this looks great! One thing I would want from an implementation is a code generator for statically typed languages so you can pass around strongly typed objects representing the config with right types.", "id": "dap200e"}, {"comment": "Since Pure supports a definition format, code generation should be fairly simple.\n\nCool idea.", "id": "dap29x3"}], [{"comment": "It doesn't look like this offers anything over [TypeSafe Config](https://github.com/typesafehub/config), which is already well specified, other than exchanging braces for mandatory indentation.", "id": "dapadr6"}, {"comment": "> other than exchanging braces for mandatory indentation.\n\nWhich I claim is substantial, considering the inability of many people to get bracing right.\n\nGreat for programmers. For others? Not so much.", "id": "dapaley"}, {"comment": "> considering the inability of many people to get bracing right.\n\nI've seen plenty of people fail at indentation. How do you fail to get bracing right?", "id": "dapbzq3"}, {"comment": "But enforcing indentation of an arbitrary number of spaces is asking for trouble. I guarantee you that this becomes a headache for anyone having to deal with the format.\n\nImagine you have a massive config with 1000+ lines, and tons of nesting. Someone adds a line with 13 spaces instead of 12. Now you have to hunt for this.", "id": "daplqe7"}, {"comment": "> Imagine you have a massive config with 1000+ lines, and tons of nesting. \n\nMy experience is that 90% of config files has a single identation level (when considering \".\" a level in various formats)\n\nTwo levels takes you to 98%.", "id": "daptwec"}], [{"comment": "Why use this over TOML?", "id": "dapged2"}], [{"comment": "> The worst formats to ask people to edit (programmers included) is by far YAML and JSON.\n\nI find YAML readable now, but it took a while. It requires a bit of explaining though, for noobs.\n\nI like this new format.", "id": "daoxejf"}, {"comment": "YAML is pretty much \"if your editor doesn't support it, you probably will get something wrong\". But it is nice and readable and requires little to no setup so I usually use it.", "id": "dap1882"}, {"comment": "One of the main points of the proposed format is exactly that you can't expect a random user to have anything but Notepad or TextEdit.", "id": "dap1plv"}, {"comment": ">Notepad\n\nDamn, that makes significant linebreaks a no-go as well.", "id": "dapj7hu"}], [{"comment": "Seems like a lot of sensible ideas but I'm not sure about the indentation. Do end users really understand the tab key and indentation? Would you just use the dot format for end-user-facing config files?", "id": "dap17ky"}, {"comment": "It's a valid concern, but IMO any kind of bracketing is bound to fail when edited by users. A mysteriously disappearing \"}\" or \",\" happens all the time.\n\nAll in all, I think indentation is easier to understand than bracketing for \"normal people\" :)\n\n(My knee-jerk reaction when defining textual formats is to bracket things, but it's really not something non-technical people find intuitive)\n", "id": "dap1svk"}, {"comment": "That said, the one overriding reason I would never give a non-technical person a YAML file to edit is because the whitespace would trip them up. Wrong number of spaces? Cryptic error. Tab instead of spaces? Cryptic error.\n\nWith that out of the way, I can't see any advantage of Pure over YAML: YAML's array syntax is a lot more intuitive, for example.\n\nEDIT: Case in point, the \"List of things/arrays\" example has different levels of indentation for the different array elements - even the author got tripped up.", "id": "dap5f08"}, {"comment": "YAML is intuitive if you know it. For random end users, it's a mystery. What does all those weird characters mean? Who knows.", "id": "dap5ndi"}, {"comment": "Yeah, but I don't see that this is much better. In the simple case, it looks about the same as YAML. In the more complex cases, it looks just as cryptic (What does `=>` mean? What do the `[` and `]` mean? Why do some blocks have commas after them?)", "id": "dap61ve"}, {"comment": "It's a balancing act.\n\nI'd say => actually simplifies things greatly, once you have a comment explaining that it means \"reuse the config named such-and-such to avoid loads of repeated entries\"\n\nLoads of repeated entries is evil. If there are no repeating subentries, there will be no => in the file.\n\nA less cryptic alternative to [] for arrays would be great. I hate it, but haven't found anything better. Fortunately, arrays are exceedingly rare in user-facing config files.", "id": "dap8k2p"}, {"comment": "If the worry of `[]` is scaring end-users, how about replacing them with parenthesis? It's just easier to explain to a user, over \"brackets\", seeing how most people at least know what parenthesis are. They might end up using the wrong brackets otherwise. Or maybe allow any bracket to be used interchangeably (with the only requirement being that both opening and closing has to be the same type), seeing as their only usage is for arrays.", "id": "dapa0pb"}, {"comment": "Taken into consideration. Thanks.", "id": "dapaenv"}, {"comment": "Sure, `=>` simplifies things in the same way that `&` does in YAML. Both are cryptic, and both need a comment explaining. \n\nClaiming that YAML is a mystery to end users but Pure is fine is flawed, I think. Both are about equally complex.", "id": "dapdu89"}, {"comment": "> Both are about equally complex.\n\nBullshit. Here's one YAML example, under the \"Simple example\" heading for annotations:\n\n    aliases:\n    # example of an alias that defines just a single piece of data\n    - &environ [DAMAGE_ENTITY_EXPLOSION, DAMAGE_FIRE,  DAMAGE_CONTACT, DAMAGE_DROWNING, DAMAGE_FALL, DAMAGE_SUFFOCATION]\n    \n    # example of an alias that defines a block of data, using the previously defined alias\n    - &environDropNothing\n      tool: *environ\n      drop: NOTHING\n      exclusive: 1 # this means that if this drop occurs - none of the others will, unless they have the same number\n    \n    \n    otherblocks:\n    CREATURE_ZOMBIE:\n        - &environDropNothing  # stop mob farming - no environmental drops\n\nSimple my ass.\n", "id": "dapfcuc"}, {"comment": "Right, now post the same thing in Pure for comparison.\n\nIt's a little bit unfair to say \"bullshit, YAML is a mystery but Pure is fine\", then post only a complex YAML example.", "id": "daph263"}, {"comment": "Indenting is no better than brackets. You're saying that if the file is not written in this highly specific way, it means something totally different.\n\nFight the good fight. You can do it without mandatory whitespace. Look at TOML for example. You already have most everything else in place to do this.", "id": "dapi0pg"}, {"comment": "I'm a TOML user. It lacks proper references (thus reuse), nesting is unnatural (exactly why you do need whitespaces)\n\nIf you like TOML, go for it.", "id": "dapi3ia"}], [{"comment": "What's wrong with INI format?", "id": "dap2w6c"}, {"comment": "Deep nesting require you to invent naming standards for sections, no way to reference common properties, untyped.\n\nBut INI-files are definitely easy for people to understand, Pure tries to keep that property (pun intended)", "id": "dap34ki"}, {"comment": "I had this need about 2-3 months ago for a personal project and decided to go with INI, that's why I ask (even made my own little ini parser in cpp for that). \n\nBut I can see the advantages of Pure.", "id": "dap3crg"}, {"comment": "Ini is great for when it is sufficient. And choosing to constrain yourself to it can help make code much easier to set up, because whatever config you have is going to be simple.\n\nIt's likely to be insufficient for many projects, but the simplicity's half the beauty of it.", "id": "dapqkpu"}], [{"comment": "I like plenty about it, though I hate other things about it.  I like the references and the flexible nesting.  I don't like the indentation-based grouping (though that's just a personal preference, and not based in any sort of logic).  I do like the \"include\" directive, but there has to be some specification about how relative includes are handled (Relative to the current file?  Some include path?  The program's CWD?).  100% agreed on the comments.\n\n* One thing that's awful is the \"parser *must* replace environment variables\".  That assumes that the user that is reading the config file is the same user that the config file should be in effect for, making that functionality useless for a daemon, unless you drop into the user profile and re-parse for each invocation.  It also will trip up end-users who might not expect it (Trying something like $USD as a field value for example).  Leave the environment variable thing alone and let the programmer handle it themselves (or make it opt-in only).\n* Call the \"format definition\" a schema.  Schema is the term that everybody is already used to.  If you want to support schemas for a format, you probably should support them in the format itself.  There's a good reason JSON schemas are expressed in JSON itself, and why XML schemas are expressed in XML.  There's no reason for this to have a disparate format for just the schema itself.\n* A lot is left unspecified.  What if you mix the dot notation with indent notation?  What if you have a \"database\" section with a \"data.path\" field?  You say quotes are optional, but what about quotes that don't fully surround a field, like `fo\"o`, or `\"fo\"o`? What about `fo\"o`?  `\"foo`?\n* Is the data interpreted as a type, or is it always a string when the programmer gets it?  If you have a format definition, is the type of the read value different?  What if you have a format definition specifying a field as a string type which then gets a value of 500?  This is especially important for strongly-typed dynamic languages like Python.\n* What is that block in \"Lists of things/arrays\" supposed to be?  Is it a list of hashmaps?  Is it a list with a single hashmap?  It doesn't look like the brackets are necessary at all there, given that you have servers.app-1.log.level afterwards.  Is that a mistake or a redundant syntax?\n\nI noticed that you never mentioned TOML, which is an effective fix to the problems you mentioned about INI.", "id": "daptm5z"}, {"comment": "Many good points, some of which will be incorporated into the next revision tomorrow. \n\nAgree about the schema term... I was writing the \"spec\" in a hurry while I was angry about a flawed JSON file.", "id": "dapu2w9"}], [{"comment": "Yay, cool that it supports references, very useful. Does other formats support this out of the box? I guess XML can refer to other nodes, using xpath, but too ugly (other ways?)", "id": "daoxgxx"}], [{"comment": "This seems pretty cool.  Is there a C++ implementation?", "id": "daoxt8i"}, {"comment": "There are no implementations, because there is no specification. There is no file format. You don't even know what character encodings (utf8, utf16, latin?) are allowed. \n\nThere is nothing here.", "id": "dap1x0o"}, {"comment": "Pretty sure UTF8 will do even with its limitations just like this format, It's aiming at the 99% case", "id": "dap4h57"}, {"comment": "You know what... I'm actually interested in making a C++ implementation. Seems easy enough.\n\nI hope someone make a Java and C# implementations as well.", "id": "daoywum"}, {"comment": "> Seems easy enough.\n\nSee you in ten years.\n", "id": "dap8y7m"}], [{"comment": "This is a really nice format IMO. Unfortunately, the \"sucks less than other...\" title is going to cause this to get downvoted.\n\nAnyway, I hope other formats picks up the requirement to expand env variables. Great idea.", "id": "daoz3pp"}], [{"comment": "I can see myself using this. Please submit the link again when there are parsers available!", "id": "dap04on"}], [{"comment": "Clearly invented by a python developer.", "id": "dap2h6i"}, {"comment": "Author here. I hate Python, I'm a curly braces guy! \n\nYet, for config files, indentation makes sense.", "id": "dap2ldd"}], [{"comment": "I started reading this thinking \"Ugh why do we need yet another format\" and ended it wondering how quickly I could implement it! Sure, it needs some fleshing out, and format spec, but it looks really good. Nice work!\n\nOne thing I'd consider is how to write this out from an API as well as read it, while preserving the structure of the original file as much as possible. I guess that's more down to implementations to do a good (as well as just \"correct\") job than it is the spec though", "id": "dap2kfa"}, {"comment": "> One thing I'd consider is how to write this out from an API as well as read it, while preserving the structure of the original file as much as possible.\n\nThanks for the kind words :) \n\nI'd love to see a good solution to the format-preservation problem. Try saving a property-file in Java... it ends up like garbage. Preserving the format is even more important since comments are supported!\n\nNot sure what the best solution is, but clearly preserving newlines and spaces in pristine state is part of the solution.\n", "id": "dap2qj5"}], [{"comment": "Looks similar to HOCON which already has parsers in different languages.", "id": "dap4j9m"}], [{"comment": "Personally i use a simple file format for more than a decade. It is very simple to edit *and* parse and looks like this:\n\n    foo=bar\n    moo=\"cow\"\n    bell\n    {\n        no=yes { actually=maybe } # go figure\n    }\n\nI've written a bunch of parsers and generators for variations of this format in C, C++, Java, Free Pascal, HaXe and others. [Here is a C++ one](http://pastebin.com/yYCVKx4U) that keeps the key-value tree in memory and can save/load from disk files (note that the code needs a bunch of extra classes but it should be obvious what it does from the comments and names).\n\nSometimes i try other formats (especially if they come with some framework i'm using), but generally i end up using this format since it can be used for both configuration and as a general storage format.", "id": "dap570x"}, {"comment": "?? I'm confused. The `foo=bar` and `moo=\"cow\"` part is clear, you're defining a key-value map. But what does it mean to have `bell` there too? And what is the brace nesting doing in this example? I can't see a clear correspondence to some kind of hierarchy of lists/maps, like there is in JSON or YAML.", "id": "daq29eh"}, {"comment": "`bell` is a node without value (or actually, an empty value). Whitespace is ignored so it could have been `bell { ... }` instead. Each node has a name, a value and children. If a node doesn't have a value, you don't need to type the `=value` (or `=\" some value\"`) part and if it doesn't have children you don't need to type the `{` and `}`.\n\nCheck `CKVNode::ImportNode` in the code above, it should be clear :-). Note that this particular variation of the parser also supports nameless nodes (so you can have something like `things { { foo=bar } { foo=baz } { foo=moo } }` which defines a node `things` with three nameless children) and has to take care for the ambiguity of a nameless node after a valueless node (the writer simply adds a `=\"\"` in that case), but i decided to live with that to save a little bit of space (in other implementations i just use a short name like `a` that i simply ignore when parsing the tree).\n\nI have a much older one in C which i wrote it around 2003 and is much simpler, but it is read only (that one was used for user made configuration alone) and... well, i don't have it in this computer :-P. And later i decided that i also want to be able to save the trees too since it is useful for more than just configuration :-).\n\nEDIT: actually [i found it](http://pastebin.com/WZYZTQ5u). Note that the code is old and i have changed my style significantly since then (especially my C style - my C++ style is actually closer to that with CamelCase names and such, but my C style looks more like K&R now).", "id": "daq7nr5"}], [{"comment": "Yet I prefer XML for one reason: an XSD schema for your config grammar enables Intellisense in MS DevStudio. Hunting down stupid typo's cost a lot more time than verbose format.\n", "id": "dap8hu4"}, {"comment": "As explained in the link, Pure offers the equivalent of XSD schemas.\n\nCouldn't agree more about the usefulness of schemas.", "id": "dap8r3y"}], [{"comment": "I think the indentation structure is a bad idea. A programmer can get used to this quickly, but how does this satisfy a non-technical end user who copy and pastes some config from the web, and can't understand why the program is not working because they messed up the paste, and don't know it matters?\n\nI think your dot notation is much better. I am not concerned with repetitiveness in a config file. In fact, I would prefer it because it makes it extremely clear what setting I am making. \n\n", "id": "dapk2r3"}, {"comment": "> I think your dot notation is much better. I am not concerned with repetitiveness in a config file. In fact, I would prefer it because it makes it extremely clear what setting I am making. \n\nThen that's what *you* do. Pure supports it.", "id": "dapu0um"}], [{"comment": "I get that you don't want to dictate the filename, but I recommend defining a canonical file extension to make things like editor auto detection easier.\n\nOther than that, it seems useful! You might want to draw a stronger line on what separates this from YAML, since the end product feels very similar. 100% with you on JSON being rubbish for configuration.", "id": "daprwwa"}], [{"comment": "I'm not really sure which issues with config files this is supposed to eliminate. A lot of the suggestions which would solve certain issues also introduce others. \n\nI really don't get why repeated prefixes are such a bad thing. We have invented the clipboard centuries ago, it's your friend. And that is completely disregarding that writing a config file from scratch almost never happens. I will ALWAYS prefer an easily adjustable and readable config file over something that is easy to create. Repeated prefixes have several advantages. For me two of the most important ones are: Auto-completion in editors (almost every editor understands those even if they don't know how to handle schema failes) and, far more important: Settings are easy to find. Searching for \"server.log\" will give me exactly what I need; Good luck finding exactly the setting you want if it's just \"log\" on one line and \"server\" somewhere above. That would require a regex that even people who use it more than just once a year will find annoying to construct. Nesting being optional makes it even worse. Now I have to go through the \"server\" group AND make sure that something isn't overwritten somewhere at the end of the file with the \"server.\" notation. The prefixes also allow for something that I admittedly don't use often but has come in handy every now and then: Being able to alphabetically sort config files by option. Especially when comparing different config files from a program this helps a lot.\n\nAnd don't get me started on indenting things. Typing the full prefix is almost impossible to get wrong whereas improperly indenting a line happens even to the most seasoned coders. \n\nThe real issue with hierarchies and prefixes isn't how they are handled in config files; The problem are programs that don't name their options properly. It really doesn't matter how you format the config file if the options themselves don't have unique names. No config spec will fix this, developers have to. \n\nI also strongly disagree that references add to readability. Yes, it will remove some redundancy in config files but having to manually \"parse\" a config file just to understand what it actually contains is a much bigger problem than having duplicate settings.\n\nI'm also not a fan of using environment variables in config files. I open the config file just to find out I have to quit the editor to first check the contents of the variable? Meh. Also, this can easily ruin portability. Even when using variables that are sure to exist on every system it's still not clear what value the config file holds without doing a manual check first.\n\nIf you ask me, this spec introduces features that might be convenient when writing a config file from scratch but readability goes out the window. That's not a tradeoff that I am willing to take because for every new config file I have to write I have to read/edit a hundred that are already there.\n\nThe point is: I see config files as an important part of any documentation and thus they should be as precise as possible. I should be able to know exactly what a line does just by looking at that single line only. And for that this spec is just as bad as many others.", "id": "dapwstn"}], [{"comment": "Why is everyone so much against normal, common config formats? I get why XML sucks, but it's a solid format to represent plain config objects. And what happened to properties? It's a format so simple, you just can't fuck it up, and it can still represent most simple to medium configs. Instead everyone insists on making up cross-referencing, indent-sensitive, arcane formats that serve NO. DAMN. PURPOSE.", "id": "dapzvt1"}], [{"comment": "I really like the graph idea/syntax, hard to get cyclic graphs down to JSON", "id": "daoz1vi"}], [{"comment": "You don't specify this explicitly, but I assume I can reference properties before they are defined (textually)?", "id": "dap07k0"}, {"comment": "Correct", "id": "dap0ure"}], [{"comment": "I like the idea of pseudoinfinite nesting and keeping things rather plaintext. Let's wait and see what the language support is for this first.", "id": "dap0ooc"}], [{"comment": "I did something like that already: https://www.reddit.com/r/programming/comments/4v6chu/why_json_doesnt_support_comments_douglas_crockford/d5w343r/\n\nConverts any sort of binary data into an easy to read and edit text file", "id": "dap2z2p"}], [{"comment": "If you want to use something that's already implemented:\n\n* http://jsonnet.org\n* https://github.com/typesafehub/config\n\nYes, they both use braces.\n\nFor \"format definitions\" just map the configuration files to something well defined, for example, Protocol Buffers. So, for example, you can use Jsonnet in a language agnostic way by writing a build rule that validates a Jsonnet configuration file against a Protocol Buffer definition while parsing, and then outputs the configuration as a serialized Proto message. Your program can then just use the Proto message as its configuration. Since Protocol Buffers are available for many languages, it means that you can now use Jsonnet indirectly from all of those same languages. Of course, you can decide to use something other than Protocol Buffers instead (Cap N'Proto, Thrift, Avro, etc).", "id": "dap4kjd"}, {"comment": "> Yes, they both use braces.\n\nBraces and comas en masse. That's exactly what I'm trying to avoid, considering how often people make mistakes editing those formats.", "id": "dap4yf7"}, {"comment": "I'd love to see the data on: \"how often people make mistakes editing those formats\".\n\nYou keep citing it as matter-of-factly.\n\nOr if you have a survey please link it.", "id": "dapkhcw"}, {"comment": "Your not forced to use braces in HOCON", "id": "dapkzl7"}], [{"comment": "Worth while to also throw [SDL](http://sdlang.org/) into the mix as well of other formats.\n\nWhat happens for multiline strings?\nHow about what constitutes an indent? Tab versus number of spaces ext.\n\nI might write a quick D parser and emitter tomorrow, looks like fun.", "id": "dap4wal"}], [{"comment": "Read the whole thing. Great stuff.", "id": "dap5wim"}], [{"comment": "I think the best configuration file format is the language you're using.   \nFor example LISP in Lisp  \nJavascript in Json   \nElixir in Elixir   \nand so on\u2026", "id": "dap66sd"}, {"comment": "Great for dynamic languages. For Java and C++, not so much.", "id": "dap87u9"}, {"comment": "I don't think XML or YAML are in any way better\u2026   \nIn C/C++ nothing is simple, but [there are options anyway](http://www.hyperrealm.com/libconfig/)    \nIn Java nothing is concise, so XML or YAML are probably much better.\n", "id": "dapf6j4"}, {"comment": "Yeah but you can't just place runtime specific configs in a c++ header file and ship it with the binary. I think that is what he meant.\n", "id": "dapkyfo"}, {"comment": "In those cases I still prefer not using a configuration format but instead [Lua as configuration language](https://www.lua.org/pil/25.html)    \nIt's smaller and more manageable than any Xml or Yaml or whatever parser I've seen around, plus it is type safe.", "id": "dapmp1w"}, {"comment": "That's a different story. Not a bad idea if you are writing configs for other developers. ", "id": "dapn87j"}, {"comment": "For Java, I would have gander at https://github.com/typesafehub/config", "id": "dapkv7n"}, {"comment": "...until you have to interoperate between languages.", "id": "daq2a3q"}, {"comment": "\u2026 and the configuration format you've chosen has a shitty implementation in one of the languages you're using", "id": "daqe33g"}], [{"comment": "How should the parsed file be represented in memory?\n\nMaybe a lazy data structure is the best, as it avoids the problem of whether `=>` should copy or not.", "id": "dap6xqh"}, {"comment": "That would work.\n\nTo handle forward references, you can also simply keep a map of key => not-yet-there mappings. When the whole thing is parsed, you replace placeholder objects with the mapped objects.", "id": "dap7l62"}], [{"comment": "There is a bit of a name clash between this and the [Pure language](http://purelang.bitbucket.org/).", "id": "dapd0vo"}, {"comment": "It's just a working title anyway.", "id": "dapfrji"}, {"comment": "And the [Pure](http://purecss.io/) CSS framework. Googleability is a valid concern.", "id": "dapheda"}], [{"comment": "The referencing behaviour is nice but if I understand it correctly I feel it's pretty dangerous. I could easily see something like this happening ...\n\n    payment_provider = paypal\n\n    paypal\n        id = \"abc123\"\n        sandbox = true\n\nDo I mean the paypal structure, or the string `\"paypal\"`?\n\nAdding a new property may affect unrelated properties. For me that's dangerous.", "id": "dapejlg"}, {"comment": "You missed the fact that references are made with =>, not =", "id": "dapftgx"}, {"comment": "ah, ok. That's fine then.", "id": "dapg65u"}, {"comment": "Why not just consistently require quoting for strings? I think the inconsistency will be worse for nontechnical users who won't understand why quotes are sometimes significant and sometimes not.", "id": "daq7yvs"}], [{"comment": ">whitespace indenting based\n\nToo feeble to end users.\n\nOtherwise 8/10 would prefer to the other formats mentioned.", "id": "dapfdru"}], [{"comment": "How do you define a schema for config file?  Or otherwise, is there some way for a person to verify that their config is \"valid\" according to whoever originally created the file?\n\nFor example, I was working with LiquiBase recently which uses XML for defining how to setup your database tables/data/etc.  I find the autocomplete and validation features afforded by XML to be incredibly useful.\n\nAs a counter-example:\n\n    shared\n        log\n            filename = server.log\n            rolling = true\n            keep-count = 10\n            max-size = 50MB\n\nIs there a way for an editor to know that \"max-size\" is one of the option I can put under \"log\"?  If you have a proper schema and a decent editor, then you could just have your cursor one  a new line and hit \"ctrl\"+\"space\" to get a list of valid fields that can appear there.\n\nI can see where a lot of people might say this is only useful when you're making a config file for someone else to actually config, or in other words that this is overkill for your own config for your own app.  However, even on your own project, I take the view that you should always write code as if you're writing for someone else.  Even if that \"someone else\" is just the future version of you.  Because future you is going to be so thankful that past you made the config so easy to work with.\n\nNow in the article it was pointed out that XML is not so easy to edit by hand for a human.  However, I would argue that this is an issue of using a proper editor.  A proper XML editor makes it incredibly easy to ensure your changes are entered correctly, and that your document as a whole is correctly formatted and valid.", "id": "dapizgg"}, {"comment": "The README shows an example of how to define a config schema. This will help the parser verify, and can be used by editors to implement intellisense.\n\n> this is an issue of using a proper editor\n\nYes, but one of the major design goals of Pure is *exactly* to avoid depending on a particular editor. Why? Because your customers tend to use something silly like Notepad.", "id": "dapj7eu"}, {"comment": "> The README shows an example of how to define a config schema.\n\nStupid me, reading is hard.  Being able to define a schema is like 90% of what I look for in a data format, because it's just so dang powerful.  So now I'm pretty much onboard with Pure :-)\n\n> Yes, but one of the major design goals of Pure is exactly to avoid depending on a particular editor. Why? Because your customers tend to use something silly like Notepad.\n\nI think it would be FAR better to not let your customers edit config files to begin with.  Now it's a little different for me possible, because recently I've been doing mostly web-based services.  So for me, all customer editable configs are done through a web interface, and has a nice intuitive UI, and inputs are validated.  Very different situation compared to someone editing a file on their hard drive.\n\nIt's actually kinda maddening to me that Linux (for example) uses plain text for all it's config files.  Especially since it seems like every program / subsystem / etc uses *slightly* different syntax.  It's so bad in fact, that a *few* of the more system critical configs can be edited through a \"special editor\" that will refuse to save your changes if they are not formatted properly.  For example, the sudo file is super important, and so you should never edit it directly, instead you should the \"visudo\" program to do it.  \"Visudo\" is not actually a special program at all, but rather it is just the standard vi program with the one difference that the OS will check your formatting when you attempt to save.  But you still have the issue of different configs have different formats, and you don't get good error messages, and there's no auto-complete, and etc, etc.  Basically, the kernel devs responsible for config files would all get fired from any place I've ever worked at before, for insisting on rolling their own half-baked systems that barely works instead of using proven off the shelf technology.\n\nOk, rant over.  Anyway, Pure seems like an incremental improvement over \"old fashioned ini\" / \"java style properties\", and a massive improvement over JSON/YAML.  I think that on the server side, XML + properties files will still be my preferred config formats for now.  However, if Pure continues to mature and grow a supportive community and develop good tool-chain support, then I could easily see it becoming my preferred client side config format :-)", "id": "daplxel"}, {"comment": "> I think it would be FAR better to not let your customers edit config files to begin with\n\nUnrealistic, especially for server software.\n\nThanks for useful input though!", "id": "daptttd"}], [{"comment": "so... YML?", "id": "dapnkrv"}], [{"comment": "A massive part of how useful a config file format is is parsing speed tho. Json may not be amazing from a human-readability point of view, but it's easy and extremely fast to parse, given it's a LL(1) grammar. I haven't looked at Pure enough to judge, but I don't think parser design has had much consideration here", "id": "dapteeg"}, {"comment": "> I don't think parser design has had much consideration here\n\nSpeed is totally irrelevant for config files. You read it once into an internal memory structure.\n\nThe story is different for JSON, since it's a serialization format. Pure is not intended to be that.", "id": "daptqy4"}, {"comment": "you read a config file once, and it tends to take < 5ms even for the most verbose of formats...", "id": "dapubxt"}], [{"comment": "Clearly you hit a nerve - A pull request and 60 GitHub stars in 12 hours, lol.", "id": "dapva7z"}, {"comment": "Yeah, I even got two PM's from people wanting to write parsers in cooperation with me.", "id": "dapvgv6"}, {"comment": "Mine is already able to parse out the files. Although I'm using the extension \".purc\".\n\nStill got to put it into an AST, write extensions e.g. %include and do the substitutions.\nSchema will be a while away since I have no clue what I want to do with that.", "id": "dar8y02"}], [{"comment": "This is a great idea, but:\n\n>quantity            An integer followed by a unit,\n\nNOOO -- Do NOT require an integer followed by a unit; floating-point numbers should be allowed.", "id": "daq1vl2"}, {"comment": "They are.\n> double              64-bit IEEE double literal, such as 3.1415", "id": "dar8ty4"}]]], "5g5vwk": ["cloud-config a disposable VPN with DNS masking & ad-blocking in 60 seconds", "2016-12-03 00:26:51", 8, "https://github.com/imjacobclark/ubuntu-vpn-server", [[2, "> Recomended to not assign an IPv6 address when spinning up your cloud instance and disabling IPv6 traffic at the client VPN also.\n\nWhy? You're not really helping IPv6 adoption either..."]], [[{"comment": "> Recomended to not assign an IPv6 address when spinning up your cloud instance and disabling IPv6 traffic at the client VPN also.\n\nWhy? You're not really helping IPv6 adoption either...", "id": "dapqp5l"}, {"comment": "Because tin foil hats?  The opposition to IPv6 is just dumb.", "id": "dapyods"}]]], "5fodji": ["Option<T>, Discriminated Unions, Pattern Matching and Partial Applications for C#", "2016-11-30 10:32:03", 47, "https://github.com/DavidArno/SuccincT", [[6, "Sadly the \"pattern matching\" is really just a trivial dispatch, and so far as I can tell can't do match completeness (at compile time anyway). The syntax is also really verbose bordering on unreadable.\n\nAlso provides both `Option<T>` and `Maybe<T>`\u2026 with the former being a reference type and the latter being a value type."], [6, "Great job, I think libraries like this are a great learning tool.\n\nOne criticism, Option<T> is a reference type, which means it doesn't really solve the problem it's meant to solve."], [0, "what's wrong with... in the odd couple of places you'd use it in your code.\n\n    var cycle_idx = ((idx++ % max_idx) + (max_idx) % max_idx);"], [-13, "As primarily a Java developer these days `Option<T>` can die in a greasy fire."]], [[{"comment": "Sadly the \"pattern matching\" is really just a trivial dispatch, and so far as I can tell can't do match completeness (at compile time anyway). The syntax is also really verbose bordering on unreadable.\n\nAlso provides both `Option<T>` and `Maybe<T>`\u2026 with the former being a reference type and the latter being a value type.", "id": "dalvc00"}, {"comment": "I'd love to see, in particular, discriminated unions in C#, but without compiler/runtime support it ends up just looking kind of...hacky.  Neat tricks, but I think I'd actually hate working in a large codebase that used this library.", "id": "dalyx2z"}], [{"comment": "Great job, I think libraries like this are a great learning tool.\n\nOne criticism, Option<T> is a reference type, which means it doesn't really solve the problem it's meant to solve.", "id": "dama4kk"}, {"comment": "Which is also a performance issue. I don't want to be sticking every reference behind another reference (bye bye locality), when all that it's doing is attaching a bool flag to it.", "id": "damzxtb"}, {"comment": "But... it's functional.", "id": "dan1g42"}], [{"comment": "what's wrong with... in the odd couple of places you'd use it in your code.\n\n    var cycle_idx = ((idx++ % max_idx) + (max_idx) % max_idx);", "id": "dalymg6"}], [{"comment": "As primarily a Java developer these days `Option<T>` can die in a greasy fire.", "id": "dalv6p7"}, {"comment": "As primarily a C# developer, these days Java can die in a greasy fire.", "id": "dalw871"}, {"comment": "As primarily a Java developer, these days Java can die in a greasy fire.", "id": "dalwni8"}, {"comment": "As primarily a grease fire, don't extinguish me with Java.  ", "id": "dam0jb8"}, {"comment": "That would require a `AbstractFireEstinquishDecoratorFactory`.", "id": "dame4ww"}, {"comment": "Grease Fire Extinguisher: Enterprise Edition", "id": "damglfp"}, {"comment": "As primarily an `Optional<T>` developer, these days a greasy fire can be extinguished with Java.", "id": "dam3yrf"}, {"comment": "Why?", "id": "dalv9kl"}, {"comment": "Because it creates **a lot** of noise, and when you use `Option<T>` in a public interface you are **forcing** your clients to use this horrible pattern even though C# will soonish implement a way of indicating that a type is nullable which will eradicate the **only** reason to use it in C# since `??` and `?.` solves the common problems that `Option<T>` also solves. But you'll have to leave the trash out after it's useful because you made it part of your public interface.\n\nAlso in Java a common mis-usage of `Optional<T>` is using `Optional.of` when you really meant `Optional.ofNullable` which will helpfully throw a NPE. Although this behavior is understandable it could have been avoided by implementing some kind of optional nullability support in the language, and C# is doing exactly that.\n\n`Option<T>` is a verbose way of solving an issue that is much better solved by syntactic sugar.", "id": "dalwbad"}, {"comment": "> Also in Java a common mis-usage of Optional<T> is using Optional.of when you really meant Optional.ofNullable which will helpfully throw a NPE. \n\nIsn't that the exact opposite? `Optional.ofNullable` takes a value or a null and returns the corresponding `Optional`, `Optional.of` takes an actual value and raises an NPE if given a null.\n\n> `Option<T>` is a verbose way of solving an issue that is much better solved by syntactic sugar.\n\n`Option<T>` is a tool to lift nullability in a separate type, and segregate nullable and non-nullable items as different types. You can't solve that with syntactic sugar, and you can use syntactic sugar to reduce the verbosity overhead of `Option<T>` (which is what Swift does, or C# for `Nullable<T>`)", "id": "dalwvzi"}, {"comment": "> Isn't that the exact opposite? Optional.ofNullable takes a value or a null and returns the corresponding Optional, Optional.of takes an actual value and raises an NPE if given a null.\n\nYes I think you misread me, or I wasn't being clear.\n\n> You can't solve that with syntactic sugar, and you can use syntactic sugar to reduce the verbosity overhead of Option<T> (which is what Swift does, or C# for Nullable<T>)\n\nYou totally can, and `??` and `?.` does. In Java `@Nullable` and `@Nonnull` partially solves the idea of intention without putting it in the type system and at least IntelliJ honors this and will give you warnings if you forget to null-check a `@Nonnull` or null-check a `@Nullable`. It solves the business problem without resorting to all the noise that `Optional<T>` gives.", "id": "dam1bp5"}, {"comment": "> You totally can, and ?? and ?. does.\n\nIt's not a solution it's a workaround, you get no support from the type system and can put these pretty much at random.\n\n> In Java @Nullable and @Nonnull partially solves the idea of intention without putting it in the type system\n\nThese annotations are ad-hoc extensions to the type system. That's why you need *both*, if the feature were part of the type system only one of them (the non-default case) would be necessary.\n\n> It solves the business problem without resorting to all the noise that Optional<T> gives.\n\n@Nullable is hardly less noisy than Optional, and Nonnull would properly be pointless.", "id": "dam20ei"}, {"comment": "But the Optional type is horrible without actual language support. In my opinion it's *worse* than nothing because it creates so much code for something so seemingly simple.\n\nProgramming is always about compromise, and the Optional type just creates way to much baggage to be worthwhile. Annotations solves the issues in 99 out of 100 cases. The programmer usually know if a type can be null or not, you don't need type system support for it.", "id": "dam65fb"}, {"comment": "> Option<T> is a tool to lift nullability in a separate type, and segregate nullable and non-nullable items as different types. \n\nThat's what is says on the label, but it isn't what it actually does.", "id": "damfxyd"}, {"comment": "Nullable only supports value types (ie. structs) in C#.", "id": "damdprg"}, {"comment": "That's besides the point (and logical since C# reference types are always nullable).", "id": "damejx7"}, {"comment": "> C# will soonish implement a way of indicating that a type is nullable\n\nDon't hold your breath. I believe this proposal will go down. Too much legacy, too many problems, a lot of valid code that becomes compile-time error.", "id": "dalwzpj"}, {"comment": "Except that it won't generate compile-time errors, but warnings instead. If I'm not mistaken, you can also change it to errors or set it to be ignored completely.", "id": "dalya6o"}, {"comment": "Irrelevant distinction. You cannot just release a language change that will produce infinite amount of warnings on code that is currently fine. They can hide it behind flags but it is still problematic and it still blocks some existing patterns which are perfectly fine code like ThrowNotFoundIfNull(someObject)", "id": "dalyrng"}, {"comment": "They do that all the time for VB. The language has been getting stricter and stricter over the last 15 years.\n\nIf you don't like it, just suppress that warning number. ", "id": "damg192"}, {"comment": "TypeScript did this behind --strictNullChecks flag and it's been ok. It was a big commit to enable it though :).", "id": "damhied"}, {"comment": "Can it? That's great! Interesting how it would work if it interoperates with JavaScript.", "id": "damn37s"}, {"comment": "Like everything else, stuff coming from js is 'any', unless there is a type definition file stating that return value is 'null | Foo' or just 'Foo'. Ts union types are nice in that there is no need for Option wrapper", "id": "danpzvh"}, {"comment": "Yeah... but it seems to me that this approach is unacceptable for C#. You can't just generate a warning because the user moved that method in another assembly.\n\n", "id": "danz2dk"}, {"comment": "If someObject is of the type 'object?' there will be no warning and the pattern would still be usable.\n\nI'm sorry, but I don't see the problem.", "id": "dalzdgs"}, {"comment": "So someObject is an object of nullable type. Say you just got it from the database and null indicates that there was no record for that ID so you want to return 404 Not Found by throwing HttpResponseException. You do this on the second line in the method and you know that the value is not null after that but the compiler does not know that and spits a warning on every usage of someObject after this point. Note that things like Code Contracts can handle this via post conditions.", "id": "dam05u0"}, {"comment": "I see your point. I still hope they add the feature though.", "id": "dam3r5h"}, {"comment": "The compiler can tell if you checked for null and threw.  It already does this when enforcing other rules.", "id": "damggju"}, {"comment": "It could but it wasn't in the proposal and there will be issues with libraries unless it relies on something like code contracts", "id": "damn4n2"}, {"comment": "A simple example of API providing possibilities that are far beyond what nullability information can provide [here](https://doc.rust-lang.org/std/option/enum.Option.html). It's not C# nor Java but it shows how powerful this concept is.\n\nOf course Java also gives much better API than just having no null value, so I guess C# won't be worse. The biggest problem with such introduction of `Options` and `Maybes` is that we got 10y or 20y of language and it's eco development and `Options` are included only now, You can hardly find Java libraries working this way. And nobody is upgrading legacy API.", "id": "dalwgp3"}, {"comment": "None of those things can't be done on a nullable type.", "id": "dalwkwe"}, {"comment": "No one said that's the point. The point is having clean API and way of providing value absence explicitly.", "id": "dam09c8"}, {"comment": "Other than than that nullable is opt-out, rather than opt-in, in what way is the API cleaner? Null is a problem because it's a member of every type, not because it's harder to abstract over.", "id": "dam0d0d"}, {"comment": "When you accept null then you have to deal with null checking. If you don't accept it then you have to provide your own way of dealing with value absence.\n\nFor language like C# where we got null since it's early stage the easiest and most safe way is to combine `Option` and opt-out nullability. This way you are sure that there won't be any `NPE` and you don't have to create `NullObjects` or specific `Result` objects every time you want to return explicit value absence.", "id": "dam0thq"}, {"comment": "> When you accept null then you have to deal with null checking.\n\nAnd when you use `Option` you have to deal with `None` checking.", "id": "dam1gsh"}, {"comment": "Yes, but the point is you have rich API to deal with this stuff. So not only you end with more compile time checks, but also less verbose code and saner API.\n\nAnd if you still try to work on pure `None` then it's also nowhere near the freedom of spreading bugs with null. Any type can have value of `null` so you can write something like this (in Java):\n\n    String s = null; Integer i = null;\n\nand it will compile. On the other hand the only object that can have value o `None` is `Option`. You will got compile time errors when you try something like this (in Rust)  https://play.rust-lang.org/?code=fn%20main()%20{let%20x:%20String%20=%20None;} :\n\n    let x: String = None;\n\nIn Java you hove something a little different but still the only type that can have value of `Optional` is `Optional`. If you type:\n\n    String s = Optional.of(\"abc\");\n\nit won't compile. Instead you write:\n\n    Optional<String> maybeS = Optional.of(\"abc\");\n    String s1 = maybeS.or(DEFAULT_STRING);\n    String s2 = maybeS.orElseThrow(exceptions);", "id": "dam4as2"}, {"comment": "Although this doesn't apply to C#, Java's Option<T> has methods such as ifPresent, map, orElseGet, etc. which interact very poorly with checked exceptions.", "id": "dalxi86"}, {"comment": "> which interact very poorly with checked exceptions.\n\nThat applies to most of the language.", "id": "dam22p1"}, {"comment": "The funny thing is that there's no concept of checked exception in the JVM itself. It's purely Java thing.", "id": "dam8584"}, {"comment": "Good thing too, otherwise we wouldn't see so many other languages on the JVM.", "id": "damfse1"}, {"comment": "Why are so many Java folks so resistant to powerful changes?\n\nAh, yes, because otherwise they wouldn't care about Java.", "id": "dalyqrp"}, {"comment": "`Option<T>` in Java (and C#) is just plain stupid.\n\nAll reference variables in Java/C# are already option/maybe types. What we're missing is a `NeveNull<T>` type.", "id": "damfvr6"}, {"comment": "I don't disagree, but that's just because nullity is a stupid default.", "id": "damgf4u"}, {"comment": "Agreed. ", "id": "dami1ev"}]]], "5g55z8": ["Meaningful & useful representations of data with machine learning using Wolfram Language", "2016-12-02 22:20:56", 1, "http://blog.wolfram.com/2016/12/02/new-in-the-wolfram-language-featureextraction/", [], []], "5g87yi": ["Loop optimization, and microbenchmarking", "2016-12-03 08:59:35", 8, "https://kristerw.blogspot.com/2016/11/loop-optimization-and-microbenchmarking.html", [], []], "5fr9rx": ["Conclusions at writing library to checking email in Go, Rust, Dart, and Swift", "2016-11-30 21:35:19", 0, "https://fastchemail.gitlab.io/page/post/modern-languages/", [[2, "GUI for swift you never heard of?\nDid you ever see the name \"UIKit\"?"]], [[{"comment": "GUI for swift you never heard of?\nDid you ever see the name \"UIKit\"?", "id": "damp1jm"}]]], "5fwpwj": ["How to Deploy Software", "2016-12-01 17:07:01", 0, "https://zachholman.com/posts/deploying-software", [], []], "5fx414": ["Bro, do you even map ? \u2014 MapReduce demystified", "2016-12-01 18:24:06", 0, "https://medium.com/@aherve/bro-do-you-even-map-mapreduce-demystified-ea7f11b0e238", [], []], "5fvmfo": ["I made an Arduboy OLED low level memory emulator - use it for making fast drawing algorithms!", "2016-12-01 11:59:43", 4, "http://codepen.io/SarahC/pen/wWjjEL", [], []], "5g46aa": ["C++ confessions of a C developer", "2016-12-02 19:31:20", 40, "http://undo.io/resources/blog-articles/cpp-confessions-of-a-c-dev/", [[33, "I *love* modern C++, even as somebody who has spent the majority of my time using C# almost since its inception. The power and flexibility of the language once you get used to it is almost intoxicating. And thanks to things like Boost it's pretty easy to write relatively high-level code using some of their neat abstractions that hide platform-specific bullshit you don't really care about  (or at least the stuff you know you don't *need* to care about). The C++17 file system library, for example, is a godsend--I wish we had something like `path` in C#!\n\nGranted, when I use C++ it's entirely for personal projects that I never intend to finish so there's no pressure to deliver anything in a timely fashion so I can take as long as I want designing my libraries and really figure out how I want to pass an argument to a function I'm writing or whatever.\n\nTemplates are weird coming from a C# background, and it took a lot of stubbing my toe before I realized \"template\" actually means it's a code template. I kinda wish we had something similar in C# separate from generics.\n\nSFINAE is still terrible though, or at least it feels terrible in my experience. I understand why it is the way it is but it's such a pain in the ass. I'm pretty sure I spent at least an hour trying to figure out how to create a templated class that would only accept a boost stream as a type parameter so I could provide common read/write methods for file writing/reading, and I'm still not sure I ever solved that.\n\nI wish I got to use C++ more often. It's nice, 10/10"], [12, "> When I was a young journeyman programmer, I would learn about every feature of the languages I was using, and I would attempt to use all of those features when I wrote.\n\n> I suspect that anyone who\u2019s been developing for any length of time recognizes that description in someone they have worked with\n\nI've never met that person before.  Even when I was a C++ dev, and C++ devs are allegedly \"famous\" for this.  In my experience the majority of C++ devs write \"C with class\", and actively avoid as many C++ language features as possible."], [-21, "The STL sucks balls, classes are basically pointless when you have structs, and I see no reason to use C++ over C."]], [[{"comment": "I *love* modern C++, even as somebody who has spent the majority of my time using C# almost since its inception. The power and flexibility of the language once you get used to it is almost intoxicating. And thanks to things like Boost it's pretty easy to write relatively high-level code using some of their neat abstractions that hide platform-specific bullshit you don't really care about  (or at least the stuff you know you don't *need* to care about). The C++17 file system library, for example, is a godsend--I wish we had something like `path` in C#!\n\nGranted, when I use C++ it's entirely for personal projects that I never intend to finish so there's no pressure to deliver anything in a timely fashion so I can take as long as I want designing my libraries and really figure out how I want to pass an argument to a function I'm writing or whatever.\n\nTemplates are weird coming from a C# background, and it took a lot of stubbing my toe before I realized \"template\" actually means it's a code template. I kinda wish we had something similar in C# separate from generics.\n\nSFINAE is still terrible though, or at least it feels terrible in my experience. I understand why it is the way it is but it's such a pain in the ass. I'm pretty sure I spent at least an hour trying to figure out how to create a templated class that would only accept a boost stream as a type parameter so I could provide common read/write methods for file writing/reading, and I'm still not sure I ever solved that.\n\nI wish I got to use C++ more often. It's nice, 10/10", "id": "dapnhui"}, {"comment": "Assuming you're using 14, you can just do this:\n\n    #define REQUIRES(x) std::enable_if_t<x, int> = 0\n\nAnd now you can do things like this:\n\n    template <class T, REQUIRES(std::is_integral<T>::value)>\n    void foo(T t) { std::cerr << \"int\"; };\n\n    template <class T, REQUIRES(!std::is_integral<T>::value)>\n    void foo(T t) { std::cerr << \"not int\"; };\n\nLive example: http://coliru.stacked-crooked.com/a/5281a3ab9647251a. It takes some getting used to SFINAE but once you learn best practices you can actually do some really useful things quite easily, and even more useful things if you work at it. Highly recommend this talk:https://www.youtube.com/watch?v=Am2is2QCvxY&t=1s. It's a two parter. Will take a couple hours in total, but I can almost guarantee it will make you feel far more confident about SFINAE and templates. The price of power in C++, is sometimes you actually have to sit and just learn :-).", "id": "dapyd9h"}, {"comment": "Oh wow it never occurred to me to use a macro, thanks! I ended up just aliasing any of the messy-looking ones I thought I might re-use, like an `is_iterator_for` or whatever (or at least before I realized duh Boost already has type traits for the thing I was looking for, whoops).", "id": "daq4f9a"}, {"comment": "Couldn't you just use template specialization for that, though?", "id": "darmo3i"}, {"comment": "What? There is the static Path methods in C# which cover just about all of boost filesystem/C++17 paths. The C++17 filesystem library has terrible support for non-POSIX paths. Just try:\n\n```\nnamespace fs = std::experimental::filesystem;\nconst fs::path huh(R\"(\\\\?\\C:\\)\");\nauto rootName = huh.root_name();\n```\n\nEven worse with UNC paths. ", "id": "dapqz0e"}, {"comment": "Except the static `Path` class are just helper functions. You don't get little quality of life things like the `/` or `/=` operator to concat paths, instead you have to use `Path.Combine` which, if you're joining multiple paths simultaneously (e.g. `Path.Combine(rootDir, Path.Combine(workingDir, fileName))`), is less readable than `rootDrive / workingDir / fileName` IMO. The ability to iterate over path parts is also a nice convenience, sparing you from having to parse it out manually. \n\nIt's not the *best* solution but it's helpful. Your example is a good one and not one I'd encountered yet, I've pretty much only used it for local file paths.", "id": "dapusyo"}, {"comment": "I agree. Types are good here. Oh well one day. Sad there's on for `Uri` and not path.", "id": "dapwvsv"}, {"comment": "Since .NET 3.5 there you can do 4 strings without creating an array, and handle anything more by passing in string[] array:\n\nhttp://stackoverflow.com/a/1996202/1288473\n\n", "id": "dapvp6h"}, {"comment": "Oh god, Boost.\n\nWhy does this feature creep always happens with C++?\n\nGames that mandate boost - WHY.", "id": "dapszva"}, {"comment": "Because despite what you think, boost is an excellent library. Sure it may be 'bloat' in your eyes, but you don't have to use all of it and there are tools to extract libraries you want from it if that is really a concern.\n\nIn any case, most of if it is header only, so I don't see the issue. There's no point in re-inventing the wheel when boost has implemented it already and probably with a much better implementation that what you could have provided.", "id": "dapwmtr"}, {"comment": "I see Boost the way I see .NET, a great set of libraries that is ginormous but invaluable.", "id": "daq6w83"}, {"comment": "Yeah, needing to work with the file system in a reliable way. Or work with dates times and timezones with all the hard stuff handled for you. Or being able to hash a struct by combining the hashes of its fields. Total bloat. Who needs this stuff. Let's just write our own weak version of this in a weekend that ignores dozens of edge cases that people writing Boost have spent a cumulative total of years on. Or spend 6 months working on a library that's not directly part of my business functionality instead of getting the high quality one in zero time from Boost.\n\nSounds good.", "id": "dapwxeo"}, {"comment": "Probably for asio.\n\nJust a guess on my part, I have no tangible evidence.", "id": "dapwo9m"}, {"comment": "boost was actually the one thing i liked most about C lol", "id": "dapyuxd"}], [{"comment": "> When I was a young journeyman programmer, I would learn about every feature of the languages I was using, and I would attempt to use all of those features when I wrote.\n\n> I suspect that anyone who\u2019s been developing for any length of time recognizes that description in someone they have worked with\n\nI've never met that person before.  Even when I was a C++ dev, and C++ devs are allegedly \"famous\" for this.  In my experience the majority of C++ devs write \"C with class\", and actively avoid as many C++ language features as possible.", "id": "daphxmw"}, {"comment": "How long ago were you a C++ dev? This style of C++ is becoming more and more rare, and is usually associated with places that are stuck with old toolchains. Even a lot of people are doing modern C++14 on embedded these days.\n\nIn FinTech (my field) every good shop I've heard of is on 11 and using many newer features.", "id": "dapx3pl"}, {"comment": "> Even a lot of people are doing modern C++14 on embedded these days.\n\nYou mean a few? And you mean power hungry System on a Chip like Intel Atom?\n\nBecause I still havent found an C++ compiler targetting something like PIC32 that doesnt make the assumptions that it is targetting a desktop like enviroment in the regard of memory space size and processing power.", "id": "daq1j76"}, {"comment": "> CppCon 2016: Jason Turner \u201cRich Code for Tiny Computers: A Simple Commodore 64 Game in C++17\u201d\n\n> The Commodore 64 was released in 1982 and is the best selling computer model of all time. At 34 years old, even the most simple embedded processor today outperforms it. Join me on an exploration of how C++17 techniques can be utilized to write expressive, high performance, high level code for simple computers. Together we will create a game for this aging system.\n\n\nhttps://www.youtube.com/watch?v=zBkNBP00wJE", "id": "daq3xqt"}, {"comment": "I wanted to share this as well. Great talk!", "id": "daq4b32"}, {"comment": "This is indeed a great talk but Jason actually wrote a [tool](https://github.com/lefticus/x86-to-6502) which translates `x86` assembly to `mos6502` (Commodore). There is no native support for that platform in C++ toolchains.\n\n", "id": "daqdcyo"}, {"comment": "Yes? And\u00bf)?\n\nIf you're implying that there are no C++ compilers for small environments, explain how the arduino uses it for its avr chips.", "id": "daqg48o"}, {"comment": "Noup :) I was implying that support for most embedded platforms in terms of modern versions of C++ (and standard library) is not that good (unfortunately).", "id": "daqiz6x"}, {"comment": "I'm not sure, I've spoken to plenty on reddit, neither \"a lot\" nor \"a few\" are very precise so I'm not sure what the point is arguing.\n\nThe target for a C++ compiler is irrelevant in terms of memory usage; at the compiler level memory can only be acquired through things like new and malloc. The compiler doesn't have any leeway to start allocating things for fun. Maybe by memory you mean something other than RAM?", "id": "daq24sq"}, {"comment": "> at the compiler level memory can only be acquired through things like new and malloc.\n\nI'm not sure what you mean. Automatic allocation isn't dependent on the system.", "id": "daq3szf"}, {"comment": "C++ is used for avr chips, on the arduino for instance.", "id": "daqg4pf"}, {"comment": "I've used C++11 and later on both pic32s (PIC32MX320F128H) and 8-bit AVRs, using modern functionality like tuples, `auto`, std::function, template metaprogramming etc. (using gcc as compiler each time.)\n\nSome things are still better restricted, especially when you're on the smaller AVRs, like exceptions and excessive virtual methods, but it's not generally a huge deal IME. vtables incur a very small global overhead, not a per-object overhead in terms of memory, and the overhead in terms of CPU time is pretty small. I've used the AVR 32u4 a lot, which has 32kb of flash and 2.5kb of RAM, and there you can pretty much just go nuts with the language features.", "id": "daqip9p"}, {"comment": "Gross", "id": "dappqo7"}, {"comment": "Actually that's two nice things - classes and <<\n\nIf C would have included these two then perhaps it could have prevented C++. :)\n\nC++ just was too complex for its own good. But languages rarely become less complex as time passes by ...", "id": "dapt1l6"}, {"comment": "> classes\n\nYou can do it with structs, function pointers and naming conventions. No inheritance, but many see it as a good thing.\n\n> <<\n\nYou mean that stream clusterfuck? Seriously?\n", "id": "darlz2w"}], [{"comment": "The STL sucks balls, classes are basically pointless when you have structs, and I see no reason to use C++ over C.", "id": "daprn6y"}, {"comment": "You'll start to appreciate it once you gain some experience and tackle larger scale projects.", "id": "dapvefl"}, {"comment": "I can see someone hasn't ever used the type system to their advantage!\n\nCppCon 2016: Jason Turner \"Rich Code for Tiny Computers: A Simple Commodore 64 Game in C++17\" uses the type system and constexpr to move a lot of work to the compiler.\n\nhttp://jimkeener.com/posts/type-madness-part1 I use the type system to enforce rules.", "id": "daq43cb"}]]], "5gb44k": ["Cross platform actor model framework, is there a need for it?", "2016-12-03 22:06:43", 8, "https://github.com/AsynkronIT/gam/issues/35", [[2, "As long as messages adhere to a shared protocol such as AMPQ or JMS then cross platform actor communication is possible."], [2, "There's certainly a need for it, unfortunately it's all an ad-hoc mess right now, even with common message format protocols, this is not enough for cross-platform communication."], [2, "I question the real life utility of actors talking to each other across platform boundaries. I imagine one wouldn't want to split a single service across actors running on different platforms. That would be too esoteric. It's much easier to get interoperability via de-facto standards like REST, AMQP, JSON, etc. at the service boundary.\r\n\r\nHowever, a unified cross-platform model that would make switching from platform to platform while applying same concepts, APIs, behaviors, and skills I think would bring a substantial value by making platforms more of a customer's choice or environment than a major learning curve and a barrier that they are today."]], [[{"comment": "As long as messages adhere to a shared protocol such as AMPQ or JMS then cross platform actor communication is possible.", "id": "daqueox"}, {"comment": "It's possible, but simply adhering to AMPQ or similar is not enough.\n\nA realistic actor model framework would need to take care of a few more things, like being able to opt into message persistence, opt into \"at least one, at most once\" deliver guarantees, have message prioritization and so on.\n\nThere are plenty of patterns that you'll otherwise have to reinvent in every language to emulate what should be baseline protocol features.\n\n", "id": "dar1aba"}, {"comment": "The logical conclusion is that actor systems shouldn't directly communicate. Use a broker such as RabbitMQ or Kafka and then Akka or Orleans or whatever can process messages as they wish. ", "id": "dar1y8e"}, {"comment": "I wouldn't say that's the logical conclusion.\n\nActor systems, and systems in general do communicate directly nowadays through makeshift TCP protocols, or even worse - HTTP tunnels pushing XML and JSON, and lots of wheel reinvention.\n\nSystems are destined to communicate, and the Actor model is more discovered than invented, it's simply the nature of communicating systems to me.\n\nSo the potential of Actors will only be truly unleashed when they can directly talk to each other respective of platform and location.", "id": "dar2evh"}, {"comment": "Why is that the logical conclusion? did you follow the link?\nGAM is designed to be cross platform from day 1.\nIt does support both Akka style fire and forget actors and Orleans like grains.", "id": "dar31b0"}], [{"comment": "There's certainly a need for it, unfortunately it's all an ad-hoc mess right now, even with common message format protocols, this is not enough for cross-platform communication.", "id": "dar17r6"}], [{"comment": "I question the real life utility of actors talking to each other across platform boundaries. I imagine one wouldn't want to split a single service across actors running on different platforms. That would be too esoteric. It's much easier to get interoperability via de-facto standards like REST, AMQP, JSON, etc. at the service boundary.\r\n\r\nHowever, a unified cross-platform model that would make switching from platform to platform while applying same concepts, APIs, behaviors, and skills I think would bring a substantial value by making platforms more of a customer's choice or environment than a major learning curve and a barrier that they are today.", "id": "dardkjk"}, {"comment": ">  That would be too esoteric. It's much easier to get interoperability via de-facto standards like REST, AMQP, JSON, etc. at the service boundary.\n\nWhat if we did have a standard for actor interaction?\nWhat if we could say, this is how actors interact across network boundaries, and this is how serialization works?\n\nOnce you have a standard for that, it would be no stranger to have actor systems talking to eachother than having two REST services talking to eachother, right?", "id": "dark8ut"}]]], "5gbogn": ["Thou Shalt Honour Thy Bugs (or How I Learned to Stop Worrying and Love the bug)", "2016-12-03 23:55:05", 1, "https://marcelog.github.io/articles/thou_shalt_honour_thy_bugs.html", [], []], "5fjjej": ["I made this: a multiplayer game where you code to play", "2016-11-29 19:23:36", 479, "http://www.machinegame.com", [[19, "Recommended for desktop (rather than mobile)? I tried on Android with Chrome and Google keyboard but couldn't copy-paste anything.\n\nI haven't tried it on desktop yet. Anyhow, is it just me with this problem?\n\nTo naysayers: So why copy-paste? Well, you know when you're reading through the documentation and you want to copy-paste the examples as a quick feel-good starting point to get it to do *something* before you turn your brain on..."], [18, "What language is it?\n"], [13, "Looks really fun to me so far.  \nA few things: I'd really like a bit more information to get started. I didn't realize I had to open my browsers console at first to get the log messages (and since i'm not using javascript much I do need those :/ )  \nAnother thing is if oyu collect a wrench after your fifth you will not get more but it will disappear - is that an intended game mechanic?  \n  \nBots trying to execute two or more actions should at least result in a warning that something is wrong.  \n\nI'd also appreciate a short rundown of the classes - something like   \n\n    bot fields: {id, x, y, wrenches, action,}\n        functions: { moveTo, attack ...  }\nbut I guess people will figure it out after a bit.  \n  \nSummarum: The lack of feedback and exact docu might be a problem for people not familiar with js/programming in general.\n\n"], [9, "It looks like Screeps for poor. :0)"], [7, "Similar: www.halite.io:\n\n> Players control a bot using the programming language of their choice. Bots fight for control of a 2D grid. The bot with the most territory at the end wins. Victory will require micromanaging of the movement of your pieces, optimizing your bot's combat ability, and braving a branching factor billions of times higher than that of Go."], [6, "[I focused on combat with mine.  It works, except they blatantly ignore castles if there is an enemy nearby.](http://i.imgur.com/v7Ehyi3.png)\n\nEdit: Update!  We've conquered the [known world](http://i.imgur.com/OwuY9RW.png) for our glorious leader."], [4, "Sometimes it just stops working and no error shows up; it seems to be desyncing from the server but it's hard to tell. "], [4, "I tried the example code from the docs but it didn't work?\nAm i doing something wrong? my bot just stands at the wrench but never picks it up...\nalso the console.logs don't show up in the console?.."], [4, "Looks very similar to [codetition](http://www.codetition.com)\n\nEdit: like very similar ....."], [3, "When using CTRL and + (to do i++ for example) it zoomed the browser in lmao.\n\nTook me like an hour to figure out why it kept randomly changing"], [3, "Good concept, poor execution.\n\nAdd:\n\n* A return value for the collect() function (i.e. if(!bot.collect()){*do whatever*}\n* More direct control over the bots\n* Coordinates for the object that you can send your bots to, with a function to get the coordinates of any object.\n\nMaybe it's because my javascript is rusty but I couldn't get any loops to run. Is there a reason for that?"], [3, "if you don't know where to start,  here is some [sample code](https://gist.github.com/yoyoerx/85a971a321aa153ed6dd73b7daaab63e).  I used it to take over the world for a while.  Obviously very janky programming style.\n\n Based on some subsumption architecture. Very swarmy in behavior. "], [2, "It's pretty nice! As others have already pointed out, the documentation needs a bit more detail, e.g. what language should I be writing code in? (Javascript), what fields are accessible on the different objects?\n\nMy two major gripes are 1: the play speed is far too fast for me to keep up, and I usually end up losing track of my bots, and 2: when writing code the play area keeps zooming in and out in response to = and - keys.\n\nEdit: Now playing against other people. The graphics go completely screwy when I toggle between the Leaderboard and Machinegame tabs most of the time."], [2, "I know nothing about coding.  Could someone like me easily learn some basics off of this? "], [2, "Is there any way to preserve things between states? I tried tacking some extra properties on my bots, assigning them different roles (worker, fighter, defender) for example, only to find that all that stuff gets stripped between states. Defining lists or objects in the \"global\" scope doesn't accomplish this either; any mutations made aren't preserved. Sad :("], [2, "You need to say in your instructions that you must save the code to execute the commands. It took me 5 minutes to figure that out :/"], [2, "The game seems to freeze whenever I loop over other bots (state.others). How do I check if an enemy bot is near me?\n\nEdit: It appears the app is running the loop many times (over 2,000), even though the loop has no length. I was using the code: \n\n    for (i = 0; i < state.others.length; i++) {\n            other = state.others[i];\n            if (distance(bot, other) <= 1) {\n                if (other.wrenches <= bot.wrenches) {\n                    bot.attack(other);\n                }\n                return;\n            }\n        }\n\nEdit2: Also getting the error: \n\n    NetworkError: Failed to load worker script at \"http://www.machinegame.com/js/lib/ace/worker-javascript.js\"\n\nNot sure if that's related"], [1, "This sounds interesting, I will look into this!"], [1, "I love it! Like a grown up Scratch. I will be wasting a couple hours now."], [1, "Very interesting. I'd like code to be saveable cross-computers though."], [1, "> Your code did not compile, check the logs (F12)\n\nNothing in the console. No feedback on what worked or what didn't. But now the code isn't saved, and I'll revert to a working version if I refresh. Not cool\u2026"], [1, "Period save would be nice, hit back by accident and lost my code (kek)"], [1, "This is great. I've played around with a few ideas of programming a bot as a game but struggled to have it actually be fun. I'm on mobile now but can't wait to try this on desktop!"], [1, "Where did you buy this domain from?"], [1, "This this is really fun. Also, it's getting me to mess around with javascript which I generally consider \"icky\", but now I can appreciate some things about it. Thank you."], [1, "I had a very similar idea. But I didnt know how to do It. "], [1, "It's pretty frustrating that the API is so awkward and not completely listed in one place. Why does each action eat your turn even if it doesn't do anything? For example, bot.collect() should return true if wrench was collected and consume your turn, otherwise return false and allow you to make another action call. I have to write a loop just to determine if I should make a .collect() call, which is totally pointless and obnoxious. Also I had to read the comments here to figure out that I needed to press the save button in order for any code to run. I'd expect whatever I'm writing to execute immediately whenever there are no syntax errors."], [1, "Pretty fun.  I noticed when I try to store data in a bot in an arbitrary property, it gets cleared out between steps.  I don't know much about Javascript, but this makes me wonder if I can reliably track bots, wrenches, or castles by reference, or if I'd have to store the id and iterate each list every step.\n\nedit:\n\nYep, looks like the all the objects are recycled every step:\n\n    let prevbot;\n    function play(state) {\n        if (prevbot !== undefined) {\n            console.log(\"IDs equal: \" + (prevbot.id === state.bots[0].id))\n            console.log(\"References equal: \" + (prevbot === state.bots[0]))\n        }\n        prevbot = state.bots[0];\n        console.log(\"preset dump: \" + JSON.stringify(state.bots[0]))\n        state.bots[0].foo = 'bar';\n        console.log(\"postset dump: \" + JSON.stringify(state.bots[0]))\n    }\n\nResults in the following output:\n\nRun 1:\n\n    preset dump: {\"id\":2,\"x\":0,\"y\":0,\"wrenches\":1}\n    postset dump: {\"id\":2,\"x\":0,\"y\":0,\"wrenches\":1,\"foo\":\"bar\"}\n\nRun 2:\n\n    IDs equal: true\n    References equal: false\n    preset dump: {\"id\":2,\"x\":0,\"y\":0,\"wrenches\":1}\n    postset dump: {\"id\":2,\"x\":0,\"y\":0,\"wrenches\":1,\"foo\":\"bar\"}\n\nThis wouldn't be an issue if the arrays were instead objects indexed by the ID, otherwise we have no way to keep track of bots, or especially to be able to determine whether one has died (this can be especially useful for giving bots different behavior, or assigning a \"class\" to a bot at birth.  I was attempting to designate bots to jobs, having harvest/building bots, combat bots, and conquering bots for taking castles, but the lack of persistence ended up making it difficult).  The current way appears to be keeping our own objects and building maps with each step, and storing state data in some global objects instead of trying to work with the bots directly."], [1, "Sometimes in the multiplayer mode all my bots simply freeze :/ Mostly happens when I have 200+ bots and make a code-change. I can still see other players bots move and attack so its not that I've lost connection or something."], [1, "I was trying to use a foreach loop for quite a while until I realized that it doesn't seem to work with your pipeline."], [1, "[You will be assimilated](http://i.imgur.com/EhUIx6B.png)\n\nEdit: It feels so good to destroy an army of 200 bots in a single turn\n\nEdit 2: [Poor guy...](http://i.imgur.com/NttgrEL.png)"], [1, "For everyone like me - You MUST use the save button for your code to be executed \n\nInitially i thought i could just save my code to a file with this button"], [1, "/u/luiii \nthe game really needs a way to change the amount of ticks that go by in singleplayer. makes it so, *so* difficult to go at a reasonable pace without having to spam click \"next frame\".\n\ntrying to figure out why my units don't seem to be attacking, but more often than not when I find enemies, I die before I can pause. shit, some sort of development corner would be great, where you could drag and drop enemy units, castles, wrenches, ect onto the grid.\n\nedit: even a simple \"pause when enemy appears\" checkbox would be **great**"], [1, "a new addiction, greaatttt, thanks brooooooo"], [1, "This is way more fun than I expected. I spent a few hours last night refining my script, and was on top until Windows automatically updated and restarted. I have noticed a couple times where all my bots will suddenly stop moving until I recompile the script (without any error messages in the console). Also it would be nice if it was easier to tell the difference between 10 bots stacked on top of each other and 100, the text blends in with the bot after 100 are stacked. Great work!"], [1, "Fun little game. I'll try giving it a run during primetime instead of at night.\n\nhttp://i.imgur.com/qit9UVq.png"], [1, "Damn, one little typo and my whole army has been exterminated while on its way to world domination."], [1, "When storing state in globals I'm finding they aren't cleared by resetting the game, only by reloading the page. If you can't automatically clear them, maybe we could get an init function that's only called at the start of the run. It might also be nice to have access to the current tick number.\n\nSeems to work pretty well on Chrome for Android on a tablet with a keyboard, the biggest isssue I'm facing is a lack of debugging tools. It would be great if you could display syntax errors when saving, and also show any console.out messages.\n\nLastly, it would be nice if you could drag the divider between the code and map panes."], [0, "Blocked at work... Lol"], [0, "reminds me of codingame.com\n"], [0, "Does it actually execute the code to test it? \n\nInjection attack in 3... 2... 1..."], [-6, "Judging from looking at it for 5 secs its basically the game I once imagined. Good, so I don't have to write it (which wouldn't have happened anyway)."]], [[{"comment": "Recommended for desktop (rather than mobile)? I tried on Android with Chrome and Google keyboard but couldn't copy-paste anything.\n\nI haven't tried it on desktop yet. Anyhow, is it just me with this problem?\n\nTo naysayers: So why copy-paste? Well, you know when you're reading through the documentation and you want to copy-paste the examples as a quick feel-good starting point to get it to do *something* before you turn your brain on...", "id": "dakslab"}, {"comment": "Definitely will have a better experience on desktop, I've tried reaching the point of \"not completely unusable\" on mobile, but it's a real challenge.\n\nDid not think of copy-paste though, I'll look into that\nThanks!", "id": "dakwmhq"}, {"comment": "Can confirm (Chrome on Android) - Copy paste is not working in the code editor.  \nNot that I would want to really do much on mobile, but still since some parts of the page kinda look like they were designed for smaller screens (it's a rather good design for mobile imo). Although you do not really have access to the console on mobile anyway so it's not really that useful.", "id": "dakxge3"}], [{"comment": "What language is it?\n", "id": "dakr7nq"}, {"comment": "/r/programming's favorite language ", "id": "dakt367"}, {"comment": "\"You've probably never heard of it...\"", "id": "dalbn3g"}, {"comment": "[deleted]", "id": "dalgkzf"}, {"comment": "Or, and i know this is a big stretch so hear me out, maybe he was making a joke/reference.", "id": "dalnm5y"}, {"comment": "How is JavaScript modern?", "id": "dam1oi3"}, {"comment": "Haskell?", "id": "daljqxw"}, {"comment": "javascript...", "id": "daksl2u"}, {"comment": "The language for toys", "id": "dal4lht"}, {"comment": "And app development, according to Facebook (I actually have found react native quite alright).", "id": "dampwky"}, {"comment": "Javascript, I'll include it in the documentation\n\n", "id": "dakwj1n"}, {"comment": "So is there any way to move a bot around without a target?  I hate to see them sit there and do nothing, because no targets are visible.", "id": "dalhx2l"}, {"comment": "You can pass an object with x and y attributes (absolute coordinates, not relative to the bot). E.g.\n\n    var target = {\n        x: 42,\n        y: 24\n    }\n    state.bots[0].moveTo(target)", "id": "dalrvzu"}, {"comment": "Thanks!  I'm used to explicitly typed languages so I didn't think of this for an embarrassingly long time. ", "id": "dam4bmw"}, {"comment": "Yes.  You can specify coordinates.", "id": "dalt0xm"}], [{"comment": "Looks really fun to me so far.  \nA few things: I'd really like a bit more information to get started. I didn't realize I had to open my browsers console at first to get the log messages (and since i'm not using javascript much I do need those :/ )  \nAnother thing is if oyu collect a wrench after your fifth you will not get more but it will disappear - is that an intended game mechanic?  \n  \nBots trying to execute two or more actions should at least result in a warning that something is wrong.  \n\nI'd also appreciate a short rundown of the classes - something like   \n\n    bot fields: {id, x, y, wrenches, action,}\n        functions: { moveTo, attack ...  }\nbut I guess people will figure it out after a bit.  \n  \nSummarum: The lack of feedback and exact docu might be a problem for people not familiar with js/programming in general.\n\n", "id": "dakysmr"}, {"comment": "Ah this is very useful feedback, thanks a lot :)\n\nThe doc is still slim, it helps me immensely to know what you lacked, thanks!", "id": "dalqi7u"}], [{"comment": "It looks like Screeps for poor. :0)", "id": "daksg0o"}, {"comment": "Free Is Better", "id": "dakv5o6"}, {"comment": "Ah interesting, I had not heard of Screeps.\n\nIt's indeed the same concept, less advanced than Screeps (they went all the way into showing you what's in memory, etc)\n\nThey also seem to mix scripting units with some mouse interaction, which is interesting and richer. ", "id": "dakx3u9"}, {"comment": "If you have some time at hand, please try to make a open source client for it. The entire backend code is open sourced, but the client code is not.", "id": "dalt0vg"}, {"comment": "I regret purchasing screeps tbh.", "id": "dal6orx"}, {"comment": "Why?", "id": "dal7413"}, {"comment": "You don't get enough features in the free version to see how effective your algorithms are and I felt like it would take quite a bit of time (which I was paying for while my initial stabs at strategies were running) to develop a robust enough lib to do what I wanted to do. \n\nIt's been a while but that's what I remember my gripes being. ", "id": "dal82i2"}], [{"comment": "Similar: www.halite.io:\n\n> Players control a bot using the programming language of their choice. Bots fight for control of a 2D grid. The bot with the most territory at the end wins. Victory will require micromanaging of the movement of your pieces, optimizing your bot's combat ability, and braving a branching factor billions of times higher than that of Go.", "id": "daltgsh"}], [{"comment": "[I focused on combat with mine.  It works, except they blatantly ignore castles if there is an enemy nearby.](http://i.imgur.com/v7Ehyi3.png)\n\nEdit: Update!  We've conquered the [known world](http://i.imgur.com/OwuY9RW.png) for our glorious leader.", "id": "dalh19h"}, {"comment": ":) This is awesome\n\nI like that you hid your code by folding it", "id": "dalqmry"}, {"comment": "Curious, if there's nothing in range, are you waiting for more wrenches to spawn or moving in a random direction? I couldn't think of anything other than rolling a dice to decide which direction to move to.\n", "id": "dalt87r"}, {"comment": "I'm moving in a bigger and bigger square. Random directions are probably not that good, because then the bot only moves locally.", "id": "dalvlz1"}, {"comment": "I had my bots roam around until they all had 5 wrenches, then they returned to (0, 0).  I got lucky because the 1st place player was there with 7 castles.  I ran him out with my secret attack algorithm. :)\n\nI'll be rewriting my AI today to store the locations of wrenches and castles globally so they don't need to maintain vision of something they've found.  Also might try to add some scouting.", "id": "dam4jrc"}, {"comment": "I want to try and expand my code, but I don't know enough about javascript objects to find all the available variables associated with say a wrench or enemy.\n\nIs javascript efficient enough to determine the closest enemy or wrench for a particular bot with a foreach loop? I'm not confident enough in my own abilities to create an algorithm to detect the closest object without knowing there's an optimizer like in Java or C++.", "id": "damrj3k"}, {"comment": "It's plenty efficient for that kind of task.  If you want to know the variables available on an object, just `console.log(object);`  It's members should show up in the developer console for your browser.", "id": "dan1970"}, {"comment": "Oh wow, I didn't realize that was possible. That makes things a little easier.", "id": "dan898t"}, {"comment": "I'm taking over... http://imgur.com/a/cxjuo", "id": "damuo23"}], [{"comment": "Sometimes it just stops working and no error shows up; it seems to be desyncing from the server but it's hard to tell. ", "id": "dalnpsm"}, {"comment": "Check your browser's javascript console; usually when it stops working for me it's because I made a typo in my code.", "id": "dalusxo"}, {"comment": "That's what I meant by \"no error shows up\" - console is empty. Saving will make it go for a few turns before it stops again.", "id": "dalxw4u"}, {"comment": "Same problem comes up with me.", "id": "daly09r"}, {"comment": "i get this as well. gotta recompile (involves changing the code, even if it's just adding a space randomly) or refresh the page after every time I \"restart\" the world. it's annoying.", "id": "damautr"}, {"comment": "Something that might work is making sure every branch of your function has a return.  I believe that it can get stuck, especially when a bot or the last bot dies.  The return statements should cause it to restart the loop and avoid this.", "id": "dami4la"}], [{"comment": "I tried the example code from the docs but it didn't work?\nAm i doing something wrong? my bot just stands at the wrench but never picks it up...\nalso the console.logs don't show up in the console?..", "id": "dakwzio"}, {"comment": "Had the same problem, realized you have to press the save button that appears before it will use any of your code.", "id": "dal4o5m"}, {"comment": "Oh good point, it makes total sense", "id": "dalqijk"}, {"comment": "I've got the same issue. I'm trying to do the solo mode and arena mode and for both of them if I save and click the play button nothing happens, the guy just stands there. FWIW my browser is getting a 404 for `http://www.machinegame.com/js/lib/ace/worker-javascript.js`. Chrome 54.0.2840.98 (64-bit) on OSX 10.11", "id": "dammhfz"}], [{"comment": "Looks very similar to [codetition](http://www.codetition.com)\n\nEdit: like very similar .....", "id": "daky5g3"}, {"comment": "Oh nice, I had not heard of codetition.\n\nIt's uncanny how starting from the same idea the end result is very similar\n\nThere does not seem to be a multiplayer mode though", "id": "dalqkad"}], [{"comment": "When using CTRL and + (to do i++ for example) it zoomed the browser in lmao.\n\nTook me like an hour to figure out why it kept randomly changing", "id": "dal6w85"}], [{"comment": "Good concept, poor execution.\n\nAdd:\n\n* A return value for the collect() function (i.e. if(!bot.collect()){*do whatever*}\n* More direct control over the bots\n* Coordinates for the object that you can send your bots to, with a function to get the coordinates of any object.\n\nMaybe it's because my javascript is rusty but I couldn't get any loops to run. Is there a reason for that?", "id": "daleu8t"}, {"comment": "Sorry you had a bad experience, your feedback is very useful though. The moveTo is indeed a little strange.\n\nDid you figure out what was wrong with the loops?", "id": "dalqm1i"}, {"comment": "Loops work fine.\n\nAlso, try this:\n\n    console.log(JSON.stringify(state));\n\nThat will show you what is there. I believe you can move to a coordinate by passing in any object like { x: myX, y: myY }; Then you can write your own functions. See also [importScripts](https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/importScripts) if you want underscore or something.", "id": "dalo8kr"}, {"comment": "> A return value for the collect() function (i.e. if(!bot.collect()){do whatever}\n\n\nIf you decompile the bot actions (\"decompile\" in javascript means `console.log(bot.collect)`), all they do is something like:   \n\n    this.action = <constant>\n\nWhich means the game can't really provide a return value for bot actions. A better way of thinking about it is that you're filling out state.bots with your plan for next turn, which gets executed on the server and then returned to you.\n\nThis means that when you call bot.collect() (or any other bot action), there's no way of knowing what the result will be until the next tick. ", "id": "dalzo0p"}, {"comment": "My mistake. I'm focusing on C right now so I'm in that mindset.\n\nMy javascript is very rusty. ", "id": "dam6k5c"}, {"comment": "You can't blame this on JavaScript, it would work the same in any language :)\n\nThe API could be a bit more explicit that you're creating a plan to be executed instead of actually executing actions one by one, though. ", "id": "dam6x98"}, {"comment": "As in I'm not using the right syntax\n\nI'm on mobile right now so I can't test.", "id": "dama6va"}, {"comment": "I think this game is a little bit infastructure light on purpose. It makes you develop your own methods and forces you to develop the best algorithms, rather than being handed any.", "id": "dalzujh"}, {"comment": "Wouldn't that mean you need to handle the coordinates yourself rather than one catch-all goto method?", "id": "dam6hni"}, {"comment": "I didn't say it has no infastructure, it just has a very limited infrastructure. For example, a method to get objects at a location would be helpful, since it's kinda hard to do that without super inefficient looping.", "id": "dama9zx"}, {"comment": "Fine, but shouldn't there ALSO be lower level options to do things by hand? Especially when I'm learning I want to be able to manipulate everything to get a firm grasp. Furthermore it's more fun/challenging to see who can have the best function to collect stuff. ", "id": "daml902"}], [{"comment": "if you don't know where to start,  here is some [sample code](https://gist.github.com/yoyoerx/85a971a321aa153ed6dd73b7daaab63e).  I used it to take over the world for a while.  Obviously very janky programming style.\n\n Based on some subsumption architecture. Very swarmy in behavior. ", "id": "danq2iq"}, {"comment": "Out of curiosity, do you think its better to flee to your set location or would it be better to modify the flee algorithm to run in the opposite direction of any enemies that might be near it?  Seems like you might save some lives this way :P  \n  \nI like the way you implemented the marching.", "id": "dapqc6x"}, {"comment": "Fleeing was sort of an afterthought and it was the easiest way to implement it. In reality,  I don't think it matters. If them others chase,  my bots won't outrun them. If they don't chase,  it would probably be slightly better to run away, rather than perhaps running towards them and get into a fight. \n\nThe marching was fun to make. I was trying to avoid global variables and incur more \"state\". ", "id": "daq2zps"}, {"comment": "I am working on my algorithms now that I have some free time, and I've constantly been thinking of them in sort of an overall way.  \n  \nie. The brain decides what the body should be doing to be most effective whereas in yours, each individual body part can decide what to do.  \n  \nI don't have any experience with AI, so what would you say are some of the pros and cons of each?", "id": "dar99no"}, {"comment": "I am no expert but I did take an AI class in college. Honestly,  I never thought of trying to code it the other way. I am curious to see what you did to make a central system. \n\nFrom what I know,  the distributed systems like mine require less overhead in terms of memory and processing. It is also easier to code,  in my opinion. They can result in emergent behavior from a set of simple rules. The downside is that they can be less efficient at tasks and you might not get the behavior you want. This would be where a learning algorithm would help, which is non trivial. I basically had to watch how the swarm behaved and tweaked parameters and priorities until I observed successful behavior. \n\nA central controls system has the benefit of being easier to task,  ie who hunts,  who occupies, etc. However,  you have a lot of overhead managing the state of who is doing what. You also have to make decisions about what each bot needs to do. \n\nIn my system,  I have set up a priority list with specific criteria. Each round,  each bot gets the opportunity to assess its current situation and make an action based on that. Very simple (I think). \n\nThe downside of what I have done is that the array index of the bots, wrenches, and others tend to change, so the the goals for each round are somewhat random. This results in a lot of thrashing and a lot of extra movement. The saving grace is that picking up a wrench or attacking are top priority and are based on searching the others and wrenches list. So there is no wasted opportunities there. \n\nA system that constantly tracks closet bot to a wrench, for example, and assigns it could avoid a lot of that. \n\n\nI hope this helps.  Good luck!", "id": "darfw70"}, {"comment": "Thanks for all the input!  I am currently a sophomore in college and I've been leaning towards network security as a career, but this is fun and I'm really enjoying learning about different algorithms while I'm thinking up how to tackle this game.  \n  \nCurrently, (since there is no way I can see to store anything from round to round), I am planning on modeling it as some form of min-cost flow problem and finding an algorithm I like to solve it and determine the most optimal assignment of bots to tasks.  \n  \nDepending on the runtime, I may have to use an approximation algorithm, but we'll see.  \n  \nIn the meantime, I'm using a blend of your code and code that I had already implemented beforehand, plus some other modifications that I've added to it.  \n  \nI'll post it if you'd like to see what it is.", "id": "darjs2c"}], [{"comment": "It's pretty nice! As others have already pointed out, the documentation needs a bit more detail, e.g. what language should I be writing code in? (Javascript), what fields are accessible on the different objects?\n\nMy two major gripes are 1: the play speed is far too fast for me to keep up, and I usually end up losing track of my bots, and 2: when writing code the play area keeps zooming in and out in response to = and - keys.\n\nEdit: Now playing against other people. The graphics go completely screwy when I toggle between the Leaderboard and Machinegame tabs most of the time.", "id": "dal6i7a"}], [{"comment": "I know nothing about coding.  Could someone like me easily learn some basics off of this? ", "id": "dal6zng"}, {"comment": "yea probably. Try and see?", "id": "dalav5t"}, {"comment": "I would take a quick javascript tutorial first, since this doesn't really teach syntax in the documentation, but this would be a fun first project.", "id": "dalzvg3"}], [{"comment": "Is there any way to preserve things between states? I tried tacking some extra properties on my bots, assigning them different roles (worker, fighter, defender) for example, only to find that all that stuff gets stripped between states. Defining lists or objects in the \"global\" scope doesn't accomplish this either; any mutations made aren't preserved. Sad :(", "id": "dalj2cc"}, {"comment": "Use a dictionary with bot.id as an identifier.", "id": "dalzaop"}, {"comment": "If custom properties and globals get stripped between states, how are you preserving the dictionary?", "id": "dame9f6"}, {"comment": "this code works, also with dictionaries/objects.\n\n    var direction = 1;\n    \n    function play(state){\n        console.log(direction++);\n    }\n", "id": "damgiw5"}, {"comment": "Huh, you're right. I could swear I tried that exact thing yesterday with different results. Thanks anyway, this opens up a lot of fun possibilities.", "id": "damvznc"}], [{"comment": "You need to say in your instructions that you must save the code to execute the commands. It took me 5 minutes to figure that out :/", "id": "dalmk59"}], [{"comment": "The game seems to freeze whenever I loop over other bots (state.others). How do I check if an enemy bot is near me?\n\nEdit: It appears the app is running the loop many times (over 2,000), even though the loop has no length. I was using the code: \n\n    for (i = 0; i < state.others.length; i++) {\n            other = state.others[i];\n            if (distance(bot, other) <= 1) {\n                if (other.wrenches <= bot.wrenches) {\n                    bot.attack(other);\n                }\n                return;\n            }\n        }\n\nEdit2: Also getting the error: \n\n    NetworkError: Failed to load worker script at \"http://www.machinegame.com/js/lib/ace/worker-javascript.js\"\n\nNot sure if that's related", "id": "dalwuo4"}], [{"comment": "This sounds interesting, I will look into this!", "id": "dakpyze"}], [{"comment": "I love it! Like a grown up Scratch. I will be wasting a couple hours now.", "id": "dakqwp8"}, {"comment": "I wasted four hours on this. So beware.", "id": "dapc208"}], [{"comment": "Very interesting. I'd like code to be saveable cross-computers though.", "id": "dakthgd"}], [{"comment": "> Your code did not compile, check the logs (F12)\n\nNothing in the console. No feedback on what worked or what didn't. But now the code isn't saved, and I'll revert to a working version if I refresh. Not cool\u2026", "id": "daktzfr"}, {"comment": "I had the same problem and it seemed to be fixed by adding a newline at the end of my code.", "id": "dalhw6t"}], [{"comment": "Period save would be nice, hit back by accident and lost my code (kek)", "id": "dal71qb"}], [{"comment": "This is great. I've played around with a few ideas of programming a bot as a game but struggled to have it actually be fun. I'm on mobile now but can't wait to try this on desktop!", "id": "dalgfbw"}], [{"comment": "Where did you buy this domain from?", "id": "dalhfc8"}, {"comment": "Someone's been surfing the way back machine, eh?", "id": "daltag6"}], [{"comment": "This this is really fun. Also, it's getting me to mess around with javascript which I generally consider \"icky\", but now I can appreciate some things about it. Thank you.", "id": "dalqc3u"}], [{"comment": "I had a very similar idea. But I didnt know how to do It. ", "id": "dalqzgu"}], [{"comment": "It's pretty frustrating that the API is so awkward and not completely listed in one place. Why does each action eat your turn even if it doesn't do anything? For example, bot.collect() should return true if wrench was collected and consume your turn, otherwise return false and allow you to make another action call. I have to write a loop just to determine if I should make a .collect() call, which is totally pointless and obnoxious. Also I had to read the comments here to figure out that I needed to press the save button in order for any code to run. I'd expect whatever I'm writing to execute immediately whenever there are no syntax errors.", "id": "dalriia"}, {"comment": "I think that would ruin part of the strategy. Also wrenches are in different orders sometimes in the list so you have to check what rench is closest to the bot and go to that. Just doing it randomly resulted in all my bots being stuck and repeapting the same steps ", "id": "dalxexb"}, {"comment": "How does requiring writing the exact same loop for every bot ruin part of the strategy? When you're on top of a wrench, you always want to collect.", "id": "dam2p4z"}, {"comment": "It seems that is part of the game. You get a list of bots, wrenches, others and castles. So far from what I can tell the wrenches don't always come in the same order. You'd have to loop through them all anyway for each bot to figure out which one is closest or store which ever wrench your bot was going to in order to keep going towards that wrench. If you don't than how can you be sure that you are going to the same wrench each time it loops? Adding that feature I don't think would really solve anything. ", "id": "damob5e"}, {"comment": "That's not the model the game uses. \n\nWhen you do a bot.collect, you're _planning_ to have that bot collect at its current location.  You're not having the bot immediately collect.  \n\nOnce the function ends, it sends your plan back to the server. The server then executes everyone's plans in recieved order.  Then it advances the tick and sends you the updated world state.\n\nSo it _can't_ tell you if bot.collect worked,  because it hasn't happened yet. ", "id": "dammm0x"}, {"comment": "Ah OK, an actual description of the model would be very helpful along with the full API.", "id": "dan74pz"}], [{"comment": "Pretty fun.  I noticed when I try to store data in a bot in an arbitrary property, it gets cleared out between steps.  I don't know much about Javascript, but this makes me wonder if I can reliably track bots, wrenches, or castles by reference, or if I'd have to store the id and iterate each list every step.\n\nedit:\n\nYep, looks like the all the objects are recycled every step:\n\n    let prevbot;\n    function play(state) {\n        if (prevbot !== undefined) {\n            console.log(\"IDs equal: \" + (prevbot.id === state.bots[0].id))\n            console.log(\"References equal: \" + (prevbot === state.bots[0]))\n        }\n        prevbot = state.bots[0];\n        console.log(\"preset dump: \" + JSON.stringify(state.bots[0]))\n        state.bots[0].foo = 'bar';\n        console.log(\"postset dump: \" + JSON.stringify(state.bots[0]))\n    }\n\nResults in the following output:\n\nRun 1:\n\n    preset dump: {\"id\":2,\"x\":0,\"y\":0,\"wrenches\":1}\n    postset dump: {\"id\":2,\"x\":0,\"y\":0,\"wrenches\":1,\"foo\":\"bar\"}\n\nRun 2:\n\n    IDs equal: true\n    References equal: false\n    preset dump: {\"id\":2,\"x\":0,\"y\":0,\"wrenches\":1}\n    postset dump: {\"id\":2,\"x\":0,\"y\":0,\"wrenches\":1,\"foo\":\"bar\"}\n\nThis wouldn't be an issue if the arrays were instead objects indexed by the ID, otherwise we have no way to keep track of bots, or especially to be able to determine whether one has died (this can be especially useful for giving bots different behavior, or assigning a \"class\" to a bot at birth.  I was attempting to designate bots to jobs, having harvest/building bots, combat bots, and conquering bots for taking castles, but the lack of persistence ended up making it difficult).  The current way appears to be keeping our own objects and building maps with each step, and storing state data in some global objects instead of trying to work with the bots directly.", "id": "dalrt0a"}], [{"comment": "Sometimes in the multiplayer mode all my bots simply freeze :/ Mostly happens when I have 200+ bots and make a code-change. I can still see other players bots move and attack so its not that I've lost connection or something.", "id": "daluiis"}, {"comment": "Check your browser's javascript console. Usually when that happens to me it's because I made a typo in the code.", "id": "dalutcw"}], [{"comment": "I was trying to use a foreach loop for quite a while until I realized that it doesn't seem to work with your pipeline.", "id": "dalvszq"}], [{"comment": "[You will be assimilated](http://i.imgur.com/EhUIx6B.png)\n\nEdit: It feels so good to destroy an army of 200 bots in a single turn\n\nEdit 2: [Poor guy...](http://i.imgur.com/NttgrEL.png)", "id": "dam4km1"}], [{"comment": "For everyone like me - You MUST use the save button for your code to be executed \n\nInitially i thought i could just save my code to a file with this button", "id": "dam8ytq"}], [{"comment": "/u/luiii \nthe game really needs a way to change the amount of ticks that go by in singleplayer. makes it so, *so* difficult to go at a reasonable pace without having to spam click \"next frame\".\n\ntrying to figure out why my units don't seem to be attacking, but more often than not when I find enemies, I die before I can pause. shit, some sort of development corner would be great, where you could drag and drop enemy units, castles, wrenches, ect onto the grid.\n\nedit: even a simple \"pause when enemy appears\" checkbox would be **great**", "id": "damfz10"}, {"comment": "Yes, some way to create your own scenarios for testing your code would be really helpful. Currently I mostly manually enable/disable logging in different parts to debug certain decisions without the console being completely filled with 200 bot messages.", "id": "damgwoh"}], [{"comment": "a new addiction, greaatttt, thanks brooooooo", "id": "damxhxk"}], [{"comment": "This is way more fun than I expected. I spent a few hours last night refining my script, and was on top until Windows automatically updated and restarted. I have noticed a couple times where all my bots will suddenly stop moving until I recompile the script (without any error messages in the console). Also it would be nice if it was easier to tell the difference between 10 bots stacked on top of each other and 100, the text blends in with the bot after 100 are stacked. Great work!", "id": "damy4nn"}], [{"comment": "Fun little game. I'll try giving it a run during primetime instead of at night.\n\nhttp://i.imgur.com/qit9UVq.png", "id": "danbdpb"}], [{"comment": "Damn, one little typo and my whole army has been exterminated while on its way to world domination.", "id": "danjq9b"}], [{"comment": "When storing state in globals I'm finding they aren't cleared by resetting the game, only by reloading the page. If you can't automatically clear them, maybe we could get an init function that's only called at the start of the run. It might also be nice to have access to the current tick number.\n\nSeems to work pretty well on Chrome for Android on a tablet with a keyboard, the biggest isssue I'm facing is a lack of debugging tools. It would be great if you could display syntax errors when saving, and also show any console.out messages.\n\nLastly, it would be nice if you could drag the divider between the code and map panes.", "id": "daok2q1"}, {"comment": "You can drag the three lines button at the top between code and map.", "id": "daphshb"}], [{"comment": "Blocked at work... Lol", "id": "dakrta0"}], [{"comment": "reminds me of codingame.com\n", "id": "daktmnn"}], [{"comment": "Does it actually execute the code to test it? \n\nInjection attack in 3... 2... 1...", "id": "dam51ue"}], [{"comment": "Judging from looking at it for 5 secs its basically the game I once imagined. Good, so I don't have to write it (which wouldn't have happened anyway).", "id": "dal5vnk"}, {"comment": "Downvoted for saying what everybody's thinking.", "id": "damqvh2"}, {"comment": "A truly amazing reason for down voting.", "id": "damv306"}]]], "5fqh3r": ["OCP vs YAGNI", "2016-11-30 19:21:30", 0, "http://enterprisecraftsmanship.com/2016/11/28/ocp-vs-yagni/", [[1, "Why does the YAGNI version add all sorts of code that you don't need, like the `ShapeType` enum and the switch statement? Both have the same extension point, the `Shape` class, it's just that the \"OCP\" version calls that out better.\n\nOne thing most discussions of OCP fail to bring up is that it is often best to completely close a class from extension via inheritance so that all extension occurs through composition. If that were the case, the switch might be better. But this example already uses a `Shape` \"base\" class, so it is just over-complicating things by not allowing sub shapes to specify how they differ in their geometry. (the \"YAGNI\" version of `Shape` is never shown, so it is unclear how it stores all the data it needs for representing different shapes. A giant union perhaps?)\n\nAn alternative would be that `Shape` disallows deriving and instead specifies a geometry path: the line segments, points, curves, etc that make up the shape. Now it is no longer limited to Circle and Triangle and whatever your enum contains, but truly represents any shape."]], [[{"comment": "Why does the YAGNI version add all sorts of code that you don't need, like the `ShapeType` enum and the switch statement? Both have the same extension point, the `Shape` class, it's just that the \"OCP\" version calls that out better.\n\nOne thing most discussions of OCP fail to bring up is that it is often best to completely close a class from extension via inheritance so that all extension occurs through composition. If that were the case, the switch might be better. But this example already uses a `Shape` \"base\" class, so it is just over-complicating things by not allowing sub shapes to specify how they differ in their geometry. (the \"YAGNI\" version of `Shape` is never shown, so it is unclear how it stores all the data it needs for representing different shapes. A giant union perhaps?)\n\nAn alternative would be that `Shape` disallows deriving and instead specifies a geometry path: the line segments, points, curves, etc that make up the shape. Now it is no longer limited to Circle and Triangle and whatever your enum contains, but truly represents any shape.", "id": "dambi0y"}]]], "5frioe": ["Developer Preview -\u0080\u0093 EC2 Instances (F1) with Programmable Hardware", "2016-11-30 22:16:50", 20, "https://aws.amazon.com/blogs/aws/developer-preview-ec2-instances-f1-with-programmable-hardware/", [[3, "Ok thats just cool...."]], [[{"comment": "Ok thats just cool....", "id": "damoqza"}]]], "5fggs5": ["Writing C without the standard library - Linux Edition", "2016-11-29 06:54:24", 857, "http://weeb.ddns.net/0/programming/c_without_standard_library_linux.txt", [[315, "Writing C without the standard library by reimplementing the standard library.\n\nEdit: Just to be clear, my comment is not to be seen as negative. I think this post has value in understanding the magic and great service provided by the standard library, as well as delving into the more intricate details of the platform architecture.\n"], [53, "Answer: use psudoassembly and hook syscalls. Oh and if you are on i386 - it's going to be somewhat different. :)"], [39, "This is very insightful. Thanks for posting it."], [25, "Wouldn't you rather just use a standard library meant for embedded use cases, if you needed something small?\n\nI haven't done much embedded work but all my binaries built with avr-gcc and avr-libc have been very small."], [23, "is it just me or is some formatting maybe indeed useful for reading and comprehension?"], [25, "> Why would you want to avoid libc?\n\n> - Your code will have no dependencies other than the compiler.\n\nGiven that the compiler usually comes with the standard libs, this seems moot.\n\n> - Not including the massive header files and not linking the\n  standard library makes compilation faster. It will be nearly\n  instantaneous even for thousands of lines of code.\n\nEven large code compiles pretty dang fast these days, unless you're doing something really large, in which case you're not really saving much time by doing this. Probably wasting plenty of extra time doing it all without the standard libs. So moot at best, but really it's just untrue.\n\n> - Executables are incredibly small (the http mirror server for my\n  gopherspace is powered by a 10kb executable).\n\nI'm unclear on why exactly you would want this, with the exception of the following point:\n\n> - Easy to optimize for embedded computers that have very limited\n  resources.\n\nDon't those sorts of things either come with appropriately compact standard libraries? And probably use entirely different calling conventions? Are there any ultra-compact x86 platforms where this is necessary? And isn't this all dependent on a whole linux kernel above it anyway?\n\n> - Easy to port to other architectures as long as they are\n  documented, without having to worry whether the libs you use\n  support it or not.\n\nI'd argue otherwise. C already ports just fine between most platforms, unless you're trying to bang 64 bit things into a 32 bit platform, or working with wacky 14 it DSP chips, but in that case the libraries are the least of your concern. This makes porting *harder* because you're using low level conventions for a single platform rather than using a high level standard interface to an appropriate standard library for each platform.\n\n> - Above all, it exposes the inner workings of the OS, architecture\n  and libc, which teaches you a lot and makes you more aware of\n  what you're doing even when using high level libraries.\n\n> - It's a fun challenge!\n\nI'll agree with these points, but nothing else. I really don't think there's any practical advantages to working this way, just the novelty and educational value."], [16, "Yeah, let's build a house, but without premade bricks."], [13, "Minimal example:\n\n    #define syscall(a, D, S, d) __asm__ __volatile__(\"syscall\" : : \"a\"(a), \"D\"(D), \"S\"(S), \"d\"(d))\n\n    void _start(void)\n    {\n            syscall(1, 1, \"hello\\n\", 6);\n            syscall(60, 0, 0, 0);\n    }\n\n\nCompile with `-nostdlib`."], [9, "This is actually rather nice to get to know how things work (especially calling conventions and how thr stdlib works).\n\nAlso: Couldn't you optimize the amd64 syscall wrapper to deduplicate the various argument arities into one function?\n\n    syscall5:\n        mov r8,r9\n    syscall4:\n        mov r10,r8\n    syscall3:\n        mov rdx,rcx\n    syscall2:\n        mov rsi,rdx\n    syscall1:\n        mov rdi,rsi\n    syscall0:\n        mov rax,rdi\n        syscall\n        ret\n\ni.e. having the pointers for the lower arities point into the middle of the syscall5 function, and ordering the movs so that it moves the higher arguments first.\nBecause labels are just another entry in the symbol table, aren't they?"], [6, "Interesting read!"], [6, "wow, an interesting article with code and about programming at the top of /r/programming. that's not every month."], [4, "Why not just write assembly? I find it more easy than weird C"], [3, "The server is getting hit pretty hard right now, did not expect this much traffic. In the meantime, you can find a bbcode mirror of the guide here: https://ccplz.net/threads/writing-c-software-without-the-standard-library-linux-edition.69623/\n\nEDIT: should be fine now, I shut down some memory hungry golang application I had running on my vps. tfw 128mb ram"], [1, "Is anyone else completely unable to load this page? Android, Chrome, ERR_CONTENT_DECODING_FAILED\n\nThe URL indicates that it's a plaintext document, so something seems fucky."], [1, "Could have sworn I've seen this done with the context of making the smallest executable possible, but I can't find it now (as in, this article was just a rip off of that with a little polishing to make it different).\n\n\nBut similar stuff I found while searching:  \nhttps://www.microsoft.com/msj/archive/S569.aspx  \nhttp://www.catch22.net/tuts/reducing-executable-size  \nhttp://www.mvps.org/user32/nocrt.html  \n\n\n\nEDIT:  \nI'm wagering this was the article that I was thinking of  \nhttp://www.muppetlabs.com/~breadbox/software/tiny/teensy.html\n"], [1, "I attempted to curl | less this page and was very disappointed. <_<"], [1, "C has a standard library!??!\n"]], [[{"comment": "Writing C without the standard library by reimplementing the standard library.\n\nEdit: Just to be clear, my comment is not to be seen as negative. I think this post has value in understanding the magic and great service provided by the standard library, as well as delving into the more intricate details of the platform architecture.\n", "id": "dakbleq"}, {"comment": "Write your web app without jQuery by reimplementing jQuery one browser wart bug at a time.", "id": "dakbpv9"}, {"comment": "Avoiding bloat always seems like a good idea at first, you'll just write a couple of functions to avoid another unnecessary dependency in the project.\n\nAfter a few weeks, you'll be on the issue tracker of that library you avoided, checking how they fixed one of the bazillion edge cases you keep running into.\n\nWith tree-shaking and so many small libs with good test coverage and widespread production use, I pretty much feel the less code I have in my codebase, the more likely the application will work as expected.", "id": "dakchin"}, {"comment": "The only way to avoid bloat in js is to avoid js.", "id": "dakdm25"}, {"comment": "Filthy casuals, just ctrl+c ctrl+v the useful parts like a real professional.", "id": "dakebuy"}, {"comment": "Directly from stackoverflow without reading the text around the code, time is precious!", "id": "dakgy7j"}, {"comment": "What, you mean you don't automate your SO import scraping?\n\nGotta get that [StackSort](https://xkcd.com/1185/) implemented properly...", "id": "dako6om"}, {"comment": "> the less code I have in my codebase, the more likely the application will work as expected\n\nprogramming: putting bugs into existing code", "id": "dakhq82"}, {"comment": "If I were to reimplement more than like 80% of the library's features and the codebase would be similarly large and not fun to write, I'd probably consider using the actual library.\n\nBut more often than not, your reimplementation is going to be a much smaller codebase. You have to consider that the library you're using adds its own codebase to yours, and that codebase also has a certain probability of bugs per LoC.", "id": "dakifiy"}, {"comment": "Jqlite", "id": "dake91z"}, {"comment": "if you don\u2019t need to support old browsers, not using jQuery is also a pretty nice experience.\n\nexcept for creating and populating elements. wtf, DOM? something like [this](https://github.com/Matt-Esch/virtual-dom#example) would be better:\n\n    h('tagname', { attr: value }, [child])", "id": "dakc7t7"}, {"comment": "The entire DOM API is terrible.", "id": "dake385"}, {"comment": "`style`, `classList`, `querySelector`, quite some of the properties and so on are reasonably nice.", "id": "dakelcr"}, {"comment": "It should be noted that the last two were pretty significantly inspired by jQuery.", "id": "dakfnpm"}, {"comment": "I don't know why you're getting downvotes, you're absolutely correct. jQuery had popularized the functionality provided by classList and querySelector years before they were standardized and implemented natively.\n\nWait, I *do* actually know why you're getting downvoted. It's because it's a meme on /r/programming to hate jQuery and people are clueless.", "id": "dakiwma"}, {"comment": "(s)he isn't downvoted anymore.\n\nAnd you're both right of course: the main reason for using jQuery was selecting, modifying, and adding DOM elements, and doing this, as well as some cross-browser utility functions (xhr, forEach), in a maximally compatible way.\n\nToday, most people can do that subset of its functionality easily with built-in standards-compliant methods. (Except for creating and adding elements, which is still ugly)\n\n`fetch` is nice though.", "id": "dakm0uz"}, {"comment": "Technically the main reason for using jQuery was patching over the most egregious cross-browser bugs and incompatibilities. \n\nThe second reason (not far behind) was getting a set of APIs which didn't want you to stab your eyes out with rusty forks. And as you note the nice fluent DOM APIs (including all the events delegation stuff) are still nowhere near the actual standard DOM, though I guess you can get it via a lightweight implementation of the API which just assumes implementations are correct e.g. [Zepto](http://zeptojs.com).\n\nThe third one was various shortcuts for animations, selection and the like, and some object-related API (e.g. the Array-based utility functions)", "id": "dakttcs"}, {"comment": "Can you explain why? I don't have much experience with it, but I've read the Mozilla DOM API docs and it doesn't seem as bad as I always hear it is.", "id": "dakfmmw"}, {"comment": "It really isn't, it can be quite verbose and you certainly wouldn't want to write a whole application with nothing but `document.createElement` (that's where WebComponents come in), but it's a reasonably pleasant and performant API for messing with the DOM*.\n\n*^(assuming you don't need to support a handful of ancient versions of IE)\n\nSorry, this is /r/programming - JavaScript is horrible, the DOM is horrible, there are no redeeming factors, I award you no points, may god have mercy on your soul.", "id": "dakharh"}, {"comment": "It's very verbose, e.g.:\n\n    // create element\n    // DOM\n    var element = document.createElement('a');\n    element.href = 'http://example.com/';\n    element.target = '_blank';\n    element.appendChild(document.createTextNode('example.com'));\n    document.body.appendChild(element);\n    // jQuery\n    $('<a>', {href: 'http://example.com/', target: '_blank'}).\n        text('example.com').\n        appendTo(document.body);\n\n    // remove element\n    // DOM\n    if (element.parentNode) {\n        element.parentNode.removeChild(element);\n    }\n    // jQuery\n    $(element).remove();\n\n    // insert element as first child\n    // DOM\n    if (parentElement.firstChild) {\n        parentElement.insertBefore(newElement, parentElement.firstChild);\n    } else {\n        parentElement.appendChild(newElement);\n    }\n    // jQuery\n    $(parentElement).prepend(newElement);\n\netc.", "id": "dakrmbg"}, {"comment": "Your insert element as first child is overly complex.  insertBefore will work the same as appendChild if the sibling is null or undefined.\n\n    parentElement.insertBefore(newElement, parentElement.firstChild);\n\nworks in all cases.", "id": "dal9vg1"}, {"comment": "Ah, good to know.", "id": "dalb7f9"}, {"comment": "It's not but it gives redditors something to do. Keeps them off the streets.", "id": "dal22mb"}, {"comment": "It's not even old browsers. \n\nJust earlier this year someone was posting on proggit about their success moving away from the \"bloat\" of jQuery for some specific methods. You go to the jQuery source and what do you see in those methods? \n\nThe \"bloat\" is fixes for rendering bugs on Safari and some array bounds checking and some other various corner cases I can't remember. \n\nWent to their issue tracker and what did you see? \n\nLot of issues with broken slider components on Safari and the upstream project still on jQuery doesn't have the issue. \n\nAnd of course you check their code and they've just copy pasta'd the top StackOverflow. \n\nHrmmm.. wonder what that could have been. ", "id": "dakn2ew"}, {"comment": ">proggit \n\nI got all excited thinking there was another programming content site like reddit/hn. Googled it and ended up back here. lol.", "id": "dakygxk"}, {"comment": "It's a name from the days when programming.reddit.com was the programming subreddit (before anyone could make subreddits)", "id": "dal9yc2"}, {"comment": "The bloat is pulling in the whole library just for those methods.", "id": "dal40k3"}, {"comment": "CDNs are wonderful things.", "id": "dalocbp"}, {"comment": "Not always possible or desirable (intranets) and still wastes time compiling.", "id": "dalowg8"}, {"comment": "On an intranet you aren't even going to notice the 83kb of minified jQuery. ", "id": "dalrful"}, {"comment": "Intranet isn't always in the same building, or even the same continent.\n\nYou're also assuming that it's just jquery and you aren't doing the same thing with a dozen other libs. That 83k adds up.", "id": "dalrpc9"}, {"comment": "Something like that is sometimes referred to as _hyperscript_ There's a react-hyperscript, for example, for people that don't want XML markup in their js for some reason. ", "id": "dal2m9x"}, {"comment": "Or not implementing the 99% of it that you don't need.", "id": "dal6b1l"}, {"comment": "I think the best use-case for this is embedded systems; from my experience when you have limited ROM available (like 8-16KB) every byte matters so you tend to write more ASM because the code doesn't need to be portable.", "id": "dakd8us"}, {"comment": "This happens regularly. E.g. in bootloaders like uboot (or the better, but not so well-known barebox) you write in C without a standard C library.", "id": "dake7cz"}, {"comment": "I'm afraid to Google \"barebox\" at work.", "id": "dakj7r5"}, {"comment": "> barebox\n\nIt's safe. I volunteered to Google it for ya.", "id": "dakl3sg"}, {"comment": "You put your grain of sand to make this world better.", "id": "dako0ja"}, {"comment": "> every byte matters so you tend to write more ASM because the code doesn't need to be portable.\n\nMy day job is embedded systems, and `-Os` does a damn good job these days. The main reason I've needed to reach for assembly on recent projects is to do hardware-specific things, e.g., enable or disable interrupts.", "id": "dakluem"}, {"comment": "Thank you. Considering modern linkers are pretty good at extracting only the necessary lib functions, purposefully working around them and rewriting equivalent logic is self-defeating.", "id": "daljbci"}, {"comment": "Or [demoscene coding](http://www.pouet.net/prod.php?which=27647).", "id": "dakhnwy"}, {"comment": "i dont understand the demoscene", "id": "daphdkb"}, {"comment": "It all started with home computers ([C64](https://en.wikipedia.org/wiki/Commodore_64), [Atari](https://en.wikipedia.org/wiki/Atari_8-bit_family), [Amiga](https://en.wikipedia.org/wiki/Amiga) etc). People would copy games (usually stored on floppy disks), game developers would add copy protections, some people would break them and add small \"intros\" to the game to announce themselves. Over time these intros would become fully-fledged freeware programs (\"demos\") that were shared independently of any games.\n\nToday there are several categories in which demos are entered in competitions: [demo](http://www.pouet.net/prod.php?which=63), size contests ([256b](http://www.pouet.net/prod.php?which=3397), [4k](http://www.pouet.net/prod.php?which=1221) etc) and others.", "id": "dapipfi"}, {"comment": "But these smal executables link against bigger libraries? Or is it magic?\n\nTo me, it seems like hacker wizards with knowledge of dark magic not taught at any uni in the world.", "id": "dapiywg"}, {"comment": "DOS demos use only very little OS/BIOS/VGA functions; they mostly \"rule the computer\" by themselves.\n\nWindows demos have to use DirectX/OpenGL to access the graphics hardware to create a hardware-accelerated window, but there are many demos that afterwards only use [software rendering](http://www.pouet.net/prod.php?which=5). They also need to access the audio hardware somehow.\n\n[Here](https://github.com/anttihirvonen/demoscene-starter-kits/tree/master/windows)'s some software to get you started, maybe you'll code something like [this](http://www.theverge.com/2012/5/14/3014698/assembly-4k-demoscene-fractals) (or [these](http://www.pouet.net/groups.php?which=1317&order=thumbup)) some day :)\n\nEDIT: [compo](https://www.youtube.com/watch?v=fATsm_k_d0I)", "id": "dapl6ku"}, {"comment": "To be fair, micro-controllers generally don't want you to put Linux on them. Generally you upload a binary blob to their ROM and on power-up the microcontroller will jump to a predefined address in your binary blob and let the CPU do whatever is there.", "id": "dakji9b"}, {"comment": "What about that prevents or hinders you booting Linux?", "id": "dalhzbz"}, {"comment": "[Here's](http://dmitry.gr/index.php?r=05.Projects&proj=07.%20Linux%20on%208bit) a good write up for it. The guy did put linux on the same architrcture microcontroller as Adruino, but Adruino itself doesnt have enoigh RAM to keep the whole linux kernel in its memory.", "id": "dalvzhr"}, {"comment": "Nothing, it is just a lot of work for little gain.", "id": "dalqu2z"}, {"comment": "yep, 4KB to 16KB flash a person has to continually consider the size of every bit of code you use on very cheap microcontrollers.  32KB is a more reasonable minimum flash size, but still it's not enough flash to be wasteful.  As the flash size increases, I worry less and less when I use large standard library functions.\n", "id": "dalwopm"}, {"comment": "... by reimplementing the standard library **in an insecure way**.\n\nDevelopers who feel this is a good idea should stay far away from the software I use. Something like this wouldn't fly for a second in a security conscious project (eg, OpenBSD).", "id": "dakcvtz"}, {"comment": ">Developers who feel this is a good idea should stay far away from ~~the software I use.~~ writing software.\n\nFTFY. It's rarely a good idea to reinvent the wheel in software development. Especially without studying existing \"wheels\" and understanding why they made certain decisions.\n\nSecurity doesn't even need to enter into it.\n\nHowever, often the best way to understand why decisions were made is to attempt to do it yourself - not to publish in production software - purely as an exercise, which I believe is the purpose of the OP.", "id": "dakdmti"}, {"comment": "I think that it is good to reinvent wheel. Unless you expect others to use it. \n\nIf its just for you to learn how the wheel works and to better understand whats under the hood you can reinvent all the wheels you like. \n\nJust don't force your misshapen wheels down other peoples throats. ", "id": "dake5ej"}, {"comment": "spoken like a true poet", "id": "dakgc1r"}, {"comment": "Especially when that wheel is 40 years old--ancient tech, and definitely time tested.", "id": "dakdtu1"}, {"comment": "> ... by reimplementing the standard library in an insecure way.\n\nStandard C library is hardly a paragon of secure design.  \nAnd for that matter, musl is a re-implementation of the standard library.", "id": "daki9a0"}, {"comment": "How is it insecure?  \n\nTechniques like this are used in embedded software all the time.", "id": "dakgtns"}, {"comment": "It's not guaranteed to be insecure; in fact if your programmer is godlike it might even be more secure! But in reality....  one single programmer usually produces worse code than an entire community. The stdlib has had a lot more eyes on it. \n\nJust look at all the problems with OpenSSL.......", "id": "daki54e"}, {"comment": "It's not also not like embedded software is particularly known for security, either.", "id": "dalqwlm"}, {"comment": "Reimplementing the parts we need with the level of complexity we need ;)", "id": "dakesw8"}, {"comment": "I think this is a very useful thing to know, especially for embedded system development.\n\nAs a potentially easier alternative, is there a way to static link just the stdlib functions you actually use (like _start)?\n\nI remember playing with a static standard library back when I used Linux From Scratch as my production system, but I don't recall checking to see if individual functions would be static linked, or if the compiler would bring in the entire lib.", "id": "daksvzu"}, {"comment": "I am actually working on a fully statically linked Linux From Scratch install using musl libc. It's very possible and it's really awesome.", "id": "dakusz6"}, {"comment": "> As a potentially easier alternative, is there a way to static link just the stdlib functions you actually use \n\nYes. Static linking already does it, although at the level of .o files instead of functions. Since most libc implementations only put one or two functions into each source file, it's s a decent approximation.", "id": "dakuxrx"}, {"comment": "Fun fact: It's not possible to efficiently implement `memmove()` in\nstraight C. This is because it's not legal for the function to compare\nits pointer arguments with anything other than `==`/`!=` since they could\ncome from separate allocations. For efficiency it needs to do this so\nthat it knows how to perform the copy (front-to-back, back-to-front).\n\nA possible work around is to allocate a temporary buffer and use it as\nan intermediate space for copying. However, allocating memory can fail\nand `memmove()` is not permitted to fail. It's also inefficient.\n\nFor a time I thought it was completely impossible until someone\npointed out another workaround. Since this is undefined behavior:\n\n    void *memmove(void *dest, const void *src, size_t n) {\n        if (dest < src) {  // illegal comparison\n            // ...\n        }\n        // ...\n    }\n\nInstead use a loop to compare one byte at a time:\n\n    for (char *p = dest + 1; p < dest + n; p++) {\n        if (p == src) {\n            // result: overlap, with dest < src\n        }\n    }\n\n*In theory* the compiler could turn this into the intended straight\npointer comparison, but I've never seen this happen.\n\nAnother problem is that when using libc, the compiler knows the\nsemantics of functions like `memmove()`, `memcpy()`, and `memset()`.\nThis also includes some math functions like `sqrt()`. Often it will\ncompletely eliminate calls to these functions and emit the proper code\nto directly. When building a freestanding program, the compiler can't\nmake these assumptions and optimization opportunities are missed.\n", "id": "dako3bq"}, {"comment": "    void *memmove(void *dest, const void *src, size_t n) {\n        if ((uintptr_t)dest < (uintptr_t)src) {", "id": "dakt1pw"}, {"comment": "That will generally work on more sensible architectures with a flat address model, but there aren't any guarantees about the representation of the pointer in the `uintptr_t` or that operations on the integer correspond to operations on the pointer, especially in the face of segmented memory or [other creative pointer implementations](https://www.usenix.org/legacy/event/sec09/tech/full_papers/akritidis.pdf). The comparison isn't undefined behavior, but it's still not guaranteed to be meaningful.", "id": "daku2f1"}, {"comment": "It doesn't really matter actually.  For memmove, the comparison only has meaning if the pointers are aliased, in which case the comparison is guaranteed to work.", "id": "dalalzw"}, {"comment": "Is `++` guaranteed to go in the same direction for `uintprt_t` and `char*`?\n\nEDIT: After a casual lecture of the standard: No, there is no such guarantee. If you have two pointers and `p < q`, then it's possible that `(uintptr_t)p < (uintptr_t)q` or `(uintptr_t)p > (uintptr_t)q`, or even both in the same program. The only requirement about `uintptr_t` conversion is that it's reversible. \n\nSo you can have `(uintptr_t)p == 1`, `(uintptr_t)(p+1) == 7`, `(uintptr_t)(p+2) == 5` and it is fine according to the standard.", "id": "dalneju"}, {"comment": "> Writing C without the standard library by reimplementing the standard library.\n\nYes. Except you're free to deviate from the standard library interface, and avoid some of its warts.\n\nFor those interested, I've been working for quite some time in a similar direction:\n\nhttps://github.com/arsv/sninit (conventional libc, syscalls in assembly, solid)  \nhttps://github.com/arsv/minitools (non-conventional base library, early stage)\n\nAssuming Linux host, musl and/or dietlibc are also highly recommended.  \nStrange the author did not mention them. Especially syscall implementation in musl.", "id": "dakihlw"}, {"comment": "Writing C without the standard library by writing assembly code in C.", "id": "dakir22"}, {"comment": "Solution: just use assembly?", "id": "dal3bju"}, {"comment": " ", "id": "dakgzf5"}], [{"comment": "Answer: use psudoassembly and hook syscalls. Oh and if you are on i386 - it's going to be somewhat different. :)", "id": "dak8p3v"}, {"comment": "And yet the author says \"Easy to port to other architectures.\"  Yeah right!", "id": "dakaw1o"}, {"comment": "to start with, `long` on Win64 is 32 bits wide, so\n\n    typedef long int intptr; /* ssize_t */\n\nis wrong.", "id": "dakbc5o"}, {"comment": "Architectures not OS. On most OS (including unices) raw syscalls are not supported in the first place, and the system's standard library is how you perform them.", "id": "dakc0l1"}, {"comment": "It's also surprising how few system calls you actually *need* in order to implement a more or less fully functional standard library.", "id": "dakco79"}, {"comment": "\"the system's standard library\"? how can a standard library execute syscalls not available to raw assembly executables?", "id": "dakcfdl"}, {"comment": "The systems in question also require dynamically linking the system libraries.\n\nWhat happens is that, although you *can* manually implement the system calls in assembly, the OS will ship updates. And these updates will add and remove system calls to fit the needs of the system libraries, and change around the system call numbers. The system library will be updated with these new system call numbers, but your hand crafted assembly won't be, and your binaries will break.\n\nSolaris and Windows are the two OSes I'm aware of that do this.", "id": "dakcmao"}, {"comment": "> And these updates will add and remove system calls to fit the needs of the system libraries, and change around the system call numbers.\n\nOr change the signature of specific syscalls.\n\n> Solaris and Windows are the two OSes I'm aware of that do this.\n\nOSX as well, you can't statically link libSystem (and thus libc which is a symlink) for that reason.", "id": "dakcofs"}, {"comment": "In practice, the system calls and their numbers are stable on OSX, because they're exposed to the user via syscall.h. So, a number of langauges like Go invoke them directly. Same with my pet project.", "id": "dakcrxb"}, {"comment": "Exactly. That's why Go broke with the Sierra update for OSX IIRC.", "id": "dake0tg"}, {"comment": "> how can a standard library execute syscalls not available to raw assembly executables?\n\nThe syscalls is available to assembly but there is no guarantee that assembly-level syscalls are stable even between minor versions, only performing syscall through the dynamically-linked standard library (libc/win32/libSystem/\u2026) is supported as that library will be updated alongside the system itself.", "id": "dakcpur"}, {"comment": "Linus: we do not break userspace.", "id": "dakjux5"}, {"comment": "That's on Linus and that's why you can use raw syscalls on Linux.\n\nIf you do that on any other system, \"fuck you and the horse you rode in on\", any breakage is on you, all other systems pretty extensively tell you to *not* make raw syscalls and that the libc is the API.\n\nIn fact, that exact scenario happened for Go in the runup to 10.12 as they handroll syscalls and Apple changed the ABI of gettimeofday.", "id": "dakl6ab"}, {"comment": "The syscalls are instead meant to be an internal A(P/B)I, with the standard library providing the external API. For example, the Windows kernel syscall numbers are designed to be internal only, with ntdll.dll being the stable & supported API for standard/non-internal use. This allows the syscall numbers to change between versions without breaking software, since ntdll.dll just has to update its syscall translation and as long as ntdll.dll keeps its API non-breaking, all [software that uses ntdll.dll like it should] is fine and dandy.\n\nIn other words, the syscalls are not directly exposed and the syscall numbers are kept internal, and programs perform syscalls by instead calling the standard library's syscall API. The standard library then performs the appropriate syscalls itself, rather than making the programmer do it. Since the standard library and the OS are closely tied, the syscalls no longer need to remain stable and can then be modified without breaking code that uses them.\n\nSo the syscalls *are* available to raw assembly, but the syscalls are undocumented/unsupported/unstable to promote the programmer instead using the documented/supported/stable standard library, which performs the syscall on the programmer's behalf.", "id": "dakcu5j"}, {"comment": "yep I believe the way to do it on windows, for example, would be win32api, which is fine by me, since it's available on pretty much every windows version that's still used and can probably be used without the C runtime.", "id": "dakhfns"}, {"comment": "As you see later in the guide, platform-dependent types are moved to the platform-specific layer, so all you have to do is have documentation for the target architecture and make a platform specific layer for that arch with the types, syscalls and everything.\n\nOf course, in this guide I am only targeting 2 linux architectures so a lot of the code works on both, but if you were to target windows as well, or more linux archs you'd have to separate code further and have an extra layer that wraps the platform's syscalls into a generic API that's always the same, much like stdlib does.\n\nI'm only making it as portable as it needs to be. As I add new architectures, I make types portable for those as well.", "id": "dakhkze"}, {"comment": "Fun fact, I actually did this for real once. Search [here](http://git.savannah.gnu.org/cgit/smalltalk.git/tree/winewrapper.c) for `linux_spawnve`, there is also a comment at the top of the file explaining what it is used for.", "id": "dakb8yu"}], [{"comment": "This is very insightful. Thanks for posting it.", "id": "dak6x0c"}], [{"comment": "Wouldn't you rather just use a standard library meant for embedded use cases, if you needed something small?\n\nI haven't done much embedded work but all my binaries built with avr-gcc and avr-libc have been very small.", "id": "dakca9b"}, {"comment": "In production? Probably.\n\nBut it's still useful to know this. Especially since some very useful system calls aren't actually exposed by libc -- `futex`, for example, and you have to write your own system call for them.", "id": "dakck67"}, {"comment": ">Especially since some very useful system calls aren't actually exposed by libc\n\nyeah [`memfd_create`](http://man7.org/linux/man-pages/man2/memfd_create.2.html) is pretty awesome when you don't want to mount an entire `tmpfs` directory.\n\nThen you have [`getrandom`](http://man7.org/linux/man-pages/man2/getrandom.2.html) the correct way of getting randomness on Linux Systems. It handles the `/dev/urandom` vs `/dev/random` bullshit for you depending on system state.\n\nCopy data between files without loading them into userland memory? [`copy_file_range`](http://man7.org/linux/man-pages/man2/copy_file_range.2.html)\n\nLastly **FLAGS**. If you do systems works you eventually run into very awesome flags that are exported from `sys/linux/foobar.h` not your normal `sys/foobar.h` path. The easiest way to resolve this I find is writing my own syscall wrapper. ", "id": "daks3we"}, {"comment": "> since some very useful system calls aren't actually exposed by libc -- `futex`, for example\n\nIt's exposed by pthreads, and is the fundamental building block for any concurrency primitive that might need to wait until something happens. Unless this is a commentary on the sad state of the C11 thread support library, I'm not sure what you're getting at.\n\nAlso, [one does not simply use futex](http://dept-info.labri.u-bordeaux.fr/~denis/Enseignement/2008-IR/Articles/01-futex.pdf). (PDF)\nIf I see someone calling it by hand, I'm going to get _really_ suspicious. Even if half a dozen people review it, there's still a good chance we're doing it subtly wrong.", "id": "dakmb3t"}, {"comment": "Futexes are *not* exposed by pthreads. The futex system call is misnamed -- it's not a mutex. It's nothing more than an atomic `compare and sleep` call. It doesn't replace mutexes, although it can be a nice tool to build them. Still, it's far more general than that.\n\nDepending on the specific use cases, you can get pretty significant performance boosts by *not* using locks, and using futexes instead to provide sleep and wake functionality to avoid busylooping the CPU. Or as another example, are other times where you may want NUMA-aware locks, so you would find yourself doing something like cohort locks, in order to reduce cross-core contention. This has a cost, so it's not  suitable to implement generally in libpthreads, but is useful in some contexts, which means you need to roll your own outside of libc (or someone else does). \n\nBasically: Pthreads are good for a lot of stuff, and handles 95% of use cases. But there are a number of cases where you may want to do something a bit different.\n", "id": "dalb68a"}, {"comment": "I have a feeling we're talking past each other.\n\n>The futex system call is misnamed -- it's not a mutex. It's nothing more than an atomic compare and sleep call. It doesn't replace mutexes, although it can be a nice tool to build them.\n\nI'm aware - that's exactly what the paper I linked discusses, and pthreads uses them almost any time it wants to sleep a thread.\n\n> Depending on the specific use cases, you can get pretty significant performance boosts by not using locks, and using futexes instead to provide sleep and wake functionality to avoid busylooping the CPU.\n\nYep! In most cases, `pthread_mutex_lock` first attempts to take the lock using a few atomic operations, then falls back to a `futex` sleep if there's contention on the lock.", "id": "dalbrcx"}, {"comment": "Yep, but if you just try spinning, it's likely that your lock is probably going to be unfair. Most of the time, you don't care, but sometimes you really do. Other times, you may want thigns like MPMC queues that don't busy wait, and very little exposed from pthreads is going to help you -- at least, not without contortions.\n\nBasically, there are absolutely use cases for futexes to be called without pthreads. They're not too common, but saying \"You shouldn't be calling it ever\" is wrong.\n", "id": "dalck1w"}, {"comment": "Absolutely! I'm certainly not claiming that every single use for `futex` is covered by pthreads.", "id": "daldji7"}], [{"comment": "is it just me or is some formatting maybe indeed useful for reading and comprehension?", "id": "dakarz6"}, {"comment": "OP has old-school [opinions](http://weeb.ddns.net/0/articles/software_philosophy.txt) on formatting:\n\n> The UI should at the very least fit into a 800x600 display or\n  smaller", "id": "dakbtyo"}, {"comment": "And some *bizarrely* old-school [opinions](http://weeb.ddns.net/1/gopher) on the Web:\n\n> This structure makes it extremely easy and consistent to navigate, and because it's plaintext only, the services and content hosted on it do not rely on any graphical features, which makes it very lightweight to browse even on low-end machines.\n\nGraphical features? It would be a challenge to find a *cell phone* today that has trouble displaying graphics. I'm not even talking about smartphones -- even Jitterbug, which started out being [dumb on purpose so seniors didn't get confused](https://www.jitterbugdirect.com/images/jitterbug-flip-unfolded.jpg), is now selling [slightly-smart phones with graphical web browsers](https://www.greatcall.com/phones/jitterbug-smart-smartphone-for-seniors).\n\nIronically, the main thing that makes a website hard to read on a display like that is when it tries to keep formatting consistent, such as these pre-wrapped lines -- if I had a native Gopher client on my phone, it would still be trying to show me a UI (and text) designed to be viewed on much larger screens, or it would have to basically guess how to re-wrap that content. If this were a simple HTML page, all it would take is a bit of metadata to indicate that this works on mobile, too.\n\n> The plain text-ness also makes it nice and compact to read, unlike HTML layouts which are entirely up to the web designers.\n\nSometimes it's for the best that designers can actually design things.\n\nOther times, that's what greasemonkey and user-CSS and the like are for.\n\n> I personally think browsers should not be an entire OS, and anything more complicated than a static plain text page should be a dedicated app instead of a web app.\n\nI think this is someone who either underappreciates or outright doesn't realize what the Web gives us. As he points out, \"native\" is no guarantee that things will actually be fast, since many \"native\" apps are just web apps in a native-looking wrapper. But if you leave them in the Web, the Web gives you a ton of stuff for free:\n\n* Multiple tabs and windows\n* Bookmarks\n* Back/forward for navigation\n* The refresh button as a generic \"Reload everything and try again\".\n* Automatic updates, by default.\n* Sandboxing -- the app has to ask permission to do anything other than talk to the Internet.\n* Caching and prefetching by default\n* Basic encrypted communication, with the relevant root certificates already installed.\n* An API (via browser extensions or just Curl), whether you want to or not.\n\nI agree with the sentiment that we could do with more web *pages,* rather than web apps. But I think this guy doesn't appreciate just how useful web apps are. These days, many native app developers find themselves reimplementing many of the above features, especially the first few (tabs, bookmarks, and navigation) -- it's to the point where I don't think anyone should start a native app without having a very good answer to \"Why won't this work as a web app?\"", "id": "dakcmy1"}, {"comment": "I don't think you can say they are bizarre when you are reading them over a gopher page.", "id": "dakcwfz"}, {"comment": "> Back/forward for navigation\n\nFrequently broken entirely.\n\n> Automatic updates, by default.\n\nA terrible invention, it turns out.  Far too frequently I have come to a program I feel comfortable in, only to find that without warning it has changed or removed some feature I relied on.  The latest example that made me disable auto updates in every program I could was Chrome breaking backspace so I could no longer navigate.  Without warning and with no option for downgrading to an older, still supported, major release.  Automatic updates with anything other than purely security fixes should be banned.\n\n> Sandboxing -- the app has to ask permission to do anything other than talk to the Internet.\n\nOr now talk to USB, or any other features they decide are useful for reading text.\n\n> Basic encrypted communication, with the relevant root certificates already installed.\n\nIncluding many untrustworthy ones you've never heard of.\n\n> without having a very good answer to \"Why won't this work as a web app?\"\n\nThe answer to that is always: because some people have JS disabled, or are not running the latest browesr released 7 minutes ago.", "id": "dakd2cy"}, {"comment": "> > Back/forward for navigation\n\n> Frequently broken entirely.\n\nThat's the fault of the web site author, same as if a gopher author incorrectly formatted or escaped their content. (Check out OP's own [guide on beginning lines with \\* or \\# over gopher](http://weeb.ddns.net/1/gopher/escaping_special_chars).)\n\n> > Automatic updates, by default.\n\n> A terrible invention, it turns out. Far too frequently I have come to a program I feel comfortable in, only to find that without warning it has changed or removed some feature I relied on. The latest example that made me disable auto updates in every program I could was Chrome breaking backspace so I could no longer navigate. Without warning and with no option for downgrading to an older, still supported, major release. Automatic updates with anything other than purely security fixes should be banned.\n\nAlt+Left to go back. Backspace to delete text. (Does your gopher client natively support backspace to go back?)\n\nIf you still want the one-handed option, just add the [Backspace extension](https://chrome.google.com/webstore/detail/backspace-to-go-back/nlffgllnjjkheddehpolbanogdeaogbc?hl=en) (or [grab the source](https://github.com/oslego/chrome-backspace-back#from-source) if you prefer that).\n\n> > Sandboxing -- the app has to ask permission to do anything other than talk to the Internet.\n\n> Or now talk to USB, or any other features they decide are useful for reading text.\n\nWhat's your complaint here -- that these features are available, or that they require the user opting in to those permissions?\n\n> >without having a very good answer to \"Why won't this work as a web app?\"\n\n> The answer to that is always: because some people have JS disabled, or are not running the latest browesr released 7 minutes ago.\n\nSince the dawn of the Web we've had solutions for both of these problems.", "id": "dakd9du"}, {"comment": "I wasn't advocating for Gopher, just less \"interactive\" HTML.  You are right that all those points have fixes, but they aren't used - I can't even post to Reddit, a mostly textual website with an occassional textbox, without javascript despite having solutions since the dawn of the web.", "id": "dakddyc"}, {"comment": "That's a pretty serious failure on the Reddit devs IMHO.", "id": "dakkjb5"}, {"comment": "Because, and bear with me here, *POST requests in a web browser are implemented solely in the JS API*", "id": "dakfkjl"}, {"comment": "> Frequently broken entirely.\n\n> > Automatic updates, by default.\n\n> A terrible invention, it turns out.\n\nBy some measures, but the alternative is not updating, which just isn't an option anymore:\n\n> The latest example that made me disable auto updates in every program I could was Chrome breaking backspace so I could no longer navigate.\n\nChrome also ships security updates, though. So your choice here is to learn alt-left and alt-right (which have numerous advantages anyway), or open yourself up to a giant pile of vulnerabilities, not all of which can be avoided by disabling JavaScript.\n\n(In fact, *disabling backspace* is a huge advantage, because backspace depended on cursor focus -- if you went to a site that auto-focused on something, you couldn't backspace to go back, because the thing you were focused on would eat your backspace. But if you were typing a long Reddit post like this, and you accidentally lost focus and tried to backspace a thing, you'd go back and lose your work. There should've been a warning, but I'm pretty happy with this change.)\n\nSo when you complain about this:\n\n> Without warning and with no option for downgrading to an older, still supported, major release.\n\nThere should've been a warning, clearly, but there's no such thing as an older *still-supported* major release of Chrome. Because:\n\n> Automatic updates with anything other than purely security fixes should be banned.\n\nWhich means every month and a half, everyone using Chrome would have to *manually* go upgrade, or remain vulnerable, since Chrome doesn't ship purely-security-fixes for old versions.\n\nIf you're proposing that Chrome should support old versions... for how long? Six months? That would means every security patch must be backported four times, and everyone *still* has to manually upgrade every six months. But it almost doesn't matter what you answer here -- if Chrome *ever* abandons an old release without auto-updating everyone, a significant number of users will never upgrade, and the Internet will be a worse place for everyone.\n\nAnd the longer they wait till they abandon an old release, the more time and effort the Chrome devs have to spend supporting the ever-multiplying old releases instead of actually making the browser better, so the new releases suck more.\n\n*And* it's not just the Chrome devs -- *every* web developer would have to support all those ancient versions of browsers. I lived through the era of everything having to work on IE6 *and* IE7 *and* IE8 -- it wasn't pretty. These days, you can pretty much assume that if it works on the latest version of all the major browsers, it's going to work fine for almost everyone, and that's a huge deal.\n\nAll so you don't have to learn about alt-left.\n\n> > Sandboxing -- the app has to **ask permission** to do anything other than talk to the Internet.\n\n> Or now talk to USB...\n\nNope, [looks like it requires permission for that, too](https://wicg.github.io/webusb/#permission-api).\n\n> Including many untrustworthy ones you've never heard of.\n\nThe worst of which also get removed by the browser.\n\n> > without having a very good answer to \"Why won't this work as a web app?\"\n\n> The answer to that is always: because some people have JS disabled, or are not running the latest browesr released 7 minutes ago.\n\nThat's not even a *somewhat* good answer. All major browsers auto-update and have JS enabled by default, so what you're really saying is, this will be annoying for the *tiny* chunk of the population that's deliberately unset both of those things -- and that's a population that understands how to re-enable JS on that page, and how to keep at least one modern browser around.\n\nBut that *is* a good reason to not adopt your ban on auto-updates.\n\nEdit: But, to be fair, navigation *is* frequently broken entirely. The point is that it's a feature users want, and it'll work properly by default unless you break it, and there's no good reason to break it other than laziness. And if you make sure it keeps working, then you've added a ton of functionality *for free* users frequently ask for from native apps, and someone else already built out all the UI for them to use those features.", "id": "dakdlod"}, {"comment": "In the last 15 years there have been about 5 major Windows releases for end-users (depending on how you count them): XP, Vista, 7, 8, 10; all of which are STILL supported in some way, with almost no backwards-compatability breaking changes ever, without at least a lot of warning.\n\nIn half that time there have been 56 major Chrome releases (thats 22x faster release schedule), with no long-term support on any, and breaking changes whenever they feel like.  This is not a good situation at all!  Maybe if they stopped making such stupidly frequent major releases they could concentrate on actually supporting them for more than a week.  The problem isn't really auto-updates, it is auto-updates with breaking changes.  Use major versions for breaking changes, and keep security support for old versions (maybe even non-breaking new features) for something like 5 years (standard LTS time, or which there is currently no option for Chrome).  People like to claim that the web is the new universal OS, maybe they should start treating it as such.", "id": "dakdyrr"}, {"comment": "> XP, Vista, 7, 8, 10; all of which are STILL supported in some way...\n\nXP is properly end-of-life'd unless you're willing to pay literally millions. But not everyone has upgraded, because far from being forced, you actually have to *pay* for these upgrades. Most people won't see the new version until they buy a whole new computer.\n\nBut in the mean time, it's not just Microsoft -- *everyone* has to either support at least four very different versions of Windows, or deliberately break their program for a significant chunk of the population. A prime example of this can be found in the versions of Direct3D that ship with each one -- new games either need to miss out on features that are only available on Win10, or have an entirely separate renderer that works on Win7/8 versus Win10.\n\nEvery major version of Windows that's still out there in any significant numbers is an ongoing major cost to the entire software community -- *everyone* needs to sink time, money, and effort into each version of Windows they have to support, which could be better spent in a million other ways.\n\n> Maybe if they stopped making such stupidly frequent major releases they could concentrate on actually supporting them for more than a week.\n\nSure, but that means *everyone* does. Again, look at IE. Even today... I mean, thankfully, we don't have to care about IE6 anymore, or even IE7, but IE8 is still somewhere between 5 and 20% of IE users. So a modern website needs to support IE8, IE9, IE10, IE11, and Edge, or they say \"screw you\" to a huge number of IE users. And those are meaningful differences, because IE standards support still sucked a lot as recently as IE8.\n\nBut you only need to support Chrome 54 now, and the Chrome 55 beta to make sure it doesn't break anything. That's a *huge* amount less work for every website on the Internet.\n\n> ...with almost no backwards-compatability breaking changes ever...\n\nThat's true of web browsers, too. You weren't complaining about that, you were complaining about a UI change, and Windows tweaks its UI all over the place with every major upgrade.\n\nHow many actually-breaking changes has Chrome put out? I can only think of two important ones: One where it's planning to kill off certain types of Chrome Apps (with plenty of warning), and another where NPAPI was dropped in favor of PPAPI. And those changes basically affect plugins and extensions, which tend to be pretty browser-specific anyway -- *websites* mostly just tend to keep working...\n\n...unless there's a security issue -- like if browsers have to make major changes in how they work to fix some brand-new problem like \"clickjacking\" -- but you were all for automatic security updates, right? I mean, the breakage sucks, but it's better than the alternative...\n\nBut... yeah, breaking changes suck. I agree wholeheartedly. I'm just not convinced that any of the ways people have proposed to mitigate them are actually better than giving up and accepting the risk of auto-updates.", "id": "dakfm5l"}, {"comment": "Chrome actually supported XP *longer* than Microsoft did.", "id": "danba87"}, {"comment": "> In the last 15 years there have been about 5 major Windows releases for end-users (depending on how you count them): XP, Vista, 7, 8, 10; all of which are STILL supported in some way, with almost no backwards-compatability breaking changes ever, without at least a lot of warning.\n> \n\nFirst, XP isn't supported any more, so at least there is a limit.  But support for an OS is different from support for a browser.  Browsers are easier to upgrade, they're free, and the compatibility landscape doesn't change dramatically with each new revision (OK, it changes a *little*, but not too much).\n\nI have been pretty irritated at some of the changes Google has forced in browser updates, but comparison with the OS market is unfair.  ", "id": "dakf7f4"}, {"comment": "> Browsers are easier to upgrade...\n\nThat depends on the OS. ChromeOS upgrades are incredibly painless, all you need to do is reboot -- kind of like browser updates. You might say, \"Of course, but that's because ChromeOS is just a browser...\" But actually, this style of update is coming to Android, too. There is no good reason an OS has to be harder to upgrade than a browser.\n\n(Well, there's *one* reason: Android drops hardware compatibility after 2-3 years, because hardware vendors refuse to support newer kernels longer than that. But the problem here is clearly the fact that a hardware vendor can, through sheer laziness, prevent Google from shipping a new OS.)\n\n> ...they're free...\n\nI mean, Windows 10 was a free upgrade, most OSes come free with the computer, and there are completely free OSes like Linux and Android. There's even cases where one version sort of costs money (ChromeOS only runs on certain specific pieces of hardware that it comes with), but there's a completely free version, too (ChromiumOS).\n\n> ...the compatibility landscape doesn't change dramatically with each new revision...\n\nThat's mostly a function of the speed and scope of each update, not the kind of thing being updated. The compatibility landscape probably changed more between IE6 and IE7 than between XP and Vista. Since then, the differences between Windows Vista, 7, 8, and 10 were relatively minor -- I suspect that IE8, IE9, IE10, and IE11 broke more things.\n\nChrome is fine *because* there's a new version every couple months, not in spite of it.", "id": "danbyqi"}, {"comment": "I think you're really stretching on these counterpoints.  ChromeOS and Android are highly controlled environments, and can't be compared with desktop and server OSs.  Yes, they're operating systems, but they're not the ones we're talking about.\n\nAnd OSs are not free with new computers -- Microsoft gets paid (not much, but some), and Windows 10 was only free for awhile.  People still pay for licensing, even if they don't feel it or see it on the sticker.\n\nAnd on compatibility, if you think that stuff didn't break between 7, 8, and 10, then I don't think you have enough exposure.  I am currently working with a customer who can't migrate from 7 to 10 because of fundamental UI changes that impact security requirements.  I'll agree that it's getting better, but it's not perfect.  And in-place upgrades are still less common than wholesale reinstalls.  Maybe Microsoft will close the gap, but for now it's not seamless.", "id": "danhz28"}, {"comment": "> ChromeOS and Android are highly controlled environments, and can't be compared with desktop and server OSs. Yes, they're operating systems, but they're not the ones we're talking about.\n\nI don't see what \"highly controlled\" has to do with it -- if anything, I would think that the APIs surfaced might actually be *more* things to keep compatible than with a proper desktop OS.\n\n> And OSs are not free with new computers -- Microsoft gets paid (not much, but some)...\n\nThey get paid that whether or not you end up using that OS. For many prebuilt computers (including by far most laptops), your only option is to get a computer shipped with another OS -- for liability reasons, they refuse to ship computers without an OS at all, so this can literally mean shipping you a computer with DOSBox on it.\n\nThey usually don't pass the savings on to you in that case. That's partly because manufacturers often more than recoup Microsoft's fee by adding crapware to the machine.\n\nSo yes, Microsoft technically gets some money. But *effectively,* it's free to you -- it's not like, when buying a new computer, there was a less-expensive version with no OS, or with your old OS.\n\n> ...Windows 10 was only free for awhile.\n\nSure, but it was free to anyone who wanted it and had any of the past two or three versions of Windows. If Windows 10 becomes the forever-OS they envisioned, or if they do this again for Windows 11, that still amounts to a basically-free upgrade cycle for anyone who wants it.\n\n> And on compatibility, if you think that stuff didn't break between 7, 8, and 10, then I don't think you have enough exposure.\n\nThat's possible. I just don't think it was anywhere *near* what it's been in previous versions, and enough things just kept working that I do think it's comparable to Chrome updates over the same time period.", "id": "dani7mb"}, {"comment": "This is a pretty bad example since Microsoft are doing everything they can to phase out support for older versions of Windows. (Apparently, supporting lots of different software costs a lot of money - who would have thought!)", "id": "dakkmsc"}, {"comment": "I wasn't thinking of phones on the graphical features point. I'm thinking, very low-end PCs that could use a little more free ram and still view and access content and services over gopher. Or for example if for some reason you are stuck in tty and you need to view something online. Of course, web sites that aren't too image heavy work on browsers like lynx, but they often rely on the graphics.\n\n>many \"native\" apps are just web apps in a native-looking wrapper\n\nYeah, unfortunately devs moved to stuff like electron which is probably the most resource expensive way to do desktop apps. I mean good native apps, like telegram desktop.", "id": "dakfi1z"}, {"comment": "> I wasn't thinking of phones on the graphical features point. I'm thinking, very low-end PCs that could use a little more free ram and still view and access content and services over gopher.\n\nMy point with phones is, if my *phone* can handle it, then even a very low-end PC can more than handle viewing graphics on a webpage.\n\n> Or for example if for some reason you are stuck in tty and you need to view something online.\n\nI've been there, but that was before I had a smartphone. Now, if for any reason I am stuck in a TTY, I pull my smartphone out of my pocket and use it to view the documentation I need to view to fix my display server.\n\n> I mean good native apps, like telegram desktop.\n\nWhy not just say you want good apps, then? Good web apps exist, and bad native apps exist.\n\nReddit is an example of a mostly-good app, I'd argue -- is your experience replying to this comment noticeably worse than it would be in a standalone app, in a way that you can't fix with an extension?", "id": "dakfr62"}, {"comment": "Yup, some web apps actually work good, especially if they don't go overboard with dynamic content, and chromium's reliability is decent even over months of uptime on a mid to high tier pc.\n\nDon't get me wrong, I don't hate HTTP THAT much, but enforcing the protocol to be plain text by default like gopher does would result in more services that are able to work even in text-only mode.\n\nSure, your phone or a low end computer can handle a couple tabs running modern webpages, but it would be able to multitask a lot more without that resource hog. You'd be able to keep 10, 20, 50 pages open and ready to use while doing other stuff without the OS swapping hard.\n\n50% of the problem is how developers use http, that's for sure. If every site was static then it wouldn't be as bad. 10 years ago I was much happier with it than I am now.\n\nReddit has no dynamic content and could work in text-only mode too, so that would not be something I would make a dedicated app for.", "id": "dakg9tu"}, {"comment": "> Sure, your phone or a low end computer can handle a couple tabs running modern webpages, but it would be able to multitask a lot more without that resource hog.\n\nThat's true. This is the part where I care less, though, because:\n\n> You'd be able to keep 10, 20, 50 pages open and ready to use while doing other stuff without the OS swapping hard.\n\nWhy on earth would I want 50 pages open and ready to use? That's enough that I'd lose track of them easily. I know people actually do open that many Chrome tabs, and I don't understand those people -- when I get too many tabs open, I end up re-opening the same thing in a new tab, and that's usually a clue that I need to close some tabs.\n\nA low-end PC can still multitask to a *reasonable* degree, especially with lighter websites.\n\nAnd my phone hardly needs to multitask -- it *can* do more, but most of the time, there's one foreground app, one background app playing music, and a bunch of syncing. The syncing is periodic, throttled by the OS, and fairly resource-light, even for web apps.\n\n> 50% of the problem is how developers use http, that's for sure. If every site was static then it wouldn't be as bad.\n\n...erm... are you saying \"HTTP\" when you mean \"JavaScript\"?\n\n> Reddit has no dynamic content and could work in text-only mode too, so that would not be something I would make a dedicated app for.\n\nReddit has *tons* of dynamic content -- voting and commenting can be done within a page, without reloading the page. Expanding and collapsing threads doesn't even require a round-trip to the server, unless the thread is particularly deep -- there's even a little \"formatting help\" below the comment box. That's all done with client-side Javascript. It's a perfect example of all this modern JavaScript and HTML making the experience *better,* not worse.", "id": "dalnqua"}, {"comment": "sure, reddit has some javascript but it would be the kind of site that would work just fine as 100% static, which is why I said I wouldn't make a dedicated app for it.\n\n>...erm... are you saying \"HTTP\" when you mean \"JavaScript\"?\n\nyeah, in this case it's javascript, but it could be anything dynamic built on top of http. Most modern HTTP sites rely on javascript to be even usable.", "id": "dalvfkt"}, {"comment": "The point is that Reddit wouldn't work as well if it were built without JavaScript. I moved to Reddit from Slashdot, and a big part of the reason why is that Slashdot was mostly static -- to reply to a comment, you had to go to a whole new page, and then submitting your reply was *another* page load. Moderation involved selecting a bunch of stuff from dropdowns and then clicking \"submit\", reloading the entire page. You had to adjust a ton of fancy sliders to filter the comments, because loading and scrolling through hundreds of comments was too cumbersome.\n\nThe whole experience was slow. Partly this is a slow backend, partly it's that the pages themselves were bloated. But partly, round-trips take time -- Reddit can feel responsive over surprisingly high-latency connections, by comparison.\n\nSlashdot has since become more dynamic, but I wouldn't say Reddit would \"work fine\", so much as that it would technically work.", "id": "damedpo"}, {"comment": "Exactly, reddit could technically work as entirely static documents, but it would no longer be the useful platform it is today, and wouldn't enjoy the influence it has as a result of that utility.", "id": "danbj5z"}, {"comment": "I don't understand what you mean by HTTP. HTTP is a protocol on top of [usually] TCP, just like gopher. It sounds like you're complaining about *the Web* which is a set of higher-level languages that Web browsers interpret and present to the user.\n\nA Web browser could be written that uses gopher instead of HTTP. (Web browsers already support other protocols, like FTP.) Similarly, a gopher client could be written that interprets gopher documents as encoded Web pages and presents them to the user as such.\n\nRegardless, your argument starts with more fundamental complaints than dynamic content. You would prefer that reddit be presented as a tree of documents, with each document comprised of plain-text submissions and comments. That's just a fundamentally different experience, more like Usenet than what reddit actually is.", "id": "danbhln"}, {"comment": "gopher's simplicity, orientation towards the directory tree structure (which is basically built into the protocol) and plain-textness would make it harder to build an ecosystem such as the one that's built on top of HTTP without major hacks. I know it's mostly the stuff that's on top of HTTP at fault, though.\n\nIf the web was as it was like 10 years ago, minus the flash content, I'd probably be okay with it. But as it is now, gopherspace is only of the few safe spaces from bloated content presentation.", "id": "daner07"}, {"comment": "If I felt like it, I'd bet I could find a copy of this article from quite a few years ago. I do not think it is new.", "id": "dakg2f5"}, {"comment": "Maybe there's an older version of it somewhere, but the version I linked to has a modification time on November 11th of this year. And there's a [similar anti-web rant](http://weeb.ddns.net/0/articles/modern_software_is_at_its_worst.txt) that definitely uses modern terminology, criticizing things like \"responsive design\" and complaining about electron-wrapped websites masquerading as apps.\n\nAt the very least, OP did end up responding to defend at least pieces of that rant, so I think it's fair to criticize it.", "id": "dalo450"}, {"comment": "This is OP's ideal presentation: https://i.imgur.com/qSPo3wh.png\n\nYou're all just viewing a poor emulation of it /s", "id": "dakene6"}, {"comment": "> users/loli", "id": "daljede"}, {"comment": "Or [just like this](http://i.imgur.com/IAB1Hjx.png). You don't have to use a terminal based Gopher client you know (FWIW [this is mine](http://runtimeterror.com/tools/gopher/)).\n\nAs a sidenote, i dislike how some Gopherholes treat the protocol as \"HTML lite\" and use menu entries as hyperlinks that ignore hierarchy - most commonly seen with \"Back\" links. Menu entries are supposed to point to content and info entries are supposed to be used to help navigate the content, not cover 90% of the menu with text.", "id": "dalf2x0"}, {"comment": "I was following the [author's suggestion for how to browse gopher](http://weeb.ddns.net/1/gopher/0_README_how_to_browse).", "id": "dalhfi2"}, {"comment": "Ah i see. Well, IMO the original gopher client is probably the worst way to browse these days since most gopher servers do not support the \"GOPHER+\" or whatever it was called that the client assumes the server does (apparently the developers thought everyone will use their own server and didn't make the client backwards compatible) :-P.", "id": "daljo0s"}, {"comment": "Kindda like formatting code by 78 char lines", "id": "dakc1iz"}, {"comment": "Except not really. At 80 chars you're wasting way less space.", "id": "dakdip1"}, {"comment": "You need to be able to fit \"> \" for replies.  ;-)", "id": "dakf9j3"}, {"comment": "Yeah but at 72 chars, you're leaving room for sequence numbers, and without those, where will you be if you accidentally drop your card deck on the floor?", "id": "dakff4z"}, {"comment": "79 (or similar) character limits can be good for readability, allow better multitasking (2-4 files on one screen), and force you to think about how to break down incomprehensible one-liners into a sequence of logical parts. They're not always the right choice, but they can be useful.", "id": "dakynhm"}, {"comment": "The UI can fit into 800x600 whilst letting your browser insert proper line breaks. This is unreadable. I couldn't even put it into Reader mode because of the unnecessary mid-sentence breaks.", "id": "dake0x8"}, {"comment": "> This is unreadable.\n\nI think my \"favorite\" part is the writing of English text in monospace font.\n\nAnd yeah, I concur.", "id": "dal21u3"}, {"comment": "I am next to positive that this is an old article from many years ago. ", "id": "dakg19k"}, {"comment": "I occasionally code for a 24x80 text only display", "id": "dal92wq"}, {"comment": "Yes, it was nice of the author to _preformat_ that text for you so your computer would know exactly what to display.  :-)", "id": "dakawyy"}, {"comment": "I personally find 67 column width more readable than text than spans over the entire screen. I tend to lose track of the line I'm reading and such. It's not even because of my 800x600 ui convention. I format all my code like that too. I used to use 80 column width but since I often post my code in gopherspace I switched to 67 which is optimal for gopher", "id": "dakf3fj"}, {"comment": "limiting column width sure is a good thing.\nit's just some other basic things: i can read a non-monospaced text body more efficiently. for code monospace is fine.\n\nand more visible breaks. that's about it.\n\nfigured i could manage a more constructive comment than my first one. do with it what you want :)", "id": "dal3k1k"}, {"comment": "http://imgur.com/a/p0tbp\n\nYet it leaves some users with almost 80% of their screen being completely empty. I find that hurts readibility of a site far more than lines being too long. There is a happy medium, and its at least double what you use (and even then its best to let the browser decide how to wrap the text) based on the size of the screen.", "id": "dal4ig4"}, {"comment": "if I was making an actual website I'd opt for something like 800px width and let the browser decide how to wrap, however in this case I'm mirroring plaintext gopher content, where every space and newline is aligned by hand with love, and rewrapping it would just be ugly. I'll think about centering the text block though.", "id": "dal65sv"}, {"comment": "Is your font blury, or is it image compression? It looks like the text is smudged by a greasy finger on my screen.", "id": "dapi0z1"}, {"comment": "Font looks fine on my screen, but in the image its blurry. I imagine that its because Imgur compressed the size of the image to display it. When I open the image in a new tab and zoom in most of the blurryness goes away", "id": "dapi98i"}, {"comment": "I have no idea what you are talking about. I mean, it's [perfectly formatted](http://i.imgur.com/EAGYDkt.png) once I reach 260% zoom.", "id": "dakj0p9"}, {"comment": "Yes, [it's really useful](https://imgur.com/a/2hda0)", "id": "daklyht"}, {"comment": "Apparently proggit can't handle a text file.  It's beneath the community to read something formatted in the style of the days of yore.  On the one hand, proggit will complain if it's gray text on a white background, on the other they'll complain if it's not styled enough.  I'm surprised someone hasn't criticized it for being light text on a dark background (but maybe there's still a little nerd left in the proggit readership).  \n\nCan't we all just get along and accept content on its technical merit?  ", "id": "dakfgij"}], [{"comment": "> Why would you want to avoid libc?\n\n> - Your code will have no dependencies other than the compiler.\n\nGiven that the compiler usually comes with the standard libs, this seems moot.\n\n> - Not including the massive header files and not linking the\n  standard library makes compilation faster. It will be nearly\n  instantaneous even for thousands of lines of code.\n\nEven large code compiles pretty dang fast these days, unless you're doing something really large, in which case you're not really saving much time by doing this. Probably wasting plenty of extra time doing it all without the standard libs. So moot at best, but really it's just untrue.\n\n> - Executables are incredibly small (the http mirror server for my\n  gopherspace is powered by a 10kb executable).\n\nI'm unclear on why exactly you would want this, with the exception of the following point:\n\n> - Easy to optimize for embedded computers that have very limited\n  resources.\n\nDon't those sorts of things either come with appropriately compact standard libraries? And probably use entirely different calling conventions? Are there any ultra-compact x86 platforms where this is necessary? And isn't this all dependent on a whole linux kernel above it anyway?\n\n> - Easy to port to other architectures as long as they are\n  documented, without having to worry whether the libs you use\n  support it or not.\n\nI'd argue otherwise. C already ports just fine between most platforms, unless you're trying to bang 64 bit things into a 32 bit platform, or working with wacky 14 it DSP chips, but in that case the libraries are the least of your concern. This makes porting *harder* because you're using low level conventions for a single platform rather than using a high level standard interface to an appropriate standard library for each platform.\n\n> - Above all, it exposes the inner workings of the OS, architecture\n  and libc, which teaches you a lot and makes you more aware of\n  what you're doing even when using high level libraries.\n\n> - It's a fun challenge!\n\nI'll agree with these points, but nothing else. I really don't think there's any practical advantages to working this way, just the novelty and educational value.", "id": "dakddbp"}, {"comment": "> Educational value\n\nTotally. I can't even begin summarising what I all learned by mucking about with the internals of lots of things. I'd be sitting here all day.\n\nIt's one of the best ways to learn once you understand the basic things. Looking at other code and trying to understand it, adding in your own stuff and reinventing the wheel.", "id": "dakeeoj"}, {"comment": "Oh yeah for sure, I'm in no way suggesting this should never be done - only that it should never be done in a real project. Doing weird shit just to see how it's done is the very foundation of education in my opinion. You don't learn shit by doing the same stuff you've already done.", "id": "dakegnl"}, {"comment": "do you imply that only projects made for distribution are _real_ projects?", "id": "daket06"}, {"comment": "No. I mean projects with a real application beyond their novelty. And I suppose there is some overlap between \"novelty\" and \"real\" projects.\n\nSemantics aside: this is not a serious technique for serious projects. It is a novelty for novelty projects. You know what I mean.", "id": "dakft7g"}, {"comment": "yeah, i know what you mean. the author obviously does it for his programs and puts them to real application. if he were to get away with say a hyper low-powered MCU with the help of this technique, then that is as real as it gets. i find that a way more novel goal than throwing hardware and energy at shitty CRUDs like there were no tomorrow. it's all about application, man =)", "id": "dakgacq"}, {"comment": "Yeah it's true that they aren't \"real world\" advantages other than the educational value and coolness points with current hardware and compilers.", "id": "dakernh"}], [{"comment": "Yeah, let's build a house, but without premade bricks.", "id": "dakc4if"}, {"comment": "Design and grow your own trees!", "id": "dakc87w"}, {"comment": "It's not too long until concrete 3D-printing is mainstream, so yes, let's build.", "id": "dakcvjl"}, {"comment": "[Yeah!](https://www.youtube.com/watch?v=P73REgj-3UE)", "id": "dakmz7k"}, {"comment": "A great set of videos, that.", "id": "dant2xb"}, {"comment": "Kind of a good analog to this. It's not necessarily something useful, but more for the sake of understanding what came before us, and what technologies were used to get us to where we are today.", "id": "dao20sk"}], [{"comment": "Minimal example:\n\n    #define syscall(a, D, S, d) __asm__ __volatile__(\"syscall\" : : \"a\"(a), \"D\"(D), \"S\"(S), \"d\"(d))\n\n    void _start(void)\n    {\n            syscall(1, 1, \"hello\\n\", 6);\n            syscall(60, 0, 0, 0);\n    }\n\n\nCompile with `-nostdlib`.", "id": "dakjyn1"}, {"comment": "yep, inline asm also works, and that's what you find in most other guides, but I personally don't like the syntax. it does save some cpu cycles that are spent calling my syscall trampolines though, so I would use that for syscalls that are called many times a second.", "id": "dakk4so"}, {"comment": "Should save space too, since a syscall instruction is shorter than a call.", "id": "dakug2m"}], [{"comment": "This is actually rather nice to get to know how things work (especially calling conventions and how thr stdlib works).\n\nAlso: Couldn't you optimize the amd64 syscall wrapper to deduplicate the various argument arities into one function?\n\n    syscall5:\n        mov r8,r9\n    syscall4:\n        mov r10,r8\n    syscall3:\n        mov rdx,rcx\n    syscall2:\n        mov rsi,rdx\n    syscall1:\n        mov rdi,rsi\n    syscall0:\n        mov rax,rdi\n        syscall\n        ret\n\ni.e. having the pointers for the lower arities point into the middle of the syscall5 function, and ordering the movs so that it moves the higher arguments first.\nBecause labels are just another entry in the symbol table, aren't they?", "id": "dakdwye"}, {"comment": ">     syscall5:\n>         mov r8,r9\n>     syscall4:\n>         mov r10,r8\n\nThis puts `r9` into `r10`.", "id": "dakfhar"}, {"comment": "Right. So that's why it has to be done the other way round. You'd be overwriting the other values", "id": "daki64x"}, {"comment": "not sure if this is possible without overwriting registers, which would be why I didn't do it, I'll test later", "id": "dakeq22"}, {"comment": "Will overwrite registers. Ergo doesn't work.\n\nDidn't see it at first", "id": "daki7hm"}, {"comment": "You need a left-to-right calling convention for this to work, I believe.", "id": "dakktid"}], [{"comment": "Interesting read!", "id": "daka9va"}], [{"comment": "wow, an interesting article with code and about programming at the top of /r/programming. that's not every month.", "id": "dakevtn"}], [{"comment": "Why not just write assembly? I find it more easy than weird C", "id": "dakbt1n"}, {"comment": "Beating a compiler for size of executable is reasonably doable, but beating one for performance is as good as impossible these days.\n\nActually winning on size has been impossible for a long time with the release of Crinkler, and that compresses C code better than assembly.", "id": "dakccfd"}, {"comment": "Having written a bunch of assembly for performance critical inner loops and analyzed instruction level performance traces for a lot of compiled code, I'm going to have to disagree on both of those. Compilers are still shit at register management. Especially at optimizing register allocation for hot path.", "id": "dalv18s"}, {"comment": "re Performance, how many people in the world do you think can do that? versus how many programmers in the world? I think you'll agree \"as good as impossible\" is an apt description.\n\nre size, the [demoscene](http://crinkler.net/) has done things you might like to read about", "id": "danluu3"}, {"comment": "I've written assembly programs before, but I prefer C for now. I'm not that good at assembly either.", "id": "dakesd3"}], [{"comment": "The server is getting hit pretty hard right now, did not expect this much traffic. In the meantime, you can find a bbcode mirror of the guide here: https://ccplz.net/threads/writing-c-software-without-the-standard-library-linux-edition.69623/\n\nEDIT: should be fine now, I shut down some memory hungry golang application I had running on my vps. tfw 128mb ram", "id": "dakqrhp"}], [{"comment": "Is anyone else completely unable to load this page? Android, Chrome, ERR_CONTENT_DECODING_FAILED\n\nThe URL indicates that it's a plaintext document, so something seems fucky.", "id": "dakfq0p"}, {"comment": "it's actually a html page that displays a txt with a color scheme. I haven't had problems on chromium on desktop, but then again the web server that is serving the content is handmade and I've never written a http server before so it's likely that I fucked up somewhere. I'll let you know if I find anything weird", "id": "dakfuew"}, {"comment": "I'm going to try explicitly turning off any encoding in my response header, let me know if that works for you.\n\nAlso there are some non-ascii characters that show up as ? in my copypasted snippets of the ABI pdf's which I will fix soon, but I don't think that would cause a browser to get so confused that it doesn't render the page.", "id": "dakh3lm"}], [{"comment": "Could have sworn I've seen this done with the context of making the smallest executable possible, but I can't find it now (as in, this article was just a rip off of that with a little polishing to make it different).\n\n\nBut similar stuff I found while searching:  \nhttps://www.microsoft.com/msj/archive/S569.aspx  \nhttp://www.catch22.net/tuts/reducing-executable-size  \nhttp://www.mvps.org/user32/nocrt.html  \n\n\n\nEDIT:  \nI'm wagering this was the article that I was thinking of  \nhttp://www.muppetlabs.com/~breadbox/software/tiny/teensy.html\n", "id": "daliasl"}, {"comment": "there are many articles like mine, but I focus on making a setup for making more complex programs than just a hello world and I target multiple architectures.", "id": "dalvcg8"}], [{"comment": "I attempted to curl | less this page and was very disappointed. <_<", "id": "dao9jhi"}, {"comment": "you gotta do it from the source, which is gopherspace:\n\n```echo \"/users/loli/programming/c_without_standard_library_linux.txt\" | nc sdf.org 70 | less```", "id": "daoe5gj"}], [{"comment": "C has a standard library!??!\n", "id": "daklpod"}, {"comment": "Yep: https://en.wikipedia.org/wiki/C_standard_library", "id": "daloet8"}]]], "5g28c9": ["Let\u2019s Stop Bashing C", "2016-12-02 11:25:26", 1215, "http://h2co3.org/blog/index.php/2016/12/01/lets-stop-bashing-c/", [[951, "> It also mentions that terminating semicolons fall into the same category and that they should be replaced with newlines. This is very much not true, though.\n\nI'm really not able to understand that modern obsession with going semicolonless. In a braceful whitespace-insensitive language, a semicolon is meant to mark the end of a statement and do that *unambiguously*. Sometimes you need to split a single statement on many lines for readability (especially with lambdas, long initializer lists, etc.) and this is where the semicolon plays its real role. It also makes parsing and error recovery a lot easier."], [247, "If you think C is shit, don't use it, for most purposes it's not the best language nowadays. But there are a lot of legitimate reasons for using C, and it's not going away soon. \n\nSpend your time making nice stuff instead of endless debating."], [201, "I'm down for criticizing C. This article should be titled \"Let's stop using bikeshedding arguments like whitespace vs semicolons+braces when there are much more important flaws to discuss\""], [176, "Bashing C is pointless, but so it is defending its \"simple, beautiful design\". \n\nIf you read [The Development of the C Language](https://www.bell-labs.com/usr/dmr/www/chist.html) written by certain [Dennis M Ritchie](https://en.wikipedia.org/wiki/Dennis_Ritchie) you'll see that basically there was no design there - it was a hack on top of a hack; evolution at its best (or worst). From that paper:\n\n> \"In 1971 I began to extend the B language by adding a character type and also rewrote its compiler to generate PDP-11 machine instructions instead of threaded code. Thus the transition from B to C was contemporaneous with the creation of a compiler capable of producing programs fast and small enough to compete with assembly language.\"\n\n> \"After creating the type system, the associated syntax, and the compiler for the new language, I felt that it deserved a new name; NB seemed insufficiently distinctive. I decided to follow the single-letter style and called it C\"\n\n> \" As should be clear from the history above, C evolved from typeless languages. It did not suddenly appear to its earliest users and developers as an entirely new language with its own rules; instead we continually had to adapt existing programs as the language developed, and make allowance for an existing body of code.\"\n\nAnd finally, the best summary from the man himself:\n\n> \"C is quirky, flawed, and an enormous success\""], [159, "And let's start Cing BASH.\n\nNote: I'm very sorry to bring such bad humour into a serious post. Please don't downvote this even if you don't upvote it. I just had to say it somewhere and it lacks context anywhere else. Let it thrive here in its cozy little corner for the rest of time."], [122, "C is imperfect, but most of the critics are no better. They're just stabbing in the dark, based on their opinions. The fact is that C is old, it is successful, precisely because it does more things right than it does wrong. The same often can't be said for new languages."], [93, "Meh. No, let's bash C. There's tons of ~~valud~~valid complaints. It's not exactly the fault of C, but of the state of the compiler tech 40-50 years ago, and the overall state of the computing, really.\n\nBack then, it was a **very** good compromise. Nowadays, so much less so.\n\nAnd yes, some desisions are just wrong, wrong, wrong (e.g. precedence).\n\n>  I\u2019m no Python expert, but I\u2019ve run into hard-to-debug errors several times because I\u2019ve cut and pasted some code into my function during refactoring, and it misbehaved because of the indentation that didn\u2019t happen to match the then-current indent level.\n\nCopy-pastes code, complaints it doesn't work. Not cool!"], [98, "As someone who codes in python quite a bit I have to say:\n\n\"In a language where whitespace is significant, automatic indentation becomes literally impossible, which is very annoying. I\u2019m no Python expert, but I\u2019ve run into hard-to-debug errors several times because I\u2019ve cut and pasted some code into my function during refactoring, and it misbehaved because of the indentation that didn\u2019t happen to match the then-current indent level.\"\n\nI _never_ have hard to debug problems because of this. This speaks to unfamiliarity with the convention, more than to an inherent flaw. When you copy paste code into a new context you need to make sure it fits the context. In C that means making sure the braces are right (and then adding indentation for readability) in Python it means making sure the indentation is right (which means selecting the pasted block and hitting tab the correct number of times).\n\nMaybe it's because I have very little C experience, but I really fail to see how this is substantially different."], [62, "I think a lot of commenters are missing the point of eevee's article. It's not that C sucks. C is fine for the kind of uses it is applied to. The point is about high level languages copying features from C that they shouldn't have. There is no reason Javascript has it be such a screwed up language for example."], [37, "There's a difference between rationalizing and justifying. Most of these posts that defend C are rationalizations.\n\n\"What's so bad about X?\" is not an argument in favor of X, it's an argument against removing X from C. Nobody is suggesting that we change C.\n\nHowever, in order for X to be considered for a new language, it needs to be able to stand on its own legs. Merely citing it's existence in C is not good enough. Yes, every language feature of C has a purpose, but is that purpose still relevant 40 years later? If C didn't exist, would we still choose to do things this way?"], [22, "A pet peeve. Spot the difference:\n\n    if (looks_like_rain()) {\n        ...\n    }\n    if (!looks_like_rain()) {\n        ...\n    }    \n\nOh, **come on**. Learn to read code, what the fuck. do you want, an all caps operator? THECONTRARYOFTRUEWATCHOUT( *expression* )"], [23, "I think that the point of the first article was not to bash C itself, but to discourage new languages to bring aspects from C (and C++) without giving too much thought.\n\n*My* opinion is: do not create a new _serious_ language, unless you are a \"Guido van Rossum\"-like character, *and* you know deeply about the advantages and flaws of all main programming languages. There are too many languages already, and new ones are appearing by the bunch.\n"], [25, "I didn't see the original post (Eevee's) as bashing C, so much as bashing languages that copy C (for no apparent reason).  The more different a language is from C, the easier it is to justify.  Someone who takes C and modifies one little syntactic thing isn't really making a new language.  Someone who genuinely makes a new language, a new way of accomplishing a task or a fundamental different way of thinking about a process, someone who makes that and then *hides* the newness behind C's syntax is unnecessarily making it harder to learn.\n\nC has its place, and I use it.  Designers of other languages (and programmers considering other languages) should have a good reason for being the same as C in some respect, but still not just use C."], [19, "[deleted]"], [19, "While you have arguments about whether C shall be bashed or not, I'm sitting in my office being productive writing C code. I see that as a superior use of my time."], [22, "Overall, I liked most of eevee's article (though there's clearly some Python bias as that's her favorite language I would presume), and also agree with the points raised in this blog post as well.\n\nI posted a breakdown of my positions on eevee's points [here](https://twitter.com/byuu_san/status/804368450554646529), if for some reason anyone cared.\n\nIt's good to challenge deeply held beliefs from time to time, and have discussions like this.\n\nWhat always becomes very apparent is that there's clearly no one language that is going to be perfect to everyone. Yet by hearing viewpoints from many people, we can get a feel to design more successful languages in the future."], [14, "It is not the syntax of C that is bad, it is the semantics.\n\nIt is almost impossible to write secure string handling code in C."], [13, "Author seems to conflate \"bashing C\" with \"inventing a different language\"."], [11, "If they hate C so much, then stop bootstrapping your new-fangled languages in it.  :-) "], [13, "Semicolons are a waste of time Imagine all the times you have had to type a semicolon Now take all those milliseconds and add them up throughout the length of your programming career The savings are significant And every keystroke you type leads you one step closer to arthritis\n\nI propose that in the English language we stop using full stops They are totally unnecessary in the modern world We don't read out loud anymore Thus we have no reason to have a directive in our text that explicitly tells us to stop In the same way that semicolons are a waste of time imagine all the milliseconds you've wasted typing periods at the end of sentences The savings are significant"], [11, "I think a lot of people misunderstand a lot of what makes c great and ubiquitous.\n\n1. features and updates are very conservative\n\n2. the standard is pretty small and is designed to make writing a compiler for a new system easier\n\n3. it is not handcuffed, and doesn't assume the author is a dumb chimp that needs to be told how to do things the \"right\" way\n\n\nIt is not the only language available, lot's of other choices. It isn't written for or needed by \"newbs\". Yes anyone can make simple mistakes, but with rigid and disciplined styles/convention/testing can greatly reduce errors. It is not only, not for every application, it is also, not for every programmer."], [9, "It might be better to say \"let's stop bashing programming languages.\" Pick a programming language and *someone* will be more than happy to provide you with a long-winded rant about how it's the worst thing since sexually transmitted diseases. \n\nVirtually all programming languages have their strengths and weaknesses, and if you don't like a language then don't use it. C in particular isn't really all that bad. Sure, it's missing some niceties present in more modern languages, but it's still possible to do most anything you can think of in C. Then again, I'm a big fan of assembly, so maybe I'm not the best person to ask."], [9, "People who bash C don't work on drivers. People who do work on drivers find this amusing. Sometimes we even write *assembly*. "], [8, "The original purpose of C was to be a tiny abstraction above assembly language.  C has functions because processors have call and ret instructions.  C has ++ and -- because processors have inc and dec instructions. C has ints and floats because processors have ints and floats.\n\nMy main gripe with C today is that it never kept up with the processors.   long long is not a good solution to the increasing range of register sizes.  There is no vector support.  A lot of this is solved with extensions and libraries, but it should be standard by now.  Instead the standard seems to be the most common denominator.  It will work on little 8 bit cpus or multicore monsters.\n\n"], [9, "Let's stop C-ing bash. "], [7, "Eevee's article was well reasoned and thorough. This response is anything but.\n\n> What\u2019s Wrong with Integer Division?\n\nNothing, which is why eevee pointed at Python and Dart which have explicit integer division operators. Would you rather write `a ~/ b` or `a / (double) b` in general?\n\nThe author didn't read the original post in any detail and jumped to the conclusion that eevee wanted to eliminate integer division.\n\n> What\u2019s Wrong with Increment/Decrement?\n\nAs statements? Nothing. As expressions? I've been programming for fifteen years and I refuse to use increment and decrement as expressions. It would be like not just allowing but *recommending* code like\n\n    double y = 2;\n    double x = pow(y, y = y  * 2);\n\nWhat's the result? That depends on the order of execution. Normal code has far less dependency on order of execution within a single expression, and that makes it easier to read. But this snippet requires me to understand more of the minutiae of the compiler.\n\nIt costs me literally nothing to write `x++; foo(x)` instead of `foo(x++)` or `foo(++x)`, whichever it happens to be. Pre/post-inc/decrement are better defined, but that doesn't reduce the amount of cognitive work I need to do. It just means I look at a different section of the language spec.\n\nThe author's response to someone's complaint about this is that people who don't like it should go code in C for a few years. Dismissive and snide.\n\n>     return\n>     1 + 2\n\n> Should it return unit, or should it return 3?\n\nIf you take a language without significant whitespace and with explicit delimiters, write some code that wouldn't pass code review, then remove delimiters without making whitespace significant, it doesn't work. My goodness! Shock! Horror! Flabbergastery! Who would ever suggest using whitespace instead of semicolons when *this* happens if you use **neither**?\n\nThis isn't even an attempt to be convincing."], [8, "I found one thing funny:\n\n> There is a prefix and a postfix variation of them that\n> do slightly different things. The usual semantics is\n> that the prefix ones evaulate to the already-modified \n> expression, while postfix ones yield the original value.\n> This can be very convenient, as in different contexts,\n> code might require the value of one state or another,\n> so having both versions can lead to more concise\n> code and less off-by-one errors.\n\nI conider that confusing for beginners - so actually, the original point still stands - C IS complex! :)\n\nI think this is also ok. It just should not be advertised as a super-simple language."], [5, "Society is already divided, now more than ever, what better than yet another C argument.\n\nC is not for everything, I think the issue here is that people are bashing C for the wrong reasons, reasons that are already solved by another languages, and that's fine too. If we pretend that C solves every problem and is designed for every application, then yeah, it has a lot of disadvantages, but that's not the case.\n\nCase in point is one of the most used languages in the word (Linux Kernel for instance), is the closest language to ASM where you basically can predict how the assembly would be and it's the father of most of the languages right now. Still relevant, old yes, but not obsolete. So let's not pretend it's perfect, and also let's not pretend and it's obsolete and useless neither. Can we agree on that?"], [8, "Why are you complaining about integer division!? We have integer division because it's fast compared to using floating point numbers; which is an actual hardware design constraint with floating point numbers. There's that, and some microcontrollers, which are programmed mostly in C, do not have any hardware support for floating points. They're instead simulated in software making it very, very slow. "], [5, "I like IDEs that tell me when i miss a simple typing errors before committing to a test or some other time consuming process. I guess it's not super cool to use advanced tools, but it makes a lot of these semantic arguments seem like a giant waste of effort. "], [5, "/bin/bash C\n\nDid I just bash C?"], [4, "Sounds like tilting at windmills to me. Thin skinned author with shares of C stock? (Whatever that is.)\n\nThere has never been a language invented that didn't *instantly* and *forever* have critics. Use what you love or what you're paid to use. "]], [[{"comment": "> It also mentions that terminating semicolons fall into the same category and that they should be replaced with newlines. This is very much not true, though.\n\nI'm really not able to understand that modern obsession with going semicolonless. In a braceful whitespace-insensitive language, a semicolon is meant to mark the end of a statement and do that *unambiguously*. Sometimes you need to split a single statement on many lines for readability (especially with lambdas, long initializer lists, etc.) and this is where the semicolon plays its real role. It also makes parsing and error recovery a lot easier.", "id": "daox3ph"}, {"comment": "Ever used a Fluent library in C#? If you have, then you have written code that looks like this:\n\n    var thingie = oldthingie.DoTheFirstThing()\n                            .DoTheSecondThing()\n                            .DoTheThirdThing()\n                            .DoTheFourthThing()\n                            .DoTheFifthThing();\n\n..and those lists of method calls get stupid long. Don't get me wrong, I hate fluent coding because it makes setting breakpoints the way I want impossible, but it is a really common coding technique. If whitespace ended statements, then this would be all on one line. How fun that would be to read!", "id": "dap19uh"}, {"comment": "Speaking of stop imitating C, let's not make breakpoints line dependent anymore.", "id": "dap5i55"}, {"comment": "Good luck. Breakpoint information in object files is language agnostic and only knows file/line.", "id": "dapave1"}, {"comment": "There's already a dozen or so standards for that information.  What's the harm in one more if it legitimately does its job better than the other options?  And to head off the eventual [xkcd](https://xkcd.com/927/), this standard would be adding new information and supporting new workflows, rather than simply attempting to unify.", "id": "dapcqz7"}, {"comment": "There are actually very few standards for debugging information. The entire UNIX ecoysystem has zeroed in on DWARF (the debugging format for ELF, also used for Mach-O) 27 years ago. Microsoft uses COFF (the predecessor of ELF) object files with the debugging format that comes with that. In the past there was also stabs but that's not really used anywhere.\n\nAdding a new standard for debug symbols sounds like a really bad idea.", "id": "dapd9lr"}, {"comment": "There's four different major versions of DWARF, there's also stabs, and when you go to some other architectures like MIPS, they've got a totally different, custom thing that they can use.  And COFF is just a container format, what's stored in there, and in the PDBs, has heavily changed over the years more than once, to the point of when you're writing a decoder you pretty much treat the different versions as totally separate.  (I'm in the process of writing a binutils replacement in Rust).", "id": "dapdn7f"}, {"comment": "> I'm in the process of writing a binutils replacement in Rust\n\nI pray for your soul.", "id": "dapdq8f"}, {"comment": "Haha, it's not actually that bad.  I'm actually finding a few minor bugs in binutils as well, (like addr2line gets confused in the edge conditions with ARM thumb code, PowerPC sync instruction has a ton of extra whitespace in objdump, etc.).  And it's not a totally masturbatory exercise, the end goal is to see how much safe Rust makes sense in a qemu knockoff, and it's easier to test the machine code parsing by just diffing it with binutils' output.", "id": "dapedrd"}, {"comment": "I am so sick of seeing that fucking webcomic. It isn't how the industry works, 99% of the time.  Misapplied xkcd is a fucking contagious disease communicated by karma whores.", "id": "dapgbe6"}, {"comment": "Kotlin/IntelliJ does this :) Create a breakpoint on a line with a lambda, and it will ask whether to break on the lambda, the line, or both.", "id": "dapbl17"}, {"comment": "In Visual Studio you just press F9 on the statement you want to break on. Doesn't work for Fluent API, but IIRC that's coming in the next VS.", "id": "dapjirm"}, {"comment": "Scala doesn't have this problem though. If you line starts with a . It's treated as a continuation of the last line", "id": "dap1w3p"}, {"comment": "Yes. Although I'm used to semicolons, it's hard to argue with the logic of going without them. The fact is, either you user a special character to end a statement, or you use a special character to continue a statement on the next line. Which situation comes up less often? For me I split a statement between multiple lines less often than I have a statement on a single line. Therefore, using a special character to continue a statement would be less verbose and, therefore, should be preferable to having a special character every time you end a statement.", "id": "dapmqp6"}, {"comment": "Every single conversation about meaningful whitespace goes this way. For every supposed shortcoming there's a way of filling it, and most likely a language that has already implemented it. Every point the opponents make can be refuted as soon as you start actually trying to look for solutions. They don't, because they don't want solutions. They don't want it to work. So they stay where they are.", "id": "dapjyjx"}, {"comment": "It's one of those where people are coming up with ways to defend their opinion.\n\nIt's just an opinion.  I like semicolons because they're unambiguous for me.  If I'm working on someone else's code and they want me to *not* use them if possible, then I won't.  If I'm dictating the style of a codebase, then I will use them.\n\nI don't get the hubbub.  I like them.  It's okay to not like them.  It's like food.  Some people like carrots and broccoli, some people hate them.", "id": "dapmwdb"}, {"comment": "> unambiguous \n\nMy take is\n\nUnambiguous grammar --> Easier to Parse\n\nEasier to Parse --> better tools. \n\nBetter tools --> my life gets easier.\n", "id": "dapxhzt"}, {"comment": "No you could have exactly the same thing in python:\n\n    thingie = oldthingie.DoTheFirstThing() \\\n                        .DoTheSecondThing() \\\n                        .DoTheThirdThing() \\\n                        .DoTheFourthThing() \\\n                        .DoTheFifthThing()\n\nor fortran\n\n    thingie = oldthingie%DoTheFirstThing() &\n                        %DoTheSecondThing() &\n                        %DoTheThirdThing() &\n                        %DoTheFourthThing() &\n                        %DoTheFifthThing()\n\nBoth of which use newlines to terminate statements. I think having a character at the end of each line for non-standard formating is a small price to pay for all those missing semicolon errors.", "id": "dap24z9"}, {"comment": "> all those missing semicolon errors.\n\nIn all my years of C and C++, a missing semicolon has been at most a slight annoyance at compile time. Mountain out of a molehill.", "id": "dapfxt9"}, {"comment": "And almost every IDE I've used picks it up instantly as well, non issue.", "id": "dapmq1z"}, {"comment": "As opposed to the whitespace errors you can get if you paste in code that doesn't have quite the right indentation level, and the code you're running doesn't work the way it *looks* like it should work... \n\nI hate significant whitespace because of actual painful experience with its problems.", "id": "dapsiz5"}, {"comment": "Don't forget working on a team and your editor defaults to tabs where everyone else uses spaces.  Fuck significant whitespace.", "id": "dapuay4"}, {"comment": "I think missing or extra semicolons is something that confounds and confuses rank beginners trying to learn C style languages. And thus academics who have to deal with rank beginners think it's a 'big problem'. People that use these languages think it's barely a problem.\n", "id": "dapxpwa"}, {"comment": "Please, oh please!\n\n    thingie = (oldthingie.DoTheFirstThing()\n                         .DoTheSecondThing()\n                         .DoTheThirdThing()\n                         .DoTheFourthThing()\n                         .DoTheFifthThing())\n\n(though I tend even to do)\n\n    thingie = (\n        oldthingie\n        .DoTheFirstThing()\n    )", "id": "dap2nk6"}, {"comment": "At the risk of sounding like a moron, could you explain why?", "id": "dap4zb3"}, {"comment": "Mostly subjective reasons like: it looks better, requires less typing, its the pep recommended way, its more widely used/useful since that's how multiline function calls or definitions work, etc, etc.\n\nBut additionally (and not particularly relevant if your text editor trims trailing whitespace...but...), a trailing space after a backslash no longer counts as a line continuation. Potentially resulting in confusion.\n\nIts mostly just one of those things that bother me when I look at it, especially because people tend to use it to allow them to indent the subsequent lines in the same way as the original example. Which means: the indentation is dependent on the length of the variable name which means its prone to get misaligned very often; and I end up having to edit code like below and press tab and space a thousand times if I want to add things\n\n    nice_descriptive_name = CoolObjectTable.somethingidk.objects.filter(name='example', othername='othername') \\\n                                                                .values('name', 'othername')", "id": "dap6qww"}, {"comment": "Probably because PEP 8 says so.\n\n I think I read a justification for that rule somewhere a while ago but can't remember what it was.", "id": "dap6ot8"}, {"comment": "[deleted]", "id": "dap445m"}, {"comment": "> all those missing semicolon errors.\n\nIs this a thing? Do people actually have issues with this?", "id": "dapsg1u"}, {"comment": "Or old fixed format Fortran where you don't need a line continuation character at all, but just needed to start the next one in the 6th column!", "id": "dap6jmh"}, {"comment": "I would much rather have a compiler error for missing a semicolon than a runtime error for not indenting/newlining properly.", "id": "daprrxk"}, {"comment": "How is this not just trading missing semicolon errors for some other (potentially more cryptic) error when you forget a \\ or &?", "id": "dapsr47"}, {"comment": "That python example is horrible.. you're escaping an invisible character (the newline).  Put a space after one of those backslashes and you now have an invisible failure.", "id": "daphby2"}, {"comment": "> I think having a character at the end of each line for non-standard formating is a small price to pay for all those missing semicolon errors.\n\nSuppose you have an arbitrary kind of expression with lots of grouping parens or braces, which also spans across more than one line (I couldn't think of a more meaningful example):\n\n    ((5) +\n        3))\n\n    print \"Next statement\"\n\nYou also have unbalanced parentheses. Will most semicolonless compilers complain about an unexpected \"print\", or will they properly tell you that there are unbalanced parens?", "id": "dap2g3w"}, {"comment": "      File \"p.py\", line 2\n        3))\n          ^\n    SyntaxError: invalid syntax\n", "id": "dap33dl"}, {"comment": "So what you're saying is, it would have looked much worse in other languages?", "id": "dap6oav"}, {"comment": "> If whitespace ended statements, then this would be all on one line.\n\nThere's pretty much no language in which that is true (at least not for that example). Parsers can trivially determine that the first token being a dot is a continuation of an expression from the previous line.", "id": "dapess6"}, {"comment": "line break + dot .\n\n    var thingle = oldthingie.DoTheFirstThing().\n                        DoTheSecondThing().\n                        DoTheThirdThing().\n                        DoTheFourthThing().\n                        DoTheFifthThing() \n\nhere your grammar is now unambiguous", "id": "dap2klg"}, {"comment": "But you can't line up your code neatly on the dot, and that would annoy me.", "id": "dap3sks"}, {"comment": "So lining up by the dot is ok but lining up by the character after the dot is not ok?\n    \n    var thingle = oldthingie.DoTheFirstThing().\n                             DoTheSecondThing().\n                             DoTheThirdThing().\n                             DoTheFourthThing().\n                             DoTheFifthThing() ", "id": "dap4pzg"}, {"comment": "This only identifies that you're a little weak in languages that use newline characters as ends.\n\nYou can do exactly the same thing without using semicolons in other languages and still retaining a newline as an end of expression.  And as a point, with your example, the semicolon is quite subtle at the end there.  As a 'stupid human', I might miss the semicolon as often as I see it.", "id": "daphyey"}, {"comment": "This is one thing that Haskell got really, really right. Normally things are white space sensitive, but when you want you can break out braces and semicolons without anyone even noticing. The ability to do both it's awesome. Also, Haskell has a stricter definition of a statement or expression and where they're allowed, so there isn't really a need for a line continuation character. It makes formatting code easier.", "id": "dap0l1v"}, {"comment": "Haskell does not have statements. It just has expressions and declarations. There are expressions that look awfully like statements in do notation, but those are still expressions.", "id": "dap3k18"}, {"comment": "I use Haskell all the time for fun and occasional profit so I'm not trolling, but data declarations, type classes and instances, and modules require statements", "id": "dapp83k"}, {"comment": "I want to say yes, but I've never really understood this part of Haskell. Can you always convert a braces thing to indentation? I tried to do a case..of in a let in a do block the other day, and I just couldn't figure it out. Had to use braces in the end. ", "id": "dap4rzp"}, {"comment": "The default in Haskell is indentation, it's more that you opt in to braces.  I would say that it's more possible that there could be places where you wouldn't be able to convert indentation to braces, rather than the other way around.  For what you're wanting to do, sounds like you were using a `let-in` declaration in a `do` block, but for very technical reasons that I can't remember precisely without more coffee you have to use just `let` in a do block.  So something like\n\n    main = do\n        c <- getChar\n        let x = case c of\n                'a' -> \"That's A\"\n                'b' -> \"That's B\"\n                _   ->  \"I don't know what that is\"\n        putStrLn x\n\nOne thing that can trip people up is that the GHC compiler unambiguously interprets tabs as 8 spaces, always.  One reason why it's recommended to just use spaces in Haskell.  The other thing that trips people up is how much to indent with a `let` or `let-in`.  I think it's better illustrated like this\n\n    main = do\n      c <- getChar\n      let\n        x =\n          case c of\n            'a' -> \"That's A\"\n            'b' -> \"That's B\"\n            _   -> \"I don't know what that is\"\n      putStrLn x\n\nOr with braces, it should be something more like\n\n    -- Don't kill me if I get this somewhat wrong, I\n    -- don't have access to a compiler at the moment\n    main = do {\n        c <- getChar;\n        let {\n            x = case c of {\n                'a' -> \"That's A\";\n                'b' -> \"That's B\";\n                _   -> \"I don't know what that is\";\n            };\n        };\n        putStrLn x;\n    }\n\nThe trick to realize here is that the `let` itself is creating a new block.  I sometimes like to put the `let` on its own line, especially with if I'm using 2 space indentation.  It also makes it easier to shuffle lines (which doesn't matter as much in Haskell, but it can improve readability.  When you have `<rhs> = <lhs>`, everything in `<lhs>` has to be indented to a level beyond where `<rhs>` is.", "id": "dap83qb"}, {"comment": "Yes. Transforming an expression of the form `keyword { item 1; item 2; item 3 }` into an indented block works like this:\n\n* the column position of the first character of `item 1` (regardless of whether it's on the same line as `keyword` or not) is the block's indentation, let's call it I.\n* Any line starting at I starts a new item in the block.\n* Any line starting further than I is a continuation of the item from the previous line.\n* The first line starting earlier than I closes the block and belongs to whatever is the containing expression (which might in turn be an indented block and check its indentation against its own I).\n\nSo your nesting would be for example:\n\n    do foo                      -- start the \"do\" block with I = 3\n       baz                      -- new item in the \"do\" block\n       let x = 42               -- new item in the \"do\" block; start the \"let\" block with I = 7\n           y =                  -- new item in the \"let\" block\n             case x of          -- continue the \"y = ...\" item of the \"let\" block\n               42 -> 0          -- start the \"of\" block with I = 11\n               _ -> 1           -- new item in the \"of\" block\n             + 3                -- Close the \"of\" block, continue the \"y = ...\" item of the \"let\" block\n       return y                 -- Close the \"let\" block; new item in the \"do\" block\n", "id": "dap7ryn"}, {"comment": "The overwhelming majority of statements span one line. It makes sense to make the common case easier rather than the other way around. \n\nBesides, long lambdas, long initializer lists, etc, can easily be handled in a language without semicolons - just continue the line implicitly if there's an unmatched brace. Hell, there's no reason  (at least as far as I can figure) that Python couldn't allow lambdas to span multiple lines when enclosed by parentheses (and I might argue that the lambda syntax should require parentheses to begin with).", "id": "daoyaeo"}, {"comment": "what's so hard in semicolons?", "id": "daoz5dl"}, {"comment": "There's nothing hard about them. There's also nothing hard about typing break after every case in a switch statement, but that doesn't mean I want to have to do it. It's basically analogous to the semicolon situation. The rarely desired behavior, in this case fallthrough, is made the default while the behavior that's desired in 99\u2105 of cases requires extra syntax. I don't see how people think that's good language design. (For the record I like C and use it for most of my personal projects, however I don't think all of it's design choices are perfect.)", "id": "dap2fdu"}, {"comment": "[deleted]", "id": "dap3ona"}, {"comment": "> There's also nothing hard about typing break after every case\n> It's basically analogous to the semicolon situation\n\nthat's not true.   \nsemicolons are part of the syntax, just like in Italian the verb \u00e8 has a different accent from perch\u00e9.   \nYou just learn it and that's it.   \nbreak after case is a cognitive dissonance and it's cause of many subtle bugs.    \nin fact compilers nowadays issue a warning if you don't put it     \nwe could get rid of `break` and instead have a keyword for `fallthrough`  \n\n>  I don't see how people think that's good language design\n\nIt's just what it is, not good nor bad    \nthe way we write addresses is completely crazy, the way we track time makes no sense, and still we need abstractions   \nC is in the good part, not in the bad part    ", "id": "dap5rvs"}, {"comment": "Nothing. They are so engrained in to my programming that I actually have difficulty not putting them there at this point. ", "id": "dap30ev"}, {"comment": "Because\n\n>[Querty](https://en.wikipedia.org/wiki/File:Qwerty.svg)\n\n>[Quertz](https://en.wikipedia.org/wiki/File:KB_Germany.svg)\n\ndon't get me started on \\ / and {}.\n\nPlus it's doing something explicit which doesn't need to be explicit. I know C but I like python better, I simply don't know any cases where you need the \"statment\"-ness of stuff that would justify always having to use the semicolon.", "id": "dap1kou"}, {"comment": "I live in a QUERTZ country, changed to custom QWERTY. I have never regret that decision. (You don't even have to buy a new keyboard for swapping layouts, my newest keyboard has AZERTY printed on it, it doesn't matter at all.)\n\nEdit: Because people are going to not get how easy it is: Every computer I had to use so far allowed me to swap the layout to QUERTY - I have yet to see a computer that does not have QUERTY among the pre-installed layouts.\n\nYou need to look at the keys when you're typing? Well I guess your problem isn't the location of frequently used keys then ...", "id": "dap3vwu"}, {"comment": "I don't get it, on all of those layouts, the semi-colon seems to be in *almost* the same place as the QWERTY. Maybe even an easier place than on QWERTY. What am I missing.\n\n(Side note: while typing that, I somehow misspelled QWERTY)", "id": "dap4rxv"}, {"comment": ">Hell, there's no reason (at least as far as I can figure) that Python couldn't allow lambdas to span multiple lines when enclosed by parentheses \n\nIt already does.  There's no problem having multi-**line** lambdas (and it'll do so implicitly when enclosed by brackets), the restriction is in having multi-**statement** lambdas (or rather, any statement at all, it's limited to an expression, which python differentiates from statements).", "id": "dap2np6"}, {"comment": "> Besides, long lambdas, long initializer lists, etc, can easily be handled in a language without semicolons - just continue the line implicitly if there's an unmatched brace.\n\nWhat happens if the line is terminated early by an extra brace?", "id": "daoyrj7"}, {"comment": "Sounds like a syntax error getting discovered at runtime. ", "id": "dap0jls"}, {"comment": "syntax errors due to unmatched braces.", "id": "dap1mi7"}, {"comment": "Python uses indent to delineate blocks which {} style code does not so line continuation in that case can have ambiguity.  Eevee argues about not using either and doesn't mention how to denote block scope, which would make reading code even more confusing.  ", "id": "dap0bx6"}, {"comment": "The problem is line continuation via escaping the new line is ugly as sin. Whereas semi-colon termination doesn't look ugly.", "id": "dap2vg9"}, {"comment": "> I'm really not able to understand that modern obsession with going semicolonless.\n\nIt's the same reason why the newbie prefers automagical promotion to floating point: it seems to do what s/h/it expected. The newbie doesn't understand that floating point is trickier than integers, or that casting from floating-point back to integer will produce the exact same result, if not the same side effects.\n\nTo wit, the newbie doesn't understand why anyone would write a program in any other way. The newbie doesn't understand why anyone would use pre/post increment/decrement -- except by way of that old rumour among newbies that \"processors used to have pre-decrement and post-increment memory access, so C supported that\", a commonly-believed falsehood just the same as C++ iterator pre-increment being faster than post-increment.\n\nIn the end, the only people who bash C are those who're insufficiently competent to understand it.", "id": "daoy047"}, {"comment": "> In the end, the only people who bash C are those who're insufficiently competent to understand it.\n\n...and people who understand it deeply enough to know it is often not the right tool for the job.\n\nWithin the space of low-level languages, C has one really strong design point, and that's simplicity of implementation. You can write a decent C compiler in a matter of days. That's also what C was invented for \u2013 they didn't want to rewrite Unix for every new computer, so they made a language that was really easy to write a compiler for. Rewriting the C compiler for every new computer was no big deal.\n\nThen of course, C has one really strong cultural point as well: lots of users.\n\nLogical conclusion: when you write a program that you want to be able to quickly port to new or niche architectures, C is a great choice. For most other programs there are better alternatives. For people who's definition of \"porting\" is moving from 32 bit Intel to 64 bit AMD, any number of Ada, D, Rust or others will likely suffice.", "id": "daoy527"}, {"comment": "> You can write a decent C compiler in a matter of days\n\nYou've got to be kidding.\n", "id": "dap42it"}, {"comment": "I read the parent as saying that that was true at the time period they were talking about, even though it's written in the present tense.", "id": "dap6d6y"}, {"comment": "C, as a language, was originally written to be specifically easy to write a compiler for (among other reasons).  The core language was a very thin veneer over assembly (essentially).  And all the undefined behavior / implementation specific behavior also makes it much easier to write the compiler.\n\nBut the language is much more complex today than it was originally, and even back then \"A matter of days\" seems wildly optimistic...", "id": "dape4hn"}, {"comment": "If by 'decent' he meant 'without implementing any form of optimizations, and only for a very specific instruction set', then it's possible if you're already very quick with compiler writing.", "id": "dapeez6"}, {"comment": "> Rewriting the C compiler for every new computer was no big deal.\n\nWell when GCC came it wasn't. GCC had a modular backend to generate object language. There were a few commercial compilers like it, but GCC had the virtue of being open source so had a larger number of people porting it at any time.\n\nA new implementation would take about a month or so depending on the architecture. Some RISC systems were tricky enough to need more.", "id": "dap5xw5"}, {"comment": "> s/h/it \n\nFYI, this is where you use the word 'they' as a gender neutral singular.", "id": "dap2wgn"}, {"comment": "I thought you they were swearing  \n\n\nEdit: Fucking auto complete. *I thought they were swearing*", "id": "dap68rg"}, {"comment": "I'm pretty sure they're being purposefully ridiculous", "id": "dapap0z"}, {"comment": "The post-increment operator in C++ has to return a *new* object, so the pre-increment is preferable if you just want to increment your existing iterator.\n\nGranted, if you don't use the return value, most of the time it'll be optimised away.", "id": "daoy8n7"}, {"comment": "> It's the same reason why the newbie prefers automagical promotion to floating point\n\nNot really; the newbie prefers correct math, which floating point is not. Ideally, there would be automagical promotion to rationals/decimals (just like how Python does the correct thing by automafical promotion to arbitrary precision integers, rather than looping around like C).", "id": "daozhud"}, {"comment": "However, C's treatment of integer arithmetic is correct: where significant, the programmer must account for a remainder. Same as grade school algebra really.", "id": "dap08eb"}, {"comment": "I like to have my arithmetic silently degenerate to the point where `x == x` does not always holds (same for `x+1 > x`) \n/s.", "id": "daozdhz"}, {"comment": "It's attitudes like this that give programmers a bad name.", "id": "dap1xm1"}, {"comment": "> The newbie doesn't understand why anyone would use pre/post increment/decrement\n\nThe funny thing is, those same hipsterish types are complaining about the \"inexpressiveness\" of most languages, and yet scream to death when they see something like `*(p + x) = (a ? foo : bar)() + *q++`. This is the essence of a high-level, \"expression-oriented language\" \u2013 you do many operations in a single statement (where each operation returns a value and can be nested), and the semicolon clearly marks the end.", "id": "daoy6f6"}, {"comment": "When people say they want expressiveness, they're assuming we're talking about the space in which readability is retained (or ideally increased).", "id": "daoyfvq"}, {"comment": "Is mathematical syntax readable to beginners?\n\nReadability is relative to what you *know*. I would personally break up the above statement into multiple lines for clarity &ndash; I strongly believe every line should do its own thing, and complexity-per-line should be maintained consistent, and somewhat low. However, I don't find it difficult to *parse*, even if in my opinion it's too complex to be best expressed that way.", "id": "daoymgw"}, {"comment": "Mathematical syntax (assuming we're speaking somewhat basic algebra/analysis here) have the unfair advantage of purity, which instantly limits the number of possible meanings for any given expression. Branching is also generally encapsulated into more meaningful structures.\n\nThat said, there's a reason most maths expressions are surrounded by English text explanations.", "id": "daoypgv"}, {"comment": "> That said, there's a reason most maths expressions are surrounded by English text explanations.\n\nAnd that's why programming languages support identifier names longer than `a`, `q`, and `N'`. :)", "id": "daoyqis"}, {"comment": "If you want an expressive language, write in APL. Here is one of my recent APL programs:\n\n    ' \u2339'[(\u222a\u2218.=\u2296){\u2375/\u2373\u2262\u2375}\u2283(\u22a2,,)/3*\u233d\u23731+\u2395]\n\nThis program prints something called the [devil's staircase](https://en.wikipedia.org/wiki/Cantor_function) and does so in an elegant and intuitive manner.", "id": "daoz3b6"}, {"comment": "> Quote filing cabinet end quote. Begin square bracket. Open parenthesis, union degrees stop equals glass half full, close parenthesis. Begin curly brace, boobs divided by an iota REALLY equals no boobs, close brace. Horseshoe magnet. Open parenthesis, Tetris, comma, comma, close parenthesis. Divided by 3, multiplied by stile, 1 iota plus box. Close square bracket.\n\nHow'd I do boss!?\n\nEDIT: removed plural 'braces' in favour of the singular. Y'know... For clarity.", "id": "dap3q0m"}, {"comment": "Yeah, that's intuitive. ", "id": "daozu48"}, {"comment": "If you have learned APL, it definitely is. Read [this](http://codegolf.stackexchange.com/a/46919/134) for an explanation of the code.", "id": "daozx1o"}, {"comment": "That argument is specious. The entire reason we're having this discussion is because people seemingly **don't** believe that _if you learned X, you'd understand X_.", "id": "dap07mz"}, {"comment": "Come back a week later, it won't make much sense. At least that's what I remember from APL a long time ago.", "id": "dapd2uu"}, {"comment": "Aargh! Two (or three) side effects in one expression!", "id": "daoyj9b"}, {"comment": "I like your last sentence. In a classic form it would be:\n\nAny complaints come from incompetence.\n\nHonestly, that is what you're going with?\n\nSo the response to your floating point opinion, using the same method, would be: \n\n\"In the end, the only people who claim floating point is tricker than integers are those who're insufficiently competent to understand it.\"\n\nYour statement only tries to make those bashing C feel incompetent, and if you did not know, I can tell you, they (because I, myself, do not bash C) will not accept your little psychological trick as the truth anyway. Just like I suspect you do not feel the constructed response to your float vs int statement would feel true for you.", "id": "dap5dlb"}, {"comment": "Nice demonstration of confirmation bias right there. ", "id": "daoz9bw"}, {"comment": ">  just the same as C++ iterator pre-increment being faster than post-increment.\n\nIt's potentially faster due to temporaries when dealing with objects, I'm unsure as to how that's the same.", "id": "dap16tn"}, {"comment": "This is the only reason why I program in Scheme! No semicolons, and also easy to write expressions over multiple lines (in fact, most expressions do).\n\nInstead, we use semicolons for comments.", "id": "dap0jh3"}, {"comment": "lisps get this right. statements, expressions, and blocks are all delimited with starting and ending markers. this make it unambiguous for both the human and the machine. but everyone shits on lisp for too many parentheses.", "id": "dap3xf1"}, {"comment": "I've never understood this sentiment. I've been programming in Lisp-like languages for years. With all the braces used in c-like languages, it doesn't seem like lisps have more delimiters; rather, delimiters in different places.", "id": "dap98wr"}, {"comment": "But the delimiters are all the same, and common styles pile them up.\n\n        )))))\n\nVs\n\n                 );\n             }\n         }\n    )", "id": "dappmfq"}, {"comment": "> With all the braces used in c-like languages, it doesn't seem like lisps have more delimiters\n\nC:\n\n    bool inBounds = x1 * x1 + y1 * 1y < radius * radius;\n\nDelimiters: 0\n\nLisp:\n\n    (let ((in-bounds (< (+ (* x1 x1) (* y1 y1)) (* radius radius)))))\n\nDelimiters: 16\n\nThere's a lot to like about s-exprs, but they really do involve a lot more explicit delimiting. Implicit delimiters is effectively what having precedence *means*. If you have operator precedence, like C, you're going to have fewer parentheses.", "id": "daq44ex"}, {"comment": "It's about IDEs. Writing LISP with the wrong IDE is horrible. ", "id": "dapok1k"}, {"comment": "I actually like Rust's approach here: semicolons then expressions into statements. If you omit the semicolon in Rust and it's in statement position, you're returning that value from the function.\n\nThis let's you do stuff like this:\n\n    // conditional assignment\n    let x = if condition {\n        y\n    } else {\n        z\n    };\n\n    // conditional return\n    if condition2 {\n        x + 1\n    } else {\n        x - 1\n    }\n    // no statements allowed\n\nI prefer this to C semicolons because they have more meaning. I agree with the assertion that you can easily design a language without semicolons, but you can also build one around them, so really the problem is up to language designers and you can't just lump it all under the umbrella of \"unnecessary syntax\".\n\nAs for parsing, to can always go the route Go chose and add them in during parsing.", "id": "dap3xs0"}, {"comment": "I'm not sure if that behaviour goes any deeper than in your example. But for that specific example I think C's ternary operator is just as readable:\n\n    int x = condition ? y : z;\n\nMuch shorter too even with the semicolon", "id": "dapbq1b"}, {"comment": "`if ... { ... } else { ... }` effectively *is* the ternary operator in rust when the last expression in each of the two blocks doesn't have a semicolon. It makes more sense when compared to other conditional expressions (e.g. `if let` and `match`) and when there are multiple statements in the blocks and the blocks then end with an expression. The other form [was removed][0]. There was also a [discussion about adding it back][1].\n\n[0]: https://github.com/rust-lang/rust/issues/1698\n[1]: https://github.com/rust-lang/rfcs/issues/1362", "id": "daphxtl"}, {"comment": "(if condition y z) ", "id": "dapib04"}, {"comment": "Yup, there's nothing truly unique in Rust except for having everything in one place.  I really like how they essentially took concepts from functional languages (like lisp) but put it in a procedural language with other fancy features.", "id": "dapipzi"}, {"comment": "This was definitely the weakest argument in the original (eevee) article.  I love Python, but I don't think every language needs to be Python.  \n\nSignificant whitepace comes with it's own annoyances.  If you're following PEP8 (4-space indents,  79-char limit,  descriptive snake-case variable names, spaces around operators) it doesn't take much to need a multi-line statement.  I've learned to work with it, but sometimes it's a net loss for readability.", "id": "dapkn0t"}], [{"comment": "If you think C is shit, don't use it, for most purposes it's not the best language nowadays. But there are a lot of legitimate reasons for using C, and it's not going away soon. \n\nSpend your time making nice stuff instead of endless debating.", "id": "daoyunw"}, {"comment": "> instead of endless debating.\n\nIt gives redditors something to do and keeps them off the streets.", "id": "dap0afn"}, {"comment": "Kids who code and debate don't steal or deal. ", "id": "dap6g66"}, {"comment": "I would beg to differ as a programming drug dealer that was on the debate team ", "id": "dapp4za"}, {"comment": "This article is not about C (and the article it's responding to isn't, either). It's about all the other programming languages that copy C for arguably no good reason beyond cargo cult, or for a good reason, depending on which side of the debate you're on.", "id": "dap1e6l"}, {"comment": "C will probably outlive many of us.", "id": "dap336w"}, {"comment": "> C will outlive all of us.  \n\nFTFY", "id": "dap4qp6"}, {"comment": "If not all of us. There are still COBOL programmers out there! Not many tleft but still.", "id": "dap4x67"}, {"comment": "I've recently learned about RPG, a language that was supposedly made to simulate work with punchcards.\n\nPUNCHCARDS.\n\nApparently really ancient finance systems still worked this way when programming was in the stone age.\n\nPUNCH. FUCKING. CARDS.\n\nFrom what I've heard there's like a 1000 people total who know the language.", "id": "dap51wj"}, {"comment": "I just started a job programming in RPG. After 15 years of Java, it's a bit of a culture shock, but it's an easy language to learn. The older fixed format code resembles assembly, while the newer free format code resembles BASIC.\n\nAs an exercise, I wrote an implementation of the MD5 hashing algorithm in modern free-form RPG if you're curious to see what the language looks like: https://rosettacode.org/wiki/MD5/Implementation#RPG", "id": "dap856r"}, {"comment": "RTFA. It has nothing to do with using or not using C, but what parts of C should be ignored when designing modern programming languages. ", "id": "dap5det"}, {"comment": "That's a straw man, the eevee blog post wasn't trying to convince people to stop using C. It was complaining about the tendency of new languages to copy C's design decisions without carefully evaluating whether that is indeed the best solution. It seems unwise to endlessly keep repeating the mistakes of the past.", "id": "dapq23p"}], [{"comment": "I'm down for criticizing C. This article should be titled \"Let's stop using bikeshedding arguments like whitespace vs semicolons+braces when there are much more important flaws to discuss\"", "id": "daozctp"}, {"comment": "That discussion has already been had a generation ago. Today the participants don't know what the results were back then. Consequently instead of \"more important flaws\" being discussed we have people going around in circles unable to make a bloody decision if their life depended on it, and rehashed myth from cryptopartisans, each hoping to push people off C and into a fat runtime / fat syntax / scripting toy / omniscient IDE / B&D / otherwise not-C language.\n\nFunnily, the current (i.e. since the mid-aughties) upswing in C's popularity is a direct consequence of the previous generation's \"better than C, because [quirk]\" languages. The prior examples were Java, Delphi, Python, C++, Ada, and all the Java/C++ hybrids such as D, respectively. Turned out that lots of people really prefer C to the startup time, the hojillion dependencies per program, extra syntax noise for \"readability\", opaque semantics for \"ephemeral copies\", and so forth.", "id": "dap0hip"}, {"comment": "Has C really been gaining popularity recently?  Everything I have seen is C++ and C# making gains in popularity.  Even in the open source Linux desktop C++ is making gains against C.", "id": "dap5ddb"}, {"comment": "> there are much more important flaws to discuss\n\nBut apart from the aqueduct, the sanitation and the roads...\n\nWhat has C ever done for us?!", "id": "dapn525"}], [{"comment": "Bashing C is pointless, but so it is defending its \"simple, beautiful design\". \n\nIf you read [The Development of the C Language](https://www.bell-labs.com/usr/dmr/www/chist.html) written by certain [Dennis M Ritchie](https://en.wikipedia.org/wiki/Dennis_Ritchie) you'll see that basically there was no design there - it was a hack on top of a hack; evolution at its best (or worst). From that paper:\n\n> \"In 1971 I began to extend the B language by adding a character type and also rewrote its compiler to generate PDP-11 machine instructions instead of threaded code. Thus the transition from B to C was contemporaneous with the creation of a compiler capable of producing programs fast and small enough to compete with assembly language.\"\n\n> \"After creating the type system, the associated syntax, and the compiler for the new language, I felt that it deserved a new name; NB seemed insufficiently distinctive. I decided to follow the single-letter style and called it C\"\n\n> \" As should be clear from the history above, C evolved from typeless languages. It did not suddenly appear to its earliest users and developers as an entirely new language with its own rules; instead we continually had to adapt existing programs as the language developed, and make allowance for an existing body of code.\"\n\nAnd finally, the best summary from the man himself:\n\n> \"C is quirky, flawed, and an enormous success\"", "id": "dap2x4t"}, {"comment": "[deleted]", "id": "dap4ufy"}, {"comment": "Well it was a very honest comment from Ritchie.", "id": "dapcke7"}, {"comment": "C can be crazy, but almost everyone is using more strict standards like ANSI, so there's a bit of a straw man when people list that as a downside to C.", "id": "dapsjdr"}], [{"comment": "And let's start Cing BASH.\n\nNote: I'm very sorry to bring such bad humour into a serious post. Please don't downvote this even if you don't upvote it. I just had to say it somewhere and it lacks context anywhere else. Let it thrive here in its cozy little corner for the rest of time.", "id": "dap1fl0"}, {"comment": "we already bashed c, that's how shells started. ", "id": "dap5k04"}, {"comment": "If you *C* your *BASH*, you will get *CSH* ;)", "id": "dap8vhi"}, {"comment": "A great example of why Cing Bash is a bad idea", "id": "dapjhsu"}, {"comment": "Okay, I'm glad I only had to scroll a little bit down to find a joke about that.", "id": "dapafq3"}], [{"comment": "C is imperfect, but most of the critics are no better. They're just stabbing in the dark, based on their opinions. The fact is that C is old, it is successful, precisely because it does more things right than it does wrong. The same often can't be said for new languages.", "id": "daoxsps"}, {"comment": "Use the right tool ~~foe~~ for the right job. It's not that hard.\n\nBut some people either want to use the one language everywhere (javascript) or every language in one place in a horrendous mishmash of code paella", "id": "daozbzf"}], [{"comment": "Meh. No, let's bash C. There's tons of ~~valud~~valid complaints. It's not exactly the fault of C, but of the state of the compiler tech 40-50 years ago, and the overall state of the computing, really.\n\nBack then, it was a **very** good compromise. Nowadays, so much less so.\n\nAnd yes, some desisions are just wrong, wrong, wrong (e.g. precedence).\n\n>  I\u2019m no Python expert, but I\u2019ve run into hard-to-debug errors several times because I\u2019ve cut and pasted some code into my function during refactoring, and it misbehaved because of the indentation that didn\u2019t happen to match the then-current indent level.\n\nCopy-pastes code, complaints it doesn't work. Not cool!", "id": "daoy3au"}, {"comment": "Once you're done bashing C, I have some very, very dead horses I bet you'd be thrilled to see.", "id": "daoz79r"}, {"comment": "The original article was bashing *things that come from C* that are still done in modern languages. The point was not \"C sucks\" rather \"which languages copied C's bad decisions?\".", "id": "dap37yu"}, {"comment": "Then let's bash assembly while we're at it. Why did they ever invent that? Only a compromise and sad state of computing 50 years ago?", "id": "dap08ch"}, {"comment": "No, but lets bash modern languages that try to emulate assembly for no good reason other than that is how it was always done.\n", "id": "dap91zu"}, {"comment": "He/she's not talking about copy/pasting random code from the internet, they're talking about copy pasting code from a function they wrote to another place in their codebase for refactoring. Why shouldn't this just work straight away?\n\nI really think that of all the languages to compare C to, Python really isn't the best choice haha", "id": "dap3rq9"}, {"comment": "Finally someone mentions the core issue. The compiler! I see so many <insert random language> programming experts talking about why this language it's bad and why theirs is better. Few of them could even begin to start explaining how the language works the way it does. The defined grammar and compiler rules don't even exist to them.  C is good when it's used for the reason that it was created. But you want to make some non embedded software? Use a language that better fits your application. ", "id": "daoyjfy"}], [{"comment": "As someone who codes in python quite a bit I have to say:\n\n\"In a language where whitespace is significant, automatic indentation becomes literally impossible, which is very annoying. I\u2019m no Python expert, but I\u2019ve run into hard-to-debug errors several times because I\u2019ve cut and pasted some code into my function during refactoring, and it misbehaved because of the indentation that didn\u2019t happen to match the then-current indent level.\"\n\nI _never_ have hard to debug problems because of this. This speaks to unfamiliarity with the convention, more than to an inherent flaw. When you copy paste code into a new context you need to make sure it fits the context. In C that means making sure the braces are right (and then adding indentation for readability) in Python it means making sure the indentation is right (which means selecting the pasted block and hitting tab the correct number of times).\n\nMaybe it's because I have very little C experience, but I really fail to see how this is substantially different.", "id": "daoydmh"}, {"comment": "My preferred language is C++, but I've used Python a fair bit too, and I agree. I've never run into any issue with whitespace indentation.\n\n(I have run into issues with braces)", "id": "dap07fc"}, {"comment": "It happens to me constantly, I guess it probably wouldn't if you were very mindful of indentation.\n\nI probably rely on auto indent too much, but sometimes I accidentally delete an indent at the end of a block and go crazy trying to find the issue. It's much harder to accidentally move a statement outside of a curly brace.", "id": "daoywxw"}, {"comment": "When you copy and paste python, it's up to you to make sure the indentation is correct. \n\nWhen you copy paste C, you can just run auto indent on the file and it becomes obvious if there's a mistake or not. ", "id": "dap358n"}, {"comment": "I am a C programmer who is not a fan of Python and its conventions, but I agree with you. Of all things I find annoying in Python the significant whitespace is not one. As you say it is just another convention to learn.", "id": "dap0wgk"}, {"comment": "The way I figure it: I would be doing the indentation anyway, so why not make it meaningful, in and of itself?\n", "id": "dapbco1"}, {"comment": "Because you can't even recognise which statements belong where if you're copy / pasting large amounts of code.\n\nI've been using Python a lot lately, and auto indent really fucks my day up sometimes, especially if I'm switching between 2 spaces for indentation and 4 spaces.\n\nIn C, switching between the two is easy, 1 command to specify the indentation size and a shortcut to reindent everything on the page.\n\nWith Python, if you ever (god forbid) get a mix of the two somewhere:\n\nif (asd):\n    statement\n    statement\n  statement # oops\n\nasdasd\n\nThat statement might get pushed out of the if. Debugging this is an insane task, when you have to understand every line of the code before being able to find out where it should be indented??\n\nThe real problems come with pasting a 2 space indent into a 4 space indent file.", "id": "dap3kd2"}, {"comment": "Copying and pasting code, of course, being a solid programming pattern that language designers should take into account and encourage.", "id": "dap7v65"}, {"comment": "What are you on about mate\n\nNobody's saying you should copy and paste huge amounts of code off of a blog into your codebase and cross your fingers. But you'd have to be pretty silly to think that nobody ever copies and pastes code, I do it all the time, how else do you refactor functions...?", "id": "dapgrec"}, {"comment": "Well, the python style guide is unambiguous that indentation is done with four spaces. I can totally see how 2 spaces files would be a mess.\n\n> Because you can't even recognise which statements belong where if you're copy / pasting large amounts of code.\n\nI don't understand that point. Usually I take python code, paste it to its new location, select the block of pasted code and hit tab once or twice to bring it to the correct level. I never manipulate individual lines when copy pasting code. This means the relative location of the indentation levels is preserved, and it's visually immediately obvious if I have pasted correctly.\n\n    if True:\n        a = 1\n    b = 1\n\nOops, I ment the copy paste to end up in the if block, mark it, hit tab:\n\n    if True:\n        a = 1\n        b = 1\n\nvoila. If it's a long complicated nested statement I am pasting I still need to only ever check the location of the first line relative to the preceding line. Nothing else. Obviously some people have a workflow that is incompatible with this, and apparently it has to do with using auto indenting intended for C on Python code (???). But I still don't really get where the problem arises.", "id": "dap9q84"}, {"comment": "That's exactly the point that the author was trying to make with this example. ", "id": "dap0r0p"}], [{"comment": "I think a lot of commenters are missing the point of eevee's article. It's not that C sucks. C is fine for the kind of uses it is applied to. The point is about high level languages copying features from C that they shouldn't have. There is no reason Javascript has it be such a screwed up language for example.", "id": "dap3gpl"}, {"comment": "Poor example. JavaScript \"fixes\" division in the way Eevee suggests, which makes arithmetic broken. There's plenty of criticism to level at C (and every other language for that matter), but when the criticisms include \"can't use emoji\", or \"I don't understand integer division\"  or \"it should use semantic white space\" or \"I have a pet peeve with the ! operator\", it's just kind of a lame article that fails to make any point at all.", "id": "dap9t00"}, {"comment": "Optional semicolons in javascript also introduce opportunity for errors.  Yet another \"fix\" of C semantics that causes more problems than it solves.", "id": "dapdju8"}, {"comment": "Yeah, like \n\n    []+{}            // \"[object Object]\"\n    {}+[]            // 0\n    {}+[] === []+{}  // true", "id": "dapit3e"}, {"comment": "[wat](https://www.destroyallsoftware.com/talks/wat)", "id": "dapixf2"}, {"comment": "The cool thing is I learned a whole hell of a lot about JavaScript trying to understand WATs like these.  As inconvenient and \"broken\" as they are they still fascinate me.", "id": "dapj0b8"}, {"comment": "Division isn't \u201cfixed\u201d in Javascript. It's just that Javascript's only numeric type is an IEEE 754 double precision floating point number.", "id": "dapb4sc"}, {"comment": "My point is that it's not a fix, and even introduces more subtle errors that most people wouldn't expect or understand. Ie. Add 0.1 and 0.2, get 0.30000000000000004.\n\nMaking everything a float by default is a shitty solution. Making values implicitly cast between integers and floats is a shittier solution. Integer division should return an integer, unless we explicitly cast. That's predictable behavior.", "id": "dapfz92"}, {"comment": "Of course it isn't. It's just that Javascript doesn't have integers. It doesn't make sense to have integer division semantics in Javascript when there aren't even integers.", "id": "dapg3jm"}, {"comment": "> can't use emoji\n\nThat criticism is a way of expressing to an english audience that non-english characters fail. Being unable to input a poop emoji is a minor niggle which also implies that a user not typing in the latin alphabet simply cannot communicate.", "id": "daphp8p"}, {"comment": "Are you saying that Javascript is screwed up because it copied features from C that were better left out? I think there are a lot of other reasons Javascript is screwed up outside of that.", "id": "dapafsc"}], [{"comment": "There's a difference between rationalizing and justifying. Most of these posts that defend C are rationalizations.\n\n\"What's so bad about X?\" is not an argument in favor of X, it's an argument against removing X from C. Nobody is suggesting that we change C.\n\nHowever, in order for X to be considered for a new language, it needs to be able to stand on its own legs. Merely citing it's existence in C is not good enough. Yes, every language feature of C has a purpose, but is that purpose still relevant 40 years later? If C didn't exist, would we still choose to do things this way?", "id": "dap1wux"}], [{"comment": "A pet peeve. Spot the difference:\n\n    if (looks_like_rain()) {\n        ...\n    }\n    if (!looks_like_rain()) {\n        ...\n    }    \n\nOh, **come on**. Learn to read code, what the fuck. do you want, an all caps operator? THECONTRARYOFTRUEWATCHOUT( *expression* )", "id": "dap532q"}], [{"comment": "I think that the point of the first article was not to bash C itself, but to discourage new languages to bring aspects from C (and C++) without giving too much thought.\n\n*My* opinion is: do not create a new _serious_ language, unless you are a \"Guido van Rossum\"-like character, *and* you know deeply about the advantages and flaws of all main programming languages. There are too many languages already, and new ones are appearing by the bunch.\n", "id": "dap5v1j"}, {"comment": "Guido probably didn't know he was a guido-character until he became one", "id": "dapf0ca"}, {"comment": "> There are too many languages already, and new ones are appearing by the bunch.\n\nIs that necessarily a problem?  Languages are not a limited resource.  Having \"too many\" doesn't cause much harm, in and of itself.", "id": "dapdop4"}, {"comment": "But this rush to create the next big thing results in lots of rushed garbage being released and none of it has any real time or thought put into it. And then we end up with terrible industry standards like Javascript.", "id": "dapgp4h"}], [{"comment": "I didn't see the original post (Eevee's) as bashing C, so much as bashing languages that copy C (for no apparent reason).  The more different a language is from C, the easier it is to justify.  Someone who takes C and modifies one little syntactic thing isn't really making a new language.  Someone who genuinely makes a new language, a new way of accomplishing a task or a fundamental different way of thinking about a process, someone who makes that and then *hides* the newness behind C's syntax is unnecessarily making it harder to learn.\n\nC has its place, and I use it.  Designers of other languages (and programmers considering other languages) should have a good reason for being the same as C in some respect, but still not just use C.", "id": "dap6vs4"}], [{"comment": "[deleted]", "id": "dap3vkz"}], [{"comment": "While you have arguments about whether C shall be bashed or not, I'm sitting in my office being productive writing C code. I see that as a superior use of my time.", "id": "daozeok"}, {"comment": "This.\n\nI've been using C since 1979. I went through the bad old \"near / far pointer years\" in the 80s, the \"what's a standard library?\" days up until the first C standard came out, and the \"let's use C++ instead . . . wait, nope, that sucked\" days (which are still kind of going on, quite frankly). I've worked with wannabe-C languages and they mostly stunk because they didn't capture what was great about C while at the same time they added useless bullshit in an attempt to fix what wasn't broken. Okay, actually I've been doing mostly C++ since 1990, but you get my drift.\n\nEevee has maybe a couple good points. The rest is just whining. The bit about integer division is a howler; C is close to the machine, and this is how machines bloody *work*, okay?\n\nThere are a lot of crappy C programs out there. One of my cow-orkers is wrangling some FOSS code that generates more warnings that there are lines of source; apparently the author didn't think that warnings weren't worth paying attention to, holy fuck. I've worked with bozos who decided that the C preprocessor was there to be abused, and I wish I'd been able to fire them (we definitely threw away their output, after it was more of a pain to work with than just rewriting it).\n\nOn the other hand, there's a lot of *really good* C code out there, written by people who grok the language, do a great, clean and professional job, and you don't see most of this code because it just works. It's ubiquitous, and much of it is at the base of technologies that prop up the modern world.", "id": "dap1crs"}], [{"comment": "Overall, I liked most of eevee's article (though there's clearly some Python bias as that's her favorite language I would presume), and also agree with the points raised in this blog post as well.\n\nI posted a breakdown of my positions on eevee's points [here](https://twitter.com/byuu_san/status/804368450554646529), if for some reason anyone cared.\n\nIt's good to challenge deeply held beliefs from time to time, and have discussions like this.\n\nWhat always becomes very apparent is that there's clearly no one language that is going to be perfect to everyone. Yet by hearing viewpoints from many people, we can get a feel to design more successful languages in the future.", "id": "daoz721"}], [{"comment": "It is not the syntax of C that is bad, it is the semantics.\n\nIt is almost impossible to write secure string handling code in C.", "id": "dap124d"}, {"comment": "There are syntax design mistakes in c, too.\nThe string insecurity is partly unchecked array bounds(a very desired feature in a low level, \"bare metal\" language for high performance), but mostly very badly designed libraries.\n\nNull terminated strings are a mistake(they're mostly library though, and only a language issue due to string literals, but a simple macro fixes that). Pascal strings are safer and a library based on Pascal strings and buffers would be far safer.", "id": "dap4497"}], [{"comment": "Author seems to conflate \"bashing C\" with \"inventing a different language\".", "id": "dap2le2"}], [{"comment": "If they hate C so much, then stop bootstrapping your new-fangled languages in it.  :-) ", "id": "dap3qau"}, {"comment": "I think that will actually happen. Language runtimes and compilers do not have to be in C, and probably many are in C++ today, including even C compilers. I think world is ready to leave C behind for new projects, and people look at things like Rust and Go instead as compiled languages that offer more safety for low cost.", "id": "dap4g8q"}], [{"comment": "Semicolons are a waste of time Imagine all the times you have had to type a semicolon Now take all those milliseconds and add them up throughout the length of your programming career The savings are significant And every keystroke you type leads you one step closer to arthritis\n\nI propose that in the English language we stop using full stops They are totally unnecessary in the modern world We don't read out loud anymore Thus we have no reason to have a directive in our text that explicitly tells us to stop In the same way that semicolons are a waste of time imagine all the milliseconds you've wasted typing periods at the end of sentences The savings are significant", "id": "dap4n47"}, {"comment": "Spaces too.", "id": "dap8d0f"}], [{"comment": "I think a lot of people misunderstand a lot of what makes c great and ubiquitous.\n\n1. features and updates are very conservative\n\n2. the standard is pretty small and is designed to make writing a compiler for a new system easier\n\n3. it is not handcuffed, and doesn't assume the author is a dumb chimp that needs to be told how to do things the \"right\" way\n\n\nIt is not the only language available, lot's of other choices. It isn't written for or needed by \"newbs\". Yes anyone can make simple mistakes, but with rigid and disciplined styles/convention/testing can greatly reduce errors. It is not only, not for every application, it is also, not for every programmer.", "id": "dap0lj4"}, {"comment": "> the standard is pretty small and is designed to make writing a compiler for a new system easier\n\nI have to respectfully disagree here. It's like 600, very dense, pages. I'd argue that writing an LLVM backend is probably easier, though that's baseless speculation. Granted, the language itself (before the library) is only like 160 of those pages, but you do still have to untangle things like:\n\n>    EXAMPLE 3    To  illustrate the rules for redefinition and reexamination, the sequence\n\n    #define x      3\n    #define f(a)   f(x * (a))\n    #undef  x\n    #define x      2\n    #define g      f\n    #define z      z[0]\n    #define h      g(~\n    #define m(a)   a(w)\n    #define w      0,1\n    #define t(a)   a\n    #define p()    int\n    #define q(x)   x\n    #define r(x,y) x ## y\n    #define str(x) # x\n    f(y+1) + f(f(z)) % t(t(g)(0) + t)(1);\n    g(x+(3,4)-w) | h 5) & m\n    (f)^m(m);\n    p() i[q()] = { q(1), r(2,3), r(4,), r(,5), r(,) };\n    char c[2][6] = { str(hello), str() };\n    \n>results in:\n\n    f(2 * (y+1)) + f(2 * (f(2 * (z[0])))) % f(2 * (0)) + t(1);\n    f(2 * (2+(3,4)-0,1)) | f(2 * (~ 5)) & f(2 * (0,1))^m(0,1);\n    int i[] = { 1, 23, 4, 5,  };\n    char c[2][6] = { \"hello\", \"\" };\n\n(The whole preprocessor section in general is pretty neat IMO)", "id": "dap1uw3"}], [{"comment": "It might be better to say \"let's stop bashing programming languages.\" Pick a programming language and *someone* will be more than happy to provide you with a long-winded rant about how it's the worst thing since sexually transmitted diseases. \n\nVirtually all programming languages have their strengths and weaknesses, and if you don't like a language then don't use it. C in particular isn't really all that bad. Sure, it's missing some niceties present in more modern languages, but it's still possible to do most anything you can think of in C. Then again, I'm a big fan of assembly, so maybe I'm not the best person to ask.", "id": "dap98di"}], [{"comment": "People who bash C don't work on drivers. People who do work on drivers find this amusing. Sometimes we even write *assembly*. ", "id": "dapfmph"}, {"comment": "Exactly what I was thinking. Enterprise developers don't understand the embedded world. Articles bashing C always make me laugh.", "id": "dapir6p"}, {"comment": "Go team goto :)", "id": "dapivkn"}], [{"comment": "The original purpose of C was to be a tiny abstraction above assembly language.  C has functions because processors have call and ret instructions.  C has ++ and -- because processors have inc and dec instructions. C has ints and floats because processors have ints and floats.\n\nMy main gripe with C today is that it never kept up with the processors.   long long is not a good solution to the increasing range of register sizes.  There is no vector support.  A lot of this is solved with extensions and libraries, but it should be standard by now.  Instead the standard seems to be the most common denominator.  It will work on little 8 bit cpus or multicore monsters.\n\n", "id": "dap1tp5"}], [{"comment": "Let's stop C-ing bash. ", "id": "dap5shm"}], [{"comment": "Eevee's article was well reasoned and thorough. This response is anything but.\n\n> What\u2019s Wrong with Integer Division?\n\nNothing, which is why eevee pointed at Python and Dart which have explicit integer division operators. Would you rather write `a ~/ b` or `a / (double) b` in general?\n\nThe author didn't read the original post in any detail and jumped to the conclusion that eevee wanted to eliminate integer division.\n\n> What\u2019s Wrong with Increment/Decrement?\n\nAs statements? Nothing. As expressions? I've been programming for fifteen years and I refuse to use increment and decrement as expressions. It would be like not just allowing but *recommending* code like\n\n    double y = 2;\n    double x = pow(y, y = y  * 2);\n\nWhat's the result? That depends on the order of execution. Normal code has far less dependency on order of execution within a single expression, and that makes it easier to read. But this snippet requires me to understand more of the minutiae of the compiler.\n\nIt costs me literally nothing to write `x++; foo(x)` instead of `foo(x++)` or `foo(++x)`, whichever it happens to be. Pre/post-inc/decrement are better defined, but that doesn't reduce the amount of cognitive work I need to do. It just means I look at a different section of the language spec.\n\nThe author's response to someone's complaint about this is that people who don't like it should go code in C for a few years. Dismissive and snide.\n\n>     return\n>     1 + 2\n\n> Should it return unit, or should it return 3?\n\nIf you take a language without significant whitespace and with explicit delimiters, write some code that wouldn't pass code review, then remove delimiters without making whitespace significant, it doesn't work. My goodness! Shock! Horror! Flabbergastery! Who would ever suggest using whitespace instead of semicolons when *this* happens if you use **neither**?\n\nThis isn't even an attempt to be convincing.", "id": "dapv1bs"}], [{"comment": "I found one thing funny:\n\n> There is a prefix and a postfix variation of them that\n> do slightly different things. The usual semantics is\n> that the prefix ones evaulate to the already-modified \n> expression, while postfix ones yield the original value.\n> This can be very convenient, as in different contexts,\n> code might require the value of one state or another,\n> so having both versions can lead to more concise\n> code and less off-by-one errors.\n\nI conider that confusing for beginners - so actually, the original point still stands - C IS complex! :)\n\nI think this is also ok. It just should not be advertised as a super-simple language.", "id": "dapbzhw"}], [{"comment": "Society is already divided, now more than ever, what better than yet another C argument.\n\nC is not for everything, I think the issue here is that people are bashing C for the wrong reasons, reasons that are already solved by another languages, and that's fine too. If we pretend that C solves every problem and is designed for every application, then yeah, it has a lot of disadvantages, but that's not the case.\n\nCase in point is one of the most used languages in the word (Linux Kernel for instance), is the closest language to ASM where you basically can predict how the assembly would be and it's the father of most of the languages right now. Still relevant, old yes, but not obsolete. So let's not pretend it's perfect, and also let's not pretend and it's obsolete and useless neither. Can we agree on that?", "id": "daoybzk"}, {"comment": "> is the closest language to ASM where you basically can predict how the assembly would be\n\nyou have no idea what you're talking about if you think you can predict the assembly output of a modern C compiler or if you think it even matters", "id": "dap0t95"}, {"comment": "Quite a few embedded systems make assumptions about the type of code the compiler generates, at least in certain circumstances.\n\nI've interviewed many embedded engineers. One of my favorite questions is what \"volatile\" actually does. Blank stare = no hire, but you *can* have a very long discussion indeed about what an optimizing compiler is permitted to do, and it's a real eye-opener.\n\nSo generally what embedded folk do is examine what the compiler generates and hope that it doesn't change too much. And it won't, because the compiler vendor knows its customers, and that \"Our code is busted with your compiler update and we need to ship next week\" isn't best answered with \"Suck it up, our language lawyers said that whole-program optimization was okay\".\n\nI've used assembly on two projects in the last decade, probably less than a thousand lines, total. I used to write that much assembly in a week, back in the 80s. Things have definitely improved.", "id": "dap1q2j"}, {"comment": "> One of my favorite questions is what \"volatile\" actually does.\n\nThis is an excellent example of what I'm talking about, because volatile has no well-defined function except providing a very vague implementation-defined hint to the compiler. There is a lot of abstraction between C code and assembly these days.", "id": "dap2lvs"}, {"comment": "That has become a big problem recently\n\nIn the past you knew, int, float and pointer are 32-bit values on your system, so you can cast the float* to an int or an int* and then get the mantissa from some bits of the int. Nowadays the compiler says, no, no, fuck you, an int* is not float*, so I will optimize it all away, be happy that I do not override the program with cat pictures, because I am allowed to that.", "id": "dap4omd"}, {"comment": "The linux kernel standardizes on a compiler and a version of that compiler, one of the advantages of doing so is knowing what the assembly is going to be.", "id": "dap1qp1"}], [{"comment": "Why are you complaining about integer division!? We have integer division because it's fast compared to using floating point numbers; which is an actual hardware design constraint with floating point numbers. There's that, and some microcontrollers, which are programmed mostly in C, do not have any hardware support for floating points. They're instead simulated in software making it very, very slow. ", "id": "dap1xc7"}, {"comment": "> We have integer division because it's fast compared to using floating point numbers;\n\nThis was true decades ago, but this is not the case any more (at least on modern common PCs).", "id": "dap3bnc"}], [{"comment": "I like IDEs that tell me when i miss a simple typing errors before committing to a test or some other time consuming process. I guess it's not super cool to use advanced tools, but it makes a lot of these semantic arguments seem like a giant waste of effort. ", "id": "dapfxea"}], [{"comment": "/bin/bash C\n\nDid I just bash C?", "id": "dap5ueh"}], [{"comment": "Sounds like tilting at windmills to me. Thin skinned author with shares of C stock? (Whatever that is.)\n\nThere has never been a language invented that didn't *instantly* and *forever* have critics. Use what you love or what you're paid to use. ", "id": "daperfv"}]]], "5fwx1s": ["Visual Studio toolkit will build bootable apps", "2016-12-01 17:47:00", 39, "http://www.infoworld.com/article/3146205/microsoft-windows/cosmos-looks-to-make-net-apps-soar.html?idg_eid=df97dd9f0fcf9f53d37214de9758d408&token=%23tk.IFWNLE_nlt_infoworld_developer_2016-12-01&utm_source=Sailthru&utm_medium=email&utm_campaign=InfoWorld%20App%20Dev%20Report%202016-12-01&utm_term=infoworld_developer#tk.IFW_nlt_infoworld_developer_2016-12-01", [[10, "Honestly, when I first stumbled upon this a few years or so ago, I assumed that this was just a hobby project, like some game engine that was continuously developed, has impressive demos, but is never actually used in real game development and exists only as a technical demo, or to otherwise prove a point.  \n\nCongrats.  I'm seriously impressed with this effort.  "], [6, "Cosmos?\n\nI saw that project YEARS ago back in college and thought it was super cool. Is it still being developed? I thought it was dead..."], [1, "Is this that midori OS from a long time ago?"], [1, "Holy buckets that's cool. Does anyone know if Cosmos is derived from Midori (and X# a variant of M# or whatever the Midori language was?) or developed parallel to it?"], [1, "Awesome, I haven't looked into this in detail but at first glance it reminds me of the Spin OS paper (protection domains via language/compiler enforcement) "], [-2, "Is that a variant of comic sans? :o"]], [[{"comment": "Honestly, when I first stumbled upon this a few years or so ago, I assumed that this was just a hobby project, like some game engine that was continuously developed, has impressive demos, but is never actually used in real game development and exists only as a technical demo, or to otherwise prove a point.  \n\nCongrats.  I'm seriously impressed with this effort.  ", "id": "danmeoe"}, {"comment": "It does sound pretty cool. It just makes me smile though because from how it's been described to me (so correct me if you know better), MS-DOS wasn't really a kernel in the traditional sense, every program was linked against all the code it needed to interact with the hardware while it was running. DOS was basically a file management shell, an application loader/launcher and a runtime library. There was no user/kernel space and the CPU hardware didn't make such distinctions. You did basically boot into apps when you launched them.\n\nSo I smile because this project sounds like a return to that, and you can even program it in basic! I don't mean to sound like I'm criticizing it, I think this model of software design could certainly have advantages in many scenarios. It's just funny when you consider the history.", "id": "daos0z5"}], [{"comment": "Cosmos?\n\nI saw that project YEARS ago back in college and thought it was super cool. Is it still being developed? I thought it was dead...", "id": "danv2c6"}, {"comment": "I think that's the fundamental issue between large projects and the general public.  People lose interest in projects that don't provide flashy results after a week and if the progress is slow, they think that there is very little development and that the project is dead.  I don't know if that's just the nature of things or the bad influence of web-related projects, which have life cycles shorter than most people's attention.", "id": "daodzns"}, {"comment": "While I agree.. this project has been in development for 10 years and has not reached an initial release...\n\nIf I knew anything about OS dev, i would have forked long ago.", "id": "daofdx3"}, {"comment": "Personally, I don't care if it ever gets a release beyond the previews.  MS is learning a boat load from projects like these, which makes them create wonderful things like Roslyn.", "id": "daomcd7"}], [{"comment": "Is this that midori OS from a long time ago?", "id": "dao8wys"}, {"comment": "No.", "id": "daoe0x4"}], [{"comment": "Holy buckets that's cool. Does anyone know if Cosmos is derived from Midori (and X# a variant of M# or whatever the Midori language was?) or developed parallel to it?", "id": "dao9u79"}, {"comment": "Nope, it's a completely different project with quite different goals.\n\nAlso x# has nothing to do with c#, it's actually just a high level assembler for x86.", "id": "daobcpw"}], [{"comment": "Awesome, I haven't looked into this in detail but at first glance it reminds me of the Spin OS paper (protection domains via language/compiler enforcement) ", "id": "daolw98"}], [{"comment": "Is that a variant of comic sans? :o", "id": "danna61"}]]]}