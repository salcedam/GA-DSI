{"4hndq3": ["Go and Quasar: a comparison of style and performance", "2016-05-03 18:01:55", 3, "http://blog.paralleluniverse.co/2016/05/03/skynet-go-quasar/", [[5, "I just implemented this with Rust:\n\n    extern crate rayon;\n    \n    use rayon::prelude::*;\n    use std::sync::mpsc::{channel, Sender};\n    use std::time::Instant;\n    \n    fn skynet(c: Sender<u64>, num: u64, size: u64, div: u64) {\n        if size == 1 {\n            c.send(num).unwrap();\n            return;\n        }\n    \n        let (tc, rc) = channel();\n        let mut sum = 0;\n        (0..div).map(|i| (i, tc.clone())).collect::<Vec<_>>().into_par_iter().for_each(|(i, tc)| {\n            let sub_num = num + i * (size / div);\n            skynet(tc, sub_num, size / div, div);\n        });\n        for _ in 0..div {\n            sum += rc.recv().unwrap();\n        }\n        c.send(sum).unwrap();\n    }\n    \n    fn main() {\n        let (tx, rx) = channel();\n        let start = Instant::now();\n        skynet(tx, 0, 1_000_000, 10);\n        let result = rx.recv().unwrap();\n        let took = start.elapsed();\n        println!(\"Result: {} in {} ms.\",\n                 result,\n                 took.subsec_nanos() as f32 / 1.0e6);\n    }\n\nIt seems to finish in 200ms. It's not 100% the same, as Rust prefers OS threads over green threads. The code is even smaller with normal threads, but Windows obviously won't hand out 1 million OS threads. Rayon uses a work stealing thread pool though, which is roughly equivalent to what Go does.\n\nNote that you wouldn't even need the channels in Rust, as you could just fold / reduce over the parallel iterator."], [1, "So I read this article and thought to run some comparison myself. So here is what I did for Go. \n\n* Copy-pasted go code in file and `go run main.go`\n\nFor Java\n\n* Copy pasted Java code and ..\n* Looked for quasar binary but could not find in article.\n* Went to github and looked there for release binary. It is not there\n* Downloaded source-code and looked for ant build script. It is not there\n* Apparently it need gradle to build which is separate download.\n* For benchmarking accurately it needs JMH. Another download. \n* Just Give up.\n\nIt is clear that I could not complete many more steps to run the Java code. \n\nSo I am just going to assume Java is better for enterprise class applications and Go is good only for toy programs.\n"]], [[{"comment": "I just implemented this with Rust:\n\n    extern crate rayon;\n    \n    use rayon::prelude::*;\n    use std::sync::mpsc::{channel, Sender};\n    use std::time::Instant;\n    \n    fn skynet(c: Sender<u64>, num: u64, size: u64, div: u64) {\n        if size == 1 {\n            c.send(num).unwrap();\n            return;\n        }\n    \n        let (tc, rc) = channel();\n        let mut sum = 0;\n        (0..div).map(|i| (i, tc.clone())).collect::<Vec<_>>().into_par_iter().for_each(|(i, tc)| {\n            let sub_num = num + i * (size / div);\n            skynet(tc, sub_num, size / div, div);\n        });\n        for _ in 0..div {\n            sum += rc.recv().unwrap();\n        }\n        c.send(sum).unwrap();\n    }\n    \n    fn main() {\n        let (tx, rx) = channel();\n        let start = Instant::now();\n        skynet(tx, 0, 1_000_000, 10);\n        let result = rx.recv().unwrap();\n        let took = start.elapsed();\n        println!(\"Result: {} in {} ms.\",\n                 result,\n                 took.subsec_nanos() as f32 / 1.0e6);\n    }\n\nIt seems to finish in 200ms. It's not 100% the same, as Rust prefers OS threads over green threads. The code is even smaller with normal threads, but Windows obviously won't hand out 1 million OS threads. Rayon uses a work stealing thread pool though, which is roughly equivalent to what Go does.\n\nNote that you wouldn't even need the channels in Rust, as you could just fold / reduce over the parallel iterator.", "id": "d2rextv"}, {"comment": "I'd be interested in Rust with coroutines, maybe you can have a look at https://github.com/atemerev/skynet/issues/71? Not knowledgeable enough in Rust to submit a PR.", "id": "d2s3sa2"}, {"comment": "Looks like the channels really introduce a lot of overhead. This code is far simpler and only takes 9 milliseconds:\n\n    extern crate rayon;\n    \n    use rayon::prelude::*;\n    use std::time::Instant;\n    \n    fn skynet(num: usize, size: usize, div: usize) -> usize {\n        if size == 1 {\n            num\n        } else {\n            (0..div)\n                .into_par_iter()\n                .map(|i| {\n                    let sub_num = num + i * (size / div);\n                    skynet(sub_num, size / div, div)\n                })\n                .sum()\n        }\n    }\n    \n    fn main() {\n        let start = Instant::now();\n        let result = skynet(0, 1_000_000, 10);\n        let took = start.elapsed();\n        println!(\"Result: {} in {} ms.\",\n                 result,\n                 took.subsec_nanos() as f32 / 1.0e6);\n    }\n\nI'll try a version with coroutines next.", "id": "d2srjim"}, {"comment": "The coroutine version seems to be super slow (700 ms):\n\n    extern crate coroutine;\n    \n    use coroutine::asymmetric::Coroutine;\n    use std::time::Instant;\n    \n    fn skynet(num: usize, size: usize, div: usize) -> usize {\n        if size == 1 {\n            num\n        } else {\n            let coroutine = Coroutine::spawn(move |me| {\n                for i in 0..div {\n                    let sub_num = num + i * (size / div);\n                    let result = skynet(sub_num, size / div, div);\n                    me.yield_with(result);\n                }\n            });\n        \n            coroutine.fold(0, |a, b| a + b)\n        }\n    }\n    \n    fn main() {\n        let start = Instant::now();\n        let result = skynet(0, 1_000_000, 10);\n        let took = start.elapsed();\n        println!(\"Result: {} in {} ms.\",\n                 result,\n                 took.subsec_nanos() as f32 / 1.0e6);\n    }\n    ", "id": "d2su6y1"}, {"comment": "Thanks!", "id": "d2tjz1u"}], [{"comment": "So I read this article and thought to run some comparison myself. So here is what I did for Go. \n\n* Copy-pasted go code in file and `go run main.go`\n\nFor Java\n\n* Copy pasted Java code and ..\n* Looked for quasar binary but could not find in article.\n* Went to github and looked there for release binary. It is not there\n* Downloaded source-code and looked for ant build script. It is not there\n* Apparently it need gradle to build which is separate download.\n* For benchmarking accurately it needs JMH. Another download. \n* Just Give up.\n\nIt is clear that I could not complete many more steps to run the Java code. \n\nSo I am just going to assume Java is better for enterprise class applications and Go is good only for toy programs.\n", "id": "d2ra756"}, {"comment": "No need to download anything. Go to Github, clone the repo, run `./gradlew`. Go and Java are both great, you're probably just more familiar with one than with the other.\n\n-----\n\nOh, and no need for JMH (basically, JMH is a tool that knows about possible compiler optimizations, and makes sure that your microbenchmark isn't enjoying optimizations that won't be possible in a real application. For any scientific microbenchmark, in any language -- Go, Java or C -- something like JMH is necessary, although it may play a greater role in a JITted runtime like HotSpot, where more optimizations are possible). But we're not benchmarking single instructions here, so no need for nano-level accuracy ", "id": "d2rb4iy"}, {"comment": "OMG, I made the mistake of actually looking at that file, I almost went blind.  Is that a standard thing everyone just copies and pastes into their java repos, or what? ", "id": "d2rh7v2"}, {"comment": "No, it's an auto-installer (Gradle Wrapper, hence `gradlew`) for the build tool, Gradle, which the build tool creates if you ask it, so that people who don't have it installed can build the project easily. If you have Gradle installed you don't need it.", "id": "d2rhzbj"}, {"comment": "thank you! this is EXACTLY why peope are using Go and not Quasar, Elixir, Akka, etc etc etc\n\nGo provides what most people want out of the SDK install", "id": "d2rejxi"}, {"comment": "No, it's just that this benchmark was written around capabilities that happen to come pre-packaged with Go, and /u/goedel obviously knows how to launch Go (with `go run`) but didn't know about Java (`./gradlew`). That's all. There's no doubt that Go has a particularly easy onboarding process (certainly compared to Java's), but I don't think that that is the deciding factor after a while. Again, Go and Java are both great, and they each have their strengths and weaknesses. I also think that there are still a few folks out there who choose Java for plenty of good reasons, even if it isn't as beginner-friendly as Go.", "id": "d2rfy1m"}]]], "47i542": ["Top 5 irritating things in programming tutorials", "2016-02-25 12:37:42", 2, "https://medium.com/@pistacchio/top-5-irritating-things-in-programming-tutorials-2f6ba4f2184e#.f6b8k6c56", [[26, "The most irritating thing is people making videos when a Web page would be better. "], [13, "Have you ever watched Microsoft MVC Tutorial?\n\nIts 50 min each video and 50% of the video is them talking about the new features in Visual Studio and how great it is.\n\nAlso mid lesson they make a mistake with the application and have to take a break to tell jokes.\n\nNo ideia why they decided to use it, but its there online for everyone to see."], [3, "My #1 is TOY EXAMPLES. Currying? Start with the most trivial function imaginable, add(a, b) -> a + b, and make it more complicated for no obvious benefit! The end. Monads? To quote Stack Overflow:\n\n> [x*2 | X<-[1..10], odd x]\n\n> This expression returns the doubles of all odd numbers in the range from 1 to 10. Very useful!\n\nIndeed!!"], [1, "Top 1 most irritating blog title"], [2, "Math examples."]], [[{"comment": "The most irritating thing is people making videos when a Web page would be better. ", "id": "d0d3kqm"}, {"comment": "Not only that but people seem to be allergic to using video editors or re-recording any bits.\n\n> So hi welcome to my video on assembling FooWidget! So first you pick up this part and oh I've already partially assembled it wait a mo let me just undo these screws hang on here  we go though actually your one is a different version so it won't quite look like this and er where's my cross head this is the wrong screwdriver I'm just going to get the right one out of my toolbox, why is it never on top haha er right here it is so right where was I oh yes I'll just undo these screws first right now I have to unslot this right here we go so your part will look like this or actually it will look a bit different because we started shipping a new version so oh I think I mentioned that already right so you take your part and you pick up the second part and slot it like this, you then take the 5mm screws er where are the screws well I think your ones will be in a packet but obviously I didn't ship one of these to myself so I don't have the screws in a packet so let me just find the 5mm screw and it goes in like this oh huh that's the wrong length I think it must be a 6mm one, er so where are my calipers I'll measure the screw ah here it is its this is the 5mm screw and so you tighten it here. Then you pick up this part...", "id": "d0d5l0x"}, {"comment": "\"Ad these are the 100 lines of code that you're supposed to copy from the video by pausing it if you want to try it by yourself\"", "id": "d0d3lq0"}, {"comment": "Yeah, YT video as novel version control tool. Because why should they give any traffic to the free and popular services that would let you clone any-fucking-thing. Just pause and re-type like an animal.\n\nThere are peeps who do it well -- like [Parens of the Dead](http://www.parens-of-the-dead.com/) tutorial, where every show is linked to a release on github. So basic, yet so rare.", "id": "d0d4da6"}], [{"comment": "Have you ever watched Microsoft MVC Tutorial?\n\nIts 50 min each video and 50% of the video is them talking about the new features in Visual Studio and how great it is.\n\nAlso mid lesson they make a mistake with the application and have to take a break to tell jokes.\n\nNo ideia why they decided to use it, but its there online for everyone to see.", "id": "d0d3r8w"}, {"comment": "Maybe they missed the part where you can edit a video before uploading it ;)", "id": "d0d3rtc"}, {"comment": "\"I kept saying we should have kept developing Windows Movie Maker, but nobody listened! Now fuck it, it goes unedited!\"", "id": "d0d3z0u"}], [{"comment": "My #1 is TOY EXAMPLES. Currying? Start with the most trivial function imaginable, add(a, b) -> a + b, and make it more complicated for no obvious benefit! The end. Monads? To quote Stack Overflow:\n\n> [x*2 | X<-[1..10], odd x]\n\n> This expression returns the doubles of all odd numbers in the range from 1 to 10. Very useful!\n\nIndeed!!", "id": "d0dv95a"}], [{"comment": "Top 1 most irritating blog title", "id": "d0d427f"}, {"comment": "found you, bad tutorial maker.", "id": "d0d5gf2"}], [{"comment": "Math examples.", "id": "d0d4l2e"}]]], "4aszou": ["Perl is not dead: It was early web novices that gave it a bad name", "2016-03-17 17:31:16", 5, "http://techbeacon.com/perl-not-dead-it-was-early-web-novices-gave-it-bad-name", [[15, "Well aren't you optimistic.\n\nThe organization that I work for is scrambling to find a path *out* of Perl."], [12, "There is tonnes of existing Perl out there, and large Perl systems. Not one offs too. There are a tonne of them.\n\nBut whilst there are examples of new systems being built in Perl I suspect most are done at places which are already using Perl elsewhere. So they aren't really choosing Perl. They are just not jumping over board.\n\nPlaces which weren't using Perl, and are deciding to use Perl on new projects, is the real holy grail to saying that Perl is still alive. Outside of a few exceptions I just don't see that happening."], [9, "I'm going to write a Perl script today just because you guys are all so salty about it."], [9, "This is an honest question: is there any good reason to use perl over python on a new project these days? (other than perhaps the always-valid \"there is an awesome library for something very important to our business in perl, that doesn't have as good a python equivalent\". And even that, the python ecosystem is pretty huge).\n\nI believe that as the article claims, it is possible to write nice clean code in Perl. But it's also possible to write nice clean code in python, and by all indications python seems to cause people to write nicer code on average than perl.\n\nOther high level dynamically typed languages that are competitive or surpass python in usage have something very strong going for them. Ruby has RoR and better language facilities for DSLs. JS is JS. Visual Basic makes it easy to build windows applications. PHP... well I have no idea to be honest. So I'm curious what Perl brings that would make me seriously consider it for a new project. Saying this as someone who when seeing Perl code in the past, found it completely unreadable maybe close to half the time, whereas in python/ruby I feel like it's more like 10%."], [7, "So, there are a few unsupported controversial statements this article makes, which I'll gloss over for now.\n\nMy favorite line is \"Modern Perl is a clean, powerful language and looks nothing like those poorly written piles of legacy code with which most developers associate it.\"\n\nWhich I respond with: Since you'll most likely be working for someone else, and keeping existing systems operational, getting to work with clean Perl will likely be a rare treat, and you can expect piles of poorly designed and inconsistent spaghetti code."], [5, "As user of Perl for many years... language definitely shows its age. I hope Perl 6 will get a good fast JIT because it really fixes a lot of gripes I have with language.\n\nBut beside that... all of my old code (as in \"my code from when 56k modem was standard method of internet access\") wrote under antique versions of perl 5 still works on newest one (with occasional \"please use it like that, this syntax is deprecated) and that is a **HUGE** advantage for my work (I work as sysadmin and do a bit of coding)."], [5, "Cobol doesn't seem to be dead yet either. Maybe the train just departed..."], [3, "Early web novices were not responsible for Perl 6, so..."], [2, "I'm a big Python fan, but I also enjoy Perl programming. Perl 5 has the advantage that it's already present on almost every UNIX system, and it even works on Plan 9."], [0, "My first Perl project rubbed the lettering off of my shift keys in about a month. Can't blame early web novices for that."], [-8, "No. It actually just sucks. "]], [[{"comment": "Well aren't you optimistic.\n\nThe organization that I work for is scrambling to find a path *out* of Perl.", "id": "d138an7"}, {"comment": "Same. Other languages have far more robust AWS libraries, and we haven't found a developer who even wants to _learn_ Perl.\n\nThankfully, we have servware. But since only I can read Perl, it falls to me to port everything, URL by URL.", "id": "d13c396"}, {"comment": "> wants to learn Perl\n\nIt's not a good look for one's career.", "id": "d14279b"}, {"comment": "The thing about it is, nobody expects to ever need it again, and it doesn't have any glamor like the 'secret alien technology' of Lisp.\n\n(I like Perl, it was my first love. I'd maintain that its differences from the mainstream are mind-expanding, and that makes it interesting and worthwhile to learn. But culturally, it looks like Perl is the new COBOL\u2026)", "id": "d14uqij"}, {"comment": "> The organization that I work for\n\nWhat sector is it in?", "id": "d1426x3"}, {"comment": "Web hosting services.", "id": "d1428tc"}], [{"comment": "There is tonnes of existing Perl out there, and large Perl systems. Not one offs too. There are a tonne of them.\n\nBut whilst there are examples of new systems being built in Perl I suspect most are done at places which are already using Perl elsewhere. So they aren't really choosing Perl. They are just not jumping over board.\n\nPlaces which weren't using Perl, and are deciding to use Perl on new projects, is the real holy grail to saying that Perl is still alive. Outside of a few exceptions I just don't see that happening.", "id": "d1396hl"}], [{"comment": "I'm going to write a Perl script today just because you guys are all so salty about it.", "id": "d13fbrx"}, {"comment": "Can you tell us how often you had to look up something when you're done, let alone stackoverflow?\n\nI have to write bash stuff and I have to look up even if comparisons all the times, it's so irrational that my mind boycotts learning only part of it. Floating point arithmetic is hell..", "id": "d13gx5f"}, {"comment": "> I have to write bash stuff and I have to look up even if comparisons all the times, it's so irrational that my mind boycotts learning only part of it. Floating point arithmetic is hell..\n\nI made a refcard out of the linked pages for files and strings a long time ago: http://tldp.org/LDP/abs/html/tests.html  Getting them all in one place made it quicker to look up and after a while I didn't need the card anymore.  Another trick if you can't remember something like \"is it -z or -e?\" is do [[ -z $thing ]]; echo $?; [[ -e $thing ]]; echo $? at a shell and just test it out.\n\nEverything is familiarity :)\n\nP.S. I just shell out to something else for floating point if I need it in the shell:\n\n    echo 'print(4.0 * 24)' | python\n", "id": "d13hhy8"}, {"comment": "$ echo '1.5 * 5' | bc -l\n\n7.5\n", "id": "d145uzn"}], [{"comment": "This is an honest question: is there any good reason to use perl over python on a new project these days? (other than perhaps the always-valid \"there is an awesome library for something very important to our business in perl, that doesn't have as good a python equivalent\". And even that, the python ecosystem is pretty huge).\n\nI believe that as the article claims, it is possible to write nice clean code in Perl. But it's also possible to write nice clean code in python, and by all indications python seems to cause people to write nicer code on average than perl.\n\nOther high level dynamically typed languages that are competitive or surpass python in usage have something very strong going for them. Ruby has RoR and better language facilities for DSLs. JS is JS. Visual Basic makes it easy to build windows applications. PHP... well I have no idea to be honest. So I'm curious what Perl brings that would make me seriously consider it for a new project. Saying this as someone who when seeing Perl code in the past, found it completely unreadable maybe close to half the time, whereas in python/ruby I feel like it's more like 10%.", "id": "d13b6sv"}, {"comment": "Any good reason to use Python over Perl these days?\n\nIt's just preference. Some people like Perl, others like Python. There is nothing you can do in one and not the other.", "id": "d13l0jm"}, {"comment": "I use Perl, but work uses Python so I'm trying to make the switch. If I had to give one reason to use Python over my beloved Perl it would be that Python seems to have a...more modern community. You can run Python at Amazon and venv/virtualenv is more mature than Perl's version are the two examples.\n\nPython feels to me these days as filling the same kind of gaps as Perl did back in the early 00's. Definitely not the same gaps, like CGI scripts, but the same kind, frontier environments like AWS and micro-services.", "id": "d13opyw"}, {"comment": "Modern or not I don't really care about *that* much, but god, the perl community can be extremely toxic and religion-like sometimes.\n\nAny kind of lack of feature or other type of criticism anybody makes towards it is shot down and berated so hard, you get the impression that there's a prize to win. Until the missing feature gets added to the language or otherwise gets fixed, at which points everybody starts celebrating how great perl is.\n\nNow, to be fair, I've gotten fanboys and kneejerk reactions from just about any language community before, but the perl community is something else.", "id": "d13rx98"}, {"comment": "> the perl community can be extremely toxic\n\nEhh, I think the Perlmonks crowd can be alright. Or at least that's what I remember in my head. I've seen worse with regards to toxicity. They're no Linus, right?\n\n> and religion-like sometimes\n\nThis is **absolutely true**. It's difficult to have a rational discussion about Perl without someone fanboying about it in the abstract. Let's call a spade a spade; she ain't pretty.", "id": "d1429dm"}, {"comment": "Of all of the good programming languages out there, I cannot think of many projects where Perl is the best candidate, unless \"Because I already know it\" is a core criteria.", "id": "d13c2vp"}, {"comment": "Maybe an old mainframe that doesn't have python on it?", "id": "d13kp2l"}, {"comment": "I think that there is GCC for that architecture.", "id": "d13t31i"}, {"comment": "Probably no good reason to prefer it for a new \"project\". Something of that scope requires an amount of software engineering that is frankly harder to do with perl. When doing computational work, there is a spectrum of quick and dirty work versus solid engineering work. If something needs to be well-engineered I will use something with static types and an excellent complier (like haskell or c++; python lacks these qualities and is good for the middle of the quick and dirty vs engineering zone). If I need to solve a quick and dirty problem and all of the subproblems have already been solved, a shell script is the way to go. Unforunately, shell languages are clunky, but perl has an excellent interface with shells and good handling of quick-and-dirty datatypes like strings, so if I'm doing something like a shell-script but it requires a something more sophisticated like a nested loop or a gaussian distribution or flickr downloads, perl is a good choice. This niche it occupies is relevant enough that I write perl like twice a year maybe, but I wouldn't recommend anybody learn perl anytime soon.\n\nAlso, the good things about python are not that related to the language itself in my opinion. Ipython/numpy/scipy/pandas/matplotlib/seaborn/jupyter are excellent technologies, but in a slightly different world perl could have been the language where this wealth of software engineering ended up.", "id": "d13ravl"}, {"comment": "PDL (Perl Data Language) seems rather mature for that sort of thing. There are lots of cpan modules utilizing it. ", "id": "d16akpb"}, {"comment": "I'm an ex-Perl user and besides familiarity, the main reason I can think of to use Perl over anything else is the wealth of libraries it offers.  There are some that exist for specialized purposes and some very nice general purpose libraries.  Granted, it's been a few years, so I don't know how good they are now.  However, if you're starting something new, depending on what it is it may not hurt to at least prototype it in Perl if it has a library that would make you're life easier.\n\nOther than that, my preference is to use a nice compiled language with fast build times.  IMHO, if you can easily get good run-time performance and be about as productive as you are in something like Perl, you should go for it.", "id": "d140etj"}, {"comment": "> I'm an ex-Perl user\n\nWhat do you write in now?", "id": "d142brb"}, {"comment": "Professionally: right now, Golang.  Used to do more Java.\n\nRecreationally: D.  Granted, I haven't done much in it, but it's my favourite language to program in right now.", "id": "d14e7nm"}, {"comment": "That's awesome that you get to do something like Golang for dollars. I think there's like one Go company in my city...", "id": "d14eh25"}, {"comment": "Heh...it's not a company-wide thing.  We just need to write small things for a project, some of them RESTful, and we picked go to try it out.  It's worked well for what we needed.", "id": "d14laz1"}, {"comment": "> is there any good reason to use perl over python\n\nLet's just go ahead and say probably not. The tooling, market, and enthusiasm for Python is greater than for Perl.\n\nI try really hard to like Perl, being a former Perl addict myself. I am not doing a good job of convincing myself.", "id": "d142ax0"}, {"comment": "> Visual Basic\n\nThe 90s called. They don't want it back", "id": "d13em5k"}, {"comment": "PHP makes it easy to build dynamic web pages (and potentially web applications), just like VB makes it easy to buld Windows applications.", "id": "d13k98g"}], [{"comment": "So, there are a few unsupported controversial statements this article makes, which I'll gloss over for now.\n\nMy favorite line is \"Modern Perl is a clean, powerful language and looks nothing like those poorly written piles of legacy code with which most developers associate it.\"\n\nWhich I respond with: Since you'll most likely be working for someone else, and keeping existing systems operational, getting to work with clean Perl will likely be a rare treat, and you can expect piles of poorly designed and inconsistent spaghetti code.", "id": "d13bhyo"}, {"comment": "I do quite well modernising old perl (spending about half my time doing that and half on greenfield perl stuff atm).  Except for the worst kind of code (that you find everywhere) it's fun and satisfying.  Even the old really bad stuff is kind of fun, so long as you have a patient boss who understands the problems with their system.\n\n", "id": "d16jrrp"}], [{"comment": "As user of Perl for many years... language definitely shows its age. I hope Perl 6 will get a good fast JIT because it really fixes a lot of gripes I have with language.\n\nBut beside that... all of my old code (as in \"my code from when 56k modem was standard method of internet access\") wrote under antique versions of perl 5 still works on newest one (with occasional \"please use it like that, this syntax is deprecated) and that is a **HUGE** advantage for my work (I work as sysadmin and do a bit of coding).", "id": "d13ag7z"}, {"comment": "> language definitely shows its age\n\nWhen one considers named function parameters an amazing new feature, maybe you have a problem.", "id": "d142cmo"}, {"comment": "> When one considers named function parameters an amazing new feature, maybe you have a problem.\n\nAs the author of the referenced article, I have to agree with you. This makes me frickin' sad.", "id": "d14mlyz"}, {"comment": "just pass a hash with arguments, it's The Perl Way^^TM ;)\n\nBut honestly looking at how function calling and overloading works in Perl 6, devs might've gone overboard the other way...", "id": "d143fmp"}, {"comment": "> wrote under antique versions of perl 5 still works on newest one\n\nFor Perl that's probably okay, but one of my primary complaints about PHP would make this a negative, not a positive. PHP needs a major version that breaks a lot of things in order to make things sane - it'll break a lot of legacy code but I think it would help the language a lot.\n\nI say \"probably\" about Perl, because I've no idea about it as I haven't written any in about 10 years. :( I want to like it, but I just don't really have an excuse to use it over Python.", "id": "d14brhy"}, {"comment": "PHP's been progressing a lot in the last couple of years.  A whole bunch of terrible PHP4 stuff has been deprecated and/or completely removed in php5.6 and php7.", "id": "d153sbo"}], [{"comment": "Cobol doesn't seem to be dead yet either. Maybe the train just departed...", "id": "d13eypd"}], [{"comment": "Early web novices were not responsible for Perl 6, so...", "id": "d13ms0g"}], [{"comment": "I'm a big Python fan, but I also enjoy Perl programming. Perl 5 has the advantage that it's already present on almost every UNIX system, and it even works on Plan 9.", "id": "d13dpa6"}], [{"comment": "My first Perl project rubbed the lettering off of my shift keys in about a month. Can't blame early web novices for that.", "id": "d142u7w"}], [{"comment": "No. It actually just sucks. ", "id": "d138jqo"}]]], "45ccih": ["Data analysis of GitHub contributions reveals unexpected gender bias: \"Women's contributions to open source are more likely to be accepted than men's.\"", "2016-02-12 04:44:38", 0, "http://arstechnica.com/information-technology/2016/02/data-analysis-of-github-contributions-reveals-unexpected-gender-bias/", [[9, "At least this rendition is closer to reality. The end of the article \n\n> we have further evidence that there is measurable bias against women in computer science\n\nis rather incorrect. The evidence presented in the (non-peer-reviewed) paper clearly shows that if there's a bias at all, it's against men. The authors of the paper theorize that this is observed because women are held to a higher standard and that this higher standard is the anti-women bias, but there's nothing in the actual statistics presented in the paper to support that hypothesis because it doesn't examine whether women are actually held to a higher standard or not. The *only* thing this study looks at is the pull request acceptance rate, and it shows an apparent bias against men they couldn't directly account for. That is the only conclusion one can draw from it; anything else is speculation.\n\nThis has been discussed here [several](https://www.reddit.com/r/programming/comments/452jcz/gender_bias_in_open_source_womens_contributions/) [times](https://www.reddit.com/r/programming/comments/45a461/women_are_more_likely_to_get_their_pull_requests/), so I'll refrain from repeating my criticisms of the paper and it's news coverage. I encourage people to read the article and come to their own conclusions about the accuracy of its data selection and analysis methodology and its possible confirmation bias."], [6, "For a grain of salt I'll just link to this comment thread over here:\n\nhttps://www.reddit.com/r/science/comments/45bq1q/data_analysis_of_github_contributions_reveals/czx2yay\n"], [0, "This is the best tl;dr I could make, [original](http://arstechnica.com/information-technology/2016/02/data-analysis-of-github-contributions-reveals-unexpected-gender-bias/?) reduced by 92%. (I'm a bot)\n*****\n> Based on previous work done on women in computer science, which has revealed that women consistently earn lower salaries than men and have to prove their worth more often, the researchers hypothesized that open source project leaders would incorporate fewer contributions from women into their code.\n\n> Perhaps men involved in open source had a &quot;Helper&quot; complex, and they wanted to bring women into the fold so badly that they merged women&#039;s pull requests more often than they did men&#039;s.\n\n> So why are women in open source more competent than men? Given that there is no &quot;Computer science gene&quot; that occurs more often in women than in men, there has to be a social bias at work.\n\n\n*****\n[**Extended Summary**](http://np.reddit.com/r/autotldr/comments/45ci14/data_analysis_of_github_contributions_reveals/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ \"Version 1.6, ~35598 tl;drs so far.\") | [Theory](http://np.reddit.com/r/autotldr/comments/31bfht/theory_autotldr_concept/) | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr \"PMs and comment replies are read by the bot admin, constructive feedback is welcome.\") | *Top* *keywords*: **women**^#1 **men**^#2 **more**^#3 **contributions**^#4 **open**^#5\n\n"]], [[{"comment": "At least this rendition is closer to reality. The end of the article \n\n> we have further evidence that there is measurable bias against women in computer science\n\nis rather incorrect. The evidence presented in the (non-peer-reviewed) paper clearly shows that if there's a bias at all, it's against men. The authors of the paper theorize that this is observed because women are held to a higher standard and that this higher standard is the anti-women bias, but there's nothing in the actual statistics presented in the paper to support that hypothesis because it doesn't examine whether women are actually held to a higher standard or not. The *only* thing this study looks at is the pull request acceptance rate, and it shows an apparent bias against men they couldn't directly account for. That is the only conclusion one can draw from it; anything else is speculation.\n\nThis has been discussed here [several](https://www.reddit.com/r/programming/comments/452jcz/gender_bias_in_open_source_womens_contributions/) [times](https://www.reddit.com/r/programming/comments/45a461/women_are_more_likely_to_get_their_pull_requests/), so I'll refrain from repeating my criticisms of the paper and it's news coverage. I encourage people to read the article and come to their own conclusions about the accuracy of its data selection and analysis methodology and its possible confirmation bias.", "id": "czwscxw"}], [{"comment": "For a grain of salt I'll just link to this comment thread over here:\n\nhttps://www.reddit.com/r/science/comments/45bq1q/data_analysis_of_github_contributions_reveals/czx2yay\n", "id": "czxev77"}], [{"comment": "This is the best tl;dr I could make, [original](http://arstechnica.com/information-technology/2016/02/data-analysis-of-github-contributions-reveals-unexpected-gender-bias/?) reduced by 92%. (I'm a bot)\n*****\n> Based on previous work done on women in computer science, which has revealed that women consistently earn lower salaries than men and have to prove their worth more often, the researchers hypothesized that open source project leaders would incorporate fewer contributions from women into their code.\n\n> Perhaps men involved in open source had a &quot;Helper&quot; complex, and they wanted to bring women into the fold so badly that they merged women&#039;s pull requests more often than they did men&#039;s.\n\n> So why are women in open source more competent than men? Given that there is no &quot;Computer science gene&quot; that occurs more often in women than in men, there has to be a social bias at work.\n\n\n*****\n[**Extended Summary**](http://np.reddit.com/r/autotldr/comments/45ci14/data_analysis_of_github_contributions_reveals/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ \"Version 1.6, ~35598 tl;drs so far.\") | [Theory](http://np.reddit.com/r/autotldr/comments/31bfht/theory_autotldr_concept/) | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr \"PMs and comment replies are read by the bot admin, constructive feedback is welcome.\") | *Top* *keywords*: **women**^#1 **men**^#2 **more**^#3 **contributions**^#4 **open**^#5\n\n", "id": "czwtewi"}]]], "42ccuw": ["Pikachu Injector: now on bower and npm", "2016-01-23 22:44:51", 0, "https://github.com/a-r-d/pikachu-injector", [[5, "Who said innovation is dead?"]], [[{"comment": "Who said innovation is dead?", "id": "cz9hl6e"}]]], "55m3x3": ["Haskell is Not a Purely Functional Language", "2016-10-03 08:34:09", 0, "https://chadaustin.me/2015/09/haskell-is-not-a-purely-functional-language/", [[26, "Um, you might as well say that nothing is purely functional because every computation increases entropy in the Universe, and therefore is not side-effect free.\n\nThe source of Input, and the destination of Output, are by definition outside the boundary of the language. \"Purely functional\" applies to the language within that boundary, not outside it."], [11, "Author has wrong assumption that functions with `IO` type are different from other (pure) functions. There is no evidence in the article other than author's own statement.\n\nThere are people that might agree ([Conal Elliott](http://conal.net/blog/posts/is-haskell-a-purely-functional-language)), but that is rather academical discussion."], [10, "Saying a language is impure because it has the IO monad is misunderstanding what the IO monad is. It is *not* an effect, any more than a list of groceries saying to buy milk and cookies is the same thing as an actual bottle of milk and a box of cookies.\n\nThe proper interpretation is that the IO monad is constructing the shopping list, but the shopping list doesn't *do* anything. Haskell does construct the shopping list 100% purely: there is no uncertainty involved whatsoever in constructing a list that says \"buy milk and cookies\".\n\nOnce this pure shopping list is constructed, you can interpret it however you want. Going to the store and performing side effects *is not* the only valid interpretation (though it's the most common). But it's just as valid to look over the list and see whether the person is fond of purchasing high-calorie foods--which would also be a pure computation."], [10, "Well, a programming language that is really 100% purely functional would be useless except as a textual calculator. You absolutely **need** side-effects at the end of the day, even if you just want to print to a screen/file/database."], [5, "> Haskell is Not a Purely Functional Language \n\nI think it's a horrible title.\n\nShould have NOT JUST in there.\n\nAuthor argument that Haskell is more than just a purely functional language and it has features that are similar to popular language such as Java, etc..\n\nAs a realist, I know this sounds like I'm waging a religious war, but Haskell is never going to be popular in term of Java and the likes. \n\nIt will be a great language to expand your mind and makes you a better programmer, but it's a niche language. I don't see any killer framework and the likes to catapult Haskell to better standing. "], [4, "> I propose instead that, for most programmers, it's better to think of Haskell as a language with restricted effects.\n\nThat's wrong too. There's nothing restricted about Haskell in that regard.\n\nA more accurate way to characterize Haskell would be to say that side effects are encoded in its type system.\n"], [3, "[A more compelling argument from Conal Elliott](http://conal.net/blog/posts/is-haskell-a-purely-functional-language)."], [2, "I am disappointed.\n\nThe blog entry does not use the word monad at all. :("], [0, "Yes it is. /thread"], [0, "Right, I would tweak it to make it a bit harder to handle input and output. /s"]], [[{"comment": "Um, you might as well say that nothing is purely functional because every computation increases entropy in the Universe, and therefore is not side-effect free.\n\nThe source of Input, and the destination of Output, are by definition outside the boundary of the language. \"Purely functional\" applies to the language within that boundary, not outside it.", "id": "d8bux1n"}, {"comment": "> Um, you might as well say that nothing is purely functional because every computation increases entropy in the Universe, and therefore is not side-effect free.\n\nI think most people understand the difference between \"map and territory\". A purely functional language would have a side-effects free model. By definition it's not executed on a side-effects free machine, because PCs are very much stateful (both in and outside their model).\n\n> The source of Input, and the destination of Output, are by definition outside the boundary of the language.\n\nIO is basically a side-effectual interpreter that's pretty much a part of Haskell. It's provided by Haskell even if it's in another bounded context from what you could say the \"language\" is.\n\nIt's factored almost as if the purpose of it was for Internet nerds to argue about it on Reddit. :-)\n", "id": "d8bv77u"}, {"comment": "> \n> \n> The source of Input, and the destination of Output, are\n> by definition outside the boundary of the language. \n\nWhat if you run a haskell computer inside a monad?\n\nIs the environment then part of the system or is it still inside of it?\n\nGranted, we have no haskell computers that I know of, but purely in the sense of theoretical pondering here.\n\n", "id": "d8by7el"}, {"comment": "Not to mention that it is impossible to actually implement pure functions in hardware due to hw failures, power failures, cosmic rays... we have to draw a line somewhere to keep our sanity.", "id": "d8ciojw"}, {"comment": "Executing a purely-functional language is by definition impure.\n\nBesides, with no output to detect, why run it? (\\^:", "id": "d8e90sd"}, {"comment": "A *pure* computation does not increase the entropy, by definition.\n\nEDIT: the incompetent downvoters do not know the definitions of entropy and information. Go and read some Chaitin and Kolmogorov before coming back.", "id": "d8c17u9"}, {"comment": "Can a computation ever happen without increasing entropy (aside from a _[reversed computation](https://en.wikipedia.org/wiki/Reversible_computing)_)?", "id": "d8ckp2t"}, {"comment": "The pure computation (from the algorithmic information theory point of view) did not even happen - it does not add any new information to the system.", "id": "d8ckwbx"}, {"comment": "Right, so there's no such thing as _pure_ (physical) computation (as opposed to theoretical-only function evaluation).", "id": "d8clets"}, {"comment": "Yet, we're talking about a *pure functional* computation - which by definition does not add any information. Physical or not.", "id": "d8cm5oy"}, {"comment": "Pure functional evaluation adds information, since it involves computation (which necessarily changes some physical state), and can involve unobserved _effects_ (from _outside_ the function) **during** computation/evaluation, just as long as there is no left-over residue. \n\nThe entropy of an _evaluated_ purely functional program is always equal to or greater than the unevaluated function.", "id": "d8curcw"}, {"comment": "Pure function does not observse state changes, and entropy of its normal form is equal to the entropy of any other chain of reductions.", "id": "d8d9zst"}, {"comment": "By that definition of purity, any imperative computation (without IO), is trivially transformed to a pure one.", "id": "d8dd227"}, {"comment": "And? Without IO -> without true random events -> information & entropy are constant. You're simply re-wording one of the most fundamental consequences of the algorithmic information theory.", "id": "d8dd3de"}, {"comment": "From a computational complexity point of view it most certainly \"happens\". The same amount of computational work is required or cryptography would be open to a \"pure computation attack\", whatever that would mean.", "id": "d8dcz5c"}, {"comment": "> From a computational complexity point of view it most certainly \"happens\". \n\nHow exactly? It does not add any new *information* to the system, and does not change the number of degrees of freedom (i.e., does not affect the entropy).", "id": "d8dd3ys"}, {"comment": "First, computational complexity is a much more relevant view of computation than information entropy. While a natural number and its prime factors may contain the same information, it takes a lot more computational work to go in one direction than in the other. AFAIK, Kolmogorov complexity does not take into account this most crucial concept of computational complexity. \n\nSecond, I am not familiar with algorithmic information theory, but I believe (though I'm not certain) that it is not true that the Kolmogorov complexity of a lambda term is the same as its reduced form, because beta reductions are not reversible. A great many expressions reduce to the normal form \"1\", yet their Kolmogorov complexity may be greater.", "id": "d8ddgm5"}, {"comment": "> but it is not true that the Kolmogorov complexity of a lambda term is the same as its reduced form\n\nIt is, by definition.\n\n> because beta reductions are not reversible\n\nAnd? Terms lost in reduction are *noise*, not an *information*. Again, by definition.\n\n> A great many expressions reduce to the normal form \"1\", yet their Kolmogorov complexity may be greater.\n\nIf term reduces to 1, this is its complexity. By definition. Complexity is defined by the shortest equivalent form.\n\n", "id": "d8ddkbu"}, {"comment": "> It is, by definition.\n\nCan you point me at that definition? The Kolmogorov complexity I'm familiar with is defined differently (the shortest TM that can produce the given string). I don't see how the K complexity of the program's output string is related to the K complexity of the program's description by the definition I know.\n\nAlso, can you point me at the relationship between Kolmogorov complexity and physical entropy, which is what /u/GeneReddit123 was referring to? AFAIK, physical entropy is increased as energy is dissipated with any irreversible bit change. If a computation is irreversible, then there would be an increase in physical entropy (I know very little about this subject, too, but this seems to me to be the conclusion of whatever little I've about it).\n\n> [Information] complexity is defined by the shortest equivalent form.\n\nAFAIK, you're looking at it backwards. As you cannot reproduce the original string from the reduced one, the complexity of the original string is not the same as that of the reduced one. There is no equivalence relation if the reduction is irreversible, and so the reduced term is not equivalent to the unreduced term.\n\nTo give a concrete example, suppose you want to find whether there is a traveling salesman route through all the cities in the US which is shorter than 10K miles. The program contains the map of the US, but it is reduced to either a TRUE or a FALSE. Does a map of the US have the same Kolmogorov complexity as TRUE or FALSE?", "id": "d8ddnpv"}, {"comment": "Yep, computation (or logical proof) is an erasure of information, and a decrease in information entropy. This decrease must be compensated by a greater increase in physical entropy, because [the two are indeed related](https://en.wikipedia.org/wiki/Entropy_in_thermodynamics_and_information_theory) (also [this](https://en.wikipedia.org/wiki/Landauer%27s_principle) and [this](http://www.nature.com/news/the-unavoidable-cost-of-computation-revealed-1.10186)). If you find anything that contradicts this, let me know. ", "id": "d8kueho"}, {"comment": "Oops, sorry, with all the trolling I forgot about the important stream of conversation. I'll get back to this thread when I'm not on a mobile and explain in detail what definition of information and computation I used and why it is important to do it this way.", "id": "d8kwi2c"}], [{"comment": "Author has wrong assumption that functions with `IO` type are different from other (pure) functions. There is no evidence in the article other than author's own statement.\n\nThere are people that might agree ([Conal Elliott](http://conal.net/blog/posts/is-haskell-a-purely-functional-language)), but that is rather academical discussion.", "id": "d8bu8a0"}, {"comment": "> Author has wrong assumption that functions with IO type are different from other (pure) functions.\n\nWell there is at least one thing that's different about them: they don't produce anything meaningful as seen from within the functional boundaries of the language, and yet they produce everything that's ever meaningful outside its boundaries.\n\nWhich is why to say Haskell is purely functional is kind of disingenuous.\n\nIt's like a Schrodinger cat factory. Your job whole day is to set up cats in boxes, complete with poison gas and a quantum mechanism hooked to a switch. Then you are to flip the switch, and ship the boxes, but *never open them*.\n\nAnd because you never opened them, you can say \"no animals were harmed in the production of these boxes\".\n\nBut that's a bald-faced lie, and you know it.", "id": "d8bw07y"}, {"comment": "But it really isn't: Haskell supports performing effects just fine, and gives the programmer control over what effects occur when, passes values from earlier effects to subsequent effects, etc. just like an imperative language. The difference is that it's explicit about what functions have effects, the sequencing of those effects, etc. So it retains referential transparency even though it manipulates state, does I/O, etc.", "id": "d8c2xug"}, {"comment": "> So it retains referential transparency even though it manipulates state, does I/O, etc.\n\nYes yes, no animals were harmed, because you don't look in the box. I get it.\n\nIt'd be fun if Haskell's approach was actually used in math. \"To obtain the next value of this infinite list of integral numbers, throw dice\". Or maybe \"the result of this function is determined by the weight of the heaviest item in the room that you can lift\".", "id": "d8c3cmm"}, {"comment": "This has absolutely nothing to do with Haskell in particular, but all IO or interaction with things external to the program (like the OS's scheduler), are modeled mathematically very nicely with nondeterminism. Nondeterminism is a corenerstone of computation for over 60 years, and the idea of oracles goes back to Turing.", "id": "d8c5bs3"}, {"comment": "> Yes yes, no animals were harmed, because you don't look in the box. I get it.\n\nNot quite. You only look in the box once: at the point at which you _have to_ interact with the world outside the program. So the Haskell runtime calls `unsafePerformIO` for you, as a convenience, and your code gets all the benefits of referential transparency.\n\n> It'd be fun if Haskell's approach was actually used in math. \"To obtain the next value of this infinite list of integral numbers, throw dice\".\n\nThat essentially _is_ how a referentially transparent random number generator works. More interestingly, probability distributions form a [monad](https://hackage.haskell.org/package/probability), so probabilistic functional programming is a thing.", "id": "d8c6xbf"}, {"comment": "> That essentially is how a referentially transparent random number generator works.\n\nThat's why I said it. But it's not how math and mathematical functions work. It's a kludge.", "id": "d8cdkc3"}, {"comment": "> But it's not how math and mathematical functions work.\n\nWell, actually, it is: an infinite list is a perfectly good [coinductive data structure](http://www.cs.umd.edu/~micinski/posts/2012-09-04-on-understanding-coinduction.html). [Random number generation](https://www.schoolofhaskell.com/school/starting-with-haskell/libraries-and-frameworks/randoms) is an effect, so you do it in a [monad](https://en.wikipedia.org/wiki/Monad_(category_theory\\)), which is a perfectly lovely construct from category theory, a \"pure theory of functions,\" as [Dana Scott](http://www.megacz.com/thoughts/what.is.category.theory.html) put it. What may be unfamiliar from pure mathematics is the relationship between monads and \"doing things.\" That key insight came from [Eugenio Moggi](https://core.ac.uk/download/pdf/21173011.pdf).", "id": "d8coza8"}, {"comment": "Now, I could be wrong about this, but I believe that Moggi's discussion of monads in the context of IO requires the monads themselves to be defined externally to the language. Anyway, Moggi's solution is a way to represent IO *within the FP formalism*. Turing's oracles -- which mathematically represent IO in the TM formalism -- are a far older, more established, more familiar formulation of IO in \"pure mathematics\", as is the representation of IO in various FSM models, used in the well-formalized synchronous languages. However, all fall pretty far away from what 99% of mathematicians do (i.e. \"ordinary math\"); Leslie Lamport calls it \"computer science math\". Functional programming is not the source of mathematical views of computation. If anything, it is so far the FP representation is among the least mature ones. Much of the work done in theoretical FP these days is precisely to fill in the holes.\n\nIn fact, even the very concept of a function (with extensional semantics) in FP is different from the concept of a function used in virtually all of math. You're free to believe that mathematicians are wrong not to be constructivist (personally I have no opinion on the matter; the debate has been raging for a hundred years), but the fact is that almost none of them currently are.", "id": "d8deic3"}, {"comment": "> your code gets all the benefits of referential transparency.\n\nThere is no well accepted definition of referential transparency, and in any event, the definitions [are not so simple](http://stackoverflow.com/a/9859966). Reddy says that it was Strachey [who first introduced the term to PLT](http://www.itu.dk/courses/BPRD/E2009/fundamental-1967.pdf), and in the context of imperative languages (i.e., to show that imperative languages are referentially transparent). In any event, whatever it is you choose to call referential transparency, if you apply it to an IO monad, then it applies to imperative code as well.\n\n> That essentially is how a referentially transparent random number generator works.\n\nDitto. Imperative and monadic are *the same thing* in that regard. You either apply the term \"referentially transparent\" to both (as was the original intent), or to neither. In other words, a random number generator and a referentially transparent random number generator are the same thing.\n\n", "id": "d8ckew1"}, {"comment": "We are talking about functions. Function has its definition. As long as you meet that definition you are done. Fact that compiler will translate these functions into program that has effect on the outside world isn't important for definition of a function, is it?", "id": "d8ciavq"}, {"comment": "> they don't produce anything meaningful \n\nI don't think that computer science theory cares the slightest bit about the \"meaning\" of things.", "id": "d8bzef7"}, {"comment": "Yes, I'm sure computer science is about getting a program to make things, no matter what things. Just at least a few of them things. That's the goal.", "id": "d8bzk7d"}], [{"comment": "Saying a language is impure because it has the IO monad is misunderstanding what the IO monad is. It is *not* an effect, any more than a list of groceries saying to buy milk and cookies is the same thing as an actual bottle of milk and a box of cookies.\n\nThe proper interpretation is that the IO monad is constructing the shopping list, but the shopping list doesn't *do* anything. Haskell does construct the shopping list 100% purely: there is no uncertainty involved whatsoever in constructing a list that says \"buy milk and cookies\".\n\nOnce this pure shopping list is constructed, you can interpret it however you want. Going to the store and performing side effects *is not* the only valid interpretation (though it's the most common). But it's just as valid to look over the list and see whether the person is fond of purchasing high-calorie foods--which would also be a pure computation.", "id": "d8bxfh1"}, {"comment": "But the article does not mention the word monad at all!!!", "id": "d8by7sc"}], [{"comment": "Well, a programming language that is really 100% purely functional would be useless except as a textual calculator. You absolutely **need** side-effects at the end of the day, even if you just want to print to a screen/file/database.", "id": "d8buwbf"}, {"comment": "You need _effects_, not _side_ effects. What's brilliant about Haskell is that it offers facilities for manipulating state, doing I/O, etc. that maintain referential transparency (\"purity\").", "id": "d8c0qd8"}, {"comment": "> What's brilliant about Haskell is that it offers facilities for manipulating state, doing I/O, etc. that maintain referential transparency (\"purity\").\n\nIt's very brilliant in online arguments (especially if we don't mind the mutually contradicting statement of \"it maintains purity while manipulating state\"), but in practice what do you get out of it?\n\nThe graveyard of computing is full of brilliant, but not that useful concepts. ", "id": "d8c4dk7"}, {"comment": "> It's very brilliant in online arguments (especially if we don't mind the mutually contradicting statement of \"it maintains purity while manipulating state\")...\n\nIt's not actually a contradictory statement, but the [definition of \"purity\" and \"referential transparency\"](http://blog.higher-order.com/blog/2012/09/13/what-purity-is-and-isnt/) is more subtle than is generally understood. There's a nice example of manipulating state\u2014even in-place\u2014purely [here](https://apocalisp.wordpress.com/2011/03/20/towards-an-effect-system-in-scala-part-1/), and of doing I/O purely [here](https://apocalisp.wordpress.com/2011/12/19/towards-an-effect-system-in-scala-part-2-io-monad/).\n\n> ...but in practice what do you get out of it?\n\nA few things, all of which revolve around being able to compose functions knowing that the composed function will work correctly if the functions it's composed from do. In general, we call this [\"equational reasoning\"](http://www.haskellforall.com/2013/12/equational-reasoning.html). There are also some ancillary benefits, like much safer concurrency constructs.\n\nTo me, though, the real killer is having a set of design patterns that, since they're defined in terms of mathematical laws, are guaranteed to work, and work together, period, the end. These patterns come from abstract algebra or category theory, so they have weird names and sound kind of off-putting: semigroup, functor, applicative, traversable, monoid, monad... but once you know them (and they're all really ridiculously simple) and, most importantly, what you can do with anything that is one of them, you find you're getting the kind of code reuse and predictability that OOP always promised, but has never delivered (and, it turns out, can't).\n\nRob Norris' [Programs as Values](https://tpolecat.github.io/presentations/lambdaconf-15.pdf) spells this out well, by defining a monad for dealing with a JDBC `ResultSet`. His slides show a lot of the functions you get for free that are useful with `ResultSet`s, but have nothing to do with `ResultSet`s _per se_: they're available on any monad/monoid/applicative/functor/semigroup...", "id": "d8c6p7g"}, {"comment": "> It's not actually a contradictory statement, but the definition of \"purity\" and \"referential transparency\" is more subtle than is generally understood. \n\nIt's not only subtle, it's pretty vague and ill-defined. For example, there are a lot of actions that one would consider side effects (such as sleeping, or anything time related) that are conveniently handwaved away by a lot of FP advocates whenever these actions get in the way of them being able to declare their function pure.\n\n> A few things, all of which revolve around being able to compose functions knowing that the composed function will work correctly if the functions it's composed from do.\n\nThat's a pretty useless claim, though, since it applies to non pure functions as well: they work fine as long as all the functions they call work fine.\n\nIn my experience, purity (and referential transparency in general) is pretty useless, or certainly not as useful as composition is. Rx is a great example of that claim: the composition of all the operators is extremely powerful and leads to clean and understandable code, but a lot of these operators are not referentially transparent (and can't easily be).\n", "id": "d8camx8"}, {"comment": "> That's a pretty useless claim, though, since it applies to non pure functions as well: they work fine as long as all the functions they call work fine.\n\nBTW, this is true neither for imperative nor functional languages. No matter how correct are the components, the difficulty of ensuring that the composition is correct is not only a function of the number of components but of their respective complexity. This important result [was proved in 2005](http://www.lsv.ens-cachan.fr/Publis/PAPERS/PDF/DLS-jcss-param.pdf) (although it hides under the obscure name \"model checking isn't fixed-parameter tractable\"). \n\nThis is easily demonstrated by the following simple program:\n\n    long foo(long x) {\n        if (x <= 2 || (x & 1) != 0) return 0;\n        for (long i = x; i > 0; i--)\n            if (isPrime(i) && isPrime(x - i))\n                return i;\n        crash(); // reachable?\n    }\n\nAssuming `isPrime` correctly classifies prime and non-prime integers. Does `foo` ever crash? We've been trying to figure it out for almost 300 years with no success. The problem is that regardless of `isPrime`'s correctness (and apparent simplicity), it's state space is so complex that even simple compositions of it are nigh impossible to figure out.\n\nIf correctness were composable, then programs would be easily verified regardless of their size if they were only built in a structured way, as nearly all programs are, but this is true neither in theory nor in practice. Clearly even Haskell programs contain lots of bugs (and not significantly less than imperative programs).\n", "id": "d8db9st"}, {"comment": "> It's not only subtle, it's pretty vague and ill-defined.\n\nThat's an odd claim to follow a post that links to a very concrete, well-defined definition with.\n\n> For example, there are a lot of actions that one would consider side effects (such as sleeping, or anything time related) that are conveniently handwaved away by a lot of FP advocates whenever these actions get in the way of them being able to declare their function pure.\n\nThat's simply not true, which is apparent when you look at tools like [fs2](https://github.com/functional-streams-for-scala/fs2) and its [time](https://github.com/functional-streams-for-scala/fs2/blob/series/0.9/core/shared/src/main/scala/fs2/time/time.scala) module. Note, in particular, the [`sleep`](https://github.com/functional-streams-for-scala/fs2/blob/series/0.9/core/shared/src/main/scala/fs2/time/time.scala#L80-L85) function.\n\nThen consider actual FRP frameworks like [reactive-banana](https://wiki.haskell.org/Reactive-banana). There's no handwaving: it deals with time and interactivity, and does so referentially transparently.\n\n> That's a pretty useless claim, though, since it applies to non pure functions as well: they work fine as long as all the functions they call work fine.\n\nThat's not true: a function that works fine in isolation in imperative code very often _won't_ work fine when composed with another function in imperative code. The obvious examples are when the functions share mutable state whose manipulation needs to be sequenced correctly, or the functions do I/O that needs to be sequenced correctly, or the functions are concurrent.\n\n> In my experience, purity (and referential transparency in general) is pretty useless, or certainly not as useful as composition is. \n\nComposition is only safe given referential transparency. Granted, a lot of people are willing to roll the dice, but why should they?\n\n> Rx is a great example of that claim: the composition of all the operators is extremely powerful and leads to clean and understandable code, but a lot of these operators are not referentially transparent (and can't easily be).\n\nNo one, least of all me, is claiming violating referential transparency isn't _convenient_. But I think it's a bad idea, tantamount to giving up prematurely. Something like [radioactive](https://github.com/radioactive/radioactive) might be today, or might evolve to become, a better approach to using Rx (with [radioactive.rx](https://github.com/radioactive/radioactive/wiki/radioactive.rx)) in JavaScript. For, e.g. Scala, you might look at something like [Monix](https://monix.io/) instead.\n\nSo I guess I just don't find the argument against referential transparency compelling, even given claims about difficulty dealing with, e.g. time.", "id": "d8cr067"}, {"comment": "> Composition is only safe given referential transparency.\n\nThis statement makes no sense. For one, [imperative languages are referentially transparent](http://www.itu.dk/courses/BPRD/E2009/fundamental-1967.pdf) when their semantics are considered carefully. For another, almost every machine instruction -- including destructive memory updates -- is referentially transparent when their semantics are considered carefully, and yet their compositions tend to have bugs. I mean, you could compile any binary to a monadic machine-code interpreter in Haskell, and voila, every program is referentially trasnparent; how is it safe? Finally, Haskell programs have lots of bugs. So, what does \"safe\" mean? \n\nYou are, of course, correct that you need to worry less when composing pure functions, which is why they're generally good practice. But, again, I'm not sure what you mean by \"safe\"; let's say that this has no theoretical impact on correctness. Also monadic code is the same as imperative code in that regard.\n\nIn general, you are extrapolating rather minor (though far from useless!) theoretical points into grand theoretical achievements that just aren't there and can't be there. I know you and I have a difference of opinion on the precise practical contribution of PFP, but this should raise a red flag: if prior to PFP -- with category theory, type theory, and all the other theories you think are relevant -- programming languages were in a total darkness, whereas now we have the path to full reasoning abilities through the power of referential transparency and equational reasoning -- how come no one has ever claimed a 100x increase in program correctness/productivity when switching to PFP? I won't argue whether it's closer to 1.1x (as I claim) or 1.5-2x as you claim; how come such a theoretical breakthrough hasn't yielded a 100x improvement? Similarly, how come people working on software verification in pure functional languages don't report a 100x improvement over those verifying C (there are significant benefits, but not so large, and not for the reasons you mention)? The answer is that the local properties guaranteed by PFP -- while very convenient in many cases -- do not scale to large global gains. Whatever benefits they do yield, if any, is through an accumulation of local savings, which do not amount to a whole lot (but perhaps shouldn't be discounted).", "id": "d8db4tt"}, {"comment": "> That's not true: a function that works fine in isolation in imperative code very often won't work fine when composed with another function in imperative code.\n\nYou left out the most important part of your original claim:\n\n> A few things, all of which revolve around being able to compose functions knowing that the composed function will work correctly if the functions it's composed from do.\n\nIf all functions called by this function work correctly, then that function will work correctly too. This applies to all functions, referentially transparent or not.\n\n> No one, least of all me, is claiming violating referential transparency isn't convenient. But I think it's a bad idea, tantamount to giving up prematurely. \n\nSure, we all have opinions about this. I don't think it's a bad idea, just one that should be weighed every time you ask yourself the question.\n\nBesides, the types alone still won't prove that your function is correct, there's this pesky concept of function body, which can still be buggy. Tests have the merit of verifying what types alone can't: your actual code instead of just the function signature.\n\nJust because a function can't formally be proven that it's correct doesn't mean it's incorrect.\n\n", "id": "d8d0y01"}, {"comment": "> If all functions called by this function work correctly, then that function will work correctly too. This applies to all functions, referentially transparent or not.\n\nThat's simply incorrect, as experience shows very quickly. Bugs from incorrectly-managed shared state, I/O, etc. are literally everyday occurrences in imperative/OO programming. The level of inaccuracy expressed here makes me seriously question whether you're just trolling.\n\n> Besides, the types alone still won't prove that your function is correct, there's this pesky concept of function body, which can still be buggy.\n\nThis depends upon the specificity of the types and the expressive power of the type system. For example, in [Doobie](https://tpolecat.github.io/doobie-0.3.0/00-index.html), we know that `ConnectionIO[A]` represents a computation that takes place in a context where a `java.sql.Connection` is available, and returns an `A`. What a [`ConnectionIO[A]`](https://github.com/tpolecat/doobie/blob/v0.3.0/core/src/main/scala/doobie/free/connection.scala#L292-L297) can do is far from arbitrary: it's a free monad derived from an algebra that wraps `java.sql.Connection`. In particular, to run a `ConnectionIO[A]` and get the `A`, we need to `.transact` with a `Transactor[M]`. Doing so gives us an `M[A]`, which is to say, a monad that, when run, gives us the `A`. One of the things that's great about this, as the [first three programs](https://tpolecat.github.io/doobie-0.3.0/03-Connecting.html) demonstrate, is that you have the full power of scalaz's monad typeclass and its supporting typeclasses, like applicative, at your fingertips. So `42.point[ConnectionIO]` is a perfectly valid `ConnectionIO[Int]`, as is `sql\"select 42\".query[Int].unique`, as is:\n\n    for {\n        a <- sql\"select 42\".query[Int].unique\n        b <- sql\"select random()\".query[Double].unique\n    } yield (a, b)\n\nas is:\n\n    val a = sql\"select 42\".query[Int].unique\n    val b = sql\"select random()\".query[Double].unique\n    (a |@| b).tupled\n\n> Tests have the merit of verifying what types alone can't: your actual code instead of just the function signature.\n\nTests are categorically dual to types, providing existential quantification to types' universal quantification. Tests are definitely useful when your types aren't precise enough. In particular, property-based tests help close the gap between the proofs types give (because of that \u2200 thing) and the \u2203-nature of tests by generating random data and running tests up to some maximum threshold, so you have some probabilistic assurance that the property \"always\" holds (\u2204x:\u00acP(x)). I'm a fan... when your types aren't precise enough. Or, to be fair, when it's too costly to make them precise enough.\n\n> Just because a function can't formally be proven that it's correct doesn't mean it's incorrect.\n\nNo, but it's best to place your bets as if it did.", "id": "d8d4bkz"}, {"comment": ">  Bugs from incorrectly-managed shared state, I/O, etc. are literally everyday occurrences in imperative/OO programmin\n\nBut then these functions don't meet the premise: the functions they are calling are not behaving as expected.\n\n> The level of inaccuracy expressed here makes me seriously question whether you're just trolling.\n\nOh please. Don't tell me you're one of these people who automatically classifies someone who challenges them or disagrees with them as a troll. But if it's more convenient for you to just walk away from this interesting discussion with this silly excuse, be my guest.\n\n> What a ConnectionIO[A] can do is far from arbitrary\n\nSure but we're talking about what the method of the function is doing, not the type. For example, make a typo in the SQL that the function emits and your function is broken. Types will never save you from that. Tests will, though.\n\n> Tests are categorically dual to types\n\nNo, because tests can prove a superset of what types can prove. For example, types will never be able to tell you that a function that multiples an `int` by 2 is incorrect simply because all they can see is `Int -> Int -> Int` and nothing more. A test will prove you that your function is correct (with QuickCheck or similar).\n\n", "id": "d8d5loi"}, {"comment": ">>> But then these functions don't meet the premise: the functions they are calling are not behaving as expected.\n\n>> The level of inaccuracy expressed here makes me seriously question whether you're just trolling.\n\n>> Oh please. Don't tell me you're one of these people who automatically classifies someone who challenges them or disagrees with them as a troll. But if it's more convenient for you to just walk away from this interesting discussion with this silly excuse, be my guest.\n\nOK, I'll try: do you not see a difference between \"works as expected in isolation\" and \"fails when called by some other function in context X?\"\n\n> Sure but we're talking about what the method of the function is doing, not the type. For example, make a typo in the SQL that the function emits and your function is broken. Types will never save you from that. Tests will, though.\n\nThere's certainly more opportunity for failure when parsing an arbitrary string, and yes, that's a good example of where you want tests. However...\n\n> No, because tests can prove a superset of what types can prove.\n\nNo, they can't, because you can't test for all values of a type with an infinite number of inhabitants. Also...\n\n> For example, types will never be able to tell you that a function that multiples an int by 2 is incorrect simply because all they can see is Int -> Int -> Int and nothing more.\n\nThat is, again, not true: dependent types can express \"times 2\" at the type level. See [Shapeless](https://github.com/milessabin/shapeless), [Idris](http://www.idris-lang.org/), [Agda](http://wiki.portal.chalmers.se/agda/pmwiki.php), [Coq](http://coq.inria.fr)...\n\n> A test will prove you that your function is correct (with QuickCheck or similar).\n\nQuickCheck doesn't do proofs. It gives you probabilistic confidence given 100 attempts (or whatever you change the default number of attempts to). That's very helpful, for sure, but falls short of `A => B` (`\u2200a:A,\u2203b:B`).", "id": "d8df8jt"}, {"comment": "> the definition of \"purity\" and \"referential transparency\" is more subtle than is generally understood. \n\nThat is *a* definition; not quite *the* definition. It seems like the term is commonly more used by FP practitioners; it appears rarely in academic literature and almost not at all by leading scholars since the 90s.\n\n> There's a nice example of manipulating state\u2014even in-place\u2014purely here, and of doing I/O purely here.\n\nNot surprising as the term \"referential transparency\" was introduced from philosophy to computer science in 1967 by Strachey, in a [paper](http://www.itu.dk/courses/BPRD/E2009/fundamental-1967.pdf) that shows that imperative languages are referentially transparent.", "id": "d8es9cw"}, {"comment": "> A few things, all of which revolve around being able to compose functions knowing that the composed function will work correctly if the functions it's composed from do. In general, we call this \"equational reasoning\". There are also some ancillary benefits, like much safer concurrency constructs.\n\nAre you serious. Do you think I compose code in non-functional languages with fear in my heart that it might not work? Composition is a property of structured languages, which basically all languages today are. Except Brainfuck.", "id": "d8cdgee"}, {"comment": "> Are you serious.\n\nCompletely.\n\n> Do you think I compose code in non-functional languages with fear in my heart that it might not work?\n\nIf you don't, you should. In the general case, after all, it doesn't work.\n\n> Composition is a property of structured languages, which basically all languages today are. \n\nI suspect you're using an informal definition of \"composing.\" I mean, literally, function composition: `f(x) \u2218 g(x) == f(g(x))`. This works if the functions are referentially transparent, otherwise all bets are off. When we combine this observation with the need to control effects with monads, we get monadic functions, `A => M[B]` where `M` is a monad, and if we wish to compose an `A => M[B]` with a `B => M[C]` to get an `A => M[C]` we use Kleisli composition, as described [here](https://www.quora.com/Haskell-programming-language-What-are-some-practical-uses-of-Kleisli-composition/answer/Michael-O-Church). Again, this works, 100% of the time, no exceptions, and that's why we do it.\n", "id": "d8cpjd7"}, {"comment": "> In the general case, after all, it doesn't work.\n\nWhat is it exactly that you think \"works\" in the general case when composing functions in PFP (let alone when monadic effects are concerned)? Well, a composition of pure functions is itself pure. That is a good thing in many circumstances, but I'm not sure how that would amount to \"works\". In general, the local properties enforced by PFP do not (and cannot) generalize to global properties. If they did in the general case, I could show you how I start breaking theorems right and left.", "id": "d8deobs"}, {"comment": "> If you don't, you should. In the general case, after all, it doesn't work.\n\nWell I don't make engineering choices based on prejudice and paranoia, but evidence. \n\nA meteorite may strike me as I walk on the street, but I'm not afraid of walking outside without a helmet. Likewise with languages that *allow* mutable state, but just as easily allow you to write pure functions.\n\n> I suspect you're using an informal definition of \"composing.\" I mean, literally, function composition: f(x) \u2218 g(x) == f(g(x)). This works if the functions are referentially transparent, otherwise all bets are off.\n\nYou may think OOP programmers write with their eyes closed, but \"referentially transparent\" functions (aka with no shared mutable state, no effects, etc.) are very common in imperative languages. It's common sense to separate nullipotent functions from procedures with effects, there are even architectures based around it like CQRS. The concept of functional composition is not blowing my mind, I use it all the time, especially for data transform, validation etc., and the lack of a dedicated operator (which functional languages tend to have) is hardly significant. I just call it \"pipelining\", BTW, sorry to trivialize something you hold so dear.\n\nProbably the most significant difference between us here, is that we both realize the dangers of reckless use of mutable state, we're both disciplined about when to use, but unlike you, I don't feel like I need to draw a hard boundary for me, because it's quite obvious when you *use and mutate state*.\n\nSure, enforcing it from the platform has benefits, but they aren't related to *function composing* but rather things like lazy execution, automatic memoization and so on, which are interesting, and also are the cause of functional programs that are very hard to profile in terms of performance and RAM use... Which is why I'm not exactly missing these features (if I need to make something lazy, or cache it, I just do it explicitly).", "id": "d8cqk3i"}, {"comment": "> Probably the most significant difference between us here, is that we both realize the dangers of reckless use of mutable state, we're both disciplined about when to use, but unlike you, I don't feel like I need to draw a hard boundary for me, because it's quite obvious when you use and mutate state.\n\nYou're right\u2014we agree! I just happen (very much by accident) to work on a large codebase with a large team, and I guess I'm affected a lot, too, by my sense that JavaScript was a perfectly nice little language for writing input validation scripts etc. but is a nightmare at scale, so I definitely take an \"enforce principles all the way down\" stance so as to avoid issues as either the code or the team grow. The truth is that I've written a lot more Scala and OCaml that _isn't_ referentially transparent than Scala that is. But what I suppose I've come to believe is that referential transparency is easy enough in languages in which it's not the default, like Scala and OCaml, that it's worth doing anyway.\n\nBTW, I also agree that laziness is the wrong default evaluation strategy, and am happy that, for example, [Idris](http://www.idris-lang.org/) eschews it.", "id": "d8cs728"}, {"comment": "> Well, a programming language that is really 100% purely functional would be useless except as a textual calculator. \n\nMaybe more people should be willing to admit that when they argue that \"functional programming\" is the bright future of programming.\n\nI think functional programming is a very solid aspect of programming that general purpose languages can support, but as you said it often can't achieve much *on its own*.", "id": "d8bv54h"}, {"comment": ">> Well, a programming language that is really 100% purely functional would be useless except as a textual calculator.\n\n> Maybe more people should be willing to admit that when they argue that \"functional programming\" is the bright future of programming.\n\nThe reason we don't is that it isn't true.\n\nIn functional programming, we rely on [\"purity,\" or \"referential transparency,\"](http://blog.higher-order.com/blog/2012/09/13/what-purity-is-and-isnt/) for a number of reasons. Providing a safer context for concurrency and supporting [equational reasoning](http://www.haskellforall.com/2013/12/equational-reasoning.html) about our code are benefits we talk about a lot.\n\nWhat seems to be hardest to explain, though, is that we get this without any difficulty in manipulating state, doing I/O, etc. In other words, we can still develop the whole panoply of kinds of software we want to develop, including [GUI programming](https://wiki.haskell.org/Reactive-banana), [microservices](http://haskell-servant.readthedocs.io/en/stable/), etc. \"purely.\"\n\nSocially, I think there's some difficulty in narrowing the gap between the definition of \"purity\" and \"referential transparency\" in the first link and how it's reflected in frameworks like reactive-banana or servant, and what it means in terms of more predictable, easy-to-reason-about, correct code. Many people are understandably skeptical. I don't actually use Haskell on the job\u2014I use Scala and the [scalaz](http://eed3si9n.com/learning-scalaz/) ecosystem, including [scalaz-stream](https://gist.github.com/djspiewak/d93a9c4983f63721c41c)\u2014but I'm happy to try to answer any questions you may have about either.\n\n", "id": "d8c1bx1"}, {"comment": "Purity, referential transparency and equational reasoning make little sense, when, say, you query an SQL database, and in every run of your program the results of the query can be different, including all kinds of possible error states you can encounter.\n\nSuch programs are functional, pure and deterministic only on a technicality, but not in spirit. And while math is absolute, the \"spirit\" matters, because it means your program may branch in millions of ways during its course as it implicitly or explicitly produces side-effects in IO, and then it's not any different than writing imperative code, in practice. In fact, it easily gets worse than imperative code.\n\nThe benefits of purity are \"cashed out\" when all of these external concerns are done in advance by some other entity, and given to you as an in-memory input to work with. At this point you can't, however, say that your functional program is interacting with the world, it's merely taking input from the caller, and returning output to it.\n\nI don't know how scalaz-stream works precisely, and as far as I know Scala is not purely functional at all, so I'm not quite sure what context you use to make these statements.\n\nBut I'd like to hear what's the benefit of calling an SQL database, or any other remote API, in a \"functional\" way. Especially considering the countless way this call can screw up, including returning invalid data, or timing out.", "id": "d8c1k6n"}, {"comment": ">But I'd like to hear what's the benefit of calling an SQL database, or any other remote API, in a \"functional\" way. \n\nThe OP actually goes over this when he talks about \"restricted effects.\" Using an algebra to describe side-effectful computations instead of performing them directly provides you with a variety of benefits. See [haxl](https://github.com/facebook/Haxl) for example.", "id": "d8c4epb"}, {"comment": "> The OP actually goes over this when he talks about \"restricted effects.\" Using an algebra to describe side-effectful computations instead of performing them directly provides you with a variety of benefits.\n\nLike what, though? What happens here is that you use a function in Haskell to assemble an imperative program in an IO type, which is then executed by the runtime like any other imperative program.\n\nIt's a neat way to try and have your cake and eat it, too, but in the end there's a clear stateful/imperative part of Haskell, which doesn't fit any definition of \"pure\" and \"functional\".\n\nThe IO type might as well be an opaque string where you assemble JavaScript code and then the runtime passes it to eval(). The string is \"pure\". The effect of it isn't.", "id": "d8c4j45"}, {"comment": "What is your point? A pure function that produces a string of JavaScript is still a pure function.", "id": "d8c574z"}, {"comment": "Or we build real-world systems on top of meaningful values, referential transparency and so on, rather than these imperative notions of input and output. A lot of the time you can model your real-world business functionality as the evalutaion of an expression, which can absolutely be done purely-functionally. It's just (currently) hard to do that in a generic way, and few if any languages are sufficiently generic in how they interface with the real world (you could replace `IO` with something suited to your domain, but then you'd have a programming language that would only be usable in that domain).", "id": "d8byk93"}, {"comment": "Functional programming is a sandbox where chaos doesn't exist, and we have a strict set of mathematical guarantees about our program behavior.\n\nUnfortunately the world out there is pure chaos. This is why while, as I said, functional programming will always be a useful aspect of programming, you need something standing between functional programming and the outside world, and beating chaos into order for you.\n\nAnd that something is typically aware of nuisances like time, state, non-deterministic behavior, untrusted clients and servers, hardware failures and so on.\n\nDefining a functional model for dealing with all this is an NP-hard problem. It seems plausible, but if you try to tackle it, it ends up requiring unbounded, possibly infinite complexity.\n\nThink about the non-functional part of your program as a good manager, and the functional part as a good specialist.\n\nIt's the job of the specialist to engineer a product with specific given parameters. It's a functional problem: given this input, produce this output.\n\nOn the way to this goal, you'll have foreign interference in the form of budgetary limits, nosey managers from other departments messing in your work, strategy shifts across the company, dependencies on other teams who don't always care or understand what you want and so on.\n\nA good manager takes all those complexities and hides them from you, the specialist, by making them appear well-defined, and trivial, despite it's god damned chaos behind the scenes. But as the specialist you never get to learn about it.\n\nBut if it weren't for the manager, you wouldn't be able to accomplish a single thing unshielded in the real environment you're operating.\n\nAnd so that's why we have functional programming, but also stateful imperative OOP.", "id": "d8byu09"}, {"comment": "A lot of this hinges on the definitions that you use.\n\nFor instance, I always say that ruby is the most prototypical among the traditional class-based programming languages.\n\nYou can also reason that you use other OBJECTS to create new objects - and that these objects are the blueprint (the \"class\").\n\nReally so much depends on the definitions that are used. People need to define these things more clearly and also consistently use them (which is another big hurdle to overcome apparently).", "id": "d8by8pj"}, {"comment": "A functional language is based on the math definition of a function and has no concept of time or state. It simply a series of equations for transforming data. \n\nAs such, it's quite clear in both its benefits and shortcomings. ", "id": "d8byfx1"}], [{"comment": "> Haskell is Not a Purely Functional Language \n\nI think it's a horrible title.\n\nShould have NOT JUST in there.\n\nAuthor argument that Haskell is more than just a purely functional language and it has features that are similar to popular language such as Java, etc..\n\nAs a realist, I know this sounds like I'm waging a religious war, but Haskell is never going to be popular in term of Java and the likes. \n\nIt will be a great language to expand your mind and makes you a better programmer, but it's a niche language. I don't see any killer framework and the likes to catapult Haskell to better standing. ", "id": "d8buhn2"}, {"comment": ">  is more than just a purely functional language \n\nIf you have more than purity, then you don't have purity.", "id": "d8bzg0u"}], [{"comment": "> I propose instead that, for most programmers, it's better to think of Haskell as a language with restricted effects.\n\nThat's wrong too. There's nothing restricted about Haskell in that regard.\n\nA more accurate way to characterize Haskell would be to say that side effects are encoded in its type system.\n", "id": "d8c0pl1"}], [{"comment": "[A more compelling argument from Conal Elliott](http://conal.net/blog/posts/is-haskell-a-purely-functional-language).", "id": "d8c0njz"}], [{"comment": "I am disappointed.\n\nThe blog entry does not use the word monad at all. :(", "id": "d8by6ya"}], [{"comment": "Yes it is. /thread", "id": "d8bu11k"}], [{"comment": "Right, I would tweak it to make it a bit harder to handle input and output. /s", "id": "d8buiz1"}]]], "51p6uy": ["Static Typing vs WebSockets", "2016-09-08 06:52:56", 1, "http://yogthos.net/posts/2016-09-06-Static-Typing-WebSockets.html", [[42, "This argument makes me want to claw out my eyes.\n\nIf you are writing test to guarantee you are using types appropriately then you are effectively created a statically typed language. But you have had to do extra work to do it and your compiler takes forever to run now.\n\n\n"], [27, "Number of times I've been bitten by `unsafeInterleaveIO`: 2\n\nNumber of times I've been bitten by unexpected nulls on the JVM (which a simple type system can prevent): much more than 2"], [27, "The messages weren't being dropped because of unsafeInterleaveIO. The faulty version didn't even use unagi-chan. It used Control.Concurrent.Broadcast, a library that doesn't provide channel semantics (and it isn't supposed to, it's an entirely different synchronization mechanism - one that simply broadcasts the most recent value).\n\nI didn't run the benchmark before pointing out it's dropping messages, I just looked at the types."], [17, "Type safety has nothing to do with this. The author of the Haskell implementation of that benchmark did not read the documentation of a library he was using. Yes, proper testing would have probably caught it, but there is no need for this false dichotomy between testing and static types."], [7, "The field of automatic program verification is a vast field. Types, contracts, specifications are several ways of going about it. Grinding axes though does not help anyone. The engineering landscape when it comes to programming is pretty vast so I think we can all get along.\n\nWhat would be nice to see is actual field studies and analysis of trade-offs when it comes to the kinds of verification tools that people use. \n\nTests are pretty well-trodden and no one denies their benefits but just like too much of a good thing I've seen some nightmarish test suites that simply slowed development to a crawl.\n\nSimilarly type systems when properly utilized provide great benefits in terms of excluding various classes of errors automatically and making some runtime failures actual compile time failures but again I think you can go overboard. I don't have a good sense for when type systems become a burden so some analysis on the kinds of cognitive overhead that elaborate types can lead to would be great.\n\nI am enjoying TypeScript's approach to types. Externalizing the type system and making it modular is kinda nice. I'm looking forward to more research that allows one to use more such external modes of reasoning to elaborate and validate code."], [6, "[deleted]"], [0, "People here are idiots. Yogthos is basically the Reza Rahman of the Clojure world. Stop wasting your time and carry on."], [-1, "Please note that the post doesn't argue for or against static typing. It simply highlights the fact that static typing is not a guarantee of correctness. Conversely, most type systems are not expressive enough to provide a meaningful specification for a program. Regardless of the type discipline you prefer, you still need to have a specification and tests that implement it to know what your code is doing."]], [[{"comment": "This argument makes me want to claw out my eyes.\n\nIf you are writing test to guarantee you are using types appropriately then you are effectively created a statically typed language. But you have had to do extra work to do it and your compiler takes forever to run now.\n\n\n", "id": "d7dq5zf"}, {"comment": "I think you missed the point entirely. Types do not provide the kinds of guarantees you're actually interested in, unless you use something like Coq.\n\nWhether you use a static or dynamic language, you need to write specification tests to know what the code is doing. Period. The argument that static typing obviates the need for tests is frankly asinine.\n", "id": "d7dqh1n"}, {"comment": "> The argument that static typing obviates the need for tests is frankly asinine. \n\nI agree, but I don't think anyone has made that argument ever\n\n> Types do not provide the kinds of guarantees you're actually interested in\n\nI'm interested in many guarantees, types are some of them\n\n> Whether you use a static or dynamic language, you need to write specification tests to know what the code is doing. \n\nYes, but you can write fewer/simpler tests, all else being equal, with a static typed language, because SOME tests have already been done for you. Like \"did you pass an integer to the function that has declared it deals only with integers?\" or \"what happens if you pass a string to the function that only can handle floats?\"\n\n\n\n\n\n", "id": "d7dqp6q"}, {"comment": "Also, is imposible to have a decent IDE without static typing.", "id": "d7e3zwi"}, {"comment": ">I'm interested in many guarantees, types are some of them\n\nSpecification tests are a superset of the guarantees offered by types. What types let you do is potentially track down bugs faster when your tests fail. However, you have to spend more time up front encoding the problem you're solving using the type system. It's a trade-off.\n\nWhat most type systems let you express is generally not terribly interesting. The time you spend expressing things via the type system can be non-negligible however.\n\n>Yes, but you can write fewer/simpler tests, all else being equal, with a static typed language, because SOME tests have already been done for you\n\n[citation needed]\n\n>Like \"did you pass an integer to the function that has declared it deals only with integers?\" or \"what happens if you pass a string to the function that only can handle floats?\"\n\nThese kinds of errors are not very interesting in my experience, and are found very early on in the development cycle. It's also worth noting that working with the REPL lets you see exactly what the code is doing each step of the way. Any time I write a function I send it for evaluation and see what it's doing. I never have to guess anything about that.\n\n", "id": "d7dr1eg"}, {"comment": ">However, you have to spend more time up front encoding the problem you're solving using the type system. It's a trade-off.\n\nI personally believe the opposite (i.e. that you spend *less* time when you have static typing - at least with the more modern languages), due to superior tooling, ease of refactoring the structure of your data, and just less time spent on questions like \"do I need to check if this is null?\", \"do I need to check if the object passed into this function has this property?\" and similar.\n\nOf course depends on the use case.\n\n>These kinds of errors are not very interesting in my experience\n\nWhen talking about primitive types (numbers, strings, etc.), I tend to agree. But when dealing with structured data - different kinds of objects with properties, methods, some of them optional, etc., it's a whole other story. Especially when that structure changes during development.", "id": "d7dsp3q"}, {"comment": ">I personally believe the opposite (i.e. that you spend less time when you have static typing - at least with the more modern languages), due to superior tooling, ease of refactoring the structure of your data, and just less time spent on questions like \"do I need to check if this is null?\", \"do I need to check if the object passed into this function has this property?\" and similar.\n\nSure, and that's why you prefer it. I don't find the tooling to be superior, it's just different. Out of curiosity, have you worked with a Lisp and used REPL driven development before?\n\n>I tend to agree. But when dealing with structured data - different kinds of objects with properties, methods, some of them optional, etc., it's a whole other story.\n\nI agree that when you work with imperative languages, dynamic typing can be problematic. However, I found most of these problems simply don't exist when you work in a functional language. You don't have objects and methods and so on. Data is just data and you pass it through a series of functions to get a different piece of data.", "id": "d7dtjan"}, {"comment": ">I agree that when you work with imperative languages, dynamic typing can be problematic. However, I found most of these problems simply don't exist when you work in a functional language. You don't have objects and methods and so on. Data is just data and you pass it through a series of functions to get a different piece of data.\n\nFunctional programming tends to simplify solutions to problems that are \"dataflow driven.\" But if we are talking about a functional language with a pure system for effects (which I would argue is required for a language to truly be functional), things start to get more complicated. 95% of the benefits of monads come from the powerful type system in Haskell (which is really just a shout out to higher kinder types which allows typing structures like monads and functors).\n\nWithout higher kinded types and type classes, you lose the ability to write monadic code that is both polymorphic and typed. You can give up on the very succinct syntax if you opt for a less powerful type system. Or you can have succinct syntax and no static typing. A type system powerful enough to do inference and the polymorphism Haskell does is actually pretty cool.\n\nIf I'm solving a purely computational problem (as your comment seems to imply you tend to work on), it really doesn't matter because I will easily be able to do the typechecker's work. Composing pure functions is something we have all been doing since gradeschool. I write out the types my functions ideally would have in JS all the time. It makes refactoring very easy because I can move functions and parts of functions around, never worrying too much about breaking things. But the first impure function you have already makes this a shit ton more difficult. Having monadic effects would probably help a bit (not necessarily, it is possible to write monadic code that is as bad or worse of a mess than imperative code when done poorly).", "id": "d7duiid"}, {"comment": ">Functional programming tends to simplify solutions to problems that are \"dataflow driven.\"\n\nHaving worked in a functional language for the past 6 years, I can firmly say that all problems can be expressed as being dataflow driven.\n\nI work with Clojure and majority of the benefits come from having a small set of immutable data structures. All the functions in the language operate on the same data structures. Vast majority of the code is written by composing reusable functions from the standard library. These functions do not care about concrete types. When I use something like `map`, `filter`, `reduce`, and so on, they just know how to do the iteration. The domain specific code is passed in. This naturally makes all the code that cares about the concrete types bubble up to a shallow layer at the top.\n\n>If I'm solving a purely computational problem (as your comment seems to imply you tend to work on), it really doesn't matter because I will easily be able to do the typechecker's work. \n\nMy work is primarily building web applications, so I do a lot of UI development, and writing services.\n\n", "id": "d7e2oag"}, {"comment": "> I don't find the tooling to be superior, it's just different.\n\nRight...yet your IDE can't know anything about the kind of data that your functions/values can take. Your tooling have a 'F' in UX.", "id": "d7ee4ki"}, {"comment": "Yes, because everybody wants what you want. It's how the world works.", "id": "d7eetq9"}, {"comment": "You are right. Not everyone is sadistic masochist.", "id": "d7eex2f"}, {"comment": "What can I say, we can't all be like you.", "id": "d7eeyti"}, {"comment": "> Out of curiosity, have you worked with a Lisp and used REPL driven development before?\n\nFrom my experience, REPL driven development is very similar to, but slightly worse than, TDD (test driven development).  The REPL actually wins in terms of being a little faster for development.  TDD gives you similar power in terms of being able to rapidly try out different codes and see what the results are, without having to wait through a long server startup time.  The REPL is faster though in this regard.  However, I think that TDD wins out because in the end you have an automated test suite that catches regressions.", "id": "d7efoif"}, {"comment": ">From my experience, REPL driven development is very similar to, but slightly worse than, TDD (test driven development). \n\nThat's a strange statement. I'm not sure how having more immediate feedback can be construed as a negative.\n\n>The REPL actually wins in terms of being a little faster for development. TDD gives you similar power in terms of being able to rapidly try out different codes and see what the results are, without having to wait through a long server startup time.\n\nThe whole point of REPL driven development is that you never restart the application. Perhaps we're not talking about the same thing here.\n\nWhat I mean by REPL driven development is this. I start the application and it runs the REPL. I then connect my IDE to the REPL and any code I write I can evaluate in the context of the running application.\n\n>However, I think that TDD wins out because in the end you have an automated test suite that catches regressions.\n\nIt's a very common workflow to write test code in the REPL as you're developing, then take the REPL session and turn it into tests.", "id": "d7eghuu"}, {"comment": "> The whole point of REPL driven development is that you never restart the application. Perhaps we're not talking about the same thing here.\n\nYea, and that's a problem. When you finally do restart it who knows what state it will be in compared to your never-ending dev environment.\n\n ", "id": "d7ehvls"}, {"comment": ">\nYea, and that's a problem. When you finally do restart it who knows what state it will be in compared to your never-ending dev environment.\n\nYou do realize that this isn't a problem when you're working with immutable data right? Applications written in a language like Clojure are predominantly stateless. Most of the things that have state in my apps are resources such as database connections or queues.", "id": "d7enhox"}, {"comment": "> That's a strange statement. I'm not sure how having more immediate feedback can be construed as a negative.\n\nI didn't say that immediate feedback is bad.  But in context, a REPL is only *slightly* more immediate than TDD.\n\n> The whole point of REPL driven development is that you never restart the application. Perhaps we're not talking about the same thing here.\n\nYeah, I know.  I was not implying that you have to restart your app with a REPL.  I was saying that \"not restarting \"is something that REPL and TDD have in common.\n\n> It's a very common workflow to write test code in the REPL as you're developing, then take the REPL session and turn it into tests.\n\nAlright, then I'll make a concession and retract my previous statement.  Instead I'll say, doing TDD with a REPL is slightly better than doing TDD without one, but doing TDD without a REPL is still better than doing RDD without TDD.", "id": "d7ek5xk"}, {"comment": ">I didn't say that immediate feedback is bad. But in context, a REPL is only slightly more immediate than TDD.\n\nI can literally run code as I write it with the REPL. I write a function, I run it. I don't have to switch from the editor, setup a test or anything. I find that makes a big difference for me.\n\n> Instead I'll say, doing TDD with a REPL is slightly better than doing TDD without one, but doing TDD without a REPL is still better than doing RDD without TDD.\n\nI find that I often use the REPL to explore the problem space as I might not know what the approach I will take ultimately. So, the REPL session is more than just TDD for me. Once I do have a solution I want to use, then I agree that extracting that into test is very valuable.", "id": "d7ekms1"}, {"comment": "> Out of curiosity, have you worked with a Lisp and used REPL driven development before?\n\nI have. In my AI class, Lisp took significantly longer than VB for doing the same kinds of assignments. \n\nAnd REPL, outside of a console window, is akin to playing guess-and-check. If I truly don't know what I'm doing, for example learning a new library, it makes sense. But the vast majority of the time I want to just sit down and write the program. I don't need to double check my work literally after every line.", "id": "d7efvyb"}, {"comment": ">I have. In my AI class, Lisp took significantly longer than VB for doing the same kinds of assignments.\n\nYou're seriously comparing that to using Lisp professionally with a real IDE?\n\n>And REPL, outside of a console window, is akin to playing guess-and-check.\n\nThat's not how you use the REPL in Lisp though. If you're interested in how the workflow works, you can look at a [recent talk I gave](http://chariotsolutions.com/screencast/philly-ete-2016-2-dmitri-sotnikov-transforming-enterprise-development-clojure/) where I live code a small application. (starts at 11 min)\n\n", "id": "d7egcor"}, {"comment": "I don't write small applications. And I know very well that small app demos are never what its like after you have a few weeks of accumulated code.\n\nBesides, on a good day I'll only run my code once an hour or so. I'll build out the whole feature, write all of my tests, and if I did my job particularly well, run it them once before checking it in. \n\nMy workflow doesn't need a REPL. At most I'll turn on \"Runs tests after compile\", but even that's overkill and a distraction most of the time.", "id": "d7eh4cb"}, {"comment": ">I don't write small applications. And I know very well that small app demos are never what its like after you have a few weeks of accumulated code.\n\nI don't write monolithic applications. Any application can, and should, be broken down into small isolated components you can reason about individually. My team has applications we've been working on for over 4 years now, and we've never had issues with them.\n\nIf anything I find that immutability plays the biggest role when it comes to maintaining large code bases. When I work with immutable data, I'm able to do local reasoning about code. I don't have to know what the state of the entire application is, when I'm working on a specific feature.\n\n>My workflow doesn't need a REPL. At most I'll turn on \"Runs tests after compile\", but even that's overkill and a distraction most of the time.\n\nSure, and there's absolutely nothing wrong with that. It's a different approach. There are different ways to arrive at the same result. However, there's absolutely no empirical evidence out there that one approach is more effective than the other. It's a personal preference.", "id": "d7eha9z"}, {"comment": "> What types let you do is potentially track down bugs faster when your tests fail\n\nThey also:\n\n- Allow compilers to generate faster code.\n- Enable automatic refactorings in your IDE's.\n\nNo big deal.\n\n> These kinds of errors are not very interesting in my experience, and are found very early on in the development cycle\n\nYeah, why bother catching things before you ship when users will be more than happy to file crash reports for your app?\n\n", "id": "d7dsdr9"}, {"comment": ">Allow compilers to generate faster code\n\nThat's not at odds with dynamic typing. For example, Clojure allows you to provide type annotations where you need to optimize things.\n\n>Enable automatic refactorings in your IDE's\n\nI use that all the time in [Cursive](https://cursive-ide.com/) IDE. It does static analysis on Clojure source code, and allows doing most kinds of refactorings you'd expect, such as renaming functions, auto imports, and so on.\n\n>Yeah, why bother catching things before you ship when users will be more than happy to file crash reports for your app?\n\nI think you missed the point of the article. Static types don't prevent you shipping broken code to the users. The WebSocket benchmark was implemented correctly in every **dynamic** language it was attempted in. The language it was implemented incorrectly in was Haskell, a strongly typed language.\n\nMy whole point was that you need specification testing to prevent shipping broken code to users. But by all means continue living with the delusion that if your code compiles it's safe to ship in a static language.\n", "id": "d7dtnrt"}, {"comment": "> It does static analysis on Clojure source code, and allows doing most kinds of refactorings you'd expect, such as renaming functions, auto imports, and so on.\n\nAll of which can break your code unless the developer double checks them.\n\nThere's no magic here: without types, all the IDE can do is guess.\n\n> Static types don't prevent you shipping broken code to the users\n\nThat was never the claim, you are falling prey to the slippery slope fallacy.\n\nJust because you can't ship code that's 100% safe doesn't mean you shouldn't try to ship good code. Statically verified code is safer than non-statically verified code. It's that simple.\n", "id": "d7dtt9q"}, {"comment": ">All of which can break your code unless the developer double checks them.\n\nUn no, that's not how static analysis works.\n\n>There's no magic here: without types, all the IDE can do is guess.\n\nUh no, that's not what happens at all actually. The other common approach is to leverage the runtime via the REPL the way most Lisp IDEs do. This gives the IDE all the information about types that are loaded in the image. You might want to read up on how these things actually work. [Here's](http://marijnhaverbeke.nl/blog/tern.html) some reading to start with.\n\n>That was never the claim, you are falling prey to the slippery slope fallacy.\n\nPerhaps read your own comment again:\n\n>Yeah, why bother catching things before you ship when users will be more than happy to file crash reports for your app?\n\n>Just because you can't ship code that's 100% safe doesn't mean you shouldn't try to ship good code. Statically verified code is safer than non-statically verified code. It's that simple.\n\nI'm afraid you're falling prey to the straw man fallacy. If you actually bothered to read the post you'd see that nobody is arguing for shipping bad code.\n\nWhat I said in the post is that specification tests provide stronger guarantees, and what your type system verifies is a subset of those guarantees. It's that simple.", "id": "d7dtzwm"}, {"comment": "I say this only to help you make your arguments better: some of your responses are attacking more than they need to. You will convince more people if they don't feel belittled. (I'm referring primarily to the \"uh no\" and the \"bothered to read\" parts.)\n\nI do appreciate your interest in the topic however.", "id": "d7dv2e6"}, {"comment": "> static analysis works\n\nUnnecessary approach when your language is backed up by a decent compiler which know everything and anything of your program. ", "id": "d7eera2"}, {"comment": "Oh you mean like the ones for CL that the IDEs like LispWorks leverage?", "id": "d7eeww3"}, {"comment": ">>Allow compilers to generate faster code\n\n>That's not at odds with dynamic typing. For example, Clojure allows you to provide type annotations where you need to optimize things.\n\nRight, but you actually have to specify those yourself. A modern C compiler is so sophisticated these days that even specifying inline is often unecessary for reducing function call overhead.\n\nClojure seems like a nice language, but I see very little reason to use it in a production environment these days over something like JavaScript, Ruby or Python.\n\nAnd sure, V8 is actually a very good JS compiler, but only Chrome users reap the benefits of that. Mozilla's JS interpreter is meh in comparison.\n\nWith C, though, just about every compiler can pull this off", "id": "d7dumc6"}, {"comment": "Full disclosure: I'm primarily a Python developer and have been since 2001, but just a hobbiest Clojure developer.\n\nSo, I'm not looking to like... throw myself into this debate in any meaningful way, but I would like I say that I absolutely love Clojure for webdev because Lisp and functional programming in general operate in a similar way to how I already approach webapps, conceptually. Namely, I treat them as stateless software, and FP discourages use of global state. To me, cookies -- being the only real state on the web -- are just parameters to be passed to a function, not actual state. This is probably a personal thing.\n\nBasically, I reason through webapps and Clojure code in the same ways, so it lends itself quite well to what I do. From my perspective, it just fits perfectly.\n\nAs for a practical reason (one I'm 100% sure you're aware of), it runs on the JVM, so you can use it pretty much anywhere. Java on the server is quite speedy.\n\n\n^^^Also, ^^^parens ^^^feel ^^^like ^^^hugs.", "id": "d7dxqog"}, {"comment": ">Right, but you actually have to specify those yourself\n\nTurns out you don't. Take a look at the example I linked in the article of how [Typed Clojure generates types](https://github.com/typedclojure/auto-annotation) from tests.", "id": "d7e2khy"}, {"comment": "OMG, hahaha...oh dear, you are so desperate. Pointing to an alpha project from another failed project like Typed Clojure. This is too good.", "id": "d7eek35"}, {"comment": "Oh look you're back, I guess you just can't resist me after all. :)", "id": "d7eels8"}, {"comment": "> I use that all the time in Cursive IDE.\n\nHahaha.\n\n> That's not at odds with dynamic typing. For example, Clojure allows you to provide type annotations where you need to optimize things.\n\nAll your approaches relate to typing like peasant, while stalang compilers do all this petty things automatically.", "id": "d7ee62m"}, {"comment": "ROFL", "id": "d7eespd"}, {"comment": "Yawn.", "id": "d7eey8a"}, {"comment": "> However, you have to spend more time up front encoding the problem you're solving using the type system.\n\n*trigger warning: anecdote*  In my experience, static typing *reduces* the upfront cost.  For me, this is because when using a dynamic typing system, I have to keep in my head all the things that the compiler would normally do for me (in a static system).  So I find that static typing lets me focus on the actual problem instead of tedious book keeping (again, b/c the compiler does the book keeping for me).\n\n> These kinds of errors are not very interesting in my experience, and are found very early on in the development cycle.\n\nRight, they are not very interesting errors.  They are in fact the most boring and mundane errors possible.  But they are also *BY FAR* the most common type of error when working with dynamically typed systems (at least in my experience).\n\n\n\n> > Yes, but you can write fewer/simpler tests, all else being equal, with a static typed language, because SOME tests have already been done for you\n> [citation needed]\n\nNope, no citation needed.  It's literally just common sense.  Seriously, just think about it a little.", "id": "d7eefxi"}, {"comment": "See, I use the REPL for all these things.\n\n>Nope, no citation needed. It's literally just common sense. Seriously, just think about it a little.\n\nI have, and I've used static languages for over a decade before moving to a dynamic one. It seems like a lot of people base their view of dynamic languages on something like JavaScript. Just like with static ones there are many kinds of dynamic languages, and all of them are very different from one another.\n\nWhen I work in a functional language backed by immutable data, I very rarely have to keep a lot of things in my head. Things are naturally contextualized and I can do local reasoning when reading code.\n\nWhen I have high level specification tests, they're primarily used as a sanity check. When a test fails, it's trivial to track down the problem in my experience.", "id": "d7eerk7"}, {"comment": ">Specification tests are a superset of the guarantees offered by types. \n\nType checks are a partial mathematical proof, tests only check the correctness of the data that actually passes through the test functions. Calling something as fragile as tests a superset of type guarantees is *so* wrong it upsets me.", "id": "d7e1sdk"}, {"comment": ">Type checks are a partial mathematical proof, tests only check the correctness of the data that actually passes through the test functions\n\nUnfortunately, as the WebSocket example shows. These mathematical proofs are very weak and don't allow you to encode any interesting properties that would let you know that your code is doing what's intended.\n\nConsider something like a sorting function. All the type system tells you is that you passed a list in, and got a list back. It can't tell you that the list has the same number of elements, or that the elements are in correct order. So, it doesn't tell you that the sorting function actually sorts anything correctly.\n\nFor that you need tests. However, once you have these tests, they will necessarily validate the types of the data the function works on.\n\nClaiming that types provide any useful guarantees is far more wrong if you ask me.", "id": "d7e2d8s"}, {"comment": "> For that you need tests. However, once you have these tests, they will necessarily validate the types of the data the function works on.\n\nTests are utterly inadequate when dealing with actual algorithms. I always chuckle when you see someone doing a tutorial on TDD and they try to somehow test their way into the Fibonacci sequence.\n\nTests cannot be exhaustive. They cannot guarantee anything other than that a function works for a few edge cases you have envisioned and the common cases.\n\nYou better have a paper with a proof backing your sorting algorithm.\n\nEither way, both tests and types are nice to have when writing one, or using one.\n\nI can't tell you how _annoying_ it is to change a field in a map in Clojure. Code breaking everywhere, that could be caught by a compiler.", "id": "d7elfk0"}, {"comment": "Most type systems are utterly inadequate when dealing with actual algorithms.\n\nHere's an example for you to consider. Let's say you have a sort function. The function should have the following properties:\n\n* returns the same elements that were passed in\n* elements are in the desired sort order\n\nUnless your type system can encode that effectively, you'll need specification tests to show that the code is doing what was intended.", "id": "d7eo162"}, {"comment": "Yes, for correctness of the algorithm, particularly one of that nature\n\n> You better have a paper with a proof backing your sorting algorithm.\n\nTesting may be your best bet with the actual code, though.\n\nAnd it's still a hassle code related to records in Clojure. And lazy seqs with their HOFs failing at a distance. I don't believe that laziness and dynamic typing are a good mixture.", "id": "d7evzrc"}, {"comment": "Personally, I haven't really had an issue with this working with Clojure professionally. I'm sure it depends on your domain, code base, coding style, and many other factors. This is why both approaches exist. I don't think it's a zero sum game.", "id": "d7ex8bx"}, {"comment": "> For that you need tests. However, once you have these tests, they will necessarily validate the types of the data the function works on.\n\nThis is not true.  Tests only validate the types along the code paths that they exercise, and the more complex the system is the more likely that an end-to-end test will only exercise the happy path.", "id": "d7f4opf"}, {"comment": ">This is not true. Tests only validate the types along the code paths that they exercise, and the more complex the system is the more likely that an end-to-end test will only exercise the happy path.\n\nThat's why you tend to break the system up into small individual components that you can reason about. I'm not sure why static typing proponents always encourage you to build a monolith.", "id": "d7f513z"}, {"comment": "> I'm not sure why static typing proponents always encourage you to build a monolith.\n\nHuh? Where'd you get that idea?", "id": "d7fa4rh"}, {"comment": "Every time the argument invariably turns into \"you just can't maintain large systems in a dynamic language\". My question is why would I want to.", "id": "d7fjxym"}, {"comment": ">However, you have to spend more time up front encoding the problem you're solving using the type system. It's a trade-off.\n\n\nMost of the research on this ( you can browse some of the research by  Andreas Stefik such as http://link.springer.com/article/10.1007/s10664-013-9289-1 ) finds that development time is lowest when function declarations have types declared but function bodies types are optional.  Such as found in C#, C++, F# (if you chose to annotate the function signatures!) and many others.\n\nSo static typing with type inference basically.\n", "id": "d7e22hb"}, {"comment": "The study is paywalled, so I can't tell what the actual results were there. However, development in a language like C# or C++ is pretty slow to begin with. These languages also lack a lot of tooling such as the REPL, that allow you to inspect what the program is doing as you develop it. I'd be much more interested in a comparison with something like Erlang, Clojure, or CL.", "id": "d7e29wo"}, {"comment": "The study didn't compare C# or C++, google around, lots of research on this by him, youtube videos where he talks about it etc.\n\nAnd there are REPLs for both those languages.\n\n", "id": "d7e2qvv"}, {"comment": "> What most type systems let you express is generally not terribly interesting.\n\nMaybe your problem domain is not terribly interesting. For instance, I have code that needs to track different types of time (UT, DT, etc) without mixing them up; a phantom type suffices to rule out entire classes of bugs.", "id": "d7ekbx2"}, {"comment": "Sure, perhaps your domain is far more fascinating than mine. If types help you there, then power to you. However, a lot of people happen to work in domains where types are just not that exciting, so perhaps we don't need the same hammer for every problem.", "id": "d7ekdhr"}, {"comment": ">For instance, I have code that needs to track different types of time (UT, DT, etc) without mixing them up; a phantom type suffices to rule out entire classes of bugs.\n\nCan you go into more detail on this? Perhaps even link to some source code?\n", "id": "d7fa1t9"}, {"comment": "An [old article of mine](http://alaska-kamtchatka.blogspot.com.ar/2012/08/a-helping-phantom-hand.html) about this technique.\n\n*Edit:* If OCaml syntax is not your thing, [here](http://gabrielsw.blogspot.com.ar/2012/09/phantom-types-in-java.html) (Reddit [discussion](https://www.reddit.com/r/programming/comments/zm7f9/phantom_types_in_java/)) and [here](http://gekkio.fi/blog/2013-02-07-increased-compile-time-safety-with-phantom-types.html) are some Java examples.", "id": "d7gx3ed"}, {"comment": "> Types do not provide the kinds of guarantees you're actually interested in\n\nI wonder how you know about my interests.", "id": "d7e3yzy"}, {"comment": "Because you never get tired of telling me baby, you follow me around like a barnacle.", "id": "d7e41ol"}, {"comment": "Don't know what you are talking about. Your zealotry hasn't been relevant to me in a long time.", "id": "d7e45bb"}, {"comment": "Oh baby, are you leaving me?", "id": "d7e4kvt"}, {"comment": "Cringe... like seriously.", "id": "d7edgyu"}, {"comment": "That's how I feel, but you keep following me around like a lost puppy.", "id": "d7eevzb"}, {"comment": "> Types do not provide the kinds of guarantees you're actually interested in\n\nYes they do, because unlike you I believe in defensive programming. Which in part means I want to be absolutely sure that no data structure is passed to a function that can't support it. \n\n", "id": "d7esx3f"}, {"comment": "That goes right back to having specification tests. If I have a test for the overall feature, then I know that all the intermediate code is doing what it's supposed to. I only need to do validation at the edges. This not a new concept by any means I might add.", "id": "d7etl7x"}, {"comment": "1. I agree that it isn't a new concept.\n2. I also agree that it is a valid way to write tests.\n3. That is still a monolithic design strategy and one that many of us are trying to move away from.  ", "id": "d7etvc9"}, {"comment": "This is not monolithic design at all, and I've already gave a concrete example of it not being one in another comment.\n\nYou can have reusable components that you compose together to do things. The glue code is the business logic for the application, while the components encapsulate a particular piece of functionality, such as talking to an HTTP server, or converting data to JSON, and so on.\n\nThe functional approach is all about building reusable context free components. Practically every problem is approached by composing functions together to do a specific data transformation.\n\nThere's absolutely nothing monolithic about it.\n\nI think you're making the assumption that all the components are tied to a specific data model. This is not actually true however. The components simply know how to do particular transformations on the data. So, your glue code massages data into a particular shape the component expects. This code is very simple however. All the complex logic is encapsulated in the components themselves.", "id": "d7eu0ta"}, {"comment": "> So, your glue code massages data into a particular shape the component expects. \n\nAnd what happens if it doesn't? What happens if you forget to call the \"format this correctly\" function before passing it to the component.\n\nSince the component isn't checking its inputs, the result is undefined. ", "id": "d7eu9ne"}, {"comment": ">And what happens if it doesn't? What happens if you forget to call the \"format this correctly\" function before passing it to the component.\n\nThat's why you're working in a REPL where you get immediate feedback and have specification tests that prevent regressions. When an  API level test fails, I can find the problem pretty quickly from there.", "id": "d7euusy"}, {"comment": "That's fine if you are working solo on a monolithic project. \n\nBut if you are working across multiple teams you aren't necessarily even going to have access to the whole application.", "id": "d7evf2q"}, {"comment": "You do realize that you're explaining how you think my project works to somebody who's been working on such a project for the past 3 years. I'm working with a team of 5 people, and we simply have not had the problems you allude to.\n", "id": "d7exp8r"}, {"comment": "> Types do not provide the kinds of guarantees you're actually interested in\n\nBesides the assurance that your program is correct, you mean?\n\nYeah, who cares about that?\n\n", "id": "d7dsbyc"}, {"comment": ">Besides the assurance that your program is correct, you mean?\n\n[How did that work out exactly?](https://github.com/hashrocket/websocket-shootout/pull/14)\n\nHerp derp, code compiled, must be correct!", "id": "d7dtorv"}, {"comment": "Are you seriously using an anecdote to try to refute a mathematical fact?\n", "id": "d7dtqx0"}, {"comment": "Luckily for me there is no mathematical fact that supports your argument. However, unluckily for you, there is a concrete example that contradicts your claim. Think of it as proof for contradiction if you want to get mathematical about it.", "id": "d7du09u"}, {"comment": "[Some homework for you](https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence).", "id": "d7dvx18"}, {"comment": "I sometimes wonder if the people who trot out the Curry-Howard correspondence actually know what it means.", "id": "d7e0ul3"}, {"comment": "Clearly not in this case.", "id": "d7e2ea9"}, {"comment": "to be fair, it's spoken often about at \"conferences\" and many times they just glaze over the basics and stress some ideas for some use types or you're immoral agenda. I can see people picking that up and incorrectly using it.", "id": "d7e4eg5"}, {"comment": "What does 'correct' mean to you here?\n\nHere's an example of a perfectly typed Haskell program for adding two numbers that is obviously incorrect:\n\n    add       :: Integer -> Integer -> Integer\n    add x y   = x - y\n\nIn fact, I fail to see any definition of 'correct' for which your statement could be true without being tautological ('a well-typed program in a strongly typed programming language is correct, i.e. it is well-typed in that language').", "id": "d7dz2wi"}, {"comment": "> your program is correct\n\nWhat feature does that again?", "id": "d7e40p3"}], [{"comment": "Number of times I've been bitten by `unsafeInterleaveIO`: 2\n\nNumber of times I've been bitten by unexpected nulls on the JVM (which a simple type system can prevent): much more than 2", "id": "d7dtzcj"}, {"comment": ">unexpected nulls on the JVM (which a simple type system can prevent)\n\nHave you tried ~~our lord and savior~~ Kotlin?\n", "id": "d7duyxy"}, {"comment": "I haven't, yet, but I've heard great things about it!", "id": "d7dv3kr"}, {"comment": "The way nulls are handled in it have really made my life easier for the small projects I've used it on. They built the usual Optional type into the language itself. If a value with type t can be null, then it must be type t?. \n\nCombined with immutable values (which, since all variables are declared with val or var, is natural and doesn't require another word in front of the type), you can do interesting things like\n\n     val x = foo() //could return null\n     if(x != null){\n            ... //compiler guarantees that x will not be null anywhere inside this scope.\n     }\n\n", "id": "d7dv8rl"}, {"comment": ">Have you tried our lord and savior Kotlin?\n\nOr as I like to call it, Safety-scissor Scala!", "id": "d7ejx3u"}, {"comment": "However, the impact of a missing null check is typically easily detected, unless a catch-all exception handler is used.\n\nInvalid use of unsafe* function? Not quite so easily.", "id": "d7dxu5b"}, {"comment": "First, nowhere do I argue for or against static typing in the article. All I said is that the Haskell type system is insufficient as a tool for specification. You need specification tests regardless of the type discipline you prefer.\n\nSecond, to the best of my knowledge nobody has empirically shown that static typing results in delivering more robust code faster. Barring some new and exciting evidence that static typing is a major factor in code quality, it comes down to personal preference.\n\nYour anecdotal evidence guides you towards using Haskell, mine guides me towards using Clojure. There is absolutely no evidence that one produces better code than the other.\n\n", "id": "d7dub5a"}, {"comment": "Since you like tests so much, I'll use the world of testing to further illustrate my point.\n\nMost mature software organizations have unit tests and integration tests.  Integration tests exercise the entire system while unit tests exercise each individual part.\n\nYou might ask: why do people even run unit tests at all if the integration tests already exercise the entire system end-to-end? \n\nThe answer is usually one of the two following reasons:\n\n* unit tests run much more quickly than integration tests\n* unit tests are cheaper to maintain than integration tests, so they better exercise less frequent code paths\n\nSo in order to improve development velocity software developers will usually iterate quickly using unit tests to flush out most bugs quickly.  Then, once those bugs are caught they will move on to debug more complex interactions in the integration test.  There's no point running the integration test if you're not passing your unit tests, though.\n\nTo complete the analogy: the relationship between types and tests is analogous to the relationship between unit tests and integration tests\n\nTo make the analogy precise:\n\n* type-checking runs much more quickly than tests\n* types are cheaper to maintain than tests, so they better exercise less frequent code paths\n\nIn fact, types are so much better at exercising less frequent code paths (like unhandled nulls) that I consider it almost irresponsible not to use them.\n\nNote that types are not a substitute for tests (just like unit tests are not a substitute for integration tests).  They are just something that is much more cost effective for the things that they do catch.", "id": "d7duvr8"}, {"comment": ">The answer is usually one of the two following reasons:\n\nActually, the answer is they don't have a REPL to work with.", "id": "d7e2j6f"}, {"comment": "i both agree and disagree with your REPL argument; I agree with it when i'm writing new code, I disagree with it when i'm maintaining large swaths of someone elses code i've never dealt with before. Not because the repl can't be useful in that last scenario, but because it's very slow to exercise in REPL all that might need to be exercised, when indeed types often help me in that scenario (even types in not the best type systems). Again this is not empirical evidence, just my experience, how I feel about your suggestion when I've tried it.", "id": "d7e4s5z"}, {"comment": "My approach has always been to take the test code I write during the REPL session and create tests from it.\n\nI also find that when it comes to maintainability, the biggest factor by far is breaking things up into individual modules you can reason about independently.\n\nThis is why I find that immutability is by far the biggest factor when it comes to correctness. When I work with immutable data, I can apply local reasoning and I don't have to keep a lot of stuff in my head to understand what a particular piece of code is doing.\n\nYou're right though, it's all personal experience, and in absence of clear empirical evidence that's all we have to go on unfortunately.", "id": "d7e5a7s"}, {"comment": "All the languages I use on a regular basis have a REPL, and I use it regularly. I still run my unit tests, preferably in some sort of inotify loop that react directly to changes I make to my code. REPL and unit tests are complementary, they solve related but distinct workflow problems. REPL is volatile, free-form, excellent for ad-hoc checks, explorative work, etc.; but it sucks for actually solidifying things, pinning things down, and consolidating the results of experimentation into, well, a codebase. Typing the same test cases into a REPL over and over gets old quick; it's manual labor, slow, error prone, and just doesn't scale. That's why you evolve your REPL experiments into unit tests, and you run them because if you don't, why bother.", "id": "d7ejpyv"}, {"comment": ">REPL is volatile, free-form, excellent for ad-hoc checks, explorative work, etc.; but it sucks for actually solidifying things, pinning things down, and consolidating the results of experimentation into, well, a codebase\n\nI don't find that to be the case at all. I explore the problem space in the REPL, then once I solidify what I want to do, I take the code I wrote during the REPL session and turn it into tests.", "id": "d7ekore"}, {"comment": "Exactly. That's the workflow. And then you never run those tests? I'm sure you do, that's what you write them for, right? But actually, if you're already pretty sure what kind of properties you want to hold, writing the tests first is a pretty neat workflow - first you think, then you write down how you would want to use your imaginary function, and what kind of output you'd want, and then you write the function. You don't even break out the REPL until you need to figure out why your first attempt doesn't work as expected.", "id": "d7ellm6"}, {"comment": "> And then you never run those tests? I'm sure you do, that's what you write them for, right?\n\nWe have this thing called a build server, and it runs the tests for us whenever code is checked into the repo.\n\n>You don't even break out the REPL until you need to figure out why your first attempt doesn't work as expected.\n\nI don't break out of the REPL at all actually. I do all my development with it. When I get code in the state I want, then I extract the test code from the REPL into tests for the project.\n\nThe tests ensure that there aren't regressions later on when the code is changed down the road.\n\n", "id": "d7ens3y"}, {"comment": "I think the difference between your workflow and mine explains things. It seems that you like to start with making things do stuff, I like to start with jotting down some assumptions and properties. It's \"which part of the problem can I solve right now\" vs. \"what do I know about the problem right now\". I've tried the REPL-only workflow, and didn't like it at all, because it doesn't fit how I work and think - writing down my assumptions in a code file and having a watch job running on the side that keeps telling me which ones do and do not hold is way more productive for me. I love REPLs for the part that remains, but for me, it's not REPL -> source file, but the other way around. Unit tests and type checks are much more than just safeguards against regressions for me; they are brain extensions that help me structure the problem and contain complexity.\n\nAnd likewise, the \"make things do stuff\" approach doesn't benefit from a type checker anywhere near as much as the \"write down properties\" approach; and conversely, \"making things do stuff\" benefits from a dynamic language more than the \"write down properties\" approach.\n\nNow maybe my brain is a bit flawed that way, but whenever I roll with the \"make things do stuff\" approach, I end up stuck, because at some point, the implicit architecture becomes too complex to keep in my head, I lose track of things, and refactoring becomes a nightmare. I much prefer reasoning about my functions in terms of constraints and properties, and having a toolchain that verifies those properties for me so I don't have to.\n\nOne thing I like particularly about Haskell is type-driven refactoring. Say you need to change a function such that its behavior becomes configurable through an extra parameter; so you change its signature from `IO ()` to `Config -> IO ()`. Of course this breaks all of its call sites, but the fun part is that there's an automated tool that can print a list of all the affected dependencies of that function (that tool being the compiler), and then I just walk that list and fix the call sites. Quite often, I need to walk the dependency chain deeper, because the call site itself doesn't have the configuration yet, but again, the compiler maintains that list for me. I don't have to track the dependency tree in my head, I can just plough through the list the compiler gives me. This may not seem like a huge benefit, but considering how the human brain is ridiculously bad at processing tree structures and keeping more than 5-9 things in our working memory, the impact is *huge*, and the linear list traversal workflow scales much better than the tree traversal workflow. And once I'm done, it is very unlikely that I fucked up in a way that the type checker won't detect - I cannot have forgotten any of the dependencies, I cannot accidentally pass a `null` for the configuration, I cannot accidentally forget to initialize a variable, I cannot accidentally attempt to load the configuration from disk in a lazy function that ends up never being called, etc. etc. A large class of possible bugs remains, namely that of implementing the wrong functionality correctly, but an even larger class is already taken care of. More often than not, I even just boldly write my refactorings as sed scripts, and then I let the compiler catch the cases that my script doesn't cover. I wouldn't dare think about that in, say, Python, or JavaScript, or Clojure, or any other dynamic language.", "id": "d7fgik6"}, {"comment": "Right, and this is precisely why I keep saying that different approaches appeal to different mindsets.\n\nI like having a conversation with the program, and explore the solution space interactively when I build things.\n\nThe way I avoid having to keep a complex architecture in my head is by aggressively breaking things up into small independent modules.\n\nWhen you've worked with a dynamic language for a long time, you develop intuition as to when you need to break things up, and what patterns to avoid.\n\nOne side effect of this approach is that it avoiding writing monolithic code, and the components you build are reusable in nature.\n\nWhen you write a focused library, you can understand all that it's doing and you can have high confidence in the fact that it functions well. All you do at the higher level where you're writing domain specific code is glue this libraries together.\n\nYou end up thinking about problems differently, you end up structuring code differently, and you use different patterns when you work in a dynamic language. However, my experience is that it's just as effective in the end.", "id": "d7fjjsw"}], [{"comment": "The messages weren't being dropped because of unsafeInterleaveIO. The faulty version didn't even use unagi-chan. It used Control.Concurrent.Broadcast, a library that doesn't provide channel semantics (and it isn't supposed to, it's an entirely different synchronization mechanism - one that simply broadcasts the most recent value).\n\nI didn't run the benchmark before pointing out it's dropping messages, I just looked at the types.", "id": "d7dy64a"}, {"comment": "> I didn't run the benchmark before pointing out it's dropping messages, I just looked at the types.\n\nI think you've touched on something really crucial here. The premise of the article is that the only way to get confidence in software is to test it, in fact, it says that:\n\n> The only way to know that the code is doing what was intended is to have a specification, and test the code against it.\n\nBut that's plainly wrong. You have more confidence in software that you understand than software that passes its unit tests. Ideally, you'd have both, but types aren't that helpful on the replacing testing side, whereas they are helpful on the software comprehension side.", "id": "d7dyqqr"}, {"comment": ">But that's plainly wrong. You have more confidence in software that you understand than software that passes its unit tests. Ideally, you'd have both, but types aren't that helpful on the replacing testing side, whereas they are helpful on the software comprehension side.\n\nI completely agree that it's important to understand what the code is doing. I've made that argument many times on r/prog. Unfortunately, I find static typing is often directly at odds with that goal.\n\nWhen you're using static types you have to express yourself in a way that the type system can verify. You effectively have to bake a proof of correctness into each statement. This can actually makes it harder to tell what the intent of the code is when a human tries to read it.", "id": "d7e2s8y"}, {"comment": "What happened to you yogthos? You used to be cool :(\n\nor I'm thinking of yogsototh, why are your names so similar!", "id": "d7eqw2j"}, {"comment": "I don't know why it's so shocking for static typing enthusiasts that somebody could possibly prefer a different way to develop code.", "id": "d7esepd"}, {"comment": "It's not shocking. It's fine to discuss the possibilities of both ways of working, I just thought you were the other person, who is a known Haskell enthusiast.", "id": "d7evhpp"}, {"comment": "That investment needs to be paid off :)", "id": "d7fdpwd"}, {"comment": "It does often feel like the monster cable phenomenon. You can feel the difference. :)", "id": "d7fjq9i"}], [{"comment": "Type safety has nothing to do with this. The author of the Haskell implementation of that benchmark did not read the documentation of a library he was using. Yes, proper testing would have probably caught it, but there is no need for this false dichotomy between testing and static types.", "id": "d7e4pgv"}, {"comment": "> there is no need for this false dichotomy between testing and static types.\n\nUnless you have an axe to grind. I'd half expect /u/yogthos was down to the handle by now but no, he's still at it. Mighty big axe it must be.", "id": "d7eljlq"}, {"comment": "Except I never suggested any such dichotomy. That's the straw man that keeps floating around in this thread. RTFA, nowhere does it argue for or against static typing. All it says is that if you want to have an actual specification, types are generally not sufficient for that.", "id": "d7enww0"}, {"comment": "Except I am not the origin of such a straw man, if it really is one. But you come time and time again crusading armed with the same argument, as if it were anything more than your personal preference.", "id": "d7eq4v3"}, {"comment": ">Except I am not the origin of such a straw man, if it really is one.\n\nYou could RTFA before commenting, I know it's a quaint concept and al, but maybe for nostalgia sake.\n\n>But you come time and time again crusading armed with the same argument, as if it were anything more than your personal preference.\n\nActually, my entire argument **IS** that it's personal preference. Nobody has shown that one approach or the other is more effective in practice. Yet, people keep ascribing magic properties to static typing. I'm simply saying there are trade offs to both approaches, and you should use the one that floats your boat.", "id": "d7esmgt"}, {"comment": "You could stop assuming I didn't read the article. Try to be charitable for a change.\n\nBy the way, you seem to ascribe magic properties to use-case testing, going as far as saying that behavior in expected cases is sufficient specification. Have you not heard of Heartbleed and similar hundreds of exploits that depend on *un*expected behavior? Do you not know that the stronger your preconditions are the more brittle your program is?", "id": "d7euazf"}, {"comment": ">You could stop assuming I didn't read the article. Try to be charitable for a change.\n\nSo, where in the article do I say anything about any dichotomy?\n\n>By the way, you seem to ascribe magic properties to use-case testing, going as far as saying that behavior in expected cases is sufficient specification.\n\nI said intended cases, that means inputs that the are expected to be handled by a particular feature. This obviously includes the negative cases as well. If we had a sorting function, then we would want to test something like null inputs in it.\n\nThe point I was making is that you need tests to know whether the code is doing what's intended or not. This is completely tangential to having types.\n\nIn a typed language, you may end up writing less tests because types will catch some of the edge cases that aren't caught otherwise. However, you still need to come up with a specification and test your code against it. This is exactly what I say in the article you claim to have read.\n\n\n", "id": "d7eupyv"}, {"comment": "> So, where in the article do I say anything about any dichotomy?\n\nWhere in this conversation did *I* use the word \"dichotomy\" except in quotes?\n\n> I said intended cases\n\nI fail to see the distinction between what you \"intend\" and what you \"expect\". What is an unintended case and how does it differ from an unexpected one?\n\n> The point I was making is that you need tests to know whether the code is doing what's intended or not. This is completely tangential to having types.\n\nNot in my experience: the overwhelming majority of code is trivial, to the point that it doesn't need tests and visual inspection suffices; a small minority is so complicated it requires formal proof (quick sort, binary search, etc.). In between there's \"interesting\" code for which use-case and (especially) randomized tests serve as a crude safety network to ensure that the code is doing the same thing it did last time (far more useful to test an invariant than specific cases).\n\nThis of course is my personal opinion. I'm not a fan of testing and I find its applicability limited. I don't go ranting and raving about my preferences, however.", "id": "d7evfw5"}, {"comment": ">Where in this conversation did I use the word \"dichotomy\" except in quotes?\n\nHere's your own comment:\n\n>>there is no need for this false dichotomy between testing and static types.\n>Unless you have an axe to grind\n\nApparently, you think I'm proposing some false dichotomy because I have an axe to grind.\n\n>I fail to see the distinction between what you \"intend\" and what you \"expect\". What is an unintended case and how does it differ from an unexpected one?\n\nI think we're arguing about the semantics here. I've already said that I agree that the specification should cover edge cases. Perhaps the word intended does not communicate that well.\n\n>This of course is my personal opinion. I'm not a fan of testing and I find its applicability limited. I don't go ranting and raving about my preferences, however.\n\nI think this is where our experiences diverge. I find that specification level testing provides the best bang for your buck.\n\nMy experience working with statically typed languages is that the value types provide is limited, and not proportional to the work of encoding the problem in a way that the type system can verify.\n\nHowever, that's my experience and I'm perfectly fine with the fact that other have difference experiences. I'm not the one arguing that one approach is superior to the other here.\n\n>I don't go ranting and raving about my preferences, however.\n\nSo, where am I ranting about my preferences again?", "id": "d7exnco"}, {"comment": "> Here's your own comment:\n\nI thought you, as a Lisper, would distinguish between a `quote` and a form.\n\nGood night.", "id": "d7eyb1z"}, {"comment": "There is not dichotomy between tests and types. And nowhere in the article do I suggest any such dichotomy. All the article says is that you need specification tests regardless of the typing discipline.\n\nThe fact that people in this thread turned this into some attack on types is absolutely hilarious to me.", "id": "d7enunv"}], [{"comment": "The field of automatic program verification is a vast field. Types, contracts, specifications are several ways of going about it. Grinding axes though does not help anyone. The engineering landscape when it comes to programming is pretty vast so I think we can all get along.\n\nWhat would be nice to see is actual field studies and analysis of trade-offs when it comes to the kinds of verification tools that people use. \n\nTests are pretty well-trodden and no one denies their benefits but just like too much of a good thing I've seen some nightmarish test suites that simply slowed development to a crawl.\n\nSimilarly type systems when properly utilized provide great benefits in terms of excluding various classes of errors automatically and making some runtime failures actual compile time failures but again I think you can go overboard. I don't have a good sense for when type systems become a burden so some analysis on the kinds of cognitive overhead that elaborate types can lead to would be great.\n\nI am enjoying TypeScript's approach to types. Externalizing the type system and making it modular is kinda nice. I'm looking forward to more research that allows one to use more such external modes of reasoning to elaborate and validate code.", "id": "d7dvwc0"}], [{"comment": "[deleted]", "id": "d7dtiud"}, {"comment": "Actually, a sufficiently expressive type system _can_ guarantee your implementation is free of errors. It's just that, at that point, you're at the intersection of \"programming language\" and \"theorem prover,\" and how best to be at that intersection without forcing the programmer to spell out the specification of literally every function in the program is an area of open research, because we already know type inference (or, looking through the Curry-Howard isomorphism lens, \"proposition inference\") for such expressive type systems (\"dependent types\") is incomplete.\n\nStill, there are already [systems](http://wiki.portal.chalmers.se/agda/pmwiki.php) that [support](http://www.ats-lang.org/) this [approach](http://www.idris-lang.org/). A nice example of the use of one of them, ATS, to prevent the OpenSSL \"heartbleed\" bug can be found [here](https://bluishcoder.co.nz/2014/04/11/preventing-heartbleed-bugs-with-safe-languages.html).", "id": "d7e936l"}, {"comment": "Can it prove that `x = y * 3.000` shouldn't be `x  = y * 3.0001`?", "id": "d7edvdb"}, {"comment": "You don't even need dependent types for that: in sane languages with sane type systems, \"3\" and \"3.0001\" are already different types, and your second example wouldn't compile.", "id": "d7eh3ib"}, {"comment": "Assume that they are both floating point numbers for the purpose of this discussion.", "id": "d7eh5x4"}, {"comment": "Then you presumably want to express the fact that the \"3\" should be constrained to an integral value. Either refinement types or dependent types can do that. There are good refinement type systems for [Scala](https://github.com/fthomas/refined) and [Haskell](https://hackage.haskell.org/package/refined), and there's even a whole new language with refinement types based on Haskell, [Liquid Haskell](http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/about/). Refinement types are also available for [F#](https://www.microsoft.com/en-us/research/project/f7-refinement-types-for-f/), but if you're going to go that distance, honestly, you might as well move on to [F*](https://www.fstar-lang.org/) and its full-on dependent types.\n\nAnyway, the point is, the really good type systems let you write arbitrary constraints on the behavior of your code. The only interesting question is how easy such type systems are to use. Refinement types, in particular, seem like they hit a sweet spot in supporting a lot of constraints that aren't possible to express in the currently popular type systems without going all the way to supporting the kind of type-level programming dependent types do.", "id": "d7ehjxy"}, {"comment": "> the really good type systems let you write arbitrary constraints on the behavior of your code\n\nYou mean really rich or really precise. Nobody is certain (and nobody claims) that a very rich, very precise type system is necessarily good or even better than a less rich, less precise one. The preciseness carries its own heavy costs. Nobody knows whether refinement types are an actual sweet spot or just another point on the typing spectrum because there has been almost no experience with them. Type systems are a very interesting, albeit somewhat controversial topic, but I wish we could talk about them without constantly assigning them value judgments based on pure aesthetic preferences or fledgling research results.\n\n> you might as well move on to F* and its full-on dependent types.\n\nSimilarly, according to F* own website, \"F* is a state-of-the-art research project\", so there is no \"might as well move on\" to it. These are all interesting research questions with early prototypes in various stages of polish. \n\n> The only interesting question is how easy such type systems are to use.\n\nIf feasible use, convenience and effort are the concerns, then another interesting question is whether those constraints should be expressed as types at all. I have yet to hear an explanation for what benefit expressing interesting, rich program properties as types yields. A type-systems expert once told me that the advantage is modularity, but for rich properties the modularity types provide is questionable and/or not necessarily advantageous. Another advantage is automatic generation of an algorithm from a correctness proof, but this is largely hypothetical and no one knows how well this works in practice or how useful it is. OTOH, expressing properties as types has significant disadvantages, as this requires that the proofs be part of the program itself, which makes the program more convoluted and harder to understand (as well as creating the difficulty of separating the proof from the useful code when compiling). Also, it doesn't allow for less certain forms of verification -- it's watertight proof or nothing.", "id": "d7g22w3"}, {"comment": "No. What I'm saying is that your \"sufficiently expressive type system\" can't guarantee that constants have the correct value.", "id": "d7ehrgm"}, {"comment": "Sure they can: constants in typed languages have types. Constants in refinement type systems can have certain constraints on their values (a \"refinement type\" refines one type to construct a smaller type). Dependent types are types that can \"depend\" on values, and support arbitrary constraints on those values, full stop.\n\nSo just saying \"`x = y * 3.000 shouldn't be x = y * 3.0001`,\" without specifying a language, type system, context in which the expression appears, etc. isn't meaningful. If it's important that the 3.000 be integral, constrain it to be integral, either by making it an actual integer and doing a conversion before using it in the floating-point expression, by creating a refinement of \"`double`\" or whatever that constrains its value to be integral, by using a dependent type \"`DoubleThreePointZero`,\" or whatever.", "id": "d7ei69e"}, {"comment": "It doesn't matter if 3 is an integer or not. What matters is whether or not 3 is the right numeric value.\n\nIf someone says \"The width should be 3 times the breadth\" and \"The breadth is 5\", you shouldn't say \"Then the width is 20\".\n\nNo amount of type checking is going to prevent that type of error.", "id": "d7eiho7"}, {"comment": "Actually, there are type systems which can prevent this sort of error.  For example, Haskell has a type system extension called Liquid Haskell that supports type-level numeric predicates (and we use it at work to statically eliminate out-of-bounds errors).\n\nTo illustrate this, let's begin with an ordinary Haskell program without  fancy types:\n\n    breadth :: Int\n    breadth = 5\n\n    width :: Int\n    width = 3 * breadth\n\nLike you mentioned, this ordinary Haskell program doesn't even let us specify something like \"the width is 20\", let alone reject that specification as false.\n\nHowever, we can add \"refined types\" that do let us specify this:\n\n    {-@ breadth :: { x : Int | x == 5 } @-}\n    breadth :: Int\n    breadth = 5\n\n    {-@ width :: { x : Int | x == 20 } @-}\n    width :: Int\n    width = 3 * breadth\n\nNow we have a way to specify at the type level that we expect `width` to be 20, and the type-checker can now inform us that our program does not match the specification.  I can run the above program through the Liquid Haskell type-checker and it gives me this error message:\n\n    test.hs:7:9-19: Error: Liquid Type Mismatch\n \n    7 | width = 3 * breadth\n                ^^^^^^^^^^^\n \n      Inferred type\n        VV : {VV : GHC.Types.Int | VV == ?a * Main.breadth}\n  \n      not a subtype of Required type\n        VV : {VV : GHC.Types.Int | VV == 20}\n  \n      In Context\n        Main.breadth := {Main.breadth : GHC.Types.Int | Main.breadth == 5}\n\n        ?a := {?a : GHC.Types.Int | ?a == (3 : int)}\n\n... which is a very non-user-friendly way of saying that `3 * 5` is not the same as `20`.  However, if I fix the type of `width` to:\n\n    {-@ width :: { x : Int | x == 15 } @-}\n\n... then the type-checker accepts the program.\n\nWhat's neat about Liquid Haskell is that it can actually reason symbolically without even knowing what the specific values are.  For example, I can write:\n\n    {-@ example :: x : Int -> { y : Int | y == x * x - 1 } @-}\n    example :: Int -> Int\n    example x = (x + 1) * (x - 1)\n\n... and the type-checker will accept the program and prove that it's true for all possible inputs to `example`.", "id": "d7f4474"}, {"comment": "> If someone says \"The width should be 3 times the breadth\" and \"The breadth is 5\", you shouldn't say \"Then the width is 20\".\n> \n> No amount of type checking is going to prevent that type of error.\n\nThat is, again, incorrect. It's perfectly possible to use dependent types to say \"this is the singleton type of the number `3`\" and use that in your expression. You're assuming that all you can mean by \"constant\" is \"value expression with some default type ascription provided by the language.\" But this is incorrect even in popular mainstream languages:\n\n    scala> 3\n    res0: Int = 3\n    \n    scala> 3l\n    res1: Long = 3\n    \n    scala> 3d\n    res2: Double = 3.0\n\nSo one option is to use a constant whose value can only be three, but whose representation is a double, or whatever. Another option is to use types in the rest of the expression that let the other values in the expression be doubles, but only supports the operation `*` with a type that constrains the value to be `3` but again, the representation is as a `double`.\n\nIn other words, you're assuming the syntax and semantics of the mainstream languages, and that the programmer is, for some reason, simply not going to express the required constraint. But that has no bearing on whether you can express the required constraint in some type system or not. You can.", "id": "d7emt1k"}], [{"comment": "People here are idiots. Yogthos is basically the Reza Rahman of the Clojure world. Stop wasting your time and carry on.", "id": "d7e3m0e"}, {"comment": "Who is Reza Rahman and why are you insulting him?\n\n", "id": "d7ee10i"}, {"comment": "This is basically a RealTalkInTech post with slightly better writing ;)", "id": "d7egttw"}, {"comment": "Yeah, I know right. The idea that types != meaningful specification is so insane. Thanks for the laugh buddy.", "id": "d7ehjf3"}, {"comment": "All you need is a sufficiently intelligent compiler. :)", "id": "d7fm33a"}, {"comment": "I guess once we have the whole AGI problem cracked, writing code's gonna get a lot easier. :P", "id": "d7fm87x"}, {"comment": "If fun to pick on a zealot like him time on time.", "id": "d7e4238"}], [{"comment": "Please note that the post doesn't argue for or against static typing. It simply highlights the fact that static typing is not a guarantee of correctness. Conversely, most type systems are not expressive enough to provide a meaningful specification for a program. Regardless of the type discipline you prefer, you still need to have a specification and tests that implement it to know what your code is doing.", "id": "d7dtuod"}, {"comment": "> It simply highlights the fact that static typing is not a guarantee of correctness.\n\nIt's not a guarantee of absolute correctness, it's a guarantee of **more** correctness.\n\nWhen you have types, you can prove more properties about your code than without them.\n", "id": "d7dvycu"}, {"comment": "It is not a guarantee of more correctness.\n\nConsider something like a sorting function. All the type system tells you is that you passed a list in, and got a list back. It can't tell you that the list has the same number of elements, or that the elements are in correct order. So, it doesn't tell you that the sorting function actually sorts anything correctly.\n\nFor that you need tests. However, once you have these tests, they will necessarily validate the types of the data the function works on.\n", "id": "d7e2dv3"}, {"comment": "> All the type system tells you is that you passed a list in, and got a list back. It can't tell you that the list has the same number of elements, or that the elements are in correct order.\n\nDepends on the type system. You can encode list lengths in Haskell type and enforce the length property pretty easily.", "id": "d7e3a2l"}, {"comment": "So, now you know you gave the function a list and got back another list with the same number of elements. You don't know if the elements are the same as in the original list of whether they're sorted. That's the key point of the function however. The type system is simply not telling you whether the code is doing what you intended or not.", "id": "d7e3yz4"}, {"comment": "> The type system is simply not telling you whether the code is doing what you intended or not.\n\n\"Doing what you intended\" is not a verifiable property. You can only verify that which you can specify, and types allow you to write specifications.", "id": "d7e5377"}, {"comment": "Of course it is. Doing what you intended literally means having a specification and your code following it. However, types simply don't provide a way to create such a specification.\n\nAgain, consider the sorting example I gave earlier. How do you encode that specification using the Haskell type system. It has to prove the following at the very minimum:\n\n* same number of elements is returned\n* same elements are in the output as the input\n* output is sorted", "id": "d7e5dw2"}, {"comment": "> Doing what you intended literally means having a specification and your code following it.\n\nNo it doesn't, spec bugs are common. Information flow: intentions -> spec -> program.\n\n> However, types simply don't provide a way to create such a specification.\n\nType-based theorem provers disagree.\n\n> How do you encode that specification using the Haskell type system.\n\nThat specifications of *some* algorithms using Haskell's types are awkward, does not entail that specifying *any* algorithm is awkward using Haskell types. In fact, many properties can be statically ruled out in various ways, like array bound checks, use-after-free bugs, protocol state machine correctness via session types, and more.\n\nEvery statement you've made about types in this thread suffers from a faulty generalization fallacy.", "id": "d7e7415"}, {"comment": ">No it doesn't, spec bugs are common. Information flow: intentions -> spec -> program.\n\nThe most important part there is intentions. The spec reflects the intentions. My experience is that most type errors end up being caught very quickly when you have specification tests.\n\n>That specifications of some algorithms using Haskell's types are awkward, does not entail that specifying any algorithm is awkward using Haskell types. \n\nSpecification of most meaningful things is either very difficult or outright impossible to do using the Haskell type system.\n\n>In fact, many properties can be statically ruled out in various ways, like array bound checks, use-after-free bugs, protocol state machine correctness via session types, and more.\n\nMany of these bugs are ruled out by simply using higher order functions. For example, functions like `map`, `filter`, `reduce`, and so on, don't care about the concrete types at all. They just care that they're passed in a collection. The functions encapsulate the logic around boundary and nil checks making it reusable. So, there are many approaches to solving same problems out there.\n\n>Every statement you've made about types in this thread suffers from a faulty generalization fallacy.\n\nNot really, I'm simply pointing out a very simple fact that it's difficult to provide a meaningful specification using types. This is apparently controversial somehow. \u00af\\\\_(\u30c4)_/\u00af", "id": "d7e95sf"}, {"comment": "I can't speak for Haskell, but [here it is in Scala](https://github.com/milessabin/shapeless/blob/master/examples/src/main/scala/shapeless/examples/sorting.scala).\n\n**Update:** OK, here's an approach in [Liquid Haskell](http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2013/07/29/putting-things-in-order.lhs/) (which offers refinement types) and [one in plain Haskell](https://personal.cis.strath.ac.uk/conor.mcbride/pub/hasochism.pdf), appropriately entitled \"Hasochism.\"", "id": "d7e98cn"}, {"comment": "Well Scala does have a Turing complete type system, which in itself could be considered a misfeature. :)", "id": "d7e9hn9"}, {"comment": "Yeah, heaven knows I've been heard to quip \"information wants to be free; computation wants to diverge,\" and if you're going to have dependent types, you kinda do want to disallow general recursion (Turing completeness) at the type level.\n\nAnyway, obviously, this sort of thing is a stunt. What you know I'll continue to argue for, though, is indeed a more careful approach, whether to fully dependent types, or at least to refinement types, that _do_ allow us to easily encode much richer constraints in types than the currently popular typed languages support.\n\nOn the third hand, you and I continue to be in complete agreement that emphasizing immutability, regardless of types, is an _overwhelming_ step in the right direction. At most, we merely disagree on where to stop. :-)", "id": "d7e9ukp"}, {"comment": "So does Haskell, and it's usually considered a necessary evil.", "id": "d7eky7q"}, {"comment": "No, it tells you that a list of integers were passed in, as opposed to a list containing a mixture of strings, floats, and Employee objects.", "id": "d7edy1e"}, {"comment": "Right, but the specification tests will catch that error anyways. So, working in the context of having specification tests, the type system isn't catching anything new here.", "id": "d7eev6d"}, {"comment": "What happens if a list containing a mixture of strings, floats, and Employee objects is passed in?\n\nYou can't just shrug your shoulders and say \"it won't happen\". You need to actually account for when it does happen. \n\nThat's means you need a new specification. And a new set of specification tests. And new library code to implement that specification.\n\nIt also means your application is going to run slower because it has to verify, at runtime, that the correct types were passed in. Though only a O(1) check with static typing, with dynamic typing it becomes a O(n) check as each element is manually inspected prior to the sort.\n", "id": "d7efnte"}, {"comment": ">What happens if a list containing a mixture of strings, floats, and Employee objects is passed in?\n\nYour specification test will fail, then you'll look at the trace to see where the data came from.\n\n>You can't just shrug your shoulders and say \"it won't happen\". You need to actually account for when it does happen.\n\nWhen have you ever had a situation where you just had some random data show up in the application. That's completely nonsensical.\n\n>It also means your application is going to run slower because it has to verify, at runtime, that the correct types were passed in\n\nThat doesn't make any sense. You do verification at the edges of the application where you interact with the external world. You need to validate data coming in regardless of the type discipline.\n\nOnce the data is in your app, why would you need to keep revalidating it?\n\n[Here's](https://github.com/yogthos/memory-hole/blob/96e055c48238602e78a3a63efdf6a4600e464661/src/clj/memory_hole/routes/services.clj#L134) a real world example from a small app I worked on recently. The data is validated at the service layer, and I don't need any other validation within the application.\n", "id": "d7egnh5"}, {"comment": "> Your specification test will fail, then you'll look at the trace to see where the data came from.\n\nAgain, I don't write \"small applications\". I often write \"small libraries\" and are combined into large applications, but that's an entirely different ball game.\n\nYou use what we refer to as \"defenseless\" style of programming, which tends to make code brittle and hard to debug in our experience. \n\nIf you were working for me and wrote code like that, I would fail your code review and give you remedial lessons on \"Defensive Programming\".\n\nhttps://en.wikipedia.org/wiki/Defensive_programming\n", "id": "d7ehna1"}, {"comment": ">You use what we refer to as \"defenseless\" style of programming, which tends to make code brittle and hard to debug in our experience.\n\nBecause your experience is working with imperative languages that use mutable data. When I worked with Java, I used to have a very similar mindset.\n\n>If you were working for me and wrote code like that, I would fail your code review and give you remedial lessons on \"Defensive Programming\".\n\nConversely, if you worked for me and peppered checks all over the place instead of doing them at the edges where they belong, I'd fail your code review. :)", "id": "d7enl8s"}, {"comment": "It has nothing to do with mutable state. Passing in an Immutable Array of Strings to something that expects a list of integers is no better than passing in a Mutable Array of Strings.\n", "id": "d7esl24"}, {"comment": "> When have you ever had a situation where you just had some random data show up in the application. That's completely nonsensical.\n\nActually, it does happen -- hurrah for cosmic rays, low voltage, etc.\n\nAnd this is one of the main limitations of the optimizations that static type analysis permits -- even if you can prove that your intention is correct, you still need to (occasionally, perhaps) check that the machine is doing what you expect at run-time.", "id": "d7fly59"}, {"comment": ">Actually, it does happen -- hurrah for cosmic rays, low voltage, etc.\n\nSeems like we're now firmly outside the scope of what a software system can guarantee. :)", "id": "d7fm2vu"}, {"comment": "Well, there's guarantee and then there's a probability distribution of defect detection.\n\nThe former has always been an illusion used to cover up that the latter is just too much like hard work.\n\nStill, the point is that if you really want reliability, it needs to have some dynamic feedback system, even if your specification is perfect.", "id": "d7fm9td"}, {"comment": "Well \"more correctness\" also includes the case that if you pass in an integer 42, it won't respond with string \"hello world\". Because neither can happen.\n\nAnd a with a little bit more typing you can indeed express that the function gives a sorted permutation of its input list! See http://www.cs.bu.edu/~hwxi/ATS/EXAMPLE/MISC/listquicksort.dats for an example in ATS :).", "id": "d7e2xb4"}, {"comment": "A case that would clearly be caught by the specification test.", "id": "d7e356o"}, {"comment": "But it also allows the calling code to benefit from the type specification: it is impossible to call the function with an integer. Regardless of which kind of edge case might be involved. You typically wouldn't mock all external libraries to check if your code actually calls them with proper argument types..", "id": "d7e3pks"}, {"comment": "You don't need to mock all the external libraries though. The specification tests are a contract. They show that your code is behaving as expected for all the **intended** cases. You can also generate types from these tests as seen [here](https://github.com/typedclojure/auto-annotation).", "id": "d7e3wui"}, {"comment": "I recommend reading the discussion in r/haskell. Especially [this comment](https://www.reddit.com/r/haskell/comments/50xsxy/the_hashrocket_websocket_shootout_in_haskell/d7820dg):\n\n> Yup, there's no way you can get chan semantics from the type `MVar (Either [MVar a] a)`. The only thing you can do when broadcasting a new `a` is replace the `a` possibly contained within (after sending to any listeners).\n\nThe types were used to track down the problem.\n\nAlso, from your article:\n\n> The developer can't possibly be expected to audit every library they use in their project to ensure that it behaves safely.\n\nNo, but the compiler can do that. See [Safe Haskell](https://wiki.haskell.org/Safe_Haskell).", "id": "d7dv8wc"}, {"comment": "The types might've been used to track down the problem, but the point was that the compiler didn't catch the problem and the bug slipped into runtime.\n\nSafe Haskell is very cute, but the reason you have unsafe functions in the first place is for performance. Note that once the bug was fixed, getting the benchmark to perform was a challenge for multiple experienced Haskellers.\n\nMeanwhile, a single person managed to write correct working benchmarks in a bunch of languages. Hence my point that a robust ecosystem is a huge factor in productivity.", "id": "d7e2huf"}, {"comment": "The bug had absolutely nothing to do with unsafe functions. It was a misunderstanding of [Control.Concurrent.Broadcast](https://hackage.haskell.org/package/concurrent-extra-0.7/docs/Control-Concurrent-Broadcast.html).\n\n> Meanwhile, a single person managed to write correct working benchmarks in a bunch of languages.\n\nIt's no harder to write a correct Haskell version than any other language. The fact that that didn't happen first time here was just down to negligence. It doesn't surprise me that making a fast Haskell version is a challenge. Naively written Haskell tends to be quite slow, but it is possible (though difficult) to write Haskell that performs very well.", "id": "d7e4ua8"}, {"comment": "However, that doesn't change the fact that libraries like unagi use unsafe and it bypasses the type system. So, even if the issue was caused by a different problem, it doesn't mean the unsafe problem doesn't exist in Haskell.\n\n>It's no harder to write a correct Haskell version than any other language.\n\nWell, clearly it is. [It took multiple experienced Haskell devs to come up with a version that worked reliably](https://github.com/bitemyapp/websocket-shootout/pull/3) while still performing poorly. So, disagree that it's down to just simple negligence.\n\nThis is why I emphasize the value of having a mature ecosystem in my article. You can quickly write code that does what's expected even in a language like Js, given mature and well tested libraries.\n\n", "id": "d7e56w7"}, {"comment": ">Well, clearly it is. [It took multiple experienced Haskell devs to come up with a version that worked reliably](https://github.com/bitemyapp/websocket-shootout/pull/3) while still performing poorly.\n\nShouldn't you wait until there are actual numbers from the resulting version? Last I saw there were no actual numbers after a user commented he got performance around that of Go with -N $numcpu and one more flag.\n", "id": "d7far6a"}, {"comment": "Maybe it improved since, but last I looked there was high variance in performance still. As it stands, the fact that it's taking over a week to get these numbers isn't really flattering if you ask me. This is a benchmark that could be written in under an hour in many languages to work correctly and perform efficiently.\n\nThis is why a big part of my argument is that the ecosystem matters. The quality of the VM matters, and the libraries that are available matter. These factors eclipse any benefits you get from a fancy type system when it comes to building real world projects. This is why hosted languages have a huge leg up on any language that also has to build up its own ecosystem.", "id": "d7fjtn7"}, {"comment": ">This is why a big part of my argument is that the ecosystem matters. The quality of the VM matters, and the libraries that are available matter. These factors eclipse any benefits you get from a fancy type system when it comes to building real world projects. This is why hosted languages have a huge leg up on any language that also has to build up its own ecosystem.\n\nThat's not the argument put forth in your article. In fact, your articles introduction is entirely false:\n\n> \u00a0However, it turned out that the Haskell implementation failed to deliver messages reliably,\u00a0dropping 98% of the messages it received.\n\nUsing the wrong library did this.\n\n> What's interesting is that this is exactly the kind of behavior we would expect Haskell type system to prevent from happening.\n\nNo, it's not. The type system won't help you if you've chosen a concurrency primitive that drops messages it's supposed to keep.\n\n> So, how did the fact that messages were being dropped slip by completely undetected?\n\nSomeone saw a websockets benchmark that didn't include Haskell and hurriedly implemented something while making the mistake of using the wrong concurrency primitive. \n\n> The answer is that Haskell provides escape hatches from its type system, and these are often used in practice to achieve reasonable performance.\n\nThis is kind of true, the most I can agree to is \"sometimes used\" rather than often used. Maybe if I thin on it longer, somewhere  between \"sometimes\" and \"often\".\n\n> When we look at code in the\u00a0unagi-chan\u00a0library used in the Haskell implementation, we can see that it uses\u00a0unsafeInterleaveIO\u00a0to get the channel contents.\n\nIt does use unsafeInterleaveIO, but the bug in question didn't come from unagi-chan.\n\n", "id": "d7fkrwm"}, {"comment": ">That's not the argument put forth in your article. \n\nFrom the article:\n\n>The developer can't possibly be expected to audit every library they use in their project to ensure that it behaves safely. Since most applications rely on large amounts of third party code, **availability of mature and reliable libraries is a major factor when it comes to building robust applications**.\n\n>In fact, your articles introduction is entirely false:\n\nSo, the original implementation didn't deliver 2% of messages then, was I living in some alterverse where that happened?\n\n>Using the wrong library did this.\n\nYes, every language is perfect when we start blaming the user.\n\n>No, it's not. The type system won't help you if you've chosen a concurrency primitive that drops messages it's supposed to keep.\n\nThe whole point of using a language like Haskell is that this shouldn't just happen with no warning. What happened to all that emphasis on formally controlling side effects?\n\n>Someone saw a websockets benchmark that didn't include Haskell and hurriedly implemented something while making the mistake of using the wrong concurrency primitive.\n\nSomeone being a very experienced Haskell user who's writing a book on the language. I guess if that's not a sufficient level of proficiency to correctly write a simple websocket sever in Haskell, I think that says it all really.\n\n>This is kind of true, the most I can agree to is \"sometimes used\" rather than often used. Maybe if I thin on it longer, somewhere between \"sometimes\" and \"often\".\n\nSeems to pop up in lots of libraries that deal with IO.\n\n>It does use unsafeInterleaveIO, but the bug in question didn't come from unagi-chan.\n\nThe fact that there are other ways to shoot yourself in the foot in Haskell, doesn't change the problem with unsafe. Unless you're claiming that this is incorrect somehow?\n\n>While Haskell is conceptually a pure language, the internal GHC implementation is imperative in nature. GHC runtime evaluates impure functions that produce side effects making the order of evaluation important. Functions like unsafeInterleaveIO expose the impure runtime to the user, and open the gate for all the types of errors we're familiar with from imperative languages.\n\n>The way GHC implements Haskell inherently precludes safety guarantees by its type system. The purity is effectively an honor system, and cannot be proved by the compiler. In other words, once we use a library that happens to use unsafe operations any guarantees that we get from the type system go out of the window.\n\nPlease feel free to correct anything I got wrong there.\n\n\n\n", "id": "d7flbhu"}, {"comment": "I wish this had been included in the post.", "id": "d7e4rqt"}, {"comment": "Does the post suggest anywhere that it's not the case?", "id": "d7e5awj"}]]], "4iv6r6": ["After reading \u201cRails is yesterday\u2019s software\u201d, I need to reply", "2016-05-11 18:34:56", 14, "http://www.codethinked.com/it-takes-all-kinds", [[25, "The original post articulated positions on architecture, extensibility, community ecosystem, design patterns, maintainability, etc.  Your post focused on tooling and optimization - it seems like an Apples to Oranges reply to me."], [14, "[deleted]"], [1, "    for f in Ruby Scala Golang Python Ruby Perl Java Lisp Pascal Fortran Cobol\n    do\n        echo $f is yesterdays software\n    done "], [-7, "I have nightmares about falling into an infinite loop and not being able to get out. These Opinion about an Opinion blogs are causing PTSD."], [-7, "[deleted]"]], [[{"comment": "The original post articulated positions on architecture, extensibility, community ecosystem, design patterns, maintainability, etc.  Your post focused on tooling and optimization - it seems like an Apples to Oranges reply to me.", "id": "d31nxn6"}], [{"comment": "[deleted]", "id": "d323pc9"}, {"comment": "That's how I feel to... All these thought leaders trying to push us one direction or another, when do they even have time to code?", "id": "d32j9ej"}], [{"comment": "    for f in Ruby Scala Golang Python Ruby Perl Java Lisp Pascal Fortran Cobol\n    do\n        echo $f is yesterdays software\n    done ", "id": "d31sv4f"}, {"comment": "Of course. Let's replace them all with JS", "id": "d31wlox"}, {"comment": "JS been around too long. We should invent new hypelang just for the hypes sake", "id": "d32bx5h"}], [{"comment": "I have nightmares about falling into an infinite loop and not being able to get out. These Opinion about an Opinion blogs are causing PTSD.", "id": "d31jut9"}, {"comment": "That's called \"discussion\", and it's ok as long as it stays flat enough.", "id": "d31mpvg"}, {"comment": "There was 1000 comments in the reddit thread. Even if this blogger doesn't read reddit I can assure you he visits at least some area where discussion could be had. Instead we are discussion a blog about blog about an opinion that we already discussed. yo dawg i heard you like meta discussion", "id": "d31nfc3"}, {"comment": "[deleted]", "id": "d31syf3"}, {"comment": "I know I should get this joke, but I don't.", "id": "d31uldx"}, {"comment": "The joke is that he already did.\n\nEdit: for the record, the deleted post said something about Satan redirecting all the blog to medium.com when you go to Hell.", "id": "d31w4oz"}], [{"comment": "[deleted]", "id": "d31date"}, {"comment": "Why do I feel the reverse?", "id": "d31i2od"}, {"comment": "Because they are just opinion pieces. ", "id": "d31jcau"}, {"comment": "I agree with you. I was underwhelmed with the original post. The title promised a lot. It didn't deliver.\n\nThis has less pretense and is more open minded.", "id": "d325lpb"}]]], "3y3nok": ["fast-http-server: Super fast, zero configuration command line HTTP Server", "2015-12-24 20:55:11", 0, "https://github.com/sdogruyol/fast-http-server", [[16, "Super fast because the only thing it can do is 200."], [7, "On OSX you can already use: \n\n    python -m SimpleHTTPServer \nor\n\n    php -S localhost:8000\nno need to install anything"], [5, "* Where are the benchmarks? (I dont understand crystal, but looking at the code I wouldn't expect it to be \"fast\")\n* HTTP::Server appears to be the web server, where is this located? Is it some built in library in crystal?\n* Why is this in /r/programming? Not something like /r/webdev?\n"], [2, "Excuse my idiocy, but what language is this written in?"], [2, "You should probably make it clearer that this is only *Super fast* when comparing to a couple Ruby solutions, because this doesn't look fast at all. In fact, if that's really all you're benchmarking, I wouldn't be surprised if it turns out to be benchmarking noise. I guess what I'm trying to say is that you can do a full HTTP round-trip with a lot more data than that, going both ways in less than 1ms; so what you have here doesn't sound fast, let alone *Super fast*. It actually sounds *Super slow*."], [1, "Just added the benchmarks https://gist.github.com/sdogruyol/25aea510c82675c382a3 and updated the REAMDE"], [1, "16K qps is not fast\u2026"], [1, "Did you test it against [fileserver](https://github.com/valyala/fasthttp/tree/master/examples/fileserver) which is based on fasthttp?"]], [[{"comment": "Super fast because the only thing it can do is 200.", "id": "cya91ea"}, {"comment": "No it's fast because it's written in [Crystal](http://crystal-lang.org). It's a simple command line HTTP server in purpose of serving the current folder. If you want something more check [Kemal](https://github.com/sdogruyol/kemal) or a full featured server like Apache / Nginx", "id": "cya945d"}, {"comment": "> No it's fast because it's written in Crystal.\n\nThat does not make something fast", "id": "cyagnvw"}, {"comment": "..yes.., why would it not?\n\nCompare: \n\nhttps://gist.github.com/colinstein/5cb8b116c8a0d8bc0c3f\n\n", "id": "cyak8gf"}, {"comment": "This compares a limited subset, what about python, apache, php -S, etc?", "id": "cyarhdb"}, {"comment": "Did you build with --release ?", "id": "cyavv03"}], [{"comment": "On OSX you can already use: \n\n    python -m SimpleHTTPServer \nor\n\n    php -S localhost:8000\nno need to install anything", "id": "cyaffit"}], [{"comment": "* Where are the benchmarks? (I dont understand crystal, but looking at the code I wouldn't expect it to be \"fast\")\n* HTTP::Server appears to be the web server, where is this located? Is it some built in library in crystal?\n* Why is this in /r/programming? Not something like /r/webdev?\n", "id": "cyaf3xq"}, {"comment": "1) Crystal is compiled, it's faster than what most people use for their quick HTTP server needs (SimpleHTTPServer.py, for instance)\n\n2) HTTP::Server is built in.  ", "id": "cyak9ei"}, {"comment": "1) That does not declare the speed compared to other common webservers.\n2) Then this project is nothing more then an example of HTTP::Server and not a webserver, the web server is bundled with crystal.", "id": "cyardf1"}, {"comment": "1) Nobody is going to use this for production\n\n2) Yes, pretty much, it's just a wrapper", "id": "cyarehu"}, {"comment": "Then fast is a terrible name, should just be called \"Crystal HTTP::Server example\", naming it fast is stupid when it privides no benchmarks.", "id": "cyaryi1"}, {"comment": "I'll add the benchmarks today. (against SimpleHTTPServer, php and http-server.", "id": "cyasugx"}, {"comment": "> I dont understand crystal\n\ndon't*\n\nYour code must compile, why don't you take the same care with your English?", "id": "cyb7g7j"}], [{"comment": "Excuse my idiocy, but what language is this written in?", "id": "cya8mff"}, {"comment": "It's written in [Crystal](http://crystal-lang.org/)", "id": "cya8nmr"}, {"comment": "Ah thank you. \n\nI've not looked at Crystal yet. Another one for the list ...", "id": "cyabu9f"}, {"comment": "I thought Crystal didn't have threading or concurrency yet. Is everything single threaded?", "id": "cyaek12"}], [{"comment": "You should probably make it clearer that this is only *Super fast* when comparing to a couple Ruby solutions, because this doesn't look fast at all. In fact, if that's really all you're benchmarking, I wouldn't be surprised if it turns out to be benchmarking noise. I guess what I'm trying to say is that you can do a full HTTP round-trip with a lot more data than that, going both ways in less than 1ms; so what you have here doesn't sound fast, let alone *Super fast*. It actually sounds *Super slow*.", "id": "cyavi0r"}, {"comment": "[deleted]", "id": "cyavtz0"}, {"comment": "Hi Serdar,\n\nCalling people names, especially names like \"troll\", is unlikely to improve your project.\n\nPeople are going to be very critical of your project because you're making statements without justification or explanation.\n\nPublishing your hard work is hard work, and your feelings will get hurt. You can and should ignore anyone you think is actually trying to hurt your feelings, but I think you should address the concerns people have.\n\n[dash](https://github.com/geocar/dash) is a fast web server: It gets into the 100,000 queries/sec space in under 100 lines of C code (dynamic requests above 60,000 queries/sec).\n\nNote that in addition to [justification](https://github.com/geocar/dash#kdb-2ksec), I also explain:\n\n* Exact systems I tried it on (so someone can repeat my benchmarks easily)\n* [All code provided](https://github.com/geocar/dash#setup) so it's easy for someone to point out a mistake I made in testing their favourite language/framework.\n* [Qualifiers](https://github.com/geocar/dash#linux-31821-on-350ghz-xeon), in case someone wants to disagree with my definition of \"fast\".\n\n[Your page](https://github.com/sdogruyol/fast-http-server/blob/e12b598af7671f33bd9889ff7e05d42796947cd1/README.md) does none of these things; [the timings I can find](https://gist.github.com/colinstein/5cb8b116c8a0d8bc0c3f) do not impress, and [your response](/r/programming/comments/3y3nok/fasthttpserver_super_fast_zero_configuration/cyavv03) does not provide your expectations and instead blames the user for following *your directions* instead of knowing enough about Crystal to build your application in a performant way.\n\nI'd recommend [relabelling your application](/r/programming/comments/3y3nok/fasthttpserver_super_fast_zero_configuration/cyardf1) so that you can have the conversation you *seem* to want to have.\n\nGood luck.", "id": "cyb1wb9"}, {"comment": "This is the most useful Reddit comment ever. Thank you!", "id": "cyb6jmm"}], [{"comment": "Just added the benchmarks https://gist.github.com/sdogruyol/25aea510c82675c382a3 and updated the REAMDE", "id": "cybrwno"}], [{"comment": "16K qps is not fast\u2026", "id": "cyf0tn0"}, {"comment": "compared to?", "id": "cyf184o"}, {"comment": "I missed the answer: https://www.reddit.com/r/programming/comments/3y3nok/fasthttpserver_super_fast_zero_configuration/cyb1wb9", "id": "cyi9itp"}], [{"comment": "Did you test it against [fileserver](https://github.com/valyala/fasthttp/tree/master/examples/fileserver) which is based on fasthttp?", "id": "d28tof9"}]]], "4680vy": ["The Ruby Community Code of Conduct", "2016-02-17 14:46:48", 2, "https://www.ruby-lang.org/en/conduct/", [[16, "Fucking hell, this bullshit obsession with Code of Conducts lately in programming projects is getting out of hand. They do nothing but hinder discussion as people will just run to them anytime it's convenient. What the fuck happened to decency and common sense?"], [9, "It's a beautiful CoC: simple, and captures the community's ethics."], [4, "Aggressive proposals for entryist revision in 3.. 2.."], [4, "Awesome. Short, sweet, sensible. I am afraid this is going to annoy the tumblrinas though."], [2, "I would rather instead of \"Participants will be tolerant of opposing views\" be changed to \"Participants will be tolerant of persons with opposing views.\" Sometimes opposing views are terrible ideas and should not be tolerated, but I should disagree respectfully."], [-4, "> When interpreting the words and actions of others, participants should always assume good intentions.\n\nThis could lead to the potentially dangerous statement if followed literally:\n\n\"Oh hi! I am working on implementing a back door into Ruby so that I can personally attack distributors of Ruby that directly use their source code rather than maintaining a patch set. I do this because I believe in patch sets and that downstream releases should never be vanilla flavored.\"\n"]], [[{"comment": "Fucking hell, this bullshit obsession with Code of Conducts lately in programming projects is getting out of hand. They do nothing but hinder discussion as people will just run to them anytime it's convenient. What the fuck happened to decency and common sense?", "id": "d03agft"}, {"comment": "I have seen Rust's Code of Conduct do a *ton* of good to the community. No language community is more healthy, for all I can tell, and it is great enough to get public recognition for it. Oft-quoted is \"The Rust community seems to be populated entirely by human beings. I have no idea how this was done.\"\n\nOn the contrary, I've not seen a Code of Conduct do any observable harm. I've seen claims like \"people will just run to them anytime it's convenient\" before, but never any concrete example of it happening. And they always seem to be alongside rather uncharitable comments; yours is yet another in the line, albeit does avoid making arbitrary stabs at LGBT groups.\n\nFollowing the most stringent of CoCs would rephrase your comment as\n\n> Why are Code of Conducts so popular lately in programming projects? They do nothing but hinder discussion as people will just run to them anytime it's convenient. What happened to decency and common sense?\n\nDoes this really prevent you from expressing your point? I'd argue it does better - it focusses on what you're actually trying to argue about, and avoids\n\n* the uncomfortable injection of an us-vs-them resolution to the debate, making it less likely to argue on emotional appeals\n\n* generating hostile and off-track responses, as emotional attacks are prone to doing,\n\n* assuming the argument (eg. \"bullshit obsession\"), which hinders engaged debate,\n\n* discouraging activity from people who don't enjoy being personally attacked; although some people are fine with putting up with personal attacks this isn't something that we should *require* of people to join a debate.\n\nDecency and common sense seem to support the CoC for me. Perhaps you have a different experience, though I struggle to imagine what that might be.", "id": "d04avq6"}, {"comment": "My biggest and only real issue with CoCs is what it might end up causing for the future. IMO receiving honest and direct criticism is the best way to improve yourself and your skills as a programmer, and if people are worried about offending or hurting each others feelings then how are we going to improve as a community? Look at the backlash against Linus Torvalds responses to bad commits, some people take it personally instead of stepping back and trying to learn from it, and try to shut him down from being able to give criticism. Sure you don't need that level of severity on all projects, but on something as critical as kernel dev you shouldn't let ANYTHING through that doesn't meet the high standard.  \n  \nAnyway, I'm just worried that having CoCs will start reducing the kind of criticism we give each other, and I'm getting sick of seeing people basically threaten or bully projects if they don't have one in place (look at the [spacemacs discussion](https://github.com/syl20bnr/spacemacs/pull/3484) for example).  \n  \nThanks for actually taking the time to respond with a though out comment, not many people will anymore for CoC hate comments. Although why would someone bring LGBT groups into it O_o we're all just personalities behind a computer screen, who the hell cares what race, sex or gender we are?", "id": "d04ifr8"}, {"comment": "Having a code of conduct doesn't mean you can't say \"you're not ready to contribute to this project\"*, \"your commit does not meet our guidelines\" or \"you're simply wrong about this\".\n\nIt means you can't say \"fuck off, n00b\", \"your code is shit, faggot\" or \"you're full of shit\".\n\nRust has a solid code review process - more solid than most projects - and all that requires is just avoiding attacking the person or using insulting adjectives.\n\nIf you think fear or insults are needed to have a consistent, critical and powerful review process, I'd like to see some justification. As far as I'm concerned, Linus is the odd one out and one data point does not equal a correlation.\n\n> Although why would someone bring LGBT groups into it O_o\n\nBeats me, but it seems to have some association with an anti-Tumblr sentiment or with thinking CoCs are a Tumblr idea. That goes back the the us-vs-them attitude I'm particularly unfond of.\n\n---\n\n\\* Though saying someone's \"not ready to contribute\" does seem rather arbitrary on second thought; I'd personally avoid the phrase. Something like \"We're only looking for contributions from experienced developers at this time.\" is much more obvious.", "id": "d04vuz5"}, {"comment": "Sadly your example is exactly what I'm worried about, changing dialog choices to please the code of conduct and not hurt anyone's feelings. Sorry but if someone commits something absolutely worthless it should be pointed out, although I agree with Linus, criticize and be blunt about the persons code, not the person. I've said it in a previous comment but the internet taught me 4 amazing things, to have a backbone, personality matters much more than what someone is or how they look, actions speak louder than words and communication skills are very important. Why does it seem like people lately are too scared of these things and want to create safe spaces instead of learning life skills?", "id": "d04yehr"}, {"comment": "If you feel you need to say \"fuck off, n00b\", \"your code is shit, faggot\" or \"you're full of shit\", I have no qualms excluding you from discourse. They don't contribute to the conversation, whatever it may be, they attack the person and they make the environment hostile.\n\nYou can blame it on the target of your attacks for being \"too scared\" or whatever, but the point is you've attacked the person and they're under no obligation to accept that.\n\nTelling to people to man up when you can instead just not create conflict in the first place is short-sighted.", "id": "d04zblu"}, {"comment": ">I have no qualms excluding you from discourse.\n\nSo who died and made you the police?", "id": "d067l9k"}, {"comment": "Nobody. Typically the CoC would be enforced by the moderators.", "id": "d067s1m"}, {"comment": "> What the fuck happened to decency and common sense?\n\nThat fucked off a long time ago, the whole point of these codes of conduct is to try and bring it back, although this one is not particularly well set up.", "id": "d03dp8x"}, {"comment": "> What the fuck happened to decency and common sense?\n\nCo\u00f6pted by fat chicks & trannies.\n\nCheck out the tellingly-titled sibling post on /r/GamerGhazi for example: the poster lays out the goals of various CoC pushes. E: and my god, it's too good not to quote:\n\n>>I'm struggling to see anything encouraging, welcoming or reasonable in this.", "id": "d03arw8"}], [{"comment": "It's a beautiful CoC: simple, and captures the community's ethics.", "id": "d03gcvh"}, {"comment": "[The discussion that led to this formulation](https://bugs.ruby-lang.org/issues/12004) is quite interesting, from a socio-anthropological perspective.", "id": "d03l04x"}, {"comment": "Absolutely.", "id": "d04b12k"}, {"comment": "Doesn't look like they're going to let it go at that though. The author of the Contributors Covenant is using some [insulating language](http://archive.is/RVBbt) now and has asked for [Matz removal from the community management](http://archive.is/EVLry).\n\nShe's just going to keep trying to rile people up until someone gives in to her demands. Just like [she did](http://archive.is/uQdAJ) for the [Opal incident](https://github.com/opal/opal/issues/942#issuecomment-113227261).", "id": "d04wyt5"}], [{"comment": "Aggressive proposals for entryist revision in 3.. 2..", "id": "d039t4p"}, {"comment": "TBH I do find that limiting disparaging speech only in the case of personal attacks is kind of weak. It gives leeway for open bigotry in communication channels if it can be defended that it wasn't directed at nobody in particular.\n\nNot that I'm a fan of the usual CoC that's pushed everywhere with its carte blanche for bullying people considered to be members of privileged classes.", "id": "d03a8dd"}, {"comment": "> Not that I'm a fan of the usual CoC\n\nAny CoC at all is like letting the devil have your pinky as a compromise. See Linux: the \"code of conflict\" hasn't silenced the self-appointed moral authorities, nor stopped efforts to expand it to the point of making developers dance on eggshells as per Sarah Sharp's original threat-demand.", "id": "d03p20b"}], [{"comment": "Awesome. Short, sweet, sensible. I am afraid this is going to annoy the tumblrinas though.", "id": "d03myje"}], [{"comment": "I would rather instead of \"Participants will be tolerant of opposing views\" be changed to \"Participants will be tolerant of persons with opposing views.\" Sometimes opposing views are terrible ideas and should not be tolerated, but I should disagree respectfully.", "id": "d05gkfn"}], [{"comment": "> When interpreting the words and actions of others, participants should always assume good intentions.\n\nThis could lead to the potentially dangerous statement if followed literally:\n\n\"Oh hi! I am working on implementing a back door into Ruby so that I can personally attack distributors of Ruby that directly use their source code rather than maintaining a patch set. I do this because I believe in patch sets and that downstream releases should never be vanilla flavored.\"\n", "id": "d035yqf"}, {"comment": "It's just a rephrasing of [the principle of charity](https://en.wikipedia.org/wiki/Principle_of_charity). It's one of those things that can't be a hard-and-fast rule because it precisely means that you have to step back and engage the argument and the person individually, rather than a possibly imaginary and easily brushed off version of both.\n\nOn the flip side, you see it break down on HN when people start contorting themselves to find an intelligent interpretation of everything Paul Graham says and accuse his opponents of interpreting his words uncharitably, but that's only because they are making people engage a possibly imaginary version of his arguments and his person that can't be cast aside, ever.\n\nEdit: on second thought, \"assume good intentions\" is too much of a simplification of this. Sometimes you can take the strongest and most reasonable interpretation of an argument and still end up reading drivel or hate.", "id": "d036awq"}, {"comment": "Yes I agree, it would be far better worded to something such as \"do not automatically imply that a user's intention is malicious before it can be proved that it is, if it even is as mistakes can happen with no ill intent.\".\n", "id": "d03a8c2"}]]], "42whdv": ["voxel.css WebGL enabled voxel rendering in the browser.", "2016-01-27 10:55:51", 0, "http://voxelcss.com", [[4, "/r/programming/comments/42txj2/voxelcss_an_opensource_inbrowser_3d_rendering/\n\nStill on front page hermano."]], [[{"comment": "/r/programming/comments/42txj2/voxelcss_an_opensource_inbrowser_3d_rendering/\n\nStill on front page hermano.", "id": "czdo8pk"}]]], "4ktsz4": ["Pepperoni - A framework to build apps faster, powered by React Native", "2016-05-24 17:36:59", 6, "http://getpepperoni.com", [[39, "finally a framework to build apps faster! never heard that promise before. "], [20, "Another framework with a fancy website... Do JavaScript programmers spend all of their free time building new frameworks? Do they actually build any apps, or do they just build new frameworks for building apps that never get built?"], [11, "Chill out people, framework was a bit incorrect term here, sorry for the confusion. It's a starting point to kickoff React Native development, which may be quite a puzzle. Even if you dislike starter kits/boilerplate projects, you can get inspired by our way to build RN apps. This is our best understanding how to ship them well. Pepperoni will be evolving as we learn new things. Hope you find it useful. "], [10, "YAFF - Yet Another F***ing Framework.\n\nI don't see the point of frameworks that glue more frameworks together. Make something that solves a legitimate problem."], [6, "There's barely any documentation or sample code, why on earth would I use this?"], [4, "no ty!"], [4, "From personal experience i can say that:\nthe amount of domain knowledge needed to understand these kind of frameworks and use it for actual product creation is so high that it is usually faster to stick with native app development. Even if you have to deal with different platforms like iOS and Android.\nI tried various (cross platform solution) frameworks. But I find it difficult to get a good problem solving / product creation ratio. With these frameworks i spend most of my time on google and stackoverflow to solve an endless flow of issues and questions. \n\nAt the same time you could argue that the standard iOS and Android frameworks are not really better. but at least they are used by thousands of developers. Usually every issue is already questioned. That makes problem solving easier."], [3, "Is there an abstraction layer I can use on top of this?"], [2, "Wow, who'd have fucking thought that every JS programmer with an opinion somehow can't manage to make a framework that works for everyone?\n\nIt's almost like using simpler tools to construct simpler solutions custom to one's problem is better than big, giant, opinionated tools that claim to solve everything but solve only one or two problems well while massively ballooning complexity."], [1, "I never understand why people would want to use these boilerplate things rather than just composing their own `package.json` files and picking and choosing what libraries they want to use. The days of `LAMP` and `MEAN` are over. We are in a age where its really easy to mix and match your stack to suit your particular use case. We don't need to go back to this."], [1, "Hopefully natives will react and not too kindly for yet another framework."], [0, "This is the tastiest looking framework I've seen in pretty much any language.\n\nEdit: A word"]], [[{"comment": "finally a framework to build apps faster! never heard that promise before. ", "id": "d3hqdx3"}], [{"comment": "Another framework with a fancy website... Do JavaScript programmers spend all of their free time building new frameworks? Do they actually build any apps, or do they just build new frameworks for building apps that never get built?", "id": "d3hvyu7"}, {"comment": "Nah. It's the circle of JS:\n\n- X looks at the different frameworks for his new app.\n- X writes a brand-new framework. *Because*.\n- Y looks at the different frameworks for her new app, including X's.\n- Y writes...\n\n...and it goes on and on.", "id": "d3hz5fv"}, {"comment": "Wait, I thought /r/programming was always complaining because there are too many apps being built in JS. Now there aren't enough? Which is it?", "id": "d3hxkch"}, {"comment": "Yes.", "id": "d3i2n8i"}, {"comment": "It's just an outcome of how huge the JS userbase is. Something like 0.001% of JS users decide to build a framework. The end result is lots of frameworks.", "id": "d3i08tk"}, {"comment": "The worst part is that in front end dev, potential employers judge you almost exclusively by the number of JS libraries, frameworks, and trivial tools listed on your resume, as if an experienced programmer couldn't just pick one up, and start working.", "id": "d3izulp"}], [{"comment": "Chill out people, framework was a bit incorrect term here, sorry for the confusion. It's a starting point to kickoff React Native development, which may be quite a puzzle. Even if you dislike starter kits/boilerplate projects, you can get inspired by our way to build RN apps. This is our best understanding how to ship them well. Pepperoni will be evolving as we learn new things. Hope you find it useful. ", "id": "d3i18oq"}, {"comment": "The project looks great, but the homepage is a little difficult to deciper. I had trouble guessing whether you had created a stub or a library. Perhaps it would help to put a code sample in the front page. You could look at the homepages of react or ember for inspiration.\n", "id": "d3itcx0"}], [{"comment": "YAFF - Yet Another F***ing Framework.\n\nI don't see the point of frameworks that glue more frameworks together. Make something that solves a legitimate problem.", "id": "d3hxurf"}, {"comment": "> All problems in computer science can be solved by another level of indirection... Except for the problem of too many layers of indirection.", "id": "d3hza4p"}], [{"comment": "There's barely any documentation or sample code, why on earth would I use this?", "id": "d3hv9nj"}], [{"comment": "no ty!", "id": "d3hpm5n"}], [{"comment": "From personal experience i can say that:\nthe amount of domain knowledge needed to understand these kind of frameworks and use it for actual product creation is so high that it is usually faster to stick with native app development. Even if you have to deal with different platforms like iOS and Android.\nI tried various (cross platform solution) frameworks. But I find it difficult to get a good problem solving / product creation ratio. With these frameworks i spend most of my time on google and stackoverflow to solve an endless flow of issues and questions. \n\nAt the same time you could argue that the standard iOS and Android frameworks are not really better. but at least they are used by thousands of developers. Usually every issue is already questioned. That makes problem solving easier.", "id": "d3hzsdl"}], [{"comment": "Is there an abstraction layer I can use on top of this?", "id": "d3ithvw"}], [{"comment": "Wow, who'd have fucking thought that every JS programmer with an opinion somehow can't manage to make a framework that works for everyone?\n\nIt's almost like using simpler tools to construct simpler solutions custom to one's problem is better than big, giant, opinionated tools that claim to solve everything but solve only one or two problems well while massively ballooning complexity.", "id": "d3i0ijt"}], [{"comment": "I never understand why people would want to use these boilerplate things rather than just composing their own `package.json` files and picking and choosing what libraries they want to use. The days of `LAMP` and `MEAN` are over. We are in a age where its really easy to mix and match your stack to suit your particular use case. We don't need to go back to this.", "id": "d3hw39q"}], [{"comment": "Hopefully natives will react and not too kindly for yet another framework.", "id": "d3i5tfh"}], [{"comment": "This is the tastiest looking framework I've seen in pretty much any language.\n\nEdit: A word", "id": "d3hz2pr"}]]], "55hwem": ["systemd: OpenSSL of the future?", "2016-10-02 15:43:08", 0, "http://coderinaworldofcode.blogspot.co.uk/2016/10/systemd-openssl-of-future.html", [[21, "Everyone complains about systemd but very very few seem to be able to quantify this distaste. Two people in this thread say it's broken by design and one called it an 'overengineered pile of shit' with no concrete facts to back up their assertion. These things may be true; but why should anyone believe you?\n\nWay too many of these arguments boil down to a few people (just like in this thread) going, \"someone really should audit/fuzz the code\", and no one ever actually seems to. Well, the absence of evidence is not the evidence of absence, so right now, the burden of proof is on these systemd accusers."], [16, "was the author high when they wrote this?\n\nThe reason OpenSSL and SystemD have so many public \"issues\" is because they are open to scrutiny. Nobody can say for sure how many bugs non-free SSL libs or service control apps and frameworks have, because they are not open to scrutiny.\n\nAlso sure, people can hack you if you remain ignorant in times where the security information is easy to come by. There are 2-3 commands you can run to update a modern system with a high-degree of certainty patches will work. You wouldn't cry because your cars oil needed changing, or because it needed work and you had to pay a mechanic to do so. You wouldn't moan that things in your office suffer wear. So why expect computers to be different?\n\nIt's a good thing for open-source that vulnerabilities are found, and it's a good thing for security that they are patched.\n\nThis is why dev-ops, specifically continuous deployment is a thing now. So you can upgrade the OS you live on and deploy patches for those bugs without as many man-hours. You can script your tests so that your release is not stable or changes merged unless checks are met, and have it stage to test and run those tests after pushing changes one minute before home-time. In the long run, OpenSource always has lower risk and more wins for people and business, because it can survive lack of funding; ideas can be implemented by anyone; it can innovate and iterate as much as the community needs it to.\n\nNothing is perfect, we all need to get over that!\n\nYesterday I wrote a systemd script to force a program to stay resident for a kiosk. It was a 2 file solution. The script to start the kiosk, and one systemd service. That's a win for productivity and it reads so well I'm sure even kids could understand it. I didn't have to make start, stop and restart, I didn't have to fill in defaults, I just followed the docs and setup a service that works.\n\nAs /u/audioen points out...\n\n> systemd is in the unenviable position of having to be absolutely perfect in every situation, or articles like these keep on coming out. I've been using it in production for soon a year now, and this is the first indication of any problems at all, and even in this case it requires a local attack which simply allows me to ignore it for now.\n\n***Update*** [*(Xenial Patch)*](http://www.ubuntu.com/usn/usn-3094-1/)"], [13, "systemd is in the unenviable position of having to be absolutely perfect in every situation, or articles like these keep on coming out. I've been using it in production for soon a year now, and this is the first indication of any problems at all, and even in this case it requires a local attack which simply allows me to ignore it for now.\n\nHow about people put this thing through some systematic fuzzing before declaring it has to be replaced wholesale? And maybe it can be patched do some more multiprocessing for security and reliability reasons in places where it currently doesn't do it.\n\nI do not consider it shown that it's so fundamentally broken as its detractors claim. If anything, I'm seeing that it works quite well and reliably.\n\nOh, one thing. Someone please solve how to set up ipv6 on wlan with systemd. hostapd apparently has to run first so the link layer is up before ip6 can be configured for interface. Has anyone tried to figure this thing out yet? Debian's regular ifup/down networking scripts can't set up ipv6 for wlan either."], [6, "Completely relevant: https://www.agwa.name/blog/post/how_to_crash_systemd_in_one_tweet"], [3, "Except that systemd isn't a crypto library and a security bug in systemd (such as [these ones](https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=systemd)) aren't nearly as important as bugs in a crypto library.\n\nBut yeah, other than that, fear mongering about the fact that software does have bugs is as good an excuse as any other to write yet another rant about systemd."], [4, "Meh. Could we agree to limit the tiresome anti-systemd\ntrolling to r/linux or r/history? Thanks."], [-1, "systemd will be remembered as the systemd of the past, a warning example for everyone."], [0, "Ah, yes. Anti-systemd click bait and neckbeardisms."], [-2, "Well, they are working on a web API...\n\nhttps://cfp.systemd.io/en/systemdconf_2016/public/events/21"]], [[{"comment": "Everyone complains about systemd but very very few seem to be able to quantify this distaste. Two people in this thread say it's broken by design and one called it an 'overengineered pile of shit' with no concrete facts to back up their assertion. These things may be true; but why should anyone believe you?\n\nWay too many of these arguments boil down to a few people (just like in this thread) going, \"someone really should audit/fuzz the code\", and no one ever actually seems to. Well, the absence of evidence is not the evidence of absence, so right now, the burden of proof is on these systemd accusers.", "id": "d8aubce"}, {"comment": "Trying to write a robust init script in bash is a near impossibility. Systems is modular and has plugins and tools. It's a way better init system too.", "id": "d8avawp"}, {"comment": "> Systems is modular and has plugins and tools.\n\nNot quite. When stuff goes wrong, you're facing the whole thing. Recently I had to patch an udev deb package (was the shortest way to get around problems): now you need whole systemd dependencies to crosscompile that. So, I patched by hand.\n\nSo, not so modular in practice: when used in combination with wrong package manager on the weird system with clueless system administrator.", "id": "d8b15lr"}, {"comment": "> Trying to write a robust init script in bash is a near impossibility.\n\nI guess the fact that there are and have been many robust init systems written in sh doesn't matter? OpenBSD's init system is a work of art. ~300 SLOCs of easy to read, highly audited, sh code, which just works, and works very well. It does everything you need in an init system.\n\n> Systems is modular\n\nWhat does this even mean? And once you've qualified what you mean by this: what does this give you that an easily understood and edited sh script doesn't?", "id": "d8b99r9"}, {"comment": "Yeah, I don't get all the hate. All my personal experience with systemd has been really positive.", "id": "d8az09r"}, {"comment": "There are many posts explaining why systemd is broken, explaining the design principles that are not followed, rewriting same arguments again won't help, the other side will reply with the exact same arguments so we will need to wait for something major to happen to move this discussion forward", "id": "d8b2oln"}, {"comment": "Are you retarded? What facts do you need besides an obvious distance between the complexity of a problem domain (it is just a fucking init system you idiot, what can be simpler?!?) and an actual implenentation (dozens of obscure binaries, hundreds of thousands lines of code). What kind of an ignorant monkey can ever dare to consider this shit an adequate piece of engineering?!?", "id": "d8bw142"}, {"comment": "It's not just an init system though anymore, is it? So I think that what you said is disingenuous on top of being rude. If you don't think it should encapsulate so much functionality, that's a different argument. It's not big for what it does.", "id": "d8cjerk"}, {"comment": "Even if you throw away all the shit and leave init related code only, the same argument stands.", "id": "d8ckxuo"}, {"comment": "Discussing with systemd fanboys on Reddit is pointless. They are wilfully ignorant. All they do is bring ad-hominems and say 'But it works'.  I mean we are on /r/programming, you would expect people to see a problem with a huge, enterprisey, ever-growing C project that creeps from one problem domain to the next and adds a sloppy new feature every week that will take 20 years to be removed. And you would expect /r/linux to see a problem with this, when everyone can't wait to switch from X11 to Wayland. \n", "id": "d8bwny7"}], [{"comment": "was the author high when they wrote this?\n\nThe reason OpenSSL and SystemD have so many public \"issues\" is because they are open to scrutiny. Nobody can say for sure how many bugs non-free SSL libs or service control apps and frameworks have, because they are not open to scrutiny.\n\nAlso sure, people can hack you if you remain ignorant in times where the security information is easy to come by. There are 2-3 commands you can run to update a modern system with a high-degree of certainty patches will work. You wouldn't cry because your cars oil needed changing, or because it needed work and you had to pay a mechanic to do so. You wouldn't moan that things in your office suffer wear. So why expect computers to be different?\n\nIt's a good thing for open-source that vulnerabilities are found, and it's a good thing for security that they are patched.\n\nThis is why dev-ops, specifically continuous deployment is a thing now. So you can upgrade the OS you live on and deploy patches for those bugs without as many man-hours. You can script your tests so that your release is not stable or changes merged unless checks are met, and have it stage to test and run those tests after pushing changes one minute before home-time. In the long run, OpenSource always has lower risk and more wins for people and business, because it can survive lack of funding; ideas can be implemented by anyone; it can innovate and iterate as much as the community needs it to.\n\nNothing is perfect, we all need to get over that!\n\nYesterday I wrote a systemd script to force a program to stay resident for a kiosk. It was a 2 file solution. The script to start the kiosk, and one systemd service. That's a win for productivity and it reads so well I'm sure even kids could understand it. I didn't have to make start, stop and restart, I didn't have to fill in defaults, I just followed the docs and setup a service that works.\n\nAs /u/audioen points out...\n\n> systemd is in the unenviable position of having to be absolutely perfect in every situation, or articles like these keep on coming out. I've been using it in production for soon a year now, and this is the first indication of any problems at all, and even in this case it requires a local attack which simply allows me to ignore it for now.\n\n***Update*** [*(Xenial Patch)*](http://www.ubuntu.com/usn/usn-3094-1/)", "id": "d8apdbn"}, {"comment": "> The reason OpenSSL and SystemD have so many public \"issues\" is because they are open to scrutiny. \n\nWasn't the thrust of the article about product quality, regardless of source availability?  Even the counter examples presented (openssh, vsftpd) are open source.\n\n>Nothing is perfect, we all need to get over that!\n\nNo, nothing is ever prefect.  It's about relative levels of quality. Who's asking for perfection?\n\nDid anyone voice/imply that closed source was a better alternative?\n\nWhy are you arguing against points nobody here or in the linked article are making?", "id": "d8auup1"}, {"comment": "> OpenSSL has received a lot of flak over the years. Both cryptographic and implementation flaws have been plentiful, and researchers are all over it. Much has been said about the software engineering process that was used to put it all together.\n\n> It appears to me that systemd is following a similar path, with another vulnerability turning up in the last few days. A very quick assessment of this vulnerability would place it as a 'medium' (CVSSv3 between 5.5 and 6.5) severity vulnerability. Ayer's post goes on to use this example as another data point in favour of the \"systemd is insecure\" camp.\n\n&\n\n> If you are starting a project, or running a project, please look at the design of vsftpd and OpenSSH. Look over the various secure software development life-cycles. Think about using a language that supports you. If you're going to push people to use your system, consider the security implications of your decisions and remember that hope is not a strategy. \n\nWhat part of that was positive about systemd or openssh? In fact don't answer, just STFU", "id": "d8b12te"}, {"comment": "> The reason OpenSSL and SystemD have so many public \"issues\" is because they are open to scrutiny. \n\nWhich other reasons did you consider and reject before arriving at this one?", "id": "d8aphpd"}, {"comment": " * code-quality (Irrelevant. Can always be improved)\n * fitness for particular purpose outside illustrated examples (Irrelevant. Don't use a spoon to dig graves, then complain they bend)\n", "id": "d8aqk0c"}, {"comment": "So, no considerations on its architecture, or fitness for purpose within \"illustrated examples\"? The latter in particular seems rather radically narrower than the breadth of application that systemd's marketing suggests, i.e. that of managing all application- and network-facing programs in a running GNU/Linux system.", "id": "d8ar27h"}, {"comment": "really? You've gone to the effort of making a non-comment on the project architecture, then stating we should all read marketing to seriously evaluate tech decisions... GTFO", "id": "d8b1mvv"}, {"comment": "Well, you have a nice day too~", "id": "d8b7h05"}, {"comment": "> code-quality (Irrelevant. Can always be improved)\n\nAnd yet some designs are harder to safely implement than others. By this logic IIS 4 is just as safe as modern Apache since hey, it's just a bit of difference in code quality...", "id": "d8aubek"}, {"comment": "oh another idiot... IIS4 is not maintained, apache is. IIS4 has been abandoned by it's owner so they can sell IIS7 (or whatever they are up to now). In open-source projects code-quality of any one release is largely irrelevant, as anyone with the skills to say \"I don't like this\" can always change it. You cannot do that with IIS4", "id": "d8b19d2"}, {"comment": "The fact that software can be improved in the *future* does not make its quality better *today*.\n\nI'm trying really hard to imagine the Bugzilla resolution status for your idea. What would it be, something like \"RESOLVED SOMEONE_WILL_FIX_IT_SOMEDAY\"?", "id": "d8b5tk8"}, {"comment": "Drawing false comparisons again... \n\nSaying any bugs that exist can be fixed by any qualified and motivated individual or team in open-source vs only by those given incentive by the company the product is tied to... Nothing like  \"RESOLVED SOMEONE_WILL_FIX_IT_SOMEDAY\"?\n\nLet's also not forget \"wont-fix\" is a valid response to an issue, as well as-is \"help wanted\". Sometimes some issues are less important and take longer.\n\nIf we are going to simplify what I've said: \"Not being able to conceive of every possible situation is not a failure of a software developer, architect or CTO.\" \n\nTheir job is to gather and assemble information and systems to deal with what is known at the time. All they can do is put processes and systems in-place to allow them to deal with that ever-growing list of user needs and situations. As a user, you should only reasonably expect existing known situations to be dealt with. Expecting a crystal ball or everything handled ahead of time is a sign of stupidity and ignorance and is incredibly dangerous.", "id": "d8b7rqp"}, {"comment": "Systemd is different. It could have been hundreds of times simpler and smaller, with proportionally fewer defects. Yet, it is an overengineered pile of shit, and unavoidably choke-full of issues. With OpenSSL, it's unlikely you can make it significantly simpler than it is now.", "id": "d8aqq13"}, {"comment": "No. There are *claims* that systemd could be a hundreds of times simpler and smaller. That is something totally different. That claim is not backed by most distribution maintainers and developers by the way.\n\nWith openSSL there is proof that a lot of stuff can be stripped out without breaking many applications. See libreSSL.", "id": "d8b4uwq"}, {"comment": "> There are claims that systemd could be a hundreds of times simpler and smaller.\n\nIt is pretty obvious to anyone who ever had a look at the code.", "id": "d8b62ap"}, {"comment": "... to me it's pretty obvious that this is a lie. Not even suckless is 100x smaller.\n\nIf you reduce the code by the factor of 100x you might get some init system. But with totally different properties. Go forward, do it. And then promote it. If it's better then distributions will adopt it. I'm however not holding my breath.", "id": "d8b75yj"}, {"comment": "You do not know much about programming, do you? If you cannot tell an overengineered shit from miles distance.", "id": "d8b78eh"}, {"comment": "If you use words like \"shit\" than I can smell meaning, not facts, from kilometers distance.", "id": "d8b7nj4"}, {"comment": "Just read the bloody code. It's a disgusting bloat. Even worse than Linux itself.\n\n", "id": "d8b8eca"}, {"comment": "I'm in the pro-systemd pro-openssl, write one better or GTFO camp", "id": "d8b1ohf"}, {"comment": "There already is a far better system - SysV init.", "id": "d8b27xi"}, {"comment": "Some of us don't like the huge complex SysV init files you end up on complex software.\n\nCompare\n\nhttps://github.com/elastic/elasticsearch/blob/master/distribution/deb/src/main/packaging/init.d/elasticsearch\nto\n\nhttps://github.com/elastic/elasticsearch/blob/master/distribution/src/main/packaging/systemd/elasticsearch.service\n\nhalf of that is PID file and dir management ", "id": "d8b58aq"}, {"comment": "And what about OpenBSD's init system - a 300 line shell script that is easily understood by anyone who care's to look, and who's init scripts are this simple\n\n    #!/bin/sh\n\n    daemon=\"/path/to/daemon\"\n    . /etc/rc.d/rc.subr\n    rc_cmd $1\n", "id": "d8ba2hi"}, {"comment": ":)", "id": "d8b6vez"}], [{"comment": "systemd is in the unenviable position of having to be absolutely perfect in every situation, or articles like these keep on coming out. I've been using it in production for soon a year now, and this is the first indication of any problems at all, and even in this case it requires a local attack which simply allows me to ignore it for now.\n\nHow about people put this thing through some systematic fuzzing before declaring it has to be replaced wholesale? And maybe it can be patched do some more multiprocessing for security and reliability reasons in places where it currently doesn't do it.\n\nI do not consider it shown that it's so fundamentally broken as its detractors claim. If anything, I'm seeing that it works quite well and reliably.\n\nOh, one thing. Someone please solve how to set up ipv6 on wlan with systemd. hostapd apparently has to run first so the link layer is up before ip6 can be configured for interface. Has anyone tried to figure this thing out yet? Debian's regular ifup/down networking scripts can't set up ipv6 for wlan either.", "id": "d8aoypu"}, {"comment": "> this is the first indication of any problems at all\n\nSo essentially you have not noticed any other problems?\n\nStrange. Perhaps you are not reading bug reports then?\n\nThe article however had is bad - openssl is in nowhere anywhere similar to systemd whatsoever. I can easily use Linux without systemd; I can not feasibly do so in regards to openssl. Too many other tools that I need depend on it.\n\n> I do not consider it shown that it's so fundamentally broken as its detractors claim. \n\nI consider it fundamentally broken by design too. So now what? You have one opinion, I have another.\n\nIn regards to openssl, at the least one viable alternative was started, libressl. I can not evaluate it (I have never used OpenBSD) but this is a good thing - this is how things should be.\n\nSystemd instantly went in to infiltrate Linux via PID 1. Past this point there is no going back for those who were assimilated.\n\n> If anything, I'm seeing that it works quite well and reliably.\n\nOh so you are saying that there are no bug reports at all.\n\nI'll refer to your statement here for future issue requests about bugs.", "id": "d8aptqn"}, {"comment": "When I talk about problems, I am talking about what I've personally seen. I don't usually have problems with init systems, and this is true for all of sysv init, upstart, and now systemd. From my point of view, there's huge amount of noise about precisely nothing, except I am going to say that I like writing systemd unit files far more than sysvinit start up scripts, and don't see much difference in practice compared to upstart service files, except systemd has tons of new security/sandboxing/performance-related options I can use.\n\nIn interests of fairness, I note that there was one integration error which had to do with ubuntu's systemd and resolvconf integration. As interfaces went up and down, sometimes resolvconf did not get the message that something needs to change in resolv.conf. This was fixed in Ubuntu somehow, but I already had solved the problem for myself by using more systemd, as my resolv.conf is generated by systemd-resolved, which also solved the problem.", "id": "d8au409"}, {"comment": "systemd is broken by design", "id": "d8aq24u"}, {"comment": "Could you elaborate more? or provide a link to an article/blogpost ", "id": "d8aumm9"}, {"comment": "Are you a developer? ,what kind and how many years of experience? My comment is not about the number of bugs or if it works or not but the architecture of the system from a developer point of view not as an user or system administrator.", "id": "d8awk2m"}, {"comment": "Are you a developer? Let's pretend we all are for a bit... Have any specifics for how it's broken by design?", "id": "d8b6hsv"}, {"comment": "YEs , I am a developer so I do not want to talk technical things if you can't understand them because you do not hav experience working with large code bases for years.", "id": "d8bbe1t"}], [{"comment": "Completely relevant: https://www.agwa.name/blog/post/how_to_crash_systemd_in_one_tweet", "id": "d8aqdyf"}, {"comment": "Also the EFI variable filesystem, mounted read-write by default...", "id": "d8ar3kx"}, {"comment": "To systemd's defense, nobody knew ahead of time that having EFI variables modifiable by root would be a problem. Unfortunately, it turned out that there exists some broken firmwares which in fact can't cope with missing EFI variables, which was run into because some people did rm -rf / in order to destroy their systems -- they didn't anticipate that this would actually brick their hardware.\n\nThe blame lies with the broken firmwares. The fix to the problem was done in kernel, to protect broken firmwares from bricking themselves. Systemd was always fine, i.e. they took the position that in principle being able to change what loader the system's firmware should boot out of the box is fine thing to want in principle, and shouldn't require mounting or whatever. It's a root-only feature anyway. It is not often needed feature, but I've installed refind a couple of times and in those situations EFI variables do get adjusted.", "id": "d8aul5s"}, {"comment": "> To systemd's defense, nobody knew ahead of time that having EFI variables modifiable by root would be a problem.\n\nIf that is the best defense, then systemd should be destroyed _yesterday_. Mounting a generic interface through which firmware, which is known to be universally of borderline quality, can be fucked by unrelated programs that merely deal with files (such as `rm -rf /`), is simply inexcusable.\n\nNot to mention the systemd developers' response, that the filesystem must remain read-write for systemd's own functionality to work, and that wrappers around tools that require read-write efivarfs access are unacceptable!", "id": "d8axdss"}, {"comment": "> can be fucked by\n\nAgain, no one knew this. If they knew \"firmware can be fucked up\", then yes, the programmer should get flamed.\n\nBut systemd just did what other init systems did.\n\nIn the end the Kernel fixed this (what should have been fixed by this specific buggy EFI implementation, which *really* fucked). So if you ask me, this EFI implementor should get all the flame.", "id": "d8b7dle"}, {"comment": "... which is exactly what *all* other init systems did, too.\n\nThe issue was fixed within days of getting known *in the kernel*, which was exactly the right place to fix this issue.", "id": "d8b58iu"}, {"comment": "All critical software should be written in robust verifiable languages not c or c++. Ada or Rust. Bitching about quality of systems they should bitch about bind and the kernel as well.\n\nI cant believe c or c++ is still being used to write critical software. ", "id": "d8aveh1"}, {"comment": "This has nothing to do with the language. It's not a bug caused by an oversight, it's a failed assertion, according to the text.", "id": "d8b9f91"}, {"comment": "But Rust isn't verifiable, is it? With all that `unsafe` that real-world programs appear to require 100% of the time.", "id": "d8b7ikr"}, {"comment": "Being able to verify 99% of your program, and before it even ever compiles, is far more valuable than being able to verify 0% of it up front. Sure, you can always run static analysis after the fact, or presume your design is \"good enough\" to cover some lackluster code, but being forced to pass that analysis up-front before ever even being able to run it is a way to better enforce quality.\n\nIf even the compiler can't figure out what the heck you're doing, then you can get earlier insight into whether your design is sensible, or you're maybe better off not committing this hacky code into your repo even as a stop-gap measure. Being able to focus and save time on code reviews is also no laughing matter, when you can pick apart the 1% of your code that isn't verifiable, knowing that the rest will probably hold up as long as it does.\n\nSure, very well-trained coders and reviewers can help, as can post-compilation analysis, but obviously those measures aren't good enough, if these kinds of mistakes still regularly slip into stuff like OpenSSL and systemd, yet could have easily been prevented by simply picking a language like Rust, whether it's fully verifiable or not.", "id": "d8b8to2"}], [{"comment": "Except that systemd isn't a crypto library and a security bug in systemd (such as [these ones](https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=systemd)) aren't nearly as important as bugs in a crypto library.\n\nBut yeah, other than that, fear mongering about the fact that software does have bugs is as good an excuse as any other to write yet another rant about systemd.", "id": "d8apg7p"}, {"comment": "> Except that systemd isn't a crypto library and a security bug in systemd (such as these ones) aren't nearly as important as bugs in a crypto library.\n\nThis doesn't make sense.  First of all, security bugs often give attackers access that renders your cryptography moot.\n\nSecond, let's look at the first two issues in the page you linked (as of now):\n\n* CVE-2015-8946: ecryptfs-setup-swap in eCryptfs before 111 does not prevent the **unencrypted swap partition** from activating during boot when using GPT partitioning and certain versions of systemd, which allows local users to obtain sensitive information via unspecified vectors.\n* CVE-2015-8945: openshift-node in OpenShift Origin 1.1.6 and earlier improperly stores router credentials as envvars in the pod when the --credentials option is used, which **allows local users to obtain sensitive private key information** by reading the systemd journal.\n\nThe first two issues in that page are related to cryptography!", "id": "d8b0th4"}, {"comment": "Oh yeah, \"related\", in that it's about cryptography. Duh.\n\nA crypto library is used by other apps. OpenSSL in particular is widely used. Apps using it were affected by bugs like Heartbleed and became remotely exploitable. I'm not even sure how even people dare to compare that situation with a service manager like systemd. Systemd has had security bugs, and nobody cared about them more than the other many security bugs patched every day - it didn't create a internet wide security panic. And it never will, because it's not an important crypto library.\n\nSo no, systemd is not the \"OpenSSL of the future\", no matter how much they insist on it (not that Betteridge's law hadn't already answered the question)", "id": "d8b1sjm"}, {"comment": "> ecryptfs-setup-swap\n\nOkay, so you're telling me that older versions eCryptFS and OpenShift Origin implementation was buggy and that systemd didn't fix their bug?  How shameful.\n\nBTW, I have a display bug in chromium, why doesn't systemd fix that for me?", "id": "d8b7l4n"}, {"comment": "I agree with you about the openssl versus systemd comparison.\n\nThe scope of openssl and problems in it are much more severe.\n\nAs for \"fear mongering\" - what fear \"mongering\"? These are specific entries to bugs that existed or have existed. That is not \"mongering\" - these are factual statements.\n\nAs to whether the IMPLICATION of these statements has any positive or negative merit past that point is subjective - but the listing of bugs (or at the least \"undefined\" or erratic behaviour) is something objective.", "id": "d8apv6z"}, {"comment": ">  what fear \"mongering\"?\n\nprobably the whole rest of the article outside of links to bugs", "id": "d8aqe8j"}, {"comment": "Software unavoidably contain bugs. Shitty overengineered software, like systemd, contain disproportionally more bugs than a decent high quality software.", "id": "d8bw82r"}], [{"comment": "Meh. Could we agree to limit the tiresome anti-systemd\ntrolling to r/linux or r/history? Thanks.", "id": "d8aq9f2"}], [{"comment": "systemd will be remembered as the systemd of the past, a warning example for everyone.", "id": "d8aool8"}, {"comment": "I'm certainly not convinced that systemd is the end all of init + low level plumbing on Linux, I'm expecting something else to supersede it sometime down the line, by learning from it's mistakes and limitations.\n\nHowever I see no indication of distros going back to any of the pre-existing solutions which systemd in turn replaced.\n\nA 'de facto' standard base system for Linux distros is something that obviously is attractive to the majority of maintainers/developers on the Linux platform, else it would not have seen such uptake (and please don't go with the Gnome + logind nonsense, it doesn't hold water).\n\nThat said, it's not as if previous solutions have to disappear, as long as they are maintained they will remain options for distros which doesn't want systemd, this is and always has been the actual reason there is 'choice' in the Linux ecosystem, someone actually stepping up and maintaining said solutions.", "id": "d8bcpgj"}], [{"comment": "Ah, yes. Anti-systemd click bait and neckbeardisms.", "id": "d8aq7ql"}], [{"comment": "Well, they are working on a web API...\n\nhttps://cfp.systemd.io/en/systemdconf_2016/public/events/21", "id": "d8aptpa"}, {"comment": "This is about Cockpit, which is a web application that talks with services through dbus, and to do this it uses cockpit-bridge which is (more or less) a web server that translates between http and dbus. But it has nothing to do with systemd itself", "id": "d8b2rcm"}]]], "4vgo03": ["Towards Scalaz 8", "2016-07-31 15:07:51", 0, "https://github.com/scalaz/scalaz/issues/1231", [[-7, "Spam"]], [[{"comment": "Spam", "id": "d5y8ghf"}, {"comment": "Not spam, but perhaps better suited to /r/scala", "id": "d5yfwdq"}, {"comment": "Uhh....\n\n> GREAT DEAL ON KITCHEN COUNTERS! Made from 50% quartz, 45% cement, and 5% formaldehyde. GET a vintage stove FREE! No strings attached! 50% off! NO FRILLS FINANCING! WE WILL ACCEPT EQUITY LOANS.\n\n*That's* spam.", "id": "d5yii6x"}, {"comment": "i went to the page and it was just filled with porno", "id": "d5yor7c"}]]], "44wl9x": ["Get off of GitHub", "2016-02-09 16:11:28", 49, "http://sudophilosophical.com/2016/02/09/get-off-of-github/", [[60, "Why?"], [27, "Nah"], [21, "\nShould we point out that when it becomes annoying. The same thing will happen t github as to what happened to sf. everyone will run like fuck to somebody else."], [22, "I am planning to leave GitHub myself, but the title of this is just divisive. Don't use the imperative in a title unless you want to polarise people."], [21, "I've thought a lot about this too. My general philosophy towards open source is to use it unless it's just not feasible. \n\nGitlab is a great product, and I have moved a lot of my stuff to self hosting, so Gitlab is a great fit. The one killer feature Github has that makes Gitlab infeasible is its community. If I want any hope of attracting FLOSS developers to any of my fledgling products, then it has to be on Github. \n\nThe claim that maybe in the future Github might be like SF just isn't convincing enough. "], [20, "I think it makes sense to mirror your git repositories on other hosts like bitbucket and gitlab, but github does a lot more than just host the repo. There's an entire social side of things where github basically doubles as my resume. I also find it way easier to make PRs to open source projects through github, because they make it stupid easy."], [14, "> Error establishing a database connection\n\nMaybe you should host your blog on a reliable service for simple websites such as github?"], [14, "Things that irk me as a paid Github.com user (2x) and a licensee of GithubEnterprise at work:\n\n1) Code Reviews are in a relational schema instead of Git itself, and wholly un-exportable (incl. history) by org/repo admins.\n\n2) Ditto issues.\n\n3) The inability to enhance my user's editing experience - http://paulhammant.com/2015/06/07/custom-json-editors-for-github/\n\n4) lack of holistic monitoring tools for administrators.\n\nThings I like:\n\n5) Git of course.\n\n6) The wiki being backed by Git too."], [12, "i moved away from github for one reason...seems to make zero sense to continue to pay for only 5 private repos when other services give unlimited private repos for free. I don't mind paying but 5 is rather limited IMO. They could win my money back when that limit is increased substantially"], [7, "If your world stops when GitHub gets DDOSed, I hear *distributed* version control can help."], [7, "Closed source doesn't particularly bother me.  What does bother me is the strange SJW racist non-sense that's going on at Github.  \n\nhttp://www.breitbart.com/tech/2016/02/08/report-anti-white-agenda-revealed-at-githubs-diversity-team/\n\n(please ignore the terrible website, just read the tweets/screen shots if you can't stand the obvious tilt of the author)"], [5, "Replacing Github for *anything else* is basically find&replace for git push url and then push\n\nnot a problem. Go away and try to \"fix\" something else\n\nThe \"problem\" is somewhere else, almost no tool for managing deps supports seamless multiple mirrors so many devs default to github because it is more popular.\n\nPackage managers in linux distros solved that years ago but programming tools are behind"], [3, "I'm not convinced by this article at all. I do, however, maintain archives of my repos and sync commits to multiple hosts."], [4, "> There\u2019s always been an irony to GitHub: it\u2019s the proud bastion of free and open source software, and yet it\u2019s completely and unquestionably closed source. This has always struck me as odd, kind of like when open source projects opt to use Slack as their chat platform instead of IRC; it\u2019s sends the signal that FOSS is good enough for us but not good enough for them.\n\n**TL;DR** Not everyone is ideological about open source. It's a practical matter for some of us.\n\nYou sound ideological about open source. I don't use Github because I suspect they drink my flavor of Kool-Aid, but because it's free, sharable code hosting with a great UI and minimal hassle. Similarly, I don't avoid IRC like the plague because it's not *sufficiently open-source*, but because every IRC client I've ever touched prioritizes \"feeling like a wizard for subduing a needlessly complex tool\" over, well, communicating efficiently.\n\nAnyway, if Github goes the way of 1990s Microsoft, it's easy enough to jump ship."], [3, "Github should pay less attention to this SJW thing and focus on improving Github platform. Their desktop site looks outdated,  profile and news feed need redesign, their mobile site is unusable and so on."], [2, "No one cares if its closed source."], [2, "Looks like the website is having trouble (getting an \"Error establishing a database connection\").\n\nHere is the [cached version](http://webcache.googleusercontent.com/search?q=cache:cYfqyzvFRLYJ:sudophilosophical.com/2016/02/09/get-off-of-github/+&cd=1&hl=en&ct=clnk&gl=uk) for anyone else who can't load it."], [2, "What the author says is possible to happen, but too early to be any confident about it actually happening.\n\nThe argument of \"source not open!\" is actually a good one IMO. Projects using it all open their source, but GitHub not? Hmmm, shady, in the context..."], [2, "I hate that Github is like hacker facebook. \"If i don't host my shiny project there nobody will discover it\". And companies will have to figure out how to do technical interviews again since github was like Your Score on a scale of one to Eleven of how awesome a brocoder you are."], [-1, "Sorry, but no. They can do anything internally as long as github is up and running I'm fine..."], [1, "So i have to rent my own server to host some small projects i have on github ? \n\nHmm i will stick to GitHub for now."], [1, "So, you don't actually know anything, but you'd like to spread rumours of a nameless fear anyway?"], [1, "All those articles against GitHub make it look like someone is initiating a huge campaign against them."], [1, "The great thing about Git is that theres no reason that we can't keep our open-source code on both GitHub, Gitlab and Bitbucket. As well as keep all the code in sync. So if GitHub starts to seem dodgy we can keep a backup on other hosted services.\n\nThe big problem is that a few ecosystems like Bower and Go is built on top of GitHub and can't easily be moved."], [1, "> and yet it\u2019s completely and unquestionably closed source.\n\nNot completely."], [1, "This is Git. You have all your history in your local copy. Just push it somewhere else if GitHub goes under."], [-8, "TLDR"], [-9, "to be honest, IRC sucks balls (comes from a guy who used to run bitlbee for all his communications)."], [-10, "It's just 'off', not 'off of.'"]], [[{"comment": "Why?", "id": "czte5h4"}, {"comment": "Seriously, this article didn't tell me why I should move things off of GitHub to Gitlab other than GitHub is receiving VC. But if GitHub didn't receive VC, it probably wouldn't survive in its current form, like most tech companies. Also, why should I care that it's closed source? Are you going to start boycotting other companies because they're closed source?", "id": "cztejrr"}, {"comment": "Plus it's just a website where you upload stuff for everyone to see anyway, I don't see how being closed source is so bad.", "id": "cztfdv0"}, {"comment": "Also their core technology is GIT which is GNU Public License free as in freedom.\n\nIt's not like GitHub going down means you'll lose code, or access to proprietary specialized tools... It's a fucking Ruby  On Rails wrapper around GIT (with some database magic).\n\nWhat's too open source? All their auth, cookie, and DB wrapper code? I donate to the FSF but sometimes you freetards go too far. ", "id": "czthzhx"}, {"comment": "Issues maybe? Yeah, there are FOSS issue-trackers, but for many projects it would hurt losing issues. \n\nGitHub pages? \n\nPremissions?\n\nPull requests? (Surprisingly hard to implement in a good way).\n\nCommit-comments?", "id": "czumw8w"}, {"comment": "[deleted]", "id": "czu52uj"}, {"comment": "Any future employer that sees a few week gap and thinks \"this guy wasn't coding in his free time for a few weeks, let's not hire him\" is probably an employer best avoided.", "id": "czuggir"}, {"comment": "Use a generator to fill it in.", "id": "czue1si"}, {"comment": "If I have a free alternative, I tend to prefer it. ", "id": "cztrvlj"}, {"comment": "Sure, if the alternative is equivalent, then it's a no-brainer.  However, some things are worth paying a little money for.", "id": "czugezh"}, {"comment": "I mean free as in freedom.", "id": "czw9wrd"}, {"comment": ">But if GitHub didn't receive VC, it probably wouldn't survive in its current form, like most tech companies.\n\nLast I know GitHub wasn't VC-fuelled, they did have profit.\n\nAlso, you are making it sound as if tech is leeching off VC.", "id": "czuhzpe"}, {"comment": "They got a bunch of VC funding recently to try expand from what I heard.\n\nhttp://www.wired.com/2012/07/github100m/", "id": "czuiwsn"}, {"comment": "Yes, sure, I rather meant that they weren't operating on VC funding like many startups do, they actually could operate and turn a profit on their own.", "id": "czukxu1"}, {"comment": "That's WAAAY old. They just got $250 M for series B. http://techcrunch.com/2015/07/29/github-raises-250m-series-b-round-to-take-risks/", "id": "czvdsqf"}, {"comment": "Didn't Jira survive just fine without VC money?  I never see people telling me to quit using them.", "id": "czttfjs"}, {"comment": "They took some VC money at some point, but it was like a bonus bunch of cash, they could have survived without it.", "id": "czucwyd"}, {"comment": "Being closed-source means if they have any security bugs it will be much harder for hackers to find them before they get fixed. I'm not in favour of everything becoming open-sourced, just for the sake of it.", "id": "czumtyo"}, {"comment": "I see it as an argument about ideology. \n\nIf you are adamant on creating open source software / tools, you should have every piece of your workflow be open source (such as something like Gitlab for source hosting).\n\nOf course it would be very limiting to have every piece of your workflow be open source (OS, email, tools to write the software, compile, etc, ....) but where you host your code is very visible.", "id": "d003czq"}], [{"comment": "Nah", "id": "czteeaa"}, {"comment": "Yep.", "id": "cztfj3k"}], [{"comment": "\nShould we point out that when it becomes annoying. The same thing will happen t github as to what happened to sf. everyone will run like fuck to somebody else.", "id": "cztef4o"}, {"comment": "I don't like to deal in any way with companies that have a policy of discriminating against my race.", "id": "cztuynq"}, {"comment": "Could you elaborate? github or sf?", "id": "czukjn9"}, {"comment": "Github in particular. There was a leak a few days ago where a github executive was giving a lecture on how certain positions in github are \"not a job for white men\", and how \"white women are an obstacle to progress\", and a recruiter complained he had trouble justifying interviews with white people to his superiors, who demanded hiring people of other races to their exclusion.", "id": "czuksmw"}, {"comment": "[deleted]", "id": "czunc1n"}, {"comment": "Well this just massively increased my respect for Github. A company that's actually doing something (meaningful) to increase diversity in the industry? Sign me right up.", "id": "czuo151"}, {"comment": "Meaningfully discriminating against whites", "id": "czuv3bj"}, {"comment": "[deleted]", "id": "czul74j"}, {"comment": "It was my privilege.\n\n>I feel ya though bro. Being a white male in this country is fucking hard.\n\nThat may or may not be the case, but I sure won't support anyone who wants to make it that way. Every other race is allowed to organise and explicitly look out for its interests, so are we. Deal with it.", "id": "czul930"}, {"comment": "> Every other race is allowed to organise and explicitly look out for its interests, so are we.\n\nThis already happens. White people already look out for the interests of other white people. We don't advertise it because we don't need to. If you are white, you get the benefits anyway. It has been called \"an invisible package of unearned assets\". The word \"unearned\" is key; when you are white and complain about diversity policies violating meritocratic ideals, you are not arguing from a position of strength.", "id": "czuzvuq"}, {"comment": ">  It has been called \"an invisible package of unearned assets\"\n\nThat's a very roundabout way of saying \"white culture\" - ie, what you should expect living in a predominantly white society. All societies are inherently ethnocentric, fighting to make it otherwise is a historical aberration, not an attempt to \"reverse injustice\" as those doing so are trying to portray it.", "id": "czv054f"}, {"comment": "So, non-white people have a different culture than white people? Don't you live in the same place, watch the same movies, eat the same food, and vote in the same elections?", "id": "czv69iq"}, {"comment": ">Don't you live in the same place\n\nNot if I can help it.\n\n> watch the same movies\n\nI don't watch much TV, but I especially make a point of staying away from programmes where racial people are over-represented or mis-represented.\n\n> eat the same food\n\nI tend to stay away from the ethnic aisle, for the most part.\n\n>and vote in the same elections\n\n...for different people.", "id": "czv920y"}, {"comment": "OK, dude. Try not to get your sheets dirty at the next rally, or you might get mistaken for one of them.", "id": "czv9jdb"}, {"comment": "It's ok, I don't care about your opinion and refuse to feel the guilt or embarrassment you're trying to evoke for my beliefs. I recognise it for what it is - a fully-general counterargument and an especially lazy suppression attempt.", "id": "czv9r6n"}, {"comment": "And it's easier than ever, since git is a distributed VCS. Just pull from GH and push to your new remote.", "id": "czubbf4"}], [{"comment": "I am planning to leave GitHub myself, but the title of this is just divisive. Don't use the imperative in a title unless you want to polarise people.", "id": "cztghd6"}, {"comment": "I think the point was to polarize people. It gets people discussing it, even if it is a lot of people complaining", "id": "cztouq2"}, {"comment": "It gets people's attention though", "id": "cztx0wk"}, {"comment": "OH EM GEE, LIKE, TOTES! EVERYONE SHOULD JUST, LIKE, TOTALLY JUST, LIKE, BE PRETEND POLITE SO THAT THERE'S NO, LIKE, CONFLICT, LIKE, EVER. GOSH.", "id": "cztu6vi"}, {"comment": "So being civil is now the trait of dumb American teen girls? You've got this totally backwards, I'm guessing you also get upset in discussions about tabs vs spaces too.", "id": "cztxvup"}], [{"comment": "I've thought a lot about this too. My general philosophy towards open source is to use it unless it's just not feasible. \n\nGitlab is a great product, and I have moved a lot of my stuff to self hosting, so Gitlab is a great fit. The one killer feature Github has that makes Gitlab infeasible is its community. If I want any hope of attracting FLOSS developers to any of my fledgling products, then it has to be on Github. \n\nThe claim that maybe in the future Github might be like SF just isn't convincing enough. ", "id": "czthbh7"}], [{"comment": "I think it makes sense to mirror your git repositories on other hosts like bitbucket and gitlab, but github does a lot more than just host the repo. There's an entire social side of things where github basically doubles as my resume. I also find it way easier to make PRs to open source projects through github, because they make it stupid easy.", "id": "cztg46f"}, {"comment": "Yeah, that social side of things is what I couldn't care less for.  Once you need to use GitHub as your \"resume\", they'll start monetizing it in some stupid way.  I don't know, \"For only $10.99 per day you can see who forked your repo.  For only $2 you can find out who the owner of that repo is.  For $10,000 you can access our user base for your HR recruiting effort, filtering your job applicants based on GitHub contributions.\"  Evil stuff like that.  And then there will be ads.  This is the danger of getting VC's involved in anything resembling \"social\" on the internet.", "id": "czthqg1"}, {"comment": "Honestly I severely doubt that since they currently make plenty of money though businesses and people paying for private repositories. ", "id": "cztijpv"}, {"comment": "Obviously these 'features' would only apply to public repos", "id": "czu88mt"}, {"comment": "You sound like the sky is falling. If they start charging and you don't find that it's the best value to you, then don't subscribe. This is how capitalism works. GitHub has no moral imperative to provide you a free service; their only imperative is economic (and it just happens that their business model currently incentivizes them to provide free tiers for open source projects).", "id": "cztm5i8"}, {"comment": "The sky isn't falling.  There have always been legitimate reasons not to use GitHub, and this has always been one of them (among others, such as those outlined by Linus Trovalds).  The irony is that git was created to eliminate the need for monetized hosting services for open source projects.  People took to GitHub because it was easy, not because it was the right thing to do.  It helps to have an occasional reminder because it's still not the right thing to do. ", "id": "cztnyah"}, {"comment": "> There have always been legitimate reasons not to use GitHub, and this has always been one of them\n\n\"Because the service could cease to be free one day\" is not a reason to avoid a service, at least not when migrating away from the service is setting up an account elsewhere.\n\n> (among others, such as those outlined by Linus Trovalds)\n\n*Torvalds. Anyway, what are his grievances. I couldn't find any that could be considered a valid reason to give up GitHub (only that he didn't like the PR UI).\n\n> People took to GitHub because it was easy, not because it was the right thing to do.\n\nIt sounds like you're chastising people for basing their hosting decisions on costs and not ideology. I want to give you the benefit of the doubt, but I'm not seeing any other way to interpret your statement..", "id": "cztths1"}, {"comment": "I think you may be missing the broader point.  It's not about what might happen later, it's about having transparency and control over your work.  You could be lending your support to a project whose values are better aligned with yours, not just because it's \"free\".   And it's already not \"free\", anyway.  Your own argument is self-defeating - the only reason everyone keeps having to make like rats on a sinking ship every time one of these services goes to shit is because they didn't *invest* in something that they can truly own, and is just as good.\n\nThere are already subtle conflicts between open source and corporate interests.  One of which is GitHub's antagonizm towards freedom of speech and expression.  There are also trade offs caused by monetization - such as a centralized global authority rather than a federated & syndicated architecture.  GitHub is down? You're SOL! Unless you paid them for the privilege of running it on your own servers.  This is not what Open Source is supposed to be about - it's what people used to call crippleware.  \n\n\n Want to run it on your own server? Perhaps with some tweaks, perhaps, such as fixing the broken pull request model and using the one that is actually built into git?  Sorry, can't do that! You can, but only if you clone your repo somewhere else and use that other place as your master.  Which many people do with their private and even corporate repos, in my experience.\n\n\n", "id": "czu9lfx"}, {"comment": "> Your own argument is self-defeating - the only reason everyone keeps having to make like rats on a sinking ship every time one of these services goes to shit is because they didn't invest in something that they can truly own, and is just as good.\n\nI'm not sure how hard you think it is to change code hosting, but it's very easy. Much easier (and cheaper) than operating your own servers.\n\n> There are already subtle conflicts between open source and corporate interests. One of which is GitHub's antagonizm towards freedom of speech and expression.\n\nFreedom of speech and expression is a human interest, not an open source interest. As such, it's probably the most valid reason not to use a product or service. I generally stay away from Mozilla for this reason.\n\n> There are also trade offs caused by monetization - such as a centralized global authority rather than a federated & syndicated architecture. GitHub is down? You're SOL!\n\nUsing GitHub for free has been well worth their downtime. You seem to think that owning and operating your own server is somehow free, and that you could do a better job than GitHub.\n\n> This is not what Open Source is supposed to be about\n\nSorry, Open Source is not my religion. As such, I don't care \"what it's supposed to be about\". I use and contribute to open source software when it suits me. I think it's neat and fun, but that's the extent of it.\n\n> Want to run it on your own server?\n\nNo.\n\n> such as fixing the broken pull request model and using the one that is actually built into git?\n\nI use GitHub because it makes git less painful. Git is not the model for how a distributed version control system should work, and I suspect far fewer people would use it if it weren't for GitHub (personally, I think the world would be much better off if the GitHub folks heard about Mercurial before Git).\n\n> I think you may be missing the broader point. It's not about what might happen later, it's about having transparency and control over your work.\n\nI do have transparency and control over my work. GitHub is just where I host (some of) my code. I don't suspect we'll agree, because this isn't a matter of ideology for me as it is for you.", "id": "czueeui"}, {"comment": "One problem is what happens or could happen when almost all projects are places with the same company. \"Everyone\" is using Github and a lot of us are doing this because \"everyone else\" is doing it. Not only because it is free, then Bitbucket and Kiln and others would have a much large piece of the market. And more competition might create better products, for example with the possibility to export code reviews and issues (and code reviews didn't exist at first).\n\nI think we like the idea of a global directory of all open source projects. And the star-rating-system could possibly be made to work across hosting providers but it would be nice if not one provider owned such a large part of the market (of hosted source code repositories). \nTheir real value might now be that they are large and known, not that they have the best system.", "id": "czunctt"}, {"comment": "> And more competition might create better products, for example with the possibility to export code reviews and issues (and code reviews didn't exist at first).\n\nI don't think capitalism works because people boycott the best products to give their competition a better shot. I'm not about to switch my search engine to Bing because Google's search results are too good, for example.\n\n> I think we like the idea of a global directory of all open source projects.\n\nI don't especially care about this. I just like that it's a good UI around git, but I'm just fine with BitBucket (which even supports Hg!)\n\n> it would be nice if not one provider owned such a large part of the market \n\nThis doesn't really bother me either, although I do wish there was something as good as GitHub for Mercurial repos. That said, I don't talk about boycotting GitHub because they're suppressing Mercurial-based competition; the Mercurial guys just need to step up their game or be wiped out.", "id": "czurmlh"}, {"comment": "You seem to assume that Github is the best solution. I don't think that has been true all along, it might not even be true right now. \n\nOne problem is when everyone is using a solution that is not the best, which I felt has happened. Another problem is that products usually evolves much slower when one provider owns most of the market, and I think we all agree that Github has a very large part of the market.\n\nI havn't said anything about mercurial and it is not relevant for my points but I do think it was a better solution for a long time, it might even be the better solution for most users right now (I see it a easier to use and having a built-in gui is really great).", "id": "czvckdx"}, {"comment": "> You seem to assume that Github is the best solution. I don't think that has been true all along, it might not even be true right now.\n\nThe market thinks GitHub is the best product.\n\n> One problem is when everyone is using a solution that is not the best, which I felt has happened.\n\nThis isn't a problem for everyone; this is only a problem for you. Everyone else is quite happy using GitHub. I brought up Hg as an example because I would much prefer everyone to switch to BitBucket and use Mercurial--I think that's the better solution for everyone. Still, I recognize that most folks disagree with me (even though they're largely ignorant), and I don't take it upon myself to tell people what tools they should or shouldn't use.\n\n> Another problem is that products usually evolves much slower when one provider owns most of the market, and I think we all agree that Github has a very large part of the market.\n\nThis only happens because of some anticompetitive forces acting on the market (regulation, litigation, etc) or because the dominant player is doing *such a good job* delivering value that its competition can't keep up. The former isn't happening in this case, and the latter is desirable for the market in general (even though it's perhaps suboptimal for you and I in particular).", "id": "czw4ehz"}, {"comment": "Can't you just put your personal projects on Gitlab, and put that on your resume? I really doubt employers would be scrutinizing your commit steaks, and get discouraged by your inactivity, despite having actual contributions you highlight on your CV.", "id": "cztiqt5"}, {"comment": "Tell me more about these \"commit steaks.\" They sound delicious.", "id": "cztuuqr"}, {"comment": "> There's an entire social side of things\n\nYeah, that's the bad part.\n\n> github basically doubles as my resume\n\nDoesn't sound safe to rely on that. Exactly what [dungone said](https://www.reddit.com/r/programming/comments/44wl9x/get_off_of_github/czthqg1).\n\n> I also find it way easier to make PRs to open source projects through github,\n\nGitHub's issue tracker is one of the worst. It caters to people -- not implying you, I'm just speaking generally -- who mistake barfing two half-sentences into a new tracker entry for reporting a bug. Instead, the tracker should support the people who work with the tracker all the time: the developers. I'm sure you are aware of [this](https://github.com/dear-github/dear-github).\n\nThe github issue tracker doesn't support binary attachments (so users are allowed to waste time and space with base64 encoding their stuff). It also defaults to markdown, which is great for reddit, but incredibly stupid for a problem tracker where source code and diagrams should be the norm, not the exception. Again, there's an unwelcome social side to it. It's the facebook of issue trackers.\n\nBut, the worst aspect of github's issue tracker is that the data is all held hostage. You can take your git commit history and push it elsewhere, sure; but you can't export the issues. In the first place, you can't have a *complete* email audit trail of any issue, because you don't get emails about your own actions & comments.\n\nA well-maintained Bugzilla instance runs circles around github's tracker. Bugs have a bunch of metadata, the bug reporting can start with a template form (exact version, general description, steps to reproduce, frequency of reproduction, expected results, actual results, and so on), the email transcripts are complete, and (AIUI) Bugzilla should be able to export bugs in some XML format.\n\n> because they make it stupid ~~easy~~.\n\nFTFY\n\n**EDIT**: look [here](https://www.reddit.com/r/programming/comments/44wl9x/get_off_of_github/czth3q1) -- and that's a paying customer!\n\n... and [here](https://www.reddit.com/r/programming/comments/44wl9x/get_off_of_github/cztxkuf).", "id": "czu8a87"}, {"comment": "Don't forget that BitBucket is owned by a for-profit company. That's not to imply they're bad, but Atlassian has 1,259 employees to pay according to Google, meaning they have pressures to grow and show a profit like GitHub does.\n\nPreparing for the inevitable day GitHub becomes evil sort of feels like a bunker mentality. OTOH, I'm sure people can come up with looong lists of other free service darlings that went bad.", "id": "czugpfb"}], [{"comment": "> Error establishing a database connection\n\nMaybe you should host your blog on a reliable service for simple websites such as github?", "id": "cztenvp"}, {"comment": "It got Reddit hugged. ", "id": "czud89y"}, {"comment": "Connection to database? I can't even connect to the site.", "id": "czumm5m"}], [{"comment": "Things that irk me as a paid Github.com user (2x) and a licensee of GithubEnterprise at work:\n\n1) Code Reviews are in a relational schema instead of Git itself, and wholly un-exportable (incl. history) by org/repo admins.\n\n2) Ditto issues.\n\n3) The inability to enhance my user's editing experience - http://paulhammant.com/2015/06/07/custom-json-editors-for-github/\n\n4) lack of holistic monitoring tools for administrators.\n\nThings I like:\n\n5) Git of course.\n\n6) The wiki being backed by Git too.", "id": "czth3q1"}, {"comment": "> 1) Code Reviews are in a relational schema instead of Git itself, and wholly un-exportable (incl. history) by org/repo admins.\n> \n> 2) Ditto issues.\n\nI agree fully. `Reviewed-by` and similar tags should be picked up by maintainers from the project's development mailing list(s), and added to the commit messages (git rebase, reword).\n\nIt doesn't work of course if patch emails, review emails, pull emails, and command line `git` usage are replaced with \"github pull requests\", and a button that you can click on their proprietary webgui to merge the request.", "id": "czu8pc3"}, {"comment": "Yeah, but one of them is better (for me at least) because I need way less mental overhead.", "id": "czumxau"}, {"comment": "Custom editors sound like a perfect opportunity for XSS...", "id": "czuiwz4"}], [{"comment": "i moved away from github for one reason...seems to make zero sense to continue to pay for only 5 private repos when other services give unlimited private repos for free. I don't mind paying but 5 is rather limited IMO. They could win my money back when that limit is increased substantially", "id": "czth7nr"}, {"comment": "I have a BitBucket account for this reason alone right here. I also have a github, but only with the intention of dressing it up for resumes.", "id": "cztjiln"}, {"comment": "This is pretty much my use case for both services too.\n\nI use Bitbucket as a simple cloud storage for code that I don't particularly want public: be it things that are a work in progress, technologies I don't really want to be associated with, or little experiments/learning projects.\n\nMeanwhile, I like to think my Github gives a decent run down of my skillset and what I actually enjoy doing. I need an account for work and it makes contributing elsewhere easy enough - so it just *works* for me.", "id": "czun4b9"}], [{"comment": "If your world stops when GitHub gets DDOSed, I hear *distributed* version control can help.", "id": "cztqjzr"}, {"comment": "GitHub doesn't just do source control. If you store all your work items there (I don't, but I guess they'd like you do), being unavailable might limit your ability to browse your work (obviously the same goes for online TFS, FogBugz-on-Demand and other services).", "id": "cztr2dy"}, {"comment": "Doctor, it hurts when I do this.", "id": "czud7hl"}, {"comment": "I don't; but that doesn't mean it's a stupid idea.\n\nThere are tons of services out there that people use (I listed a few above) that give them huge productivity gains and it's a perfectly valid thing to do. Even if you chose not to do it at all (which I really doubt... even if it's email, I suspect you'll have some services outside or your companies control that will cause you grief if they're unavailable) it's likely going to get harder and harder to find locally-installable versions of hosted services over time.", "id": "czvajus"}, {"comment": "You shouldn't do that, then...", "id": "czu67ku"}, {"comment": "I don't; but that doesn't mean it's a stupid idea.\n\nThere are tons of services out there that people use (I listed a few above) that give them huge productivity gains and it's a perfectly valid thing to do. Even if you chose not to do it at all (which I really doubt... even if it's email, I suspect you'll have some services outside or your companies control that will cause you grief if they're unavailable) it's likely going to get harder and harder to find locally-installable versions of hosted services over time.", "id": "czvajdv"}, {"comment": ">I don't; but that doesn't mean it's a stupid idea.\n\nIt is a stupid idea to not have mirrors of your data. Having only one copy is just *retarded*, whether that one copy is on github or not. Even if they have backups that's irrelevant, they should have LIVE MIRRORS so that tools SEAMLESSLY transition to other sources if one goes down.\n\nIt's not that hard. You don't have to have local versions of everything. You just need backups and live mirrors. ", "id": "czvjs44"}, {"comment": "> It is a stupid idea to not have mirrors of your data. Having only one copy is just retarded, whether that one copy is on github or not\n\nNowhere did anyone say anything about having only one copy of your data. However having a copy of your data is not the same as seamlessly being able to work. Let's say you have copies of all your stuff from FogBugz when FogBugz-On-Demand goes down, you can't assign cases, raise new cases, add comments to cases, do code reviews (if you use Kiln)... Sure, you can use pen and pape, but then you'd have to copy stuff back into these things when the service returns.\n\nIf you live in a world where losing your internet connection doesn't affect your work *at all* then that's great, and I'm jealous. That's not the case for many of us and it's a relatively small risk that it's not worth the effort (or compromised services) that would be required to be able to work (without any type of inconvenience at all) that way.\n\nAs always, everything on the internet the internet must be black and white and apparently there's nothing in between \"being able to work entirely without a service\" and \"OMG this service is down it's the end of the world\". There's a lot in between. There's a lot of minor annoyances when services go down that don't stop the world, but are still worthy of complaining about (things don't improve if nobody complains).", "id": "czvtul9"}, {"comment": "I'm not talking about stuff like FogBugz though, sorry if the discussion got confused there. I mean stuff like the Homebrew registry, the tsd registry, etc. Those services should have live mirrors and clients should seamlessly shift to using mirrors rather than github if github is down.", "id": "czvujtk"}, {"comment": "Fair enough; my comments were more about the general theme lately of someone saying \"GitHub is down, it's affecting my ability to work\" and then a load of responses that say \"you're doing it wrong\", \"it's distributed\", \"you're an idiot\", etc.\n\nIt's valid for a service going down to affect you, even if it's GitHub. People are too quick to tell others they're wrong without knowing anything about what they do :(", "id": "czvx661"}, {"comment": "Except we are all behind NAT and probably have dynamic IP addresses. So we sort if need a central server some where...", "id": "czwkdx4"}], [{"comment": "Closed source doesn't particularly bother me.  What does bother me is the strange SJW racist non-sense that's going on at Github.  \n\nhttp://www.breitbart.com/tech/2016/02/08/report-anti-white-agenda-revealed-at-githubs-diversity-team/\n\n(please ignore the terrible website, just read the tweets/screen shots if you can't stand the obvious tilt of the author)", "id": "cztgbw1"}, {"comment": "I believe that article is largely based off of the [Business Insider one](http://uk.businessinsider.com/github-the-full-inside-story-2016-2) that preceded it if you'd prefer a more reputable source", "id": "cztw4kp"}, {"comment": "Thanks a lot!  Thats the one I was looking for.", "id": "cztwtsp"}], [{"comment": "Replacing Github for *anything else* is basically find&replace for git push url and then push\n\nnot a problem. Go away and try to \"fix\" something else\n\nThe \"problem\" is somewhere else, almost no tool for managing deps supports seamless multiple mirrors so many devs default to github because it is more popular.\n\nPackage managers in linux distros solved that years ago but programming tools are behind", "id": "czth2cf"}, {"comment": "> Package managers in linux distros solved that years ago but programming tools are behind\n\nReally? So who won? Apt? Yum? Something else? Because I'm pretty sure package management in Linux is still in disarray.", "id": "czumz7p"}, {"comment": "Care to elaborate ? And no \"i tried to pull package from completely different distro and it didnt work\" and \"package maintainer fucked up deps\" is not a valid argument.\n\nI can have both multiple versions **and** multiple archs of same package:\n\n    ->  dpkg-query -f '${binary:Package}\\n' -W |grep libx264\n    libx264-116:amd64\n    libx264-118:amd64\n    libx264-120:amd64\n    libx264-123:amd64\n    libx264-133:amd64\n    libx264-142:amd64\n    libx264-142:i386\n    libx264-146:amd64\n    libx264-146:i386\n    libx264-148:amd64\n    libx264-dev:amd64\n\nJust that it is rarely needed if developer of lib is competent. Sure you can try to fence the incompetence by puilling deps separately for each part like npm does but you end up with 70% duplication and 100MB  of crap just to compile css file\n\n\n", "id": "czun837"}, {"comment": "* It's not solved when you have to choose between 5-6 versions of a package depending on which distro you're using.\n* it's not solved when you download a 6-year-old package of abandonware that is the only tool people say you need to solve your problem and it can't run because your libraries are too new.\n* it's not solved when the same library has different names between distros.", "id": "czunkrc"}, {"comment": "That can be summed up to:\n\"i tried to pull package from completely different distro and it didnt work\" \n\nDistros cant fix it for that. Use containers for your legacy crap", "id": "czuo491"}, {"comment": "In other words, \"go fix it yourself or go f- yourself\". The typical linux-community response to anyone with a problem.", "id": "czuo8z8"}, {"comment": "[deleted]", "id": "czupdbk"}, {"comment": "You can swear on 4chan all you want, but /r/programming is supposed to have some restrictions.", "id": "czuq837"}, {"comment": "If your problem is from \"I'm too incompetent to fix it myself\" you can pay someone to fix it. Hell, Red Hat spinned business out of it.\n\nSorry for not having magical command `fix-my-shit` that fixes your shit. Programming is hard, there is no magic (altho there is plenty in package process, including automatically adding deps for lib versions you used in your app. But hey why should you bother with researching anything before you spew bullshit over the internet)", "id": "czusvpb"}, {"comment": "When I am the **user**, I shouldn't have to fix other people's products. Though I have been forced to do that on a couple of occasions, because we really needed those things fixed.", "id": "czutw6f"}, {"comment": "> Package managers in linux distros solved that years ago but programming tools are behind\n\nEver heard of \"dependency hell\"? This is actually a problem that is solved by some programming tools (cargo and bundler for instance), but not solved by most package managers in Linux distros.", "id": "cztkdnn"}, {"comment": "Dependency hell has been solved by distro package managers for YEARS. Go look in your `/lib` some time.\n\n>omg we are so original guys we like totally put version numbers in directory names omg", "id": "czu65ku"}, {"comment": "\"Solved\" as in \"add a bunch of redundant crap\". \n\nThere is a reason why most distros dont go the way of \"just include lib in 8 versions needed by various deps\", it would double (or more) install size and increase memory usage (multiple versions of same lib instead of one shared by every app).\n\nIt is better for end user if package maintainer and app dev get their shit together rather than waste RAM and diskspace.\n", "id": "cztq4ob"}, {"comment": "Your asking for many many sets^1 of two probably unpaid strangers who don't know each other to coordinate over long periods of time to save a small amount of RAM and disk space. Especially when philosophies between these people can and do differ on a regular basis.\n\nI'd rather just let the RAM and disk space be used then try to coordinate all those people. There's 'better' and then there's 'feasible'.\n\nFootnote 1: The number of sets being the number of applications times the number of distributions.", "id": "czugglz"}, {"comment": "Point one: Debian exists.\n\nPoint two: you dont need any coordination between the two. Patch doesn't need to be upstreamed\n\nPoint three: if you are outside of ruby/js land, libs usually have pretty good backward compatibility so outside of major version change you most likely dont have to do shit to make it work\n\nPoint 4th: have you actually tried ? because it *sound* like you are pulling arguments out of your ass just for the sake of argument", "id": "czulesc"}, {"comment": "1. Debian is one distribution. There are so many other distributions out there. And while Debian tries, all I see are outdated packages. And even as it tries, it's taking quite a lot of time and effort that is unpaid to do this. Time and effort that can probably be spent better elsewhere.\n\n2. So then the developers get bug reports on your distribution that they cannot reproduce locally because you changed something. Is it their job to support these users? Many would say no, so now your distribution has to.\n\nFurthermore, not every program can be patched. If the program is closed source, you cannot modify it. You might be willing to run only open source software because of this, but most people don't care.\n\n3. It depends on the developer. I see backwards incompatible changes in lots of ecosystems all the time. Really, C and C++ are the only languages I don't generally see breaking changes in the libraries.\n\n4. I haven't tried, no. Because I'm not a distributor of packages. It's not for me to try nor have I released an application that requires external libraries since I'm usually working on web servers.", "id": "czuxodm"}, {"comment": "> There is a reason why most distros dont go the way of \"just include lib in 8 versions needed by various deps\", it would double (or more) install size and increase memory usage (multiple versions of same lib instead of one shared by every app).\n\nSo what, you only maintain a single version of a lib on your system? And when that changes in a backwards incompatible way, what are you going to do then? Demand project X that was using version 1.0.0 of lib Y refactor their code to support version 2.0.0 of lib Y? Just so you don't have to have two copies of a library on your disk?\n\nAre you working on a cellphone developed in the early 2000s? I can't think of any other reason why you'd be so worried about disk usage from shared libs.\n\nAt a worst case, my local Maven repository which caches every Maven artefact I download ever, and I work with a lot of JVM projects, is 3.1G.  ", "id": "czud6jy"}, {"comment": "[deleted]", "id": "czujq52"}, {"comment": "Yeah send me 200 1TB SSD drives and I'll agree with you. ", "id": "czull1h"}, {"comment": "If it is major incompatible version you can just have 2. Look at what your distro does, for example:\n\n    -> \u16ef dpkg-query -f '${binary:Package}\\n' -W |grep -P 'libpython\\d.\\d:amd'\n    libpython2.7:amd64\n    libpython3.3:amd64\n    libpython3.4:amd64\n    libpython3.5:amd64\n\nIf it is just minor version upgrade.... **I dont want ANY app to use outdated version of openssl because it WIIL be insecure**. You are replacing \"dependency hell\" with \"security hell\", where instead of updating one lib you have to update 40.", "id": "czullsn"}], [{"comment": "I'm not convinced by this article at all. I do, however, maintain archives of my repos and sync commits to multiple hosts.", "id": "cztfah4"}, {"comment": "I too. I mean I also use `git pull`\n\nThat's the beauty of Git", "id": "czth750"}], [{"comment": "> There\u2019s always been an irony to GitHub: it\u2019s the proud bastion of free and open source software, and yet it\u2019s completely and unquestionably closed source. This has always struck me as odd, kind of like when open source projects opt to use Slack as their chat platform instead of IRC; it\u2019s sends the signal that FOSS is good enough for us but not good enough for them.\n\n**TL;DR** Not everyone is ideological about open source. It's a practical matter for some of us.\n\nYou sound ideological about open source. I don't use Github because I suspect they drink my flavor of Kool-Aid, but because it's free, sharable code hosting with a great UI and minimal hassle. Similarly, I don't avoid IRC like the plague because it's not *sufficiently open-source*, but because every IRC client I've ever touched prioritizes \"feeling like a wizard for subduing a needlessly complex tool\" over, well, communicating efficiently.\n\nAnyway, if Github goes the way of 1990s Microsoft, it's easy enough to jump ship.", "id": "cztlt3z"}], [{"comment": "Github should pay less attention to this SJW thing and focus on improving Github platform. Their desktop site looks outdated,  profile and news feed need redesign, their mobile site is unusable and so on.", "id": "czuk46c"}], [{"comment": "No one cares if its closed source.", "id": "cztehje"}, {"comment": "I care, for what it's worth. It's a good service nonetheless.", "id": "cztequc"}, {"comment": "Why do you care? Do you want to host your own for some reason?", "id": "cztmf5y"}, {"comment": "I don't want to rely on any service I can't bail out of if I want to. The actual repos are just git, so I don't care about that, I have a full copy of the repo myself.\n\nThe issue tracking, though? GitHub has me by the balls if I rely on that, so I don't and won't. If they were really focused on being open and friendly to the developers that use GitHub they'd use a system for that information that was exportable and re-implementable by others.\n\nIf I have something I expect to be trying to work with for the coming decade I can't reasonably state that it's definitely true that in 10 years GitHub won't turn around and start demanding payment for a previously free service, or just stop existing entirely.\n\nRemember that a big part of the reason git exists at all is because BitKeeper went from free-to-use to not. Git was largely made to escape the trappings of a good but proprietary system that decided to change the game.\n\n", "id": "cztxkuf"}, {"comment": "> The issue tracking, though? GitHub has me by the balls if I rely on that, so I don't and won't.\n\nAFAIK GitLab is quite capable of importing the issues from GitHub. I haven't used it extensively, though, so maybe it lacks something important.", "id": "czuk65h"}, {"comment": "We'll import issues, repos, wiki's and pull requests from all your repo's in one click.", "id": "czvir45"}, {"comment": "> If they were really focused on being open and friendly to the developers that use GitHub they'd use a system for that information that was exportable and re-implementable by others.\n\nYou mean like [this][1]?\n\n> Remember that a big part of the reason git exists at all is because BitKeeper went from free-to-use to not. Git was largely made to escape the trappings of a good but proprietary system that decided to change the game.\n\nYes, but we're not talking about git, we're talking about *GitHub*. There's nothing stopping you from migrating if you decide they're not delivering you the best possible value; in fact it's very easy.\n\n[1]: https://developer.github.com/v3/issues/#list-issues-for-a-repository", "id": "cztyt2e"}], [{"comment": "Looks like the website is having trouble (getting an \"Error establishing a database connection\").\n\nHere is the [cached version](http://webcache.googleusercontent.com/search?q=cache:cYfqyzvFRLYJ:sudophilosophical.com/2016/02/09/get-off-of-github/+&cd=1&hl=en&ct=clnk&gl=uk) for anyone else who can't load it.", "id": "cztenlz"}, {"comment": "Yeah, that is exactly *why* you shouldn't make private gitlab instance on random VPS just to \"replace\" github, like some people want.\n", "id": "czth66l"}, {"comment": "How often do you link Reddit to your Gitlab installation? Because that strikes me as not being very clever.", "id": "czud96k"}, {"comment": "How the fuck did you got to that conclusion ?\n\nI was talking about case \"oh, github HA infrastucture can occasionally go down too, let's replace it with single node and hope it will do better than redundant architecture that is monitored 24/7\"", "id": "czuli50"}, {"comment": "You're commenting on a website that got Reddit hugged. Hence my question, how often do you really need a massive redundant architecture when you're not being Reddit hugged?", "id": "czviur0"}, {"comment": "Have it ever crossed your mind that people use Git in companies ?\n\nIf your company used github and replaced it by one non redundant gitlab install and it went down it would usually be heavy disruption of work. You would be basically doing extra work to ensure that you will have more downtime.\n\nSure, set it up as a *backup* to github, or set it up so if one server dies recovery from that will take minutes not hours \n", "id": "czvv098"}], [{"comment": "What the author says is possible to happen, but too early to be any confident about it actually happening.\n\nThe argument of \"source not open!\" is actually a good one IMO. Projects using it all open their source, but GitHub not? Hmmm, shady, in the context...", "id": "czui77c"}], [{"comment": "I hate that Github is like hacker facebook. \"If i don't host my shiny project there nobody will discover it\". And companies will have to figure out how to do technical interviews again since github was like Your Score on a scale of one to Eleven of how awesome a brocoder you are.", "id": "czvclls"}], [{"comment": "Sorry, but no. They can do anything internally as long as github is up and running I'm fine...", "id": "czthdti"}], [{"comment": "So i have to rent my own server to host some small projects i have on github ? \n\nHmm i will stick to GitHub for now.", "id": "cztj9r7"}, {"comment": "No, for instance gitlab.com offers public and private repos. ", "id": "cztyztd"}, {"comment": "I may be assuming, but I think the OP was referring to actual web hosting and not just hosting the repository.  With GitHub you can create a branch that will act as a website letting people browse your docs, etc. without having to do so in your README.md.  Not sure if this is offered on the other services...", "id": "czu0myv"}, {"comment": "If you're talking about github pages, gitlab has this features since a few weeks ! http://doc.gitlab.com/ee/pages/README.html (the service is available on gitlab.com and in the Enterprise Edition, not Community Edition)", "id": "czuoaii"}, {"comment": "bitbucket.org -- also does free private repos", "id": "czu47td"}], [{"comment": "So, you don't actually know anything, but you'd like to spread rumours of a nameless fear anyway?", "id": "cztrdtp"}], [{"comment": "All those articles against GitHub make it look like someone is initiating a huge campaign against them.", "id": "czuiv1g"}], [{"comment": "The great thing about Git is that theres no reason that we can't keep our open-source code on both GitHub, Gitlab and Bitbucket. As well as keep all the code in sync. So if GitHub starts to seem dodgy we can keep a backup on other hosted services.\n\nThe big problem is that a few ecosystems like Bower and Go is built on top of GitHub and can't easily be moved.", "id": "czulf39"}], [{"comment": "> and yet it\u2019s completely and unquestionably closed source.\n\nNot completely.", "id": "czumjcx"}], [{"comment": "This is Git. You have all your history in your local copy. Just push it somewhere else if GitHub goes under.", "id": "czz2ii3"}], [{"comment": "TLDR", "id": "czteux5"}, {"comment": "TL;DR:  FUD", "id": "cztg5sg"}], [{"comment": "to be honest, IRC sucks balls (comes from a guy who used to run bitlbee for all his communications).", "id": "cztfmxz"}, {"comment": "why?", "id": "czu27z9"}], [{"comment": "It's just 'off', not 'off of.'", "id": "cztijsx"}]]], "4ish5v": ["Learn how emoticons became emoji. And how to support them in your next app. Interesting piece by Instrument Marketing", "2016-05-11 05:01:30", 0, "http://www.instrument.com/latest/emoji-support-in-web-applications", [[1, "TIL \"emoji\" isn't just the newer, hipper term for \"emoticon.\""]], [[{"comment": "TIL \"emoji\" isn't just the newer, hipper term for \"emoticon.\"", "id": "d30zkla"}]]], "41ic9g": ["10 features in PHP that you really should learn (and use!)", "2016-01-18 13:03:15", 19, "http://www.codeaddiction.net/articles/34/10-features-in-php-that-you-really-should-learn-and-use", [[21, "Why on earth should I really learn to use anonymous classes? Can someone think of a reasonable use case where it's better than having a clean file with a class definition or better than using a lambda (the authors case should've used a lambda)?"], [5, "> 4) Reflection\n\nWorth knowing, but like most magical things, half the expertise is knowing when *not* to use it.\n\n> 6) DateTime class\n\nAnd don't forget about [DateTime**Immutable**](http://php.net/manual/en/class.datetimeimmutable.php) either, which is often what you want when you're passing dates around between different sections of code.\n\n> 9) json_encode() and json_decode()\n\nNote that `json_decode()` returning null is ambiguous: It could either be that the input is indeed a JS `null`, or that an error occurred. Unless you're certain that null is not a legal input, make sure you check [json_last_error()](http://php.net/manual/en/function.json-last-error.php) to figure out what just happened."], [2, "Couple ones I didn't know about, but the array one is pretty basic stuff. I agree that basic stuff is stuff you should learn."], [-4, "With PHP7 you can also use foreach. \ud83d\ude06"], [-6, "[deleted]"], [-19, "best feature so far is \nadd and remove -> uninstall"]], [[{"comment": "Why on earth should I really learn to use anonymous classes? Can someone think of a reasonable use case where it's better than having a clean file with a class definition or better than using a lambda (the authors case should've used a lambda)?", "id": "cz2nodu"}, {"comment": "I think the functionality is extremely niche and rarely useful, but I have used it a few times in Java for cases where I wouldn't have used a lambda, though mostly only in one project that was built around using the strategy pattern to provide extremely configurable behaviour. \n\nI don't really think it's a top ten feature on any list other than \"top ten things you should probably never use\" ", "id": "cz2pb85"}, {"comment": "That does make perfect sense, thanks. ", "id": "cz2q58r"}, {"comment": "> I think the functionality is extremely niche and rarely useful\n\nI can't think of any actual examples other than prototyping, but I don't really feel as if it was such an incredibly small niche that the PHP devs would have taken the time to implement it.", "id": "cz3ojop"}, {"comment": "Before lambdas were more mainstream a lot of anonymous class usage was just poor-mans lambdas. So most usage has been replaced.\n\nThere are times when you want to use a lambda but are forced to use a class. So it's useful to know it for those occasions as it can be nicer to inline an anonymous class when only 1 line of it's code is actual logic.\n\nThe other advantage is that you can think of anonymous classes as being a lambda that can have multiple methods. Mouse handlers which can have mouse move, down, up, and click are a good example of this in action.\n\nNote that in 5 years of Java I've used fucking tonnes of anonymous classes. In about 5 years of PHP I'm pretty sure I have never used a single one.\n\nAnonymous classes are really more of a Java thing.", "id": "cz2sa1n"}, {"comment": "Also C#, where it is used quite a lot in LINQ.", "id": "cz3oh33"}, {"comment": "I guess it would be useful in Unit Testing (mockups).", "id": "cz2pd6z"}, {"comment": "I use anonymous classes in code that essentially pulls information out of a database and then returns it in JSON format - essentially an ad-hoc container for when the PHP code doesn't care about the data within except to pass it to JSON_encode.", "id": "cz2zvjr"}, {"comment": "You use anon clases to avoid unnecessary hierarchies of related classes that add little to nothing to be maintain as regular classes eg code bloat.  ", "id": "cz3jdzv"}, {"comment": "I've never had good reason to use anonymous classes in a professional setting, but I do remember some data structures examples from school that seemed to make sense. For example, when implementing a linked list from scratch, you'd expose methods like add(), remove(), etc., but you'd hide the \"nodes\" (the storage mechanism for the objects being added to the list) inside an anonymous class because it was an implementation detail that the user shouldn't need to know about.", "id": "cz30nuc"}], [{"comment": "> 4) Reflection\n\nWorth knowing, but like most magical things, half the expertise is knowing when *not* to use it.\n\n> 6) DateTime class\n\nAnd don't forget about [DateTime**Immutable**](http://php.net/manual/en/class.datetimeimmutable.php) either, which is often what you want when you're passing dates around between different sections of code.\n\n> 9) json_encode() and json_decode()\n\nNote that `json_decode()` returning null is ambiguous: It could either be that the input is indeed a JS `null`, or that an error occurred. Unless you're certain that null is not a legal input, make sure you check [json_last_error()](http://php.net/manual/en/function.json-last-error.php) to figure out what just happened.", "id": "cz3jc85"}], [{"comment": "Couple ones I didn't know about, but the array one is pretty basic stuff. I agree that basic stuff is stuff you should learn.", "id": "cz2m4gz"}], [{"comment": "With PHP7 you can also use foreach. \ud83d\ude06", "id": "cz2mh3h"}, {"comment": "Sure it's still available, foreach has been available in PHP since at least version 4. Great feature nonetheless!", "id": "cz2mmjq"}, {"comment": "Of course. With many constructs it's a lot slower than a simple for, though. ", "id": "cz2uo03"}], [{"comment": "[deleted]", "id": "cz2krs2"}, {"comment": "I agree that there exists better languages than PHP, but we're facing the fact that a really big chunk of web development is done in PHP. Considering this I think it's important to spread knowledge on how to do PHP the best way possible.", "id": "cz2l1cq"}, {"comment": "It's not just that a large portion of the web is in PHP, I'd argue that a bigger component is that the majority of the web will already have PHP installed and enabled, as part of their LAMP/WAMP/XAMP stack.\n\nIf you want to develop a service or web app and want maximum adoption and ease of access, you do it in PHP (actually doing this currently myself).  Yes, you're denying yourself the sanity and tools that come with other languages, but then installation for end-users becomes as simple as drag-and-drop into their web directory.\n\nAnd THAT is huge.  That is what's stopping development for other languages, because people don't want to install and configure a handful of different language's toolchains just to get a web app running.", "id": "cz37st4"}, {"comment": "Of course, this notion is only appealing for small businesses which are the most common denominator.", "id": "cz3d36r"}, {"comment": "[deleted]", "id": "cz2mnms"}, {"comment": "Problem is that there is high quality software written in PHP.\n\nAs awful as PHP is, as long as other languages can't do the equivalent of wordpress, drupal, phpbb or mediawiki, I am sorry - the joke is on these languages.\n\nYou can laugh all you want about the quality, but at the end of the day, others will laugh at you and the \"solutions\" you offer them in perl, ruby and python.\n\nPHP beats you silly despite being an inferior language.\n", "id": "cz2w7ld"}], [{"comment": "best feature so far is \nadd and remove -> uninstall", "id": "cz2m3x9"}]]], "4bws69": ["I've made a small twitter account where I tweet one command (and it's man entry) everyday. Not exactly useful or ambitious, but I wanted to share that :3", "2016-03-25 18:57:43", 0, "https://twitter.com/acommandaday", [[5, "From the sidebar:\n\n> **Guidelines**\n\n> * Please try to keep submissions on topic and of high quality.\n\n> * Just because it has a computer in it doesn't make it programming.\n\n> * Memes and image macros are not acceptable forms of content.\n\n> * If there is no code in your link, it probably doesn't belong here.\n\nThat makes it, IMHO, very questionable if your post belongs here..."], [2, "This is actually pretty cool! Keep going:)"], [2, "I wish you'd focus on stuff that's not terminally obsolete like `wall`.\n\nOn the other hand, `yes` was something I'd forgotten about, and I'm grateful you're reminded me.\n\nNice work chap."], [0, "Nice. Fun way to remember obscure or useful Unix commands.\n\nThanks!"]], [[{"comment": "From the sidebar:\n\n> **Guidelines**\n\n> * Please try to keep submissions on topic and of high quality.\n\n> * Just because it has a computer in it doesn't make it programming.\n\n> * Memes and image macros are not acceptable forms of content.\n\n> * If there is no code in your link, it probably doesn't belong here.\n\nThat makes it, IMHO, very questionable if your post belongs here...", "id": "d1d75fg"}, {"comment": "Yes, I realized afterwards that this probably wasn't the right subreddit. :/\nI wonder where would be an appropriate place to post that ? ", "id": "d1d7jyq"}, {"comment": "I'm not sure, but I think if you write a little piece on how you did this it should have no problem being on this sub.\n\nThanks for sharing anyway", "id": "d1d972o"}, {"comment": "maybe r/linux or even better r/commandline", "id": "d1emh64"}, {"comment": "Oh perfect ! Thank you !", "id": "d1en9nf"}, {"comment": "I think it's fine here, but making a blog post on how you made it and linking the result would be an even better fit.", "id": "d1dsmly"}], [{"comment": "This is actually pretty cool! Keep going:)", "id": "d1d3e12"}], [{"comment": "I wish you'd focus on stuff that's not terminally obsolete like `wall`.\n\nOn the other hand, `yes` was something I'd forgotten about, and I'm grateful you're reminded me.\n\nNice work chap.", "id": "d1dfobn"}, {"comment": "I'll be more careful with the next tweets :)", "id": "d1donzg"}, {"comment": "Replacement for wall?", "id": "d1f5ajv"}], [{"comment": "Nice. Fun way to remember obscure or useful Unix commands.\n\nThanks!", "id": "d1d2mrl"}]]], "4e0rf7": ["19-year-old programmer creates free robot lawyer to save money on legal fees", "2016-04-09 14:08:11", 86, "http://www.odditycentral.com/technology/free-robot-lawyer-created-by-19-year-old-programmer-is-saving-people-a-lot-of-money-in-legal-fees.html", [[182, "All this does is ask a series of questions and try to figure out if you said yes or no.  It is a basic decision tree.  Calling this a robot lawyer is a massive overstatement."], [31, "I was expecting something like [this](http://afflictor.com/wp-content/uploads/2016/02/20150102futurama-robot-lawyer-1.jpg)"], [19, "[Not affiliated](https://i.redditmedia.com/HRhswi3Sep7TnDizOTO51tWsQ82NBNX1DcEK7E9O-V4.jpg?w=1024&s=dae0ab60c07aae4e6999d7ded17036ab)"], [15, "Surely the creator of said robot would open themselves up to a world of liability if people were using this?"], [10, "Technically this is trivial. I would expect more than this tabloidesque content from a sub like /r/programming"], [4, "Reminds me of Weizenbaums ELIZA and how people would put all their trust into its answers."], [3, ">  The breakthrough came when I learned how to create a way for the robot to learn and compare phrases itself, so that it doesn\u2019t matter how the user phrases his or her requests.\n\nOoo, don't hook this up to Twitter.. it will ruin it."], [3, "[Cinco e-Trial](https://youtu.be/XL2RLTmqG4w)"], [2, "Is the developer liable for any legal advice this thing gives?"], [2, "[Link to the service](http://www.donotpay.co.uk/) (it's called \"Do Not Pay\")\n\nFor some reason, it requires an account, although it doesn't seem to validate your email address at all -- not even syntactically. Like, you can put in `bob`as your email address and it'll take it.\n\nSeems like a cool idea, though."], [2, "I really wanted to be excited by this.\n\nBut this is really absolutely NOTHING.  Did you guys try it?  It doesn't actually work as a lawyer or is smart enough to understand questions you ask... it can ONLY do 3 things: help with parking tickets, delayed transit, and claiming PPI.  So it's really really not impressive at all... I mean, as a school project for a random course sure this is cool, but to get this in the news.... 19 year olds can build amazing things nowadays. This is not amazing :S\n\nIt can't even understand me trying to get help.  It says I can ask \"what can you do\" to get help. But if you have a typo of even one letter -- if you don't type exactly those characters -- it's useless.  I'm honestly not impressed at all, and I did want to be!"], [-5, "Decided to look it up. I'd be embarrassed if I was this kid. End-to-end amateur execution."], [-11, "Destroy it, destroy it now.\n\nHuman lawyers still have morals - yes, it's true - but a robot does not.\n\nBefore you know it, you'll have some jumped-up idiot with a 'save the galaxy' complex using this thing to find, exploit and create loopholes in law and then, before anyone realises it, he'll be running the show and the galaxy will be embroilled in civil war.\n\nIf *Star Wars* has taught me anything, it's taught me this.\n\nEDIT: Too obscure a reference I take it?  \nUnderstandable."]], [[{"comment": "All this does is ask a series of questions and try to figure out if you said yes or no.  It is a basic decision tree.  Calling this a robot lawyer is a massive overstatement.", "id": "d1w4izm"}, {"comment": "Ikr. First time I heard of this, I thought he made some crazy machine learning algorithm, somehow got gigabytes of court case records, did some language processing, figured out everything about each case and the outcomes, trained the algo, parsed out some rules from the constitution or something and miraculously what came out was a fucking lawyer.\n\n>So he programmed the robot to use text comparison that includes keywords, word order and pronouns.\n\nA keyword search.\n\n...\n\nTurns out it is slightly more complicated than an if-else chain. \n\nStill, good for the developer. He's getting a shit ton of traffic probably. Buzzwords trump usefulness.", "id": "d1w96ik"}, {"comment": ">made some crazy machine learning algorithm, somehow got gigabytes of court case records, did some language processing, figured out everything about each case and the outcomes, trained the algo, parsed out some rules from the constitution or something and miraculously what came out was a fucking lawyer.\n\nThat is actually a pretty good idea.", "id": "d1wafzm"}, {"comment": "Until you encounter the fact that the \"formalized english\" of the law isn't nearly as formal as you would hope. Trying to machine parse the law in general is likely a fool's errand.. one would soon fall into an endless pit of ambiguity, interpretation, and hidden (often highly abstract) context. However it would be cool if someone out there tried, if only to see how deep the rabbit hole goes.", "id": "d1wjnp5"}, {"comment": "Yup, that's the hardest part. You can't just create a bunch of rules and expect it to magically work. Stuff like this will need thousands of man hours, actual humans telling the computer what every tiny little thing means. This translates to gigabytes of hand written and parsed data. But you only have to teach it once and it will remember forever, so the reward (replacing (some) freaking lawyers) definitely warrants the effort. \n\nThe only kind of lawyers we *might* be able to replace in the near future are those that deal with 'easy' cases. Repetitive stuff, small amount of variables, which is why this parking ticket bot kinda works. Dealing with complicated criminal prosecutions, for example, is something that will take humans decades, if not years to trust a bot with, not to mention, it might take that long for us to even build them.", "id": "d1wvxw3"}, {"comment": "Honestly this is why I roll my eyes every time someone is talking about the \"big data analytics\" they do.\n\nFor really complicated problems, we *have* to create narratives.  You can't win a court case by parsing and summarizing a bunch of data in a PowerBI dashboard.  You gotta take all the data and make a story out of it because otherwise people just won't grasp what's going on.", "id": "d1x2snf"}, {"comment": "I would bet human-level legal competence is a harder problem than human-level programming competence. Given all the necessary context about not only the system of law but of the world which it seeks to describe, I'd wager AI lawyers are only possible a few short steps before complete AGI.\n\nProbably still lots of opportunity for machine learning tools to help law firms cut down on human research / doc prep hours, though.", "id": "d1wvfms"}, {"comment": "This was an active area of research and commercial interest a while ago(I wanna say the 70s or 80s?), back when expert systems were all the rage. Look up legal expert system. Obviously they didn't get very far back then. Perhaps with crowdsourcing and better machine learning algorithms, and a suitable niche, the concept could be taken a little further.", "id": "d1x21xp"}, {"comment": "Maybe he can use this script as a proof of concept to get vc funding so he can build out an actual machine learning team.\n\n\nNowadays big news companies like Reuters employ scores of linguists who work with data scientists to parse through throngs of news articles and auto generate breaking news items.", "id": "d1wdqvr"}, {"comment": "I thought the same thing. I'd like to work for this guy.", "id": "d1we9r8"}, {"comment": "Yeah, it's called IBM Watson.", "id": "d1wo2bt"}, {"comment": "There's a number of startups already working on this but it's not that easy to develop and challenging to monetize - right now the most promising business model is by marketing to lawyers as a time saver", "id": "d1wq7l7"}, {"comment": "> \"If it is one day possible for any citizen to get the same standard of legal representation as a billionaire, how can that not be a good thing?\u201d\n\n", "id": "d1wa1ze"}, {"comment": "Appeal to consequences?\n\nJust because a goal is laudable doesn't mean a project is sound. (ex: \"Why are you so against homeopathy? How is a future where everybody is healthy a bad thing? \")", "id": "d1wdomr"}, {"comment": "Well, yeah I agree. There's definitely something here. Or at least the start of something.\n\nI was just hoping for more :/", "id": "d1waen6"}, {"comment": "Your imagination, coupled with your knowledge of current, although somewhat bleeding edge, technological capabilities, has left you setup for disappointment. I suspect your odds of creating some amazing convergence are high though...", "id": "d1we8sm"}, {"comment": "That's kind of what makes this an exciting time. There's still so much left to be done :) \n\nEvery market is saturated. Websites. Android. iOS. Steam. AI/machine learning/data mining is new. Nothing that people nowadays keep calling AI is actually 'artificially intelligent' or even close to what that term was meant to define. The holy grail is still out there.\n\nI was honestly surprised how much of machine learning is really just mathematical models and statistical analysis applied to data. We're only scratching the surface.", "id": "d1wf71x"}, {"comment": "That actually isn't that hard to do anymore, depending on how involved you want it to be. A student can get a free IBM Bluemix account, load a whole bunch of legal documents into a Watson corpus, do some simple training, and have this kind of a thing pretty much entirely done for them. I've seen this exact thing done with Watson in an IBM Watson university competition I was in, and it worked quite well. ", "id": "d1wb698"}, {"comment": "Check out Ross built on Watson. I mean, IBM did some pretty impressive work, similar to what you have described, but applied to medical publications to help researchers. They've probably got a team building what you've described as we speak.", "id": "d1wg456"}, {"comment": "> Buzzwords trump usefulness.\n\nWell said. So so so true nowadays. ", "id": "d1x59ck"}, {"comment": "If the content is nicely curated and all the content is phrase-tagged, I'd combine the keyword search with a simple Naive Bayes lookup to create categorized wizards for narrow down solutions.", "id": "d1wbvlm"}, {"comment": "> All this does is ask a series of questions and try to figure out if you said yes or no. It is a basic decision tree. Calling this a robot lawyer is a massive overstatement.\n\nIt all made sense until your last statement.  There is a massive leap in logic there.  Why is this a massive overstatement and not, for example, a massive understatement?", "id": "d1wmpdh"}, {"comment": "Considering that \"robots\", at least modern ones, run on programming languages that translates to binary which is just the hardware checking and manipulating \"is this particular circuit off or on? Yes or no?\".\n\nI wouldn't consider calling it a robot an \"overstatement\" considering that robots, aka computers, are fundamentally just a decision tree of off and on \"Yes or no\".", "id": "d1wo4e9"}, {"comment": "This application is quite a basic decision tree though. I just tested it out, and it requires very specific keywords to answer every question.\n\n(and annoyingly, it resets every time it doesn't understand your input)", "id": "d1wyhnk"}, {"comment": "Ok, proof of concept aside, that's what an automated lawyer or doctor  (or anyone providing knowledge based services) would look like: a natural language input driving a classifier.\n\nService output accuracy is mainly driven by the knowledge database (laws, example cases, previous outcomes, etc) size and quality.", "id": "d1wl21a"}, {"comment": "Agreed. However, the day AI replaces Lawyers will be a monumental progression for humanity. ", "id": "d1wudrs"}, {"comment": "I think you're just described a substantial portion of what a lawyer does. They don't spend much % of their time being brilliant and eloquent in front of juries.", "id": "d1wnbry"}, {"comment": "It automates a task usually performed by a lawyer. That's... just what it does. That's what it is. There's no arguing about that.\n\nSo what's your complaint, about exactly?", "id": "d1wrrog"}], [{"comment": "I was expecting something like [this](http://afflictor.com/wp-content/uploads/2016/02/20150102futurama-robot-lawyer-1.jpg)", "id": "d1w3kej"}, {"comment": "Now I'm not some fancy big city lawyer but...\n\n\n\nP.s kill all humans", "id": "d1wdmsp"}], [{"comment": "[Not affiliated](https://i.redditmedia.com/HRhswi3Sep7TnDizOTO51tWsQ82NBNX1DcEK7E9O-V4.jpg?w=1024&s=dae0ab60c07aae4e6999d7ded17036ab)", "id": "d1w4k9e"}], [{"comment": "Surely the creator of said robot would open themselves up to a world of liability if people were using this?", "id": "d1w33zl"}, {"comment": "Sounds like a question for the robot lawyer!", "id": "d1w9079"}, {"comment": "\"Robot lawyer has zero liability.. bzzzrt\"", "id": "d1w9kr1"}, {"comment": "The clear solution here is robot court.", "id": "d1wfna4"}, {"comment": "Welcome to the world of HFT.", "id": "d1wtl20"}, {"comment": "Wouldn't you be able to put a disclaimer saying that this is just for advice. Like, if I ask my neighbour for legal advice and follow them and they turn out to not help my case you (at least I hope this is the case) can't make the neighbour liable for the damages his advice caused, you decided to follow them and you didn't pay for his expertise. ", "id": "d1w4vs7"}, {"comment": ">As a general matter, only a lawyer may give actual legal advice, whereas any non-lawyer may recite legal information.\n\n[Source](http://hirealawyer.findlaw.com/do-you-need-a-lawyer/what-is-legal-advice.html)", "id": "d1w65xr"}, {"comment": "brb dragging all the \"IANAL\" posters to a court", "id": "d1w7gsl"}, {"comment": "Just because they ANAL?", "id": "d1wo5dl"}, {"comment": "That disclaimer may not be enough.\n\nLegal advice can only be given by lawyers...and criminals to other criminals actually (prison lawyers as they are called in some places)....\n\nWhen you ask your friend what you should do their is no expectation that they know really anything more than you, when you ask a lawyer there is. They can't give legal advice because they have no knowledge or training, not true for some law students. This bot is specifically designed to give legal advice than you would have the expectation that it knows what it's talking about. \n\nHowever if it turns out the not does nothing more than pick out forms and fills them out for you, it in a really grey area...knowing what forms to use and when to use them is legal advice especially if you have more than one option but at the same time you should be able to find these forms for yourself somewhere (like the courts website)...\n\nThis is in the UK so I don't really know how it works across the pond, but in America it's really going to depend on what advice is being given, and how much. I don't think a disclaimer is going to be enough as the intent is to use what it make in actual open court...so no disclaimers are going to be enough to stop the expectation that iI gives you the right forms and thus the right advice so it would be an unauthorized practice of law. ", "id": "d1w874l"}, {"comment": "Nope. You'd need to say \"entertainment purposes only.\"\n\nThis post was for entertainment purposes only.", "id": "d1w8stn"}, {"comment": "Yes you could, although in my experience disclaimers don't necessarily protect you like you'd like in court. Not to say it wouldn't, just that I wouldn't be positive the disclaimer would protect me. ", "id": "d1xcv5k"}], [{"comment": "Technically this is trivial. I would expect more than this tabloidesque content from a sub like /r/programming", "id": "d1w9fs7"}, {"comment": "Looks like the developer has created a handy and well-presented tool. Maybe he's exaggerated about it's capabilities... but he's 19 and excited about his project. I'd be proud helping hundreds of people avoid incorrect fines.\n\nThe blogger seems a bit gullible and didn't bother to check anything... but he's not obliged to, it's just some guy writing his blog.\n\nOTOH I have no idea how this hit the front of /r/programming we should know better. Maybe it's just been a quiet Saturday?", "id": "d1wngc5"}, {"comment": "An intelligent law lookup and legal letter generator is actually pretty useful. Even basic legal guidance can be expensive. Perhaps it's not bleeding edge AI, but still a nifty project that could grow into or inspire something amazing.", "id": "d1wciga"}, {"comment": "The other point is, this post isn't really about programming. The blog says nothing about the implementation or design.", "id": "d1wnh7g"}], [{"comment": "Reminds me of Weizenbaums ELIZA and how people would put all their trust into its answers.", "id": "d1w4khy"}], [{"comment": ">  The breakthrough came when I learned how to create a way for the robot to learn and compare phrases itself, so that it doesn\u2019t matter how the user phrases his or her requests.\n\nOoo, don't hook this up to Twitter.. it will ruin it.", "id": "d1wbs6o"}, {"comment": "or make it awesome.", "id": "d1wgay0"}], [{"comment": "[Cinco e-Trial](https://youtu.be/XL2RLTmqG4w)", "id": "d1waow8"}], [{"comment": "Is the developer liable for any legal advice this thing gives?", "id": "d1wjxd2"}, {"comment": "In the U.S. I think he'd be in trouble for practicing law without a license if his site is giving legal advice. ", "id": "d1wqdcc"}], [{"comment": "[Link to the service](http://www.donotpay.co.uk/) (it's called \"Do Not Pay\")\n\nFor some reason, it requires an account, although it doesn't seem to validate your email address at all -- not even syntactically. Like, you can put in `bob`as your email address and it'll take it.\n\nSeems like a cool idea, though.", "id": "d1wk71c"}], [{"comment": "I really wanted to be excited by this.\n\nBut this is really absolutely NOTHING.  Did you guys try it?  It doesn't actually work as a lawyer or is smart enough to understand questions you ask... it can ONLY do 3 things: help with parking tickets, delayed transit, and claiming PPI.  So it's really really not impressive at all... I mean, as a school project for a random course sure this is cool, but to get this in the news.... 19 year olds can build amazing things nowadays. This is not amazing :S\n\nIt can't even understand me trying to get help.  It says I can ask \"what can you do\" to get help. But if you have a typo of even one letter -- if you don't type exactly those characters -- it's useless.  I'm honestly not impressed at all, and I did want to be!", "id": "d1x5d1u"}], [{"comment": "Decided to look it up. I'd be embarrassed if I was this kid. End-to-end amateur execution.", "id": "d1we3r8"}, {"comment": "You'd be embarrassed if you were 19 and created something that people thought was interesting (on the surface) and got a story out of it?\n\nWhat did you do at 19, again?", "id": "d1whuh2"}, {"comment": "Ad hominem. Nice.\n\nI'd be embarrassed if some jumbled together spaghetti code got labelled brilliant and I labelled genius for it.", "id": "d1wk3wz"}, {"comment": "Did you hear about the Italian chef that died? He pasta way. ", "id": "d1wk6by"}, {"comment": "it is actually easier today for someone to write software that does something useful when they are 19 now than if they were 19, 19 years ago (1997).", "id": "d1wt7k3"}, {"comment": "where did you find the source? I can't seem to find it.", "id": "d1wsd2t"}], [{"comment": "Destroy it, destroy it now.\n\nHuman lawyers still have morals - yes, it's true - but a robot does not.\n\nBefore you know it, you'll have some jumped-up idiot with a 'save the galaxy' complex using this thing to find, exploit and create loopholes in law and then, before anyone realises it, he'll be running the show and the galaxy will be embroilled in civil war.\n\nIf *Star Wars* has taught me anything, it's taught me this.\n\nEDIT: Too obscure a reference I take it?  \nUnderstandable.", "id": "d1w6zjz"}, {"comment": "I need proof on the claim that that is true", "id": "d1w7v8r"}, {"comment": "A robot is perfectly capable of morality.", "id": "d1w8b10"}, {"comment": "At least if you use lawyers as a yardstick", "id": "d1w8nkx"}, {"comment": "Well, this is going to get sci-fi, but I imagine in the next 10-30 years that AIs will develop to the point that they can replace most human workers. If you look at AlphaGo (the AI that defeated Go world champion Lee Sedol), it's basically a giant neural net. It works very similar to the way a human brain does. If these AIs can act as humans, then internally, the neural connections will be similar to those in a human brain, and you could argue that morality is contained within those neural connections.", "id": "d1w8uya"}, {"comment": "While it's possible for an AI to be moral, it's not guaranteed. The paperclip maximization thought experiment is probably overused, bit definitely something to think about. Of you tell a strong AI to reduce someone's legal trouble, it could find really creative ways to do that if you don't tell it exactly what it can and can't do.", "id": "d1w9d4m"}, {"comment": "While it's possible for a human to be moral, it's not guaranteed. The paperclip maximization thought experiment is probably overused, bit definitely something to think about. Of you tell a human to reduce someone's legal trouble, it could find really creative ways to do that if you don't tell it exactly what it can and can't do.", "id": "d1wcdqi"}, {"comment": "Well of course it's not guaranteed. It really depends on how the neural net is trained. AlphaGo only knows Go. But a learning neural net that was trained to converse with people, could have internal connections that mimic our own morality so that, at least to us, it \"thinks\" as if it has morals. I'm convinced that if it talks like a duck and walks like a duck, then it's a duck (ie. if computers can actually pass the Turing test, who's to say they're not sentient? Perhaps our sentience is built on exactly the same foundation as the computer's).", "id": "d1yjrzb"}, {"comment": "The problem is training the neural net. We aren't completely sure what morality is yet. In order to properly model it we basically need to solve the field of ethics. There's also the problem with changing ethical systems. If you released an AI in an environment where the overall ethics of the society were harmful then you end up with a ruthless killing machine. Imagine if the Nazis had gotten their hands on an AI and trained it to follow National Socialism and kill all Jews. That could end up spiralling out of control and it might decide that killing everyone with any shred of Jewishness or possibility of producing Jewish offspring is the best course of action.\n\nAn ethical AI can only really exist in a utopia. Any other situation will result in it recursively amplifying the negative aspects of an ethical system.", "id": "d1yk9h7"}, {"comment": "Well, what I imagine is an AI trained in a real person's environment. If an AI trained to talk to ordinary people (not just Nazis) were indistinguishable from a human speaker, it would require some kind of \"morality\" to respond to questions like \"should gays be allowed to marry, and why?\". Of course, its answer will depend on its training environment. If it was trained with a bunch of bible-thumpers, its answer will be different than if it were trained with secular people. The thing is, it doesn't require utopia to be ethical; no human was raised in utopia. It just needs to mimic a real person, of which there are many outcomes, not some idealized notion of a \"perfectly ethical being\".\n\n\n> The problem is training the neural net. We aren't completely sure what morality is yet. \n\nMy point being, we don't need to specifically tell it what morality is. I think in order to respond intelligently to human conversation, morality is a way of achieving that. It's an internal method of reasoning, but its not the end goal.", "id": "d1ylm92"}, {"comment": "The problem is that an AI acts much faster than a human. If a human makes a mistake, it can be corrected and prevented. If an AI makes a mistake, it could spiral out of control much faster. Like I said before, the errors in a machine e learning algorithm are recursive. It's definitely possible to make an AI that has the morality capacity of a normal human, but the question is would you give a single normal human control over something important? We function as a society because of checks and balances. One person's mistake is caught by another. If you wanted to implement an AI worker you'd need to do the same. You'd need to train multiple AIs in different situations and take the weighted average of their decisions. A single AI with complete control of a system is destined for catastrophic failure.", "id": "d1ymajn"}, {"comment": "I completely agree with everything you just said. This kind of AI that mimics the human brain comes with all the disadvantages of a human brain. It's just a much faster thinker and its training can be specialized. I would never advocate letting these AIs make important decisions. For some things though, like driving cars, or doing my taxes, a specialized AI is hands-down better than any human.", "id": "d1ynliz"}, {"comment": "Sounds like something a robot would say.", "id": "d1w9d4y"}]]], "4j56wf": ["Why Functional Programming is the Awesomest Sauce", "2016-05-13 11:12:26", 0, "https://medium.com/@HappyLearnTutes/why-functional-programming-is-the-awesomest-sauce-f458fb83d45e#.9vdsune15", [[3, "\"Functional Programming is about describing what the answer should be instead of describing how to get an answer.\" \n\nI am old enough to have heard this pseudo-description of \"declarative programming\" (particularly for logic and constraint programming) and I think it does more harm than good when applied to functional programming. The problem is that it is factually wrong: a functional program cannot be simply be a specification of the answer, it must **choose a strategy for computing** (e.g. selection sort vs. insertion sort vs. merge sort are all expressed differently in a functional language).\n\nIn fact, even Church's lambda-calculus represents a departure from the (then traditional)  \"extensional\" view of functions to an \"intensional\" view as a term-rewriting system; thus computation is essential even in the foundations of FP.\n\nIMHO, the key feature for FP is referential transparency (the ability to replace equals by equals); from that leads all other benefits for reasoning about programs and compositionality."]], [[{"comment": "\"Functional Programming is about describing what the answer should be instead of describing how to get an answer.\" \n\nI am old enough to have heard this pseudo-description of \"declarative programming\" (particularly for logic and constraint programming) and I think it does more harm than good when applied to functional programming. The problem is that it is factually wrong: a functional program cannot be simply be a specification of the answer, it must **choose a strategy for computing** (e.g. selection sort vs. insertion sort vs. merge sort are all expressed differently in a functional language).\n\nIn fact, even Church's lambda-calculus represents a departure from the (then traditional)  \"extensional\" view of functions to an \"intensional\" view as a term-rewriting system; thus computation is essential even in the foundations of FP.\n\nIMHO, the key feature for FP is referential transparency (the ability to replace equals by equals); from that leads all other benefits for reasoning about programs and compositionality.", "id": "d33ttz5"}, {"comment": "Sure. Referential transparency is *precisely* talking about _what_ not about _how_. It's talking about what things are, rather than how they do what they do. This is the dependency problem manifest in most OOP imperative programming.\n\nJust as choosing a data structure is something you can't get away from if you're going to do computing, we weren't arguing that computation has to \"be actually implemented somehow at some point\", rather that that level is not where pure FP language programmers usually work at, whereas it *is* where most OOP imperative language coders work.\n\nI don't think the argument you propose is against our main argument, though, because if you write your code at an abstract enough level (which Pure FP not only lets you do but encourages, which is our point), then you can easily adjust things quickly for a \"mass net win\", for example, as Simon Marlow etc at Facebook recently did with their implementation of Applicative do. (https://code.facebook.com/posts/745068642270222/fighting-spam-with-haskell/ - see the bit about applicative do).\n\nConsider the (somewhat toy) case of computing a set of independant results and then combining them (technically a commutative monoidal computation). This is an expression of the structure of the requirements of the intention of the programmer, but it says nothing about the execution strategy, rather only about the hard dependencies of the structure of the _answer_ you want. Recompile with multicore mode on, flip a few pieces of your code and you get quite a large speedup. This is practically impossible in most imperative languages. Ironically it would probably have been possible in a language implemented as Alan Kay had originally intended OOP to be (ie proper message-passing OOP).\n\nIf you haven't read Simon Marlow's book about concurrency and parallelism in Haskell, I really recommend it. It's a great read. http://chimera.labs.oreilly.com/books/1230000000929\n\nI'm not particularly young either, and I hope this doesn't come across as an imperative / OOP bashing contest, because it's not. We regularly use imperative OOP languages day to day, but programming in pure FP improves the way that code gets written massively because it shows one where ones dependencies are whereve one writes code.", "id": "d33xm5g"}]]], "4b8gcm": ["Functional Programming Philosophy", "2016-03-20 21:42:39", 0, "http://hkupty.github.io/2016/Functional-Programming-Concepts-Idioms-and-Philosophy/", [[7, "The article seems to confuse functors (which provide the `map` function) and monads (which provide `flatMap`, called `bind` or `(>>=)` in Scalaz, Haskell, PureScript, etc)."], [7, "Painting immutable values as some kind of silver bullet that magically alleviates the shared state issue when doing multi-threading or whatever form of parallelization needs to stop. First, when you use immutable values, you avoid race conditions, but in exchange your data may be stale. Second, when using immutable data structures, they typically need to be reasonably cheap to copy/return a modified version. This design constraint has trade-offs, it generally means that the data structures are not as efficient in other ways.\n\nWhether this cost is worthwhile as compared to the cost of locks depends on the problem. Mutexes are not particularly hard to use, but they impose significant performance penalty in some applications. Mutexes and immutable data structures are similar in that regard.\n\nThe holy grail is to program without either locks or immutable data structures. Of course, that's lock free programming, and it's really hard. locks, immutability, or lock-free: all three are good techniques you should know about it."], [6, "Functional programming and static type systems are orthogonal to each other. Can we please stop conflating the two?\n\nSincerely,\n\nA Lisp hacker"], [0, "Getting really tired of this endless drivel.... who keeps on posting those? We get it, functions, \"immutable\" variables, goddam it. This is high school math.\n\nWhy this kind of writings annoy so much is that at this point, there is absolutely no added value of repeating the thoughts of cleverer people from decades ago."]], [[{"comment": "The article seems to confuse functors (which provide the `map` function) and monads (which provide `flatMap`, called `bind` or `(>>=)` in Scalaz, Haskell, PureScript, etc).", "id": "d16yqya"}, {"comment": "Glad to see you preferring `map` and `flatMap`, rather than continuing to use Haskell's confusing `fmap` and `bind`. :)", "id": "d172hlw"}, {"comment": "What are those?  Are you referring maybe to `Select` and `SelectMany`?", "id": "d1741ob"}, {"comment": "Actually I prefer `map` and `flatMap` to `Select` and `SelectMany`, even though I came from a C# background.  I never really jived with the SQL-esque naming choices.  I don't consider them *bad*, but still ... just my opinion.", "id": "d179ki1"}, {"comment": "at first I thought it was really weird, and I still like map and filter, but I think the SQL like names are pretty brilliant in terms of allowing existing .NET people to understand what these operators do pretty much right away.", "id": "d17c78r"}, {"comment": "I thought it was `point` and `<<=`?\n", "id": "d17aqfg"}, {"comment": "I didn't want to throw in too much and make the article scary for non-functional programmers. I probably have worded it badly, so instead of simplifying, it's actually inaccurate. Thanks for pointing out ", "id": "d16yych"}, {"comment": "I though the article chose a good and consistent balance for introducing things. It was a long and hard lesson to me that liberties must be taken in human communication. :)", "id": "d174op6"}], [{"comment": "Painting immutable values as some kind of silver bullet that magically alleviates the shared state issue when doing multi-threading or whatever form of parallelization needs to stop. First, when you use immutable values, you avoid race conditions, but in exchange your data may be stale. Second, when using immutable data structures, they typically need to be reasonably cheap to copy/return a modified version. This design constraint has trade-offs, it generally means that the data structures are not as efficient in other ways.\n\nWhether this cost is worthwhile as compared to the cost of locks depends on the problem. Mutexes are not particularly hard to use, but they impose significant performance penalty in some applications. Mutexes and immutable data structures are similar in that regard.\n\nThe holy grail is to program without either locks or immutable data structures. Of course, that's lock free programming, and it's really hard. locks, immutability, or lock-free: all three are good techniques you should know about it.", "id": "d178uas"}, {"comment": "I agree with what you said here; there is no silver bullet when it comes to programming. If there were, we wouldn't have such a range of languages tackling the same problems in so diverse ways.\n\nThe intention of this post is not to debunk non-functional languages; instead, all I want is to allow people to come closer to functional languages. ", "id": "d17b4y3"}, {"comment": "One particular problem is that actually, any decent programming language will let you write functions. Let's take C++.\n\n    template <typename T>\n    T min(T a, T b)\n    {\n        if (b < a) return b;\n        return a;\n    }\n\nThere you have it. Works on any type that has `>`, immutable values, whatever. You don't need to \"come closer to functional languages\" to do what people writing code have been doing for a while now. What is a \"non-functional language\", anyway? Functions are _mathematical abstractions_, not some kind of shoes you only buy at a particular shop or a delicacy you only get in the far north-west of China.\n\nAs to the silver bullet: maybe there is, we haven't found it yet. How do _you_ know?\n\n**PS** as a rule of thumb, I comment when I downvote. So nice to see everyone does that.", "id": "d17fwki"}], [{"comment": "Functional programming and static type systems are orthogonal to each other. Can we please stop conflating the two?\n\nSincerely,\n\nA Lisp hacker", "id": "d177zwo"}, {"comment": "Also, functional does not imply that the language is Haskell.  \n\nSincerely,\n\nOCaml programmer", "id": "d18t11v"}], [{"comment": "Getting really tired of this endless drivel.... who keeps on posting those? We get it, functions, \"immutable\" variables, goddam it. This is high school math.\n\nWhy this kind of writings annoy so much is that at this point, there is absolutely no added value of repeating the thoughts of cleverer people from decades ago.", "id": "d17eu9u"}]]], "4brg4p": ["I created an NPM package for everything, so you don't have to rely on so many other small packages.", "2016-03-24 17:02:40", 3, "https://www.npmjs.com/package/diys", [[9, "spoilers:\n\n    exports.func = function() {\n        return \"Do it yourself, stupid!\";\n    }"], [4, "I hoped you are somehow eval-ing the first js function with that name that you find on the internet"], [2, "I was wondering what the last S stands for. Good Job!"], [2, "and the sad part is js developers will find ways to use these one liner \"post left-pad\" jokes as serious code that will end in some other tragedy a few months down the line.."], [1, "This is everything I hoped for and more. 10/10 would use again."]], [[{"comment": "spoilers:\n\n    exports.func = function() {\n        return \"Do it yourself, stupid!\";\n    }", "id": "d1by1mx"}], [{"comment": "I hoped you are somehow eval-ing the first js function with that name that you find on the internet", "id": "d1bzy1t"}, {"comment": "That's waaaay too complicated for an npm package :)", "id": "d1c3zbn"}, {"comment": "Well, he would, but he'd have to have a way to left-pad first, and that's still not supported in Javascript.", "id": "d1c5gw7"}], [{"comment": "I was wondering what the last S stands for. Good Job!", "id": "d1buokv"}, {"comment": ":)", "id": "d1bvg4m"}], [{"comment": "and the sad part is js developers will find ways to use these one liner \"post left-pad\" jokes as serious code that will end in some other tragedy a few months down the line..", "id": "d1c501g"}, {"comment": "Probably when http://left-pad.io will have a downtime :)", "id": "d1c5e06"}], [{"comment": "This is everything I hoped for and more. 10/10 would use again.", "id": "d1bp0ip"}, {"comment": "Thanks, that's the idea!", "id": "d1bpawh"}]]], "45iznl": ["Yet Another Markup Language", "2016-02-13 08:50:45", 1, "https://elliot.land/yet-another-markup-language", [[14, "Yaml ain't markup language is what it actually stands for. Structured data is not markup. JSON isn't markup either. HTML is.\n\nAwesome post though"], [7, "In my brief investigation of YAML I got the impression that its relatively complicated and would probably be tricky to write a parser for it, which would mean that different implementations would probably behave incompatibly in the corner cases.\n\nIs this really the case or am I worrying too much?"], [7, "There's a huge difference between a language and implementations of that language, and this applies equally well to serialisation languages as it does to programming ones.  Implementations of YAML, at least the ones I've come into contact with, do seem incredibly slow.  Is there something about all that YAML flexibility that makes it inherently expensive?\n\nI'm not arguing against YAML in general, since in many cases reading configuration files (for instance) isn't performance sensitive.  But I will offer a rough, unscientific benchmark that has caused me some frustration:\n\nThe game [OpenXCOM](http://openxcom.org/) uses it as its saved game format; save files are about 1 MB and take several seconds to load and save using the C++ YAML library.  In Python, one of those save games takes approximately 9.7 seconds to read from YAML; and 5.2 seconds to save again (with the same settings for indentation, etc.).  Loading and saving the same data in JSON format, with reasonable human-readable indentation, takes 0.05 (reading) and 0.27 seconds (saving).  As far as I can tell both libraries are pure Python.\n\n(Edit: inevitable typos.)"], [5, "Firstly, it's \"[YAML Ain't Markup Language](http://yaml.org/spec/current.html)\", although Wiki notes that it was originally 'Yet Another...' - \"but it was then reinterpreted (backronyming the original acronym) to distinguish its purpose as data-oriented, rather than document markup.\"\n\nI started using YAML in Symfony (because I have a distaste for annotations, and wouldn't ever put myself through using XML), and I mostly like it. My only complaint is its rigid dependence on spaces for indentation. Had to write a bufenter autocommand in my .vimrc to turn on expandtabs when editing a YAML file, and disable it when entering any other buffer.  \n\n    fun! SetExpandTab()\n        if &ft =~ 'yaml'\n            set expandtab\n        else\n            set noexpandtab\n        endif\n    endfun\n\n    autocmd BufEnter * call SetExpandTab()"], [2, "I always use YAML for config and object serialization in Ruby; there is out-of-the-box library support and it strikes a nice balance between minimalism and human grokkability (and editability)"], [1, "My experience with yaml went like this : shit. Bad config. Paste into online yaml tool. Oops missed a space, or accidentally put a tab. Try again. Missed another space.\n\nI'll take json, or even xml any day... \n\n\nNot to mention... all of those spaces take up extra room."]], [[{"comment": "Yaml ain't markup language is what it actually stands for. Structured data is not markup. JSON isn't markup either. HTML is.\n\nAwesome post though", "id": "czy8kji"}, {"comment": "You're mixing apples and oranges here.\n\nThe markup is the syntax.\n\nThe structured data is the semantics.\n\nJSON and HTML are isomorphic, the way your mark the data (syntax) is the only difference.", "id": "czyedwf"}], [{"comment": "In my brief investigation of YAML I got the impression that its relatively complicated and would probably be tricky to write a parser for it, which would mean that different implementations would probably behave incompatibly in the corner cases.\n\nIs this really the case or am I worrying too much?", "id": "czyb01q"}, {"comment": "I've never written a parser for it but everyone says it's very complex.\n\nI'm not entirely sure of the relevance of that, though. There must be very decent parsers in most mainstream languages already so you don't actually have to *reimplement* the spec (of course, the more complex the spec, the higher the risk of bugs).\n\nA far more relevant complaint is having communicate the difference between structures as basic as\n\n    a:\n       b\n\nand\n\n    a:\n      - b\n\nThe article has more examples of the many (unnecessary, distracting) nuances of YAML.\n\nYAML is a better choice for many things JSON has been used for because JSON has been used for many things it is wholly unsuited for. YAML itself is not necessarily a good choice, however.", "id": "czybphz"}, {"comment": "I think YAML is great for configuration files. This is something where JSON is completely unsuitable for due to the lack of comments.", "id": "czybxqd"}, {"comment": "In comparison, JSON is fine if you need something very simple and that's exclusively machine-read and machine-generated. ", "id": "czyc82j"}, {"comment": "I agree. JSON is a good transmission format because its to simple and fast. However, if the file is generated by a human that's the line where YAML needs to step in.", "id": "czz0gwm"}], [{"comment": "There's a huge difference between a language and implementations of that language, and this applies equally well to serialisation languages as it does to programming ones.  Implementations of YAML, at least the ones I've come into contact with, do seem incredibly slow.  Is there something about all that YAML flexibility that makes it inherently expensive?\n\nI'm not arguing against YAML in general, since in many cases reading configuration files (for instance) isn't performance sensitive.  But I will offer a rough, unscientific benchmark that has caused me some frustration:\n\nThe game [OpenXCOM](http://openxcom.org/) uses it as its saved game format; save files are about 1 MB and take several seconds to load and save using the C++ YAML library.  In Python, one of those save games takes approximately 9.7 seconds to read from YAML; and 5.2 seconds to save again (with the same settings for indentation, etc.).  Loading and saving the same data in JSON format, with reasonable human-readable indentation, takes 0.05 (reading) and 0.27 seconds (saving).  As far as I can tell both libraries are pure Python.\n\n(Edit: inevitable typos.)", "id": "czyd5a6"}, {"comment": "For storing saves it would be better to use msgpack or other binary format rather than YAML. Or even JSON. YAML is meant to use as humanreadable format, gamesaves aren't meant to be edited by hand. ", "id": "czyia33"}, {"comment": "Using YAML for storing data like that doesn't make much sense either. It makes sense for fire and forget configurations, and for what it is, data markup. But it doesn't make sense for what JSON is meant to be used for.", "id": "czyd8uo"}, {"comment": "YAML's primary objective is to be human readable and maintainable so using it to store data that should not ever be viewed by a person means that is the wrong use. Some binary serialisation format would do a much better job in this scenario.\n\nI expected YAML to be slower in general because the parser is much complicated, but that's crazy slow. Since YAML is a super set of JSON - I wonder what the performance would be if you pasted the JSON that represents the configuration into the YAML file? Would this allow the parser to be closer to JSON parsing speeds?", "id": "czz0lpv"}, {"comment": "At work we use a lot of configuration for our PHP web app in YAML since it's perfect for this, but it's split into lots of little files for each module or area.\n\nWhen any of the configuration files change the whole lot if recompiled into one PHP file that is cached so the performance of reading the YAML isn't a problem for us.", "id": "czz0yob"}], [{"comment": "Firstly, it's \"[YAML Ain't Markup Language](http://yaml.org/spec/current.html)\", although Wiki notes that it was originally 'Yet Another...' - \"but it was then reinterpreted (backronyming the original acronym) to distinguish its purpose as data-oriented, rather than document markup.\"\n\nI started using YAML in Symfony (because I have a distaste for annotations, and wouldn't ever put myself through using XML), and I mostly like it. My only complaint is its rigid dependence on spaces for indentation. Had to write a bufenter autocommand in my .vimrc to turn on expandtabs when editing a YAML file, and disable it when entering any other buffer.  \n\n    fun! SetExpandTab()\n        if &ft =~ 'yaml'\n            set expandtab\n        else\n            set noexpandtab\n        endif\n    endfun\n\n    autocmd BufEnter * call SetExpandTab()", "id": "czy8qad"}, {"comment": "`autocmd FileType yaml setlocal expandtab`?\n\nOr maybe `setlocal expandtab` in `after/ftplugin/yaml.vim`. I've never really liked using `after/`.", "id": "czybkeu"}, {"comment": "I was using that for quite some time. Eventually, I noticed expanded-tabs starting to appear in other files, and what I traced it to is my tendency to open new files with `:split filename`. When you split a buffer, the current buffers settings are inherited, including `expandtabs`. So because of that, it is necessary for me to `set noexpandtab` whenever I open a new file. (I suppose `BufRead` would be the most accurate event to use.)\n\nI've never run across ftplugin, that looks useful. ", "id": "czyj4de"}, {"comment": "I'm aware of the renaming but Yet Another Markup Language is the original and a way better name.\n\nJust like PHP started out as Personal Home Page which was an apt name for what it was originally designed for. Then they were ashamed of its pedigree and tried to backronym it to PHP Hypertext Processor.", "id": "czz0sgd"}, {"comment": "Hah, sometimes I like the old names more than the project owners too.", "id": "czz5vqv"}], [{"comment": "I always use YAML for config and object serialization in Ruby; there is out-of-the-box library support and it strikes a nice balance between minimalism and human grokkability (and editability)", "id": "czyeqz2"}, {"comment": "For this it's perfect, but I can understand some of the previous comments if your serialising *a lot* of data that YAML can be a large drain on performance.", "id": "czz0ui8"}], [{"comment": "My experience with yaml went like this : shit. Bad config. Paste into online yaml tool. Oops missed a space, or accidentally put a tab. Try again. Missed another space.\n\nI'll take json, or even xml any day... \n\n\nNot to mention... all of those spaces take up extra room.", "id": "d00bjwy"}, {"comment": "Try using an editor or IDE that understands indentation. When you paste mixed spaces and tabs it will convert them to the one you prefer automatically. Unless your copying a lot of config and often, which would maybe indicate that you should use the files as they were provided - I have not run into this issue.\n\nI don't believe spaces is a valid argument either. If your using any one of these three formats for configuration then they should all have around about the same amount of indentation.", "id": "d0162zb"}]]], "45vpi4": ["How much does a .NET developer make in Poland?", "2016-02-15 12:27:10", 1, "http://startupmyway.com/how-much-does-a-net-developer-make-in-poland/", [[2, "Getting out of stacks like that will greatly increase your pay.\n\nThe more lucrative salaries come from the more functional languages, in Poland."], [2, "Now, the question that stands: how easy it is to get a work visa for Poland?"], [1, "in Warsaw it's rather +50-100%. Still lowish"], [1, "> 100% remote jobs are still uncommon in Poland, unless you are a Sharepoint developer.\n \nWhy sharepoint? Odd."], [1, "As someone from the US, I appreciate that you converted the Polish currency to US dollars for comparison.  But I suspect - or at least hope - that 2252 USD for a senior developer buys a lot more in Poland than it does in the US."], [-4, "[deleted]"]], [[{"comment": "Getting out of stacks like that will greatly increase your pay.\n\nThe more lucrative salaries come from the more functional languages, in Poland.", "id": "d00juor"}], [{"comment": "Now, the question that stands: how easy it is to get a work visa for Poland?", "id": "d00ljg3"}], [{"comment": "in Warsaw it's rather +50-100%. Still lowish", "id": "d00ir75"}], [{"comment": "> 100% remote jobs are still uncommon in Poland, unless you are a Sharepoint developer.\n \nWhy sharepoint? Odd.", "id": "d00k4wq"}], [{"comment": "As someone from the US, I appreciate that you converted the Polish currency to US dollars for comparison.  But I suspect - or at least hope - that 2252 USD for a senior developer buys a lot more in Poland than it does in the US.", "id": "d011blu"}, {"comment": "It's low compared to Sweden as well... which is why a number of swedish companies are outsourcing there.", "id": "d04jdcm"}], [{"comment": "[deleted]", "id": "d00jus2"}]]], "44ltwq": ["MapReduce is not functional programming", "2016-02-07 17:44:14", 1, "https://medium.com/@jkff/mapreduce-is-not-functional-programming-39109a4ba7b2#.s7ipu65dh", [[7, "Who presents MapReduce as the poster child of functional programming?\n\nMapReduce fits nicely into functional code (it fits into java code too but you probably need five abstract factories for it to work). The thing is... nobody calls it MapReduce in functional programming."], [2, "> Moreover, without a combiner, there isn\u2019t even a binary operator involved, and these fancy mathematical properties do not come into play at all.\n\n    # Ruby:\n    [3, 5, 18, 2, 9].flat_map { |n| [n] }\n    #=> [3, 5, 18, 2, 9]\n    ((((([] + [3]) + [5]) + [18]) + [2]) + [9])\n    #=> [3, 5, 18, 2, 9]\n    [3, 5, 18, 2, 9]\n    #=> [3, 5, 18, 2, 9]\n\nGotta love the identity aggregation."], [2, "I shall disagree with you sir!\n\nThere's a few definitions of FP, the one I agree with and the one that is on Wikipedia is pretty simple: coding in the absence of side effects. Using higher-order abstractions is a common consequence but not a requirement.\n\n*It's not FP because the operations involved are very trivial.* I don't think there is a non-triviality requirement. If I write a trivial one-line Haskell program then that's still functional programming.\n\n*Some people put side effects in their map stage.* Okay, so those people aren't really doing FP. It's not really MapReduce at that point.\n\nI think the more accurate thing to say is: MapReduce is not a very interesting or representative example of FP."], [2, "We're going to spend a decade telling each other what functional programming isn't and nobody is going to say what it actually (save the haskell guys, but they're speaking an alien language we call math)."]], [[{"comment": "Who presents MapReduce as the poster child of functional programming?\n\nMapReduce fits nicely into functional code (it fits into java code too but you probably need five abstract factories for it to work). The thing is... nobody calls it MapReduce in functional programming.", "id": "czr2u2a"}, {"comment": "Apart from the fact that \"map\" and \"reduce\" are functions from Lisp, and the original MapReduce paper explicitly points this out, I guess. :-)", "id": "czr3vwp"}, {"comment": "I went looking, and it seems that [they mention the inspiration right in the introduction](http://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf):\n\n> Our abstraction is in- spired by the map and reduce primitives present in Lisp and many other functional languages.", "id": "czre2kd"}, {"comment": "Yes, I'm aware of that; the post discusses the connection between map/reduce in FP and map/reduce in MR - I completely understand where the names came from, they are catchy and there is indeed a connection, but the connection is not very deep nor very important.", "id": "czr4jar"}, {"comment": "That seems like a difficult claim to sustain, given the importance of commutativity and associativity in both cases, and that the original Google designers didn't take inspiration from those functions on a whim.", "id": "czr518w"}, {"comment": "Hi, I'm the author.\n\nI can't remember many concrete examples of people presenting MapReduce as the poster child of functional programming on the spot, but I've definitely seen a lot of them, and I've done this myself when I was teaching functional programming a few years ago; I already somewhat knew what MapReduce was, but wasn't yet intimately familiar with it (as I am now, working in the team that made it), and I was eager to look for signs of usefulness of FP in anything and everything around me. (I still am, but MapReduce is not one of them :) )\n\nI can give you the latest example: the article was prompted by the amazing post http://www.haskellforall.com/2016/02/from-mathematics-to-map-reduce.html , which, after finally opening my eyes to adjoint functors, at the end says:\n\n_We could have predicted the importance of \"map-reduce purely from the theory of \"free Monoids\"!_ ... _I believe that each one of these fundamental functions is a programming paradigm waiting to be discovered just like the map-reduce paradigm._\n\nTo me, this looks like saying that, by discovering the foldMap function discussed in the article, we have discovered MapReduce, but foldMap is a very very limited special case of MapReduce, and ability to do foldMap is not the reason why MapReduce is important.\n\nP.S. Speaking of Java code and MapReduce: [here is](https://github.com/GoogleCloudPlatform/DataflowJavaSDK-examples/blob/master/src/main/java8/com/google/cloud/dataflow/examples/MinimalWordCountJava8.java) the classic \"MapReduce\" wordcount example using the [Cloud Dataflow](https://cloud.google.com/dataflow/) SDK with Java 8 - no abstract factories in sight :) okay, okay, there is one.", "id": "czr3a77"}, {"comment": "> To me, this looks like saying that, by discovering the foldMap function discussed in the article, we have discovered MapReduce, but foldMap is a very very limited special case of MapReduce, and ability to do foldMap is not the reason why MapReduce is important.\n\nI see it rather as saying both foldMap and MapReduce are things that fall out naturally from an understanding of free monoids, and he's predicting that (some) other \"paradigms\" can/will be discovered that are based on the same theoretical foundation. Not only does this seem inevitable to me, I strongly suspect we're just exploring an isomorphism between programming's relationship to math and [physics' relationship to math](https://www.dartmouth.edu/~matc/MathDrama/reading/Wigner.html). At some point, it will stop being a surprise, let alone _contentious_, that programming is a mathematical activity, and its theory is simply (a particular example of) mathematical theory.", "id": "czr45jg"}, {"comment": "I agree with almost everything you said, and I'm happy every time I learn of another application of this or that branch of mathematics to practical programming. All I'm saying is, in MapReduce as applied in practice, there is no more mathematics involved than in an SQL GROUP BY query.", "id": "czr4dc1"}, {"comment": "Which is to say, quite a lot.\n\nSeriously, what _is_ this thing where processes that are _totally_ mathematical are handwaved away as not being merely because the human being asking the computer to perform the process might not be _aware_ it's mathematical? The mathematics doesn't require a human observer to exist!", "id": "czr555y"}, {"comment": "Again I think we're agreeing on almost everything, and probably have about the same value system in relation to programming.\n\nThank you for pushing back, it's making me think more clearly what is it really that irks me about mentioning MapReduce and monoids in the same sentence.\n\nI think it is because I am really in love with both MapReduce and applications of abstract algebra in programming, so I would like to see them to be presented in their full glory, showing what really are their non-obvious greatest strengths; I would like a reader to say \"Whoa, I didn't realize it was this interesting and powerful!\" - otherwise I feel that they're not getting the appreciation they deserve: I imagine someone reading a post like this and thinking \"Huh, that's really all there is to MapReduce and monoids? apply a function to a list and combine the results? I could have done that in a perl script! Those damn eggheads, always overcomplicating things\".\n\nThat said, I very much appreciate the role mathematics has played in creating and commoditizing things like SQL and the relevant parts of MapReduce as well (combiners). I just feel that, once it's been commoditized so much that everybody finds it intuitive and even non-mathematical, it stops being a good tool for explaining the importance of mathematics in day-to-day programming. This is totally subjective, of course.", "id": "czr5noh"}, {"comment": "> I imagine someone reading a post like this and thinking \"Huh, that's really all there is to MapReduce and monoids? apply a function to a list and combine the results? I could have done that in a perl script! Those damn eggheads, always overcomplicating things\".\n\nHaving seen the phenomenon you're concerned about many times (cf. any thread on monads), I think I now understand your concern better. Thanks for the patient elaboration!\n\n> I just feel that, once it's been commoditized so much that everybody finds it intuitive and even non-mathematical, it stops being a good tool for explaining the importance of mathematics in day-to-day programming.\n\nIt loses _pedagogical_ value. That's a really interesting point I hadn't thought of. Thanks!", "id": "czr5x64"}], [{"comment": "> Moreover, without a combiner, there isn\u2019t even a binary operator involved, and these fancy mathematical properties do not come into play at all.\n\n    # Ruby:\n    [3, 5, 18, 2, 9].flat_map { |n| [n] }\n    #=> [3, 5, 18, 2, 9]\n    ((((([] + [3]) + [5]) + [18]) + [2]) + [9])\n    #=> [3, 5, 18, 2, 9]\n    [3, 5, 18, 2, 9]\n    #=> [3, 5, 18, 2, 9]\n\nGotta love the identity aggregation.", "id": "czre3tr"}], [{"comment": "I shall disagree with you sir!\n\nThere's a few definitions of FP, the one I agree with and the one that is on Wikipedia is pretty simple: coding in the absence of side effects. Using higher-order abstractions is a common consequence but not a requirement.\n\n*It's not FP because the operations involved are very trivial.* I don't think there is a non-triviality requirement. If I write a trivial one-line Haskell program then that's still functional programming.\n\n*Some people put side effects in their map stage.* Okay, so those people aren't really doing FP. It's not really MapReduce at that point.\n\nI think the more accurate thing to say is: MapReduce is not a very interesting or representative example of FP.", "id": "czri5v0"}, {"comment": "> coding in the absence of side effects. Using higher-order abstractions is a common consequence but not a requirement.\n\nThat's the definition, and so, the statement that MapReduce is not functional programming is absolutely incorrect.\n\n\"MapReduce fails to fully represent the possibilities of functional programming as a paradigm\" is a better title, but nuanced titles don't get upvoted. ", "id": "czryzw5"}, {"comment": "Nothing is functional programming by that definition.", "id": "czsuyhf"}, {"comment": "> Okay, so those people aren't really doing FP. It's not really MapReduce at that point.\n\nI agree this is not FP in the strict sense, but I disagree that this is not MapReduce - or, put another way: for you this is a reason to say that this is not MapReduce; for me, one more reason to say that MapReduce is not FP. I can't think of a way to resolve this disagreement because there is no unambiguous, undisputable formal definition of MapReduce specifying whether or not side effects are allowed - all I can tell you is, this is an important and very common practical use case of applying the system called \"MapReduce\" at Google, and AFAIK the same is true of Hadoop too. Spark seems to take a more pure approach, though.", "id": "czrzwed"}], [{"comment": "We're going to spend a decade telling each other what functional programming isn't and nobody is going to say what it actually (save the haskell guys, but they're speaking an alien language we call math).", "id": "czrjtyb"}, {"comment": "More than anything else, this is what makes me eager to retire from our field: when there really _are_ unambiguous definitions (e.g. \"referential transparency\") that give both explanatory and predictive power (\"science\"), but people reject them and insist on debating their ambiguous \"definitions\" for literally decades.", "id": "czs9jrg"}]]], "4bgryx": ["Agile Is The New Waterfall \u2014 A Followup", "2016-03-22 13:53:53", 106, "https://medium.com/@ayasin/f1c0bcd2162e#.722f1ynmi", [[117, "This is all getting pretty tired. Any methodology is bad if it is done badly, why is that obvious fact worth writing articles about?!"], [13, "TL;DR: buzzwords are dumb and we need to adapt our process depending on needs yada yada"], [15, "The problem is that you're not doing waterfall correctly.\n\nI mean agile.\n\nI mean scrum.\n\nI mean..."], [8, "Uncle Bob is allowed to bash agile but you aren't. Um. So there."], [6, "I did an Agile project for a large bank.  It was their first after being waterfall for ages.  The executive that sponsored the project insisted on Agile (huge red flag).  Fast forward 6 months and when the product being delivered without ALL of the requirements (due to the inevitable scope creep, new requirements, incomplete requirements, technical difficulties, etc), the same executive that decided that the project MUST be Agile decided that he didn't like Agile because at the end of the project he didn't get everything that he wanted when he wanted it.  He then pulled the plug and changed the methodology on-the-fly and forced the project to be waterfall.  I left at that point.\n\n\nMassive clusterfuck."], [6, "I have to say, my [large] organization adopted agile all the way to the CEO level starting about three years ago and things have *definitely* improved.  "], [6, "God, medium.com is awful. "], [5, "The engineering science of software development is not yet perfected\n\nIt's more of an art form, or in some cases, a train wreck\n\nLots of smart people invent ideas to make it better, some of these ideas help a bit, when they fit"], [4, "\"Agile isn't Waterfall\" - this is false for two reasons:\n\n* the original waterfall paper actually speaks about major traits of agile: customer feedback, iterations, \"throwaways\", testing, whatnot; if you do not believe me, find the original waterfall paper by Royce and read it carefully, past the third page (it is less than 10 IIRC)\n\n* just like **total and utter** ***idiots*** of yore completely misinterpreted Waterfall, idiots of today completely misinterpret Agile today\n\nHistory soooo repeat itself, it is uncanny!"], [3, "I'm a victim of manager change... got an old school operations manager from the 90s come in as a project manager for a dev project. He doesn't know anything about programming. He even hired a business guy from another department who was laid off. Hired him as a \"developer\" because his resume said so. He was bewildered by the other dev teams didn't hire him even though he had a \"steller\" * cough * fake * cough * resume. We've been planning, testing, planning testing for a yuuuuuge migration project which contains a bunch of systems since April 2015! aka WATER FALL! there's no water... just FALL. Daily half an hour calls... I spend 3 hours a day on meetings. No crap released yet. Ahhhhhh! I feel like quitting. I'm pretty sure things will blow up on the release day because these guys don't understand that systems are connected. I'm pretty sure the top management guys are going to cull this group once they see how much money is wasted. \n\nYou never know how good you've had it until you lose it. "], [2, "[deleted]"], [2, "It's funny seeing all these articles appear. Im like \"fuck people at work don't even think a build server is worth the effort\".\n\nTheory vs reality right there :S"], [2, "> You don\u2019t say \u201cwe have 3 bags of concrete and 2 hours\u201d then get a civil engineer to do the design.  You get the civil engineer to do analyze the issue, and that informs how much time and how many materials you need.\n\nI think this analogy is dangerous.  This sort of thinking is _why_ we have so many broken implementations of an \"agile\" process.  This is how uninformed MBA's _think_ software development works (because they're taught that in MBA school).  I get what the author is going for here, but besides preaching to the choir, analogies like this one just reinforce a broken faith on software estimates... which, if were reasonable, would imply that waterfall is the perfect methodology for software development.  Software is inherently inestimable (outside of an order of magnitude or so).  Bridges can be estimated to decent precision, in a reasonable amount of time, because so many have been built.  Every useful software project is inherently brand new: if it wasn't brand new, then by definition it's already been written, so why are you writing it again?  You can compare it to something vaguely similar, but that's only going to help you to the extent of the similarity.  On the other hand, budgets are real, too -- when you're out of money, you're out of money.  The agile manifesto was supposed to reconcile the reality of inherently immovable budgets with the reality of inherently inestimable work, but appears to have completely failed in that regard."], [1, "I actually talked about agile at my last job interview ( I really like agile, but I see its flaws) they like waterfall. \n\nEnd of discussion was that we really will try combine it. The big question is? How -_- Anyone ever did that?"], [1, "Theoretically agile development can probably be effective, but I have yet to work at a place that actually embraces agile development. Every place I've worked at has implemented its own ad-hoc \"agile development methodology\" that basically just takes the things it likes about agile and gets rid of the things it finds annoying. Namely, most places I've seen tend to embrace two parts of agile development:\n\n1. A multi-phase ticketing system like Jira that lets gives you fine-grained control over every aspect of categorization and lets you divide tickets into springs and epochs, even though no one really organizes those properly; and lets you assign story points, even though no one bothers to assign story points, either.\n2. Daily or nearly-daily meetings in which the direction of development is changed on a whim because we're \"agile\".\n\nTo state the obvious: Yes, I know there's nothing agile about that. Yes, I know you can't just implement a couple parts of agile and still have agile. Yes, I have brought this up to people. No, no one who is paid more than me has ever cared.\n\nI once worked on an \"agile\" team of 5 people in which our morning standup/scrum/whatever stretched to *forty-five minutes*. When I pointed out that the standups were getting long and suggested we actually stand up for them, someone protested\u2014I shit you not\u2014that she didn't like standing up because \"it was tiring\".\n\nI worked in one place that actually assigned story points. I thought it was bullshit at first, but lo and behold, after about 4-6 weeks, we actually started getting really good at estimating task length using story points! Holy shit! Oh, except the CEO (this was a small 6-person startup) caught wind of what we were doing, and got it in his head that 1 story point == 4 hours of work (no one could explain to him the abstract concept of story points), and would say things like, \"Oh, a 3-point task? You really think that's going to take 12 hours?\" or \"Oh, you only have 8 story points assigned to you this week? Shouldn't you have at least 10?\" and the momentum we had quickly got torpedoed.\n\nSo yeah, agile probably works if you do it right, but no one does it right and management never really tries to learn what it's all about anyway.\n\nBut really, who the fuck cares? Is the world really going to collapse because you didn't complete your new dating app or yet another food delivery service, anyway?\n\nAm I jaded? You bet! You work over 10 years in the field, you'll be pretty fucking jaded, too. Go into finance, kids; at least you'll have a pretty nice nest egg saved up after a decade."], [1, "Agile promotes mediocrity by focusing so much on estimation and predictions. Can Anyone disagree with that at least?"]], [[{"comment": "This is all getting pretty tired. Any methodology is bad if it is done badly, why is that obvious fact worth writing articles about?!", "id": "d18zcmi"}, {"comment": "Because there is no barrier to entry on medium.com", "id": "d18zfj2"}, {"comment": "Or /r/programming. I've been complaining about low effort, low value, repetitive, blog posts here for years. I mean look at the very beginning of the article;\n\n> Several months ago I wrote an article lamenting the fetishization of Agile in place of the practice of actually being agile\n\nFetishization? Really? I've worked in a lot of places, I know a lot of programmers, and I read a lot of programming sites. That looks like a huge exaggeration to me. Plenty of people are *trying* agile (and many fail) because it's new to them or their organisation, but the only people I can see fetishising are people who make money from agile. \n\nIt's just low effort clickbait, like most discussions of programming have become. \n\n**tldr; \"Blogs Considered Harmful\" ^^^/s**", "id": "d18zs7o"}, {"comment": "Consider yourself lucky. I recently left a job that went from highly productive to almost completely frozen in process overhead because we got a new manager who fetishized Agile. What the author says rings true from my personal experience.\n\nHere's the problem: Our team was already agile. If you read the Agile Manifesto, yeah, we were doing that. And it worked fantastically. We started winning some very big and important projects because we had a reputation of getting things done in a timely manner and to a high degree of quality. We were growing. And with that growth came the hiring of this new manager.\n\nAccording to him, we weren't doing Agile, because doing Agile means we need to do Scrum. And it means we need a full-time certified scrum master to serve as a second boss. And it means we have to use specific software and tools designed for Agile. And it means no work is done unless it has a ticket specifically describing that work in complete detail, with points associated with it, which means we need to hold at least two meetings with everybody on board. Any time a small complication was discovered while working on a ticket, we had to stop everything and hold a series of meetings to get the process back in line. This was all mandated from the top down, against unanimous opposition from the development team.\n\nWas the manager doing Agile and Scrum correctly? Hell no. But he truly thought he was, because he was making sure the process hit all the buzz words. And his boss thought he was, because he saw all the buzz words being hit. They believed they were more knowledgeable about Agile than the developers were, because they read the important marketing materials they got from the important expensive out-of-state meetings they attended. I doubt either of them had ever actually read the Agile Manifesto or done any real research (for the life of me, I couldn't get them to understand that Agile and Scrum were not literally synonyms). No matter. Their marketing material convinced them that this was the only correct way to do things; if it fails, it's because the team didn't commit to the process (as the bosses understood that process to be) strongly enough.\n\nSo yeah, I think it's fair to call that fetishizing Agile. Among other things.", "id": "d19lgm9"}, {"comment": "What, in your opinion, are the reasons for failure?", "id": "d19008t"}, {"comment": "[deleted]", "id": "d1904yt"}, {"comment": "To expand a little, I think it's exactly the same thing as \"everyone wants to look like a fit, healthy person but few are willing to adopt a fit, healthy lifestyle out of fear, uncertainty, doubt.\" I've spent a lot of my career as a consultant in some way for big companies and it's incredible the lengths that organizations will go through to justify continuing to do business in completely inefficient ways because it's perceived that it'll take too much effort. Consulting for companies is very similar to trying to be a personal trainer for fat people with tons of money but appetite for everything besides changing their lifestyle.", "id": "d197zx9"}, {"comment": "An apt analogy, it's a common kind of human failing/dilemma re-expressed at a large-scale.\n\nSome coaches and consultants get pulled in to function as safety-blankets, trusted-ears, or plain \"spiritual gurus\"... Even when the consultant really *wants* to help them fix their damn problem and move on.", "id": "d19ct3f"}, {"comment": "I've been pulled into political quagmires where consultants are used as scapegoats for failing projects to save executives' reputations. It's a pretty brilliant tactical move honestly, I don't blame them (the system rewards basically selfish assholes even if they're good-natured people, such is modern business). Good companies have learned to steer their star players away from those situations because they're massive wastes of mental energy. Why else would Google take DoD money to the tune of hundreds of millions at least but farm it out to partners? Others stuck holding the bag either have to sink or swim.\n\nThere are some truly amazing people out there that can turn around bad projects and work miracles through both sheer technical skill *and* soft skills, but most of us are lucky to ever have ever worked with someone like that in our careers because, similar to income inequality, companies are increasingly divided among ultra-privileged easy money street with few problems besides .01%-er style problems.... or struggling companies where every dollar of budget and revenue sharing is fought for mercilessly.", "id": "d19ew1v"}, {"comment": "Well put. Also: They often say \"I know, I know, I should quit just eating junk food, but I just dont seem to be able to force myself\"", "id": "d19a7wu"}, {"comment": "So true... This, so much this.", "id": "d1a411l"}, {"comment": "So then, we might say that people are \"fetishizing\" agile \"in place of the practice of actually being agile\"... What the OP said? ", "id": "d19h0cu"}, {"comment": "[deleted]", "id": "d19kfac"}, {"comment": "Since when is the word \"fetishizing\" a word only children/Tumblrites use? In this situation it's completely apt. ", "id": "d19qc7t"}, {"comment": "A fetish is a sexual penchant bordering on the obsessive. This term has almost nothing to do with the situation at hand.\n\nThis is the kind of word choice that emphasizes ridicule and contempt over sober reflection and careful analysis. This is exactly what turns a potentially insightful debate on the merits and weaknesses of certain methodologies into a futile exchange of insults and expressions of frustration.", "id": "d1a8vpc"}, {"comment": "Something doesn't have to be sexual to be a fetish. In this context it obviously isn't implying an obsessive sexual penchant, it's just used to imply mindless worship.", "id": "d1a8xzu"}, {"comment": "classic, blame everything on management...", "id": "d1932oo"}, {"comment": "They have the power, they get the blame.  That's how the world works.", "id": "d1951q5"}, {"comment": "yea, right.. and in real world it's usually a bit different... I guess they never ask, what programmers need, and they do not allow to design code or programmer, they just sit whole day there and look over devs shoulders..\nYes, they can make life harder, but half of problem with software come from developers, especially when they thinking, that managers will solve everything (including coding).", "id": "d196jig"}, {"comment": "[deleted]", "id": "d190vbt"}, {"comment": "Actually I'm with the manager on that one.\n\nMaybe the job of a \"scrum master\" isn't to protect the folks on the project from requests by folks who have no skin in the game of that particular project, but it is absolutely the responsibility of a manager to do so.\n\nI don't even know what part of that meandering explanation was supposed to be agile.  The fact that you felt it was reasonable to walk up to people and start asking them to take time away from the things they were currently doing for something you wanted done without speaking to the ones who actually *are* responsible for \"herding the cats\"?\n\nI don't know, but in the future, keep the \"scrum master\" in the loop.\n\nI find their response was completely reasonable.", "id": "d1988vr"}, {"comment": "The whole point of scrum is to make sure people can't just walk in and assign random tasks to developers who already have an agreed to set of things to do in a specified timeframe.  It's not necessarily a requirement of Agile, but Scrum definitely spells that out--you don't add arbitrary shit to sprints after the planning meeting(s).", "id": "d19b9kr"}, {"comment": "[deleted]", "id": "d199j1m"}, {"comment": "I think you had/have strong opinions about how that software culture was being run and it's colored everything about it.\n\nI still stand by what I said, titles or no, processes or no, it was completely reasonable for whoever is responsible for organizing the work to ask you to inform them in the future before trying to get to get developers on that project to  spend 1/5 of their time on something else.", "id": "d19f3fn"}, {"comment": "With your recruiting task: were you the \"customer\"? Did you go through planning meeting before the scrum? \n\nIf not, you had no business asking anything and the whole team should have blown you off regardless of the green light from the upper management.\n\nIf yes, it is both your and team fault for not prioritising as you expected.", "id": "d1aadew"}, {"comment": "So you were trying to shortcut the team structure and just take people out to work for you regardless of their existing commitments?\n\nAnd you're surprised they would want you to do it via their organisational process?\n\nThis seems like Scrum working perfectly, preventing arbitrary outside interference. If you want team-members for your own project you have to go to the *team as a whole* and ask for their time, not individuals. Otherwise the team could suffer as they have no chance to say no.", "id": "d1abh7v"}, {"comment": "In a lot of companies/corporations I've worked at, companies use the term \"agile\" as a way to mean \"minimal project management\". ", "id": "d195erk"}, {"comment": "In pretty much every case I've seen it fail, it's been for one or both of these reasons:\n\n* The team didn't spend enough time with a \"by the book\" Scrum/Agile implementation. Before they even start, they sit down and say, \"Well these facets won't work for us,\" and they monkey around with parts before even really trying. \n* Upper Management or \"the business\" isn't on board with the methodology. You have your sprints, backlog, etc, but then the business has the power to come in and say, \"Yeah that's great and all, but we need this new thing prioritized and delivered in a month, AND we still need what else was backlogged.\" ", "id": "d1962cg"}, {"comment": ">  The author is wrong about Agile in virtually every regard. But he does make one good point. [...] That point is:\n\n> \"Bring in the bare minimum amount of process.\"\n\n>Yes! Of course!\n\n> Does every software team need the entire suite of agile practices? Of course not.\n\n-- Uncle Bob.\n\nEdit : That's from the linked response in the OP.", "id": "d1992ez"}, {"comment": "Curious, where are you citing from? I'd love to read that article. \n\nI hope I don't come off like I'm advocating cargo cult adherence to methodology at all. In fact, I can't disagree with anything that OP's article says, because I've seen most things he's said in practice. \n\nScrum is absolutely a process, a specific Agile methodology. It's one that *can* produce viable software, but so often gets bastardized by \"Scrum-butts\":\n\n> Well, we do Scrum, but we... (do thing that isn't Scrum at all) \n\nIt often turns out that \"but\" is usually a change that takes you BACK to adding unnecessary process, or values process over people, or it's an excuse for my second point, where management doesn't accept it's role as a \"chicken\" in the scheme of things, and therefore feels entitled to dictate *how* the software is made. \n\nAnd of course, when \"going Agile\" fails, everyone wants to go back to saying that it's an *Agile* problem, rather than objectively looking at the markedly *un*-Agile things that they threw in which were likely the real disruptions. ", "id": "d19dsnm"}, {"comment": "> Upper Management or \"the business\" isn't on board with the methodology. You have your sprints, backlog, etc, but then the business has the power to come in and say, \"Yeah that's great and all, but we need this new thing prioritized and delivered in a month, AND we still need what else was backlogged.\"\n\nTHIS, SO MUCH THIS!", "id": "d19i9ls"}, {"comment": "> but we need this new thing prioritized and delivered in a month\n\nisn't that exact reason why Agile should success and all other methods should fail? Every consultant (including software developers) that agitates company to start using Agile, is this exact reason - \"waterfall\" will fail, because it cannot adopt to constant changes, therefore we need to use Agile (Scrum) because than we can change our development to fulfill this constant changing need.", "id": "d1ac8yn"}, {"comment": "Not exactly.\n\nThe difference between Agile and Waterfall regarding change is that Agile allows the opportunity to introduce change at regular, more frequent intervals, not just introducing it willy-nilly. \n\nBasically, you agree to deliver no less than X amount of functionality during this sprint. Then, before the next sprint rolls around, the business has the opportunity to determine what the new priorities are. \n\nWhat it *doesn't* allow for is the business to shunt that process and add or change priorities mid-sprint. However, that happens *so* often in many shops, and then the business expects you to deliver 4 items of functionality when you originally only agreed to 2. Then when you don't deliver *any* functionality because you didn't have time to complete anything, they want to indict Agile rather than see how subverting the agreed upon process caused the problem. ", "id": "d1afpac"}, {"comment": "and who told that spring must be 2 weeks? If I remember correctly, 2 weeks is just some default suggested number, you choose how long your spring should be. If it's better to have 1 week, you have one week, if it's 4 weeks, than it's 4.\nBtw waterfall does allow you to do changes, if you follow it correctly.\n", "id": "d1amxe7"}, {"comment": "You're totally correct, which is why earlier I said what I did about cargo cult implementations being an issue with Scrum, just like any development methodology. \n\nI'm not necessarily saying that Waterfall is *bad*, mind you, just like Scrum/Agile isn't the answer for everything. But, what is bad is when people adopt methodologies and either half-ass it, or totally don't get the point of what benefit the methodology is supposed to bring. ", "id": "d1aq70w"}, {"comment": "Incompetent team members (including management).\n\nAs pointed out in mythical man month: if you have a team that is reasonably competent (that is, can hit their own estimates, they don't need to be micromanaged), then any development methodology will work. ", "id": "d19covx"}, {"comment": "To put it another way, if you have a team that is reasonably competent, they will ignore whatever process you throw their way and get on with their jobs.", "id": "d19v3jt"}, {"comment": "Because agile is hard, it takes buy-in from the whole organisation, and someone leading it who knows what they are doing.\n\nScrum is even more disruptive as it will illuminate wasteful management structures, and poor sales and contracting processes. It also implements a very flat structure without job titles, and argues to eliminate middle management and anything which doesn't help to deliver a product. \n\nAdopted on a long-term basis it can also create an environment where salaries will seek to be equalized across the team.\n\nSurprisingly, a lot of businesses feel either threatened by this, they see the change as being too hard, or they simply just don't want to do it.", "id": "d19ozw7"}, {"comment": "> the only people I can see fetishising are people who make money from agile\n\nHow many companies have you worked at that have fully embraced agile then? Sounds like none to me.\n\nI'll add my anecdotal evidence to your anecdotal evidence. My company dove head first into agile like 2 years ago. Now everything is about agile. I don't know that I'd go as far as \"fetishization,\" but I often times find we're focusing way too much on how to be agile, vs actually getting work done.\n\nSo I wouldn't say it's too far off.", "id": "d19gmfz"}, {"comment": "My company just did a round of hiring. I'd say 50% of CVs that came in said \"Certified Scrum Master\". That's the fetishisation the author is talking about.", "id": "d19uxx1"}, {"comment": "Well that sounds awful.", "id": "d19vgzp"}, {"comment": "Actually, I think you need to link either a Twitter, Facebook, or Google account. Or, you need an email address.", "id": "d19qrt3"}, {"comment": "Because some people have yet to realize that:\n\n* If you have a good team, the methodology doesn't matter. \n\n* If you don't have a good team, the methodology doesn't matter.", "id": "d198ont"}, {"comment": "What's the methodology for creating a good team out of an ungood team?", "id": "d19d4qq"}, {"comment": "Creating a good team is fairly straightforward.... Just often politically untenable. Humans are amazing at learning. Focus on building your people up.\n\nGive me a year with an average developer who is interested in getting better and I can turn them into a great developer.\n\nOf course no company wants to spent 30-40% on L&D..... most companies don't want to spent 10% time on L&D...", "id": "d19mgiw"}, {"comment": "> who is interested in getting better\n\nThis is the problem. Lots of people are content where they are right now. The problem is improving people who themselves are not interested in improving themselves.", "id": "d1a82z4"}, {"comment": "Ah, now that is the question.", "id": "d19i7s1"}, {"comment": ">We value ..\n>Individuals and interactions, over processes and tools.\n\n-- Agile Manifesto", "id": "d1a7rei"}, {"comment": "Weird that they have all these processes.", "id": "d1bsa7m"}, {"comment": "I think many programmers tend to view management/managers as superfluous things that get in their way. At the risk of sounding like I'm putting up a straw man to know, I get the sense that a lot of people on /r/programming feel that to the extent that management should exist at all it is an obviously easy task that anyone with half a brain should be able to do. If someone is not a very good manager then it must be because they are either an idiot, a jackass, or both. \n\nThe problem with all these methodological arguments that I see play out on /r/programming is that no one seems willing to admit that core fact that being a manager and specifically being a manager of software engineers *is really hard.* I think a big one of the reasons why people fail to recognize this fact is that it is pretty easy to spot a bad manager, but can be hard to spot a good one. If you do too much, people get dependent on you. And if you do nothing, they lose hope. Doing task estimates, performance reviews, communicating with other teams, and enforcing deadlines are all tasks that programmers balk at, but they need to be done. Managers have to really know and have a mutual respect with their team to make sure these things get done right.\n\nAs a manager need to make sure deadlines are stringent enough to launch products and push your engineers, but reasonable enough that they don't feel overwhelmed. You want to make sure that people on your team have a chance to grow in their career (otherwise they will leave), but make sure get the quotidian maintenance tasks done. You have to foster a friendly working environment for everyone on the team. Not that everyone need be best friends, just able to work together and feel comfortable (at Google I've heard it referred to as psychological safety). You have to make sure that engineers on your team can work with people on other teams, while still shielding them from the politics that are (to at least some degree) inevitable in any organization of more than (let's say) 10 people.\n\nYou have to do all this while making sure that none of it gets in the way of your teams work. You have to use a light touch, like a safecracker or a pickpocket. And when you do things right, people won't be sure you've done anything at all.\n\nSo maybe there are processes that can make all of that easier, but no process is going to fix having a bad manager. If a manager doesn't care about their team, or doesn't trust them, or doesn't know how to assess their abilities, then no process, manifesto, or medium post is going to change that.", "id": "d198lgo"}, {"comment": ">  If someone is not a very good manager then it must be because they are either an idiot, a jackass, or both.\n\nThey end up being managers *because* they are idiots, jackasses, or both. If they were worth something they would be put to do some real work.", "id": "d19bv9e"}, {"comment": "Can confirm.\n\nI left programming to become a manager who wasn't an idiot. Now I still sit and code with my team if there's a pernicious problem and we need more eyes on the problem.", "id": "d19glth"}, {"comment": "You good manager. Damn good manager. Leaders lead from the front!!!!", "id": "d19ntaf"}, {"comment": "Thanks! I love that I understand what my team is doing well enough to help them fix it, but also that I can spend many days looking ahead. It's more like what I think \"architects\" are supposed to do.\n\nAlso, we charge recurring meetings to the manager who calls them. So we don't have those. It's a joy that the average meetings per week is right at 60 minutes.", "id": "d19sdtg"}, {"comment": "That's brilliant! What's your tech stack? Any chance you're hiring?", "id": "d19ttso"}, {"comment": "I have had basically 3 good managers ever. I worked at a company with constant reorganisations as it grew from 15 to 150 employees, I had a lot of different managers. The good managers are easily identifiable as the ones *who are not bad managers*. If your manager feels like the cause of your problems then they are not good. If talking to your manager is something you don't dread, you have a good manager.", "id": "d19v9c2"}, {"comment": "Are you a manager? Because if yes, you are a bad one, and I say that because in your wall of text, actually organising work is this measly passage:\n\n>As a manager need to make sure deadlines are stringent enough to launch products and push your engineers, but reasonable enough that they don't feel overwhelmed.\n\nI would rather that you spoke of understanding the work, knowing who can do what and how much time they need, adjusting plans/resource allocation when people are stuck/slower than expected, planning when to push people to do stuff they can't do well, using past evidence to plan the future work, stuff like that.", "id": "d1a6ggc"}, {"comment": "> If someone is not a very good manager then it must be because they are either an idiot, a jackass, or both. \n\nThis type of manager is common, and they are easy to recognize even without talking to them *because they don't program.* A manager who doesn't program will need to fill up his time (or waste his programmers time) with busy work, because managing a team of 10-20 people just doesn't take much time if you do it right.\n", "id": "d19czqt"}, {"comment": "this gives me an idea for a medium post: Agile Fatigue", "id": "d190xc7"}, {"comment": "\"Agile Fatigue Considered Harmful for Humans\"", "id": "d19dlaz"}, {"comment": "Half of the things I see posted on /r/programming are just bloggers arguing with each other and past each other. ", "id": "d1994kv"}, {"comment": "> Half of the things I see posted on the Internet are just people arguing with each other and past each other\n\nFTFY", "id": "d19pcv5"}, {"comment": "Relevant xkcd https://xkcd.com/386/", "id": "d1ali0i"}, {"comment": "Because some methodologies are bad even if done well.", "id": "d196ek8"}, {"comment": "it's really hard to write new and insightful things", "id": "d19822p"}, {"comment": "It's still seen as a Silver Bullet by some. And I've been in a situation where it was performed as a cargo cult ritual, and failed.  The programmers were blamed for not delivering, because \"agile\" had been adopted and the staff were obviously not capable if they couldn't perform under \"agile\" conditions.  \n\n", "id": "d193vse"}, {"comment": "That's not an easy topic I can shit out an article about that I can then point to during interviews and seem insightful by people that probably don't know any better?", "id": "d198p6f"}, {"comment": "Because in practice there's a ton of methodology being done badly. The highly correlated wisdom is that the people perpetrating it probably don't realize that they are, and some of those people will be in this thread calling this article stupid.\n\nJust because it's obvious doesn't mean it isn't worth saying, because often it's not the insightfulness that's the problem, it's doing it at all. Like flossing, or exercising. Everybody knows they should, but whether they do is a different story.", "id": "d19jno6"}, {"comment": "Sure, but how many times does the same thing need to be said? Or posted in this sub?", "id": "d19q042"}, {"comment": "I don't think it's a matter of need. This subreddit has over 600k subscribers, so some repetition on an important matter that applies to our jobs is probably a good thing. \n\nIt gets the point across, and seeing repeats about a consistent thorn in everyone's side honestly isn't that irritating unless you want to make a big deal of it.", "id": "d19qg4z"}, {"comment": "That's fair enough, to some extent, but I have seen a steady stream of these articles saying basically the same thing very regularly for a long time. It just seems more like a religious war at this point.\n\nWhy don't we see this many articles discussing positive aspects of methodoligies upvoted? Aren't they immensely more useful?", "id": "d19ufmi"}, {"comment": "Hard for me to say, but my guess is that the positive aspects don't need more advertising because most of us are already drowning in it.\n\nI would love to see more on how to do agile right, meaning agile philosophy and how to implement truly minimal process for specific teams rather than cookie cutter methodology. ", "id": "d19wk9s"}, {"comment": "I agree, most of the Agile hate seems to be people who have had terrible experiences with either consultants, management or both, and have therefore written off the entire concept. It works great for my team.", "id": "d19xrmp"}, {"comment": "And it's self perpetuating. Agile has been around for years, the article which inspired scrum was written in 1986, yet recently we've gotten a snowball like effect of people who see a post on the topic getting some traffic and that leads to more \"expert opinion\".\n\nNo one is forcing you to use agile, scrum, or any of it's implementations. They are simply tools, and aren't suited to every team and situation.\n\n", "id": "d19op0n"}, {"comment": "> Any methodology is bad if it is done badly\n\nYou have missed the point.  Scrum is deeply flawed, because it substitutes a bunch of counter productive cargo cult processes in place of genuine agile minimalism.", "id": "d1991uj"}, {"comment": "Do you mean \"capital A Agile\" Scrum? ", "id": "d19kvca"}, {"comment": ">Scrum is deeply flawed, because it substitutes a bunch of counter productive cargo cult processes in place of genuine agile minimalism.\n\nWhat do you recommend as the alternative?", "id": "d19d1hz"}, {"comment": "In my shop we adopted statistical quality management as the mental framework for interpreting agile development. When we build a feature, it goes like this:\n\n1. We build a test jig to record and measure the effect.\n1. Get the test running on a prototype of the feature.\n1. Design review the prototype and the test based on the results.\n1. Build a better test jig and begin to record results and the variance of performance.\n1. Build a new prototype\n1. Estimate the system consistency and performance relative to expectations or desires.\n1. Enter a cycle of making variance reducing and then performance enhancing improvements.\n1. After each iteration, estimate and communicate the expected release date of the feature. This is easy to do based on the variance and performance data.\n\nIt takes about the same amount of time as a waterfall project but the results are usually within about 5% of ideal performance and consistency.\n\nIf you notice, there are three distinct phases above. We call them \"do it wrong, do it right, do it well\". In the wrong phase we're just going through the motions to be sure that we understand the problem. In the right phase we're trying to get the test right and the system design roughly correct. Then the well phase is just all downhill.\n\nIt feels frustrating at times because we want to declare victory after \"right\". That's roughly when waterfall projects would have had their estimated completion date. Instead of entering a prolonged \"almost done\" phase our projects are primed for real development and component redesign at that stage.\n\n\nedit: FWIW, whenever we decide to run the test in parallel to increase testing bandwidth then we define the test jig itself as a product and build test-the-test jigs using the same pattern above. That way we can be sure that the other testing devices are equivalent and our engineers can rely on all results being interchangeable. It's a cost of doing business faster, but it's a cost that we can measure and predict so it's not all that bad.", "id": "d19ga5d"}, {"comment": "You can still follow the spirit of agile.  Write code that does something useful.  Expand functionality.  Refactor whenever needed.  Avoid all the scrum collection of BS cargo cult practices.", "id": "d19g612"}, {"comment": "I haven't missed the point at all, doing Scrum badly _is_ adhering to \"cargo cult\" processes if they are counter-productive. The team I'm on uses Scrum and it works great for us, we don't do standups because we don't find them necessary but most of the other processes work fine. Our GM is a programmer and understands software development and we keep planning lightweight and agile.\n\nDoing any methodology well is about adapting it to your needs. Just because a bunch of people fail miserably to do that with Scrum doesn't mean it is inherently counter-productive.", "id": "d19qe3x"}, {"comment": "> doing Scrum badly is adhering to \"cargo cult\" processes if they are counter-productive.\n\nWhat if ALL of scrums processes are counter-productive for you?  Then fixing all of them means you stop doing scrum.  The 'retrospective' meetings are only useful if the team has the power to use that meeting to decide to ditch scrum altogether.", "id": "d19ul5y"}, {"comment": "You talk like a crazy person.", "id": "d19vua9"}, {"comment": "You sound like a total dumbass.", "id": "d1a22l7"}, {"comment": "Touche.", "id": "d1a4igb"}, {"comment": "You complain about scrum.  What you are complaining about is actually \"scrumbut\".\n\n* \"We do scrum but we don't automate testing.\"\n* \"We do scrum but we don't do pair.\"\n* \"We do scrum but we don't use consistent tools.\"\n* \"We do scrum but we don't do planning.\"\n* \"We do scrum but we don't bother refactoring.\"\n\nThis kind of list can go on forever.  Don't blame scrum for a teams inability to use it's tools.", "id": "d19ryc1"}, {"comment": "No, I am complaining about Scrum.   It is a deeply flawed collection of crap cargo cult practices.  And having more rather than fewer cargo cult practices does not help in any way.\n\nAnd half of the people (like you) are defending scrum by saying you are not following all the processes.  The other half are defending scrum by saying you aren't flexible enough to adapt scrum your situation.  LOL", "id": "d19ug0h"}, {"comment": "Ending statements in \"LOL\" really enhances the credibility of your opinion. Kudos.", "id": "d1bhxlj"}, {"comment": "Last I know, scrum doesn't ask for any of the points except the 4th.", "id": "d1a5zx4"}], [{"comment": "TL;DR: buzzwords are dumb and we need to adapt our process depending on needs yada yada", "id": "d196qzo"}, {"comment": "Sounds like what Agile is about, to be honest.", "id": "d19l6k1"}], [{"comment": "The problem is that you're not doing waterfall correctly.\n\nI mean agile.\n\nI mean scrum.\n\nI mean...", "id": "d195rde"}, {"comment": "Cue agile consultant", "id": "d19hsyj"}, {"comment": "Flym?  \nTrumboo?  \nOdrymn?  \nEarlpong?  \n... you've probably never heard of it ... f@%ing  waterfall relict.  \n", "id": "d19j2k8"}], [{"comment": "Uncle Bob is allowed to bash agile but you aren't. Um. So there.", "id": "d190m26"}, {"comment": "Uncle Bob bashes agile?", "id": "d191nwl"}, {"comment": "Oh you missed it?   Uncle Bob has several serious reservations about the Agile Industry (reservations I think are very well founded) and also thinks that Scrum is rubbish.  I believe all this stuff is highly viewed stuff on YouTube.  I think I might love \"Agile the movement\" if it hadn't been co-opted by non-technical marketing heads who were trying to figure out how to sell stuff by tagging it Agile, and if a bunch of idiots hadn't cargo-culted the living shit out of it.", "id": "d19ipmc"}, {"comment": "Bashing scrum doesn't mean he bashes agile. Agile is much bigger than just scrum.", "id": "d19km2i"}, {"comment": "I feel like no one on /r/programming understands this", "id": "d19t1ez"}, {"comment": "Uncle Bob is actually one of The Bunch of White Guys who wrote the series of vague aphorisms known as the Agile Manifesto. Bob got mad at this article's author the last time he complained about agile, link's in the article.", "id": "d1935g6"}, {"comment": "Also, what has people's skin pigmentation got to do with anything?", "id": "d196h8y"}, {"comment": "I know that.\n\nAlso, why do you think Agile Manifesto is vague?", "id": "d19381i"}], [{"comment": "I did an Agile project for a large bank.  It was their first after being waterfall for ages.  The executive that sponsored the project insisted on Agile (huge red flag).  Fast forward 6 months and when the product being delivered without ALL of the requirements (due to the inevitable scope creep, new requirements, incomplete requirements, technical difficulties, etc), the same executive that decided that the project MUST be Agile decided that he didn't like Agile because at the end of the project he didn't get everything that he wanted when he wanted it.  He then pulled the plug and changed the methodology on-the-fly and forced the project to be waterfall.  I left at that point.\n\n\nMassive clusterfuck.", "id": "d199bxo"}, {"comment": "The problem with Agile was that it was oversold by consultants.  It was the miracle cure that would improve your IT organization overnight.\n\nPersonally, I think DevOps is the newest thing being oversold by consultants.", "id": "d19cdw4"}, {"comment": "Haha! Yes! We just had a meeting where top management basically said we need to be 'devops'. ", "id": "d19q9jf"}, {"comment": "Also, Agile is simply not the best fit for some industries for a variety of reasons (Banking would be one).\n\nThat industry just does not have the appetite for rapid change or the risks from having a defect out for a few weeks.", "id": "d19e9l4"}, {"comment": "I wonder if he fed the scope creep and requirements through the Agile system. \"Oh. That will take x amount of time...\"", "id": "d19j6qk"}, {"comment": "Enterprise?", "id": "d1a10qi"}], [{"comment": "I have to say, my [large] organization adopted agile all the way to the CEO level starting about three years ago and things have *definitely* improved.  ", "id": "d197zo1"}, {"comment": "Most likely you had no real process before that, just an ad-hoc mess ", "id": "d19d2el"}, {"comment": "Well...fuck you too. \n  \nI mean I know it's cool to hate everything, and sure, no place is perfect but this comment is just pure a-hole snobbishness.", "id": "d19kx39"}, {"comment": "I'm with you.  I've seen agile work way more often than not.  It's only organizations that cannot fight their way out of a wet paper bag that seem incapable of being successful with it.", "id": "d19r8wh"}, {"comment": "And yet, it must be a true commentary on your situation, otherwise you would have explained that you had real processes before.\n\nInstead you just started swearing. Great. \"If you throw a rock into a pack of dogs, the one the yelps loudest is the one that was hit.\" \n\nFYI there's nothing wrong with \"had lousy processes before.\" No need to get defensive. ", "id": "d19vkgx"}, {"comment": "Did we see improvements with Agile? Yes. Were our previous processes at bit \"waterfall\"? Sure, but mostly at the \"business case\"  level, not really at the code level.  It's a huge boon when you can convince your business to embrace Agile thinking at the financial end of things. That's arguably where we saw the biggest wins. And that was largely driven bottom-up which is why I perhaps get annoyed at a comment like \"You must have just sucked before\".", "id": "d19xhop"}, {"comment": "I see, so you had agile-style processes already at the developer level, but at the higher levels of planning, they were making a mess of things. ", "id": "d1a1yz6"}, {"comment": ">ad-hoc mess\n\na perfect description of where I am now...\n\nEDIT:formatting ", "id": "d19dro6"}], [{"comment": "God, medium.com is awful. ", "id": "d196rbg"}, {"comment": "And no matter how many shills they pay to downvote comments like this, they will always suck.", "id": "d19cii1"}], [{"comment": "The engineering science of software development is not yet perfected\n\nIt's more of an art form, or in some cases, a train wreck\n\nLots of smart people invent ideas to make it better, some of these ideas help a bit, when they fit", "id": "d19915h"}, {"comment": "In the case of agile we are not talking about engineering problems but people management problems. It is specifically about organizing disparate groups of people so that the right software gets built instead of worthless, well-engineered software.", "id": "d19ljrk"}], [{"comment": "\"Agile isn't Waterfall\" - this is false for two reasons:\n\n* the original waterfall paper actually speaks about major traits of agile: customer feedback, iterations, \"throwaways\", testing, whatnot; if you do not believe me, find the original waterfall paper by Royce and read it carefully, past the third page (it is less than 10 IIRC)\n\n* just like **total and utter** ***idiots*** of yore completely misinterpreted Waterfall, idiots of today completely misinterpret Agile today\n\nHistory soooo repeat itself, it is uncanny!", "id": "d19hqxr"}, {"comment": "If you know exactly what you want, you shouldn't be agile.  The iterative nature of it is geared more towards addressing the concerns of people who don't really know what they want other than that they know they want you to start right now.  \n\nNothing wrong with \"agile\" or \"waterfall\", neither are inherently good and neither are inherently bad.  Let the nature of your project pick your dev process, but if all you have is an agile then everything looks like a scrum. ", "id": "d19o29y"}, {"comment": "The Winston Royce paper did not introduce waterfall to the world, nor did it tout waterfall as a methodology. In the first two pages, the paper describes the common everyday model of software production at the time, which had been identified 14 years earlier. The remaining 8 pages of the paper explores problems with the waterfall model and proposes solutions. Some  of the paper's solutions are the same kind seen in Agile today, as you observed.  \n\nI recommend reading [Why Waterfall was a big misunderstanding from the beginning \u2013 reading the original paper](https://pragtob.wordpress.com/2012/03/02/why-waterfall-was-a-big-misunderstanding-from-the-beginning-reading-the-original-paper/)", "id": "d1ag58f"}], [{"comment": "I'm a victim of manager change... got an old school operations manager from the 90s come in as a project manager for a dev project. He doesn't know anything about programming. He even hired a business guy from another department who was laid off. Hired him as a \"developer\" because his resume said so. He was bewildered by the other dev teams didn't hire him even though he had a \"steller\" * cough * fake * cough * resume. We've been planning, testing, planning testing for a yuuuuuge migration project which contains a bunch of systems since April 2015! aka WATER FALL! there's no water... just FALL. Daily half an hour calls... I spend 3 hours a day on meetings. No crap released yet. Ahhhhhh! I feel like quitting. I'm pretty sure things will blow up on the release day because these guys don't understand that systems are connected. I'm pretty sure the top management guys are going to cull this group once they see how much money is wasted. \n\nYou never know how good you've had it until you lose it. ", "id": "d1951um"}, {"comment": ">  I'm pretty sure the top management guys are going to cull this group once they see how much money is wasted. \n\n9001. Either that, or somehow he convinces management that it wasn't him. After all, he was a superstar with a stellar resume! \n9001. The other option is that \"we need more developers!\" So, you hire a bunch of contractors. However, someone from that consultancy gets a cut from placing other contractors. So, they do marginally better, therefore we must hire more... from that agency!", "id": "d19j4pe"}], [{"comment": "[deleted]", "id": "d197hov"}, {"comment": "If we could just get it through people's heads: the process is perfect. *They're* the problem. Maybe we should get rid of them.", "id": "d199v6u"}, {"comment": "I wouldn't say that the process is *perfect* per se, but often I see people just half-assing things. \n\nNo process would improve unless those people want to improve themselves. \"Everything isn't running well! Let's add some methodology to try to fix it!\" Honestly, I think the people that run overeall well with Agile will run overall well with many different processes", "id": "d19j8m6"}], [{"comment": "It's funny seeing all these articles appear. Im like \"fuck people at work don't even think a build server is worth the effort\".\n\nTheory vs reality right there :S", "id": "d198tm3"}], [{"comment": "> You don\u2019t say \u201cwe have 3 bags of concrete and 2 hours\u201d then get a civil engineer to do the design.  You get the civil engineer to do analyze the issue, and that informs how much time and how many materials you need.\n\nI think this analogy is dangerous.  This sort of thinking is _why_ we have so many broken implementations of an \"agile\" process.  This is how uninformed MBA's _think_ software development works (because they're taught that in MBA school).  I get what the author is going for here, but besides preaching to the choir, analogies like this one just reinforce a broken faith on software estimates... which, if were reasonable, would imply that waterfall is the perfect methodology for software development.  Software is inherently inestimable (outside of an order of magnitude or so).  Bridges can be estimated to decent precision, in a reasonable amount of time, because so many have been built.  Every useful software project is inherently brand new: if it wasn't brand new, then by definition it's already been written, so why are you writing it again?  You can compare it to something vaguely similar, but that's only going to help you to the extent of the similarity.  On the other hand, budgets are real, too -- when you're out of money, you're out of money.  The agile manifesto was supposed to reconcile the reality of inherently immovable budgets with the reality of inherently inestimable work, but appears to have completely failed in that regard.", "id": "d19gkh2"}], [{"comment": "I actually talked about agile at my last job interview ( I really like agile, but I see its flaws) they like waterfall. \n\nEnd of discussion was that we really will try combine it. The big question is? How -_- Anyone ever did that?", "id": "d19ecti"}, {"comment": "It's easy; find a big waterfall, jump off, and use your agility to land at the bottom unharmed.\n\n(don't do this).", "id": "d19es8h"}, {"comment": "I think this is totally possible, but it will not be an entirely additive process.  The middle path will necessarily mean each side giving up some aspect(s) of the fundamentalist interpretation of their process.\n\nI won't proscribe how it should work.  But I don't think this is as oil and watery as some may think. ", "id": "d19h9wl"}, {"comment": "All of the freaking time. It's called \"Agile with Waterfall\", and most non-technology companies operate like it. Usually the business side runs waterfall, and the technology side runs agile. However, the agile process gets circumvented by the business side throwing new requirements in", "id": "d19jb7f"}], [{"comment": "Theoretically agile development can probably be effective, but I have yet to work at a place that actually embraces agile development. Every place I've worked at has implemented its own ad-hoc \"agile development methodology\" that basically just takes the things it likes about agile and gets rid of the things it finds annoying. Namely, most places I've seen tend to embrace two parts of agile development:\n\n1. A multi-phase ticketing system like Jira that lets gives you fine-grained control over every aspect of categorization and lets you divide tickets into springs and epochs, even though no one really organizes those properly; and lets you assign story points, even though no one bothers to assign story points, either.\n2. Daily or nearly-daily meetings in which the direction of development is changed on a whim because we're \"agile\".\n\nTo state the obvious: Yes, I know there's nothing agile about that. Yes, I know you can't just implement a couple parts of agile and still have agile. Yes, I have brought this up to people. No, no one who is paid more than me has ever cared.\n\nI once worked on an \"agile\" team of 5 people in which our morning standup/scrum/whatever stretched to *forty-five minutes*. When I pointed out that the standups were getting long and suggested we actually stand up for them, someone protested\u2014I shit you not\u2014that she didn't like standing up because \"it was tiring\".\n\nI worked in one place that actually assigned story points. I thought it was bullshit at first, but lo and behold, after about 4-6 weeks, we actually started getting really good at estimating task length using story points! Holy shit! Oh, except the CEO (this was a small 6-person startup) caught wind of what we were doing, and got it in his head that 1 story point == 4 hours of work (no one could explain to him the abstract concept of story points), and would say things like, \"Oh, a 3-point task? You really think that's going to take 12 hours?\" or \"Oh, you only have 8 story points assigned to you this week? Shouldn't you have at least 10?\" and the momentum we had quickly got torpedoed.\n\nSo yeah, agile probably works if you do it right, but no one does it right and management never really tries to learn what it's all about anyway.\n\nBut really, who the fuck cares? Is the world really going to collapse because you didn't complete your new dating app or yet another food delivery service, anyway?\n\nAm I jaded? You bet! You work over 10 years in the field, you'll be pretty fucking jaded, too. Go into finance, kids; at least you'll have a pretty nice nest egg saved up after a decade.", "id": "d19sub7"}], [{"comment": "Agile promotes mediocrity by focusing so much on estimation and predictions. Can Anyone disagree with that at least?", "id": "d19unil"}, {"comment": "Can you expand on what you mean? How would 'focusing on estimation' promote mediocrity? Estimates are only a problem until you figure out how to get them right, then they're just a thing. ", "id": "d19vx7g"}, {"comment": "I completely disagree if estimates were not a thing 40% of software projects wouldn't fail.  Estimating is extremely difficult. There's plenty of interesting readings on randomness and predictions But to focus on Scrum the problem is it rewards estimating alot of things or shipping alot of code. What this forces people to do is create mediocre code in the name of having completed the estimate.", "id": "d1bb8lo"}, {"comment": ">I completely disagree if estimates were not a thing 40% of software projects wouldn't fail. Estimating is extremely difficult.\n\nNah, once you have experience, you can hit your estimates almost every time. >40% of projects fail because management is not willing to accept the estimate given, or something similar. \"You need to cut that estimate in half!\"\n\n>But to focus on Scrum the problem is it rewards estimating alot of things or shipping alot of code. What this forces people to do is create mediocre code in the name of having completed the estimate.\n\nWell, I don't like Scrum, but I still don't see what you're getting at here. How does Scrum reward estimating a lot of things? ", "id": "d1bgrni"}]]], "5442h6": ["Why I don't unit test?", "2016-09-23 14:32:33", 0, "https://codecleane.rs/2016/09/23/why-i-dont-unit-test/", [[12, "My experience: a language with an advanced type system (e.g. Scala/F#/Haskell/...) can catch so many errors that you only need unit tests for the parts that can't be (reasonably) modeled in the typesystem and contain complex business logics. In comparison to languages like Java or Python, this is rather 3% or so."], [9, "Unit testing has a very clear downside: it slows down development.\n\nThis is acceptable if you're working on mission-critical systems, like medical or security devices, but not when you're working with tight deadlines.\n\nThe second problem is that it's very hard to integrate unit testing in an existing codebase. Code has tangled up dependencies that makes it very hard to test in isolation. And then, every time you fix the API, you have to rework your unit and integration tests.\n\nMy library [utf8rewind](https://bitbucket.org/knight666/utf8rewind/overview) was built with unit-testing in mind from the ground up. It has only 16 public functions, but over 3000 unit, integration and performance tests.\n\nIt is probably the safest library for UTF-8 encoded text out there and it took me 18 months to write."], [7, "Whenever I start writing tests, I just have the problem that I do not know when to stop. I really, really don't like the idea of testing only parts of the behaviour, I want to test every possible case, but I don't even necessarily know every possible case, or how to trigger it.\n\nTesting failure cases especially seems very important, but really hard to actually get right."], [6, "There's this one huge thing people seem to overlook when discussing unit tests all the time: the main reason to write unit tests it not to catch errors (this is the realm of integration tests, simulation tests, manual testing, defensive coding, and monitoring); unit tests are first and foremost about writing down assumptions in a formal, verifyable language, and the reason we want to do that is because 1) it helps you think, 2) it documents your assumptions for fellow programmers (including your future self), and 3) it allows an automated tool to formally verify your reasoning. Writing this:\n\n    function test_add() {\n        var expected = 5;\n        var actual = 2 + 3;\n        assertEquals(actual, expected);\n    }\n\n...means \"I assume that 2 + 3 equals 5\". The main purpose of this test is not to make sure addition doesn't break, or that you have implemented the + operator correctly, but to document the behavior that you rely on."], [5, "There is also another reason: the benefit isn't worth for the cost. This of course depends greatly on what you are doing, how you are doing it and who you are working with."], [4, "Other forms of automated software testing can provide a better cost/value ratio.  \n\nAutomated software testing should have been such an easy sell, but the strength of dogma in the people who would rather blog about testing software than actually test software kills it.\n\nEven as someone responsible for a lot of automated testing on our project, I can barely stand to listen to testing advocacy. The advice is way too strict and narrowly applicable, when it's not outright bananastown."], [2, "I generally limit unit testing for some basic low-level algorithms, such as hash functions, encoders/decoders, variable length bitstream stuff, arithmetic operations and other miscellaneous things where type transformations are performed, which could potentially break on different platforms or CPU architectures. I feel that unit testing anything beyond the aforementioned things yields rapidly diminishing returns. "], [2, "Hmmm...\n\nSo I have an old part of code which has its automated test suite, but absolutely not unit tests. There is no way I'll start rewriting this so that it becomes unit-testable.\n\nI also have new part which has unit tests.\n\nBut... the nature of the code is that it is, in most part, a wrapper around the infrastructure. The interaction with the infrastructure, possible detection of changes in its behavior, is a huge part of all that code. I find that unit tests are useless there, we need the real thing, not the mock thereof. And I can't, nor should, get the runtim infra in the build environment.\n\nSo everything still has non-unit-tests.\n\nMy favorite is the false sense of good code coverage from unit tests only, which largely ignores lower layers and the quality of the interaction with them.\n\nYMMV."]], [[{"comment": "My experience: a language with an advanced type system (e.g. Scala/F#/Haskell/...) can catch so many errors that you only need unit tests for the parts that can't be (reasonably) modeled in the typesystem and contain complex business logics. In comparison to languages like Java or Python, this is rather 3% or so.", "id": "d7yq89q"}, {"comment": "I feel that you still need unit tests as a sanity check to verify that your types were properly designed.", "id": "d7yqbyi"}, {"comment": "You still need a sanity check, but those are a better fit for end-to-end integration tests. IME it's still very much possible to make a program that doesn't work at all, but strong types mean you can be a lot more confident that if it works for one case then it will work for all the cases, to the extent that it's not worth bothering with \"classical\" unit tests.", "id": "d7ytgoz"}, {"comment": "This is what the compiler does (or should do) for you. So that you can't put in a number of kilometers into a function that expects a number of miles.", "id": "d7yqfrd"}, {"comment": "I don't understand why there's no ML-driven snapshot generator of inputs in -> assertions out to highlight breaking changes between commits. it seems perfectly reasonable that in addition to code-coverage, the code paths could be \"recorded\" for inputs and expected outputs and that estimators could be derived. A company called functionize is already trying this out to create generated selenium test cases... it seems even more trivial to do this for functional code, perhaps even OOP code. Additionally, by recording running applications, you're ensuring you're covering the most used codepaths, first. ", "id": "d7z62gg"}, {"comment": "I feel you still want tests as a safety net for when people make changes. In fact enforcing the current behaviour is the only thing I like about unit testing.\n\nIt means I can dip into someone else's code and have some confidence that if I change the behaviour then the tests will scream at me.", "id": "d7yv1t2"}, {"comment": "> In fact enforcing the current behaviour is the only thing I like about unit testing.\n\nI think this is only usefull if someone wants to change code without changing behaviour - thus refactoring or performance improvements. And the chance of changing the behaviour via refactoring is greatly reduced with an advanced typesystem. It is still existent, thus some unit tests are really usefull, but the \"unit test everything\"-approach is no longer needed.", "id": "d7yviml"}, {"comment": "> I think this is only usefull if someone wants to change code without changing behaviour - thus refactoring or performance improvements.\n\nIf you want to change some behaviour but only specific bits but several layers up the abstraction tree it's working the same. Also if you are adding behaviour but want the existing code to work the same. Both of those are pretty common scenarios.", "id": "d7ywwed"}, {"comment": "That's true. In these cases you want some parts not to change - but it is also covered by the compiler in most cases. If you'd like, provide me an example and I will try to show you what I mean.", "id": "d7z0ln9"}, {"comment": "I don't disagree that a good type system can help a lot. But the main unit tests I like are ones which are looking at the side effects of the application.\n\nFor example yesterday I had to change code at work in some excel sheet generation. It was using old code to get data out which was inefficient. I replaced it with newer alternatives which reduced work and code size.\n\nWe have unit tests that look at the sheets generated. So I know the changes I made still look ok for the end user. Another example is with GUI testing.\n\nBtw I *do* believe that how you code can be just as important as testing. Like passing is less likely to go wrong than asking for it (like calling a getter).", "id": "d7z1dpn"}, {"comment": "> But the main unit tests I like are ones which are looking at the side effects of the application.\n\nI got you wrong then. These kind of tests are exactly a part of what I meant with 3%.", "id": "d7z926p"}], [{"comment": "Unit testing has a very clear downside: it slows down development.\n\nThis is acceptable if you're working on mission-critical systems, like medical or security devices, but not when you're working with tight deadlines.\n\nThe second problem is that it's very hard to integrate unit testing in an existing codebase. Code has tangled up dependencies that makes it very hard to test in isolation. And then, every time you fix the API, you have to rework your unit and integration tests.\n\nMy library [utf8rewind](https://bitbucket.org/knight666/utf8rewind/overview) was built with unit-testing in mind from the ground up. It has only 16 public functions, but over 3000 unit, integration and performance tests.\n\nIt is probably the safest library for UTF-8 encoded text out there and it took me 18 months to write.", "id": "d7ypk2b"}, {"comment": "> This is acceptable if you're working on mission-critical systems, like medical or security devices, but not when you're working with tight deadlines.\n\nYou gotta spend time to save time. In the long turn you will (when done right) always save time. Less bugfixing time, preventing regressions, etc.\n\n> The second problem is that it's very hard to integrate unit testing in an existing codebase. Code has tangled up dependencies that makes it very hard to test in isolation.\n\nThere are techniques (depending on the language) to untangle these requirements. And every *new* feature can be built without those dependencies.  \n\nI think especially the part about preventing regressions is very important. You can't always manually re-test every single bug you've encounter, no matter how good your QA is. But with automatism you can. You can be most likely assured that a bug that was fixed stays fixed.", "id": "d7yppw8"}, {"comment": "> Unit testing has a very clear downside: it slows down development.\n\nYou get that time back when it comes to adding features in the future, thanks to automatic regression testing.  Not to mention not having to chase all the bugs your tests catch early on (assuming you use TDD).", "id": "d7ypyxo"}, {"comment": "I've found unit tests slow down things at the beginning, but can speed things up later on. Particularly, when as you go along, you refactor or find better ways to organize the code. \n\nI love being able to run the tests and see that green bar, giving me confidence that my changes didn't break the work I did before. Otherwise, I have to spend a lot of time manually testing to make sure I didn't break obvious things. That manual testing really slows things down, and I'd rather save that effort to catch non-obvious hard stuff.\n\n> The second problem is that it's very hard to integrate unit testing in an existing codebase. Code has tangled up \n> dependencies that makes it very hard to test in isolation. \n\nI've found unit testing to be a very good motivation to untangle dependencies so that I can test in isolation.\n\n> And then, every time you fix the API, you have to rework your unit and integration tests.\n\nActually, I've found this to be the best part of unit testing. Some APIs are super finicky. They are really demanding of the code trying to use it, intertwining themselves into the calling code. These APIs are annoying to use, and small changes to the API break the calling code, because of the tight entanglement. Making me less likely to want to upgrade.\n\nUnit testing forces you to use your API early. If little changes cause major breakage, I take that as a sign that I'm writing a bad API. By fixing the API, I have to fix tests less.", "id": "d7yqupm"}, {"comment": "> Unit testing has a very clear downside: it slows down development.\n\nThat hasn't been my experience. I've got to run every function at least once anyways.", "id": "d7zabht"}, {"comment": "> This is acceptable if you're working on mission-critical systems, like medical or security devices\n\nI bet that such systems get less unit tests than random throwaway websites :-)", "id": "d7z0o86"}], [{"comment": "Whenever I start writing tests, I just have the problem that I do not know when to stop. I really, really don't like the idea of testing only parts of the behaviour, I want to test every possible case, but I don't even necessarily know every possible case, or how to trigger it.\n\nTesting failure cases especially seems very important, but really hard to actually get right.", "id": "d7yqqgc"}, {"comment": "My approach is to write a basic suite of tests, test some obvious edge cases and failure cases, and then call it quits.\n\nWhen you get a bug report, write a test that fails for the conditions in the bug report, then make it pass. ", "id": "d7yxu0s"}], [{"comment": "There's this one huge thing people seem to overlook when discussing unit tests all the time: the main reason to write unit tests it not to catch errors (this is the realm of integration tests, simulation tests, manual testing, defensive coding, and monitoring); unit tests are first and foremost about writing down assumptions in a formal, verifyable language, and the reason we want to do that is because 1) it helps you think, 2) it documents your assumptions for fellow programmers (including your future self), and 3) it allows an automated tool to formally verify your reasoning. Writing this:\n\n    function test_add() {\n        var expected = 5;\n        var actual = 2 + 3;\n        assertEquals(actual, expected);\n    }\n\n...means \"I assume that 2 + 3 equals 5\". The main purpose of this test is not to make sure addition doesn't break, or that you have implemented the + operator correctly, but to document the behavior that you rely on.", "id": "d7zvyjz"}], [{"comment": "There is also another reason: the benefit isn't worth for the cost. This of course depends greatly on what you are doing, how you are doing it and who you are working with.", "id": "d7ypsy9"}, {"comment": "I'm interested, what do you think are characteristics of a project that would make it not worth it to test?", "id": "d7yq6gn"}, {"comment": "I think, *write-and-forget* academic assignments are good examples. Other ones are *write-and-leave-company* kind of projects.", "id": "d7yqdqn"}, {"comment": "First of all, i am talking about unit tests. Let's not confuse unit tests with tests in general. Now, about the examples...\n\n[This 2D game](http://runtimeterror.com/games/nikwideluxe/) i wrote 10 years ago would gain absolutely nothing from unit tests.\n\nMy current 3D game engine also wouldn't gain much from unit testing. There are a few areas where unit tests could be applies, such as the math library. However in the math library's case since it is used everywhere, if something broke it would be immediately obvious. In theory there could be an edge case where changing something only affects that case, but that would be the small benefit i mentioned - while strictly speaking, having unit tests would help find such a bug faster, in practice i would have spent way more time on the unit tests themselves (and that would have been actual time spent in the belief that *something* might *sometime* in the future go wrong, *maybe*). Also while math libs are something that is easy to test (they tend to be isolated), they are also parts that rarely change.\n\nI've worked in several projects with many people before and from my own experience with the projects i worked on, unit tests (for those projects) very rarely help. Personally i code for more than 20 years and i never felt the need to write unit tests (indeed, i used them in a couple of projects of mine and my conclusion was they were a waste of time since i spent almost more time writing the tests than the code for the project and those tests never caught anything).\n\nOf course there are cases were having tests does help. My [LIL](http://runtimeterror.com/tech/lil/) scripting language comes with a bunch of scripts that work both as examples and tests for the interpreter (which was necessary since i have two implementations of the interpreter - one in C and one in Free Pascal - and wanted to make sure that they have the same behavior).\n\nBut as i said, this depends on what you do. For me, my way of work and my own experiences, unit tests do not provide as many benefits to make worth their cost. That doesn't mean they aren't worth for anyone.", "id": "d7yrccx"}, {"comment": "I don't know much about 3D engines (I'm mainly a web developer), but I actually would have thought that in a project like that, it would be really useful to have a suite of automated unit test, since it is quite a complex system.\nIs it that the engine tends to be quite integrated with the details of the video driver? Or is that in your opinion most of your test should be end to end to actually be useful? ... or something else?\nThanks", "id": "d7ys0xf"}, {"comment": "Honestly i don't think i can speak for all 3D game engines. Unity does have some unit and automated tests, although AFAIK it is a minority and has the benefit of being an engine-only project instead of having to also work on a game. Also Unity employs a very big number of people, so having automated tests in general helps way more than if they were a 10 programmers shop.\n\nAlso i repeat that I am talking based on my own experience and the engines and teams i have worked with. Personally i am lucky that the teams i worked with were generally on the smaller size and with very good and experienced programmers.", "id": "d7yspi9"}, {"comment": "Worth testing, but not unit testing: ETL: Extract, Transform, Load code.\n\nE: I have to download some air pollution files from a government site.\n\nT: I usually have to process it to transfer it to formats I use internally.\n\nL: Load it to DB or whatever storage I'm using.\n\nEach of these steps are really easy, the difficulty comes in integrating with someone else who plays with rules you have to infer, and which change randomly.\n\n1. They change the format, like units from micrograms to nanograms.\n2. They have new illegal data, like malformed CSV.\n3. They change the download directory structure a little.\n4. They put extra unrelated files to the download directory. \n\nThese are the real problems that make the system fail. The only real solution I know is to write a monitor, that validates the data as much as it can, and gives daily reports about the missing or odd looking data.\n\nI have a few parsers that were so complex that I preferred writing unit tests. Downloading and uploading is better validated by monitors.", "id": "d7ytpc7"}, {"comment": "Also fast prototypes... but code that have to be maintained and put in prod should be tested and sadly enough I have seen prototypes been put in production. So, maybe, side-projects-prototypes but not work-prototypes ", "id": "d7yqptc"}, {"comment": "You went from \"unit-testing\" to \"testing\", whereas parent poster did not.\n\nEdit, whoops, parent responded...", "id": "d7yy7oa"}, {"comment": "Yeah... a was too broad in my assumption, but OP later clarified his posiiton", "id": "d7yzeld"}], [{"comment": "Other forms of automated software testing can provide a better cost/value ratio.  \n\nAutomated software testing should have been such an easy sell, but the strength of dogma in the people who would rather blog about testing software than actually test software kills it.\n\nEven as someone responsible for a lot of automated testing on our project, I can barely stand to listen to testing advocacy. The advice is way too strict and narrowly applicable, when it's not outright bananastown.", "id": "d7yv0dt"}, {"comment": "Yes, completely agree. In fact, I think this is part of a more general problem of developers tending to take methodologies too far. I think many programmers, good and bad, share this trait that lends itself to going all in on everything they encounter. This is of course something that is helpful when getting into programming, but it can very often lead to unnecessary complexity and dogma in real world projects, where more pragmatism is usually required.", "id": "d7z6o1w"}], [{"comment": "I generally limit unit testing for some basic low-level algorithms, such as hash functions, encoders/decoders, variable length bitstream stuff, arithmetic operations and other miscellaneous things where type transformations are performed, which could potentially break on different platforms or CPU architectures. I feel that unit testing anything beyond the aforementioned things yields rapidly diminishing returns. ", "id": "d7yvok1"}], [{"comment": "Hmmm...\n\nSo I have an old part of code which has its automated test suite, but absolutely not unit tests. There is no way I'll start rewriting this so that it becomes unit-testable.\n\nI also have new part which has unit tests.\n\nBut... the nature of the code is that it is, in most part, a wrapper around the infrastructure. The interaction with the infrastructure, possible detection of changes in its behavior, is a huge part of all that code. I find that unit tests are useless there, we need the real thing, not the mock thereof. And I can't, nor should, get the runtim infra in the build environment.\n\nSo everything still has non-unit-tests.\n\nMy favorite is the false sense of good code coverage from unit tests only, which largely ignores lower layers and the quality of the interaction with them.\n\nYMMV.", "id": "d7z18hq"}]]], "5c0qo0": ["I made an opensource WinZip alternative in c#", "2016-11-09 15:14:22", 0, "https://github.com/danielverh/Zippy", [[11, "Who uses Winzip anymore?  7z is a million times better and free"], [7, "A list of features / why I should use it instead of all the alternatives out there would be handy. I'm not sold on 2 screenshots alone ;-)\n"], [6, "Interesting. How does it compare to 7-Zip? Is it cross platform?"], [2, "I recommend creating a release for it (see https://github.com/danielverh/Zippy/releases) so people can download and use it easier. Be sure to provide both, installable and portable version."], [1, "Sleek*"], [1, "This might get me to restart my open source *ISO program (sick of PowerISO, UltraISO, MagicISO) - was also thinking about C# but the common library (DiscUtils) seems a bit clunky"]], [[{"comment": "Who uses Winzip anymore?  7z is a million times better and free", "id": "d9t3vcb"}], [{"comment": "A list of features / why I should use it instead of all the alternatives out there would be handy. I'm not sold on 2 screenshots alone ;-)\n", "id": "d9sqb71"}, {"comment": "Checkout this new list: https://github.com/danielverh/Zippy/blob/master/README.md", "id": "d9sr5jq"}, {"comment": "Better. Though \"Fast performance\" says nothing. Show me numbers and compare it with competitors ;-)\n\nAlso: If you're distributing this as an [executable/setup/package](https://github.com/danielverh/Zippy/tree/master/Setup%20Files) then you should include [SharpCompress'](https://github.com/adamhathcock/sharpcompress) License as [required](https://github.com/adamhathcock/sharpcompress/blob/master/LICENSE.txt):\n\n> The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n(And that may also go for [other components/libraries](https://github.com/danielverh/Zippy/blob/master/packages.config) you're using like [MahApps.Metro](https://github.com/MahApps/MahApps.Metro/blob/develop/LICENSE)).\n\nEssentially, you wrote a 'frontend' for SharpCompress; it's just fair to give credit where credit is due. Most of the hard work is done by the respective authors/owners (to be fair; anything of interest in *your* project is in [these](https://github.com/danielverh/Zippy/blob/master/MainWindow.xaml.cs) [three](https://github.com/danielverh/Zippy/blob/master/CompressionWrapper.cs) [files](https://github.com/danielverh/Zippy/blob/master/Interop.cs)).\n\nFinally: you should include a license yourself (should, not MUST). But make sure it's compatible with the other licenses!", "id": "d9stmxy"}, {"comment": "Thanks for the help/feedback!", "id": "d9sv9zu"}, {"comment": "I noticed you put the license(s) in the README. That's cool but not enough (nor do they NEED to be in the README). I specifically said: \n\n> If you're distributing this as an executable/setup/package then you should include SharpCompress' License as required ... And that may also go for other components/libraries\n\nE.g: The license(s) should be included in your setup/installer and copied to the installation directory (or somewhere similar) or at least be accessible by people who don't care about your code and simply download the binary installer. You could consider an \"about\" screen (which will also be useful to determine which version of Zippy you have) and have some links in there to the respective licenses.\n\nIANAL so the details may be incorrect (correct me if I'm wrong on anything), but the gist is that you include (or link to) the respective licenses (and show some credit where credit is due).", "id": "d9t0183"}, {"comment": "In the portable zip file, there is a EULA.rtf file, and in the installer, its in the licence agreement, but if I understand you correctly, I also have to put it into the app, in something like an about dialog or something, is that correct?", "id": "d9t85qk"}, {"comment": "> In the portable zip file, there is a EULA.rtf file, and in the installer, its in the licence agreement\n\nI installed it once; it wasn't in the EULA/License agreement *then*. But I guess that changed [around Nov 9, 2016, 6:42 PM GMT+1](https://github.com/danielverh/Zippy/commit/96418c1d31523631ef6b2c995c0be9a3e741231e)? \ud83d\ude09 Haven't checked since then. If you say it's in there I'll believe you \ud83d\ude09\n\nAgain: IANAL so if this is \"correct\" I don't know. At least it's [*better than nothing*](http://i.imgur.com/ZfU0eRE.png) \ud83d\ude07\n\n.\n\n^(Also, I noticed there are more repositories in your name with, potentially, the same 'problem'... no licensing of your own code*, missing licensing of others).\n\n^(* again, not REQUIRED, but surely recommended)", "id": "d9t97ak"}, {"comment": "Thank you for sharing your code. Concise.", "id": "d9tytay"}], [{"comment": "Interesting. How does it compare to 7-Zip? Is it cross platform?", "id": "d9t08f9"}, {"comment": "Its kinda like 7-zip as it uses the same compression algorithm (LZMA) but it's (unfortunately) not cross platform because I've written it in c# wpf .net, which is windows only", "id": "d9u12iy"}], [{"comment": "I recommend creating a release for it (see https://github.com/danielverh/Zippy/releases) so people can download and use it easier. Be sure to provide both, installable and portable version.", "id": "d9sv43p"}, {"comment": "Ok, I will do that, but it's in a really early stage so, should I create a release already?", "id": "d9sv907"}, {"comment": "I would. A release is always associated with a version number. I recommend using numbers less than 1.0.0 for those releases. You can also mark releases as experimental and can add comments to them, so people know that they download an unfinished product.", "id": "d9svali"}, {"comment": "Version 0.0.1!!!\nhttps://github.com/danielverh/Zippy/releases/tag/0.0.1", "id": "d9swmst"}, {"comment": "Great, but it seems like you packed the setup twice, instead of once.\n\nMaybe I was unclear, but what I meant was that you create an installer (as you did) but also pack the contents of the \"release\" folder in a zip archive, so people can decide, if they want to install or not.", "id": "d9t04jq"}, {"comment": "O, do you mean a portable version? I will add that in the next release", "id": "d9t2jdg"}, {"comment": "Yes, that would be nice. Especially pre-releases are useful to have as a portable variant.", "id": "d9t5ely"}], [{"comment": "Sleek*", "id": "d9srtfp"}], [{"comment": "This might get me to restart my open source *ISO program (sick of PowerISO, UltraISO, MagicISO) - was also thinking about C# but the common library (DiscUtils) seems a bit clunky", "id": "d9t4nk8"}, {"comment": "I'd be interested in you doing so.  At least start a repository or share the link if you already have.", "id": "d9tj7nt"}]]], "4zhxkb": ["From 10x programmer to 0.1x programmer: creating more with less", "2016-08-25 15:02:02", 1, "https://codewithoutrules.com/2016/08/25/the-01x-programmer/", [[26, "> You've heard of the mythical 10x programmers. This myth is demoralizing, but it's also not useful: how can you write ten times as much code? On the other hand, consider the 0.1x programmer, a much more useful concept\n\nNow.. either your major readership consists of barn animals and you're cleverly brainwashing them. Or then you really misunderstood a thing and wrote a blog post describing that same thing with a new name, without figuring out what the original means while you wrote it.\n\nJust.. Amazing either way!"], [2, ">Your goal as programmer is not to write code, your goal is to solve problems.\n\nIn my opinion, I think this needs to be emphasized more in the industry. I think too many developers lose sight of this."], [2, "I think you misunderstand what a 10x developer is. A 10x developer isn't someone who produces 10x code, it's someone is who 10x a productive as their peers. A 10x developer actually produces minimal code, ships regularly, documents their work. Essentially a 10x developer is 10x better at their job than a 1x developer. That metric is controversial because many have never met a 10x developer. This probably should have been titled how to go from a .1x programmer to a 10x. \n"], [-3, "I don't agree with spending time thinking. I've tried it and found it made me a much less effective programmer. Better to write the simplest code that could possibly work and go from there."]], [[{"comment": "> You've heard of the mythical 10x programmers. This myth is demoralizing, but it's also not useful: how can you write ten times as much code? On the other hand, consider the 0.1x programmer, a much more useful concept\n\nNow.. either your major readership consists of barn animals and you're cleverly brainwashing them. Or then you really misunderstood a thing and wrote a blog post describing that same thing with a new name, without figuring out what the original means while you wrote it.\n\nJust.. Amazing either way!", "id": "d6vxkem"}, {"comment": "And that's why math is a requirement for CS degrees.", "id": "d6vxmfy"}, {"comment": "Came here to say this. I have several colleagues who are typing from the moment they sit down to the moment they pick up their stuff to go home. I walk through the office all day long, having a laugh and mingling with the help desk guys. I still manage to create and maintain multiple projects (to their one, often much easier ones), get fewer bugs and generally get more done in a day than most of them do in a week.\n\nI'm not a genius ... I just bother to think about things before I do them, in fact I would argue that I only spend about 20% of my time actually typing. The 10x programmer isn't a myth, I used to believe it was but I've come in contact with so many programmers and I've seen such an incredible divide between the few who can and the few who type (or copy/paste) as if their lives depend on it. Of course if you think 10x means 'lines of code' then yeah, it's a myth, I can't type half as fast as my aforementioned colleagues and I honestly wouldn't want to.\n\nThe main difference I've noticed between the typists and the 'rock stars' is not the amount of time they apparently do nothing, it's the fear. The unholy amount of fear I see in their eyes when they have to touch some code that they may not be entirely familiar with. When you give a so-called 10x programmer a problem, they'll happily tear a piece of code that no longer fits the model apart, tests and all. When you give it to someone else you can almost see the tears welling in their eyes.", "id": "d6wac4y"}, {"comment": "No, the concept of the article makes sense.  It is basically saying that you can be more productive by **writing less code**.  In other words if developer A and developer B produce a similar similar software product, but developer B produces it 10x fewer lines of code the article claiming that developer B is superior.", "id": "d6vyegl"}, {"comment": "10x refers to productivity. Not to lines of code written during a day. Productivity refers to how much stuff happens due to your influence.\n\nAlso if we take the subsequent claim that the same product with less amount of code is a reliable indicator of quality. Lets throw a wrench to this:\n\n * The A developer's program is optimized to hell. It's 10 times faster than the B developer's 10 times shorter program.\n * The A developer's program is shorter than B developer's program, but it comes with comprehensive documentation that makes it longer. (don't argue about docs within comments -thing, sometimes that's the place for docs)\n * The A developer's program is correct and covers all corner cases.\n * The A developer wrote his program three times and we count all the three versions.\n\nSo.. um. Well neither anything of these can indicate quality because qualifiers and goals change over time. But the complexity involved here means that neither the length can work as a qualifier even if the product was same. Unless it's exactly same same. But that does not happen unless the 1x programmer has written tons of wrappers or uses wrong language in stupid manner.\n\nBtw. I gave upvote anyway because this is not utter shit what the author is writing out. It's not a shameless advert for something. And he doesn't have 2 days old account with spam in it. It's just a bit dumb and narrow.", "id": "d6vzhbj"}, {"comment": "It's always been popular for management to try measuring programmer productivity by objective metrics. In some environments, commits, lines of code, function points or bugs closed is used. None of these are really good and can all be easily gamed by somebody who isn't actually interested in productivity.", "id": "d6w0cx7"}, {"comment": "Your first three points are all accounted for by automation.  A good unit test runner also accounts of execution time of each test unit and total cumulative execution time.  The best way to gauge the performance and optimization of an application is by how quickly it accomplishes various real world tasks compared to its competitors and its previous versions.\n\nCode comments are great.  A decent version control system or diff utility allows optional ignoring of comments when analyzing or comparing code.  That said, comment size is irrespective of actual code size.\n\n> The A developer's program is correct and covers all corner cases.\n\nUnit tests.\n\nNone of these are justifications for more code.  More code means more to maintain and more test.  It also means increased learning for new people joining a given project.  Sometimes more code simply means poorly architected, as in no separation of concerns or intermixing application logic with business requirements or poor reuse.  I am juggling a bunch of unit tests written in Scala where each test has its own execution logic.  This is fairly archaic as a modern test runner abstracts away the logic so that people can simply read and write the actual test assertions.\n\nI have been writing software for twenty years and generally the top arguments for more code are the following:\n\n* We need a lower level language for speed, stability, and reliability closer to the metal.  This is typically justified at substantially higher costs because product quality is evaluated as worth the costs\n* Conventions and tooling.  Many developers introduce substantially increased lines of code because their favorite framework, tools, and code style require such.  This is purely developer preference and has nothing to do with produce quality.  There are always excuses that try to relate this to product quality or maintainability, but this leads to my next point\n* Developer confidence.  Many times developers introduce extra lines of code because they lack the experience or confidence to write the code in a more imperative way.  I have seen massive Java applications to build HTML and JavaScript artifacts for execution in web browsers.  These applications are never written in a way because their execution is faster than some more direct web browser implementation, but because its what the common culture in the company is more comfortable with.", "id": "d6w03ea"}, {"comment": "I feel that testing and test frameworks are bit weird introduction to this subject. I'm afraid I don't understand this. But..\n\n> Sometimes more code simply means poorly architected\n\nCost of maintenance for two lines of code isn't equal. Although you aren't claiming that. \n\n> More code means more to maintain and more test.\n\nNot necessarily. Good example would be that you remove the code and leave just the binaries. It gets much harder to maintain although you got less code.", "id": "d6w2bdq"}, {"comment": "Exactly. OP missed the point. It's not about \"producing lines of code\". Geez, even Bill Gates knew that.\n\nComputers are for *automation* of work. This includes automating software development burdens as well (e.g. writing code that writes code, using data to generate code, automation of testing, automation of configuration/setup/deployment, etc.)\n\nA \"10x programmer\" is a single programmer that has the skills to automate the work that would otherwise take 10 less skilled programmers to accomplish. It's about measuring automation, not measuring lines of code.\n\nFor example, if a problem has 10 variations on a theme that less skilled programmers manually hard-code where instead the more skilled programmer writes a general solution that solves all 10 variations (and more), then the skilled programmer is *at least* 10x compared to the other programmers who are hard-coding what should've been more general and better automated. If the problem grows to needing 100 variations, then hard-coding would take 100x more work than needed compared to the one general solution written by a single programmer, and so the difference is even more pronounced.\n\nThe \"10x programmer\", the \"Mythical Man Month\", and other essays basically all mirror the theme of what Edsger W.Dijkstra once said: \"[...] it is impossible to sharpen a pencil with a blunt axe. It is equally vain to try to do it with ten blunt axes instead.\"\nSuccessful programming is about successfully solving the problem, not raw manpower. So it follows that a skilled individual who can think of superior solutions can possibly be more effective than multiple other individuals for the same problem.\n\n", "id": "d6wnzzv"}], [{"comment": ">Your goal as programmer is not to write code, your goal is to solve problems.\n\nIn my opinion, I think this needs to be emphasized more in the industry. I think too many developers lose sight of this.", "id": "d6wb06v"}], [{"comment": "I think you misunderstand what a 10x developer is. A 10x developer isn't someone who produces 10x code, it's someone is who 10x a productive as their peers. A 10x developer actually produces minimal code, ships regularly, documents their work. Essentially a 10x developer is 10x better at their job than a 1x developer. That metric is controversial because many have never met a 10x developer. This probably should have been titled how to go from a .1x programmer to a 10x. \n", "id": "d6wfuve"}], [{"comment": "I don't agree with spending time thinking. I've tried it and found it made me a much less effective programmer. Better to write the simplest code that could possibly work and go from there.", "id": "d6vyobx"}, {"comment": "That works until you go down a path that is fundamentally flawed and have to start over. Or worse, forever try to hammer it into doing something it's not designed to easily do. On a simple system or one where the requirements are well defined, sure go nuts, but on a larger complex system I'm not sure that's a good strategy.\n\nYou can spend time thinking first *and then* write the simplest code possible, the two aren't mutually exclusive, but just starting code on a complex system without thinking first is risky.", "id": "d6wan6s"}, {"comment": "> But I don't have time to write a tech spec, I'm already behind\n\nSaid after the 3rd, 4th, and 5th total rewrite of the same damn feature. I don't think that he ever got it working right; QA just gave up after six weeks and passed what he had. ", "id": "d6wekte"}, {"comment": "I've heard people claim this kind of thing but it never seems to happen. As long as you stick to agile, releasing every 2 weeks and making sure all changes are driven by user-facing features, the correct design tends to just fall out. ", "id": "d6wbtmx"}, {"comment": "If all you ever code is some CRUD crap, than yes, thinking is never a requirement. This is exactly the reason you CRUD coders will go down first to the automation.", "id": "d6wcq2o"}, {"comment": "Why do you think that CRUD programmers like DI so much? It lets them add complexity like \"real programmers\" without having to add planning and thought.", "id": "d6weqeg"}, {"comment": "> the correct design tends to just fall out.\n\nEither someone above you in the food chain is smarter than you and performing that design or whatever you are working on is doomed in ways you can't imagine yet.\n\nActually, on second read I think I fell for poe's law. ", "id": "d6wdatk"}, {"comment": "The first code written without thinking is never really simple, it is most often the most expensive and the least maintainable.", "id": "d6wckhc"}, {"comment": "It's a double edged sword. While I fully agree with the idea that writing any code and see what works is good, sometimes it's better to plan out your architecture before to get too far into coding, meaning before you've codes 10.000 lines. Once you hit a large enough number of lines of code you, unbeknownst to yourself, become hesitant to throw it away and start over, leading to you sticking with your initial (sub optimal) design because you spent time and energy building it.", "id": "d6w8qsx"}, {"comment": "Continuous refactoring is vital. But it's easy emphysema to get in the habit of it, IME. ", "id": "d6wbv9o"}, {"comment": "and by `write the simplest code that could possibly work and go from there` you've agreed with the article... It's a good article. I'm not sure it's fit for an entry-level programmer as I'd suggest you have to have a bit of experience `doing it wrong` to know where you can cut from, and to gain the authority to question requests (depends who they are from and your situation to be fair).\n\nI do also have a problem with the arithmetic used in the article as I don't think I've ever heard anyone boast about lines of source code; but I have met with people you want to facepalm with a cricket bat because they take pride in obscure metrics, celebrate complexity or are generally mis-aligned with their stated goals in an obvious way. \n\nMy favourite was a GP (doctor) software vendor who said with a beaming smile on his face that his software had >400 screens, was written in MS Access with VBA and could support up to 50 users theoretically. He also delighted in showing me how many controls they could cram into a screen, showed an interest in keyboard shortcuts then asked if I'd build the replacement then charge him... Perhaps drug-use was part of his process, as I'm not sure he understood why I never spoke to him again.\n\n", "id": "d6w6v32"}, {"comment": "> and by write the simplest code that could possibly work and go from there you've agreed with the article... It's a good article.\n\nI'm saying point 3 seems entirely wrong to me.", "id": "d6w78ps"}, {"comment": "I don't know about you, but authoring new code was never a large part of my day as a coder. If I got to spend 1-2 hours of a 10 hour shift per-coder writing new code unless they are doing grunt work like hook up this API to this interface.\n\n * Do I believe in planning the beautiful system that is perfect? Hell No!\n * Do I believe in ensuring I sit down and think about what I'm coding before touching a PC? F*** Yeah!\n\nAgain, it's about where you're at. I'm at odds with just 10% (seems a client pleasing figure, but it is completely pulled from ass) spent planning a system you won't want / need to run from at the first sign of major trouble. I Do believe in iterative design and taking an iterative approach to problem-solving. On the two-hours vs two-days. Recently I led a project for a multi-lingual website with migration from an existing established web-store. We actually had a few 2 day iterations fixed in 2 hours with a different approach, it happens. What we did was move from saying an API was out of bounds because it couldn't do what we needed, to cherry picking what it could do, and implementing that. Of course the entire problem set was not solved in the 2-hour iteration, but that 2-hours gained traction instead of spinning wheels in the mud where 2 lower-level solutions had failed due to a poorly documented legacy system.\n\nIt's ***pragmatism*** vs ***perfectionism***, you shouldn't be at either extreme of the spectrum", "id": "d6wbuda"}, {"comment": "Seen from the right angle, it's all grunt work. I've participated in even major migrations a little bit at a time - sometimes over the course of years - that worked out by just setting small, user-visible goals and then coding them up. In the case you describe it sounds like the mistake was declaring something out-of-bounds in the first place - i.e. the only reason you needed design was to undo previous design - if you'd just started implementing functionality in priority order and not worried about the overall design, you'd've got it right in the first place. ", "id": "d6wceeg"}, {"comment": "Maybe you aren't satire, I pity whoever inherits your work.", "id": "d6wdgdk"}, {"comment": "Ha, if you stop your horse more often you won't have to drag it when it's dead ;-)", "id": "d6wdnrw"}]]], "57qsr8": ["Stick to UTF-8 and these three character sets", "2016-10-16 13:57:05", 0, "http://www.ilikebigbits.com/blog/2016/10/12/stick-to-utf-8-and-these-three-character-sets", [[11, "I was with the author of this program right up until the identifiers section.\n\nThe casing of identifiers, variable names in particular, is very much a style thing.  In fact, I can think of at least two style guides by the authors of languages I've used that disagree with everything said in this section."], [5, "BTW: ASCII is enough for a subset of English. Not the whole language. There are still some non ASCII words.\n"], [2, "> ASCII is a character encoding, but here I will use the term to refer to the character set consisting of the printable ASCII characters (0x20-0x7E)\n\nPedanting point - that range isn't fully defined. No doubt the author intends US-ASCII (aka the ASCII subset of Unicode), but some ASCII codes were classified as \"national use\" and gained different uses in different nations - see [Wikipedia](https://en.wikipedia.org/wiki/ASCII#Variants_and_derivations). As a Brit, I can't think of a reason to have \"\u00a3\" in my source code outside a string literal or comment, of course.\n\nAnd that's the more serious objection - string literals, and comments may need characters outside of US-ASCII for various reasons, even using English. String literals should mostly be replaced by string resources/whatever for i18n reasons, but examples in comments are still going to use the character set appropriate to the example - and if your software was written for not-primarily-English-speaking markets...\n"], [-8, "Sure, UTF-8 is nice if you're American.\n\nIf you're somebody else, you pay in memory usage just to keep them 'muricans happy!"], [-9, "> So in short: encode your code as UTF-8, but only\n> allow non-ASCII characters within string literals.\n\nSomewhat inconsistent - first, it is said to use UTF-8 - then it is said to use ASCII only.\n\nI mean, seriously."], [-10, "The world should finally start rewriting their languages in ASCII, all these additional useless characters are just ridiculous."]], [[{"comment": "I was with the author of this program right up until the identifiers section.\n\nThe casing of identifiers, variable names in particular, is very much a style thing.  In fact, I can think of at least two style guides by the authors of languages I've used that disagree with everything said in this section.", "id": "d8u7jkz"}, {"comment": "Thanks for the feedback! Maybe I should have been more clear: I did not mean to mandate the use of snake_case for all identifiers/variable names in all programming languages. Instead I mean for it to be used when you are *naming* something, in particular naming something outside of the program, like a key in a JSON, a database table, or one of a few valid (text) values in a JSON (i.e. to emulate enums, e.g. `\"state_open\"`). I can add a clarification in the article.", "id": "d8u8rq6"}, {"comment": "\u00ef\u00bb\u00bfjavascript and .NET apply totally different styles for an example.\n\nAlso just use UTF-8 for everything. The only thing I know of that really doesn't work with it are windows batch files if you add the BOM.", "id": "d8u8u5h"}, {"comment": "Yes, but why would you add a BOM to UTF-8?", "id": "d8w9od3"}, {"comment": "Many editors do it by default, including Visual Studio and Notepad++.\n\nDepending on the language it's not too bad if it is there. Batch files will just skip the first line with an error but the first line in a batch file is usually `REM` or `@ECHO OFF`. VBS files on the other hand completely fail to load.\n\nOne good reason to add the BOM (even though it has no meaning in UTF-8) is as a file signature, so the editor knows what he deals with. When not adding a BOM, the editor has to guess and [that can go wrong](https://en.wikipedia.org/wiki/Bush_hid_the_facts).", "id": "d8wehm4"}, {"comment": "Well, I only care about Linux and OS X myself, which means UTF-16 isn't something any program should guess.", "id": "d8x6qnn"}, {"comment": "> I only care about Linux and OS X myself\n\nYou realise you are still excluding about 80% (if not more) of computer users with that? It's usually the reason open source projects don't get funded.\n\nUTF-16 is what windows uses by default if you compile a program as unicode aware.", "id": "d8x6vt1"}, {"comment": "I'm fine with excluding Windows users. Windows-only developers exclude me all the time.", "id": "d8x6x2j"}, {"comment": "Typical mac user statement. Also the users did not exclude you and the programmers simply looked at the market and decided for what is best for them.", "id": "d8x6yyh"}, {"comment": "Typical Windows user statement. Also I simply look at the technology and decide what is best for me.", "id": "d8x73p3"}, {"comment": "> Typical Windows user statement.\n\nThis is not a windows user statement. This is the statement from somebody who decided if his boss should make an investment or not. If you develop an open source project and don't even attempt to care for a windows version, this is an immediate no-go, because it tells a lot about the character of the developer. You are not a special snowflake if you do this, you are just working against the market which backfires for most who do this.\n\n>  I simply look at the technology and decide what is best for me.\n\nThere is nothing wrong with that and as long as you only develop stuff for yourself, nobody cares. It's just wrong to assume it's the best for everyone and stop caring for anyone who decides to do stuff differently.", "id": "d8x906v"}, {"comment": "Yes. For identifiers I would allow uppercase letters too. And allow camel case as an alternative to snake case. At least in actual code (not JSON, etc.).\n\nAlso I would extend the exception in the second category to *comments*, which are not code but *natural language*.", "id": "d8uvzeo"}], [{"comment": "BTW: ASCII is enough for a subset of English. Not the whole language. There are still some non ASCII words.\n", "id": "d8u7mph"}, {"comment": "Can you give an example ?", "id": "d8u8ctn"}, {"comment": "There's \"na\u00efve\", although \"naive\" is the more common spelling.", "id": "d8u8mvc"}, {"comment": "It's a strange word, sorta like nai-ive.\n\nIf you write naive, it could be spoken as knife!", "id": "d8u8vg5"}, {"comment": "And that's why as a native French speaker I avoid every French loan word in English.\n\nIf I pronounce them in French, I get utter incomprehension. If I try to pronounce them like an English speaker (that tries to pronounce them in French but lacks the sounds to do so) it looks like I'm making fun of you.\n\nThere's just no way to win this.", "id": "d8un2hf"}, {"comment": "> (that tries to pronounce them in French but lacks the sounds to do so)\n\nTo be clear, we're not *trying* to pronounce them in French.  But rather, we are *succeeding* in pronouncing them in English.\n\nBut anyway, are there any French loan words that are pronounced really differently in English?  I was just listening to naive in French vs English on Google Translate, and honestly they're not that different.  ", "id": "d8z6huv"}, {"comment": "> But anyway, are there any French loan words that are pronounced really differently in English?\n\n> But anyway, are there any French loan words that are pronounced really differently in English?\n\nAll of them? I pronounce things in English but if I try to say day-ja-voo, it doesn't sound nice.", "id": "d8z79bv"}, {"comment": "Again, listening to the English vs French pronunciation of deja vu (according to Google translate), they sound extremely similar to me.  The French put the emphasis in the middle of the word, whereas the English version puts the emphasis at the beginning of the word.  That's the only difference I can tell.  I wonder if maybe your English pronunciation is better than you think it is, and people you know are just giving you a hard time?", "id": "d8z8dk1"}, {"comment": "Loanwords like \"na\u00efve\" and \"caf\u00e9\" comes to mind. I'll add a note about it in the article!", "id": "d8u8llq"}, {"comment": "Also pat\u00e9 is a good example, because pate is also an English word and means something completely different.", "id": "d8w9pky"}], [{"comment": "> ASCII is a character encoding, but here I will use the term to refer to the character set consisting of the printable ASCII characters (0x20-0x7E)\n\nPedanting point - that range isn't fully defined. No doubt the author intends US-ASCII (aka the ASCII subset of Unicode), but some ASCII codes were classified as \"national use\" and gained different uses in different nations - see [Wikipedia](https://en.wikipedia.org/wiki/ASCII#Variants_and_derivations). As a Brit, I can't think of a reason to have \"\u00a3\" in my source code outside a string literal or comment, of course.\n\nAnd that's the more serious objection - string literals, and comments may need characters outside of US-ASCII for various reasons, even using English. String literals should mostly be replaced by string resources/whatever for i18n reasons, but examples in comments are still going to use the character set appropriate to the example - and if your software was written for not-primarily-English-speaking markets...\n", "id": "d8uhw0y"}], [{"comment": "Sure, UTF-8 is nice if you're American.\n\nIf you're somebody else, you pay in memory usage just to keep them 'muricans happy!", "id": "d8ufahp"}, {"comment": "You do realize that European languages benefit tremendously from UTF-8 as well, right?\n\nIt's pretty much only the Asian languages that start to fall behind with UTF-8 vs UTF-16... but even *that* can be false if you have something like JSON where there is a fair bit of the document that's in the ASCII character set. Further, even the *worst* case the expansion in size for languages that suffer in UTF-8 is far less than the *common* case for languages with most letters in ASCII.", "id": "d8ugiht"}, {"comment": "Other way around. ", "id": "d8ufxti"}, {"comment": "not sure if serious... \n\namerica is a small subset of the places where ascii is actually used.", "id": "d8uh7ou"}], [{"comment": "> So in short: encode your code as UTF-8, but only\n> allow non-ASCII characters within string literals.\n\nSomewhat inconsistent - first, it is said to use UTF-8 - then it is said to use ASCII only.\n\nI mean, seriously.", "id": "d8u8un7"}, {"comment": "That's not what the text you quoted says though. ", "id": "d8uhtg7"}], [{"comment": "The world should finally start rewriting their languages in ASCII, all these additional useless characters are just ridiculous.", "id": "d8ub5kg"}, {"comment": "You're getting downvoted because you're being culturally insensitive. Also stupid. \n\nThe solution isn't to encode other languages in ASCII. It's to stop using other languages. \n\nI say this as a non-native English speaker. We should define English as ISO standard and just switch to it like we switched to the metric system. ", "id": "d8ug0af"}, {"comment": "> you're being culturally insensitive. Also stupid. \n\nCheck their user-name.", "id": "d8uhc5x"}, {"comment": "> Also stupid\n\nI feel it may be you who's being stupid. Or totally lacking a sense of irony. American?", "id": "d8utq7d"}, {"comment": "Did you read my entire message? Probably not since you didn't get to the part where I say I'm not a native English speaker. ", "id": "d8vdcsd"}, {"comment": "They can speak however they want to, but use proper letters instead of weird moon runes for which programmers have to bent over backwards in order to accommodate them.", "id": "d8ugj7r"}]]], "4e4a9c": ["Linq makes NoSQL a reality in .Net", "2016-04-10 06:52:13", 0, "http://www.ntierdevelopers.com/blog/linq-makes-nosql-a-reality-in-net", [[5, "NoSQL is about the database type. More specifically non RDBS. The naming \"NoSQL\" was always misleading. How you access the data doesn't matter. Ironically some NoSQL databases support SQL like querying.\nNow you can actually query NoSQL db's with LINQ if you have the right drivers (like Cassandra or MongoDB), so the article is not completly wrong. However the article doesn't go in that direction."], [3, "Wow, it's about time .NET people got use nosql.  Finally, it's a reality!"], [1, "Indeed it would be good to know if the article refers to \"avoid sql\" or specifically NoSQL.\n\n\nIn the latter case the article provides nothing specific to NoSQL, which leaves me assuming the former case was intended.\n\nIn the former case, the premise is flawed. To use EF LINQ in a performant, scalable manner, you benefit from knowledge of how the LINQ expressions written compile to queries and operations. In addition LINQ provides little to manage the underlying technology; for example backups, horizontal scaling, optimisation etc.\n\nTo take your ordering example from your article: had you specifically intended to project indexGroup into a list in memory using ToList, then to subsequently order using the database technology, and then finally to order on the set of data in memory, when the database engine could have optimised those orderbys when both considered within the same query?\n\nIf anything this article proves the opposite of what it sets out to do; that things can quickly get complicated, and when they do, the more likely you are to benefit from the database technology knowledge.\n"], [1, "Mixing SQL-style and extension method LINQ? ewww"]], [[{"comment": "NoSQL is about the database type. More specifically non RDBS. The naming \"NoSQL\" was always misleading. How you access the data doesn't matter. Ironically some NoSQL databases support SQL like querying.\nNow you can actually query NoSQL db's with LINQ if you have the right drivers (like Cassandra or MongoDB), so the article is not completly wrong. However the article doesn't go in that direction.", "id": "d1x68hj"}], [{"comment": "Wow, it's about time .NET people got use nosql.  Finally, it's a reality!", "id": "d1x5idb"}, {"comment": "LINQ was introduced to C# in 2008...\n\nedit: maybe I'm missing out on some sarcasm?", "id": "d1x5tdh"}, {"comment": "Apparently it only worked with relational databases, probably only SQL server given that it's microsoft.", "id": "d1y8kb8"}], [{"comment": "Indeed it would be good to know if the article refers to \"avoid sql\" or specifically NoSQL.\n\n\nIn the latter case the article provides nothing specific to NoSQL, which leaves me assuming the former case was intended.\n\nIn the former case, the premise is flawed. To use EF LINQ in a performant, scalable manner, you benefit from knowledge of how the LINQ expressions written compile to queries and operations. In addition LINQ provides little to manage the underlying technology; for example backups, horizontal scaling, optimisation etc.\n\nTo take your ordering example from your article: had you specifically intended to project indexGroup into a list in memory using ToList, then to subsequently order using the database technology, and then finally to order on the set of data in memory, when the database engine could have optimised those orderbys when both considered within the same query?\n\nIf anything this article proves the opposite of what it sets out to do; that things can quickly get complicated, and when they do, the more likely you are to benefit from the database technology knowledge.\n", "id": "d1xg2bu"}], [{"comment": "Mixing SQL-style and extension method LINQ? ewww", "id": "d1y9uk5"}]]], "549po7": ["jQuery 3.1.1 Released", "2016-09-24 15:12:29", 0, "http://blog.jquery.com/2016/09/22/jquery-3-1-1-released/", [[4, "[deleted]"], [0, "Does this work with boostrap v4 modal yet"]], [[{"comment": "[deleted]", "id": "d801f3i"}, {"comment": "seems a stable one", "id": "d801gf1"}, {"comment": "Are you the authority over what version release can be published on reddit and what can not?", "id": "d802yoc"}, {"comment": "[deleted]", "id": "d80a239"}, {"comment": "So don't upvote it! nbd", "id": "d80j119"}], [{"comment": "Does this work with boostrap v4 modal yet", "id": "d80ds47"}]]], "4jmeze": ["Oracle v. Google, and the end of programming as we know it", "2016-05-16 22:05:38", 2, "http://www.computerworld.com/article/3070001/application-development/oracle-v-google-and-the-end-of-programming-as-we-know-it.html", [[5, "... aaaand another site goes on the Forbes list."], [3, "Clickbait title, didn't read."], [-3, "Nice post. Thanks"]], [[{"comment": "... aaaand another site goes on the Forbes list.", "id": "d3842h6"}, {"comment": "Forbes list?", "id": "d38gdjp"}, {"comment": "Sites that we don't read due to forced annoying ad pop-ups.\n\nIt's funny, people did this shit with popup windows in the 90's for a while until it became really shameful and tacky to do so.  Then, web 2.0 sites brought it back in the form of a floating div and acted like this is totally okay and not tacky as all fuck.", "id": "d38hfmr"}], [{"comment": "Clickbait title, didn't read.", "id": "d38m0jm"}], [{"comment": "Nice post. Thanks", "id": "d37ubd5"}]]], "4an818": ["Kotlin: a new JVM language you should try", "2016-03-16 14:52:24", 2, "https://opencredo.com/kotlin/", [[2, "[deleted]"]], [[{"comment": "[deleted]", "id": "d11uv52"}, {"comment": "It has a nice enough subset of the features that draw people to languages like Scala, which presenting a *far* shallower learning curve for people coming from Java/other imperative languages, because while it uses a few of the nicest functional concepts, it's an imperative language through and through. \n\nI'm a big fan of Scala, but I've seen firsthand the difficulty many developers can have in adapting to it (through no fault of their own, there's a lot to learn and if you want to use it right the resulting code is significantly different than what you'd write in Java). Kotlin offers *some* of the same benefits but is much easier to ramp up on for many people. \n\nTo be honest, I don't know how much better it is for Android dev than other JVM languages, but their focus on Android development (even if it's just marketing) is helping a lot too. I sometimes wonder of Ceylon might be the better language (its goals are quite similar), but Kotlin is definitely marketed much better. ", "id": "d11wfdr"}]]], "4cqmml": ["Xamarin is now free", "2016-03-31 19:56:21", 8, "https://twitter.com/VisualStudio/status/715567839923580929", [], []], "4uj58r": ["Danger - Stop Saying \"You Forgot To...\" in Code Review", "2016-07-25 19:25:51", 0, "http://danger.systems", [[24, "Page needs more typefaces, colors and more things that are clickable that don't look clickable (and vice-versa).  I don't think there are enough major, minor, sub-minor, and callout headers either.  Is it possible to break up the text with more headers?  Thanks."], [8, "Danger came out of a problem we were having at [Artsy](http://artsy.github.io) applying process to our growing dev team. Through Danger we've managed to codify all sorts of interesting rules so that we, the team, don't have to think about problems like:\n\n* Does this swift code take too long to compile? \n* Was a CHANGELOG added? \n* Is a test accessing the network?\n\nThese questions are answered automatically on the PR via Danger via our [Dangerfile](https://github.com/artsy/eigen/blob/master/Dangerfile).\n"], [6, "tried to read page....had seizure....0/10...would not read again."], [3, "Bright page is bright"], [2, "I've been following this project for a while and I'm totally in love, will try to deploy it soon"], [2, "Seizures.\n\nNot just for breakfast anymore"]], [[{"comment": "Page needs more typefaces, colors and more things that are clickable that don't look clickable (and vice-versa).  I don't think there are enough major, minor, sub-minor, and callout headers either.  Is it possible to break up the text with more headers?  Thanks.", "id": "d5q6olq"}, {"comment": "They forgot to remove it.", "id": "d5qcpid"}, {"comment": "Duuude.", "id": "d5qenaj"}, {"comment": "What's wrong, is it too [artsy?](https://www.artsy.net/)", "id": "d5q9e2h"}], [{"comment": "Danger came out of a problem we were having at [Artsy](http://artsy.github.io) applying process to our growing dev team. Through Danger we've managed to codify all sorts of interesting rules so that we, the team, don't have to think about problems like:\n\n* Does this swift code take too long to compile? \n* Was a CHANGELOG added? \n* Is a test accessing the network?\n\nThese questions are answered automatically on the PR via Danger via our [Dangerfile](https://github.com/artsy/eigen/blob/master/Dangerfile).\n", "id": "d5q2luh"}, {"comment": "the automatic checks themselves look incredibly hokey", "id": "d5rdts6"}], [{"comment": "tried to read page....had seizure....0/10...would not read again.", "id": "d5qgj80"}], [{"comment": "Bright page is bright", "id": "d5qkmde"}, {"comment": "How is this?\nhttp://www.wonder-tonic.com/geocitiesizer/content.php?theme=1&music=11&url=danger.systems", "id": "d5ql7zi"}, {"comment": "Not significantly worse.", "id": "d5qlyh6"}, {"comment": "[How about this](/r/ooerintensifies)", "id": "d5qmlmm"}, {"comment": "Niiiiice.", "id": "d5qqnbb"}], [{"comment": "I've been following this project for a while and I'm totally in love, will try to deploy it soon", "id": "d5q653a"}], [{"comment": "Seizures.\n\nNot just for breakfast anymore", "id": "d5qlz5h"}]]], "3ws13z": ["How to complain about Go", "2015-12-14 15:32:10", 0, "https://medium.com/@divan/how-to-complain-about-go-349013e06d24#.q6x2uef97", [[7, "[deleted]"], [5, "TL;DR - some outspoken critics of Go have dumb objections or lack real world experience. Therefore... something."], [2, "Hahahahaha, loved it! Why would anyone use a productive, yet not objectively good language?"], [3, "OK this guy convinced me. I haven't written a line of Go and I do not intend to because I think every statically typed language without generics should be boycotted. However he makes a good point. I don't need to have written any Go to write an article and we do need to keep that trend going!"], [0, "This is one of the funniest reads I ever had on reddit."], [-2, "this article is garbage leakage..."]], [[{"comment": "[deleted]", "id": "cxyln3m"}, {"comment": "More like annoyed by repetitive blogspam... so he decided to add his own....\n\nI mean if you dont like language just dont use it... There seem to be new language popping out every month or so, plenty to choose from", "id": "cxylxhj"}, {"comment": "I couldn't read it without imagining Chris Crocker sobbing, \"Leave Go alone!\"", "id": "cxymjft"}, {"comment": "It was a fun article though :)", "id": "cxyp5n8"}], [{"comment": "TL;DR - some outspoken critics of Go have dumb objections or lack real world experience. Therefore... something.", "id": "cxyonec"}], [{"comment": "Hahahahaha, loved it! Why would anyone use a productive, yet not objectively good language?", "id": "cxylzxi"}], [{"comment": "OK this guy convinced me. I haven't written a line of Go and I do not intend to because I think every statically typed language without generics should be boycotted. However he makes a good point. I don't need to have written any Go to write an article and we do need to keep that trend going!", "id": "cxyn7qk"}, {"comment": "You got to wonder why someone would design a garbage collected language without generics.\n", "id": "cxzk2f8"}, {"comment": "Some languages have generics or generics-like mechanism and do not have a GC - C++, Rust", "id": "cxztq0q"}, {"comment": "Expanding my point, garbage collection makes generics pretty easy to implement. Where I think without that generics are hard.\n", "id": "cy03otv"}], [{"comment": "This is one of the funniest reads I ever had on reddit.", "id": "cxzicty"}], [{"comment": "this article is garbage leakage...", "id": "cxylrne"}]]], "527jc5": ["22nd Century C", "2016-09-11 11:31:44", 0, "https://procedural.github.io/post/22nd-Century-C/", [[24, "So 22nd century C is C with a bunch of useless preprocessor hacks?"], [23, "i32 in 22nd century? I would expect i128 to be the 'short int' type."], [19, "Garbage."], [16, "If you want to write go code then I'd suggest using a go compiler instead of a C compiler. Abusing the C preprocessor like this is so last century."], [13, "According to *Expert C Programming: Deep Secrets*, the original Bourne shell was written with the C preprocessor being used to make C more like Algol-68 with explicit \"end statement\" cues such as `if ... fi`.\n\n    #define IF if(\n    #define THEN ){\n    #define ELSE } else {\n    #define FI ;}\n\nThis Bornegol C dialect inspired [The International Obfuscated C Code Competition](http://ioccc.org/).\n\nWhat they say about this kind of code:\n\n> Shun any use of the C preprocessor that modifies the underlying language so that it's no longer C."], [13, "`string` should be a typedef, currently if you write \n\n    string string1, string2;\n\nit is equivalent to\n\n    char *string1;\n    char string2;"], [9, "This persons blog keeps comparing C to Swift.  It's kinda crazy that he never talks about the perf cost of safety in Swift. \n\"C is bad because I can try to read arbitrary memory address!\"  Someone should tell him about Swift's UnsafeMutableRawPointer.  \nMaybe he should compare with Rust."], [6, "And another attempt, today, to compare a language to NASA and claiming it's the reason rockets blow up.\n\nWhat this does is make C, not C, then tries to claim it's a better C but it's no longer C if you use this and, therefore, removes itself from a programmer's reason for using C in the first place."], [4, "Still have .h files and pragma once? :("], [5, ">22nd century\n\n>being this obsessed with exact bit-width of integers"], [2, "TL;DR - macros that help you write sane C. If you use astyle on this to not use the K&R braces, you essentially have [go](/r/golang)."], [4, "O don't want to sound a dick but if you're going for crazy preprocessor magic, just use go or C++.  \nSure, Linus finds C++ awful, and I'd think it is too **for a kernel**. If you're not doing a kernel C++ is fine."], [1, "This is so wierd ...\n\nThe whole site as well :/"], [1, "I've been using [Nim](http://nim-lang.org) with the garbage collector disabled (--gc:none) and it's been really nice as a C replacement for my pet projects."], [-5, "Given how fundamentally flawed C is, and the many decades of this century that have yet to pass, C still being commonly used in the 22nd century sounds quite disappointing."]], [[{"comment": "So 22nd century C is C with a bunch of useless preprocessor hacks?", "id": "d7i4zp0"}], [{"comment": "i32 in 22nd century? I would expect i128 to be the 'short int' type.", "id": "d7i0z59"}, {"comment": "I would expect hardware bignum", "id": "d7i1qbq"}, {"comment": "To be fair I still use u8.\n", "id": "d7ipm3b"}, {"comment": "Shame on you. You should be taking advantage of the full available precision of your computer. Especially for characters, booleans, and unsigned integers representing members of small enumerations.", "id": "d7yh5gv"}, {"comment": "y, u we will not need i64 for a long time.", "id": "d7i29k2"}, {"comment": "But how do I mine qbitcoins then? \n\nNot even mentioning that any crypto with 16kbit key or less was already broken in year 2099.", "id": "d7ifvzb"}, {"comment": "\"No one will need more than 637 kB of memory for a personal computer\"", "id": "d7i5ly7"}, {"comment": "Nobody ever said that.", "id": "d7i7g9n"}, {"comment": "With autocorrect and completion, surely it's easier to type the whole word out?", "id": "d7j6e4y"}], [{"comment": "Garbage.", "id": "d7hzezh"}, {"comment": "`mv c22.h pansy.h`", "id": "d7i1tya"}], [{"comment": "If you want to write go code then I'd suggest using a go compiler instead of a C compiler. Abusing the C preprocessor like this is so last century.", "id": "d7i3l5x"}, {"comment": "if you are abusing the C preprocessor, at least do it like a man:\n\nhttps://github.com/kevinlawler/kona/blob/master/src/0.c", "id": "d7ibwsw"}, {"comment": "If you're not abusing things, [you're not implementing K correctly](http://archive.vector.org.uk/art10501320)", "id": "d7icrp2"}, {"comment": "K", "id": "d7j6tn6"}, {"comment": "Any language claiming to be a systems language, especially a more modernized variant of C, which shoves a garbage collector down my throat and doesn't offer templates as an option is...not worth my time for that particular use case.\n\nI will happily abuse the CPP to high heaven, \\#defining away my own little corner of the world; increasing compile  times; making puritans roll in their graves; and forcing disassembly down the throats of those who gdb my code...if, in fact, I receive more modernized sugar and still retain the ability to shoot myself in the foot, so help me, God.", "id": "d7i767v"}, {"comment": "Go meant system programming language in the meaning of \"programming systems = servers with\", not the actual meaning like in C/Rust.\n\nReally bad words choosen from the developer team in this regard.", "id": "d7i7ird"}, {"comment": "My understanding is it actually was originally intended to be a systems language...and then it drifted into a server side language.\n\nFor a server language I'll say it seems fine though.", "id": "d7i7xuw"}], [{"comment": "According to *Expert C Programming: Deep Secrets*, the original Bourne shell was written with the C preprocessor being used to make C more like Algol-68 with explicit \"end statement\" cues such as `if ... fi`.\n\n    #define IF if(\n    #define THEN ){\n    #define ELSE } else {\n    #define FI ;}\n\nThis Bornegol C dialect inspired [The International Obfuscated C Code Competition](http://ioccc.org/).\n\nWhat they say about this kind of code:\n\n> Shun any use of the C preprocessor that modifies the underlying language so that it's no longer C.", "id": "d7i6m04"}], [{"comment": "`string` should be a typedef, currently if you write \n\n    string string1, string2;\n\nit is equivalent to\n\n    char *string1;\n    char string2;", "id": "d7i3xkl"}, {"comment": "It shouldn't be either of them; C doesn't have strings. A char pointer is only equivalent to a \"string\" in certain circumstances. Aliasing it as such will just mislead beginners in 21xx.", "id": "d7i572h"}, {"comment": "We won't have beginners in 21xx anymore because we just upload a basic programming knowledge package right into their brains.", "id": "d7i5fk0"}, {"comment": "But why would they be writing basic in the 22nd century?", "id": "d7iangq"}, {"comment": "Because that is what ws uploaded into their brians, obviously.", "id": "d7ibf3k"}, {"comment": "I doubt we'll have human programmers except for special circumstances.", "id": "d7ia47z"}, {"comment": "What would be the alternative to human programmers?", "id": "d7ieedb"}, {"comment": "Some form of AI. Remember, we're talking at least 84 years into the future.", "id": "d7igd0r"}, {"comment": "We've come essentially nowhere in the area of general AI in the last 60 years, I doubt we'll have anything approaching the AI required to write significant programmes without human support in only 84 years.", "id": "d7jkgap"}, {"comment": "Well, for the 22nd century, 84 years is the lower bound, 184 is the upper. I'd be very surprised if AI had not come any closer more than 100 years from now.", "id": "d7jtb9w"}, {"comment": "How is an AI going to understand the requirements of the users?", "id": "d7jl7v3"}, {"comment": "The same way humans do? There's nothing magical about intelligence.", "id": "d7jt7wp"}, {"comment": "I seriously doubt that people will still be writing or maintaining C code in 21xx", "id": "d7i7zkv"}, {"comment": "RemindMe! 84 years \"Write smarmy reply to /u/DarkLordAzrael\"", "id": "d7inmh7"}, {"comment": "I will be messaging you on [**2100-09-11 20:45:19 UTC**](http://www.wolframalpha.com/input/?i=2100-09-11 20:45:19 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/programming/comments/527jc5/22nd_century_c/d7inmh7)\n\n[**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&subject=Reminder&message=[https://www.reddit.com/r/programming/comments/527jc5/22nd_century_c/d7inmh7]%0A%0ARemindMe!  84 years ) to send a PM to also be reminded and to reduce spam.\n\n^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&subject=Delete Comment&message=Delete! d7inonk)\n\n_____\n\n|[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&subject=Reminder&message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&subject=List Of Reminders&message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/)\n|-|-|-|-|-|-|", "id": "d7inonk"}, {"comment": "I seriously doubt that people won't still be writing and maintaining C code in 21xx.", "id": "d7jkgq5"}, {"comment": "Fixed, thanks!", "id": "d7i4iua"}], [{"comment": "This persons blog keeps comparing C to Swift.  It's kinda crazy that he never talks about the perf cost of safety in Swift. \n\"C is bad because I can try to read arbitrary memory address!\"  Someone should tell him about Swift's UnsafeMutableRawPointer.  \nMaybe he should compare with Rust.", "id": "d7i6s45"}, {"comment": "I think in 5 years Swift will be a nice language with a some good libs. And I agree, it compares to Rust, not to C.", "id": "d7j714v"}, {"comment": "I meant he should compare C to Rust since Rust is free of abstraction overheads, unlike Swift.", "id": "d7j7gs0"}, {"comment": "Good point.", "id": "d7j7ve7"}], [{"comment": "And another attempt, today, to compare a language to NASA and claiming it's the reason rockets blow up.\n\nWhat this does is make C, not C, then tries to claim it's a better C but it's no longer C if you use this and, therefore, removes itself from a programmer's reason for using C in the first place.", "id": "d7i3noq"}, {"comment": "IMHO, this commits an even bigger offence because it tries to create an illusion that C is something more high-level, but only at the *surface*. Including a header file doesn't prevent you from incorrect pointer usage, integer overflows, or any of the numerous, subtle, UB-related issues.", "id": "d7i3zno"}, {"comment": "People who still program in C today *want* all of those 'problems' (features)\n", "id": "d7i4w7t"}, {"comment": "Thus my point to in a sense.", "id": "d7ijj1n"}], [{"comment": "Still have .h files and pragma once? :(", "id": "d7i4tub"}], [{"comment": ">22nd century\n\n>being this obsessed with exact bit-width of integers", "id": "d7i86p0"}, {"comment": "Sometimes it matters, usually it doesn't. ", "id": "d7ibcvm"}], [{"comment": "TL;DR - macros that help you write sane C. If you use astyle on this to not use the K&R braces, you essentially have [go](/r/golang).", "id": "d7hzpgk"}, {"comment": ">macros that help you write sane C.\n\nI beg to differ.", "id": "d7i1odd"}, {"comment": "`address` is quite misleadingly defined to appear like a keyword to the user of the header, but it is still the `*` operator with its own precedence which can be observed in a declaration like this:\n\n    void address(address fp)(int (address)[20]);\n\nIs it really more understandable than `void *(*fp)(int (*)[20])`?\n\nAlso, in what esoteric way is `(*in).one` considered 22nd century? That is 4 tokens versus 1 token.", "id": "d7i2jhj"}], [{"comment": "O don't want to sound a dick but if you're going for crazy preprocessor magic, just use go or C++.  \nSure, Linus finds C++ awful, and I'd think it is too **for a kernel**. If you're not doing a kernel C++ is fine.", "id": "d7i60w4"}, {"comment": "C++ has been used successfully in a number of kernels.  It may not have been a good choice back when Linux was started, but these days there is no reason not to use C++ for a kernel.  (The NT kernel and the Haiku kernel spring to mind as kernels written in C++)", "id": "d7i83lq"}, {"comment": "That's what happens when people elevate Linus to a god status. The truth is that he was full of shit in his rant.", "id": "d7ih503"}, {"comment": "C++ has not been used successfully in any actual kernels. Maybe in a couple of /r/osdev projects.\n\nC++ is far too complex a language that is far too hard to reason about to write a kernel in.", "id": "d7jkicg"}, {"comment": ">O don't want to sound a dick but if you're going for crazy preprocessor magic, just use go or C++.  \nSure, Linus finds C++ awful, and I'd think it is too ~~for a kernel~~ anything embedded. If you're not doing ~~a kernel~~ anything embedded C++ is fine.\n\nFTFY\n", "id": "d7i79ns"}, {"comment": "Uh, no. C++ is used a lot in embedded systems.", "id": "d7i7uiy"}, {"comment": "[deleted]", "id": "d7i8akn"}, {"comment": "Templates can be abused, but it seems like a lot of times they would be used macros would be used in C, which would lead to even more bloat of the execuatble size.\n\nWhy does ABI matter for embedded? It seems to me (a desktop developer) that it would be lass of a concern there due to not interacting with external modules.\n\nI'm torn on the \"bad C++ programmers\" thing.  I think it is mostly due to the number of C and Java programmers that think it is close enough so they can just pick it up and use it without really understanding the language.  I haven't had any trouble with people who have put in the time to actually learn it though.", "id": "d7i8tz6"}, {"comment": "I second this. I also believe many C++ programmers can be good, they just need to not be taught limited subsets of it by C-but-with-feature-X developers and professors anymore.\n\nAs for templates, they beat macros out of the water so much, it's not even funny: readability, maintainability, non-brittleness, power, inlining freedom for the compiler (with appropriate optimization flags), actual intelligence behind template instantiation. The only place where macros can still hold their own against templates is enums and switch cases, which the committee seems to not care much about for some reason.", "id": "d7ijilt"}, {"comment": "Macros are also useful for things like boilerplate introspection functions, etc.  (Though now that I think of it those could be done with a template mixin thing...)", "id": "d7istr9"}, {"comment": ">I second this. I also believe many C++ programmers can be good, they just need to not be taught limited subsets of it by C-but-with-feature-X developers and professors anymore.\n\nOf course they **can** be. Anyone can be good at any programming interface. \n\nAt one point do you draw the line between amount of *elementary* knowledge to effectively use a given tool to solve a problem? \n\nI use C++ all the time, but that's only because I have a virtual address space and because I spend my spare time working in OpenGL.\n\n>As for templates, they beat macros out of the water so much, it's not even funny: readability, maintainability, non-brittleness, power, inlining freedom for the compiler (with appropriate optimization flags), actual intelligence behind template instantiation. The only place where macros can still hold their own against templates is enums and switch cases, which the committee seems to not care much about for some reason.\n\nI'm not saying templates are all bad: they provide enough benefit to the point where I often wish C had native support for them. \n\nAgain, though, I'd rather spend time studying and becoming proficient in the problems I'm solving as opposed to becoming an expert in metaprogramming and C++11. \n\nI mean, honestly, I would say assembler is easier to understand, learn, and be effective with than C++. ", "id": "d7jvl8f"}, {"comment": "Maybe, but I think you're overestimating the amount of time it takes to have a decent practical knowledge of C++.", "id": "d7k4ela"}, {"comment": ">Templates can be abused, but it seems like a lot of times they would be used macros would be used in C, which would lead to even more bloat of the execuatble size.\n\n>Why does ABI matter for embedded? It seems to me (a desktop developer) that it would be lass of a concern there due to not interacting with external modules.\n\n>I'm torn on the \"bad C++ programmers\" thing.  I think it is mostly due to the number of C and Java programmers that think it is close enough so they can just pick it up and use it without really understanding the language.  I haven't had any trouble with people who have put in the time to actually learn it though.\n\nLook at my history for the long post answering why I feel this way.\n\nFor the record, I think C++ is fine for most usermode applications. ", "id": "d7jv7t3"}, {"comment": ">Templates can be abused, but it seems like a lot of times they would be used macros would be used in C, which would lead to even more bloat of the execuatble size.\n\nHow do you mean in terms of C macros causing more bloat?\n\n>Why does ABI matter for embedded? It seems to me (a desktop developer) that it would be lass of a concern there due to not interacting with external modules.\n\nABI for external modules is significant, but what's just as important is how memory is internally represented in the binary. This is touched on in a more thorough answer I gave in this thread.\n\n>I'm torn on the \"bad C++ programmers\" thing.  I think it is mostly due to the number of C and Java programmers that think it is close enough so they can just pick it up and use it without really understanding the language.  I haven't had any trouble with people who have put in the time to actually learn it though.\n\nI could argue that if everyone wrote in pure C we'd all be able to improve upon just one standardized interface. \n\nBut for me to even desire that is next to ludicrous.", "id": "d7jw4g0"}, {"comment": "Function like macros in particular lead to larger code size than templates as a template expands to a function declaration while a macro dumps it's code directly at the call site. This is dependant on inlining behavior though. (Which can be controlled by pragmas/compile switches, etc.) You got some stuff wrong in your other comment about the layout of C++ types, and I recommend that you look into standard layout types (which are identical to a similarly declared struct in C)\n\nHaving everyone write in C would be a non-starter as it doesn't scale particularly well to large and complex applications.", "id": "d7jxnan"}, {"comment": ">Function like macros in particular lead to larger code size than templates as a template expands to a function declaration while a macro dumps it's code directly at the call site.\n\nThe difference here is that plenty of C coders prefer to rely on binary representations of arbitrary data as opposed to type safety, and therefore void* it up and do so well.\n\nC++ programmers rarely take that approach.\n\n>This is dependant on inlining behavior though. (Which can be controlled by pragmas/compile switches, etc.) \n\nI'm aware of -fno-inline and I know how to define a macro which wraps an always inline attribute. Next thing you're going to mention is that ELF binaries use symbol versioning, right?\n\n> You got some stuff wrong in your other comment about the layout of C++ types, and I recommend that you look into standard layout types (which are identical to a similarly declared struct in C)\n\nI didn't get that wrong actually. The reason why macros which are designed to work with POD-only structs like offsetof will throw compiler errors on classes is because of this vagueness of binary layout as specified in the C++ standard. It's literally meant to be implementation dependent, and a standardized ABI is non-existent.\n\nIf you don't want to research this, I'll happily refer you to some references.\n\n>Having everyone write in C would be a non-starter as it doesn't scale particularly well to large and complex applications.\n\nThat's bullshit: take a look at Linux, GTK, or Quake's first 3 engines.", "id": "d9e2uen"}, {"comment": "Yes, like the F35. And the software has been blocking release since 2013. You have to reboot the systems *during flight* because the software is so bad.", "id": "d7ilbi2"}, {"comment": "I don't know what your point is about. I'm not sure if you have one.", "id": "d7in9vc"}, {"comment": "I stand corrected.", "id": "d7i80dw"}], [{"comment": "This is so wierd ...\n\nThe whole site as well :/", "id": "d7i45ub"}], [{"comment": "I've been using [Nim](http://nim-lang.org) with the garbage collector disabled (--gc:none) and it's been really nice as a C replacement for my pet projects.", "id": "d7icvuk"}], [{"comment": "Given how fundamentally flawed C is, and the many decades of this century that have yet to pass, C still being commonly used in the 22nd century sounds quite disappointing.", "id": "d7i5sn4"}, {"comment": "[deleted]", "id": "d7i7swu"}, {"comment": "Honestly, a lot of those are things that C++ is common for.  Also, what makes you think that there can't be a language that is sane while still allowing low level hardware manipulation?", "id": "d7i86mg"}, {"comment": ">Honestly, a lot of those are things that C++ is common for. \n\nI touched on this earlier in the same thread; if you read my history you'll see it.\n\nIn a nutshell, I consider C++ to be less safe and more error prone than C - for embedded systems.\n\n>Also, what makes you think that there **can't** be a language that is sane while still allowing low level hardware manipulation?\n\nI don't think that: my point is that C *is* that sane language.\n\n", "id": "d7i8gub"}, {"comment": ">In a nutshell, I consider C++ to be less safe and more error prone than C - for embedded systems.\n\nWhat do you think it is about embedded systems that make writing C++ more error prone?", "id": "d7ibexh"}, {"comment": "**tl;dr** check the very bottom.\n\nEmbedded systems are much more sensitive than typical user mode applications. Hardware debugging and a knowledge of electronics is necessary to effectively program them. This implies that you, as the programmer, have to spend  effort towards producing a reliable system which has a significantly higher success rate than failure rate. In some situations a failure rate literally means death to the individual using the system in question.\n\nHere are my arguments:\n\n1) It's notorious for providing programmers with an interface that requires a lot of focus and expert knowledge for producing quality code, far more than higher level languages than Java, and even lower level languages like C. \nThe majority of C++ programmers who work professionally are passable at best: for them to learn and become pure experts in the language distracts from the application of the language itself - this is counterproductive, because a programming language's use stems from the idea that is meant to be applied towards solving a problem. When the tool you're using makes it notoriously difficult to solve a given problem, so much that you find yourself knowing more about the tool itself than the problem you're actually solving, is it _really_ worth investing in?\n\nC++ has many different methodologies; it is effectively multi-paradigm. In most cases this is beneficial; in the case of C++, though, its core complexities _coupled with the amount of differing approaches_ makes it difficult for collaborating programmers to stick to a particular subset, _especially_ if a number of members within a group are used to programming outside of that particular agreed upon subset.\n\n2) C++ claims to be easier and safer to program in than C. Yet, many times I've found myself debugging archaic and cryptic memory issues which were sourced in levels buried deep within the reams of abstraction in the current version of the STL I was using. An example of this would be a heap block overrun I had to deal with not long ago in Windows, which involved resizing a buffer in a std vector. I've never had to deal with that level of complexity in C, because when an issue like that occurs in C it's easy to track down and fix. \n\nYesterday I was working my way through an stl header, only to find that the function I was looking for the definition of was literally this:\n\n     template <class _Tp>\n     inline _LIBCPP_INLINE_VISIBILITY\n     _Tp*\n     addressof(_Tp& __x) _NOEXCEPT\n     {\n         return (_Tp*)&reinterpret_cast<const volatile char&>(__x);\n     }\n\nThe above is unnecessarily complex, and encourages a bloated programming mentality, using constructs which really aren't necessary at all to achieve what can be accomplished with much less.\n\n3) Binary safety in C++ is a myth, and UB at the low level is far more likely given that the ABI is unstable. Take the following code:\n\n     class A {\n     public:\n          int i;\n          void some_fn();\n          int get_i() {return i};\n     };\n\n\nThere is no actual guarantee that the order of the class members specified will be represented as-is in memory. In other words,\n\n       A a;\n       void* x = ((unsigned char*)&a) + 4;\n \nthe variable x could point to some_fn(), get_i(), i itself, or the default constructor or destructor. Yet, there is legitimate software in existence which *relies* on the idea of the ordered declarations being explicitly represented the same in terms of memory layout to function. A good example of this is Assimp's Matrix operator[], who's access is dependent on individual scalar values being clustered together like so:\n    \n     class Matrix {\n          float a, b, c, d, e, f, g, h, i ..;\n      public:\n          float operator[](int i) const {\n                return *((float*)&a + i);\n          }\n     }; \n\n\nDoes it work? Yes, but only on the systems I've tried these particular operations on, which is Windows. The fact that implementing compilers are not required to abide by that rule at all, though, is significant.\n\n4) Embedded systems are a completely different beast: memory layouts and addressing schemes are extremely specific. NULL does not necessarily imply address 0x0. \n\nWhat does this have to do with C++ and its natural tendency for producing errors on embedded systems? Think about it: embedded systems by design are intended to be programmed in a manner which requires conservative resource usage. This generally involves making every single bit within a 32-bit integer (or whatever the native word size is for the system in question) count. This also means that by definition memory is meant to be used at a very low level: you're literally dereferencing constant addresses and writing to their memory locations so you can, for example, print text on your serial console. \n\n------\n\nNow, wrap all of these ideas up in large layers of abstraction which are not necessarily at all simple to parse and understand, coupled with the usage of templates (which will of course increase your binary size, and also invite semantics which are convoluted, adding an additional layer of complexity to master once more), the idea of forcing default constructors, destructors, and even operator overloads into your data structures which you may not necessarily want, _and_ providing absolutely no guarantee that you will have a properly constructed standard library to facilitate this mess. \n\nWhat happens when you use a C++ compiler which doesn't ship with an STL implementation, or even a standard C library? Implement your own memcpy and memset? Sure, that sounds great, and would be just fine and dandy if we were using C. Unfortunately, were not, and anyone who programs C++ knows that using memcpy and memset on an instance of a struct or class only invites UB.\n\nSo, in short:\n\n1) Fragmentation in reliability: the few guarantees you actually do get in C\nwork very well for embedded systems.\n\n2) C++ is extremely complex: you will have to spend a large amount of time and effort to be effective with it.\n\n3) The abstractions provided are really no more safe than the lack of abstraction provided in C.\n\n4) Templates only increase binary size, which is something one generally wants to avoid in embedded systems.\n\n5) The standards mandate that data structures will receive implicit, default class members which make working with them at the binary level extremely difficult, something that embedded systems by their very nature rely on.\n\n6) All of the issues provided in C are absolutely not fixed in C++. \n\n7) C++ may encourage one to not learn how memory actually works semantically in the programming sense; in the\nembedded realm this is counter-productive.", "id": "d7j9q5c"}, {"comment": "I'm going to preface my reply with I'm mainly familiar with C++14 (so called \"Modern C++\"), definitely not familiar with the actual standards legalese, and that I've done \"embedded\" development (as you define it) on very small scale projects (think EE/CE senior design type stuff).  Anyone who *does* have a good understanding of the C++ Standards, please correct me if I make any mistakes.\n\n1) I think \"for them to learn and become pure experts in the language distracts from the application of the language itself\" can apply to just about any language, in varying degrees - the more you have to learn to get into the \"culture\" of a language, the longer this applies.  That being said, I don't think it takes more than a couple years to become proficient enough in C++ that \"becoming a pure language expert\" is not detracting.\n\n\"When the tool you're using makes it notoriously difficult to solve a given problem ... is it *really* worth investing in?\"   Yes, but I don't think C++ fits into that category (at least where I use it).\n\nI definitely agree with \"especially if a number of members within a group are used to programming outside of that particular agreed upon subset\" though that can apply to any language where it's common to use a particular subset of it.  (Perl comes to mind, though the TMTOWTDI is becoming smaller there, IMO.)\n\n2) I've literally *never* had to debug a problem in the STL itself - ie, any time I was looking at STL code (probably from a compiler error dump) it was because *I* did something stupid.  (Usually *very* stupid.)\n\nWas your problem with a heap block overrun because *the STL implementation* was overrunning a buffer or because *your code* was?\n\nAs far as the \"unnecessarily complex\", I disagree.  There are plenty of times where something *looks* unnecessarily complex, but it's usually there for a very very good reason.  I'm going to hazard a guess (though I'm probably wrong) that the implementation of addressof() is done that way because the `operator&` of certain types (something virtual something multiple inheritance mumble) doesn't return a pointer to the beginning of the object.  Casting to a char first causes the addressof() to take a different address.  That being said, I do wish such a thing wasn't really required, but I have a feeling it's done that way because the C++ committee likes putting as much in the library as possible, leaving the language proper alone.\n\n3) As I said in the beginning, I don't actually read the C++ Standard documents, but I'm pretty sure you're wrong here.  I'm pretty sure that struct/class types that satisfy [PODType](http://en.cppreference.com/w/cpp/concept/PODType) and/or [StandardLayoutType](http://en.cppreference.com/w/cpp/concept/StandardLayoutType) have all the properties that you desire.  PODType (which is a superset of StandardLayoutType) explicitly states that it can be passed to/from C directly, in binary form (see [here](http://en.cppreference.com/w/cpp/concept/StandardLayoutType)).\nI would bet money that your example is guaranteed by the standard (see also the part about \"common initial sequences\" and imagine a number of classes that are similar to Matrix but each with one fewer member than the previous).\n\n4) NULL is not necessarily 0x0 on *any* platform - it just *happens* to be on most of them.  I'm not sure what point you're trying to make, but \"This also means that by definition memory is meant to be used at a very low level: you're literally dereferencing constant addresses and writing to their memory locations so you can, for example, print text on your serial console.\" is not true for C either.  I don't have a reference for such a statement, but even C doesn't have those semantics.  Most C people (myself included until recently) assumes that it does because it actually does for nearly all implementations of C.\n\nAs far as the bit about constructors, destructors and operator overloads I disagree again.  Yes, you get default implementations in some cases, but you can explicitly remove them with ` = delete` in the class definition.\n\n\"providing absolutely no guarantee that you will have a properly constructed standard library to facilitate this mess.\"  I'm not sure what the standard says about the availability of the STL, but I have a feeling that any implementation  that doesn't provide an STL is not a compliant C++ implementation.\n\n\"Unfortunately, were not, and anyone who programs C++ knows that using memcpy and memset on an instance of a struct or class only invites UB.\"  Citation Needed; see what I said in #3.\n\n5 (the second))  I disagree.  I use C++ all the time in my day job to twiddle registers in an FPGA via memory-mapped registers over PCIe.  It works fine.  I didn't even bother removing the class members that you say are mandatory, though I could.\n\n7) While I agree that \"Modern C++\" encourages people to ignore the low-level details, I don't think it actually *removes* them, which makes it just fine for embedded.", "id": "d7kfq1r"}, {"comment": "Looks like I touched a nerve. I don't dislike C, but like to think that the future is not about stagnation. In the year 2100, C is going to be almost 130 years old. Calling for \"22nd century C\" is highly presumptuous, no matter how much of a fanboy you happen to be. As for microwaves, I'm thankful to the companies that make them (and their employees), not Dennis Ritchie. If not for him, they'd have used something other than C.", "id": "d7i8gcq"}, {"comment": "We don't owe C any more usage just because of those things, though.", "id": "d7icjs6"}, {"comment": "With infinite resource, you can implement everything as direct circuit. C is just a convenient layer.", "id": "d7i8tll"}, {"comment": "Oh, sure. I'm not sure how that actually contradicts my point, though, or even where the relevance of that lies.", "id": "d7i9e6q"}]]], "4g14xg": ["How I got a US$250k job offer in SF with no commercial experience", "2016-04-23 03:43:51", 0, "http://haseebq.com/farewell-app-academy-hello-airbnb-part-ii/", [[43, "If you ever wanted a nice big red flag that the bubble is due to pop, this is pretty much it."], [15, ">The Airbnb interview was long and challenging. But, unlike the Google interview, it was invigorating. I met with payments engineers, infrastructure engineers, even a political analyst who worked on European Airbnb regulation. I was challenged on my understanding of algorithms, of caching layers and database indices, **I was questioned on my beliefs about the human right of free movement across borders and on the future of travel.**\n\nuh... what?\n\nis this normal in interviews now? I must be out of touch"], [11, "How I can write a 23,000 word blog on finding a job in the tech industry w/o actually showing any tech related skills at all. Neat I guess? "], [7, "Looking at the number of comments and vote-ratio, there sure are a lot of haters out there.\n\nCouple of things:\n\n1. Kudos on going from self-taught-programmer to 250k/year AirBNB developer, in one year. I had a somewhat similar experience 2 years ago, and like you mentioned, that 1st job is always the hardest. No one takes you seriously, not even yourself, until you get some solid experience under your belt. And then a year later, all of a sudden, everyone looks at you completely differently.\n\n2. Props to you for taking charity seriously, even this early in your career.\n\n3. I wish more people would talk openly about how much money they made and what kind of offers they got. Yes, it hurts your ego to learn that someone more junior than you is making more money than you, but him sharing that info is going to help you with your own salary negotiations in the future\n\n4. To anyone who's hating on this guy for achieving that level of success, don't. Look at this as an opportunity instead. He's shared his journey every step of the way, and there isn't anything \"special\" that he had going for him, which you yourself can't achieve if you work hard enough."], [5, "[deleted]"], [3, "(from part 1)\n\n>I spent the majority of my free time grinding on algorithms problems and strengthening my knowledge of system design\n\nIf the author is here, I would like to know what resources you used. I'm always looking for a good book or website for this stuff."], [4, "It's worth about $80K a year to me to stay the hell away from NYC and SF."], [1, "I'm kinda impressed that is pretty awesome and not normal out of a coding bootcamp."]], [[{"comment": "If you ever wanted a nice big red flag that the bubble is due to pop, this is pretty much it.", "id": "d2dr32f"}, {"comment": "[deleted]", "id": "d2dsr4i"}, {"comment": "Maybe, but this is someone with less than one year's experience in the industry and a grand total of 12 weeks of actual training.\n\nFirst year lawyers make $180k, tops; and they also have several years' worth of law school behind them.", "id": "d2dt7ae"}, {"comment": "95k is in stock units, however.\n\nThey will need to not burn AirBnB to the ground to cash out.", "id": "d2dv1uo"}, {"comment": "That hoodie tho bro...", "id": "d2drh1z"}, {"comment": "Why would this be it? Doesn't this signal that pretty much every programmer can require even more in payment for their work?", "id": "d2eorfw"}], [{"comment": ">The Airbnb interview was long and challenging. But, unlike the Google interview, it was invigorating. I met with payments engineers, infrastructure engineers, even a political analyst who worked on European Airbnb regulation. I was challenged on my understanding of algorithms, of caching layers and database indices, **I was questioned on my beliefs about the human right of free movement across borders and on the future of travel.**\n\nuh... what?\n\nis this normal in interviews now? I must be out of touch", "id": "d2dtowi"}, {"comment": "Actually wtf. Who asks these questions??? As someone who has interviewed in numerous places in the last year I never got such strange questions. I really do not think this is the norm. ", "id": "d2duhy3"}, {"comment": "Putting the \"cult\" in culture", "id": "d2dv8fv"}, {"comment": "It was an interview for airbnb, a company all about facilitating people moving from place to place with low friction; and a company that's faced severe regulation in Europe.\n\nIt's not really a random question because it goes to the core of the company's business purpose and to whether you align with it or not.", "id": "d2dv91s"}], [{"comment": "How I can write a 23,000 word blog on finding a job in the tech industry w/o actually showing any tech related skills at all. Neat I guess? ", "id": "d2dt4vq"}, {"comment": "I can assure you that you won't pass Google (or any other) tech interview without \"actually showing tech related skills\".\n\nHe wouldn't be getting those offers if he didn't do very well during onsite interview.", "id": "d2dtbvy"}, {"comment": "Wouldn't be surprised if it were a \"bluff\" offer that he made up to negotiate. The guy is a poker strategist.", "id": "d2dyctv"}, {"comment": "I got lucky and parlayed some opportunities into something I'm probably not qualified to do and therefore I'm entitled to write a rambling essay?", "id": "d2du0q3"}, {"comment": "Anyone can write an essay.", "id": "d2dv4in"}, {"comment": "[deleted]", "id": "d2dyc5y"}, {"comment": "The entitled quip has nothing to do with the right to write an essay. It's a critique of the logic behind this particular one. ", "id": "d2dzwpp"}, {"comment": "At many startups I've observed, 1% of people do the work and 99% take credit for it. Those 99% also tend to move from company to company very rapidly.", "id": "d2h8f2k"}], [{"comment": "Looking at the number of comments and vote-ratio, there sure are a lot of haters out there.\n\nCouple of things:\n\n1. Kudos on going from self-taught-programmer to 250k/year AirBNB developer, in one year. I had a somewhat similar experience 2 years ago, and like you mentioned, that 1st job is always the hardest. No one takes you seriously, not even yourself, until you get some solid experience under your belt. And then a year later, all of a sudden, everyone looks at you completely differently.\n\n2. Props to you for taking charity seriously, even this early in your career.\n\n3. I wish more people would talk openly about how much money they made and what kind of offers they got. Yes, it hurts your ego to learn that someone more junior than you is making more money than you, but him sharing that info is going to help you with your own salary negotiations in the future\n\n4. To anyone who's hating on this guy for achieving that level of success, don't. Look at this as an opportunity instead. He's shared his journey every step of the way, and there isn't anything \"special\" that he had going for him, which you yourself can't achieve if you work hard enough.", "id": "d2dznn8"}, {"comment": "An important distinction: OP attended one of the more well-known coding bootcamps AND worked for the school to develop its curriculum. That is entirely different than \"self-teaching.\"", "id": "d2ee4ds"}, {"comment": "Wow. It's kind of hilarious how many bitter people there are here.\n\nRaw talent both socially and intellectually + work ethic = success to some degree. Add luck on top of that and you're set.\n\nSimple recipe, ingredients aren't easy to get though.\n", "id": "d2jl1gi"}], [{"comment": "[deleted]", "id": "d2dsauq"}, {"comment": "I would tend to agree, but given that RSUs at Google are basically printed money, I wouldn't be too broken up over that.\n\nRSUs at other startups are definitely less liquid, but Airbnb is definitely more liquid that Triplebyte. ", "id": "d2dsuzx"}], [{"comment": "(from part 1)\n\n>I spent the majority of my free time grinding on algorithms problems and strengthening my knowledge of system design\n\nIf the author is here, I would like to know what resources you used. I'm always looking for a good book or website for this stuff.", "id": "d2dtpyc"}, {"comment": "CLRS is the **only** resource.", "id": "d2fqgwy"}], [{"comment": "It's worth about $80K a year to me to stay the hell away from NYC and SF.", "id": "d2dum0a"}, {"comment": "Keep me away from DC as well. Holy shit that week was hell.", "id": "d2dx6xl"}, {"comment": "[deleted]", "id": "d2ef078"}, {"comment": "I guess I lost my taste for commuting, for traffic, for congestion, for noise, crowds.  I like the food in big cities.  I like the music. Everything else I can live without or have shipped to me by Amazon.\n", "id": "d2efc32"}, {"comment": "...you're not supposed to drive to work in NYC.", "id": "d2eywx9"}, {"comment": "NYC has better facilities for non-drive commuting, but when you're taking multiple trains and it takes an hour, I still call it a commute. And I'm still affected by traffic even when I rely only on public transit.", "id": "d2f93fe"}, {"comment": "It all comes down to where you live. I'm in silicon valley and have a 15 minute bike ride on a dedicated (non-car) path each day to work. Of course, if you live in SF and work in the south bay (or vice versa), then it's going to be more painful.", "id": "d2imsou"}, {"comment": "I love DC.  Commuting is easy.  There is no traffic.  I walk everywhere.  Everywhere is within easy walking distance.", "id": "d2f7i06"}], [{"comment": "I'm kinda impressed that is pretty awesome and not normal out of a coding bootcamp.", "id": "d2dvp0u"}]]], "4dsni5": ["Google may be considering Swift for use on Android", "2016-04-07 23:17:53", 0, "http://thenextweb.com/dd/2016/04/07/google-facebook-uber-swift/", [[52, "Quality tech journalism.\n\n> Some low-level Android APIs are C++, which Swift can not currently bridge to. Those would have to be re-written\n\nWat?\n\n> It would be much less work on Google\u2019s end to get Kotlin up and running for Android, but could be a tedious transition for developers.\n\nAs oposed to the gloriously simple transition from the Java ecosystem to Swift?\n\n> In a way, Google has already begun moving away from bits of Oracle-flavored Java. It\u2019s now using the Open JDK for Android rather than the proprietary Java API, and may be considering a post-Java life altogether.\n\nThose words don't mean what you think they mean.\n\n10/10, would click bait again!"], [6, "My *sources* say, Google is rather aiming to make Go and Dart a *first-class citzen*... (jeez I cant stand that word)\nI could say anything there. Kinda hilarious without any indication who your sources are. I speculate this is pure Swift and Apple fanboyism."], [1, "I almost want to see Apple sue Google for using their APIs if they make the switch.\n\nOn a more serious note, I suspect that this is a bluff by Google. Google may be hoping that this frightens Oracle into withdrawing their suit, or at least accepting a more reasonable settlement."], [-2, "DO IT DAMMIT!  I hate Java with a passion."]], [[{"comment": "Quality tech journalism.\n\n> Some low-level Android APIs are C++, which Swift can not currently bridge to. Those would have to be re-written\n\nWat?\n\n> It would be much less work on Google\u2019s end to get Kotlin up and running for Android, but could be a tedious transition for developers.\n\nAs oposed to the gloriously simple transition from the Java ecosystem to Swift?\n\n> In a way, Google has already begun moving away from bits of Oracle-flavored Java. It\u2019s now using the Open JDK for Android rather than the proprietary Java API, and may be considering a post-Java life altogether.\n\nThose words don't mean what you think they mean.\n\n10/10, would click bait again!", "id": "d1tyay5"}], [{"comment": "My *sources* say, Google is rather aiming to make Go and Dart a *first-class citzen*... (jeez I cant stand that word)\nI could say anything there. Kinda hilarious without any indication who your sources are. I speculate this is pure Swift and Apple fanboyism.", "id": "d1u5ciu"}], [{"comment": "I almost want to see Apple sue Google for using their APIs if they make the switch.\n\nOn a more serious note, I suspect that this is a bluff by Google. Google may be hoping that this frightens Oracle into withdrawing their suit, or at least accepting a more reasonable settlement.", "id": "d1ty190"}, {"comment": "I suspect that this article is pure speculation. Since Google uses OpenJDK now, Oracle can no longer sue Google for using it (this change doesn't change the history, though). Given the maturity, massive investments and the big eco system, I think this article is just entertainment.\n\nIf Google wants a more productive language, they could choose Kotlin and help to make the compiler faster. That would be a ridiculous small effort, compared to rewriting everything in Swift.", "id": "d1u17pd"}, {"comment": ">If Google wants a more productive language, they could choose Kotlin and help to make the compiler faster.\n\nThis is what I was thinking as well. Google sponsoring a JVM language like Kotlin seems much more likely than adopting Swift for the reasons you mentioned, to say nothing of the marketing implications of using a language Apple designed essentially for the iOS.", "id": "d1u2rpl"}, {"comment": "> ants a more productive language, they could choose Kotlin and help to make the compiler faster\n\nJetrains is already doing this. Recent Kotlin EAP build has enabled incremental compilation support for Gradle and reduced the standard library method count by ~2k . These two changes are mainly targeted for Android developers. Today there are **NO** changes required from Google to support kotlin for android unless they want to provide idiomatic kotlin APIs. ", "id": "d1uefv9"}, {"comment": "Why not actually just give Oracle what they want and stop using Java and use something better?", "id": "d1ty4g7"}, {"comment": "What Oracle wants is a truck full of cash.", "id": "d1tyg6y"}, {"comment": "google gave them a pretty good way to get it by using java, cant really blame oracle for being given a target at point blank range", "id": "d1u42g4"}, {"comment": "They started using Java before Oracle bought Sun.", "id": "d1u5dw9"}, {"comment": "probably should have changed direction then, not like sun was the best owner of java either.. how long did they politically stalemate with the apache people for", "id": "d1u6uh1"}, {"comment": "As the article states, re-writing Android's API to use Swift instead of Java will be difficult and expensive, and will possibly alienate current Android developers. It will also mean that a large class of Android apps will (eventually) have to be re-written. Switching languages is not a decision that can be made lightly.", "id": "d1tyhwj"}, {"comment": "Honestly they have a better chance to switch to C# since the language is open standards and the runtimes and libraries are MIT licensed. The language is also more similar to Java than swift.", "id": "d1u5hna"}], [{"comment": "DO IT DAMMIT!  I hate Java with a passion.", "id": "d1tzg9s"}, {"comment": "Why? :/", "id": "d1u5w5y"}, {"comment": "on a mobile device, a language that uses garbage collection and doesn't provide many options to avoid creating objects can be problematic because memory is more constrained and cpu performance is a bit lower. You can avoid these performance pitfalls but it is more cumbersome to do so than in some other languages, sometimes.\n", "id": "d1uhnjz"}, {"comment": "> because memory is more constrained and cpu performance is a bit lower.\n\nAndroid phones usually have more than sufficient memory. GC has never been a big deal", "id": "d1upsd6"}, {"comment": "Sufficient until it isn't. Either you didn't work on something that needed a lot of memory, or you are used to coding in a way to not create a lot of objects and overhead. Like I said, it isn't that you can't create super efficient Java code, you can. It is just sometimes more cumbersome than it is in other languages.\n", "id": "d1uu00u"}, {"comment": "You're not wrong, I didn't thought about this issues", "id": "d1v9071"}]]], "4t8vrd": ["Your license to use React.js can be revoked if you compete with Facebook", "2016-07-17 12:43:51", 21, "http://react-etc.net/entry/your-license-to-use-react-js-can-be-revoked-if-you-compete-with-facebook", [[78, "I may be misreading the legal language, but it seems to say if you assert patents against Facebook their patent grant terminates. This is very different from the claim that licence terminates for competing against Facebook.\n"], [6, "That's why it is dumb to use projects with funky licenses.\n\nApache and the GPL family have a fair patent retaliation clause. This custom BSD seems really strange.\n\nWe should [stop license proliferation](https://www.youtube.com/watch?v=zxIEDNyZOkA)."], [5, "The really interesting part here is that Google and MS can't use React for this reason. The claim itself is backed up by a video link that I didn't bother to watch at this time."], [1, "This is the best tl;dr I could make, [original](http://react-etc.net/entry/your-license-to-use-react-js-can-be-revoked-if-you-compete-with-facebook) reduced by 82%. (I'm a bot)\n*****\n> If you do take legal actions or in other ways challenge Facebook, your license to use React is immediately revoked.\n\n> Your license is also revoked if you have any legal disputes if you have legal disputes with any other company using React.\n\n> Notwithstanding the foregoing, if Facebook or any of itssubsidiaries or corporate affiliates files a lawsuit alleging patentinfringement against you in the first instance, and you respond by filing apatent infringement counterclaim in that lawsuit against that party that isunrelated to the Software, the license granted hereunder will not terminateunder section of this paragraph due to such counterclaim.\n\n\n*****\n[**Extended Summary**](http://np.reddit.com/r/autotldr/comments/4tegqe/your_license_to_use_reactjs_can_be_revoked_if_you/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ \"Version 1.6, ~80336 tl;drs so far.\") | [Theory](http://np.reddit.com/r/autotldr/comments/31bfht/theory_autotldr_concept/) | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr \"PMs and comment replies are read by the bot admin, constructive feedback is welcome.\") | *Top* *keywords*: **any**^#1 **Software**^#2 **Facebook**^#3 **React**^#4 **patent**^#5"]], [[{"comment": "I may be misreading the legal language, but it seems to say if you assert patents against Facebook their patent grant terminates. This is very different from the claim that licence terminates for competing against Facebook.\n", "id": "d5fgs9s"}, {"comment": "That's my reading of it too. Not a lawyer.\n\n[Don't we have enough real problems to be outraged about without making stuff up?]", "id": "d5fhryu"}, {"comment": "Right, so if you depend on React you effectively (and implicitly) give them a license to all of your patents. It's certainly going to make competing with Facebook trickier, especially for large companies (where the consequences are much more difficult to oversee).", "id": "d5fl785"}, {"comment": "I wish the title was more along the lines of \"if you depend on React you effectively (and implicitly) give Facebook a license to all of your patents\". It would be as dramatic as the current one but also factually correct as opposed to made up.", "id": "d5fmtpf"}, {"comment": "That's how I understand it as well. The enterprise my employer belongs to has internally prohibited the use of react exactly because of the hypothetical situation that the enterprise may need leverage in a patent dispute against Facebook.", "id": "d5fpnrl"}, {"comment": "Presumably there are FB patents wrapped up in React. The license is a sharing license so a company can use FB patents as long as FB can use the companies patents. If a company wants to go after FB on the basis of patents, then it makes sense for FB to reject the use of FB patents.", "id": "d5fnuja"}, {"comment": "The company can use *React*.  It may not even be patented; they don't point out which patents this refers to.  By contrast, Facebook & affiliates can willfully infringe on *any* of your patents.\n\nYou then have the choice of suing: that terminates your license, and presumably that's a problem for you.  If you're lucky, it turns out there are no React patents (Facebook isn't saying), or maybe the patents aren't critical.  But you never know, and even if you did, huge lawsuits aren't free or risk-free (well, unless you're non-practicing). \n\nOf course, Facebook might be nice and pay for a license. But if they want to make your life difficult, they certainly can.  And don't forget that negotiation outcomes depend on how strong your hand is - even if Facebook plays nice, the fact that both of you know that you can't easily enforce your patents is going to depress the price.\n\nAll in all: that patent license isn't in the spirit of open source. It covers patents \"necessarily\" infringed by React \"standing alone\".  But react is a framework, not a standalone application. Combinations are explicitly excluded - so an application *using* react may not be covered, even if it's clearly doing things \"supported\" by React, so long as the patent covers things enabled by but not actually part of react.  And it's easy to imagine software patterns that an app uses but the framework supporting it does not. It's also not clear to me whether you can sub-license - so forks may not be possible if Facebook's OSS strategy changes, because while *your* license is irrevocable, it's not clear to me whether people you transfer the software too (explicitly allowed) get that same license.", "id": "d5fxazh"}, {"comment": "I went and read it, not a lawyer. But I thought the same thing.", "id": "d5fhpoc"}, {"comment": "I remember having read an analysis of this part of the licence before, and I believe they came to the same conclusion as well.", "id": "d5fl00d"}], [{"comment": "That's why it is dumb to use projects with funky licenses.\n\nApache and the GPL family have a fair patent retaliation clause. This custom BSD seems really strange.\n\nWe should [stop license proliferation](https://www.youtube.com/watch?v=zxIEDNyZOkA).", "id": "d5glpic"}], [{"comment": "The really interesting part here is that Google and MS can't use React for this reason. The claim itself is backed up by a video link that I didn't bother to watch at this time.", "id": "d5fltd5"}, {"comment": "Why would they use it? Google is heavily invested in their own front end framework. I doubt that patent line is the deciding factor for either company.", "id": "d5fo3wv"}, {"comment": "I work on the YouTube Gaming site. When the project was starting we had to exclude React from the list of possible libraries to use because of the license. They decided on Polymer right after I joined.\n\nWe very well could have used React. We had team members already familiar with it, and no one was familiar with Polymer.", "id": "d5g41su"}, {"comment": "Was the project started with the former license? Reacts previous patent grant was far more ambiguous then the current one. ", "id": "d5g588b"}, {"comment": "I'm not sure which license caused this decision. Sorry.", "id": "d5gi0zw"}, {"comment": "Microsoft have been working on a react for windows, windows phone doesn't it apply in this case as well?", "id": "d5g8lqz"}, {"comment": "MS is officially supporting react native for Universal Windows Platform (i.e. it will run on almost everything MS sells), so they don't seem to concerned.\n\nhttps://blogs.windows.com/buildingapps/2016/04/13/react-native-on-the-universal-windows-platform/", "id": "d5gahy7"}], [{"comment": "This is the best tl;dr I could make, [original](http://react-etc.net/entry/your-license-to-use-react-js-can-be-revoked-if-you-compete-with-facebook) reduced by 82%. (I'm a bot)\n*****\n> If you do take legal actions or in other ways challenge Facebook, your license to use React is immediately revoked.\n\n> Your license is also revoked if you have any legal disputes if you have legal disputes with any other company using React.\n\n> Notwithstanding the foregoing, if Facebook or any of itssubsidiaries or corporate affiliates files a lawsuit alleging patentinfringement against you in the first instance, and you respond by filing apatent infringement counterclaim in that lawsuit against that party that isunrelated to the Software, the license granted hereunder will not terminateunder section of this paragraph due to such counterclaim.\n\n\n*****\n[**Extended Summary**](http://np.reddit.com/r/autotldr/comments/4tegqe/your_license_to_use_reactjs_can_be_revoked_if_you/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ \"Version 1.6, ~80336 tl;drs so far.\") | [Theory](http://np.reddit.com/r/autotldr/comments/31bfht/theory_autotldr_concept/) | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr \"PMs and comment replies are read by the bot admin, constructive feedback is welcome.\") | *Top* *keywords*: **any**^#1 **Software**^#2 **Facebook**^#3 **React**^#4 **patent**^#5", "id": "d5gn30j"}]]], "4y44b2": ["Microsoft Patents Whitespace", "2016-08-17 10:21:34", 0, "http://appft1.uspto.gov/netacgi/nph-Parser?Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=1&f=G&l=50&s1=%2220060089942%22.PGNR.&OS=DN/20060089942&RS=DN/20060089942", [[17, "First, this is not a patent.  It's an application for a patent.  Big difference.\n\nSecond, the application is related to generating tokens and not to an actual whitespace as your title and comments posted here suggest.\n\n\"The subject invention relates to systems and/or methods that facilitate expanding keywords within an existing programming language by employing whitespace keywords containing an embedded whitespace. By utilizing whitespace keywords, the subject invention mitigates complications involved with selecting identifiers. For example, C++ Standard can be expanding within Common Language Runtime (CLR) by employing whitespace keywords. A whitespace keyword is a single token containing embedded whitespace by a lexer. Thus, programs having a type, variable or namespace identical to an adjacent token are entirely unaffected.\"\n\n"], [11, "It's 2016. Are we *still* misrepresenting patents to stir up shit?"], [8, "Not sure if I managed to deobfuscate lawyer's bullshit correctly, but here is my interpretation.\n\nIn C# 1.0, they did not have `yield` as a reserved word. This means that they were unable to simply make it a keyword when they were adding generators (existing programs that use `yield` as an identifier would break). So instead they assigned `yield` special meaning only if it is followed by `return`. In a sense, `yield` is not a keyword, but `yield return` is. Visual Studio highlights it as such, for instance.\n\nThis idea is simple, but certainly not trivial. If provides a sensible way to extend a language while maintaining backward compatibility. Whoever came up with it totally deserves credit for ingenuity. Language designers would benefit from knowing about this trick. However, it's not the kind of idea that requires millions of dollars in research to produce, so I don't think it should be protected by a patent.\n\nI'm not aware if there is any prior art. `signed int` does not qualify, because both `signed` and `int` are already keywords."], [1, "There's an awful lot of patentese here but I think what they are patenting is (some aspect of) keywords that may (or must?) include white space. So, \"window\" and \"procedure\" may not be keywords but \"window[ \\t\\r\\n]+procedure\" is. And there could be comments between window and procedure. It also looks like the result is a keyword \"window procedure\" where the space(s) are in a particular required place although some of the patent runs them together (\"ref class\" -> \"refclass\").\nWhile some older languages had multi-word keywords (Ada's \"and then\", for example), the following claims may restrict the patent to areas (such as C++ on CLR) where this is a novel technique."], [2, "I prefer tabs anyway."], [1, "How is there so much text in this document? "], [3, "\"Whitespace\" chosen to be inflammatory; what this describes so far as I can see is the use of non-visible characters to prevent visual clutter whilst preventing namespace conflicts for type names "], [1, "At first it looks like GCC would have prior art of this. It replaces comments by whitespace.\n\nOr wait.. this is not about replacing stuff with whitespace. Rather it's about introducing keywords that span across whitespace?\n\nSo you could have a keyword such as \"microsoft fail\" and it would be read in combination. It's not done in earlier languages because having multi-word keywords is a stupid idea mostly. Besides then there would be prior art in Python, which has syntax \"not in\", though this is two tokens that merge by context free grammar and not one token merged by tokenizer."]], [[{"comment": "First, this is not a patent.  It's an application for a patent.  Big difference.\n\nSecond, the application is related to generating tokens and not to an actual whitespace as your title and comments posted here suggest.\n\n\"The subject invention relates to systems and/or methods that facilitate expanding keywords within an existing programming language by employing whitespace keywords containing an embedded whitespace. By utilizing whitespace keywords, the subject invention mitigates complications involved with selecting identifiers. For example, C++ Standard can be expanding within Common Language Runtime (CLR) by employing whitespace keywords. A whitespace keyword is a single token containing embedded whitespace by a lexer. Thus, programs having a type, variable or namespace identical to an adjacent token are entirely unaffected.\"\n\n", "id": "d6kukbi"}, {"comment": "It's still trivial. \n", "id": "d6kwgsr"}, {"comment": "It's still fucking *bullshit*. There's nothing innovative here.", "id": "d6kvb53"}, {"comment": ">There's nothing innovative here.\n\nYou would have to find a publication prior to Oct 22, 2004 showing this.  Although claiming \"bullshit\" may seem like a sufficient argument, it is not.", "id": "d6kvfff"}, {"comment": "If I read the summary correctly, its essentially patenting annotations. So javadoc and similar probably would cover it.", "id": "d6kwh4c"}, {"comment": "You read the summary incorrectly.\n\nThis is a patent for \"yield return\" being a keyword while \"yield\" is not a keyword.", "id": "d6l7f83"}, {"comment": "Javadoc does not require AI for markup.  The issued patent requires this feature.\n", "id": "d6kwmp0"}, {"comment": "Wut? \n\n\nI mean: does \"AI\" mean \"Artificial Intelligence\" here, and where does the patent *require* \"AI\", whatever it means here?  \n\n", "id": "d6l0072"}, {"comment": "AI as well as other features are required in the claims of the issued patent.", "id": "d6l01pf"}, {"comment": "IANA(P)L, but is claim 13 required to be covered by the patent? As fasr as I understand, if a system is covered by claim 1, it is already covered by the patent, and claim 13 would maske clear that the (optional) use of an AI would *also* be covered\u00b4by the patent. ", "id": "d6l138h"}, {"comment": "You are looking at the claims in the application.  You need to look at the claims in the issued patent.  An application for a patent is not the same as a patent.", "id": "d6l175b"}, {"comment": "C'mon now - I do appreciate your - certainly uphill - battle against misrepresentation of patents. but that's just dismissive. \n\n*If the issued patent had the same claims as the application...*", "id": "d6l4wle"}, {"comment": "No you don't. There doesn't have to be prior art if the thing being patented is not sufficiently innovative.\n\nThere is **nothing** innovative here. It's straightforward programming.", "id": "d6kzd78"}, {"comment": "> There doesn't have to be prior art if the thing being patented is not sufficiently innovative.\n\nThis is called \"official notice\".  It is rarely used and even less rarely supported by the courts.  You almost always have to find a reference to support your argument.\n\n\u201cFor example, assertions of technical facts in the areas of esoteric technology or specific knowledge of the prior art must always be supported by citation to some reference work recognized as standard in the pertinent art. In re Ahlert, 424 F.2d at 1091, 165 USPQ at 420-21", "id": "d6kzi9r"}, {"comment": "You're just blathering. What you're saying is meaningless. \n\nThe fact of the matter is that there is a lot more to patents than prior art. Something can be NEW and not done before and not be patentable. It needs to be SUFFICIENTLY NON-OBVIOUS. ", "id": "d6m59o5"}, {"comment": "I cited from the United States Patent Quarterly and a federal patent law decision.  Versus you, who merely capitalized a few words in their sentence.  Gee, I wonder which one of us is correct?", "id": "d6maczu"}, {"comment": "You cited something completely unrelated. ", "id": "d6mazzn"}, {"comment": "And you've cited absolutely nothing.  Who do you think a judge would believe?  The person citing federal case law or the person screaming like an idiot?", "id": "d6mb3el"}, {"comment": "This isn't a court room. I don't need to cite anything, because I'm not writing a paper. You're citing IRRELEVANT case law, as I have said. Judges aren't going to 'believe' anyone. Judges don't listen and then decide who the 'believe'. \n\nDo you have any idea how the legal system works? Do you actually know what the requirements for a patent are?", "id": "d6mbh4g"}, {"comment": ">You would have to find a publication prior to Oct 22, 2004 showing this.\n\nOnly if he's claiming that the patent application shouldn't be granted based on current legal precedent and patent office practice. There's a good case for it being not innovative and bullshit, it's just that the law and the patent office don't really care. \n\n", "id": "d6lkknc"}, {"comment": "I have no idea what you are talking about.", "id": "d6lm0gk"}, {"comment": "Yours is not a constructive argument. You trust that the reddit community is too lazy to find such a publication.\n\nCompiler writing is almost as old as programming and there have been countless books on it. Tokenizing is in every one of them. I am pretty sure that some book or speech transcript or whatever mentions having whitespace as a token.\n\nThen there is the question whether a token containing non-executable data is any good. At least it would slow down compiles.", "id": "d6kwxf2"}, {"comment": "> Yours is not a constructive argument.\n\nRegardless of your opinion of my argument, it is the law.  This is the burden every patent examiner is required to meet.  And they are given little time to meet that burden.\n\nI agree Reddit is too lazy/unqualified to judge this patent application.  Considering most, including OP, don't know the difference between an application and an issued patent.\n\nHindsight is always 20/20.", "id": "d6kxsji"}, {"comment": "> This is the burden every patent examiner is required to meet. And they are given little time to meet that burden.\n\nThat's why this was created:\n\nhttp://patents.stackexchange.com/\n\nMost patents are granted without sufficient research (not the patent examiners fault, there are simply WAY too many applications) so this site was created as a way to crowdsource finding prior art, and hopefully negating the patent (hopefully while still in an application phase)", "id": "d6l3e8n"}, {"comment": "Hey, thanks for this link.  I wasn't aware stackexchange was doing this.  There have already been 352 requests for prior art.  This is probably the best way the community can get involved.  \n\nIt's not just that there are too many applications.  It has more to do with the amount of prior art that must be considered as well as searching for good prior art.", "id": "d6l3q2s"}, {"comment": "Software patents are also notoriously bad for being overly general. And the amount of patent applications is overwhelming\n\nhttps://www.uspto.gov/web/offices/ac/ido/oeip/taf/h_counts.htm\n\nThe amount of applications has doubled since 2000, which had doubled the amount since the 90s. The last time it spiked was in 1930, (which was when sliced bread was invented!)\n\n[John Oliver does a good piece on patents (specifically patent trolls)](https://www.youtube.com/watch?v=3bxcc3SM_KA)", "id": "d6le02o"}, {"comment": "With the WTO and WIPO, the USPTO is receiving applications from all over the world.  That is a major factor for the increased number of application.\n\nSince the USPTO has limited space at the Alexandria, VA office and no room to expand, they have decided to open offices around the country.  They also have a program for experienced examiners to work from home.\n\nConcerning the patent trolls, the AIA has addressed parts of this problem.  If you are sued by a troll, and the troll loses in court, the person/company that was sued can now recover full damages, court costs and attorney fees.  This has made the trolls business model significantly less profitable and more risky.\n\nThere will always be loopholes, and there will always be games people play.  But it does seem like the USPTO has been quick to address these concerns.  And it's one of the few instance where both political parties have worked together to write new laws closing the loopholes.", "id": "d6ledv5"}, {"comment": "> If you are sued by a troll, and the troll loses in court, the person/company that was sued can now recover full damages, court costs and attorney fees. This has made the trolls business model significantly less profitable and more risky.\n\nFantastic. That's like the innovation act John Oliver was referring to?\n\nI'm glad that the patent office is addressing problems. I think the stackexchange crowdsourcing is a great idea, and I hope that that community works well with the patent office to ensure that only valid patents get through. I would also love to see smaller, better scoped patents get preferred. As it stands it seems the best strategy for patents is to make it as general as you can possibly get away with.", "id": "d6lglfv"}, {"comment": "[deleted]", "id": "d6kzdj3"}, {"comment": ">Python uses white space tokens to determine lexiconal scope.\n\nThat's not what's being claimed.", "id": "d6kzepu"}, {"comment": "[deleted]", "id": "d6kztfr"}, {"comment": ">What's being patented is that white space can be a token during parsing. \n\nThat's not what's being claimed in the issued patent.", "id": "d6kzvy3"}, {"comment": "Yet nobody has still managed to point out a single language that already does this.\n\nYou have a definition of \"innovative\" that does not include \"doing things nobody else has done before\"?", "id": "d6l7did"}, {"comment": "> \"doing things nobody else has done before\"?\n\n... is necessary but not sufficient for something being innovative.  The things also need to be sufficiently advanced, creative, or non-trivial.\n", "id": "d6ljhij"}, {"comment": "> First, this is not a patent. It's an application for a patent. Big difference.\n\n\nDo you think the patent grant is much different? https://www.google.com/patents/US7496889\n\nYou quote a large section from the patent application, but the important section is the 'claims,' especially the independent claims.\n", "id": "d6kv2y4"}, {"comment": "> Do you think the patent grant is much different?\n\nYes, I do.  The claims in the issued patent are significantly more narrow than the application.", "id": "d6kv5uj"}, {"comment": "So they're talking about seperating words based on if they're split on word boundaries?\n\n1: This is ancient and obvious to literally every programmer in the world.\n\n2: How the hell do they hope to enforce that? I mean, I myself have prior-fucking-art, let alone everyone else.\n\nNGL I kinda feel betrayed that they'd even attempt such a thing.", "id": "d6l0str"}, {"comment": "No, they are talking about creating keywords in a language from multiple words separated by whitespace, without the component words themselves being keywords.\n\nThis is useful when wanting to add new keywords to an existing language without breaking existing programs (e.g. a program written for C# 1.0 with a variable `float yield = 1.5` doesn't need to change in C# 4.5 which uses the keyword `yield return` - you can even say `yield return yield;` without any amibguity).\n\nI have no idea if there is prior art for this or not, but it's certainly not used in other mainstream programming languages. \n\nIt might still be trivial, but it's not simply about tokenizing based on whitespace, but almost the opposite.", "id": "d6l258n"}], [{"comment": "It's 2016. Are we *still* misrepresenting patents to stir up shit?", "id": "d6kuyrs"}, {"comment": "It's 2016. Are we *still* shamelessly spamming the patent office with pedestrian crap? \"Keywords with white space\" is well below the bar (and not particularly novel).", "id": "d6l6oac"}, {"comment": "Nothing is being misrepresented.", "id": "d6kvawf"}, {"comment": "Really? \"Microsoft patents whitespace\"?\n\n", "id": "d6kvmoj"}], [{"comment": "Not sure if I managed to deobfuscate lawyer's bullshit correctly, but here is my interpretation.\n\nIn C# 1.0, they did not have `yield` as a reserved word. This means that they were unable to simply make it a keyword when they were adding generators (existing programs that use `yield` as an identifier would break). So instead they assigned `yield` special meaning only if it is followed by `return`. In a sense, `yield` is not a keyword, but `yield return` is. Visual Studio highlights it as such, for instance.\n\nThis idea is simple, but certainly not trivial. If provides a sensible way to extend a language while maintaining backward compatibility. Whoever came up with it totally deserves credit for ingenuity. Language designers would benefit from knowing about this trick. However, it's not the kind of idea that requires millions of dollars in research to produce, so I don't think it should be protected by a patent.\n\nI'm not aware if there is any prior art. `signed int` does not qualify, because both `signed` and `int` are already keywords.", "id": "d6kxpzj"}, {"comment": "How about END IF in BASIC?", "id": "d6kyh4k"}, {"comment": "Quite probably, unless `END` is a keyword.", "id": "d6kz7qg"}, {"comment": "C# 1.0 in 2000 already had some contextual keywords: \"get\", \"set\", \"value\", \"add\", \"remove\".\nhttps://blogs.msdn.microsoft.com/ericlippert/2009/05/11/reserved-and-contextual-keywords/\n\nThe date on this patent application is 2006, so Microsoft's own language is prior art for contextual keywords. I think the patent is just claiming the recognition of contextual keywords during lexing instead of parsing.", "id": "d6lw10w"}, {"comment": "I have this idea in Python that explicit tail calls could be done by having `return f(x)` become `return from f(x)` but I guess I don't want to be sued by MS", "id": "d6l1spi"}], [{"comment": "There's an awful lot of patentese here but I think what they are patenting is (some aspect of) keywords that may (or must?) include white space. So, \"window\" and \"procedure\" may not be keywords but \"window[ \\t\\r\\n]+procedure\" is. And there could be comments between window and procedure. It also looks like the result is a keyword \"window procedure\" where the space(s) are in a particular required place although some of the patent runs them together (\"ref class\" -> \"refclass\").\nWhile some older languages had multi-word keywords (Ada's \"and then\", for example), the following claims may restrict the patent to areas (such as C++ on CLR) where this is a novel technique.", "id": "d6kuher"}, {"comment": "Novel? What about `signed char` ?", "id": "d6kwqq7"}, {"comment": "`signed char` is not a keyword - `signed` and `char` are keywords, and they are allowed to follow one another.\n\nIn C# though, `yield return` and `yield continue`are keywords (and so are `yield \\t return` etc.) while `yield` is not. \n\nThis means that I can create a legal C# program that can say `float yield = 1.5;` without any ambiguity, while in C++ `bool signed = false;` would be illegal.", "id": "d6l1yrp"}, {"comment": "Ok, thanks for the explanation. D has used \"contextual keywords\" since 1999. For example, in `extern (Pascal)`, the `Pascal` is an identifier used as a keyword, but only in that context. There are a couple other cases of this in the language, too. The ( ) aren't necessary for this to work, I put them in simply for clarity, and if that is the only novelty in this patent, that's pretty weak.\n\nThe distinction between keyword and identifier in a language is arbitrary, and actually is an innovation that came later. Early versions of FORTRAN, if I recall correctly, distinguished them based on context (the `DO 10 I` is a famous example). I'm no patent lawyer, but I doubt this patent would stand up to a prior art search, and I don't think it is novel or non-obvious.", "id": "d6llxn1"}, {"comment": "You may very well be right about its novelty or the existence of prior art.\n\nStill, this is different from the D and FORTRAN examples you give. This is not about contextual keywords, but about keywords that include whitespace. C# actually has both (`get`, `set`, `value` and a few others are special in some contexts, e.g. in a property's definition).\n\nThe difference between contextual keywords and white-space keywords is slight, but relevant, and it goes to the heart of why keywords are actually useful: any keyword (whether it contains whitespace or not) which is not contextual can be recognized with a trivial regex. Contextual keywords, as the name implies, require some notion of context, usually making them much harder to recognize.\n\nTo illustrate my point, here is a regex for recognizing a few C# keywords, that would actually work for a simple syntax highlighter (except for problems with comments, which technically turn anything into a problem of context): `(using)|(class)|(struct)|(return)|(void)|(yield\\s+return)|(yield\\s+break)`.", "id": "d6mc626"}, {"comment": "I really don't see an interesting difference between that and including a ( ) in addition to whitespace. One could just as well say that `return#C` is novel and patentable. It's patenting trivia.", "id": "d6mcdbx"}, {"comment": "I think the difference here is that in C++, both \"signed\" and \"char\" are independent keywords so become separate tokens that are then combined at parse time instead of being a single lexical token.", "id": "d6l2ex4"}, {"comment": "window procedure <----- a single keyword.\n\nThat is what I understood, too. ", "id": "d6kusi6"}, {"comment": "Me too but I wonder why it's registered.\n\n- scan window: _tokKeyWordWindow_\n- scan procedure: _tokKeyWordProcedure_\n- parsing: if (tok.Id == tokKeyWordWindow && tok.next.Id == tokKeyWordProcedure)...\n\nwhich means that you have the special meaning from the two keywords, no need for a\n_tokKeyWordWindowSpaceProcedure_", "id": "d6kvfz3"}, {"comment": "And that's still complete bullshit.", "id": "d6kvate"}], [{"comment": "I prefer tabs anyway.", "id": "d6l0z4b"}], [{"comment": "How is there so much text in this document? ", "id": "d6ktyyw"}], [{"comment": "\"Whitespace\" chosen to be inflammatory; what this describes so far as I can see is the use of non-visible characters to prevent visual clutter whilst preventing namespace conflicts for type names ", "id": "d6kunj9"}, {"comment": "None of which is patentable.", "id": "d6kvapi"}, {"comment": "It might be for their particular application, but not more widely, though I'm not super familiar with US law (not being American...) soooo yeah I dunno. ", "id": "d6kvvo2"}], [{"comment": "At first it looks like GCC would have prior art of this. It replaces comments by whitespace.\n\nOr wait.. this is not about replacing stuff with whitespace. Rather it's about introducing keywords that span across whitespace?\n\nSo you could have a keyword such as \"microsoft fail\" and it would be read in combination. It's not done in earlier languages because having multi-word keywords is a stupid idea mostly. Besides then there would be prior art in Python, which has syntax \"not in\", though this is two tokens that merge by context free grammar and not one token merged by tokenizer.", "id": "d6kvpob"}, {"comment": "Replacing comments with whitespaces is not what this application is describing.  Here is the first claims from the issued patent:\n\n1. A computer implemented system with a memory that facilitates expanding keywords of an existing computer programming language within an expansion computer programming language, comprising the following computer executable components:\na lexical analyzer that receives code and groups the code into tokens which are parsed;\na whitespace component that creates a whitespace keyword based at least upon a successive comparison of a first adjacent token and a second adjacent token within the code and determining if adjacent tokens are a keyword in the expansion programming language, and replacing the adjacent tokens with the whitespace keyword, wherein the whitespace keyword contains a single token comprising the first and the second tokens with an embedded whitespace, and wherein the whitespace keyword replaces the first adjacent token and the second adjacent token in at least one macro replacement-list; and\nan artificial intelligence component that infers whitespace keyword usage based at least in part upon historic data and user profile.", "id": "d6kvvg6"}, {"comment": "So it's some sort of unreliable (requires computer AI to resolve, and it can get it wrong) snippet macro preprocessor coming before/after of the actual C++ preprocessor?\n\nHmm. That doesn't sound right either. What the heck CLR matters here? It's mentioned in the description.", "id": "d6kvwr6"}, {"comment": "No, it doesn't \"require computer AI to resolve\". It says that AI (among other things) _can_ be employed, i.e. using them won't let you get around this patent and you won't be able to patent it for yourself.", "id": "d6l1pl2"}, {"comment": "> multi-word keywords is a stupid idea mostly. \n\nIt's actually pretty genius if you want to retain backwards compatibility. `yield return` in C# is a keyword, but `yield` is not. That's so that programs written before `yield return` was introduced are not broken with the new compiler. \n\nOf course multi-word keywords are longer to write, but for the sake of backwards compatibility it can be worth it. And \"almost\" multi-word keywords are fairly common, except they are usually keywords on their own. e.g. `INSERT INTO`, `INNER JOIN`, `END IF`, `end function`, `not in`.\n\nEven python could have benefitted from a multi-word keyword. If `else if` had been a keyword (distinct from `else` and `if`) then they wouldn't need to create the `elif` hack.\n\nNote that the important part is that it's not 2 keywords merged together by grammar, it's a single keyword picked up by the tokenizer. This allows the separate words to be used as identifiers.", "id": "d6l4bxv"}]]], "3wu86x": ["Everything You Know About Latency Is Wrong", "2015-12-15 00:42:52", 0, "http://bravenewgeek.com/everything-you-know-about-latency-is-wrong/", [[35, "> Okay, maybe not everything you know about latency is wrong. But now that I have your attention,\n\n\\*Closes tab\\*"], [2, "This was a neat little article."], [2, "Definitely a good article. Don't be off-put by the clickbait name."], [1, "Everything you know about titles is offensive!"]], [[{"comment": "> Okay, maybe not everything you know about latency is wrong. But now that I have your attention,\n\n\\*Closes tab\\*", "id": "cxz5pzm"}, {"comment": "It's actually a pretty good article, the clickbait was unnecessary ", "id": "cxz62lz"}, {"comment": "Fair enough, but I don't like rewarding clickbait.", "id": "cxz78ll"}, {"comment": "Aye, admittedly I would have closed that tab right away too if I hadn't read the comments saying how good the article is beforehand.\n\nInstead I closed the tab when I attempted to scroll down and was greeted with the slowest and jankiest scrolling ever.", "id": "cxz7pnj"}, {"comment": "Understandable though it's not like you're paying money the longer the tab is open.", "id": "cxzj5qd"}, {"comment": "You didn't realize that literally everything you know about latency wasn't wrong before you clicked and read as much?", "id": "cxz872b"}], [{"comment": "This was a neat little article.", "id": "cxz7dol"}], [{"comment": "Definitely a good article. Don't be off-put by the clickbait name.", "id": "cxz9do2"}], [{"comment": "Everything you know about titles is offensive!", "id": "cxzg8h7"}]]], "51qnic": ["This is What Python Beginners Have to Deal With", "2016-09-08 14:33:46", 238, "http://pythonforengineers.com/this-is-what-python-beginners-have-to-deal-with/", [[273, "And as for the `re` library, if OP would only [look at the menu on the left](https://docs.python.org/3/library/re.html#module-re) You would see :\n\n6.2.1. Regular Expression Syntax  \n6.2.2. Module Contents  \n6.2.3. Regular Expression Objects  \n6.2.4. Match Objects  \n6.2.5. Regular Expression Examples  \n\nSo there's example there, not only on \"a dozen blogs written in 2008.\" and they're easy to get to, as well as the listings of the features of the library/module.\n\n**This is a bunch of reposted bull to promote the book sold at the top level domain.**"], [121, "ITT - people who are *not* Python beginners defending Python.\n\nI've been programming for 20 years. In the last couple of years I've played around with Python (mostly because I want SciPy), and he's right. The whole Python ecosystem is where PHP was 5-10 years ago in terms of ease of learning/references.\n\nAnd sure, that's not the be-all and end-all of any language - if it were, I would just have stopped trying to pick up Python at all - but it's important. It means, for example, that I haven't switched to Python for everyday tasks, because it's too painful.\n\nAnd if your answer to the OP is of the form \"do x, then y, then z, honestly I can't see what the problem is, are you retarded or something?\" then congratulations - you're part of the problem."], [72, "The problem installing libraries might be real on windows, but on any half-decent linux distribution, the process is \n\nUsing your package manager:\n\n(1) Install python and pip \n\n(2) Install the libraries you need\n\nIf (2) doesn't exist, install the library from pip.\n\n\nEdit: if you find some documentation that can be improved, Python is easy to contribute to, and the community is very beginner friendly! You can [submit](https://bugs.python.org/) a bug (or even better, a patch). Here are the [instructions](https://docs.python.org/devguide/documenting.html#building-doc) to build the documentation locally, and general instructions for [building python](https://docs.python.org/devguide/setup.html), if you ever need those."], [44, "One of the biggest challenges for me is the formatting of how Python was documented.  It feels like something that was made in a hurry for a quick small side project.  It would have been acceptable if python stayed like that.\n\nI think the content of some of the documentation is satisfactory, but how everything is formatted is god awful.  I'd rather see something like how Qt or Java formats their docs."], [17, "There's a reference in there to an article from 2004 by Yegge where he discusses Python. https://sites.google.com/site/steveyegge2/tour-de-babel\n \nHindsight is great, but Python never overtaking Perl already sounds dubious by 2004. The notion of Ruby taking over from Python practically overnight is also odd -- I have the impression many Rubyists have jumped ship to JavaScript in recent years, but Python seems to be going strong still, even with the whole Python 3 thing.\n\nI can't really make judgements on whether Python people were or are frosty -- not in my experience but who knows."], [13, "I would've thought the main hurdle for new python devs would be 2.x vs 3.x.\n\nHaving new developers choose their major version of choice, and have to double check every library they use for compatibility, seems extremely disconcerting.  Nevermind the fact that it makes it harder to google information about the language and libraries.\n\n(I say this as an outside onlooker)"], [11, "This is what python beginners on WINDOWS have to deal with, because of the cluster-fuck that is CPython+Windows+Numpy+SciPy.\n\nAnaconda is one partial answer.  But forking the CPython tooling ecosystem creates as many new problems as it solves."], [11, "Agreed on all counts. I love Python, but a lot of the documentation/support is quite lacking."], [8, "Am I the only one here to have never had these issues when I started with python? I mean.. A bad dancer is gonna blame his nutsack for getting in the way of him becoming pro.."], [7, "Ranting about compiling libraries, no mention of your OS's package management system (which linux newbies need to learn to work with rather than work around by recompiling stuff from source), or https://pypi.python.org/pypi\n\nAnd as for PHP documentation & libraries? LOL holy shit what is a polluted namespace? And how about we keep garbage comments from 11 years ago right there on the doc page, that are plain **dangerous** to follow for the current PHP 5.6 or 7.0 on the web in 2016...\n\nMeanwhile, OP needs to look again at https://wiki.python.org/moin/BeginnersGuide and https://docs.python.org/3/tutorial/index.html"], [6, "Honestly the lack of good encapsulation and sandboxing, as well as good version management, is easily the worst part to me. I much prefer a package.json to using virtualenv..."], [5, "A Python beginner, I mean someone learning the language shouldn't need non-standard libraries. And even then, I've absolutely never found it to be a problem. Hell, even compiling libraries from scratch isn't that hard. If you're unfamiliar with the process then maybe Python isn't the issue? Maybe someone can explain to me why any of this would be difficult? And for documentation, why not buy a book? There's a lot of cheap ebooks out there. And some random library documentation is lacking? Well welcome to the real world, where everything's made up and the docs don't matter. "], [5, "> No, it\u2019s not you. The documentation really is shit.\n\n...\n\n> As someone who\u2019s used a lot of C/C++,  I am used to simple and easy to use docs\n\nI'd hardly consider sifting through all the overloads \"simple and easy to use\". I like Python's docs way better."], [4, "It's not that bad but of course there are some problems. But I think that it is quite usual for documentation in other languages too. For example that mentioned PHP manual is also not exactly the best. For problems with installing modules. I had this problem only twice. For lxml and for newest version of matplotlib. But luckily for Windows there are unofficial binaries for many of those libraries. Unfortunately finding really great documentation for anything is quite rare. :0("], [4, "I was confused by Python 2 vs Python 3, and when I decided to just try one, it was really hard for me to figure out which documentation was for which version, and there could be like very minor differences, like capitalization on libraries and stuff. :/"], [5, "The author really rags on the documentation, but he doesn't mention anything about how useful the help() function is in Python. In combination with dir() I can explore any module I import, access the docstrings thanks to the help() function, all without having to go online. I don't know any other language that does this.\n\n"], [5, "I was actually going to make a post last night asking for some help on the same exact subject. I normally program in C and C++ but last night I was chatting with some friends on Discord when I realized that they have an API and thought that it would be a neat project to try out and get used to Python with.  \n\nDiscord's page recommended downloading a library for my language's implementation of Oauth2 so I did a search on pip. I thought one of Python's ideas was that there is \"one standard way to do something\" so I was overwhelmed when I saw my terminal explode with search results. \n\nSo instead, I looked up some Python Discord bot examples to get an idea of what libraries they used, and saw one that said to just use Django. I had only heard of Django before so I looked it up and got lost in the documentation. It involved setting up projects and directories and while I don't know Python that well, this seemed like a ridiculous amount of overkill.\n\nI thought I just needed something to get me an authorization token for Discord, and then something that could submit HTTP requests to Discord's API. I don't know how I ended up in this massive loop of searching for libraries and setting up virtualenv or whatever for managing packages instead of actually sitting down and programming."], [4, "I love Python, but as a scientific developer, my time is split between Matlab and Python, and for all its flaws, Matlab is much easier to get started *independently* with than Python, for all of the issues in the post. In particular, setting up scipy/other dependencies is usually fine, but sometimes a nightmare. It's not uncommon for setting up Python to be more difficult than actually writing the program. Part of the issue is the audience though - beginners and scientific users are not the same as career programmers, and for me, Python documentation is *much* harder to use than Matlab documentation. Also, many problems with setting up Python are trivial for someone who is familiar search paths, library paths, compiler selection etc. but are potentially insurmountable otherwise. Personally, I notice that I have much more difficulty setting things up on Windows compared to Linux simply because I'm not nearly as familiar with these things in Windows. This is a significant issue that affects a decent chunk of users (the users that this post is discussing) but the problem is many people in this community refuse to acknowledge that this problem exists - perhaps unsurprisingly, because this community largely consists of people who already know their system inside out, but that's not true of many users. "], [4, "I once gamely followed the instructions of an article that claimed that, there is no reason you should be building websites using PHP, Python and Flask are better and just as easy to get started with.\n\n...several hours of installation/incompatibility hell later, I'd given up. Yes, Python *may* be better. But until it actually \"just works\" - *not* \"works if and only if you know exactly what you're doing\" - PHP's going to retain its edge, I'm genuinely upset to have to say."], [4, "Have I entered some bizarro-zone? When I first started with Python the ease of installing libraries and packages, and the excellent documentation is what made me fall in love with it. To this day those are amongst my top reasons for using Python, well offsetting the language's pitfalls.\n\nThat said setting up numpy on a Windows system sucks, but that's the exception not the rule."], [3, "I agree with some of this, but the majority of it is a non-issue.  I'll counter it piece by piece.\n\n1. **Installing libraries**.  Not something I've ever encountered, and I very frequently deal with building esoteric modules in esoteric ways (I have to distribute wheels for Linux, Windows, and AIX that are bundled with all their dependencies, which all need to be statically compiled when they depend on native libraries).  It sounds like a specific module problem, and that's nowhere near limited to Python.  Any programming language that allows native extensions (which is pretty much every programming language) introduces the possibility of a badly-designed module causing compiler issues.  This is not a fault of the language, but the module author.\n2. **Horrible documentation**.  The documentation could be better, but that's a bad example.  The `re` module has a full set of examples at the bottom and the navbar takes you directly to it.  My biggest issue with the documentation is that return values are specified in the text description.  `findall`, for instance, says \n> Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result unless they touch the beginning of another match.\n\n I'd appreciate if the function signature in the documentation therefore had something like `list[str] | list[tuple[str]]` for every function.  There are plenty of times where I know what a function returns, but don't know the form in which it returns it, or how it returns in certain occasions.  All in all, the documentation is not perfect, but it is quite good.  Leagues behind what is available for C and C++, but it's understandable given how the static nature of C and C++ strongly facilitate documentation generation.\n3. **Horrible Tutorials / Examples in Libraries**. This is a problem with people who write bad documentation, not an issue with the language.  Personally, most of my documentation is a large set of well-commented unit tests, which has the dual advantage of describing how the code will actually work, and is guaranteed to work with the version of the module the tests are part of.  Each concept has a unit test, as well as the interaction of multiple concepts for good coverage and also good documentation.  I don't buy that this is that widespread a problem, given that most libraries I'm familiar with have quite good documentation.\n\nThe worst part is that the author here skips the actual issues with Python.  The biggest issue is that the standard library is horribly disjointed.  Parts are in a functional style, parts are in an object-oriented style, parts are in a procedural (data/function?) oriented style.  Some parts are snake_case, regardless of whether it's a function or a class, parts are PascalCase in the same way.  Some parts are actually badly documented, leading you in some direction when you need something else (the email module has some serious naming and organization issues here, making it difficult to determine what type you need for what).\n\nHe never brings up the issue with Python2 and Python3, where a beginner who may be unaware of these things will have code in a tutorial that doesn't even work for their latest version of Python.\n\nThe article completely misses the mark.  I'm not against Python hatred (or hatred of any language), but criticisms should be based on fact, and if you're criticizing something that causes a barrier for a beginner, you should actually bring up the biggest barriers that hit every single beginner (like Python2/3), not esoteric subjective issues that most people don't even hit."], [2, "I know this is talking about beginners, but\n\n>  No examples. I then have to Google Python regex findall examples, and go through a dozen blogs written in 2008.\n\nAny language is going to give you this problem, there is always going to be one function or another that doesn't have an example (also there was an example, ctrl f etc)\n\n- - -\n\n> `re.findall(pattern, string, flags=0)`\n\nSo I copy paste that into my code, and then go onto following the instructions. I place my pattern into the `pattern` slot, my string into the `string` slot, and either leave flags alone, or understand that its referring to the syntax for defaults, and remove it.\n\nIt seems geared towards mindful consumption, not mindless consumption, but that is just how I view it and I'm pretty sure my view is wrong though"], [2, "I'm surprised not to have noticed any mentions of the new [Stack Overflow Documentation](http://stackoverflow.com/documentation/python/topics) initiative, which is literally designed to improve and standardise documentation for people learning new languages or frameworks.\n\nAs someone who has only had very minor exposure to Python (and did so before Python 3), can anyone comment on how useful the platform appears to be at solving the OP's complaints?"], [3, "Suggestion: make a pull-req to the docs instead of writing this kind of bullshit. Bad documentation? Compared to what? \nAs someone else said above, this is clickbaiting for selling their book."], [2, "[deleted]"], [2, "The API documentation is... API documentation. It's for use as a reference, although some have good examples. There are some incomplete ones, like the multiprocessing page that doesn't mention the threading-based pool that the module includes as an alternative to its multiprocessing-based one.\n\nIn general, when I'm looking into a standard library that I haven't used before, I look at its PyMOTW page. These pages usually appear pretty high up on Google and usually have plenty of examples to get you going. You can then turn to the documentation for reference on specifics.\n\nWhen I first learned Python almost 10 years ago, the only problem I had was that all the guides were geared towards new devs. There were no \"you've been programming for a long time, here's a quick overview on how to accomplish basic tasks in Python and structure your programs\". I'm currently having that problem with Scala, in which *every single guide* assumes that I've never used a functional programming language and spends 90% of its time on that.\n\nA lot of this article is bullshit though.\n\n\"You know who uses simple, self contained examples and tutorials? Every. Other. Language. In. The. World.\"\n\nNonsense. There are plenty of Python ones that do and plenty of guides in other languages that don't. This really seems like a bias resulting in the author thinking that Python is unique simply because it was causing the most pain for him at that moment.\n\nI've picked up many, many languages over my life and will pick up many more. Python was nowhere near the hardest or had the worst community (I reserve that for the JavaScript tutorials that go over pages of build systems and dependencies to get to a hello world example for something). He mentioned PEP 8 and other PEP adherence at the end like it's a terrible thing. Thing is, I'll never shit on someone's code for not following PEP 8 or other standards, and I frequently disregard certain aspects (I use 120 width columns instead of 80). But having a community accepted style guide, along with [guides like these](https://jeffknupp.com/blog/2013/08/16/open-sourcing-a-python-project-the-right-way/) means that it's so much easier to read code written by people who follow them. The whole \"blind fanatical adherence to the church of PEP 8\" is an old strawman."], [2, "I don't see which beginners the OP is talking about. At one end, you have people who know how to program in other languages. These people would be used to the fact that documentation for a programming language won't make perfect sense until one has internalized the mindset for using that language. At the other end are total beginners to programming, who nobody would expect to be able to use any reference documentation.\n\nThis reminds me of the anecdotal managers long ago who expected programmers to do what they were told and do it fast, because it's \"just typing\". Do people expect programming to be easy?"], [2, "I gave up Python because of how bad the official site is. Java and C all the way. I want to love Python because of how easy it seems. But the docs are just crap, and that has a lot to do with how good language ends up being. "], [0, "By far the worst part is the official documentation. But I guess at least there's a stackoverflow for literally anything you can imagine about python."], [1, "Puppies? I'm learning python! "], [1, "Love Python, hate the documentation. Its woeful compared to other languages. Just a basic example with what the function expects and returns is all that's needed."], [1, "I completely disagree. The [Anaconda Python Distribution](https://www.continuum.io/downloads) makes it quite easily to setup and use (there are many others too, like [ActiveState Python](https://www.activestate.com/activepython) or [Python XY](https://python-xy.github.io/)) and there are quite a lot of good tutorials for python ([ZetCode](http://zetcode.com/) or [Invent With Python](http://inventwithpython.com/chapters/) for example). Also not sure where you're getting horrible docs for python from, but the official ones are quite nice to work with and easily searchable."], [1, "'pip install -r requirements.txt'\nCan't be much simpler imo. \n\nOh, and fuck php that inconsistent buggy piece of shit.\n"], [1, "lol python is half assed scripting language that got used outside it's scope. it's best for small throw away unix scripts. oh well, you people are the reason we can't have nice things but now we have broken brittle python infrastructure to deal with, smh."], [1, "the nonstop whining that came from that python documentation post is really amazing considering no one else had said anything prior to that point, and while learning i had no problem with using the documentation especially compared to C++ docs the author mentions\n\nlike seriously it just never stops with people doing shitty blog posts with meme names \"Le Python Is Le Bad, ANd U should FEel Le BAD!!!\", it's like these people want the document to be self morphing so they can just copy paste code and have scripts build themselves"], [1, ">The web service to this account has been limited temporarily!\n\nMirrors?\n\nFound Google Cache!"], [1, "I had all these library problems when using windows 10, now that I use Ubuntu Mate, it's so much better but I still end up googling some problems from time to time, which I'm okay with. "], [1, "Since it specifically refers to contemporaneous events, it's a big problem that this article isn't dated. Is this information still accurate at all?\n"], [1, "I haven't read the article but its thumbnail is a cut husky puppy being given a tummy rub... If that's what beginner programmers get then I'm going to have to unlearn Python. "], [1, "I have just recently started with Python, but haven't experienced this. I totally feel like a noob, yes, but somewhere deep down I enjoy it. Also I think it's pretty rewarding to make it work after long minutes of troubleshooting."], [1, "I only looked at the puppy. What did the article say?"], [1, "I have been programming in python for a few years, I am not a beginner but recently I have been feeling like a beginner as I am trying to learn \"proper\" (aka pythonic) web development with flask.  \n\nThe documentation is what is frustrating me.  It's hit and miss, it's often missing a lot of key information and one of the first things I look for is *examples* of code which are never easy to find.\n\nMore specific example is I am working on the reset password portion of my website.  I've already used Flask-Login for login management.  I find many packages and settle with Flask-Security as it look's the easiest to use.  It promises a number of different functions (such as resetting passwords) but doesn't show how to use them.  I learn after digging that just by going `security = Security(app)` in my code all these features are turned on.  Great so now I have 2 logins, I have a registration form in a way that I don't want.  I can't figure out how to turn off some of these features and I can't find out how to integrate them into my already existing layouts.\n\nI find myself more often than not looking at StackOverflow and Github code for examples to get python modules to work as the docs generally result in the last place I want to look.\n"], [1, "I recently picked up Python and haven't had anywhere near the trouble that this guy had. I haven't experienced any trouble with libraries and while the docs aren't very good (I didn't think PHP docs were much better though) Python is so popular it's not hard to find better documentation and examples elsewhere on the internet.\n\nI chose Python as one my two main languages of choice, the other being Rust.\n\nCan everybody just move to Python 3 please?"], [1, "[deleted]"], [1, "If you are a beginner on linux, you install libraries solely by `apt install python3-libname`. And they just work."], [1, "I've been having a blast with python. Visual Studio tools python and stackoverflow documentation is an amazing combination "], [1, "Is this satire? Blaming Python for the author's decision to do everything manually instead of using a package manager was silly, but I had to actually stop reading when it praised the PHP documentation."], [1, "Installing libraries in Python involves running the `pip` command. If it needs to compile code, it might fail due to a missing library or mismatched version of something, which sucks and is frustrating. A C++ newbie who needs to use a library will need to learn how to link against it and how to get their IDE to do auto-completion. A newcomer to Java will need to mess with their Eclipse Build Path or Maven (ugh) or something.\n\nThe Python official documentation is of varying quality. Generally I find that it works nicely as a written tutorial, but it sucks as a reference. An example is given of the `len` function, documentation for which resides in a page about *all* the builtin functions. Conversely, if you were to try to learn how to use a list, then the official tutorial is a great place to start. I believe this is entirely a non-issue since if you google \"python list length\" you'll get the result in the Google blurb.\n\nAs to providing bad documentation for libraries as an ideology, all I can say is that I've never once encountered that. Naturally I've only tried to use a tiny fraction of the Python libraries. Any concrete examples?\n\ntl;dr: The Python official documentation sucks if you want to use it as a reference. Therefore you should use Google as a Python reference, and the official documentation for module overviews and tutorials."], [1, "Number 1 is a problem for a lot of languages.\n\nI would say another very big issue when starting out with any new language or framework is the setup and configuration. And a lot of it ties back to the problem of dependant libraries.\n\nI feel that in most cases the developers/authors of any particular framework, live in this strange ideal world, where they only use their framework, and nothing else, on their machine. Like everything just works because that's all it does.\n\nIn reality we get conflicts, we don't have access to old versions of specific libraries, we have to run specific versions of other tools to do other functions.\n\nI find I spend more time setting up my environment to start work, than I do working, in a lot of cases.\n\nI feel there needs to be more effort put into providing turn-key frameworks. Download a installation package, double click it and it'll install and setup everything you need to use that framework. Think of how quick it is to get into writing code in Visual Studio or Eclipse (well... kinda), after installation, you really just click \"new\" and you're up and running, nothing else to configure, it just works."], [1, "From http://cryto.net/~joepie91/blog/2013/02/19/the-python-documentation-is-bad-and-you-should-feel-bad/\n\n> If you do something in a less-than-optimal way, other Python developers will shout about how horrible you are without bothering to explain much about what you did wrong.\n\nThis is totally true. When people want to bash LPTHW they just show you this link:\n\nhttp://sopython.com/wiki/LPTHW_Complaints\n\nThis fanboyism really annoys me."], [1, "I can only agree with OP. It is OK to write a 100 loc script in Python relying only on standard library, when in need of something larger - choose a serious language.\nI learned Java after Python and I love it. Granted IDE really helps and makes coding in Java a delight.\nAlso I find it really hard to read other people code in Python (not so with Java), I suspect dynamic typing is to blame."]], [[{"comment": "And as for the `re` library, if OP would only [look at the menu on the left](https://docs.python.org/3/library/re.html#module-re) You would see :\n\n6.2.1. Regular Expression Syntax  \n6.2.2. Module Contents  \n6.2.3. Regular Expression Objects  \n6.2.4. Match Objects  \n6.2.5. Regular Expression Examples  \n\nSo there's example there, not only on \"a dozen blogs written in 2008.\" and they're easy to get to, as well as the listings of the features of the library/module.\n\n**This is a bunch of reposted bull to promote the book sold at the top level domain.**", "id": "d7e3c6l"}, {"comment": "Yeah, that actually surprises me. At worst, you have to search for a specific function in the module docs (if you're a dolt like me who misses stuff on the side menu). And Python docs *do* have examples.", "id": "d7e3rfl"}, {"comment": "Python docs have awesone, complete examples. The only docs I've seen with better are PHP docs. ", "id": "d7e6pxq"}, {"comment": "MDN is fantastic as well. ", "id": "d7er3hd"}, {"comment": "MDN is really great, I seriously appreciate all the contributors.", "id": "d7f7qk2"}, {"comment": "Rust has the best docs imo. Examples of all the common places people go wrong as well. ", "id": "d7ejsnk"}, {"comment": "I don't use CL anymore, but I miss using the [CLHS](http://www.lispworks.com/documentation/lw70/CLHS/Front/index.htm).", "id": "d7f3zvu"}, {"comment": "Granted this wasn't the best example.. however:\n\nYou can't ctrl-f to something if you don't know what it's called. Is it count? len? elem_count? elements? elems? items? contains? If you already know the specific function you need, you're not really a beginner.\n\nI've spent hours looking through these long pages to find what I actually needed. ", "id": "d7evm7z"}, {"comment": "So look through it with your eyes.", "id": "d7f1mf8"}, {"comment": "So many new devs expect the docs to be written for them specifically.  No matter how much time is invested in the docs nobody can take into account how varied the backgrounds of the readers will be.  Docs have to be written assuming some baseline of knowledge (otherwise the would be a tutorial).  At some point you have to sit down and figure shit out, that's the difference between being a programmer and a user.\n\nIf you are new and struggling with python you should:\n\n* Fire up a repl, it's awesome for trying stuff out (just type python on the command line).  If you're curious about how something behaves it's a low cost way to try out a bunch of things before writing anything to a file.\n\n* Get comfortable with the [dir](https://docs.python.org/2/library/functions.html#dir) function, it's helpful for inspecting what functions are available on an unfamiliar object.\n\n* Speaking of help, the [help](https://docs.python.org/2/library/functions.html#help) function is useful for manpage style docs on just about anything.\n\nHelp on a list shows two things (re: gp's comment):\n\n    help([])\n    count(...)\n    L.count(value) -> integer -- return number of occurrences of value\n    ...\n     __len__(...)\n     x.__len__() <==> len(x)\n\nWhich should point someone unfamiliar with lists towards len over count.\n\nDocs authors have to assume a basic level of understanding, and a beginner would do well to know at least everything in the [basic functions list](https://docs.python.org/2/library/functions.html) before getting enraged over \"awful documentation\".  Knowing how to manipulate all of the basic data structures in a language should be your first step when getting started.", "id": "d7fafvd"}, {"comment": "I was really confused by this article. IMO Python is one of the easiest languages for a beginner to work with, and actually I've recommended it to several beginners who have done really well with it.  \n  \nThe docs are more than adequate. For an example of documentation that is actually bad for beginners, the author should check out [the java docs](https://docs.oracle.com/javase/7/docs/api/java/util/regex/package-summary.html). \"An excellent tutorial and overview of regular expressions is [link to paper book published in 1997].\"  \n  \nJava was the first programming language I learned, and I was literally pulling my hair out. In contrast, learning python was a zen-like experience for me. ", "id": "d7en9ln"}, {"comment": "The author also conflated Python difficulties with Linux difficulties.  Yes, they can both make life difficult for the beginner, but some of that can't be avoided and/or is an issue with a given library; not necessarily Python.", "id": "d7epuwb"}, {"comment": "Yeah, this article made no sense.  He's talking about how pip can't install dependancies.  Yes, it can.  \n\nPython is so easy, children can use it.  There is no need for the book OP is selling.  Just google any error and you have your answer.   ", "id": "d7eptte"}, {"comment": "Well, the article makes a lot of *sense* when you know the context. It's just *wrong*. The author's pushing the agenda that benefits himself.\n\nUse Python to Become AWESOME at your job eBook + Videos costs $99.", "id": "d7fh7jb"}, {"comment": "You mean [this](https://i.imgur.com/7nlGshO.png)? One of the worst navigation menus I have seen. What's with the numbers?\n\nAlso why is documentation for entire module squeezed onto single page?\n\nWhere is list of module classes functions and constants, so you can easily go to section you need?\n\nWhy is every section so badly divided? It's almost impossible to see where one section ends and next begins.\n\nLet's face it, python documentation is badly designed at best.\n", "id": "d7e6kzq"}, {"comment": ">What's with the numbers?\n\nFor easy reference, like any proper documentation.\n\n>Also why is documentation for entire module squeezed onto single page?\n\nBecause pagination is best determined by the the viewer, not the origin? That which fits on 1 portrait desktop monitor might take 4 or more phone/tablet screens to be as legible. Welcome to HTML & virtual documents rather than a printed medium?\n\n>Where is list of module classes functions and constants, so you can easily go to section you need?\n\nThe module contents? [6.2.2. Module Contents](https://docs.python.org/3/library/re.html#module-contents)\n\n>Why is every section so badly divided? It's almost impossible to see where one section ends and next begins.\n\nEach section is tagged with <h2>, the second most significant of heading styles. Perhaps your browser is in error, or you just desire a slight tweak to the CSS, which can be chosen locally. For me the current h2 text seems visually about twice the size of the paragraph text.  \nAlso feel free to submit an alternative CSS for the page to serve up if you think your styling would be popular.", "id": "d7e7r8o"}, {"comment": "I have to say, the main reason why is it so bad is because it's structured like printed documentation, not online documentation. For example, what is [this](https://i.imgur.com/WbFRw1o.png)? What use does it have? Is somebody just reading documentation like a book?\n\n> For easy reference, like any proper documentation.\n\nYes, hyperlinks are overrated anyways. Everybody will know what you're referencing when you say \"6.2.2.3.5\". I definetly need to see those numbers in the navigation, totally worth having half of the items broken into multiple lines without any seprator.\n\n> Because pagination is best determined by the the viewer, not the origin? That which fits on 1 portrait desktop monitor might take 4 or more phone/tablet screens to be as legible. Welcome to HTML & virtual documents rather than a printed medium?\n\nThis isn't pagination issue. Why are examples on same page as \"api reference\" and \"getting started\"? Completely useless, nobody is reading documentation like a book. User came to documentation to find one specific section. By putting everything onto single page, information is heavily obstructed. Again, this isn't a printed documentation, no need to save paper.\n\nAlso the navigation doesn't react to scrolling at all, still on top, no indication on what section you are.\n\nAnd yes, most docs put documentation for entire class (but never entire module) on single page. But then you at least have proper navigation (with, you know, method/function names and such) and visible separation of sections.\n\n> The module contents? 6.2.2. Module Contents\n\nYou mean those 4 pages of text without any navigation? Nice list. Easy to navigate.\n\n> Each section is tagged with <h2>, the second most significant of heading styles. Perhaps your browser is in error, or you just desire a slight tweak to the CSS, which can be chosen locally. For me the current h2 text seems visually about twice the size of the paragraph text.\n\nThis is part of the \"everything squeezed onto one page\" issue. You can have any sizes you want if it is burried in stacks of text. Text you don't want or need. Again, nobody is reading documentation like a book, usually you're looking for specific method and nothing more.\n\n> Also feel free to submit an alternative CSS for the page to serve up if you think your styling would be popular.\n\nAh, the good old \"So direct your own movie if you're so clever!\" phrase.", "id": "d7e9brg"}, {"comment": "> I have to say, the main reason why is it so bad is because it's structured like printed documentation, not online documentation. For example, what is this? What use does it have? Is somebody just reading documentation like a book?\n\nActually, you can.  Since the side bar advances you to various parts of the uni-page document, or back/forward a section, you *can* read it like a book.  *Or* you can read just the sections that are relevant to you.  Some people absorb this kind of thing to learn how to use a particular aspect of a language.  I'm not one of them, but I've worked with that sort.\n\n> Yes, hyperlinks are overrated anyways. Everybody will know what you're referencing when you say \"6.2.2.3.5\". I definetly need to see those numbers in the navigation, totally worth having half of the items broken into multiple lines without any seprator.\n\nWhat's easier?  Telling your friend \"Check section 6.2.5.4, there's an example there that's just what you need.\" or copying the link, opening your IM/email client, and sending it to him when he's already at the documentation?  Seriously, it's a reference number, you'll know exactly where to begin on the page with that number.\n\n> This isn't pagination issue. Why are examples on same page as \"api reference\" and \"getting started\"? Completely useless, nobody is reading documentation like a book. User came to documentation to find one specific section. By putting everything onto single page, information is heavily obstructed. Again, this isn't a printed documentation, no need to save paper.\n\nFor easier reference.  You can flip between different parts of the same page, or highlight every instance of a particular word and it'll show in your scroll bar, so you can jump to the exact references you want, all on the same page.\n\n> Also the navigation doesn't react to scrolling at all, still on top, no indication on what section you are.\n\nYeah I have nothing for that.  That's just bad design.\n\n> And yes, most docs put documentation for entire class (but never entire module) on single page. But then you at least have proper navigation (with, you know, method/function names and such) and visible separation of sections.\n\nYou're talking about [this](https://docs.oracle.com/javase/8/docs/api/java/net/Socket.html).  I agree, separate listings for all the function names would be nice in an easy to locate listing.  Instead, you know they're in section 6.2.2, Module Contents.\n\n> You mean those 4 pages of text without any navigation? Nice list. Easy to navigate.\n\nPlaying contrary, 4 pages of text that is the function name, a blurb about how the functions work, and in some cases stand alone examples.\n\n> This is part of the \"everything squeezed onto one page\" issue. You can have any sizes you want if it is burried in stacks of text. Text you don't want or need. Again, nobody is reading documentation like a book, usually you're looking for specific method and nothing more.\n\nAgain to the contrary, headers are there specifically to make different sections of the same page clearly stand out from one another.  Their inclusion in the text is specifically so that you can whip down a page and know you've passed into a new section that might be relevant to you.  Otherwise, go back to the navigation side bar and click on the relevant section.  It's no big deal.\n\n> Ah, the good old \"So direct your own movie if you're so clever!\" phrase.\n\nNow you're just being pedantic.  If you've got a better layout in mind, make it.  [They do take your criticism to heart](https://www.python.org/psf/#feedback).", "id": "d7endjl"}, {"comment": "> One of the worst navigation menus I have seen.\n\nThat's a really standard setup.  As soon as I saw it, I was was like \"yeah, that looks like every other code/API/library documentation I've ever seen.\"  That's how everyone does it, and it's honestly pretty good.", "id": "d7e9vmk"}, {"comment": "> One of the worst navigation menus I have seen. What's with the numbers?\n\nIt\u2019s called hierarchical structure.\n\n> Also why is documentation for entire module squeezed onto single page?\n\nIt\u2019s much easier to browse and grep. As long as there\nare hyperlink targets to the sections, that is the most\nconvenient way. Perhaps only second to browsing the\nactual code.\n\n> Let's face it, python documentation is badly designed at best.\n\nCould be worse, could be a doxygen-mangled mess\nof extracted comments. Or a Microsoft online reference.\n\nSphinx is actually one of the best documentation tools\navailable. No wonder they\u2019re [moving parts of the kernel\ndocs to it](http://lwn.net/Articles/692704/).", "id": "d7enfl7"}, {"comment": "\"What's with the numbers?\" is one of these revealing questions.", "id": "d7ff4l6"}, {"comment": "Reading this thread I submitted this patch that should improve the UX of this menu\n\nhttp://bugs.python.org/issue28044", "id": "d7fn5xc"}, {"comment": "I'm not really sure what that adds, almost always I'll use the table of contents rather than the sidebar.\n\nIf you do push forward with it, I ask that you add more padding, because the text is way too squished to the border now.", "id": "d7gs3nf"}, {"comment": "That's not very discoverable, but OK, that might be a bad example. Like, C# and PHP documentation on their respective regex stuff is marginally better but not really really better.\n\nWhat really annoys my bollocks is the way I have to refresh on some rarely used method on str or list or dict, and the way to do that is to, well, I google \"str upper python\" and get directed to an officially obsoleted `string` module, and click on the link to the actual documentation https://docs.python.org/2/library/stdtypes.html#typesseq, and then I have to find the actual documentation of that method somewhere there, and the shit on the left makes my eyes bleed so don't blame me for never looking at it. Like, go on, look at it and figure out where I have to click.\n\nThat's a damn shame. It seems that that documentation was forked from the tutorial and retains its essential structure, all that shit in one place organized in such a way that if you read it top to bottom you'd have a good idea of how that bunch of types in Python work.\n\nIt is __very emphatically not good__ as a reference documentation for some particular str method. It sucks sweaty balls as such.\n\nDisclaimer: 10 years of experience with Python, use it everyday, probably can segfault your brain with leaking abstractions from the gnarly implementation details of CPython because I'm more or less familiar with the source code and you probably aren't. And yeah, I still have to look up str methods now and then and the documentation __SUCKS__.", "id": "d7eqtdv"}, {"comment": "Why don't you just fire up an interpreter and type `help(str)`, or if you have ipython, bpython or ptpython (enhanced interactive interpreters): `str.<tab>`?\n\nI say this because I remember discovering that for the basic stuff, Python is basically self-documenting. I rarely need the \"normal\" Python documentation.", "id": "d7f3cl0"}, {"comment": "DuckDuckGo has this nice bang syntax which simplifies such search greatly:\n\n[!python3 str upper](https://duckduckgo.com/?q=!python3 str upper)", "id": "d7f7a7t"}, {"comment": "The worst part is that the scrolling on the table of contents is linked to scrolling the main document. So if I want to open a different section in a new tab, I have to scroll away from what I am looking at now to find it.", "id": "d7f18g1"}, {"comment": "There are, I think, three questions documentation should be able to answer:\n\n1. What can I do with this?\n\n2. How do I do ____ with this?\n\n3. How does ____ work with this?\n\nThe last question is the most important for experienced developers, because it should explain the error cases (can I modify the collection during a `for .. in` loop?), handling of unexpected inputs (does the `[-1]` convention apply?), or other behavior someone from another language might find unexpected (Does `+` with a string call the arguments' string method like in JavaScript?). Python's documentation is great for 1 and 2, but has always in my experience failed at 3. It's not a knock on the language - these days, most questions are answered on Stack Overflow - but it makes it less than stellarly useful.", "id": "d7fd5ti"}], [{"comment": "ITT - people who are *not* Python beginners defending Python.\n\nI've been programming for 20 years. In the last couple of years I've played around with Python (mostly because I want SciPy), and he's right. The whole Python ecosystem is where PHP was 5-10 years ago in terms of ease of learning/references.\n\nAnd sure, that's not the be-all and end-all of any language - if it were, I would just have stopped trying to pick up Python at all - but it's important. It means, for example, that I haven't switched to Python for everyday tasks, because it's too painful.\n\nAnd if your answer to the OP is of the form \"do x, then y, then z, honestly I can't see what the problem is, are you retarded or something?\" then congratulations - you're part of the problem.", "id": "d7e4919"}, {"comment": "hi, I teach python beginners.\n\nThe author brings up a fascinating problem: We aren't taught to /think/ about the things our computer is telling us or what the documentation given to us is saying.\n\nOr for that matter, how to *think*. \n\n> The compiler fails with a random error. \n\nIt is almost never a random error. It is a pointed error that has backstory. `pip` spits out logs. Reading them can reveal why something has gone awry. Thinking about the reasons why something has failed will lead you down (admittedly) many paths but oh so often it solves your problem.\n\nI'd be willing to be the \"random error\" that most people encounter is that the `-dev` package of the library they're trying to compile against isn't there. (**edit**: Or, on windows, something is weird and setting up package building on windows is br0rken; this is mostly because Windows is a second-class OS in the land of Python and was up until about a decade ago still stuck in the dark ages.)\n\n> No, it\u2019s not you. The documentation really is shit.\n\nThe documentation was meant for reading like a book. It's one of the things I tell everyone I teach python to: \"Don't think of documentation as a cookbook, where you can turn to a function and get a ready-to-eat sample; think of it as an instruction manual for a really big tool: you read it until you have an idea of what the hell is going on.\" (in this vain, commercial cookbooks are seriously laid out as a set of ingredients with percentage measures in relation to flour. Forty pages prior was probably a \"how cakes work\" section that covered how cakes get cake-y. You are expected to have read this. )\n\nOne thing the Python documentation does REALLY well is encourage you to slap open an interactive prompt and TRY something. Let's take the `findall(...)` example:\n\nFrom the documentation:\n\n> Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result unless they touch the beginning of another match.\n\nOkay, so it finds whole matches of `pattern` in `string`, and has some caveats about how regular expression group syntax is handled.\n\n\"BUT HOW DO I USE IT?????\" I hear you ask.\n\nLet a zen-like example of the first time I've used `findall` after a long hiatus of having to care, ripped straight from the interpreter, explain:\n\n    Python 2.7.10 (default, May 23 2015, 09:44:00) [MSC v.1500 64 bit (AMD64)] on win32\n    Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n    >>> import re\n    >>> re.findall(\"this is a test\", \"\\S+\")\n    []\n    >>> re.findall(\"\\S+\", \"this is a test\")\n    ['this', 'is', 'a', 'test']\n    >>> re.findall(r\"\\S+\\s+\\S+\", \"this is a test\")\n    ['this is', 'a test']\n    >>>\n\nNeat, I as someone who has never interacted with the python regex library now understands roughly how basic regular expressions are handled. \n\nHowever, I really don't think I can take the author seriously. They reference people (but never says who), libraries and documentation (but only once links to it, and poorly: there's a whole section of examples with a pretty straightforward use case, disproving the author's point.) I'm definitely agreeing with /u/Daneel_Trevize here in saying this feels like a load of bullhockey meant to sell a book.\n\nTo be completely fair, I learned Python back when the best book on the language was [Beginning Python](http://www.wrox.com/WileyCDA/WroxTitle/Beginning-Python.productCd-0764596543.html). It was a fantastic book to read as a young developer. I learned python's standard library by reading the baked-in documentation (I had no internet connection at the time) and taking the time to learn the mores of the language.\n\nThis is what I give python noobs: \"Read the documentation. Then, go play in the sandbox. You cannot hurt anything in 99% of cases if you think a little before doing what might be dangerous stuff. If you have stuff you've already written, you can `import` it.\"\n\n(I'll agree in a few different ways to the python community can be a little abrasive; those who are really eager to teach python are a rarity; this person on the other hand is a little too salty for my tastes)", "id": "d7e8d8z"}, {"comment": "Those are very useful tips, but consider this:\n\n>The documentation was meant for reading like a book. It's one of the things I tell everyone I teach python to: \"Don't think of documentation as a cookbook, where you can turn to a function and get a ready-to-eat sample; think of it as an instruction manual for a really big tool: you read it until you have an idea of what the hell is going on.\" (in this vain, commercial cookbooks are seriously laid out as a set of ingredients with percentage measures in relation to flour. Forty pages prior was probably a \"how cakes work\" section that covered how cakes get cake-y. You are expected to have read this. )\n\nNo. Just...no. The Python equivalent of a PHP function only does what the PHP function does. There's no ineffable mystery to the Python one that isn't there in the PHP one. It's not \"a really big tool\" in any way that another language isn't - it's exactly the same thing, and does not require Zen koans that you try until eventually you slap yourself with one hand and suddenly grok Python.\n\n", "id": "d7ednt4"}, {"comment": "No zen koans here, just \"read the manual and get a feel for it.\" An astonishing number of my misconceptions about a language or library are regularly revealed by reading the manual and taking notes along the way.\n\nThere are things that are fundamentally unique to Python and its basic design (e.g. import-level variables and their ability to transcend state boundaries) that only have rough analogs in other languages (singletons).", "id": "d7ehr4g"}, {"comment": "That's at a level of subtlety which I think is not quite that of the beginner, and every language has those features. \n\nTo come back to an example given earlier - if I want to use Python's \"findall\" function, I have to go to the regular expression chapter of the manual, and read through it to understand what findall does. The text does not provide any examples, and the detailed bit about findall describes it primarily by comparison to other functions.\n\nIf I want to use PHP's preg_match_all function, I get a full page telling me what it is, and how to use it.\n\nI appreciate one can say that the right way to learn something is to fully understand its whole context, get a feel for it, and try it out until you get it. The way PHP does it is indeed like a recipe book where you can just grab the function you want, minimally adapt the example code, and never really understand what you did.\n\nOne of those ways of learning requires a much larger investment in learning *before* doing than the other, and approaches the language as something people should get *right* more than something that they can just *use*.\n\nI'm not saying that's wrong, but the Python-style approach of formalistic correctness has been found to be the worse one for beginners, particularly busy beginners with alternatives that they can just use.", "id": "d7ekd8k"}, {"comment": "> The text does not provide any examples\n\n[Ahem.](https://docs.python.org/2/library/re.html#examples)\n\n", "id": "d7eld96"}, {"comment": "There is no findall example in the examples section link you've provided. And the first finall example doesn't appear until section 7.2.5.6, which is called Finding all Adverbs.\n\nAhem.", "id": "d7epl7c"}, {"comment": "TIL there are people in the world who have never encountered numbered sections, or are ignorant of their function or purpose.\r\n\r\nThese people write software.\r\n\r\nI'm scared for humanity.", "id": "d7er9w7"}, {"comment": "> The documentation was meant for reading like a book.\n\nThat is a bug, not a feature. It makes learning by experimentation (the best way to actually learn new things) much harder, especially when it comes to scripting languages that people often use to quickly tie things together and are not interested in learning the entire framework (or whatever).", "id": "d7eh3px"}, {"comment": "It encourages experimentation quite a bit. The [entire baked-in tutorial](https://docs.python.org/2/tutorial/index.html) says \"Hey you should get used to the repl because it's how you're gonna learn a lot of things\". Tools like IPython and Jupyter make this even more abundant.\n\nJust like any good text, it becomes a reference once you're comfortable browsing through it. As for \"learning by experimentation\" -- that's your way of learning. My partner isn't -- he'll read a book for hours on end and just grok the topic.", "id": "d7ei4cg"}, {"comment": "Yeah, so maybe leave \"being read like a book\" to the tutorial and have some actual reference documentation for the people who want to look up `str.upper`? Like, _that_ is not reference documentation, it's an insult. I don't want to read a book, yo.\n\nAnd this is a complaint from myself, an experienced Python developer, how much harder is it for newbies?", "id": "d7er7v0"}, {"comment": "there's a search box. Also, `help(str)` at any python prompt will get you the baked-in docs. `help(str.upper)` does the same.", "id": "d7esd9t"}, {"comment": "I don't use the REPL, I prefer to run my scripts from top to bottom.\n\nSaying that the official internet documentation doesn't suck because you can get some to the point docstrings from the REPL is retarded, sorry.\n\n**edit:** I mean, try googling \"string upper C#\" for a difference. That's a reference documentation, maybe not the best but good. Python's bullshit for str/list/dict methods is not in the same league, it's not in the same _sport_ ffs.", "id": "d7esjyr"}, {"comment": "Neat for you.  However, I have to disagree in saying that the .NET `String.toUpper()` documentation is far too verbose whereas Python's `str.upper()` is just as long as it needs to be.\r\n\r\nThe REPL is a tool central to python. Saying \"It's stupid because I don't use it\" is a: short sighted and b: not helpful. Just today I needed to generate test data; I imported my SQLAlchemy schema and generated a few thousand rows in a few minutes of thinking; the REPL made that possible without even leaving my editor. ", "id": "d7eug3v"}, {"comment": "> The documentation was meant for reading like a book.\n\nIf I wanted to read a book on Python, I would [buy one.](https://www.amazon.com/s/ref=nb_sb_ss_c_2_6?url=search-alias%3Dstripbooks&field-keywords=python&sprefix=python%2Caps%2C238)  If I want to quickly figure out how to get something done, I check the documentation and expect to be able to get the gist in a minute or two.\n\nMost of the time, I want the ready-to-eat sample.  Most of the time, so does everybody else.  Books are great when you want to do a deep dive, but you shouldn't have to bring scuba gear when you just need a quick reference.", "id": "d7enymf"}, {"comment": "A valid dislike. It becomes a handy reference once you've gotten the core stuff down but you have to be willing to spelunk through (or use search).\r\n\r\nThis also kindof gets at one of the odd parts of Python: The documentation itself is built from the source tree for much of the python runtime. Python aimed to be \"Self documenting\" like that (see: projects like Sphinx that consume Python source trees and spit out HTML documentation, sites like ReadTheDocs that can consume git repos and spit out working documentation). \r\n\r\nIt's one way to skin that cat -- Some might not like that particular mechanism for skinning. ", "id": "d7eob06"}, {"comment": "I really like your initial premise, that many people aren't taught to think any more, but instead are told \"here shove this peg in that hole\" and get flustered/frustrated when the peg or hole is wrong or mis-aligned.\n\nhowever, even here, you're assuming some people are further along than they really are:\n\n> I'd be willing to be the \"random error\" that most people encounter is that the -dev package of the library they're trying to compile against isn't there.\n\nthis just doesn't work in Windows. As others have said, getting many non-trivial modules stood up in a Windows environment is a nightmare for someone who might be learning their first programming language. Even for old hands, getting mingw32 and any necessary libraries/headers aligned just so for pip to breeze through compiling a module is often a hair-pulling exercise. For most people it's a major buzzkill and complete roadblock.", "id": "d7eewaj"}, {"comment": "I haven't personally installed any non purely python pip modules on Windows (or if I have it was transparent; I use Visual Studio on Windows to handle python).\n\nI will agree though, Python on Windows is a right bitch to get right (and right now there's no good answer for the solution)", "id": "d7egbal"}, {"comment": "The IDLE is probably one of the best tools I used to learn about new functions. Just typing in test cases and instantly running them helps me out so much when I was trying to understand a new function.", "id": "d7ea7jv"}, {"comment": "I'm an example. I suspect there were a lot like me as well who just gave up. For the record my journey was like:\n\nMatlab -> vba -> R -> Python (failed here) -> lisp -> bash/CMD -> Python ->C.\n\nProblems I've ran into: \n-I didn't know whether I could trust anaconda because I didn't know what precompiled meant (didn't even know what a complier was at that point despite being able to do basic functional programming). This severely increased the amount of reading I had to do(unnecessary at the time).\n\n- most examples unnecessary have some bash in them \n\n- docs are too big. R has two documentations types bundled for a package and one big one for r that no one seems to read. They are available to be called within r. Helps a lot!\n\n- many problem exacerbated by the fact that language designers can't agree on strict definitions for some key words. (Talking from a newbie perspective here).\n\n\nIn short, we do exist! A lot of those may seem ridiculous but well that's the point isn't it? I'll say most Python materials are good reference manuals rather than books you'll want to learn from.", "id": "d7eu5kj"}, {"comment": "I am the original author, and can I say, thank you.\n\nThis post was written for Python programmers, and  I dont know who shared it here, but Im surprised it got so many upvotes. And yet, people keep calling me an idiot for daring to point out Python's flaws.\n\n>And if your answer to the OP is of the form \"do x, then y, then z, honestly I can't see what the problem is, are you retarded or something?\" then congratulations - you're part of the problem.\n\nZingo! That's the thing. I've been using Python for 7 years (programming for 15). I know all these hacks to get libraries installed. But the post was written from the point of view of beginners. And how hard it is to even get started.\n\nSince I wrote it, I've gotten about a dozen emails a day saying basically _I thought it was just me_. I have to assure people that it's certainly not just them.\n\nPersonally, I think Python is losing the war here. Beginners get insulted, they move on to other languages. Python is the top language for beginners (just look at how many universities teach it), but most of these beginners dont stick with it. Proof? 90% of the jobs are for PHP/Ruby on Rails.\n\nIts depressing, but whats even more depressing is that no one wants to point out the emperor is naked.", "id": "d7eah6i"}, {"comment": "> ITT - people who are not Python beginners defending Python.\n\nBy definition everyone who currently knows Python was at some point a Python beginner, and unless the docs have gotten worse over time, we were beginners at a time when things were harder than they are now, so if we found Python easy to learn then, it must be at least that easy to learn now", "id": "d7eol6a"}, {"comment": "[deleted]", "id": "d7ema3v"}, {"comment": "I think the writer means beginners to software development, period, that are also new to Python.  \n\nIf you already know how to write non-trivial software in another language, then the Python learning curve isn't too bad.  I found it much easier than wrestling with Make, C, and C++ or Maven and Java.  But then I was already familiar with Make, Maven, C, C++, and Java when I tried to learn Python so it's not a fair comparison.", "id": "d7ep98n"}, {"comment": "Kind of my thought as someone who did java and and c++ before python. Sure missing a c dependency after doing a pip install sucks... but what's better? Getting java dependencies sucks, getting c++ dependencies sucks because make sucks (qt solves some of these though), NPM/bower is kind of cool ... unless there's a c++ dependency you don't have and then it sucks. Is this a python problem or just a general programming problem?\n\nAlso the python docs are great compared to tons of Java and c++ docs out there,  and is usually complete with multiple examples. (More than I can say for the android docs I've been using lately. They usually have 1 example that is a super simple case)\n\nThis article sounds to me like \"software dependencies are hard in general, documentation sucks in general, and python needs to solve it because beginners use it\"", "id": "d7eqri0"}, {"comment": ">Maybe it's because I come from the olden days when documentation sucked far, far worse.\n\nQuite possibly so. Early PHP and Javascript documentation sucked, and Perl...erg. As for XSLT. Or JSP. Just general bleh all round.\n\nClearly it's not impossible to learn Python, and not everyone will dislike the documentation, but equally clearly some people do. And the difference is, I suppose, that nobody as far as I know, *dislikes* PHP's modern documentation, although some people do *disapprove* of it.", "id": "d7epsjf"}, {"comment": "I've learned *a lot* of different languages over the years, and honestly Python is one of the easiest to learn.  I've recommended it to a bunch of people who have never programmed before, and it was easy enough for them to get into it...  I guess I'm just part of the problem.", "id": "d7eam8q"}, {"comment": "Oh, Python itself is easy enough if you have a couple of others under your belt - I mean, it's not Perl.\n\nSo, from the trivial perspective of writing some toy programs, no problem. I have those happily dancing all right.\n\nJust not getting beyond that to using it for something I would want to do with Python.\n\n", "id": "d7eddln"}, {"comment": "The \"part of a problem\" thing goes both ways though. The cplusplus.com page the linked page is referencing isn't official, it's third-party, somebody else took the time to create it. On the other side, instead of creating a page with examples, the linked article rants about the lack of examples ...", "id": "d7eykzl"}, {"comment": "The whole Python ecosystem or the SciPy ecosystem?", "id": "d7enrfz"}, {"comment": "I'm a Python beginner and haven't had nearly the trouble this guy had. Python is my go-to scripting language now.", "id": "d7eq7cn"}], [{"comment": "The problem installing libraries might be real on windows, but on any half-decent linux distribution, the process is \n\nUsing your package manager:\n\n(1) Install python and pip \n\n(2) Install the libraries you need\n\nIf (2) doesn't exist, install the library from pip.\n\n\nEdit: if you find some documentation that can be improved, Python is easy to contribute to, and the community is very beginner friendly! You can [submit](https://bugs.python.org/) a bug (or even better, a patch). Here are the [instructions](https://docs.python.org/devguide/documenting.html#building-doc) to build the documentation locally, and general instructions for [building python](https://docs.python.org/devguide/setup.html), if you ever need those.", "id": "d7e33cc"}, {"comment": "I do a lot of my coding in Windows and pip works great for me. I've never fought dependencies. ", "id": "d7e56j2"}, {"comment": "Your experience is very different to mine. Atleast 50% of packages have failed and the solution is just to go get some .exe installer from some 3rd party site.", "id": "d7eibsx"}, {"comment": "That's odd. I have a Windows development box that I always prototype on, but I have to keep the dependencies in sync on my Server 2012 dedicated box. I've had no issues with dependencies on either environment. ", "id": "d7eivlz"}, {"comment": "No numpy?", "id": "d7eoi05"}, {"comment": "I think I've dealt with numpy when I was doing stuff with OpenCV. That project was difficult only because I had to figure out how to build OpenCV with my changes, but once I got that working it hooked right into Python and all of its dependencies worked fine.", "id": "d7eoq6g"}, {"comment": "Ah. Numpy has been a pain in the ass for me, to the point that I do what /u/wowqiao said: go grab a .exe installer.", "id": "d7eotou"}, {"comment": "Weird, here's an example of me installing numpy and doing some stuff with numpy arrays with absolutely no issue in PowerShell:\n\nhttp://i.imgur.com/PRYAnfk.png", "id": "d7epgab"}, {"comment": "I also remember having had problems with numpy. I guess the `whl` packaging is kinda new, or maybe numpy did not provide it previously? Because I definitely remember it needing a C compiler at some point, but it doesn't now.", "id": "d7er8m1"}, {"comment": "What the hell?! And that doesn't appear to be anaconda either?", "id": "d7era0s"}, {"comment": "No sir, plain old Python 3.5.1.", "id": "d7erid7"}, {"comment": "On Windows you should be using Anaconda these days. It just works\u2122.", "id": "d7e4qzm"}, {"comment": "> you should be using Anaconda these days\n\nIs that obvious for a newcomer though?", "id": "d7e5xxl"}, {"comment": "No, so I'm doing my part helping them here =)", "id": "d7e7lul"}, {"comment": "If you're doing anything remotely scientific it's talked about everywhere", "id": "d7e6dzf"}, {"comment": "THis is my problem. What about people who do a little Sci-flavored Python and a lot of non-sci-flavored python. This forking of Python for reasons that come down to \"Windows Python sucks for SciPy/Numpy\", the solution of \"Move to Anaconda\" sucks for its own reasons, because it forks the community.", "id": "d7e90rc"}, {"comment": "Conda is no more a Python fork than `apt` is, or `yum`: it is a package manager that can handle Python packages, precompiled binaries, and a lot more.\n\nhttps://jakevdp.github.io/blog/2016/08/25/conda-myths-and-misconceptions/\n\n* pip works exactly the same inside a Conda env as inside a virtualenv.\n* Inside a Conda env, PyPI packages that require compilation can be `pip install`ed as usual if you have the compilers.\n* If you don't have the compilers (e.g. because you're on Windows and the hoops are daunting), you can generally `conda install` that same Python package as a precompiled binary, created by somebody on the same platform who did have the compilers.\n\n\nAs for Anaconda, as opposed to `conda`: that, too, is not a fork. It is a distribution. Like your Linux distribution includes a Python version + compatible package versions (with components that need compiling pre-compiled), that you may download from its `apt` repository if you want things to Just Work; so, too, Anaconda has prepared a Python X.X + NumPy Y.Y. + SciPy Z.Z + ... distribution, with binaries pre-compiled, that you may download from its `conda` repository if you want things to Just Work.", "id": "d7ed7y9"}, {"comment": "Forking the community is a Python specialty. See: Python 3, easy install vs pip, requests vs urllib2, string formatting, greenlets vs gevents, wsgi vs non-wsgi, etc ad nauseam.", "id": "d7epi7p"}, {"comment": "Oh, nailed it.  This is true.\n", "id": "d7f60i8"}, {"comment": "It's not a python fork", "id": "d7e9q30"}, {"comment": "pypy is a python fork. Anaconda is normal python but with precompiled windows binaries available.\n\nAt best you could argue that anaconda is a pip fork, and I'd still disagree.", "id": "d7envsg"}, {"comment": "It's another distribution of Python, and is effectively a Community forking technique.", "id": "d7ecsmy"}, {"comment": "This is sad, but true.   What about stuff that also you want to install, that installs easily in Windows mainline Python but is not packaged and tested in Anaconda?  The Python PIP-install ecosystem is huge.  It's unfortunate that getting Numpy, Scipy, and all, working on a regular Windows python install is so painful.\n", "id": "d7e8w1d"}, {"comment": "What's worse is when you have a native extensions written using C99 or C11 code not supported on the version of MSVC python is compiled on.", "id": "d7edk7x"}, {"comment": "I don't think your comment is looking at this from the perspective of a *beginner*. How does a beginner figure out what needs to be installed in step 2? A beginner might barely even know what a package manager is! Much less be able to translate some weird C/C++ compilation error into a command to install a missing package.", "id": "d7ebkde"}, {"comment": "That's exactly the issue here! \nPython was the language I started with 10 years ago and that's exactly what I found out back then!", "id": "d7fg4ki"}, {"comment": "What I frequently find on linux is you `pip install package` and it fails with a C++ compilation error. \n\nThere are so many packages with native dependencies which do not document them on pypi and don't check for them during compilation. So users of the library are left googling error strings.", "id": "d7ed4sq"}, {"comment": "Doesn't matter. It's inexcusably broken on windows.", "id": "d7e5afk"}, {"comment": "To be fair, that's partly just because everything package-and-compiler-related is broken on Windows.", "id": "d7e8esn"}, {"comment": "For one part is broken because it ignores Windows, tries to treat it like Linux, doesn't work, surprise.\n\nFor example, the most sure way to fuck up your pip setup is to listen to the instructions it gives you:\n\nNormal User, non-admin:\n\n* Install Python 2.7.x from python.org\n   -> get asked for UAC, allow it, install.\n* Run pip to install something trivial like 'six'\n   -> No UAC prompt, but it tries to install to a read only location\n    \n* Fix Permissions of the site-packages dir so it works\n* Read the pip message that pip is outdated\n* Run the suggested command\n* PIP deletes important parts of its infrastructure and you need to reinstall python to fix it. \n\nTHATS AWESOME USER EXPERIENCE for a DEFAULT install.\n\nOr assuming that requiring an (outdated for 2.7) C compiler is a great idea for a package manager. (for eggs, wheels fix that).\n", "id": "d7edhg5"}, {"comment": "> Run pip to install something trivial like 'six' -> No UAC prompt, but it tries to install to a read only location\n\nTry doing the same on linux - you'll get exactly the same error, because you forgot to sudo. \nYes it sucks that sudoing is hard on windows, but don't blame python\n\n> Fix Permissions of the site-packages dir so it works\n\nThis is exactly what you are not supposed to do. `site-packages` is protected for a reason. Use `pip install ... --user` instead, or start an admin command prompt.\n\n`apt-get install` doesn't automatically sudo, right? Why should `pip`?\n\n", "id": "d7fa3cp"}, {"comment": "Good response, yes.\n\nWell, UAC is a bit different then sudo actually. It is kind of like using an admin user for work, but getting ask if you want to do something potentially dangerous. With sudo you use a non-admin user and need to explicitly declare you want to do something dangerous. So it is a different model and it would make sense for pip to invoke 'UAC' if i have an admin user already and the python install is global. 'apt-get install' might not sudo, but most installers on Windows do use UAC. So by following linux logic on windows, it is confusing users.\n\nBut seems at least Python 3.5.2 fixed some of this, the new .exe installer defaults to a user (instead of global) install, so things work as expected now for a default install. It also now uses the correct location for a default global install ('Program Files' folder, not c:\\Python...). 3.4.4 still did it wrong.\n\n\n\n", "id": "d7fdrde"}, {"comment": "I mean, npm and nuget seem to work fine for me.", "id": "d7enfsd"}, {"comment": "It's become a lot better now for folk running Python on Windows now that pip has become the de facto package manager in place of setuptools, and even now that pip is available out-of-the-box as an option in the installer.  \n\nBut for a long time before (and even now as a backup), [Christoph Gohlke's page](http://www.lfd.uci.edu/~gohlke/pythonlibs/) for Python extensions has been a godsend when trying to grab popular libraries.  No need to worry about random errors when using setup.py, rarely any issues with the wrong Python version or architecture (most libraries offer all combos).  \n\nI've been a big advocate of using Python for tools within gamedev, but I'd probably not be as enthusiastic if Gohlke's site wasn't available.  Kinda wish there was a way to donate some cash as thanks.  ", "id": "d7e5d3x"}, {"comment": "The big thing isn't pip. It is wheels and the chance to not need an extra compiler setup.\n\nWindows actually has a stable API, unlike all the Linux variants, where you need to compile every crap to get it to work. So pip + wheels do just what you want.", "id": "d7ed571"}, {"comment": "True, but that was the beautiful thing about Gohlke's site - They were pre-packaged libraries even before the wheels became a big thing.  \n\nIt looks like Christoph has since switched almost all of them over to wheels, but for a long time the various downloads were simply Win32 installers where you simply hit \"Next\" and it did the rest for you.  No pratting about with compilers, dependencies, etc.  You just downloaded, ran and it was all done.  \n\nI'm definitely not saying wheels were inspired by them, but both Gohkle's installers & wheels seem to have decided independently that a pre-assembled approach for packages wasn't a bad idea in making useful libraries accessible to developers.  Neither were wrong.  ", "id": "d7edw4h"}, {"comment": "In between part 1 and 2 there's a step where you should probably be setting up a virtual environment for your project. I've been working with Python for years though and I still skip this step because it's never been clearly explained to me how to get it to work reliably and I end up running into odd issues- I'm still not sure whether I should use virtualenv or venv or something else. The best was [this](https://www.dabapps.com/blog/introduction-to-pip-and-virtualenv-python/) but it's outdated and doesn't cover python3 (which I use for my personal projects).", "id": "d7em6nu"}, {"comment": "try doing the above when you need both Python 2 and Python 3 ", "id": "d7eqgjl"}], [{"comment": "One of the biggest challenges for me is the formatting of how Python was documented.  It feels like something that was made in a hurry for a quick small side project.  It would have been acceptable if python stayed like that.\n\nI think the content of some of the documentation is satisfactory, but how everything is formatted is god awful.  I'd rather see something like how Qt or Java formats their docs.", "id": "d7ea2cg"}, {"comment": "The only documentation I've really pored through on a regular basis is the SDL2 library and I love how I can just go to a category and find what I need. The function, its parameters, return type, a simple explanation of what it does, and occasionally an example.  \n\nI don't need countless lines of texts, just tell me what I need to provide and what I should expect in return. Preferably in a easy to scan fashion like a table, not a paragraph.", "id": "d7eo1ii"}, {"comment": "I used the SDL documentation for a number of years and found it to be pretty uniformly bad.  I spent far too much time having to read the code of the library to figure out how things really worked when the documentation didn't give enough detail.", "id": "d7f5usl"}, {"comment": "It's pretty good, but I wish there were more code examples.", "id": "d7es2hw"}, {"comment": "Agreed 100%. Python deserves better.\n\nHonestly... whenever some time has passed and I find myself back at the Mozilla Foundation's documentation, I say, audibly, \"this is so fucking good.\"", "id": "d7eu2lr"}], [{"comment": "There's a reference in there to an article from 2004 by Yegge where he discusses Python. https://sites.google.com/site/steveyegge2/tour-de-babel\n \nHindsight is great, but Python never overtaking Perl already sounds dubious by 2004. The notion of Ruby taking over from Python practically overnight is also odd -- I have the impression many Rubyists have jumped ship to JavaScript in recent years, but Python seems to be going strong still, even with the whole Python 3 thing.\n\nI can't really make judgements on whether Python people were or are frosty -- not in my experience but who knows.", "id": "d7e3h6f"}, {"comment": "Yeah, it was incredibly funny to read with the benefit of hindsight.", "id": "d7e4w4l"}, {"comment": "It's funny the author complains about bad docs and then worries Ruby will steal the user base. ", "id": "d7e6rye"}], [{"comment": "I would've thought the main hurdle for new python devs would be 2.x vs 3.x.\n\nHaving new developers choose their major version of choice, and have to double check every library they use for compatibility, seems extremely disconcerting.  Nevermind the fact that it makes it harder to google information about the language and libraries.\n\n(I say this as an outside onlooker)", "id": "d7e5hom"}, {"comment": "It's really not as hard as it seems. Porting stuff written in 2.x to 3.x is annoying, but the differences are pretty clear-cut, and it's still fundamentally the same language (not like Perl 5 -> 6).\n\nAlso, in general, the rule is that, unless you *need* Python 2 compatibility for some reason, just use 3.", "id": "d7e8lp8"}, {"comment": "Many useful libraries still only work with python2. I'd love to use 3, but I keep getting caught out by these", "id": "d7eur0d"}, {"comment": "some not many, and seriously, a library that doesn't have a py3 version when 3.6 is around the corner is not \"serious\" pretty much by definition. \n\nI don't care if you are fucking Google - if you can't spare some ass-hours to futureproof your product 8 fucking years into 3.x and 3.5 years before 2.7 EOL, you are literally telling me that using your stuff means me loading up on technical debt.", "id": "d7excbu"}, {"comment": "> I don't care if you are fucking Google - if you can't spare some ass-hours to futureproof your product 8 fucking years into 3.x and 3.5 years before 2.7 EOL, you are literally telling me that using your stuff means me loading up on technical debt.\n\nYour honesty is refreshing. I agree.\n\nThere aren't that many libraries out there which require 2.x and are also irreplacable.", "id": "d7fga03"}, {"comment": "> Many useful libraries still only work with python2.\n\nBy all means, please share. I can't think of a single significant library that doesn't support Python 3.", "id": "d7f0f2v"}], [{"comment": "This is what python beginners on WINDOWS have to deal with, because of the cluster-fuck that is CPython+Windows+Numpy+SciPy.\n\nAnaconda is one partial answer.  But forking the CPython tooling ecosystem creates as many new problems as it solves.", "id": "d7e8x7u"}, {"comment": "Installing python and some other libraries on linux was much more straightforward than on windows which kinda surprised me, have me a real headache on windows", "id": "d7etead"}, {"comment": "Wheels have largely solved this problem for numpy and scipy.  It's not hard these days.", "id": "d7fczhq"}], [{"comment": "Agreed on all counts. I love Python, but a lot of the documentation/support is quite lacking.", "id": "d7e1cun"}], [{"comment": "Am I the only one here to have never had these issues when I started with python? I mean.. A bad dancer is gonna blame his nutsack for getting in the way of him becoming pro..", "id": "d7e4xz3"}, {"comment": "The issues are mostly with packages with C dependencies. Never had any such issues with pure python packages.", "id": "d7edypu"}, {"comment": "Maybe it's been too long since I've been a Python beginner but I can't recall having any of these issues.  Or, at least with the dependency stuff, not any problem that was unique to Python.", "id": "d7encet"}], [{"comment": "Ranting about compiling libraries, no mention of your OS's package management system (which linux newbies need to learn to work with rather than work around by recompiling stuff from source), or https://pypi.python.org/pypi\n\nAnd as for PHP documentation & libraries? LOL holy shit what is a polluted namespace? And how about we keep garbage comments from 11 years ago right there on the doc page, that are plain **dangerous** to follow for the current PHP 5.6 or 7.0 on the web in 2016...\n\nMeanwhile, OP needs to look again at https://wiki.python.org/moin/BeginnersGuide and https://docs.python.org/3/tutorial/index.html", "id": "d7e31hv"}, {"comment": "Despite its problems, PHP does have great documentation with good explanations and examples.", "id": "d7ec2qj"}, {"comment": "The comments on the other hand are a mixed bag.\r\n\r\nSometimes, there's useful tips. Other times, it's a heaping dung pile. It really does follow sturgeon's law. ", "id": "d7esff4"}], [{"comment": "Honestly the lack of good encapsulation and sandboxing, as well as good version management, is easily the worst part to me. I much prefer a package.json to using virtualenv...", "id": "d7e4dnr"}, {"comment": "In what way does virtualenv not accomplish sandboxing (in the dependencies sense) and management of versions? It's hardly a perfect system but it does those exact things just fine.\n\nComposer/package.json just dumps files to satisfy dependencies somewhere and makes sure your PHP, when running, gets them. Virtualenv does that, but also ensures all surrounding tooling will also find the versions of python and the libraries you're using for that project.", "id": "d7e5x2o"}, {"comment": "Oh no it does solve the issue, but I don't think it's as user-friendly as package.json.", "id": "d7e6xwo"}, {"comment": "`pip -r requirements.txt`\n\n    somepackage=2.3.4\n    another>=2.1.1\n    sillystring<=6.5.5\n\nDon't see what you're having issues with. ", "id": "d7eaw60"}, {"comment": "The python version not the packages and libraries", "id": "d7euo51"}], [{"comment": "A Python beginner, I mean someone learning the language shouldn't need non-standard libraries. And even then, I've absolutely never found it to be a problem. Hell, even compiling libraries from scratch isn't that hard. If you're unfamiliar with the process then maybe Python isn't the issue? Maybe someone can explain to me why any of this would be difficult? And for documentation, why not buy a book? There's a lot of cheap ebooks out there. And some random library documentation is lacking? Well welcome to the real world, where everything's made up and the docs don't matter. ", "id": "d7e3k3p"}], [{"comment": "> No, it\u2019s not you. The documentation really is shit.\n\n...\n\n> As someone who\u2019s used a lot of C/C++,  I am used to simple and easy to use docs\n\nI'd hardly consider sifting through all the overloads \"simple and easy to use\". I like Python's docs way better.", "id": "d7e5wb7"}], [{"comment": "It's not that bad but of course there are some problems. But I think that it is quite usual for documentation in other languages too. For example that mentioned PHP manual is also not exactly the best. For problems with installing modules. I had this problem only twice. For lxml and for newest version of matplotlib. But luckily for Windows there are unofficial binaries for many of those libraries. Unfortunately finding really great documentation for anything is quite rare. :0(", "id": "d7e27nr"}], [{"comment": "I was confused by Python 2 vs Python 3, and when I decided to just try one, it was really hard for me to figure out which documentation was for which version, and there could be like very minor differences, like capitalization on libraries and stuff. :/", "id": "d7e9412"}], [{"comment": "The author really rags on the documentation, but he doesn't mention anything about how useful the help() function is in Python. In combination with dir() I can explore any module I import, access the docstrings thanks to the help() function, all without having to go online. I don't know any other language that does this.\n\n", "id": "d7eh695"}], [{"comment": "I was actually going to make a post last night asking for some help on the same exact subject. I normally program in C and C++ but last night I was chatting with some friends on Discord when I realized that they have an API and thought that it would be a neat project to try out and get used to Python with.  \n\nDiscord's page recommended downloading a library for my language's implementation of Oauth2 so I did a search on pip. I thought one of Python's ideas was that there is \"one standard way to do something\" so I was overwhelmed when I saw my terminal explode with search results. \n\nSo instead, I looked up some Python Discord bot examples to get an idea of what libraries they used, and saw one that said to just use Django. I had only heard of Django before so I looked it up and got lost in the documentation. It involved setting up projects and directories and while I don't know Python that well, this seemed like a ridiculous amount of overkill.\n\nI thought I just needed something to get me an authorization token for Discord, and then something that could submit HTTP requests to Discord's API. I don't know how I ended up in this massive loop of searching for libraries and setting up virtualenv or whatever for managing packages instead of actually sitting down and programming.", "id": "d7enszz"}, {"comment": "> I thought one of Python's ideas was that there is \"one standard way to do something\"\n\nFor the language, sure.\n\nBut nobody goes breaking into developers' houses and accosting them with \"somebody already developed a third-party package for that, put down the keyboard and step away!\"", "id": "d7eoyhx"}, {"comment": "That is true, gave me a good laugh thanks haha! I see your point :) I guess a better question would be how would I go about determining which is the best for my needs without having to sift through all the packages? Some of them obviously are highly specific for use with other frameworks and libraries but I am just looking for something that implements the base functionality necessary. ", "id": "d7epyda"}, {"comment": "Depending on what you're trying to do, someone may have put together a comparison grid. Or just ask around in places where experienced folks hang out and try their recommendations.", "id": "d7eq6zd"}, {"comment": "**Django** is a great framework, but it is a lot of up-front work. For something simple to get started with I would recommend **Flask**.\n\nThat said, I am unsure what you want a web-framework for with using the discord API. Something very simple like the *requests* module might suffice for that, and I've also noticed a **discord.py** module.", "id": "d7f71nn"}], [{"comment": "I love Python, but as a scientific developer, my time is split between Matlab and Python, and for all its flaws, Matlab is much easier to get started *independently* with than Python, for all of the issues in the post. In particular, setting up scipy/other dependencies is usually fine, but sometimes a nightmare. It's not uncommon for setting up Python to be more difficult than actually writing the program. Part of the issue is the audience though - beginners and scientific users are not the same as career programmers, and for me, Python documentation is *much* harder to use than Matlab documentation. Also, many problems with setting up Python are trivial for someone who is familiar search paths, library paths, compiler selection etc. but are potentially insurmountable otherwise. Personally, I notice that I have much more difficulty setting things up on Windows compared to Linux simply because I'm not nearly as familiar with these things in Windows. This is a significant issue that affects a decent chunk of users (the users that this post is discussing) but the problem is many people in this community refuse to acknowledge that this problem exists - perhaps unsurprisingly, because this community largely consists of people who already know their system inside out, but that's not true of many users. ", "id": "d7eqnk7"}], [{"comment": "I once gamely followed the instructions of an article that claimed that, there is no reason you should be building websites using PHP, Python and Flask are better and just as easy to get started with.\n\n...several hours of installation/incompatibility hell later, I'd given up. Yes, Python *may* be better. But until it actually \"just works\" - *not* \"works if and only if you know exactly what you're doing\" - PHP's going to retain its edge, I'm genuinely upset to have to say.", "id": "d7e6mc5"}, {"comment": "What? Flask is trivial to setup. Pip install flask. It even has an http server inbuilt.", "id": "d7ee39x"}, {"comment": "Better yet, use cherrypy. It's simple as can be and has zero dependencies, and it all makes sense.", "id": "d7eqqds"}, {"comment": "Oh god.\r\n\r\nSo I went from using Flask as my go-to for one-off little HTTP projects to CherryPy for one.\r\n\r\nHow I had grown used to the \"This function is for POST things and this function is for GET things\". I had also gotten very used to Jinja templates (though found mako templates nice once I got them working)", "id": "d7esa2b"}, {"comment": "I love CherryPy though, I usually structure my apps as each endpoint being a class with GET, POST, etc. methods on it. It makes so much sense to me.", "id": "d7ewryi"}], [{"comment": "Have I entered some bizarro-zone? When I first started with Python the ease of installing libraries and packages, and the excellent documentation is what made me fall in love with it. To this day those are amongst my top reasons for using Python, well offsetting the language's pitfalls.\n\nThat said setting up numpy on a Windows system sucks, but that's the exception not the rule.", "id": "d7edqzv"}], [{"comment": "I agree with some of this, but the majority of it is a non-issue.  I'll counter it piece by piece.\n\n1. **Installing libraries**.  Not something I've ever encountered, and I very frequently deal with building esoteric modules in esoteric ways (I have to distribute wheels for Linux, Windows, and AIX that are bundled with all their dependencies, which all need to be statically compiled when they depend on native libraries).  It sounds like a specific module problem, and that's nowhere near limited to Python.  Any programming language that allows native extensions (which is pretty much every programming language) introduces the possibility of a badly-designed module causing compiler issues.  This is not a fault of the language, but the module author.\n2. **Horrible documentation**.  The documentation could be better, but that's a bad example.  The `re` module has a full set of examples at the bottom and the navbar takes you directly to it.  My biggest issue with the documentation is that return values are specified in the text description.  `findall`, for instance, says \n> Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result unless they touch the beginning of another match.\n\n I'd appreciate if the function signature in the documentation therefore had something like `list[str] | list[tuple[str]]` for every function.  There are plenty of times where I know what a function returns, but don't know the form in which it returns it, or how it returns in certain occasions.  All in all, the documentation is not perfect, but it is quite good.  Leagues behind what is available for C and C++, but it's understandable given how the static nature of C and C++ strongly facilitate documentation generation.\n3. **Horrible Tutorials / Examples in Libraries**. This is a problem with people who write bad documentation, not an issue with the language.  Personally, most of my documentation is a large set of well-commented unit tests, which has the dual advantage of describing how the code will actually work, and is guaranteed to work with the version of the module the tests are part of.  Each concept has a unit test, as well as the interaction of multiple concepts for good coverage and also good documentation.  I don't buy that this is that widespread a problem, given that most libraries I'm familiar with have quite good documentation.\n\nThe worst part is that the author here skips the actual issues with Python.  The biggest issue is that the standard library is horribly disjointed.  Parts are in a functional style, parts are in an object-oriented style, parts are in a procedural (data/function?) oriented style.  Some parts are snake_case, regardless of whether it's a function or a class, parts are PascalCase in the same way.  Some parts are actually badly documented, leading you in some direction when you need something else (the email module has some serious naming and organization issues here, making it difficult to determine what type you need for what).\n\nHe never brings up the issue with Python2 and Python3, where a beginner who may be unaware of these things will have code in a tutorial that doesn't even work for their latest version of Python.\n\nThe article completely misses the mark.  I'm not against Python hatred (or hatred of any language), but criticisms should be based on fact, and if you're criticizing something that causes a barrier for a beginner, you should actually bring up the biggest barriers that hit every single beginner (like Python2/3), not esoteric subjective issues that most people don't even hit.", "id": "d7efs8e"}], [{"comment": "I know this is talking about beginners, but\n\n>  No examples. I then have to Google Python regex findall examples, and go through a dozen blogs written in 2008.\n\nAny language is going to give you this problem, there is always going to be one function or another that doesn't have an example (also there was an example, ctrl f etc)\n\n- - -\n\n> `re.findall(pattern, string, flags=0)`\n\nSo I copy paste that into my code, and then go onto following the instructions. I place my pattern into the `pattern` slot, my string into the `string` slot, and either leave flags alone, or understand that its referring to the syntax for defaults, and remove it.\n\nIt seems geared towards mindful consumption, not mindless consumption, but that is just how I view it and I'm pretty sure my view is wrong though", "id": "d7e56ig"}, {"comment": "But [`re` has good docs](https://docs.python.org/3/library/re.html#module-re) (don't be blind to the menu), and additionally in the first screen-worth of text:\n\n>A brief explanation of the format of regular expressions follows. **For further information and a gentler presentation, consult [the Regular Expression HOWTO](https://docs.python.org/3/howto/regex.html#regex-howto)**.\n\nWhich eventually ends with:\n\n>Feedback\n\n>Regular expressions are a complicated topic. Did this document help you understand them? Were there parts that were unclear, or Problems you encountered that weren\u2019t covered here? If so, please send suggestions for improvements to the author.\n\n>The most complete book on regular expressions is almost certainly Jeffrey Friedl\u2019s Mastering Regular Expressions, published by O\u2019Reilly. Unfortunately, it exclusively concentrates on Perl and Java\u2019s flavours of regular expressions, and doesn\u2019t contain any Python material at all, so it won\u2019t be useful as a reference for programming in Python. (The first edition covered Python\u2019s now-removed regex module, which won\u2019t help you much.) Consider checking it out from your library.\n\nWhat more can you reasonably expect from docs about how to use Python's regen stuff, than docs that both cover Python's implementation, and Regex in general, and link to other popular guides in a different format if the webpage approach isn't working for you?", "id": "d7e5hhr"}, {"comment": "I don't disagree about the quality of the documentation personally, but its definitely got enough pitfalls still.\n\nlongform documentation creates a lot of understanding, but its less accessible to those who are busy, or don't care about the ins and outs", "id": "d7e5o1b"}, {"comment": "> those who are busy, or don't care about the ins and outs\n\nBut we're talking about learning *Regular Expressions* here.  \nFuck the people who are 'too busy' or don't care but then complain they can't 'just make it work'.\n\nWhere are REs easy?", "id": "d7e5qvv"}, {"comment": "There are also the people who do know the ins and outs but want to find out some specific detail. I know regular expressions fairly well, but I might go to the docs if, say, I want to match a `?` literal inside a character class and I don't remember if I need to escape it or not. Or maybe I want to create a non-capturing group, which is something I do pretty rarely, and I forget the syntax. Longform documentation sucks for answering those kind of questions. I don't want to have to read a paragraph about what a non-capturing group is before I get to the syntax for it. (Pythons regex docs were actually pretty good for those two particular questions, though)", "id": "d7ep14m"}, {"comment": "Using regexes without knowing the ins and outs is like using a gun without knowing where the barrel is pointing.", "id": "d7e8jnf"}], [{"comment": "I'm surprised not to have noticed any mentions of the new [Stack Overflow Documentation](http://stackoverflow.com/documentation/python/topics) initiative, which is literally designed to improve and standardise documentation for people learning new languages or frameworks.\n\nAs someone who has only had very minor exposure to Python (and did so before Python 3), can anyone comment on how useful the platform appears to be at solving the OP's complaints?", "id": "d7e5ddz"}, {"comment": "Nice: http://stackoverflow.com/documentation/python/632/regular-expressions#t=201609082002283770623&a=syntax", "id": "d7eo7yl"}], [{"comment": "Suggestion: make a pull-req to the docs instead of writing this kind of bullshit. Bad documentation? Compared to what? \nAs someone else said above, this is clickbaiting for selling their book.", "id": "d7e89d9"}], [{"comment": "[deleted]", "id": "d7ead2t"}, {"comment": "Seriously, I'm no genius and have never once been confused by the Python docs.", "id": "d7ede3u"}], [{"comment": "The API documentation is... API documentation. It's for use as a reference, although some have good examples. There are some incomplete ones, like the multiprocessing page that doesn't mention the threading-based pool that the module includes as an alternative to its multiprocessing-based one.\n\nIn general, when I'm looking into a standard library that I haven't used before, I look at its PyMOTW page. These pages usually appear pretty high up on Google and usually have plenty of examples to get you going. You can then turn to the documentation for reference on specifics.\n\nWhen I first learned Python almost 10 years ago, the only problem I had was that all the guides were geared towards new devs. There were no \"you've been programming for a long time, here's a quick overview on how to accomplish basic tasks in Python and structure your programs\". I'm currently having that problem with Scala, in which *every single guide* assumes that I've never used a functional programming language and spends 90% of its time on that.\n\nA lot of this article is bullshit though.\n\n\"You know who uses simple, self contained examples and tutorials? Every. Other. Language. In. The. World.\"\n\nNonsense. There are plenty of Python ones that do and plenty of guides in other languages that don't. This really seems like a bias resulting in the author thinking that Python is unique simply because it was causing the most pain for him at that moment.\n\nI've picked up many, many languages over my life and will pick up many more. Python was nowhere near the hardest or had the worst community (I reserve that for the JavaScript tutorials that go over pages of build systems and dependencies to get to a hello world example for something). He mentioned PEP 8 and other PEP adherence at the end like it's a terrible thing. Thing is, I'll never shit on someone's code for not following PEP 8 or other standards, and I frequently disregard certain aspects (I use 120 width columns instead of 80). But having a community accepted style guide, along with [guides like these](https://jeffknupp.com/blog/2013/08/16/open-sourcing-a-python-project-the-right-way/) means that it's so much easier to read code written by people who follow them. The whole \"blind fanatical adherence to the church of PEP 8\" is an old strawman.", "id": "d7eduyd"}], [{"comment": "I don't see which beginners the OP is talking about. At one end, you have people who know how to program in other languages. These people would be used to the fact that documentation for a programming language won't make perfect sense until one has internalized the mindset for using that language. At the other end are total beginners to programming, who nobody would expect to be able to use any reference documentation.\n\nThis reminds me of the anecdotal managers long ago who expected programmers to do what they were told and do it fast, because it's \"just typing\". Do people expect programming to be easy?", "id": "d7egv8k"}], [{"comment": "I gave up Python because of how bad the official site is. Java and C all the way. I want to love Python because of how easy it seems. But the docs are just crap, and that has a lot to do with how good language ends up being. ", "id": "d7enift"}], [{"comment": "By far the worst part is the official documentation. But I guess at least there's a stackoverflow for literally anything you can imagine about python.", "id": "d7e2ibo"}, {"comment": "Really? I've long thought that Python and most of it's popular libraries had some of the best documentation I've seen; it was one of my first programming languages, and I learned it largely by reading the official documentation.\n\nCompare to Ruby, where the docs are often little more than lists of method arguments, or Qt, where there's tons of detailed info on individual methods, but little in the way of higher level overviews on how things fit together.", "id": "d7e3qju"}, {"comment": "Have to agree with OP. When I look up an API reference, each function should have the following items:\n\n* short description\n* arguments with relevant info such as range, sentinel values, null behavior\n* retun value\n* exceptions it can throw, python seriously lacks here\n* detailed description with some under-the-hood information, unintuetive behavior\n* example (optionally)\n\nCompared to Java or even Win32 the Python docu is very unstructured, and it takes a lot more time to find the desired information.", "id": "d7e6ku9"}, {"comment": "Yeah same here. I've been really confused by this thread because I always found the python documentation extremely helpful, along with the documentation of some popular libraries. Python was my first programming language too so I came into it as a complete beginner and had no trouble.", "id": "d7e53g8"}, {"comment": "I typically avoid it for anything new, as they lack examples. Unfortunately this means going to stackoverflow or some blog post, to then find out the code works on a different python version, or the module referenced is no longer maintained. ", "id": "d7e3d9d"}, {"comment": "I've seen a lot of example in the Python docs. \n\nhttps://docs.python.org/3/library/functools.html\n\nhttps://docs.python.org/3.2/library/contextlib.html\n\nhttps://docs.python.org/3.2/library/re.html\n\nhttps://docs.python.org/3.2/library/json.html\n\nA whole lot of the standard libraries have quick examples with output to demonstrate functionality. ", "id": "d7e6202"}], [{"comment": "Puppies? I'm learning python! ", "id": "d7e36zv"}], [{"comment": "Love Python, hate the documentation. Its woeful compared to other languages. Just a basic example with what the function expects and returns is all that's needed.", "id": "d7e3rnq"}], [{"comment": "I completely disagree. The [Anaconda Python Distribution](https://www.continuum.io/downloads) makes it quite easily to setup and use (there are many others too, like [ActiveState Python](https://www.activestate.com/activepython) or [Python XY](https://python-xy.github.io/)) and there are quite a lot of good tutorials for python ([ZetCode](http://zetcode.com/) or [Invent With Python](http://inventwithpython.com/chapters/) for example). Also not sure where you're getting horrible docs for python from, but the official ones are quite nice to work with and easily searchable.", "id": "d7e66ru"}, {"comment": "Interesting that they're re-using the Anaconda name in a Python context.  Anaconda was also the name of the Red Hat Linux installer years ago, and actually what first got me interested in Python :)", "id": "d7eneqh"}, {"comment": "Never knew that, interesting thing to learn. Wondering if it's related in anyway.", "id": "d7eorg8"}, {"comment": "Anaconda is still the installer for RHEL/Fedora/Centos iirc", "id": "d7eugm3"}], [{"comment": "'pip install -r requirements.txt'\nCan't be much simpler imo. \n\nOh, and fuck php that inconsistent buggy piece of shit.\n", "id": "d7e8tsp"}, {"comment": "If it works. In a default install on windows, will probably just blow up with various tracebacks, compilers not found or permission problems (because you installed as Administrator and try to run pip as user for example).", "id": "d7ecpqk"}], [{"comment": "lol python is half assed scripting language that got used outside it's scope. it's best for small throw away unix scripts. oh well, you people are the reason we can't have nice things but now we have broken brittle python infrastructure to deal with, smh.", "id": "d7ea20w"}], [{"comment": "the nonstop whining that came from that python documentation post is really amazing considering no one else had said anything prior to that point, and while learning i had no problem with using the documentation especially compared to C++ docs the author mentions\n\nlike seriously it just never stops with people doing shitty blog posts with meme names \"Le Python Is Le Bad, ANd U should FEel Le BAD!!!\", it's like these people want the document to be self morphing so they can just copy paste code and have scripts build themselves", "id": "d7eae46"}, {"comment": "The real shame is that they could have put that same effort into improving the docs.  But that wouldn't have gotten them as many blog hits.", "id": "d7enio6"}], [{"comment": ">The web service to this account has been limited temporarily!\n\nMirrors?\n\nFound Google Cache!", "id": "d7ecbne"}], [{"comment": "I had all these library problems when using windows 10, now that I use Ubuntu Mate, it's so much better but I still end up googling some problems from time to time, which I'm okay with. ", "id": "d7egv13"}], [{"comment": "Since it specifically refers to contemporaneous events, it's a big problem that this article isn't dated. Is this information still accurate at all?\n", "id": "d7elig0"}], [{"comment": "I haven't read the article but its thumbnail is a cut husky puppy being given a tummy rub... If that's what beginner programmers get then I'm going to have to unlearn Python. ", "id": "d7em37t"}], [{"comment": "I have just recently started with Python, but haven't experienced this. I totally feel like a noob, yes, but somewhere deep down I enjoy it. Also I think it's pretty rewarding to make it work after long minutes of troubleshooting.", "id": "d7eni81"}], [{"comment": "I only looked at the puppy. What did the article say?", "id": "d7eoezx"}], [{"comment": "I have been programming in python for a few years, I am not a beginner but recently I have been feeling like a beginner as I am trying to learn \"proper\" (aka pythonic) web development with flask.  \n\nThe documentation is what is frustrating me.  It's hit and miss, it's often missing a lot of key information and one of the first things I look for is *examples* of code which are never easy to find.\n\nMore specific example is I am working on the reset password portion of my website.  I've already used Flask-Login for login management.  I find many packages and settle with Flask-Security as it look's the easiest to use.  It promises a number of different functions (such as resetting passwords) but doesn't show how to use them.  I learn after digging that just by going `security = Security(app)` in my code all these features are turned on.  Great so now I have 2 logins, I have a registration form in a way that I don't want.  I can't figure out how to turn off some of these features and I can't find out how to integrate them into my already existing layouts.\n\nI find myself more often than not looking at StackOverflow and Github code for examples to get python modules to work as the docs generally result in the last place I want to look.\n", "id": "d7eplop"}], [{"comment": "I recently picked up Python and haven't had anywhere near the trouble that this guy had. I haven't experienced any trouble with libraries and while the docs aren't very good (I didn't think PHP docs were much better though) Python is so popular it's not hard to find better documentation and examples elsewhere on the internet.\n\nI chose Python as one my two main languages of choice, the other being Rust.\n\nCan everybody just move to Python 3 please?", "id": "d7epp9n"}], [{"comment": "[deleted]", "id": "d7epwlq"}, {"comment": "Maybe to not have to install libraries system-wide at all, like with other sane build tools?", "id": "d7eqity"}, {"comment": "theres virtualenv for that\n", "id": "d7erou5"}, {"comment": "Aside from being tedious to set up and very beginner unfriendly, [virtualenv is the worst solution to a problem that shouldn't exist in the first place](https://www.google.com.au/amp/s/pythonrants.wordpress.com/2013/12/06/why-i-hate-virtualenv-and-pip/amp/?client=ms-android-htc-rev).", "id": "d7f5l89"}], [{"comment": "If you are a beginner on linux, you install libraries solely by `apt install python3-libname`. And they just work.", "id": "d7eqx8k"}], [{"comment": "I've been having a blast with python. Visual Studio tools python and stackoverflow documentation is an amazing combination ", "id": "d7ero0f"}], [{"comment": "Is this satire? Blaming Python for the author's decision to do everything manually instead of using a package manager was silly, but I had to actually stop reading when it praised the PHP documentation.", "id": "d7esmy7"}, {"comment": "> but I had to actually stop reading when it praised the PHP documentation\n\n...Which didn't visibly deprecate the use of the notoriously uber-bad `mysql` extension until around, like, PHP ~~6~~ 7.\n\nAnd has *really* outdated examples.", "id": "d7gsg8t"}], [{"comment": "Installing libraries in Python involves running the `pip` command. If it needs to compile code, it might fail due to a missing library or mismatched version of something, which sucks and is frustrating. A C++ newbie who needs to use a library will need to learn how to link against it and how to get their IDE to do auto-completion. A newcomer to Java will need to mess with their Eclipse Build Path or Maven (ugh) or something.\n\nThe Python official documentation is of varying quality. Generally I find that it works nicely as a written tutorial, but it sucks as a reference. An example is given of the `len` function, documentation for which resides in a page about *all* the builtin functions. Conversely, if you were to try to learn how to use a list, then the official tutorial is a great place to start. I believe this is entirely a non-issue since if you google \"python list length\" you'll get the result in the Google blurb.\n\nAs to providing bad documentation for libraries as an ideology, all I can say is that I've never once encountered that. Naturally I've only tried to use a tiny fraction of the Python libraries. Any concrete examples?\n\ntl;dr: The Python official documentation sucks if you want to use it as a reference. Therefore you should use Google as a Python reference, and the official documentation for module overviews and tutorials.", "id": "d7euzex"}], [{"comment": "Number 1 is a problem for a lot of languages.\n\nI would say another very big issue when starting out with any new language or framework is the setup and configuration. And a lot of it ties back to the problem of dependant libraries.\n\nI feel that in most cases the developers/authors of any particular framework, live in this strange ideal world, where they only use their framework, and nothing else, on their machine. Like everything just works because that's all it does.\n\nIn reality we get conflicts, we don't have access to old versions of specific libraries, we have to run specific versions of other tools to do other functions.\n\nI find I spend more time setting up my environment to start work, than I do working, in a lot of cases.\n\nI feel there needs to be more effort put into providing turn-key frameworks. Download a installation package, double click it and it'll install and setup everything you need to use that framework. Think of how quick it is to get into writing code in Visual Studio or Eclipse (well... kinda), after installation, you really just click \"new\" and you're up and running, nothing else to configure, it just works.", "id": "d7evgd0"}], [{"comment": "From http://cryto.net/~joepie91/blog/2013/02/19/the-python-documentation-is-bad-and-you-should-feel-bad/\n\n> If you do something in a less-than-optimal way, other Python developers will shout about how horrible you are without bothering to explain much about what you did wrong.\n\nThis is totally true. When people want to bash LPTHW they just show you this link:\n\nhttp://sopython.com/wiki/LPTHW_Complaints\n\nThis fanboyism really annoys me.", "id": "d7evrhn"}], [{"comment": "I can only agree with OP. It is OK to write a 100 loc script in Python relying only on standard library, when in need of something larger - choose a serious language.\nI learned Java after Python and I love it. Granted IDE really helps and makes coding in Java a delight.\nAlso I find it really hard to read other people code in Python (not so with Java), I suspect dynamic typing is to blame.", "id": "d7fcnq1"}]]], "4o1pfs": ["How a college student tricked 17k coders into running his sketchy script", "2016-06-14 18:42:10", 1, "http://arstechnica.com/security/2016/06/college-student-schools-govs-and-mils-on-perils-of-arbitrary-code-execution/", [[11, "This is the best tl;dr I could make, [original](http://arstechnica.com/security/2016/06/college-student-schools-govs-and-mils-on-perils-of-arbitrary-code-execution/) reduced by 86%. (I'm a bot)\n*****\n> Using a variation of a decade-old attack known as typosquatting, he uploaded his code to three popular developer communities and gave them names that were similar to widely used packages already submitted by other users.\n\n> Over a span of several months, his imposter code was executed more than 45,000 times on more than 17,000 separate domains, and more than half the time his code was given all-powerful administrative rights.\n\n> Before it did, the code sent a Web request to a university computer so he could keep track of how many times his untrusted code was executed and whether administrative rights were given.\n\n\n*****\n[**Extended Summary**](http://np.reddit.com/r/autotldr/comments/4o24dm/how_a_college_student_tricked_17k_coders_into/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ \"Version 1.6, ~68034 tl;drs so far.\") | [Theory](http://np.reddit.com/r/autotldr/comments/31bfht/theory_autotldr_concept/) | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr \"PMs and comment replies are read by the bot admin, constructive feedback is welcome.\") | *Top* *keywords*: **attack**^#1 **code**^#2 **developer**^#3 **Package**^#4 **research**^#5"], [3, "I found the paper on [Bitsquatting](https://media.blackhat.com/bh-us-11/Dinaburg/BH_US_11_Dinaburg_Bitsquatting_WP.pdf) linked in the article more interesting than the article. "], [1, "Meh, his package could have been running on a VM or a container like Docker..."]], [[{"comment": "This is the best tl;dr I could make, [original](http://arstechnica.com/security/2016/06/college-student-schools-govs-and-mils-on-perils-of-arbitrary-code-execution/) reduced by 86%. (I'm a bot)\n*****\n> Using a variation of a decade-old attack known as typosquatting, he uploaded his code to three popular developer communities and gave them names that were similar to widely used packages already submitted by other users.\n\n> Over a span of several months, his imposter code was executed more than 45,000 times on more than 17,000 separate domains, and more than half the time his code was given all-powerful administrative rights.\n\n> Before it did, the code sent a Web request to a university computer so he could keep track of how many times his untrusted code was executed and whether administrative rights were given.\n\n\n*****\n[**Extended Summary**](http://np.reddit.com/r/autotldr/comments/4o24dm/how_a_college_student_tricked_17k_coders_into/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ \"Version 1.6, ~68034 tl;drs so far.\") | [Theory](http://np.reddit.com/r/autotldr/comments/31bfht/theory_autotldr_concept/) | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr \"PMs and comment replies are read by the bot admin, constructive feedback is welcome.\") | *Top* *keywords*: **attack**^#1 **code**^#2 **developer**^#3 **Package**^#4 **research**^#5", "id": "d48vyr1"}, {"comment": "key details: the \"popular developer communities\" were PyPi, RubyGems, and NPM.", "id": "d495py9"}], [{"comment": "I found the paper on [Bitsquatting](https://media.blackhat.com/bh-us-11/Dinaburg/BH_US_11_Dinaburg_Bitsquatting_WP.pdf) linked in the article more interesting than the article. ", "id": "d495rzc"}], [{"comment": "Meh, his package could have been running on a VM or a container like Docker...", "id": "d48wxwn"}, {"comment": "Most production Rails and Node apps are probably running in containers or VMs, but remember that for every production app, there are multiple developers who are running the app in development mode on their local machines.\n\nI'd be surprised if this sort of typo squatting hasn't already been used to inject malicious and code in the wild.", "id": "d490auq"}, {"comment": "heh malicious code in the wild is the least of it, this could be used in impersonation attacks on 'websites'.", "id": "d494ta7"}, {"comment": "his package could of replaced express.js with expes.js which sends a copy of the users password to his own personal offsite server...", "id": "d495sz0"}]]], "4u9ezb": ["Goodbye, Object Oriented Programming", "2016-07-23 22:31:00", 0, "https://medium.com/@cscalfani/goodbye-object-oriented-programming-a59cda4c0e53", [[24, "You could keep an entire village warm in winter by burning the strawman that's been built here."], [19, "I literally knew the last paragraph would be about how functional programming is much better than OOP. If you thought one paradigm would solve every problem, you thought wrong the start. Good thing the author learned their lesson and just switched to a new singular paradigm. "], [11, "You were looking for a silver bullet not for a programing paradigm. What happened is that you noticed that it is not always possible, convenient or appropriate to use OOP. The same is true for other paradigms."], [7, "Personally if I run into these issues, it means it is time for a refactor. Interfaces and classes usually work quite well when you first write them, howeven even if you plan for the future things could still break apart. Instead of worrying about it, get it fixed. If you keep your code stored nicely in modules then refactoring should not cause major rewrites or breakage (except with a dependency family)."], [5, ">Inheritance, the First Pillar to Fall\n\nUtilize composition, not inheritance, whenever possible."], [4, "Oh, so when you reuse a class from an old project, you have to bring over the parent class?  WHO KNEW?!?!  It's almost like *every object framework in existence*.  That's also why you don't make deep inheritance trees.  Stopped reading right there.\n"], [3, "Lol, this guy also has an article called \"the point and click generation\"\n\nWhat a twat\n"], [2, "There is a large difference between object-oriented Programming and an object oriented language.  \n> Inheritance, Encapsulation, and Polymorphism. The Three Pillars of the Paradigm.\n\nYes, they are and they don't have much to do with some keywords. They are a way how you organize your code.\n\nThe most important are in my opinion abstraction and encapsulation: \nI believe the old argument \"Encapsulation allows you to reason about code without knowing the implementation\" is wrong or at least looks at the problem from the wrong side. Encapsulation is so great because it let's you know which function are accessing the data at the core of your object. When you change something (or add a new field) you only have to check with these functions if they preserve consistency, how they interact with your feature. People who never programmed in non-OOP code don't know the feeling of grepping your code base for a struct member and having it popping up everywhere. And the language support needed? The ability to define your own data structures. (Without that, it is probably possible, but masochistic.)\n\nAnd lamenting that you can break encapsulation? You can program OOP even if the language does not force you to do it.\n\nInheritance: Yep inheritance is often misunderstood. The main function of inheritance is to enable polymorphism and let you reuse code of it's **ancestors**. No, you can't easily reuse code of another project. But even functions from your functional language of choice need all the functions they are composed of and those these are composed of.. . Given this is probably worse in OOP with all the reference holding. And what is this rambling that Hierarchies don't work? Documents into company folder or company  into documents folder. Why not both? \nYou make two folder objects tag them with Company and documents respectively and put a documents folder into your Company folder and a Company folder into your documents folder. Both hold a reference to Company documents; really easy to find (and harder to remove). The thing is this is a \"contained in\" hierarchy and the problem is that Company documents would have to be contained in both even in the real world. (You disprove your own solution). Inheritance is for shared behavior. And where the behavior is shared is clear: Company documents are clearly documents and they can be accessed like documents. Company documents are not a Company or have anything meaningful in common with a company.\n\n\nPolymorphism: yes polymorphism is great makes a lot easier to read your code (not necessarily to finding bugs  mind you) and reduces your code. But you seem only to advocate for another java specific type of polymorphism. I don't see that pillar wanking anywhere.\n\nYour programming style is your choice as long as a language does provide the minimal necessary means to implement OOP you can do it by convention. Now go and implement your vtables in C.\n\n> Good-bye, Object Oriented Programming.\n\nToo bad you discarded it without trying it out.\n\n\n\n\n\n"], [4, "Good bye. Hope I'll never see you again.\n\nSincerely,\nOOP"], [1, "In the first sentence states that the author has used OO languages for decades. "], [1, "Here's a tip for you new programmers: it's almost never a mistake to start a project with an FP approach, it's almost always a mistake to start with OO.  Values are simpler than places, functions are simpler than classes and methods, combinators are simpler than loops and mutation.  Start with an FP approach, sprinkle some imperative programming when it's a little more convenient or necessary for performance, and you'll have a lot less difficulty writing code."], [1, "Dude should read POODR by Sandi Metz.\n\nUse inheritance for specialization, not behavior sharing. Also, use hooks in your base classes to avoid the \"fragile base class\" problem."], [-1, "TLDR? so much text"]], [[{"comment": "You could keep an entire village warm in winter by burning the strawman that's been built here.", "id": "d5nvef3"}, {"comment": "Agreed, all I'm getting is \"I didn't really understand what I was doing so the problems are the languages fault\"", "id": "d5nw5rn"}, {"comment": "Oh look, \"You're using it wrong\" argument. All issues mentioned in article are legit. This is not the first time someone criticized OOP, let's look at the typical \"OOP Defend Squad\" arguments: \n\n> You're using it wrong\n\nOOP was invented more than 50 years ago and if we still can't figure out what \"True OOP\" is then it's a problem. It seems everyone has it's own vision of OOP, which leads to this kind of arguments.\n\n>It's just a paradigm, not a silver bullet\n\nThe whole point of paradigms is that they should help in general. No one says \"Structural programming is just a paradigm\" because it works for everyone, in general. OOP on the other hand makes your code slow, bloated and hard to teach.", "id": "d5olhgn"}, {"comment": "> OOP was invented more than 50 years ago and if we still can't figure out\n\nWho is \"we\" here? Very, very, very many of us are using OO with great success and relatively few complaints.\n\n> OOP on the other hand makes your code slow, bloated...\n\nThis assertion simply doesn't stand up to much scrutiny. ", "id": "d5os2eo"}, {"comment": "Nobody forced the author to use OOP.  He used it, and then publically complained about it.  That's all very well, and naturally those of us who use OOP successfully every day are going to defend it.\n\n> OOP on the other hand makes your code slow, bloated and hard to teach.\n\nSpeak for yourself.\n", "id": "d5pdkj3"}, {"comment": "I prefer DDD to OOP these days.  The implementation is just details.", "id": "d5qzbqh"}, {"comment": "Ye it's pretty bad", "id": "d5nvi49"}, {"comment": "While your metaphor is quite humorous, I think you misused the term strawman.\n\nA strawman is a misstated and weaker version of an OPPONENT'S argument in order to defeat it.\n\nSince there is no opponent, there is no strawman.", "id": "d5nzme8"}, {"comment": "> strawman: a sham argument set up to be defeated.\n\nAlso the \"opponent\" could be OOP supporters.", "id": "d5o6cyd"}, {"comment": "That's a strawman definition of strawman fallacy :)\n\n> [a weak or imaginary opposition (as an argument **or** adversary) set up only to be easily confuted](http://www.merriam-webster.com/dictionary/straw%20man)", "id": "d5ol0q1"}, {"comment": "\\#2meta4u", "id": "d5pdu5c"}], [{"comment": "I literally knew the last paragraph would be about how functional programming is much better than OOP. If you thought one paradigm would solve every problem, you thought wrong the start. Good thing the author learned their lesson and just switched to a new singular paradigm. ", "id": "d5o8ws5"}], [{"comment": "You were looking for a silver bullet not for a programing paradigm. What happened is that you noticed that it is not always possible, convenient or appropriate to use OOP. The same is true for other paradigms.", "id": "d5o9nh7"}], [{"comment": "Personally if I run into these issues, it means it is time for a refactor. Interfaces and classes usually work quite well when you first write them, howeven even if you plan for the future things could still break apart. Instead of worrying about it, get it fixed. If you keep your code stored nicely in modules then refactoring should not cause major rewrites or breakage (except with a dependency family).", "id": "d5o42re"}, {"comment": "No amount of refactoring will solve the fragile base class problem for example. ", "id": "d5o4ojy"}, {"comment": "If you run into the fragile base class problem then there is a problem with your design. For my current project I only hit into it a few times, yet I was able to refactor it away by switching to a design which works far better.\n\nThere is no law or requirement that states that you must follow the \"guidelines\" of OO literally all the time.\n", "id": "d5o6lbw"}, {"comment": "Agreed that the design is problematic. But wouldn't it be better if the paradigm that you're using wasn't \"fragile\" (no pun intended) and that you didn't have to worry about these kinds of problems?\n\nFYI, I haven't used Inheritance for over 15 years. Everything I've done in Java or .NET has been contain and delegate. So we agree there too :-)", "id": "d5o75dz"}, {"comment": "Personally, use the paradigm that is right for the problem. If OO works, use it. If functional works, use it.\n\nAlso, with Java 8, the language is more functional now.", "id": "d5o98rq"}, {"comment": "> FYI, I haven't used Inheritance for over 15 years. Everything I've done in Java or .NET has been contain and delegate. \n\nIf you're using either of those, you're using inheritance, whether you like it or not.\n\nAnd it sounds like an enormous maintenance nightmare to avoid inheritance completely just for the sake of avoiding it.\n", "id": "d5p175h"}, {"comment": "What I meant by that is that my classes NEVER inherited from anything (unless I couldn't help it as in the case of Exceptions which I stopped doing when at all possible).\n\nAnd avoidance was NOT an academic exercise. I avoided it to write better software with lower cognitive overhead.", "id": "d5p1gac"}, {"comment": "You're assuming that in every case you have better software by not using inheritance.  That isn't necessarily true.  Whenever someone starts following a rule of \"never\" and \"always\" in software development, I assume they are no longer thinking critically and probably end up doing the wrong thing some amount of the time (especially if you're capitalizing never).\n\n", "id": "d5p2kiv"}, {"comment": "You assume wrong. I thought very critically about Inheritance. I was teaching a class at work on OO and questions arose that made me start to question the paradigm.\n\nThe very week I fully understood the Fragile Base Class problem was the same week where code I helped a coworker with broke when he updated his JDK. Seems Sun had changed a base class implementation. It tooks us all afternoon to hunt down that problem.\n\nExperience has taught me that Inheritance is ALWAYS worse (yes, I did capitalized) than Contain and Delegate. And in the 15+ years since then, I never encounter a single instance where Contain and Delegate was lacking or where it failed and Inheritance would have saved the day.", "id": "d5p2wn4"}, {"comment": "I'm glad you have it all figured out.  Have fun with your religion.  C&D is like dependency injection.  It can lead to interfaces that are so unwieldy as to be unusable.  Not to mention a huge maintenance nightmare when a caller needs to pass in references to half a dozen objects to make your one function do something.  We used to have those.  They were called \"parameter blocks\".  And they were awful candy machine interfaces.  And we hated them.  We cleaned them up with the magic of (TA DA!) object-oriented programming and inheritance.  All that is new and shiny isn't all that new or shiny.  Congratulations, you have now reached the plateau of software engineering called \"tradeoffs\" where you realize there is rarely one way which is always better.\n\n\n\n", "id": "d5p3hkj"}, {"comment": "Oh... Don't mistake my certainty of what's wrong with me thinking I know everything that's right.", "id": "d5p4lxt"}, {"comment": "> Contain and Delegate\n\nI remember when it was called HAS-A\n", "id": "d5qz0q2"}, {"comment": "For all the talk about fragile base classes, I simply can't remember a time when this problem actually held me back in any significant way. This simply doesn't register as a thing I spend time one when developing real code.\n\nAnd this is coming from a guy who does relatively little \"upfront\" design, and a whole lot more \"let the design emerge as I refactor\".", "id": "d5os73b"}, {"comment": "Too bad you can only guess, if your design is good or bad upfront. There are some indicators, but unlike what they teach you about the wonders of OOP, OOP is no different than any other design pattern or paradigm: You chose the lesser evil, or sometimes angels turn out to be demons.\n\nFunctional isn't a silver bullet, but if you actually start to stick to good OOP practices, you will use several principles of functional programming, and you will start using less and less extremely hierarchical classes that hold the false promise of re-usability. Forget reusing something encapsulated, you will always run into issues, even though the state is hidden from the user, the only thing you can reuse safely are pure functions.", "id": "d5r8zuw"}, {"comment": "Composition? It's been a paradigm for quite a while now, and is considered to be far superior to inheritance.", "id": "d5pig19"}], [{"comment": ">Inheritance, the First Pillar to Fall\n\nUtilize composition, not inheritance, whenever possible.", "id": "d5pieoc"}], [{"comment": "Oh, so when you reuse a class from an old project, you have to bring over the parent class?  WHO KNEW?!?!  It's almost like *every object framework in existence*.  That's also why you don't make deep inheritance trees.  Stopped reading right there.\n", "id": "d5nyvfr"}, {"comment": "Of course, when one reuses a function, it's not necessary to \"bring over\" the other functions it calls. That's why you don't make deep function call hierarchies.\n\nWait...", "id": "d5os918"}], [{"comment": "Lol, this guy also has an article called \"the point and click generation\"\n\nWhat a twat\n", "id": "d5oi1zj"}], [{"comment": "There is a large difference between object-oriented Programming and an object oriented language.  \n> Inheritance, Encapsulation, and Polymorphism. The Three Pillars of the Paradigm.\n\nYes, they are and they don't have much to do with some keywords. They are a way how you organize your code.\n\nThe most important are in my opinion abstraction and encapsulation: \nI believe the old argument \"Encapsulation allows you to reason about code without knowing the implementation\" is wrong or at least looks at the problem from the wrong side. Encapsulation is so great because it let's you know which function are accessing the data at the core of your object. When you change something (or add a new field) you only have to check with these functions if they preserve consistency, how they interact with your feature. People who never programmed in non-OOP code don't know the feeling of grepping your code base for a struct member and having it popping up everywhere. And the language support needed? The ability to define your own data structures. (Without that, it is probably possible, but masochistic.)\n\nAnd lamenting that you can break encapsulation? You can program OOP even if the language does not force you to do it.\n\nInheritance: Yep inheritance is often misunderstood. The main function of inheritance is to enable polymorphism and let you reuse code of it's **ancestors**. No, you can't easily reuse code of another project. But even functions from your functional language of choice need all the functions they are composed of and those these are composed of.. . Given this is probably worse in OOP with all the reference holding. And what is this rambling that Hierarchies don't work? Documents into company folder or company  into documents folder. Why not both? \nYou make two folder objects tag them with Company and documents respectively and put a documents folder into your Company folder and a Company folder into your documents folder. Both hold a reference to Company documents; really easy to find (and harder to remove). The thing is this is a \"contained in\" hierarchy and the problem is that Company documents would have to be contained in both even in the real world. (You disprove your own solution). Inheritance is for shared behavior. And where the behavior is shared is clear: Company documents are clearly documents and they can be accessed like documents. Company documents are not a Company or have anything meaningful in common with a company.\n\n\nPolymorphism: yes polymorphism is great makes a lot easier to read your code (not necessarily to finding bugs  mind you) and reduces your code. But you seem only to advocate for another java specific type of polymorphism. I don't see that pillar wanking anywhere.\n\nYour programming style is your choice as long as a language does provide the minimal necessary means to implement OOP you can do it by convention. Now go and implement your vtables in C.\n\n> Good-bye, Object Oriented Programming.\n\nToo bad you discarded it without trying it out.\n\n\n\n\n\n", "id": "d5oiz7q"}], [{"comment": "Good bye. Hope I'll never see you again.\n\nSincerely,\nOOP", "id": "d5omrfu"}], [{"comment": "In the first sentence states that the author has used OO languages for decades. ", "id": "d5oprh6"}], [{"comment": "Here's a tip for you new programmers: it's almost never a mistake to start a project with an FP approach, it's almost always a mistake to start with OO.  Values are simpler than places, functions are simpler than classes and methods, combinators are simpler than loops and mutation.  Start with an FP approach, sprinkle some imperative programming when it's a little more convenient or necessary for performance, and you'll have a lot less difficulty writing code.", "id": "d5pkx9r"}], [{"comment": "Dude should read POODR by Sandi Metz.\n\nUse inheritance for specialization, not behavior sharing. Also, use hooks in your base classes to avoid the \"fragile base class\" problem.", "id": "d6s7uq5"}], [{"comment": "TLDR? so much text", "id": "d5o0xg1"}]]], "3w1ma9": ["Was \u200bApple the first major open-source company? Not even close", "2015-12-09 09:58:51", 2, "http://www.zdnet.com/article/apple-was-the-first-major-open-source-company/", [[47, "[deleted]"], [13, "Don't they contribute a lot in either llvm or clang? I wouldn't say the article is totally wrong but they are not only taking benefit either."], [9, "lol"], [5, "On the first anniversary of .NET open source, no doubt."], [5, "I like how apples claim of the being:\n\n> the first major computer company to make Open Source development a key part of its software strategy\n\nis being translated as:\n\n> The first major company to contribute to open source.\n\nI haven't used a Mac in years, and I think their claim is disingenuous, but it might actually be technically true.\n\n> major *computer* company\n\nThey're not competing with tech companies here, just companies that make computers. HP, Lenovo, Toshiba. Do these companies strike you as open source drivers? The inclusion of the word computer, specifically understanding that computer could refer just to companies that ship computers, makes their claim much smaller than people read it at first (very astute half-truths, they should run for office).\n\n>  Open Source development a key part of its software strategy\n\nHere's the other thing that keeps them 'safe'. IBM is a major company that makes computers and has contributed to open source before Apple did. But no open source contributions that IBM made was ever a key part of its software strategy, whereas Swift is a key part of Apple's software strategy.\n\nSo, yes, it is lulz for _Apple_ to say this. But I think the claim is actually, technically true..."], [3, "IBM is probably the oldest big company to support open-source, but I don't think they were the first."], [0, "No shit, Sherlock. ~~The original GPL even had a clause specifically preventing executing the code on MacOS due to their closed practices...~~ edit: The original FSF FAQ recommended against porting software to Apple computers and did not support A/UX.\n\nedit 1: unsure if it was the GPL itself or some other doc. I think it was connected to gcc. I'll try to dig that up.\n\nedit 2: [Wikipedia](https://en.wikipedia.org/wiki/Richard_Stallman) references the controversy.\n\n\"In response to Apple's Macintosh look and feel lawsuits against Microsoft and Hewlett-Packard in 1988, Stallman called for a boycott of Apple products on the grounds that a successful look-and-feel lawsuit would \"put an end to free software that could substitute for commercial software\".[62] The boycott was lifted in 1995, which meant the FSF started to accept patches to GNU software for Apple operating systems.[63]\"\n\nBut I still need to find the exact wording in released software from RMS\n\nedit 3: Got It:\n\n[From emacs 18.59, Oct 31, 1992 FAQ](https://ftp.gnu.org/old-gnu/emacs/emacs-18.59.tar.gz):\n\n    101: Where can I get Emacs for my Apple computer?\n    \n    The FSF is a participant in a boycott of Apple because of Apple's \"look\n    and feel\" copyright suits.  See the file etc/APPLE for more details.\n    Because of this boycott, the FSF doesn't include support in GNU software\n    for Apple computers such as the Macintosh.\n    \n    Please don't help people port or develop software for Apple computers.\n\nYou can read the APPLE file in the archive for the details."], [-8, "http://opensource.apple.com and the releases of OS X sources take time due to legal issues (you have to be sure that what you release does not include something you shouldn't release)"], [-9, "Is author retarded or just have some fucking delusions ?"]], [[{"comment": "[deleted]", "id": "cxsl51t"}, {"comment": "[deleted]", "id": "cxsleb5"}, {"comment": "[deleted]", "id": "cxsmh8y"}, {"comment": "https://github.com/tpoechtrager/osxcross", "id": "cxsmu4r"}, {"comment": "You do know about history right. Apple tried their hand at proprietary PC's and we see how that ended when IBM went open. Apple is a fad. The only chance they have is to stick to their core and keep that fad or bring in new ones. They will never be IBM or Google. ", "id": "cxsomfm"}, {"comment": "Apple is worth  ~700$ billion, making it worth roughly 7x more than IBM, and still 200$ billion more than Google.", "id": "cxsqqtd"}, {"comment": "That's all mark-up, though. ", "id": "cxsqsi4"}, {"comment": "IBM and Google are much more than just iphones and iwidgets. ", "id": "cxsr1oj"}, {"comment": "Which makes their paltry contributions to open source compared to other companies and their subsequent outright lies about it even more annoying.", "id": "cxstnv1"}, {"comment": "I was only answering the part about creating a program for OSX without using xcode. Should have made my answer clearer. ", "id": "cxspvns"}, {"comment": "Yup, they are still making PCs and IBM isn't. I don't know if you can call 39 years a fad. There aren't a lot of tech companies that have lasted longer.", "id": "cxswcxa"}], [{"comment": "Don't they contribute a lot in either llvm or clang? I wouldn't say the article is totally wrong but they are not only taking benefit either.", "id": "cxsl5ls"}, {"comment": "Yep. They employ several LLVM devs, including [Chris Lattner](http://nondot.org/sabre/), who is the original author & lead dev of LLVM. When I was using LLVM a few years ago, I remember seeing several other Apple devs being highly active contributors. I can't see any list of contributors anywhere though :/", "id": "cxsmoko"}, {"comment": "Yes, but... Author is taking an issue with \"Apple, the first major computer company to make open source a key part of its software strategy\", and rightly so.", "id": "cxspane"}], [{"comment": "lol", "id": "cxsmvcq"}], [{"comment": "On the first anniversary of .NET open source, no doubt.", "id": "cxsoftm"}], [{"comment": "I like how apples claim of the being:\n\n> the first major computer company to make Open Source development a key part of its software strategy\n\nis being translated as:\n\n> The first major company to contribute to open source.\n\nI haven't used a Mac in years, and I think their claim is disingenuous, but it might actually be technically true.\n\n> major *computer* company\n\nThey're not competing with tech companies here, just companies that make computers. HP, Lenovo, Toshiba. Do these companies strike you as open source drivers? The inclusion of the word computer, specifically understanding that computer could refer just to companies that ship computers, makes their claim much smaller than people read it at first (very astute half-truths, they should run for office).\n\n>  Open Source development a key part of its software strategy\n\nHere's the other thing that keeps them 'safe'. IBM is a major company that makes computers and has contributed to open source before Apple did. But no open source contributions that IBM made was ever a key part of its software strategy, whereas Swift is a key part of Apple's software strategy.\n\nSo, yes, it is lulz for _Apple_ to say this. But I think the claim is actually, technically true...", "id": "cxsu6iv"}, {"comment": "people dont like it because its a claim filled with weasle words, intentionally trying to make it seem bigger than it is. its misleading", "id": "cxt1si0"}, {"comment": "Oh, sure, I definitely get that, but when people are quoting the claim incorrectly as they refute it...", "id": "cxt3jif"}, {"comment": "> whereas Swift is a key part of Apple's software strategy.\n\nAlso, to be clear, Darwin happened in the late 1990s and early 2000s, and underpins their entire OS offering for the past 15 years. They were much friendlier to OSS back in the early days of Darwin, then were less friendly, then forgot about OSS for a bit, then started the WebKit thing, then remembered about other OSS again, and then finally released Swift.\n\nThis particular statement might be disingenuous and very carefully worded, but let's not pretend that they're new to this or trying to join the OSS wave after the cool kids did. They've been releasing things, even things whose licenses don't force them to (the majority of the things on opensource.apple.com) for over a decade. It's not a healthy community relationship, but it's far more than most companies of their scale do.", "id": "cxtuesl"}, {"comment": "Thanks for the added context. I was in highschool back when OS X came out so I wasn't really aware of how many open source contributions they were making or not.", "id": "cxtzkki"}], [{"comment": "IBM is probably the oldest big company to support open-source, but I don't think they were the first.", "id": "cxsrix7"}], [{"comment": "No shit, Sherlock. ~~The original GPL even had a clause specifically preventing executing the code on MacOS due to their closed practices...~~ edit: The original FSF FAQ recommended against porting software to Apple computers and did not support A/UX.\n\nedit 1: unsure if it was the GPL itself or some other doc. I think it was connected to gcc. I'll try to dig that up.\n\nedit 2: [Wikipedia](https://en.wikipedia.org/wiki/Richard_Stallman) references the controversy.\n\n\"In response to Apple's Macintosh look and feel lawsuits against Microsoft and Hewlett-Packard in 1988, Stallman called for a boycott of Apple products on the grounds that a successful look-and-feel lawsuit would \"put an end to free software that could substitute for commercial software\".[62] The boycott was lifted in 1995, which meant the FSF started to accept patches to GNU software for Apple operating systems.[63]\"\n\nBut I still need to find the exact wording in released software from RMS\n\nedit 3: Got It:\n\n[From emacs 18.59, Oct 31, 1992 FAQ](https://ftp.gnu.org/old-gnu/emacs/emacs-18.59.tar.gz):\n\n    101: Where can I get Emacs for my Apple computer?\n    \n    The FSF is a participant in a boycott of Apple because of Apple's \"look\n    and feel\" copyright suits.  See the file etc/APPLE for more details.\n    Because of this boycott, the FSF doesn't include support in GNU software\n    for Apple computers such as the Macintosh.\n    \n    Please don't help people port or develop software for Apple computers.\n\nYou can read the APPLE file in the archive for the details.", "id": "cxsnjua"}, {"comment": "http://www.gnu.org/licenses/old-licenses/gpl-1.0.en.html\n\nWhich one would that be?", "id": "cxsobor"}, {"comment": "I am not sure it was in the GPL file itself, but I clearly remember it beeing mentioned in RMS documents. Maybe something about preventing the use of gcc to build stuff for early Mac, or something.\n\nI'll try to dig that up later -- we are talking early 90's here, and I didn't keep that stuff. I sense a lot of google and old archives coming my way :-)\n", "id": "cxsp9z7"}, {"comment": "It was in the FAQ of the emacs distribution in 1992. I updated the post you replied to with info.", "id": "cxssxvu"}, {"comment": "Could you find a source on that? \n\nCouldn't really find anything on Google, other than GPL is not complaint with Apple's App store since Apple enforces DRM.", "id": "cxsoczk"}, {"comment": "I updated the post you replied to with the info. It was in the FAQ of 1992's emacs distribution.", "id": "cxssye1"}, {"comment": "I'm gonna try to dig that one tonight for you guys. This is really really old stuff.", "id": "cxsp60u"}, {"comment": "https://www.gnu.org/bulletins/bull5.html#SEC9\n\nSpecial Report: Apple's New Look and Feel\n\nYou might have read about the new look-and-feel copyright lawsuit, Apple vs. Hewlett Packard and Microsoft. Apple claims the power to stop people from writing any program that works even vaguely like a Macintosh. If they and other look-and-feel plaintiffs triumph, they will use this new power over the public to put an end to free software that could substitute for commercial software.\n\n...", "id": "cxsqg8l"}, {"comment": "Yes, it was related to that, I added it to my original post 4 hours ago (that morons are downvoting, but reddit beeing reddit, it was expected).\n\nI remember it beeing written down in one of the distribution's file of one of the gnu product. It was something about not allowing compilation for Apple platform, IIRC (it was 25 years ago). I fear needing to dig out my old slackware distrib...", "id": "cxss1qn"}], [{"comment": "http://opensource.apple.com and the releases of OS X sources take time due to legal issues (you have to be sure that what you release does not include something you shouldn't release)", "id": "cxsmbdj"}, {"comment": "Yeah, but this provides 0 argument for apple being the ***first*** major open source company.", "id": "cxss31n"}, {"comment": "They didn't say that they said they were the first big company to make it a key part of their ongoing software strategy, which must be true because they obviously depend on darwin, bonjour, webkit etc", "id": "cxstal8"}], [{"comment": "Is author retarded or just have some fucking delusions ?", "id": "cxsootf"}, {"comment": "Are you mad because you have to charge your watch again?", "id": "cxsplca"}, {"comment": "How do you know it's noon on the Apple watch? \n\nIt stays black when you check it.", "id": "cxsruce"}, {"comment": "I charge my Pebble once a week but what does that have to do with anything ?", "id": "cxspuif"}]]], "58isoi": ["Microservices \u2013 Please, don\u2019t", "2016-10-20 23:21:50", 0, "http://basho.com/posts/technical/microservices-please-dont/", [[33, "> While I don\u2019t want the takeaway of this blog post to be \u201cMicroservices == Bad\u201d\n\nThen don't title your goddamn article \"Microservices - Please don't\""], [8, "The two unspoken advantages of microservices:\n\n- Excuse for management to hold nice presentation and get a promotion. SOA, Agile etc. was getting too chewed out.\n- Excuse for developers to aquire budget for a rewrite of a running but dusty legacy codebase."], [5, "Microservices == Agile 2.0. \n\nThe forces that drive Microservices are the same that have been driven Agile. \nPut people in crunch mode and let them produce in 14 days as much business value as possible.  No planning, design, documentation etc. allowed. Just immediate business value. Each sprint is the last sprint. "], [5, "why does this get reposted? its a giant pile of handwaving\n\non pretty much each point he also concedes the benefits of microservices...so the tl;dr of this is \"do the right thing and don't do the wrong thing\"....well ok!"], [1, "If you break your codebase up into service modules, and then deploy each one individually on different clusters...*that's a microservice*. A monolith isn't defined by \"all the code is in the same package\"."]], [[{"comment": "> While I don\u2019t want the takeaway of this blog post to be \u201cMicroservices == Bad\u201d\n\nThen don't title your goddamn article \"Microservices - Please don't\"", "id": "d90r8t1"}], [{"comment": "The two unspoken advantages of microservices:\n\n- Excuse for management to hold nice presentation and get a promotion. SOA, Agile etc. was getting too chewed out.\n- Excuse for developers to aquire budget for a rewrite of a running but dusty legacy codebase.", "id": "d90te6y"}], [{"comment": "Microservices == Agile 2.0. \n\nThe forces that drive Microservices are the same that have been driven Agile. \nPut people in crunch mode and let them produce in 14 days as much business value as possible.  No planning, design, documentation etc. allowed. Just immediate business value. Each sprint is the last sprint. ", "id": "d90rm22"}], [{"comment": "why does this get reposted? its a giant pile of handwaving\n\non pretty much each point he also concedes the benefits of microservices...so the tl;dr of this is \"do the right thing and don't do the wrong thing\"....well ok!", "id": "d90s4um"}, {"comment": "The arguments in favour of microservices involve a lot of handwaving as well. A complex system will be complex no matter how you build it, but the microservices propaganda glosses over that.", "id": "d90wowy"}], [{"comment": "If you break your codebase up into service modules, and then deploy each one individually on different clusters...*that's a microservice*. A monolith isn't defined by \"all the code is in the same package\".", "id": "d92pzlk"}]]], "4hx99w": ["Stack Overflow data shows bootcamp grads out-earn CS degree grads by $6,000 a year. Do you believe it?", "2016-05-05 03:24:03", 27, "https://blog.bloc.io/comparing-salaries-for-coding-bootcamps-vs-computer-science-degrees/?utm_campaign=reddit&utm_source=reddit&utm_medium=social", [[275, "Um... that website - bloc.io - runs a bootcamp for just $9,800"], [127, "My suspicion is that Bootcampers are currently heavily concentrated in NYC/SF, with commensurate high salaries. \n\nIf you were to control for geography, I bet the \"anomaly\" would disappear."], [50, "There are a lot of flaws with this analysis.\n\n1. They're not looking at geographical location within the US. It's extremely likely that these bootcamps are in SF or NY, and that the overwhelming majority of people coming out of these programs are seeking employment in those cities. Salaries are going to be higher there because cost of living is higher, as well as the types of positions that are available. In fact, we can already get some sense of the impact of this looking at the difference between global and US salaries.\n2. Selection bias in terms of who is filling out the reports is a confounding variable."], [16, "It seems possible, if stupid.  Then again, everything is broken, so it probably doesn't matter."], [8, "They must be extra good at whiteboard algorithms. "], [8, "Important to note that that is in comparison to a BS.  MS and PhD still earn more (to be expected, IMO).\n\nHow the data is collected is notable as well, since it doesn't look like this includes unemployed people.  So these numbers probably aren't the expected value of the salary, just a representation of what you could expect to earn if you end up being employed in the industry. (which is still meaningful information, although not completely in line with what the headline says)."], [7, "Kinda counter to many of the comments here, but as a self-taught (mostly) programmer with no degree I already out-earn most of my college educated friends and peers. I think that passion and ambition are the real factors. "], [7, "Bootcamps have two things really going for them:\n\n1) They have an extremely aggressive placement program\n\n2) Right now they can afford to be selective: they only accept highly motivated individuals. "], [6, "Most boot camps don't go over deep comp sci concepts which are required for interviews and comp sci in general."], [4, "What's a bootcamp?  Never heard about it.  Unless you are talking about those fitness bootcamps. "], [4, "Fucking bullshit.\n\nWhat is a degree if not a 3 year long full time bootcamp?"], [2, "Stack overflow does not represent the community as a whole. It does however represent the jquery community pretty well otherwise I wouldn't keep getting jquery answers to vanilla JavaScript questions"], [1, "It might be possible , these individuals might be hybrids with knowledge of another area and then they sent through a bit camp.  Would you pay more for a nurse that can program. It depends.\n\nBut I doubt it."], [1, "The [StackOverflow poll](http://stackoverflow.com/research/developer-survey-2016#developer-profile-education) shows that only 6.5% of the people have bootcamp education. "], [1, "So what are we looking at? I see a diagram where someone hilighted \"bootcamps\", and then above that, earning a little more, I see a CS degree."], [1, "I'm just glad that colleges are losing their monopoly. I don't think a bootcamp coder would be as competent as someone with a degree though."], [1, "Reported as spam."], [1, "\"There are three kinds of lies: lies, damned lies, and statistics.\"  That website is using statistics to further their own cause."], [1, "Hi, I work for CodeClan which was mentioned earlier in this thread. We've been open since Sept 2015 and on to our 5th cohort now. We've had 32 people graduate since opening and most have come from non-digital backgrounds yet after 16 weeks of learning to code have been hired by our employer partners (one even went to work for instagram - he was a journalist previously who wanted to get some coding experience to be able to move into the digital world faster). We've even hired a couple to help with our own internal dev projects which is fantastic experience for them. We are supported by the Scottish government who have acknowledged that there is a skills gap in the tech industry over here that can't be filled just through uni degrees. We run info-sessions for people interested in finding out more if you are keen however we are currently based in edinburgh and the course is taught on campus so you would need to be prepared to relocate. If you have any questions get in touch with us as we are happy to help, even if it's pointing you in the right direction of courses. \n\nSome pages worth looking at: \n\nCase studies: http://codeclan.com/student-stories/\n\nScholarship opportunity: http://codeclan.com/news/be-it-announce-new-scholarship/\n\nOur info sessions: http://codeclan.com/news/meet-the-clan-info-sessions/\n"], [-3, "I believe it. Consider what drives a person to join a coding bootcamp vs. what drives a person to get a CS degree."], [0, "What a fuckin joke! Bootcampers have a higher salary than people with PhD's in computer science.... OKAYYYYYYYYYY"], [-11, "[deleted]"]], [[{"comment": "Um... that website - bloc.io - runs a bootcamp for just $9,800", "id": "d2t6gzn"}, {"comment": "Case closed", "id": "d2tfakw"}, {"comment": "And here is your answer OP", "id": "d2tkc6o"}, {"comment": "Sure, but the graphs come from SO (specifically, [here](http://stackoverflow.com/research/developer-survey-2016#salary-per-education)). What I find strange about the graph though, is that all percentages are >100%, but \"Percents shown are developer salaries as a percent of the average developer salary in a respondent's country. [sic]\" even though the categories seem to be exhaustive. Also the US tab gives $ instead of %.", "id": "d2tmfdb"}, {"comment": "I guess it all depends if my first raise is more or less than $3,800.", "id": "d2u1pfk"}], [{"comment": "My suspicion is that Bootcampers are currently heavily concentrated in NYC/SF, with commensurate high salaries. \n\nIf you were to control for geography, I bet the \"anomaly\" would disappear.", "id": "d2t6dr7"}, {"comment": "Maybe not all of it. I'd like to know what the difference is 5 years after first hire. Bootcamps teach the current trends, not the deeper concepts. ", "id": "d2t8g7n"}, {"comment": "The \"problem\" with CS is almost all skills that are taught there will only be useful once you are 5+ years into job and have some senior position (or get into a startup) so you will have to do more than \"gruntwork\" a lot of companies put on juniors.\n\nBootcamp will learn you what you need right now to get a job, CS is more like an investment in hopes you will get a job that can use it\n", "id": "d2tmnbl"}, {"comment": "I don't think it's true that CS knowledge is only useful after 5 years. It's more that CS graduates (and even software engineering graduates) seem to *only* have theoretical knowledge. That means the stuff they build right out of school has any potentially good CS qualities hidden under a pile of bad code. It takes 5 years to start writing good code, at which point their potential is revealed.", "id": "d2tmuoc"}, {"comment": "That definitely plays a big role, but a newly hired junior will rarely be given something where CS knowledge is useful. And there is also chance someone went CS just because he heard it pays well and doesn't remember much 5 years  after graduation", "id": "d2tn4c9"}, {"comment": "CS knowledge is useful in pretty much all positions. Judging by the code I've seen though, many are of your opinion.", "id": "d2to8ma"}, {"comment": "I assume most people will pick up the deeper concepts once they start writing code. ", "id": "d2tca0s"}, {"comment": "Depends on the type of project, for the average code monkey sure but  moving up to tech lead/architect level typically requires some level of knowledge of theory that these bootcamps don't give you.", "id": "d2tct7n"}, {"comment": "You can learn on your own, it is not a secret knowledge. Just it takes time and not everyone will have luxury of having a ton of free time to learn in addition to job. CS helps in that as you \"invest\" into knowledge upfront.\n\n", "id": "d2tmmid"}, {"comment": "[deleted]", "id": "d2tgmy9"}, {"comment": "Code Monkey = Someone who can write code and do what they're told but can't actually solve a large scale problem on their own.  It's a fairly common term.  You seem like you have a chip on your shoulder about something.", "id": "d2tgw2m"}, {"comment": "[deleted]", "id": "d2tlf2q"}, {"comment": "I guess it varies program to program.  What I really got out of mine that helped me later in my career is a good foundation in how things work under the covers and in algorithmic complexity.  What's interesting is that very little of that was useful until a few years into my career but the further along I get the more useful the theory stuff becomes.", "id": "d2tq3jr"}, {"comment": "[deleted]", "id": "d2tqexe"}, {"comment": "Granted I went to school over 10 years ago but I had classes in algorithmic complexity, understanding memory management on both an application and operating system level, systems level development, security/encryption theory, networking theory (not seeing up a network but client -> server communication), compiler design etc.  \n\nThat's not so much what I meant though.  More of what I was talking about but how things work.  Take C# for an easy example, I like knowing what the difference is between a linq statement, a for loop and a foreach loop under the covers but to a lot of people they are all the same thing.", "id": "d2tqnki"}, {"comment": "I'm a code monkey and I have a cs degree. Stop being so sensitive. If you don't understand theory, its going to be more difficult to architect solutions to problems, which is what tech leads do. \n\nBut I'd take it a step further anyway. Anyone can write code, and it doesn't require a degree to write good code, but I will bet my CS degree against your boot camp training for algorithmic solutions any day of the week.", "id": "d2tgxq8"}, {"comment": "> Anyone can write code, and it doesn't require a degree to write good code  \n\nThis is really the crux of the issue I think.  If I'm running a tech team I don't need 5 architects.  I need 1 architect, maybe 1 lead 3-4 people who will just code what they're told without trying to reinvent the wheel.  From that standpoint these bootcamp grads have a certain business appeal.  ", "id": "d2tq70z"}, {"comment": "[deleted]", "id": "d2tgz2v"}, {"comment": "He has his own song and everything.", "id": "d2th2f6"}, {"comment": "Code monkey get up, get coffee", "id": "d2tihfi"}, {"comment": "Code monkey goto job. ", "id": "d2tlnto"}, {"comment": "When I used to be a kitchen hand I called myself a kitchen bitch, when I was doing electronics assembly I was a solder monkey.\n\nSome people find it humorous to use self-deprecating titles. ", "id": "d2tigo3"}, {"comment": "Being self-deprecating is a national pastime for us Brits.\n", "id": "d2tl09m"}, {"comment": "Yes, if it's one thing Brits are known for, it's their humility.", "id": "d2tmz6s"}, {"comment": "I think you are right, but I saw a bootcamp graduate write code like this:\n\n    ONE   = 1\n    TWO   = 2\n    THREE = 3\n    FOUR  = 4\n\nBecause someone told him to not use magic constants. He was still a good guy though, and he learned. ", "id": "d2td187"}, {"comment": "[deleted]", "id": "d2teg58"}, {"comment": "infinitesimal benefit I in no way endorse: s/ONE/TWO/g will leave 12 unaffected but s/1/2/g sure won't\n\nunless our friend also uses `ONETWO = 12` in which case, gosh", "id": "d2tg52z"}, {"comment": "I would imagine that's what he learned.", "id": "d2tem9a"}, {"comment": "As long as your factorial function doesn't run in O(n) time you should be fine.", "id": "d2tfaaj"}, {"comment": "> As long as your factorial function doesn't run in O(n) time you should be fine.\n\nIf you find a linear time algorithm for computing the factorial of an integer i suggest you publish immediately and collect your Turing award.\n\nThe fastest known solution takes O(n log n log log n) time. The naive solution takes quadratic time.", "id": "d2tjig0"}, {"comment": "using C++ templates or constexpr, you can calculate factorials at compiletime so that the runtime cost is O(1).  That assumes of course you know the argument to the factorial ahead of time.", "id": "d2tkhoh"}, {"comment": "If you know the argument ahead of time you can just hard code it anyway (which is all the compiler would do).\n\n    int x = 39916800; // 11!", "id": "d2tkjdc"}, {"comment": "Sort of.  Sometimes though, you are writing another constexpr function that may call factorial based on something further up the constexpr call stack.  In that case, hard coding the value at the place of use may be difficult.  Of course, since you're dealing with compile-time evaluated expressions, at the top level you could always replace it with the desired value.  But then you're losing out on the benefits of constexpr.", "id": "d2tl26a"}, {"comment": "> which is all the compiler would do\n\nthen you should probably let that to the compiler", "id": "d2tmo1o"}, {"comment": "> using C++ templates or constexpr, you can calculate factorials at compiletime so that the runtime cost is O(1). That assumes of course you know the argument to the factorial ahead of time.\n\nWhether the computation happens at compile-time, runtime or dinner time has no bearing on the complexity of the problem whatsoever.", "id": "d2tksix"}, {"comment": "> As long as your factorial function doesn't run in O(n) time you should be fine.\n\nThe original comment was (emphasis mine):\n\n> As long as your factorial function doesn't **run** in O(n) time you should be fine.\n\nThat's why I mentioned *run*time.  But yes, the complexity of the problem / algorithm isn't going to change.\n\nThe only thing I would offer is that unless exact values are required, `exp(gammaln(x+1))` will give O(1) results (with a largish constant).", "id": "d2tl64v"}, {"comment": "Well if you memoize it it'll be constant :P", "id": "d2to2hm"}, {"comment": "This is why so many accountants have won the Field's Medal.", "id": "d2tmsm2"}, {"comment": "Being an accountant doesn't require you to research every single day on how to do things. If you aren't researching deeper concepts by yourself as a professional programmer you are in the wrong job. ", "id": "d2tn3bz"}, {"comment": "\"How to do things\" is not CS knowledge. I'm talking about theoretical concepts like DFAs and Big O notation. Stuff that code monkeys are definitely not researching, judging by the code I've seen.", "id": "d2tokgc"}, {"comment": "You will not need DFAs to make good software. Except maybe highly specialized cases. Every programmer I have met either self-taught or not knows about Big O notation. Simply because they didn't learn it in a classroom doesn't mean they don't know it. ", "id": "d2tpu1l"}, {"comment": "> You will not need DFAs to make good software\n\nWell, here's your problem. \n\nYou absolutely *will* need to know about state machines, what is good and bad about them and when to use or avoid them if you want to make good software over the long term, 5 years after you've learned $LATEST_FAD_LANG.", "id": "d2tqh2g"}, {"comment": "LMAO I have 12 years of professional experience in 3 different companies and not once did I need to use the abstract computer sciency state machine reasoning. My field is embedded systems so I hardly get to use \"$LATEST_FAD_LANG\" anyway. ", "id": "d2tqujk"}, {"comment": "You didn't use it. That doesn't mean you didn't need it.", "id": "d2true5"}, {"comment": "I work with people that have 10 plus years of experience that still don't understand the deeper concepts", "id": "d2th231"}, {"comment": "Degrees, generally speaking, teach you a lot that you would not learn just by \"doing\". If they don't you likely need to rethink the courses you're taking.\n\nThere's content in 3rd and 4th year of a degree that you will only really learn in a textbook, in a paper, or in a university classroom.", "id": "d2tk1iu"}, {"comment": "if it's someting you'll never learn through coding means it's useless for coding.", "id": "d2tl4sc"}, {"comment": "Not so, diagnosing why an app has high cpu, intermittent freezes, debugging a crashed memory dump all of these things require that knowledge.  Understanding how threading works is much more important than knowing how to write threaded code.  Just because you don't use a piece of knowledge every day doesn't mean it's useless.  \n\nProblems of scalability, deployment, optimization, latency, these are all CS problems more than programming problems.  ", "id": "d2tqeg2"}, {"comment": "It's something you can absolutely make use of when coding, but not something you'll learn by doing. I use the stuff I've learned constantly.\n\nThe problem with the CS grads who graduate and can't code at all, or graduate and feel they can't make use of any of the things they learned, is because they weren't applying and making use of what they learned as they learned it.\n\nYou don't master a skill just by doing, you master it by *good practice*, which involves actively going out, learning the gaps in your knowledge, and correcting them.\n\nThe continuous argument of \"whether a CS degree is worth it\" as well as the argument of \"whether rockstar programmers are valuable\" usually don't look at the very important fact of *what* kind of code is being written.\n\nYou don't learn and properly absorb the ~1200 pages of thomas' calculus taught in university just by coding, yet calculus is applicable to a large number of domains. Likewise, if you tell an average developer with graphics knowledge and John Carmack to develop the same thing, it's not an exaggeration to say Carmack will likely develop something better in 1/10th the amount of time.", "id": "d2ub4dh"}, {"comment": "have any examples? Because I can't think of any.\n\nYour calculus example is worthless because lots of 3D graphics programmers do learn calculus and linear algebra BECAUSE they wanted to make 3D stuff. No they don't learn the \"~1200 pages of thomas' calculus\" and they don't need to because a massive amount of that book is not relevant to what they want to use calculus for. \n\nand How did John Carmack learn programming? Newsflash not by being in university, He doesn't even have an associates degree. If anything he is the poster child against CS since he is missing all these \"deeper\" topics that you can only learn when you are in university. \n\n", "id": "d2ubva6"}, {"comment": "Carmack has absolutely read countless textbooks and papers though. I'm not saying you need a degree, I'm saying,\n\n>There's content in 3rd and 4th year of a degree that you will only really learn *in a textbook, in a paper, or in a university classroom.*\n\nThe point I was making is that you don't pick up everything *just* by coding.", "id": "d2uc7ub"}, {"comment": "with coding I meant the entire process. Documenting, writing the program, testing, research on how to do certain things. You know the daily tasks of every programmer. \n\nYour original comment directly refers to a degree teaching it. Not teaching it to yourself. Carmack learned all of it by \"doing\". Just like every good programmer I have ever met taught himself 70%+ of the stuff he knows and uses.\n\n> Degrees, generally speaking, teach you a lot that you would not learn just by \"doing\". If they don't you likely need to rethink the courses you're taking.", "id": "d2udd04"}, {"comment": "There are also questions about sector. A certain number of academically-trained programmers will stay in academia or do research, which generally pays less than working for startups or big companies. Government IT and programming jobs, which are more likely to have a degree as a hard requirement, also generally pay less (they trade off salary for benefits and job security).", "id": "d2tkn5r"}, {"comment": "I wonder if there is a, for lack of a better word, personality split too. Bootcampers are business driven types who play corporate ball to climb the ladder. CS-Degree-ers are academics and engineers at heart who just want to build cool shit. ", "id": "d2ty7y7"}], [{"comment": "There are a lot of flaws with this analysis.\n\n1. They're not looking at geographical location within the US. It's extremely likely that these bootcamps are in SF or NY, and that the overwhelming majority of people coming out of these programs are seeking employment in those cities. Salaries are going to be higher there because cost of living is higher, as well as the types of positions that are available. In fact, we can already get some sense of the impact of this looking at the difference between global and US salaries.\n2. Selection bias in terms of who is filling out the reports is a confounding variable.", "id": "d2t6gol"}, {"comment": "I have to agree with both those points. #1 had definitely occurred to me. For the global salaries they normalized salaries by country. You'd ideally do the same thing for cities in the US to see how CS degree holders compare to bootcamp grads in a particular city. ", "id": "d2t6yo1"}, {"comment": "This data also doesn't seem to consider when these bootcamp graduates were hired.  In Austin, it seems like the bootcamps were doing really well getting people development gigs three years ago, but these days there are a TON of bootcamp grads applying for junior gigs all over town.  We had ~120 apply for three junior rails positions in the last couple of months, all with identical resumes and github profiles.  I really get the sense that tech companies picked up a ton of bootcampers early on because they didn't fully understand what they were getting from these candidates, but there's definitely been a shift in attitude towards hiring them over the last couple of years, and it's only gotten worse based on the number of people I see at meetups and conferences. ", "id": "d2tcflb"}, {"comment": "Exactly, to move from my current job out to SF and maintain the same standard of living I currently enjoy I'd be looking at a 60-80k pay bump.  The amount of variation between cities in the US is insane.", "id": "d2tcvnn"}, {"comment": "I'd need at least $1 million bump.  That private helicopter that's  needed to avoid traffic would cost a lot.  (I don't have a private copter now, but I don't need one.  Traffic here is very seldom slow.)", "id": "d2tkkm1"}], [{"comment": "It seems possible, if stupid.  Then again, everything is broken, so it probably doesn't matter.", "id": "d2t4k8r"}], [{"comment": "They must be extra good at whiteboard algorithms. ", "id": "d2t54ng"}, {"comment": "Yep, there's a whole day on Inverting Binary Trees in JavaScript, at web scale, in NodeJS.", "id": "d2tn3r8"}, {"comment": "You forgot to use AWS, Express, NoSQL, one or more heavy frameworks, and an excessive number of objects in your solution.  No job for you!", "id": "d2tptl7"}], [{"comment": "Important to note that that is in comparison to a BS.  MS and PhD still earn more (to be expected, IMO).\n\nHow the data is collected is notable as well, since it doesn't look like this includes unemployed people.  So these numbers probably aren't the expected value of the salary, just a representation of what you could expect to earn if you end up being employed in the industry. (which is still meaningful information, although not completely in line with what the headline says).", "id": "d2t6i70"}, {"comment": "A college professor told me that having a PhD in CS works very well against you, since you're a threat to whomever hires you.  Besides, you learn MS/PhD level in a year or two on the job regardless, if you like challenges.", "id": "d2ugywc"}], [{"comment": "Kinda counter to many of the comments here, but as a self-taught (mostly) programmer with no degree I already out-earn most of my college educated friends and peers. I think that passion and ambition are the real factors. ", "id": "d2tc6im"}, {"comment": "You most likely started earlier also. 4 years of work experience generally counts for more than 4 years of college.", "id": "d2tcboc"}, {"comment": "> 4 years of work experience generally counts for more than 4 years of college.\n\nMost important thing posted in this thread.  I absolutely will take someone with 4 years of experience over a college grad with no experience.\n\nThe trick, of course, is to get a job with no experience.  In which case, having actual code you've written helps a lot.  So the most important thing is to write code.", "id": "d2tepsh"}, {"comment": "What if they have just been writing patches on a terrible old codebase for 4 years? Actual 4 years experience could easily take someone in the wrong job about 10 years to accumulate, or they might even not have more than about 6 months of useful experience if they've just been doing the same thing over and over with the same approach.\n\nI'd rather have someone who knows best practice, current approaches and doesn't have 4 years of bad habits to beat out of them.\n\nA good graduate could very well be better than someone with 4 years experience, you really need to judge people based on their merits going forward not purely on their background. ", "id": "d2tkdwr"}, {"comment": "> In which case, having actual code you've written helps a lot\n\nBit silly really, if I was trying to get a job as a mechanical engineer, it wouldn't be expected that I had built a car in my spare time.", "id": "d2tijm5"}, {"comment": "Yeah but you probably have a CAD portfolio....", "id": "d2tnuz8"}, {"comment": "Those are two extremely different things. Anyone can spend a day learning coding and write a simple program. You can't do the same thing with a car.", "id": "d2tjiy8"}, {"comment": "You get the fuck out of this industry NOW if you think it's silly to hire based on personal projects.\n\nWhile you're at it, go tell artists what an injustice it is that they have to practice on their free time, and that any art degree should immediately entitle you to a job at a studio.", "id": "d2tptf4"}, {"comment": "I'm not an artist, stop with that bullshit.\n\nI'm an engineer, I write code for a job. When I go home, I don't then write a bunch more code, I usually have other things I enjoy doing after spending 8 hours programming. It's not that I don't enjoy programming, just that there's things I enjoy more, especially after 8 hours of work.\n\nThere's nothing wrong with personal projects if that's what you're into, just like mechanical engineers can build cars if they want, but it shouldn't be an expectation that I do.", "id": "d2uoiw0"}, {"comment": "You're not good at programming. You're some kid that thought CS degree = easy money. I get preferential treatment over you because I make cool projects (I make revenue from as well, lol) in my spare time. Go bitch and moan about the system keeping you down elsewhere.", "id": "d2vceig"}, {"comment": "You have no idea how good I am at programming.", "id": "d2vw4l2"}, {"comment": "/r/iamverysmart", "id": "d2vwbxb"}, {"comment": "That's where you belong mate, all on your high horse and shit.", "id": "d2x07me"}, {"comment": "I'm comparing myself to people with similar years of experience. That said, I have been working in IT for over 20 Years. ", "id": "d2tcoj1"}], [{"comment": "Bootcamps have two things really going for them:\n\n1) They have an extremely aggressive placement program\n\n2) Right now they can afford to be selective: they only accept highly motivated individuals. ", "id": "d2tcy76"}, {"comment": "I don't buy it. There is shortage of programmers and also it makes no sense to not take money from people for bootcamps even if they are not quite qualified..", "id": "d2tjsow"}, {"comment": "If people taking the boot camps stop getting job offers, the industry collapses. Hence only taking motivated individuals who'll boost their stats and the price of admission.", "id": "d2tpaxa"}, {"comment": "I guess I can see it.  Bootcamps can drill the \"in-demand\" stuff.  Right now, I think, that's Angular, Node.js and Docker.  Or Spark (or maybe I'm out of the loop and all that stuff is already passe).  If you can demonstrate \"in-demand\" skills right now, you can probably get a bit more money than somebody who's been doing \"yesterday's\" stuff like RoR or Django or Groovy (or whatever the hell was \"in demand\" six months ago).  However, a boot camp graduate is in for a tough road when fashions change; they're going to have to go back and either pick up the fundamentals on their own or worse, \"re-bootcamp\" for the next buzzword wave.  In the long run, you're better off having an intuitive notion of what a linked list and a hash map actually _are_ than trying to mentally map Angular phraseology onto RoR phraseology.  Of course, if you go through enough software trends, you'll end up absorbing all the concepts through osmosis... but it's going to take a lot longer than it would take if you just started from the beginning in the first place.", "id": "d2tvrs6"}], [{"comment": "Most boot camps don't go over deep comp sci concepts which are required for interviews and comp sci in general.", "id": "d2ta8fd"}], [{"comment": "What's a bootcamp?  Never heard about it.  Unless you are talking about those fitness bootcamps. ", "id": "d2t5y5h"}, {"comment": "It's basically a crash course in software engineering for about a year.\n\nSometimes with unorthodox funding models where they'd then take a cut of your salary instead of upfront payment. ", "id": "d2t70fn"}, {"comment": "Usually a lot shorter than a year, more like 6-12 weeks, which in my opinion is far too short. Some are even as short as 4 weeks.", "id": "d2tiiih"}, {"comment": "Long enough to churn out crap JavaScript.", "id": "d2u6ap0"}, {"comment": "Or Java :)\n\nI joined one shortly after I got my MS degree since I was having difficulty finding jobs. It was the most boring thing ever where they taught you some of the basics and then the basics of some frameworks.\nAs well as give you a list of framework based questions/answers that gets asked in interviews. The last thing was actually helpful ;D\nThe job was frightfully easy and boring.", "id": "d2uaka5"}, {"comment": "Ever year or two all the questions change, but everyone asks the same questions.  So the first 2 or 3 interviews are really just information gathering.", "id": "d2uh0lk"}, {"comment": "> Sometimes with unorthodox funding models where they'd then take a cut of your salary instead of upfront payment.\n\nThat sounds absolutely orthodox compared to university (in the UK anyway). ", "id": "d2thakf"}, {"comment": "Here is an example Curriculum from one that runs in the UK:\nhttp://codeclan.com/course/course-curriculum/\n\nThey charge people to sit the course, they only accept people based on an interview, they expect you to do a LOT of up front work and they claim to guarantee you a few interviews at the end of it.\n\nThe reason I think this will actually work is because if you actually put 50-60 hours a week into learning for 19 weeks then you probably will be pretty decent at it. Good enough I'd expect to be able to fit into a team working on an existing product certainly. Lets be honest, if your drive is that high you are probably going to be a pretty good employee regardless!\n\nnote: I in no way endorse this company, and I myself learnt at uni.", "id": "d2tk3wi"}], [{"comment": "Fucking bullshit.\n\nWhat is a degree if not a 3 year long full time bootcamp?", "id": "d2tld9t"}, {"comment": "3 year? I wish :(", "id": "d2tn0sy"}, {"comment": "Did that english class help you? Does it really help you to have learned and forgotten computer science concepts when all that information is readily available for free on the internet when needed? Didn't it actually take 4 or 5 years?\n\nWe're turning our population into indentured servants because we've gone crazy with credentialism.  Degrees are mainly a really expensive signalling mechanism that you are smart and hard working. If businesses can find a better/cheaper way to find good employees everyone would be better off. ", "id": "d2u1wcf"}, {"comment": "Because it's filled with tons of fluff they make you pay for.", "id": "d2tts34"}], [{"comment": "Stack overflow does not represent the community as a whole. It does however represent the jquery community pretty well otherwise I wouldn't keep getting jquery answers to vanilla JavaScript questions", "id": "d2tt6lz"}], [{"comment": "It might be possible , these individuals might be hybrids with knowledge of another area and then they sent through a bit camp.  Would you pay more for a nurse that can program. It depends.\n\nBut I doubt it.", "id": "d2t7lu5"}], [{"comment": "The [StackOverflow poll](http://stackoverflow.com/research/developer-survey-2016#developer-profile-education) shows that only 6.5% of the people have bootcamp education. ", "id": "d2tfotx"}, {"comment": "Don't worry this is the /r/programming version of ermahgahdd they took er jobs with their cheap bootcamp education compared to my fancy degree filled with lots of theory and terrible code despite all that theory.", "id": "d2ttw2u"}], [{"comment": "So what are we looking at? I see a diagram where someone hilighted \"bootcamps\", and then above that, earning a little more, I see a CS degree.", "id": "d2thwno"}, {"comment": "Masters CS Degree", "id": "d2u0sog"}, {"comment": "Sure, when I got mine that was the only alternative here in Sweden.", "id": "d2u4hsy"}, {"comment": "Usually in the US it's 4 years=bachelors, 2 more years=masters, 2 more years=phd", "id": "d2u9ydx"}, {"comment": "In Sweden we learn more in highschool earlier than in the US, so we used to have a four year masters right after highschool.\n\nAfter the Baloney program here in the EU aligning all universities, we now have 3 years bachelor followed by a 2 year masters. But when I studied there was no bachelor's degree in CS.", "id": "d2vj65q"}], [{"comment": "I'm just glad that colleges are losing their monopoly. I don't think a bootcamp coder would be as competent as someone with a degree though.", "id": "d2tlk1k"}], [{"comment": "Reported as spam.", "id": "d2ttedi"}], [{"comment": "\"There are three kinds of lies: lies, damned lies, and statistics.\"  That website is using statistics to further their own cause.", "id": "d2u49ft"}], [{"comment": "Hi, I work for CodeClan which was mentioned earlier in this thread. We've been open since Sept 2015 and on to our 5th cohort now. We've had 32 people graduate since opening and most have come from non-digital backgrounds yet after 16 weeks of learning to code have been hired by our employer partners (one even went to work for instagram - he was a journalist previously who wanted to get some coding experience to be able to move into the digital world faster). We've even hired a couple to help with our own internal dev projects which is fantastic experience for them. We are supported by the Scottish government who have acknowledged that there is a skills gap in the tech industry over here that can't be filled just through uni degrees. We run info-sessions for people interested in finding out more if you are keen however we are currently based in edinburgh and the course is taught on campus so you would need to be prepared to relocate. If you have any questions get in touch with us as we are happy to help, even if it's pointing you in the right direction of courses. \n\nSome pages worth looking at: \n\nCase studies: http://codeclan.com/student-stories/\n\nScholarship opportunity: http://codeclan.com/news/be-it-announce-new-scholarship/\n\nOur info sessions: http://codeclan.com/news/meet-the-clan-info-sessions/\n", "id": "d3k8fxq"}], [{"comment": "I believe it. Consider what drives a person to join a coding bootcamp vs. what drives a person to get a CS degree.", "id": "d2t5389"}, {"comment": "[deleted]", "id": "d2tb3ba"}], [{"comment": "What a fuckin joke! Bootcampers have a higher salary than people with PhD's in computer science.... OKAYYYYYYYYYY", "id": "d2th376"}], [{"comment": "[deleted]", "id": "d2tbyoa"}, {"comment": "Until the boot camp grad writes a bunch of inefficient methods and users complain about performance, or writes unmaintainable heaps of junk code that the rest of the dev team decides to scrap instead of extend.\n\nIndustry relevant skills can be picked up quickly if you have a CS degree. Boot camps have their place, but they aren't a replacement for an accredited university.", "id": "d2tdemm"}, {"comment": "The CS grad will do the same.   Efficiency is something gained with experience, not classrooms.\n\nJust look at all the people who were arguing about whether leftpad.js was geometric or not.  Their instinct told them one thing, benchmarks proved otherwise.", "id": "d2teuml"}, {"comment": "Benchmarks proved them wrong because some very smart people with a lot of knowledge in compiler theory build a just in time compiler that recognizes repeating patterns at runtime and optimized them. I don't know much about these people but my guess is that they have not only visited bootcamp but graduated from a university in CS or mathematics.", "id": "d2tjibr"}, {"comment": "[deleted]", "id": "d2tku7s"}, {"comment": "Self-education and software boot camps are different. As an example, John Carmack is self educated. He educated himself through experimentation, textbooks, magazines, etc for years.\n\nBoot campers can do the same. The hypothetical is: we have one guy whose only education was boot camp and another whose only education was his BS in Computer Science. We don't really have room on the budget for another developer, so he's going to have to pull his weight. Who's the better bet? Maybe we should add an interview question about a \"disaster\" we're having and ask them how they'd troubleshoot it.", "id": "d2tqeqy"}, {"comment": "> because boot camp grads spent a few months working on tutorials for the latest flavor of the month frameworks\n\nFTFY. I've worked with more than my share of them. They cannot do tree traversals (which comes up a lot when you do distributed computing or work with file systems), they don't know how different parts and pieces fit, and they copy/paste code because they don't understand they need to abstract it out to its own thing.\n\nGuess what, understanding the basics of a computer language and how different commonly used abstractions can leak are very much industry relevant skills. Once you know that a C# List<T> and a Java ArrayList<T> are just collections of pointers, it becomes a lot easier to diagnose why certain weird problems with elements getting out of sequence occur without having to come up with extra code that may still not be quite right.", "id": "d2thm3k"}]]], "4aod7w": ["JavaScript is a Dysfunctional Programming Language", "2016-03-16 19:41:32", 14, "https://medium.com/javascript-non-grata/javascript-is-a-dysfunctional-programming-language-a1f4866e186f", [[66, "We definitely needed another one of these articles."], [27, "Medium needs to change its name to \"TL;DR\". Just a bunch of angry junior engineers starting flamewars because they can't get grunt to work."], [23, "I am so tired of seeing that \"good parts vs definitive guide\" image used as serious evidence that JS is a bad language. It was funny as a joke, but it doesn't actually mean anything. Two books by different authors exploring the languages in different levels of depth. Yeah, obviously the one called \"the definitive guide\" is going to be a lot longer."], [8, "I've just started learning it for work, and yeah, coming from C# it's pretty icky, but it's not dysfunctional at all.\n\nThe problem right now is the tooling. If you stick to HTML5 + JS + CSS, it's really not so bad.\n\nIf you ignore all the tooling for it, toss node/npm/bower/gulp out the window, and you use just angular and bootstrap, you can have a decent responsive web page. I think the major mistake a lot of new web developers are making is that they start learning JavaScript coming up from node, instead of going down from the browser. The tooling is fine if you know what it's doing behind the scenes, but if your first experience with learning JavaScript is firing off a yeoman generator, you are going to have a bad time.\n\nAs long as you start with angular 1.x and learn how it handles separation of concern, you can write good JavaScript code from the get-go and you can learn prototypical oo as you go along, you don't need it right away."], [6, "JavaScript isn't necessarily a dysfunctional language; however, there are a lot of horrible JavaScript codebases cobbled together by developers without strong fundamentals.  The bigger issue, in my opinion, is that there is such a low barrier to entry that JavaScript -- much like other languages that are easy to adopt -- allows you to write bad code with terrible abstractions.  Also, until fairly recently (the past few years), there hasn't been a really great JavaScript IDE.  I think WebStorm fills that niche rather well.  And, with some interesting new tooling, and the greater JavaScript community's drive to mature as a developer culture, sees newer greenfield projects that at least have a maintainable architecture."], [4, "> the complexity and difficulty of maintaining the code base as the application grows beyond the safe threshold for the language (in the case of JavaScript, I\u2019d say that\u2019s about 20k LOC)\n\nwell... as the app grows toward that limit you can start reimplementing parts of it in Elm and just use the inter-op to communicate with the rest. "], [4, "Sounds to me like they're really talking about HTML5/the web platform as a whole, while trying to pin it all on JS for some reason. Bit of a muddled message."], [2, "Beating up the dead horse, are we?"], [1, "Web Assembly Lang"], [1, "I use TypeScript for 50-100 SLOC projects. Problem Solved."], [0, "[deleted]"], [0, "Blaming the language for your shitty code... Think simple, that is how we scale."], [-1, "abovementioned is not a word. "], [-1, "I have some grievances with this article, but those have been pretty much pointed out on other comments already. What I would like to add is this:\n\nIf you write something in JS, you can be pretty sure that you can make it run wherever you'll need it, even if you don't know yet where that will be. It's supported by every browser on every platform (without plugins), on every major OS, on most hardware, directly embedded in other languages (Java, C++, C#, Object C),  frameworks (e.g. unity), in PDF documents, in iot devices, etc...\n\nAs a result, often JS is either the only choice, or the only alternative to writing something many times. Even if the language is flawed, it  happens to be best solution for a lot of projects. So instead or trying to convince people that are more or less required to use it of how awful it is, I would suggest to accept that this is the world we live in for the foreseeable future and try to build on what we have, not what we would like to have."], [0, "I've never heard javascript called a functional language before. I guess if having function arguments is the only qualifier."]], [[{"comment": "We definitely needed another one of these articles.", "id": "d128o40"}, {"comment": "[deleted]", "id": "d12a07i"}, {"comment": "They say that when the WebAssembly cometh, it bringeth everything.", "id": "d12k6uy"}, {"comment": "Just compile the JVM to WebAssembly and laugh at anyone trying to disable your applets. ", "id": "d12lwlb"}, {"comment": "He has a whole series of article about how bad js is. ", "id": "d138do2"}, {"comment": "And upvoted to the roof.", "id": "d132o25"}], [{"comment": "Medium needs to change its name to \"TL;DR\". Just a bunch of angry junior engineers starting flamewars because they can't get grunt to work.", "id": "d12htzu"}, {"comment": "So why can't all these junior engineers get grunt to work?", "id": "d12sly5"}, {"comment": "THIS GRANDMA USED THIS ONE WEIRD TRICK TO GET GRUNT TO WORK! JUNIOR ENGINEERS HATE HER.", "id": "d1391b0"}], [{"comment": "I am so tired of seeing that \"good parts vs definitive guide\" image used as serious evidence that JS is a bad language. It was funny as a joke, but it doesn't actually mean anything. Two books by different authors exploring the languages in different levels of depth. Yeah, obviously the one called \"the definitive guide\" is going to be a lot longer.", "id": "d126csj"}, {"comment": "Came here to say this.\n\nIt's concerning that so many programmers put that forward as a serious argument. It shows woefully inadequate analysis skills.\n\nAs a joke, it's in the same class as saying that {} + [] nonsensically becomes 0. I don't find that funny, because it's not normal to add an object and an array expecting a meaningful result.", "id": "d12gje8"}, {"comment": "> because it's not normal to add an object and an array\n\nBut that's not actually what happens.\nTry to open your repl right now and write **{}** it evaluates to **undefined**?!\nbut if you say **x = {}** you get **Object{ }**\n\nIf you on the other hand say **x + []**  you get **\"[object Object]\"** instead of **0**.\n\nWhat is this craziness? Well, when you write **{}** in the repl it actually evaluates as the empty block of statements, not as an empty object. The result is that the line is interpreted as an empty block, an implicit semicolon to separate two statements and then a unary plus before the empty array coercing it into 0.\n\nI mean this is not just crazy type coercion going on, but a mixture of all kinds of crazy language features.\n\nJavascript enthusiasts will often say that you just have to understand the underlying principles and then explain it completely wrong. It might be true that most code will not make use of this, but javascript is a language that allows these strange and varying behaviors for seemingly equal things. It might not happen in ordinary code but when these things happen by mistake the results can be very misleading.", "id": "d12rn1f"}, {"comment": "Yeah, I mean, you could do that with any language.  \n\nPython: The good parts - just explain the syntax and some useful standard libraries.  \n\nPython: The definitive guide  - goes into all the standard libraries in detail and also into popular 3rd party libraries.", "id": "d126nsp"}, {"comment": "Putting the joke aside, I think you're missing the point that most other languages have far fewer warts than JavaScript has. Make a list of JavaScript's warts. Then make a list of Python's warts. You'll find that the second list is much, much shorter.", "id": "d12d7j1"}, {"comment": "> Then make a list of Python's warts. You'll find that the second list is much, much shorter.\n\nBut hopefully indented correctly.", "id": "d12e1wz"}, {"comment": "In my opinion, quantity of warts isn't really a useful metric for a programming language. What's bad about JavaScript's warts is that you're dealing with them all of the time and that they're such a core part of the language. It's not a very big language either, more complicated languages probably have innumerably more warts that most people don't really deal with until they've used it for a long time.", "id": "d12gmx0"}, {"comment": "Honestly the only language-level warts I've really had to expend any effort (and indeed debugging time) on in JS are these two:\n\n1. undefined and null are separate things\n\n2. ASI\n\nAnd even in those cases, it's only actually been a problem a handful of times.", "id": "d12h60z"}, {"comment": "How's undefined and null being separate a bad thing? I kinda like being able to differentiate between \"I never defined that\" and \"I defined that, but whatever I assigned to it was empty.\"\n\n\\* What self-idolizing jackass downvotes an honest question?", "id": "d12ok1o"}, {"comment": "The problem is that in most cases, you end up wanting them to behave the same way, and it's relatively easy to have programming errors due to inappropriately strict comparisons against `null` or `undefined`. This is particularly the case if you generally maintain a convention of always using `===` and `!==` (even if you make an exception for `x == null`, it can slip in).\n\nI agree that it's useful to make a distinction between \"set to null\" and \"not set\", but I maintain that having an `undefined` value is not a good way to do it, because it propagates and can even be set explicitly. If you want to \"unset\" a value in this sense, `a.f = undefined` is not a good way to do it. After all, by looking at the code, you don't really expect `a.foo = b.bar` to potentially \"unset\" `a.foo`, but it sure can.\n\nOne of the most common bugs I've seen because of this \"propagation of unsetness\" can be seen in this example, which ostensibly logs a separator line if called with no arguments, or the passed string if called with one argument:\n\n    function log(str) {\n        if (str === undefined) {\n            console.log('-------------------')\n        } else {\n            console.log(str);\n        }\n    }\n\nLater you're using this function, and you do \n\n    Foo.prototype.logX = function () {\n        log('X is equal to:')\n        log(this.x);\n    }\n\nAnd of course this means if property `x` is unset, we'll see in our logs:\n\n    X is equal to:\n    -------------------\n\nOf course the correct way to implement this is to replace `str === undefined` with `arguments.length > 0`. This example is pretty benign, but I've seen the same bug have way worse consequences.\n\nAnd when it comes to objects, we thankfully have another option for determining if a value is unset: `hasOwnProperty` (it should have been `in` but the semantics of that got screwed up early on). In addition to leading to fewer double-negatives (`!x.hasOwnProperty('foo')` vs `x.foo !== undefined`), this makes \"unsetting\" achievable only through `delete`. No more accidental propagation of unset-ness, and no more \"equals sign sometimes means to unset\".", "id": "d12sulg"}, {"comment": "That actually explains a lot. Thanks for the breakdown!\n\n\\* PS: happy cake day!", "id": "d12tl4p"}, {"comment": "Unfortunately `undefined` in practice is just another null and the value doesn't tell you anything. If it wasn't possible for the user to use undefined as a value just like null, you could have a point. But for now you cannot use `undefined` to mean that something wasn't there because it could have been there, just assigned to `undefined`.", "id": "d132fpn"}, {"comment": "My take: [having one kind of \"null\" value in a language is widely recognized as a mistake](https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions) - surely having two is twice as bad.", "id": "d12vbr3"}, {"comment": "That may be true for a statically compiled language, but I don't think you can make those kinds of assurances in a dynamic language (at least, not without severely getting in the way). Also, if we didn't have a built-in null, people would invent their own, so we'd have a different \"null\" object for every library.", "id": "d12wlgq"}, {"comment": ">Also, if we didn't have a built-in null, people would invent their own\n\nOr just have an `Option` type (or the dynamic equivalent) :)", "id": "d12x6ua"}, {"comment": "Very true! It's easy to trip over JavaScript's warts. C++ is a BIG language with lots of warts, but most of those warts are edge cases that you seldom run into. Nevertheless, I feel uncomfortable using C++; the idea that those warts are there bug me!", "id": "d12na6i"}, {"comment": "My favourite is having to make an empty virtual destructor.\n\nThere are many languages where you can never know what something does, but in C++ you have to fix invisible things!", "id": "d132wcv"}, {"comment": "Oh yeah, no argument there.  Just supporting /u/gurenkagurenda's argument that the existence of these two books is not a good argument by itself.", "id": "d12iubm"}, {"comment": "But doesn't it give you pause that it hasn't been done with other languages?", "id": "d12sqhh"}, {"comment": "I mean, I'm sure there are books in any language of varying size.  Maybe they just don't happen to have the same titles, but I wouldn't expect that.", "id": "d12sx1w"}], [{"comment": "I've just started learning it for work, and yeah, coming from C# it's pretty icky, but it's not dysfunctional at all.\n\nThe problem right now is the tooling. If you stick to HTML5 + JS + CSS, it's really not so bad.\n\nIf you ignore all the tooling for it, toss node/npm/bower/gulp out the window, and you use just angular and bootstrap, you can have a decent responsive web page. I think the major mistake a lot of new web developers are making is that they start learning JavaScript coming up from node, instead of going down from the browser. The tooling is fine if you know what it's doing behind the scenes, but if your first experience with learning JavaScript is firing off a yeoman generator, you are going to have a bad time.\n\nAs long as you start with angular 1.x and learn how it handles separation of concern, you can write good JavaScript code from the get-go and you can learn prototypical oo as you go along, you don't need it right away.", "id": "d12fpp7"}, {"comment": "This so much - open N++ or whatever your fav editor is and insert your JS/CSS in your controller code (php/ruby/go/whatever) when you need to load it, in an order that makes sense. Think for a second about the complexity difference between doing that and then using yeoman to \"help\" yourself to a base setup that auto installs NPM/Bower and writes out the required Grunt or Gulp ini files that initiates your build stack (now you got one, trust me). What pill do you swallow (red/blue) and who will you blame for the consequences? ;)", "id": "d12id4w"}], [{"comment": "JavaScript isn't necessarily a dysfunctional language; however, there are a lot of horrible JavaScript codebases cobbled together by developers without strong fundamentals.  The bigger issue, in my opinion, is that there is such a low barrier to entry that JavaScript -- much like other languages that are easy to adopt -- allows you to write bad code with terrible abstractions.  Also, until fairly recently (the past few years), there hasn't been a really great JavaScript IDE.  I think WebStorm fills that niche rather well.  And, with some interesting new tooling, and the greater JavaScript community's drive to mature as a developer culture, sees newer greenfield projects that at least have a maintainable architecture.", "id": "d126u0s"}, {"comment": "Javascript is definitely a dysfunctional language.", "id": "d12fxch"}, {"comment": "Are you disagreeing with any of his examples for what makes JavaScript a dysfunctional language? Freewheeling conversions, integers stored as floats, the [horrible arrays](http://thecodeship.com/web-development/common-pitfalls-when-working-with-javascript-arrays/), and one he did not mention, objects stored as maps, so that `hasOwnProperty` is required to filter out fields from the prototype when iterating keys.\n\nClearly JavaScript is not well engineered, but good engineers can work around the dysfunctions.", "id": "d129rnb"}, {"comment": "How does it affect you as developer how integers are stored? Anyway, integers are actually stored as integers in all modern implementations and clearly you or the author didn't know this, so how can it affect you?\n\nWhen iterating keys, you just use Object.keys or for-of or even better, if you want a map, just use `Map`. It's not 2008 anymore.", "id": "d132kl0"}, {"comment": "As far as I know you have to jump through some hoops to tell the JS engine it can use an integer. So that really only happens when you compile to JS.", "id": "d132zid"}, {"comment": "No you don't. The semantics of floating point operations on floats that are integers (e.g. 1.0 + 2.0) are the same as real integers as long as there is no overflow, negative zero etc. If there is overflow or negative zero it will be promoted to double that can hold the value instead of wrapping around.  \n\nI think you are confusing this with asm.js which is compiled directly to native ahead of time, thus it needs you declare ahead of time whether the type of a number is double, int or float.", "id": "d133mfh"}, {"comment": "Doubles have less precision than 64 bit integers. Asm.js is JS.", "id": "d138tne"}, {"comment": "And 64-bit integers have less precision than 256 bit integers, what's your point?", "id": "d14ess4"}, {"comment": "That you can't use a double as a 64 bit integer.", "id": "d14ew3n"}, {"comment": "I didn't claim that you could.", "id": "d14ig7s"}, {"comment": "I would tend to agree with that, but I also find it really frustrating when languages try to protect me from myself. It's fantastic for a language to say \"you don't have to worry about this\". It's terrible for it to say \"you're not allowed to worry about this\".\n\nBecause sooner or later, I'm going to need to worry about it, and when that happens, I'm going to have to go to crazy lengths to get around the language's artificial restrictions.", "id": "d12hbnb"}], [{"comment": "> the complexity and difficulty of maintaining the code base as the application grows beyond the safe threshold for the language (in the case of JavaScript, I\u2019d say that\u2019s about 20k LOC)\n\nwell... as the app grows toward that limit you can start reimplementing parts of it in Elm and just use the inter-op to communicate with the rest. ", "id": "d122pe4"}, {"comment": ">Are you doing serious software engineering, or are you hacking together relatively simple applications (less than 20k LOC)\n\nThat and also using LOC as measure of a program's complexity is arbitrary. \n\nElsewhere in the article op expressed admiration for smalltalk as the anti-js and a paradigm of good programming language, yet apple is moving away from it with Swift.  \n", "id": "d12613v"}, {"comment": "> Elsewhere in the article op expressed admiration for smalltalk as the anti-js and a paradigm of good programming language, yet apple is moving away from it with Swift.\n\nUh. Apple doesn't use Smalltalk.\n\nAnd if you want to argue that ObjC is basically Smalltalk, then you might as well argue that C is basically FORTRAN. C and FORTRAN are much closer than ObjC and Smalltalk.", "id": "d128wpg"}, {"comment": "Apple uses Obj-C, not Smalltalk. The author brings up Smalltalk as an example of a well engineered language, as a counterpoint to JavaScript's \"anti-engineering\".\n\nApple created Swift because of Obj-C's shortcomings, coming from Obj-C originating as an OOP layer bolted on top of C.", "id": "d12apxl"}, {"comment": "I believe that Smalltalk is in some ways better than JS, but the reasons why the author thinks Smalltalk is good make little sense.\n\nHe has examples of Smalltalk's great syntax that actually just showcase a large library. He uses a function to get primes when normally the point of such an example would be to show some loops and maybe arrays.", "id": "d1332gh"}, {"comment": "Yes, but getting javascript programmers to invest in learning Elm... good luck.", "id": "d12az6n"}], [{"comment": "Sounds to me like they're really talking about HTML5/the web platform as a whole, while trying to pin it all on JS for some reason. Bit of a muddled message.", "id": "d1233q0"}, {"comment": "The author is saying that the ecosystem makes up for the flaws in the language, and makes very specific arguments against the language itself:\n\n> In other words, this is user community, ecosystem, \n> and jobs versus maintainability, reliability, and productivity. \n> The classical contention in IT.", "id": "d128mpm"}, {"comment": "That only makes sense if you ignore all of the other things in its ecosystem that are unproductive, not reliable, hard to maintain, etc. Even if we replace JS with WebAssembly, there will still be tons of quirks, warts, etc to deal with and things will be only a bit more productive for the kinds of software engineering this article seems to be aiming at. Lack of types and such hasn't held back other more productive dynamic languages, and some of those have a lot of warts as well. It's the full stack that needs to progress to reach the goal here, and I think the article is taking one of the problems and trying to pin too much on it.", "id": "d12bar3"}, {"comment": "Let's be clear that JavaScript's problem with numbers is not that JavaScript doesn't have 'types'. The problem is that it doesn't have integers. Smalltalk, Scheme, Python, and most other dynamic languages have integer type values.", "id": "d12cxyh"}, {"comment": "Well, sure, but that's not the *only* big problem JS has, if we're to use it as a performant programming language for larger apps. There are also problems with HTML and CSS that need addressing for certain types of applications, if we're going to also use them for those domains. But personally I think we're all waiting for something like WebAssembly so we don't even HAVE to use JS as the language anymore for anything but the simple stuff it was meant to be used for in the first place (or as a hacky bytecode-esque thing).", "id": "d12e60q"}, {"comment": "Dynamic languages do not lack types, they lack type declarations. Languages like Ruby and Python are strongly typed. A value's type is its type, and types are well defined. If you use the value wrong, you'll get a runtime error (instead of a compile time error). JavaScript is weakly typed, in that it will juggle types to make things work, mostly, but sometimes with unexpected results.\n\nThe idea behind Web Assembly is to create a standard bytecode which is much faster to parse, allowing alternative languages with better syntax and semantics to be used in client-side code. But we don't really even need Web Assembly for that, because even today JavaScript is a *compilation target*, because people hate JavaScript and its warts enough to jump through hoops to avoid writing it.\n\nThe other issues with the Web platform as a whole are out of scope of the OP's rant.", "id": "d12kth6"}, {"comment": ">Dynamic languages do not lack types, they lack type declarations.\n\nSure, but WebAssembly aims to support not just strongly-typed static languages, but also more dynamic ones, probably including JS (though not necessarily right away).\n\n>But we don't really even need Web Assembly for that, because even today JavaScript is a compilation target\n\nRight now, maybe not. But using JS as a compilation target makes it difficult to optimize the resulting code as well as just optimizing it ahead of time and sending the IR down the wire in a bytecode format.\n\nNot to mention that even for a simple game like [AngryBots](https://hacks.mozilla.org/2016/03/a-webassembly-milestone/) the resulting bytecode binary already compiles in half the time and loads 10 times faster than asm.js, and that's at this early stage. And I can see this being far more RAM-efficient as well.\n\nSo we do sort of need this if we want to do more with the web, and more efficiently. Whether that's what we really want is another debate entirely, but I'd still rather have this than Flash for online games (for instance).", "id": "d12l82s"}, {"comment": "> Sure, but WebAssembly aims to support not just strongly-typed \n> static languages, but also more dynamic ones, probably \n> including JS \n\nHow JS gets compiled to Web Assembly has nothing to do with being weakly typed. Java, Ruby, Python and JS all can be compiled to Java bytecode.\n\n> Right now, maybe not. \n\nRight now, currently. Languages which compile (technically, transpile) to JS includes CoffeeScript, ClojureScript, Ceylon and Java.  \n\nYou're talking about talking about writing *video games* in JavaScript, which is completely different. ", "id": "d12mjpy"}, {"comment": "Ok, I've completely lost the thread of discussion here. Re-reading the comments, this is a tangent, and the real point I had you seem to shoot down completely a few comments up:\n\n>The other issues with the Web platform as a whole are out of scope of the OP's rant.\n\nI disagree. They're ranting about problems with the Web platform as a whole, yet framing it as though JS isn't just one of the problems, but is responsible for more of them than it really is.\n\nFrankly I don't even think we even disagree about anything wrt WebAssembly. I was just using it as an example that even if JS was replaced with a better language (that wasm supports), many of their points/complaints would still hold with the Web platform at large (not all of them, obviously).\n\nI don't mind agreeing to disagree on that, though.", "id": "d12n88b"}], [{"comment": "Beating up the dead horse, are we?", "id": "d12azzm"}, {"comment": "Given that every time this comes up, morons come and defend Javascript... no. No not really.", "id": "d12fwmx"}], [{"comment": "Web Assembly Lang", "id": "d1252iz"}, {"comment": "I'll wait until WebHDL", "id": "d12e45w"}], [{"comment": "I use TypeScript for 50-100 SLOC projects. Problem Solved.", "id": "d13oj9z"}], [{"comment": "[deleted]", "id": "d12bjgx"}, {"comment": "*Au contraire*. Smalltalk is neither obscure nor an \"academic\" language. Modern Smalltalk is alive and well in [Pharo](http://pharo.org/), which is evolving quickly; you can see this in the activities of [ESUG](http://www.esug.org/wiki/). There is a healthy commercial niche for Smalltalk, which is used around the world (in particular, look up Cincom and GemTalk). One of my friends owns Simberon, an Ottawa-based software house that specializes in Smalltalk.", "id": "d12cw1a"}, {"comment": "Smalltalk is definitely obscure by any sane definition of obscure. Languages don't cease to be obscure just because you personally like them.", "id": "d12fzvn"}, {"comment": "There are plenty of sane definitions of \"obscure.\" Mine is: Very few people have heard of the language, or use the language commercially, or know what it's good for. Nim (the language formerly known as Nimrod), for example, is obscure. So is Io. So is Vala. Make no mistake, these languages have their advocates, but they are obscure.\n\nMost real programmers have heard of Smalltalk. Smalltalk is commercially used, even if the market is a small niche, and it's used around globe, in Europe, South America, Australia (not so much in Asia or Africa). Most programmers know what Smalltalk is famous for; it's the father of modern OOP; it represents the ultimate of OOP purity. Smalltalk has directly influenced many of today's languages (according to Wikipedia), including Dart, Erlang, Go, Groovy, Objective-C, Perl 6, Ruby, and Scala. Smalltalk is hardly obscure.\n\nScheme keeps company with Smalltalk when it comes to obscurity. Scheme is not obscure, either, even though to my knowledge it's not much used commercially. (Full disclosure: I like Scheme, Smalltalk, Go, and Python.)", "id": "d12mxrb"}, {"comment": "Smalltalk isn't actually well known. It might be well known among the sorts of people that discuss programming on reddit, but most programmers have probably either never heard of it or know nothing about it.\n\nMany languages are used commercially by *someone*.", "id": "d12nkfk"}, {"comment": "> Smalltalk is definitely obscure\n\nLanguages don't start to be obscure just because you personally dislike them.", "id": "d12j78l"}, {"comment": "Smalltalk isn't obscure because I don't like it. It's obscure because the majority of programmers have never read Smalltalk code, would not understand it if they did, have no interest in learning it and would not consider using it commercially.\n\nSmalltalk has a shitload of fanboys on reddit for some reason. I don't know why, given that OOP is a fundamentally terrible paradigm (literally built around conflating data and code, and mutating data, both of which are very bad ideas). But I suppose you have to feel superior to Java programmers in some way and if it's not \"I'm superior to a Java programmer because I've written a tutorial explaining burritos in terms of monads\" it's \"I'm superior to a Java programmer because I know what Real OOP(tm) is, and Real OOP definitely isn't No True Scotsman, no way.\"", "id": "d12ntzy"}, {"comment": "Can you show me even five recent smalltalk job postings?", "id": "d12ni1y"}, {"comment": "I mean, I'm not sure I can find you five F#, Scala, OCaml, or Haskell job postings - and they're not exactly obscure languages :P", "id": "d12vf7n"}, {"comment": "So there are Smalltalk jobs? Gotta be 50 times smaller job market than delphi which is also commonly called obscure. Is there even one smalltalk job in ALL of canadas web based programmer job boards?", "id": "d12ilqo"}, {"comment": "Surprisingly enough, I found one job posting for a VisualWorks developer in Quebec City! ;-)", "id": "d12n1rv"}], [{"comment": "Blaming the language for your shitty code... Think simple, that is how we scale.", "id": "d12qb8x"}], [{"comment": "abovementioned is not a word. ", "id": "d12ieqr"}, {"comment": "Yes, it is: http://www.dictionary.com/browse/abovementioned?s=t", "id": "d12lcdm"}], [{"comment": "I have some grievances with this article, but those have been pretty much pointed out on other comments already. What I would like to add is this:\n\nIf you write something in JS, you can be pretty sure that you can make it run wherever you'll need it, even if you don't know yet where that will be. It's supported by every browser on every platform (without plugins), on every major OS, on most hardware, directly embedded in other languages (Java, C++, C#, Object C),  frameworks (e.g. unity), in PDF documents, in iot devices, etc...\n\nAs a result, often JS is either the only choice, or the only alternative to writing something many times. Even if the language is flawed, it  happens to be best solution for a lot of projects. So instead or trying to convince people that are more or less required to use it of how awful it is, I would suggest to accept that this is the world we live in for the foreseeable future and try to build on what we have, not what we would like to have.", "id": "d12mhnx"}, {"comment": "Coming from a serious software engineering background, I find this attitude appalling. So it doesn't matter that the language lacks the discipline and clarity to properly engineer your software? The only things that matter are JavaScript's ubiquity and not having to use more than one language for development?\n\nThe fact that JS software runs everywhere trumps reliability and maintainability? It's hard enough to find and fix bugs when you have a good, solid programming language behind you. A sloppy language like JavaScript worries me a lot, esp. if your software grows large enough. I don't suppose you've ever worked on really big code bases. Those things are maintenance nightmares, even though they're written in C or C++ or C#.\n\nYou mustn't underestimate my warning. For example, Google created the Go language for a very good reason. They needed a language that would help them manage big systems. Go is a well-designed language for supporting software engineering at scale. [It's very pragmatic](https://medium.com/p/the-little-language-that-could-61eaa62b5e0a).\n\nCan you rely on JavaScript in this manner? Or are you content to always write small-to-modest size applications?", "id": "d12oodg"}, {"comment": "I never said that \"it doesn't matter\", and what I'm \"content\" with isn't relevant to what my task at hand is. Just because I don't fully agree with the article my stance isn't the polar opposite of it.\n\nI also have worked on large projects, but JS was never the *only* language used. If you can freely choose between let's say Java and JS for a project, I would recommend Java for most people. Because, yes, JS lacks discipline, which has to be compensated for by the discipline of the developer.", "id": "d133044"}], [{"comment": "I've never heard javascript called a functional language before. I guess if having function arguments is the only qualifier.", "id": "d128rz4"}, {"comment": "Nowadays every language (except C, actually, since C only has function pointers), has first-order functions and closures (\"lambdas\"), but 15 years ago, it was the only \"popular\" language to have them. By popular, I mean \"That can get you hired by some company\". Neither Java nor C++ nor C# nor PHP had them, Python had (still has) a poor man's version, Scala and the like did not exist, Delphi, VB and COBOL were obviously not interested, etc.\n\nYet, in 2000, with Javascript, you could use a function as a parameter of another function. With lexical closure. Wow. You could implement high-order functions, curryfication, and all the like. Wow. And that was in a language that was conceived (and still used) to display the current time on webpages. And do funny things wrt the mouse cursor. That was kinda unfair. So much power in such a \"useless\" language.\n\nJavascript was probably the most \"functional\" of all popular languages. Since then, it changed a lot, yet it looks like FP is much more frequent in js framework/libraries than in other languages.", "id": "d12icfg"}, {"comment": "C# didn't exist 15 years ago, but it had delegates since v1.1.", "id": "d12lqu0"}, {"comment": "C# has lamdas since its birth.", "id": "d12ram6"}, {"comment": "JS has first-class functions which is the bare minimum to make a functional language.  \n\nFirst-class function simply means functions can be assigned to variables and passed as the parameters to another function or a function can be the output of a function.\n\nGranted, most modern languages that we think of as functional also have closures.  A closure is a function that has its own local environment for its own local variables.  \n\nFor an example of closures in the JS console:\n\n    > var counter_maker = function () {\n          var count = 0;\n          return function () {return count += 1;}\n        }\n    \n    > var counter1 = counter_maker();\n    > var counter2 = counter_maker();\n    \n    > counter1()\n    1\n    > counter1()\n    2\n    > counter1()\n    3\n    > counter2()\n    1\n    > counter1()\n    4\n    > counter2()\n    2\n\n`counter_maker` is a function that returns a function closure.  Every time `counter_maker` is called (e.g., in `var counter1 = counter_maker()`) it defines a new function (`counter1`) with a new local environment that has variables tied to the function closure (in this case `count`) that it keeps track of.  ", "id": "d12amah"}, {"comment": "See my other response, first class functions are not the bare minimum for a functional language, else almost any language can be called functional. ", "id": "d12b9sd"}, {"comment": "IMHO: the \"shibboleth\" for whether a language is functional is if it supports algebraic data types (or the dynamic equivalent). So all MLs and Lisps, most theorem provers, and Haskell.\n\nTypeScript is probably the one exception I'd make - it doesn't have sum types, but it has union types, which fulfill the same niche.", "id": "d12vklh"}, {"comment": "Where's the support for algebraic data type in Common Lisp, which most generally regarded as the first functional programming language?\n\nAlso, I would not call C a functional programming language as it doesn't have first-class functions.  It does basically have algebraic data types through `struct` (product), `union` (sum), and allows defining types (typedef).  (Granted it's much less convenient and there's no convenient pattern matching).", "id": "d12xf1k"}, {"comment": "`union` ain't no sum type! Sums are tagged unions, but `union` is untagged And C has no ~~function passing~~ first-class functions. But otherwise C can be considered a really shitty functional language.\n\nCommon Lisp being super duper flexible, you can implement the semantic equivalent of sum types. You just won't get compile-time checking.\n\nAlso, you can use Java and C# as functional languages with final/Sealed classes, it's just an incredibly obnoxious way of coding.", "id": "d12xjni"}, {"comment": "C very much has function passing via function pointers, what it lacks is closures.", "id": "d131i5l"}, {"comment": "Making JavaScript a functional language is what Brendan Eich was going for until the nasty Netscape marketing folks made him make the language look like Java (so the story goes).\n\nJavaScript is functional because functions are first class values. C lets you pass around function pointers, which are just bare references to memory locations, while in JavaScript, functions are objects that can be created and manipulated.", "id": "d12a7wb"}, {"comment": "Javascript has no algebraic data types, pattern matching, or immutability. It's inherently stateful, and in fact embraces side effects. First class functions are far from the only feature needed to qualify as a functional language. Regardless of what the original language designers intended, the current incantation is decidedly *not* functional.", "id": "d12awtr"}, {"comment": "Quite right. But it's Douglas Crockford and others who insist that functional programming is one of JavaScript's key strengths (the other being prototype objects). They're trying to sell JavaScript to the world as a functional programming language. The author is trying to dispel this nonsense.", "id": "d12cali"}, {"comment": "My original comment was to agree with the author, because I've never heard anyone call javascript functional, and can't believe some would. It has features that can be used in a functional way, but traditionally you call a language by it's most commonly supported paradigm. As an example, C# supports many functional features, but most would still say it's an object oriented language, or at least multi-paradigm. F# is the inverse.", "id": "d12cu84"}, {"comment": "First, let's get real. We're talking about *JavaScript* here, which is not really principled about anything. That being said...\n\n> Javascript has no algebraic data types, pattern matching, or \n> immutability.\n\nNone of these are *requirements* of functional programming. At the very least, functional programming is a style of programming where program control flow is driven by function application instead of imperative statement evaluation directed by side effects. The lambda calculus vs. Turing machines.\n\nThus, while JavaScript is a procedural programming language, and allows side effects, can JavaScript *naturally* express functional programming idioms? If yes, then the language is functional, but not purely so.", "id": "d12jqt5"}, {"comment": "Having first-class functions is what allows you to use common functional programming paradigms in javascript invoking higher-order functions like:\n\n    > var arr = [1,2,3,4,5];\n\n    > arr.map(function(x) { return x*x; })\n    [1, 4, 9, 16, 25]\n    > arr.map(function(x) { return x*x; }).filter(function(x) { return x > 5 } )\n    [9, 16, 25]\n    > function mysum(arr) {\n          if (arr.length == 0) { return 0; }\n          return arr[0] + mysum(arr.slice(1));\n       }\n    > mysum([1,2,3,4,5])\n    15\n\nIt doesn't really make sense for a language with weak dynamic typing to have pattern matching or ADTs, but again neither pattern matching or ADTs have anything intrinsic to do with functions either.\n\nAs for Javascript allowing mutable state and side-effects, yeah it does.  We haven't claimed it's a pure functional language -- it's multi-paradigm, like [Lisp, the first functional programming language](https://www.cs.kent.ac.uk/people/staff/dat/tfp12/tfp12.pdf) (which also doesn't have built-in ADTs or pattern matching and allows mutable state).", "id": "d12cufu"}, {"comment": "Almost all languages are multiparadigm in some way. But it's a spectrum, and typically you refer to a language by it's most common use. You can implement monads in c++, that doesn't mean it's a functional language.", "id": "d12d7f0"}, {"comment": "First, not every language has first class functions (e.g., C, fortran, pascal, ada, SQL, PL/SQL), though most modern languages do as its often convenient.  Languages that have first class functions allow you to write in the functional paradigm.\n\nSecond, being able to implement feature X in a language means very little.  You can implement [algebraic data types](https://www.npmjs.com/package/adt) or [strong typing](http://lea.verou.me/2011/05/strongly-typed-javascript/) in JS, though obviously that doesn't mean JS has ADTs or strong typing.\n\nThird, having Monads or ADTs or pattern matching or continuations or feature X is not what makes the functional programming paradigm.  E.g., ML, Erlang, Clojure, Lisp are all widely considered functional programming languages and don't primarily rely on monads to deal with side effects (and they don't all necessarily have ADTs or continuations or pattern matching or ...).\n\nThe common thread that makes a style of programming \"functional\" is using the lambda calculus mindset and having higher order functions.  It's pure function if it doesn't allow mutable state, but plenty of functional languages aren't pure.", "id": "d12j33l"}, {"comment": "I really strongly disagree that algebraic data types, pattern matching, and immutability are necessary requirements for a functional language. Hell, one of those is pretty much just syntactic sugar.\n\nI also don't think \"functional programming language\" is a well defined term. If I had to give a good definition, I'd say \"a language that encourages functional programming\".\n\nThat allows for a lot of shades of gray. And I'd say JS *weakly* meets this definition. It's certainly not *as* functional as Haskell or Erlang, but compare it to something like C, where functional programming is borderline impossible.", "id": "d12hnz1"}, {"comment": "> \"functional programming language\" is [...] \"a language that encourages functional programming\".\n\nA circular definition, which still manages to exclude JavaScript.", "id": "d12igvm"}, {"comment": "It's not a circular definition. \"Functional programming\" is pretty well defined. \"Functional programming language\" is not.\n\nAnd yes, JavaScript does encourage functional programming more than many languages do.", "id": "d12jurv"}, {"comment": "Functional doesn't mean \"has first-class functions\". C# and C++ aren't functional.", "id": "d12fy8f"}]]], "3zv1jl": ["Java isn't slow", "2016-01-07 14:05:34", 0, "http://jvns.ca/blog/2016/01/03/java-isnt-slow/", [[10, "JVM / Java being slow is an persistent myth that origins from its early days. Though the platform's startup time can be slower than others, it's [keeping up well with unoptimized C/C++ on the long run](https://bjpelc.files.wordpress.com/2015/01/graph3.png).\n\n&nbsp;\n\n^(1nb4 /u/agleiv_17)\n\n"], [9, "Actually it is compared to well-written C++. The article mentions Cassandra as an example that database software is written in Java. Scylladb is a C++ cassandra protocol compatible database. Take a look at the benchmarks at http://www.scylladb.com/technology/cassandra-vs-scylla-benchmark/\n\n Also take a look at Google Bigtable which is written in C++. The benchmarks vs HBase and Cassandra are at http://googlecloudplatform.blogspot.com/2015/05/introducing-Google-Cloud-Bigtable.html\n\nAlso take a look at the HN discussion of a paper by Google comparing C++, Java, Scala, and Go performance. Notice how the optimized C++ code has fewer lines of code than the Java version while outperforming it by a significant margin. https://news.ycombinator.com/item?id=2615096\nNote that the above comparison was using pre-C++11. With C++11/14 the code could be made simpler and possibly more performant (for example using move semantics)"], [11, "If someone is going to fairly criticize Java then they'll talk about the high memory usage. On average a garbage collected program uses in the ballpark of 2x the memory as a non-GC program (there is a paper somewhere that came up with the 2x estimate).\n\nSo if you have a server machine with a giant amount of RAM, then Java is fine. But say if you try to use a Java program on your desktop, you might be more likely to have memory paged to disk, resulting in terrible performance."], [5, "Funny this has come up. I was just reading the following about benchmarking MQTT brokers written in various systems languages, and Java:\n\nhttps://atilanevesoncode.wordpress.com/2014/01/08/adding-java-and-c-to-the-mqtt-benchmarks-or-how-i-learned-to-stop-worrying-and-love-the-garbage-collector/\n\nJava is well able to match the usual systems suspects for all but the most demanding of tasks. In fact, these days the questions need to be asked about C & C++ rather than Java IMHO.\n\nThe LMAX Disruptor project was mentioned. AIUI, the wizards who built that (for HFT exchanges who I gather can be quite demanding) spent months optimising it. As well as implementing lock-free queuing using ring buffers, they removed as much dynamic memory allocation as they could, using object pools instead. It is a pretty advanced example of what can be achieved in Java, but it is attainable nonetheless. I am sure that similar efforts are often put into such projects in other languages."], [3, "I just checked, you still can't explicitly use SIMD instructions in Java. So, for all sets of problems that can be vectorized very well you are going to be ~2 to ~12 times slower than you could be with C++ there, all else being equal. (the latest CPUs can do 16 32 bit operations at a time, all that being 99% wasted when you can't use these instructions. I grant auto vectorization 1%)\n\nThere will also be a very more instructions happening any time you \niterate over arrays since you have to do bounds checking.\n\nYou also won't have as much power to customize memory layout to avoid cache misses, and cache misses are the worst thing in the world.\n\nBut yes, ignoring those issues, if you code your java carefully enough and plan how you use memory very well you can be almost as fast a C. But if you are going to very carefully plan how you use memory.....\n\n"], [1, "Java isn't slow: when used correctly.  My observation over the years is that Java sucks at:\n\n* Startup times.  If we're lucky a full stop/start of an application takes less than 2 minutes.  Most applications are upwards of 5.  This can be a big deal for downtime/deployment if debugging an issue requires multiple restarts (should be done in dev but not everybody has best practices for every system or can afford it).\n* Debugging. The amount of time it takes to debug issues with a Java application is usually much longer (in my experience) than say a Python, Perl, PHP, Go, C, C++ application.  Even when you have support (e.g. from Oracle), it still can be a month(s) long process to identify simple problems (like if it's caused by 3rd party code, your code, improper use of 3rd party integrations, etc).  Also, heap/thread dumps can be difficult to process at times because of the size of them.\n\nThose two issues make Java \"slow\".  They can be avoided if you have good programmers and practices.  Other languages come with their own set of issues but these come up time and time again for Java."], [1, "keep repeating this ;)"], [-2, "It **is**.\n\nOn a less trolling note: it's all relative. However, *given fair conditions* C/C++ will always outperform Java. Significantly."], [-2, "if you're taking quaaludes...  /sarcasm"], [-5, "Ok, let me do a quick test. A single line Hello World (Everything default, in a desktop, no special configuration):\n\n-------\n\ntime java HelloWorld \nHello World!\n\nreal\t0m0.064s\nuser\t0m0.052s\nsys\t0m0.012s\n\n-------\n\ntime perl a.pl\nHello World!\n\nreal\t0m0.002s\nuser\t0m0.000s\nsys\t0m0.001s\n"]], [[{"comment": "JVM / Java being slow is an persistent myth that origins from its early days. Though the platform's startup time can be slower than others, it's [keeping up well with unoptimized C/C++ on the long run](https://bjpelc.files.wordpress.com/2015/01/graph3.png).\n\n&nbsp;\n\n^(1nb4 /u/agleiv_17)\n\n", "id": "cyp8whw"}, {"comment": "It is true that many people on the one hand rip too hard on Java for performance, where in practice it's really quite fast. On the other hand, this idea that Java is really at the level of C++ is also just incorrect. \n\nThe benchmarks where it keeps up or beats C++ are small, artificial benchmarks where Java is working with e.g. simple arrays of primitives with N large, where ultimately nearly identical instructions are going to be executed in either case (like the link you posted). The benchmarks where Java beats C++ usually quite directly target something in C++ that has mediocre performance for naive code; a classic example is repeatedly appending strings to a vector (triggering many small allocations, something C++ is worse than Java at. Why is C++ worse? Because: Java's GC automatically trades off space for speed, for you. C++ does not. In reality you can write a simple custom allocator and get back all that performance gain and more).\n\nIn real code, a lot of issues crop up which aren't present in these benchmarks. One of them is that Java generics don't work with primitives, which have value semantics, so instead you need to work with the boxed types that have reference semantics in many cases. Another is that in C++, memory layout is very easy to reason about and very deterministic. A good C++ programmer with 1-2 years of experience is not going to have any problem laying down critical path data in a contiguous pattern, greatly decreasing cache misses. Yet another is that the programmer has tremendous control over static vs dynamic dispatch in C++; templates and so on can remove indirections, giving the compiler more information for optimization.\n\nUltimately though it boils down to this: C++ has a very deterministic approach to things. You can look at memory layouts or generated assembly, your experiments are more repeatable, not just in terms of time but also in terms of cache misses and so forth. This is intrinsically valuable in certain applications, but it also makes reasoning about performance easier. Java can certainly still be developed faster (although, the way that C++ peeps need to accept that modern Java is pretty fast to run, Java peeps need to accept that modern C++ is pretty fast to code). But if you are going to start investing time into improving performance, your ROI on that time is better for C++ than Java (the same way that your ROI to get functionality and correctness is higher in Java).", "id": "cyphbhh"}, {"comment": "This is probably the most balanced and well written ( and therefore clearly informed instead of fan boy ) description I have read between the java /C++ tradeoff.   Thank you!!!!\n\nSource:  I'm a 15 year java programmer with C++ experience going back 23.", "id": "cypk02r"}, {"comment": "I like that summary of yours. One also has to mention that much speed of the JVM comes from its long runningtime optimizations, hotpath and predictions. So a generalized approach to code can still get a speedy result. But the optimizations are lost when you restart (?). In C++ the performance is more \"hardcoded\" and available immediately. Similar with memory.", "id": "cypl0c1"}, {"comment": "> In real code, a lot of issues crop up which aren't present in these benchmarks. One of them is that Java generics don't work with primitives, which have value semantics, so instead you need to work with the boxed types that have reference semantics in many cases.\n\nThis is mostly solved in Java with popular libraries, here is a 2002 article: http://www.onjava.com/pub/a/onjava/2002/06/12/trove.html\n\n>You can look at memory layouts or generated assembly, your experiments are more repeatable, not just in terms of time but also in terms of cache misses and so forth.\n\nIn reality most people don't do this, because they don't need to.   In the scenarios you need to do this, you also need to guarentee the configuraiton of the hardware (preocessor, memory, etc...).   Because modern systems drastically change how code & data is laid out, whether it's CUDA, or targeted to a Xeon, vs. Qualcom, vs. Freescale, etc...\n\nAll this is futile, since a good algorithm makes a far bigger difference than the ridiculously expensive, low ROI hand tuning delivers.\n", "id": "cyplog9"}, {"comment": "> This is mostly solved in Java with popular libraries\n\nI can't comment in depth on this, but I will add that there are fundamental limitations; you cannot write new primitives. Whenever you write a class, it has reference semantics. So it's hard to make guarantees about memory layout in practical software development.\n\n> In reality most people don't do this, because they don't need to.\n\nBut most people using C++ do, because they do need to, and if they didn't, they would use Java or C# or python or etc. If you think that you are going to be 99% content with the performance and memory usage of your application in idiomatic Java, then I agree Java makes a strong case. There's room in the world for both without either of us claiming that one is better in all cases (though of course it's always fair to like one better :-) ).\n\n> All this is futile, since a good algorithm makes a far bigger difference than the ridiculously expensive, low ROI hand tuning delivers.\n\nSure, a good algorithm is very important, but that's language independent. The assumption is you're going to get a good algorithm in either case; suppose you do that but still want more, what then? There are domains where more performance is almost always a strict win; video games, high frequency trading, anything that runs on a huge number of machines (savings in electricity, etc).\n\nAlso be aware that log_2(N) can't be more than about 30 or 40 on a typical machine (log_2(1 gig) = 30). The difference between L1 cache and ram data access is about x100 or x200. So on modern architectures, good data structures/algorithms are fundamentally a function of cache performance.", "id": "cyppgo2"}, {"comment": ">you cannot write new primitives.\n\nTrue, but if performance is that much of an issue, you can drop to JNI for that one local case.    Looking forward to Java value types even though currently I'm happy with the performance.\n\n> But most people using C++ do\n\nThis is about the only part I disagree with in your post :)", "id": "cytiktu"}, {"comment": "Trove isn't the best one available for HashMaps. I think there's comparison for other collections on this site too:\nhttp://java-performance.info/hashmap-overview-jdk-fastutil-goldman-sachs-hppc-koloboke-trove-january-2015/", "id": "cypmya9"}, {"comment": "Fun fact: JDK10 should allow you to have efficient memory layout of primatives. Take a look at Project Valhalla.", "id": "cyplx3z"}, {"comment": "> 1nb4 \n\nWhy the hell would you *actively summon* that moron!? ... You know people can get a notification from that in their inboxes, right?", "id": "cypi78i"}, {"comment": "I doubt he's gonna miss a title like that anyway.", "id": "cyple2q"}, {"comment": "Looks like he deleted his account. (As opposed to being banned.) Maybe he couldn't stand people trolling him for a change. In an odd way, I think I'll miss him.", "id": "cyqdvx0"}, {"comment": "We should reserve accounts agleiv_18 upwards just in case :D", "id": "cyqixlc"}, {"comment": "I think people mistake that with memory hungry a lot. JVM sometimes needs a bit of tuning and if you dont do that or do that incorrectly you might get into GC eating most of app's time or JVM mem being swapped out, both of which can cause bad performance", "id": "cypfp5f"}], [{"comment": "Actually it is compared to well-written C++. The article mentions Cassandra as an example that database software is written in Java. Scylladb is a C++ cassandra protocol compatible database. Take a look at the benchmarks at http://www.scylladb.com/technology/cassandra-vs-scylla-benchmark/\n\n Also take a look at Google Bigtable which is written in C++. The benchmarks vs HBase and Cassandra are at http://googlecloudplatform.blogspot.com/2015/05/introducing-Google-Cloud-Bigtable.html\n\nAlso take a look at the HN discussion of a paper by Google comparing C++, Java, Scala, and Go performance. Notice how the optimized C++ code has fewer lines of code than the Java version while outperforming it by a significant margin. https://news.ycombinator.com/item?id=2615096\nNote that the above comparison was using pre-C++11. With C++11/14 the code could be made simpler and possibly more performant (for example using move semantics)", "id": "cypg34y"}, {"comment": "The Scylla thing is interesting, but until it's really production ready and able to use large clusters of computers, it's not comparable.  Who knows what their code is or is not doing because it doesn't have all the features that Cassandra offers?  I don't think Cassandra is well-optimized at all either.  ", "id": "cypschs"}], [{"comment": "If someone is going to fairly criticize Java then they'll talk about the high memory usage. On average a garbage collected program uses in the ballpark of 2x the memory as a non-GC program (there is a paper somewhere that came up with the 2x estimate).\n\nSo if you have a server machine with a giant amount of RAM, then Java is fine. But say if you try to use a Java program on your desktop, you might be more likely to have memory paged to disk, resulting in terrible performance.", "id": "cypgio1"}, {"comment": "> So if you have a server machine with a giant amount of RAM, then Java is fine.\n\nUnless Java magically doubles the amount of cache memory available you absolutely will not be fine.\n\nThe modern bottleneck in all non-trivial software development is memory I/O.  This is why C++ still destroys Java in real-world, vs. synthetic benchmarks.  ", "id": "cyplhmn"}, {"comment": "memory i/o seems like a pretty easy target for a synthetic benchmark.", "id": "cypq2yi"}, {"comment": "That's not what I mean at all.\n\nThe issue is that java uses ~2X as much memory for the same code/data as equivalent C++ code.  If the synthetic benchmark compiles to something smaller than the existing caches in both cases, there will be little if any difference. \n\nI'll use an example.  Say you are using an architecture with 128k of data and instruction caches.  You compile a benchmark that results in a 32k C++ executable.  The Java bytecode is compiled into a 64k executable.  So you won't notice any big difference. \n\nHowever, say the C++ code compiled to 100k.  This would fit in the cache fine, while the resulting 200k Java binary would cause cache thrashing.  \n\n", "id": "cyptt7y"}, {"comment": "interesting, that's something i hadn't thought of. thanks.", "id": "cyuk3xk"}, {"comment": "I'm somewhat biased as I worked for the C++ group @Bell Labs in the 1990's and all this was hashed out then.  Java solved some problems inherent with C++ development, while also introducing others.  Like Perl, it was also designed to solve incompatibilities with multiple Unix vendors, which is less of an issue these days given the popularity of Linux.  \n\nIt was also clear that it would never, ever be as fast as the equivalent C++ code for non-trivial applications.  Regardless of what the evangelists promised.  This doesn't make it a bad language, or inappropriate for some applications, but it's still a dishonest statement.  \n\nOther than Android, I don't personally use Java.  ", "id": "cyukisr"}, {"comment": "I think 2x is optimistic. As a rule of thumb heap should be 3x to 4x the live set size see for example http://www.amazon.com/Java-Performance-Charlie-Hunt/dp/0137142528/ref=sr_1_3?s=books&ie=UTF8&qid=1452189760&sr=1-3&keywords=java+performance\n\nOTOH Firefox and Chrome are C++ and use Gigabytes of memory.", "id": "cypk7m0"}, {"comment": "> OTOH Firefox and Chrome are C++ and use Gigabytes of memory.\n\nIs it them or those **Java**Script monstrosities they run?\n\n(Couldn't resist that bloding :-))", "id": "cyqfagn"}, {"comment": "Or they will harp about the jitter in latency because of Garbage Collection kicking off at inconvenient times :(", "id": "cyplj2r"}, {"comment": "Wasn't that the reason for choosing Java in business applications? Throwing more RAM at it is cheaper than using something like C++.", "id": "cyptw01"}, {"comment": "No, the reason was that Java is much simpler and much much more idiot proof, so it's much easier to get cheaper developers to deliver something that still works.", "id": "cyqfbug"}, {"comment": "Modern IDEs and games mean that desktops aren't an issue any longer either.   Maybe if you were creating something for an embedded system you distinction is appropriate.", "id": "cypksqu"}], [{"comment": "Funny this has come up. I was just reading the following about benchmarking MQTT brokers written in various systems languages, and Java:\n\nhttps://atilanevesoncode.wordpress.com/2014/01/08/adding-java-and-c-to-the-mqtt-benchmarks-or-how-i-learned-to-stop-worrying-and-love-the-garbage-collector/\n\nJava is well able to match the usual systems suspects for all but the most demanding of tasks. In fact, these days the questions need to be asked about C & C++ rather than Java IMHO.\n\nThe LMAX Disruptor project was mentioned. AIUI, the wizards who built that (for HFT exchanges who I gather can be quite demanding) spent months optimising it. As well as implementing lock-free queuing using ring buffers, they removed as much dynamic memory allocation as they could, using object pools instead. It is a pretty advanced example of what can be achieved in Java, but it is attainable nonetheless. I am sure that similar efforts are often put into such projects in other languages.", "id": "cypgggq"}, {"comment": "Great article, thanks for sharing.   It's probably worthy of a link on it's own.   ", "id": "cypjyg3"}], [{"comment": "I just checked, you still can't explicitly use SIMD instructions in Java. So, for all sets of problems that can be vectorized very well you are going to be ~2 to ~12 times slower than you could be with C++ there, all else being equal. (the latest CPUs can do 16 32 bit operations at a time, all that being 99% wasted when you can't use these instructions. I grant auto vectorization 1%)\n\nThere will also be a very more instructions happening any time you \niterate over arrays since you have to do bounds checking.\n\nYou also won't have as much power to customize memory layout to avoid cache misses, and cache misses are the worst thing in the world.\n\nBut yes, ignoring those issues, if you code your java carefully enough and plan how you use memory very well you can be almost as fast a C. But if you are going to very carefully plan how you use memory.....\n\n", "id": "cypqke8"}, {"comment": "System.arrayCopy uses SIMD under the hood.", "id": "cytwyxe"}, {"comment": "Well that is handy for one use case out of a million.\n", "id": "cyu08rj"}], [{"comment": "Java isn't slow: when used correctly.  My observation over the years is that Java sucks at:\n\n* Startup times.  If we're lucky a full stop/start of an application takes less than 2 minutes.  Most applications are upwards of 5.  This can be a big deal for downtime/deployment if debugging an issue requires multiple restarts (should be done in dev but not everybody has best practices for every system or can afford it).\n* Debugging. The amount of time it takes to debug issues with a Java application is usually much longer (in my experience) than say a Python, Perl, PHP, Go, C, C++ application.  Even when you have support (e.g. from Oracle), it still can be a month(s) long process to identify simple problems (like if it's caused by 3rd party code, your code, improper use of 3rd party integrations, etc).  Also, heap/thread dumps can be difficult to process at times because of the size of them.\n\nThose two issues make Java \"slow\".  They can be avoided if you have good programmers and practices.  Other languages come with their own set of issues but these come up time and time again for Java.", "id": "cyplzon"}, {"comment": "why is java debugging slower? i've always found the tooling around to be very nice (intellij + YourKit)", "id": "cypqc4n"}], [{"comment": "keep repeating this ;)", "id": "cyth34e"}], [{"comment": "It **is**.\n\nOn a less trolling note: it's all relative. However, *given fair conditions* C/C++ will always outperform Java. Significantly.", "id": "cyp8x8k"}, {"comment": "> It is\n\nn't.\n\n> However, given fair conditions C/C++ will always outperform Java. Significantly.\n\nWith \"fair conditions\" you mean that C/C++ development should be given enough time that they can produce the same thing as quickly as with Java and given more time for optimizations than the Java counterpart? If development time is ignored, it's not fair conditions. And if development time is indeed considered, it's unlikely that \"C/C++ will always outperform Java significantly\". \n\nUnless of course we pretend that both codes have no time constraints and they are both absolutely flawless and perfect. In this instance C/C++ will definitely always outperform Java. But this is an inhuman scenario and physically impossible. In general application and IRL Java will have similar performance to a comparable C/C++ program.", "id": "cyp9q8q"}, {"comment": "If we assume that both applications use the same amount of memory? Because, as we know, space vs time form a trade-off. Typical java apps use integer multiples more memory than C++ equivalents. So to be fair, we should be caching many more things in C++ and running our hash tables at very low load factors, agree? ", "id": "cypfyt6"}, {"comment": "Java's main trade-off is memory, so a Java application will always use more memory than C++\n\n> So to be fair, we should be caching many more things in C++ and running our hash tables at very low load factors, agree?\n\nMemory is in general a non-issue for programs, execution time is far more important. But in the theoretical scenario where memory use is of critical importance, Java isn't suited for that task.", "id": "cyqerve"}, {"comment": "> With \"fair conditions\" you mean that C/C++ development should be given enough time that they can produce the same thing as quickly as with Java and given more time for optimizations than the Java counterpart?\n\n\"Fair conditions\" means absence of artificial obstacles giving wither of two an advantage, i.e. Adroid gives Java an advantage. And I also assume the scenario where **pure code performance does matter**. Otherwise the the discussion about performance is pointless.\n\nIn such case either of two will have reasonable time to optimize, not the \"you have to ship it yesterday\".\n\nAnd, with experience of working with both, I say that it's a bullshit propaganda, that with C++ it takes significantly more time to develop something. In fact, for large project is around the same if not better on C++ side and in practice project management & co. has bigger impact on development time than language.", "id": "cypbbyp"}, {"comment": "> and in practice project management & co. has bigger impact on development time than language.\n\nain't that the truth.", "id": "cypbodq"}, {"comment": "I don't use java and therefore has little experince in profiling it but I assume your statement is false because the JVM and your C++ code probably works differently. One is optimizing running code and the other is optimizing code at compile time. It might not be possible to do as good optimizations at compile time. The JVM can sometimes allocate memory faster than c++, unless you write something close to a gc yourself.\n\nYou can of course write c++ code that are faster than java for some cases, possibly for a lot of cases but probably not for all cases. \n\nIf you allow almost infinite time to write and optimize the c++ code then you could of course build an optimizing engine that runs your code and optimizes it on the fly, or for some simple applications just run a java version with similar code and then copy the resulting binaries from memory. For simple things it may work and be just as fast but then you're getting close to the \"infinite\" development time which you rarely have in real projects. If you can make an application 200% faster for N hours (months) of work it might be worth it. But if all you can do is make it 20% faster and it will take many man-years it is probably not worth it. \n\nIf your app is fetching a lot of things from memory in a straight address line cpu caches will probably make well written C++ code faster. If the app is fetching small things from all over the memory or small chunks at a time from a network the cpu caches might not be able to help and the java code might be very close or faster than the C++ code. ", "id": "cypb6bp"}, {"comment": "In C++ you can avoid dynamic memory allocation by creating objects on stack or directly as members inside other objects, as well as reduce number of memory allocations by allocating and array of objects in a single allocation or allocating some memory and creating objects inside it. None of this is possible in Java, every object is created dynamically there. In C++ you can also often avoid even creating classes and still have sane code.\n\nAnd, as I said before, the case should be where performance actually matters. If you just write a business application that moves strings around between UI and database, then most of the time is spent outside the code written anyway.", "id": "cypbqef"}, {"comment": "The java compiler does escape analysis on allocations (meaning new Object()), to determine the use pattern for that object.  If it's clear the object will not escape the scope of the function in which it's allocated, then the allocation is done on the stack.   And no, as a programmer, I don't have to think about that optimization. ", "id": "cypk5lk"}, {"comment": "Not only do you not have to think about the optimization, some escape analysis is done by the JIT and the benefits can be retroactively applied to existing, compiled class files as the JVM improves the precision of its analysis.", "id": "cypla1t"}, {"comment": "[deleted]", "id": "cypg29r"}, {"comment": "But we are talking about something which requires effort to do in Java, when in C++ it's common place and the norm.", "id": "cypiar5"}, {"comment": "Yes, c++ have some tricks. But you could fill an array of objects in java also and then use it as a buffer instead of creating new objects. Except for strings (and possibly some other things) which are immutable. I think some really fast java applications uses this method to avoid gc in critical areas. \nThe thing I was trying to say before was that the jvm may optimize some things, including how it allocates memory. It could possibly use the stack for some things without telling the developer this. \n\nAnd I think a lot of applications are more limited by i/o than by cpu and in all those cases you gain very little by going to c/c++ from java.", "id": "cypfwkk"}, {"comment": "> In C++ you can avoid dynamic memory allocation by creating objects on stack or directly as members inside other objects, as well as reduce number of memory allocations by allocating and array of objects in a single allocation or allocating some memory and creating objects inside it.\n\nUnless you spend ridiculous amounts of time, the automated GC in Java will probably do better when it comes to this, since modern processors are extremely complicated to optimize cache line, branch prediction, and memory behaviors.    \n\nUnless you have extremely expensive objects to create, this generally doesn't make sense.", "id": "cypk8nd"}, {"comment": "> Unless you spend ridiculous amounts of time, the automated GC in Java will probably do better when it comes to this..\n\nNot at all. You should reexamine the myths of C++'s difficulty to get a better sense of exactly where C++ has productivity problems before making statements like that. In this case, the C++ code is very natural and shorter than the equivalent Java code:\n\n    // C++\n    Vec3 vec;\n\n    // Java\n    Vec3 vec = new Vec3();\n\nThe allocation is super fast in C++ since it simply bumps the stack pointer up by the size of the Vec3. The Java version can be much more expensive if a naive GC performs a heap allocation, but the typical modern implementation will also be a simple pointer bump in the Generation 0 heap. The Gen 0 pointer might be cold and result in a cache miss, but that is very unlikely. The stack will always be hot. So the speed of allocation for this example should be the same, and the C++ version is no harder (and arguably simpler).\n\nThe bigger problem comes in when you need a collection of objects. In C++ it is very natural to have an effectively packed array of objects, but the natural way to do it in Java is problematic:\n\n    // C++\n    std::vector<Vec3> vertices;\n    vertices.push_back(Vec3(...));\n    vertices.push_back(Vec3(...));\n\n    // or just\n    std::vector<Vec3> vertices{ Vec3(...), Vec3(...) };\n\n    // Java\n    ArrayList<Vec3> vertices= new ArrayList<Vec3>();\n    vertices.add(new Vec3(...));\n    vertices.add(new Vec3(...));\n\nThe problem with the Java version is that the container is an array of pointers to objects, and not a flat array, so every access to an element can result in an expensive cache miss. A JIT might notice this and rearrange them to be closer together in memory, but there is no guarantee of this. It is bad enough that the typical advice for improving performance is to not using ArrayList or a class type at all and instead using parallel arrays of floats in order to approach the same speed C++ gives for little effort. In this common case, it is the Java code that requires the ridiculous amount of time to optimize.", "id": "cys30iz"}, {"comment": "> You should reexamine the myths of C++'s difficulty to get a better sense of exactly where C++ has productivity problems before making statements like that. \n\n9 years of game development here buddy.  Including hand tuned assembly only to recompile 5 years later and realizing the compiler did a better job for the general case.\n\n>The allocation is super fast in C++\n\nGot news for you, for large objects Java would beat out C++ if it's repeat allocations and especially if its destructing that object.  nevermind, you just made my point.   Java hasn't used a naive gc for decades, maybe your confusing perl, ruby, python?\n\n>The problem with the Java version is that the container is an array of pointers to objects, and not a flat array, so every access to an element can result in an expensive cache miss. \n\nThere are tuned collections when you need to be that anal.  And its nothing more than using a different dependency and class.\n\nI'm not saying C++ isn't faster, I'm merely saying that people that make that general statement are delusional.   Ultimately, the codebase most people write, using good algorithms gets you a 100% of what you need.   For the rare folks programming switches and routers that need to brainlessly move packets around C++ makes sense, but the management interface, that should be in Java, because C++ is a nightmare to code in as you delve through template hell and critical application failures with very little to go on.", "id": "cysmrwp"}, {"comment": "> 9 years of game development here buddy.\n\nThen you ought to be able to make a much better case for the areas that C++ is deficient than what you have attempted so far, which to me sound like a managed programmer who has never actually used C++ and is repeating rumors they picked up. You really shouldn't be claiming that efficient use of stack allocation and bulk allocations require spending ridiculous amounts of time to write in C++ when it is the most natural way to do things and you'd be fighting the language at every step to do otherwise. (Then again, when it comes to game programmers and C++, many do seem to fight the language at every step as if the harder and buggier way to write it is magically faster; no argument needed.)\n\n> Got news for you, for large objects Java would beat out C++ if it's repeat allocations and especially if its destructing that object. \n\nPotentially yes, depending on the allocator and other factors, though you are now moving the goal posts away from stack and bulk allocations, which was the context of the quoted portion in your prior post. Though destructing an object won't have any additional overhead (in theory) over a `Closable` Java object except for any memory deallocation in the destructor (and again, it depends on the allocator). Both still need to close file handles or unlock their mutex or whatever other cleanup is needed for whatever resource they might be managing.\n\n> Java hasn't used a naive gc for decades, maybe your confusing perl, ruby, python?\n\nOdd that you think I'm confused when I very clearly explained how a modern GC would handle the allocation (a simple pointer bump in Gen 0). Perhaps you are confused and should re-read what I wrote?\n\n> There are tuned collections when you need to be that anal. And its nothing more than using a different dependency and class.\n\nIf you think just changing `ArrayList<Vec3>` to something else will solve the problem I presented, what specifically do you suggest using instead? I already mentioned the commonly suggested one: three arrays of floats. The only thing that could easily retain the abstraction and approach C++'s performance would be user created value types (ideally a better version of C#'s `struct`), which I hope will finally make it in the next version of Java.\n\nIf you mean tuning the GC, I though your point was \"Unless you spend ridiculous amounts of time, the automated GC in Java will probably do better when it comes to this.\" Now it sounds like you want to spend ridiculous amounts of time tweaking arcane details of your implementation's GC just to approach the locality of reference C++ gives very naturally?\n", "id": "cysojc3"}, {"comment": "> Then you ought to be able to make a much better case for the areas that C++ is deficient than what you have attempted so far\n\nFirst of all, I never made the statement that \"C++ is deficient\", give me the right project and I'll use it again.   Those are your words.   The point I have made numerous times in this thread is that Java is a much better choice than the majority of use cases, even though people chest thump performance like C++ will magically be faster regardless of the use case or the level of effort on optimization.\n\nSecond of all, I really don't give a shit whether you believe me.   It just makes you seem all the more like an idiot when it comes to social interactions despite what you know about the JVM or C++.\n\n>Then again, when it comes to game programmers and C++, many do seem to fight the language at every step as if the harder and buggier way to write it is magically faster;\n\nYes, and I'm sure all the sales associated with some of the books or their titles authored by more notable game programmers shows how much they don't know.\n\nSorry getting the performance out of low end hardware and pushing the simulation envelope on modern hardware are actual cases where optimization makes sense and the game programmers that I've worked with knew that.\n\n>depending on the allocator and other factors, though you are now moving the goal posts away from stack and bulk allocations,\n\nYou're setting goal posts, I was pointing out the exceptions to the general arguments that people are making.\n\n>Though destructing an object won't have any additional overhead (in theory) over a Closable Java object except for any memory deallocation in the destructor (and again, it depends on the allocator). Both still need to close file handles or unlock their mutex or whatever other cleanup is needed for whatever resource they might be managing.\n\nSpeaking of changing the *goal posts*, sure we could talk about how the 1% (I'm being generous here) use case will probably perform at an equivalent speed, but you're ignoring the fact that the 99% use case is a simple null assignment/xor with itself vs. a system call \"unless you do something funny with the allocator\", which we all know is a lot of fun to mess with and everybody is just yearning to do it.\n\nAre you moving the goal posts?\n\n> Perhaps you are confused and should re-read what I wrote?\n\nNo, I very clearly see you tried to apply naive gc behavior for the JVM which is clearly not the case in any of the popular JVM releases.   So pointing out that naive GCs are slow, and then explaining how the JVM's GC's are more sophisticated in an attempt to stop my response is going to work.\n\n>If you think just changing ArrayList<Vec3> to something else will solve the problem I presented, what specifically do you suggest using instead? I already mentioned the commonly suggested one: three arrays of floats. The only thing that could easily retain the abstraction and approach C++'s performance would be user created value types (ideally a better version of C#'s struct), which \n\nIf you're truly going for performance a Vec3 is pointless, you want to lay out your coordinates linearly by the same dimension in order to leverage the behavior of applying transofmrations with SIMD style instructions.   So you would have to create custom data structures in both languages.\n\n>I hope will finally make it in the next version of Java.\n\nI do to, but Java's doing pretty well on performance as it is, so they haven't had the need to rush.   Memory overhead in the general case would be the biggest benefit so you don't have to make custom structures.\n\n>Now it sounds like you want to spend ridiculous amounts of time tweaking arcane details of your implementation's GC just to approach the locality of reference C++ gives very naturally?\n\nI just pionted out how your general statement is inefficient for 3d point transformations.   \n\nJust to repeat my point, Java is the better decision because it's easier to create large applications in instead of C++ for the general case.  So all those people arguing for \"speed of C++\" over Java, as if it's a closed discussion are clueless.   When you do need the power to do explicit pointer arithmitic in some locally optimized fashion, you could always drop to JNI.   Otherwise I'd rather have:\n\n* No template hell\n\n* Clear stack traces\n\n* no dealing with MAP files\n\n* a much richer standard library\n\n* better portability\n\n* easier static analysis and unit testing software\n\n* faster compile times\n\n* rich open source libraries\n\n* no preprocessor bullshit\n\n* no mapping issues\n\n* no core dumps\n\n* no smart pointer hell", "id": "cyti2w0"}, {"comment": "You really need to calm down and reconsider the point I was making.\n\n> First of all, I never made the statement that \"C++ is deficient\"\n\nSigh, reread what I wrote, I said that C++ has _areas_ where it is deficient, but that the area you brought up was not one of them.\n\n> Second of all, I really don't give a shit whether you believe me. It just makes you seem all the more like an idiot when it comes to social interactions despite what you know about the JVM or C++.\n\nI'm more of a trust, but verify guy. I figure you must have not done much C++ since around the 98 standard, or only for communities that aren't big on doing things the idiomatic way (like game programmers seem to be in my experience).\n\n> You're setting goal posts\n\nThe post you quoted set the goal posts: \"In C++ you can avoid dynamic memory allocation by creating objects on stack or directly as members inside other objects, as well as reduce number of memory allocations by allocating and array of objects in a single allocation or allocating some memory and creating objects inside it.\" My first post was responding in this context.\n\n> sure we could talk about how the 1% (I'm being generous here) use case will probably perform at an equivalent speed\n\nYou brought up destructors and I compared those against the Java equivalent, Closables. In theory, the exact same resource clean up (like closing a file) will have the same speed in both C++ and Java. In practice, of course they will be different, but it is hard to say without measuring which will have the edge (it mostly comes down to quality of implementation). There is no fundamental performance problem with destructors in this scenario (unless you are leaving your file cleanup to the GC, in which case, please don't!). The only performance difference between destructors and closables is that destructors also clean up memory where Java leaves that to the GC. This is a case where a C++ dev would have to do extra work if the memory deallocation is too time consuming. Which is all to say, picking on destructors was a bad move, you should have been focusing on the performance loss due to memory deallocation.\n\n> No, I very clearly see you tried to apply naive gc behavior for the JVM which is clearly not the case in any of the popular JVM releases.\n\nLOL. You are trying too hard to find something to disagree with. I was very clearly pointing a common misconception of how a GC allocates to point out how a modern GC would actually allocate. Many people falsely claim that a stack allocation in C++ is faster than a heap allocation in Java because they assume `new` in Java works like `new` in C++. It is you that is fixated on the naive allocation strategy.\n\n> I just pionted out how your general statement is inefficient for 3d point transformations.\n\nErr, that was _MY_ point. We seem to be in agreement here. Your solution echos mine.\n\n> Just to repeat my point, Java is the better decision because it's easier to create large applications in instead of C++ for the general case.\n\nI wouldn't say it is the better decision in all cases, but I also never said that C++ is the better decision in all cases. I merely set out to correct your misplaced exaggeration about how difficult stack and bulk allocations are in C++.\n\n> Otherwise I'd rather have:\n> No template hell\n\nI find this claim tends to be exaggerated, but there is truth to this; they can get out of control if you let them.\n\n> Clear stack traces\n\nYeah, I love this\n\n> no dealing with MAP files\n\nImplementation specific, not a C++ thing.\n\n> a much richer standard library\n\nYup, this is a huge productivity gain for Java. I've been encouraged by the call for expanding the standard library, and then immediately discouraged by the horde of C++ devs that claim adding new things to the library will bloat the language.\n\n> better portability\n\nDebatable. You have a better chance of writing a program in Java that needs zero source level changes, but C++ compilers exist for more platforms, including platforms you wouldn't want to run a full blown JVM on.\n\n> easier static analysis and unit testing software\n\nNot sure I agree, They seemed about as easy in both languages these days. If you include refactoring tools and similar features enabled by semantic analysis, then Java gets a big win here.\n\n> faster compile times\n\nIn general yes, but tell that to my last Android project. Ugh! (I hope this has improved over the last few years.)\n\n> rich open source libraries\n\nBoth have rich open source libraries\n\n> no preprocessor bullshit\n\nYes, C++ devs strongly encourage avoiding the preprocessor unless it is the only solution, and the standards committee has been making it easier to avoid it with every new standard.\n\n> no mapping issues\n\nNot sure what you mean here\n\n> no core dumps\n\nAny process can core dump, have you never had to debug a Java core dump before? Lucky!\n\n> no smart pointer hell\n\nTraded for GC root hell. But overreliance on shared_ptr by less experienced devs is a problem. unique_ptr is better, but usually the best thing is to not heap allocate objects at all and let them behave like a value type.\n\nBy the way, I noticed your list didn't have \"Easier stack and bulk allocations\" in it. ", "id": "cyu597b"}, {"comment": "I apologize if I was over reacting or misunderstanding.\n\n> Debatable. You have a better chance of writing a program in Java that needs zero source level changes, but C++ compilers exist for more platforms, including platforms you wouldn't want to run a full blown JVM on.\n\nIt maybe that you can cross compile, but endian-ness, initialization have better behavior in Java.   Also, the standard library in Java does a more sophisticated job of abstracting things like fork/join, etc....\n\n>They seemed about as easy in both languages these days. If you include refactoring tools and similar features enabled by semantic analysis, then Java gets a big win here.\n\nI would suggest that the build tools, continuous integration servers and the unit testing frameworks with their native test grouping functionality, their external data set (for input or output) support are well beyond the CPPUnit or CXXUnit equivelents.\n\n>Both have rich open source libraries\n\nYes, but one clearly has the advantage over the other http://githut.info/ ", "id": "cyu8ir1"}, {"comment": "Back in the early 2000s MIT created a project called [DynamoRIO](https://en.wikipedia.org/wiki/DynamoRIO) for operating on running native code. One of the things it could do was dynamic optimization -- basically a JIT compiler for already-native executables.  A native program running under DynamoRIO's control could be automatically instrumented, profiled, and *rewritten* in-memory to optimize the existing object code on the fly.  In their papers they claimed a native executable could end up running 12% faster on average, with some programs becoming up to 40% faster.\n\nI don't know if it still gets those kinds of results with current CPUs and compilers, but they're still doing conference presentations so apparently the project is still active to some degree.", "id": "cyqf0sd"}, {"comment": "But it would never be fair because for C/C++ to outperform Java the code base has to be almost all C.  And not easily readible C.  The nasty obscure pointer heavy C that puts hairs on the hairs of your chest and sends you to an early grave.\n\nSo the scenario you describe is not C/C++ vs Java... it's really \"Nasty C\" vs Java. There is a reason we switched to Java.\n", "id": "cypbiu7"}, {"comment": "Not really. You can write clean C++ that will significantly outperform Java. Laying out your data correctly, and favoring stack allocated versus heap allocated where possible can easily be done in C++. In fact boost has containers that are stack allocated up to a certain point before switching to heap allocation. When you know that the majority of your data are below a certain size, but you still have a tail that is above that, it can be very helpful. The standard library algorithms do not care if they refer to heap or stack memory. std::string has the small string optimization which avoids heap allocation for strings up to 20 characters on 64 bit platforms. std::function can store simple functors inline without requiring the heap. The whole point of C++ is building abstractions without losing performance and for the most part it succeeds.", "id": "cypfi0m"}, {"comment": "And if you *really* pull out all the stops, assembly hand-written by God Himself will outperform everything. ", "id": "cypika3"}, {"comment": "Perhaps on a Z80.\n\nI'd guess that there are no humans that reasonably can do all the optimizations necessary to properly utilize the insane complexity that is a modern processor.", "id": "cypk7uu"}, {"comment": "Is God Himself a human?", "id": "cyps271"}, {"comment": "> There is a reason we switched to Java.\n\nNope. Only those unable to write clean C code did :P\n\nAnd those, who don't need performance that much and need cheaper developers delivering something that still does the job most of the time.", "id": "cypbu1s"}, {"comment": "You forgot a few - and those who wanted a well defined ecosystem of platform provided capabilities such as garbage collection, threading, etc. and those who don't want to worry about having different builds for different operating systems.\n\nI started out in Assembly & C, some Pascal, moved to C++ when it was a pre-processor that generated C code, moved into Java when I needed an alternative to maintaining multiple builds for different platforms for basic data entry/read type applications.\n\nI won't use Java for systems programming and I won't use C for enterprise applications or web services (I did the fastcgi with C years ago).  \n\n>who don't need performance\n\nYou need to define context here.  My enterprise applications perform quite well, meet all required SLAs, thru put demands and concurrency load requirements.  I also hack around in OpenGL 3D coding (both in C++ and in Java via lwjgl3 which yes delegates the calls to native libraries, but does so seamlessly for me) and have code managing thousand's of entities and models rendering at framerates in excess of 300FPS with physics updates of 50 ticks per second.  \n\nIf, however, I was developing code for a network router device that was expected to handle request in the millions I would likely use something that compiled to hardware specific binaries.\n\nI'm not arguing with your statements, just pointing out that all discussions on \"performance\" are meaningless without context.  \n\nIf I have a data processing requirement that only needs to handle 100 records per second, I could do that (and more) with bash/awk scripts.  \n\nIf I needed to process 10000 records per second, I could use Java or Python or Perl or C or C++ or Smalltalk or Business Basic.\n\nIf I needed to handle millions per second, I likely want something that compiles native so Assembly, C or C++ or Haskel.", "id": "cypdxcp"}, {"comment": "[LMAX 6 Mio per sec](http://martinfowler.com/articles/lmax.html)", "id": "cypnqhd"}, {"comment": "Thanks for the link, interesting article.", "id": "cyqk337"}, {"comment": "> And those, who don't need performance that much and need cheaper developers delivering something that still does the job most of the time.\n\nWhen Sun presented Java @Bell Labs in 1996, my initial response was that it was a language created by MBAs in order to make it easier to outsource software development.  Nothing in the last 20 years has changed my mind on this!", "id": "cypldys"}, {"comment": "Less *ProxyFactorySingletonManagerFactory* patterns, more fast.\n\nEDIT meaning: excessive over-abstracted heaps of bloated crap which has nothing to do with the problem at hand but rather the intricacies of the type-checker make your code suck. You get patterns which are solely to manage your object-churn which you can't control because the information to make it more efficient is at the wrong level of abstraction so you have to resort to crappy caches instead, increasing accidental complexity.\n\nAlso, I probably should have made it clearer because I did not mean this thing SPECIFICALLY but used it as a place-holder for the common theme here. That it is recognized as something which should exist proves my point. :-P", "id": "cyp99wx"}, {"comment": "Factory pattern does not impact performance, and Singleton positively affects performance.\nProxy however can negatively impact performance (although I'm not certain with the new `InvokeDynamic` call)\n\nIt taking a longer time for you to read doesn't mean that it's slower.", "id": "cyp9ju2"}, {"comment": "> Factory pattern does not impact performance\n\nIt does, if used for no reason at all. Just creating an object is faster than calling something that creates it. Has nothing to do with language or technology though, you can just as well to overengineer anywhere, just that in Java it seems to happen more often than elsewhere.", "id": "cypbfs7"}, {"comment": "If it's a caching factory for particularly heavy objects it can be a performance win.", "id": "cypceio"}, {"comment": "In such case it's used for a reason. I believe the comment about ProxyFactorySingletonManagerFactory was about overuse of patterns for no real reason.", "id": "cypcqnz"}, {"comment": "> It does, if used for no reason at all.\n\nAssuming that the factory pattern is justifiable in a situation means that there would also be an indirection cost in any other language. \n\nAssuming a similar method of abstraction in C :\n\n    typedef int (*getNumberPtr)();\n\n    getNumberPtr createFunction() \n    {\n        return &mockFunction;\n    }\n\n    int mockFunction()\n    {\n        return 42;\n    }\n\n    int testFunctionPointer() \n    {\n        getNumberPtr ptr = createFunction();\n\n        return (ptr)(); \n    }\n\n    void Main()\n    {\n        int test = testFunctionPointer();\n        printf(\"Value from factory : %d\\n\", test);\n    }\n\nIn this call here, we first need to call a method (the factory) to produce a function which will yield the correct result, depending on some external criteria (configuration for instance, or some input parameter). The major difference between these two patterns is that only one gets constantly blamed for being unnecessary and over-engineered.\n\nIf we say that it's used for no reason at all, it's an argument against people making dumb choices, and is completely irrelevant to Java (or object-orientation in general), because the same concept exists in all programming languages. Whether or not people call it \"over-engineering\" depends on subject.", "id": "cyqg8b2"}, {"comment": "The main point in my comment was:\n\n> in Java it seems to happen more often than elsewhere\n\nat least up to this point of my career Java code I've worked with was much more overengineered compared to C++ and C# code. Not by accident, people attitude was the reason. In particular, many Java guys seemed to believe that building those monstrosities was the right thing to do.", "id": "cyqk4od"}, {"comment": "Rather: Just that in Java its called what it is: overengineering. In other languages its called clever code or beautiful design and architecture. Like C++ template messes or JS callbackhell or Haskell monads.", "id": "cypcl79"}, {"comment": "> Less ProxyFactorySingletonManagerFactory\n\nah, the java equivalent of the godwin point.", "id": "cypexe4"}], [{"comment": "if you're taking quaaludes...  /sarcasm", "id": "cypg5aj"}], [{"comment": "Ok, let me do a quick test. A single line Hello World (Everything default, in a desktop, no special configuration):\n\n-------\n\ntime java HelloWorld \nHello World!\n\nreal\t0m0.064s\nuser\t0m0.052s\nsys\t0m0.012s\n\n-------\n\ntime perl a.pl\nHello World!\n\nreal\t0m0.002s\nuser\t0m0.000s\nsys\t0m0.001s\n", "id": "cyph1db"}, {"comment": ">  A single line Hello World\n\nYou must also believe bubble-sort is the fastest thing around, because it was the best at two-item arrays.\n\n", "id": "cypieyz"}, {"comment": "Perl is like infinitely slower than bash since 0.002 / 0.000  == infinity.\n\ntime echo \"hello world\"\nhello world\n\nreal\t0m0.000s\nuser\t0m0.000s\nsys\t0m0.000s\n\n", "id": "cypkd5n"}, {"comment": "> Ok, let me do a quick test. A single line Hello World (Everything default, in a desktop, no special configuration):\n> time java HelloWorld Hello World!\n> real 0m0.064s user 0m0.052s sys 0m0.012s\n> time perl a.pl Hello World!\n> real 0m0.002s user 0m0.000s sys 0m0.001s\n\nYou have no idea how incompetent you look making this point.\n\n*edit* or misunderstood you must be...", "id": "cypknib"}]]], "45ic56": ["We\u2019re in a brave, new post open source world", "2016-02-13 05:47:05", 1, "https://medium.com/@nayafia/we-re-in-a-brave-new-post-open-source-world-56ef46d152a3", [[8, "Meh. I don't really buy the premise."], [6, "Too long. Click bait title. I skimmed the article, and still don't really know what her main point was."], [1, "Horse shit written by a star eyed idiot. You didn't change anything. God DAMN I fucking hate \"startup culture\""]], [[{"comment": "Meh. I don't really buy the premise.", "id": "czy6me9"}, {"comment": "\u201eIf you jump to conclusions you will get half of it off!\u201c", "id": "czzkysi"}], [{"comment": "Too long. Click bait title. I skimmed the article, and still don't really know what her main point was.", "id": "czy87w4"}, {"comment": "Main Point: Nowdays, The word _Software_ is by default _Open Source_.\n\nShe exposes the history behind this phenomena, and what she think is the future of _Open Source_.\n\nIt is a kind of dump of all she had compiled about the Theme.", "id": "czyoccp"}, {"comment": "> It is a kind of dump of all she had compiled about the Theme.\n\nThere's the problem, then - the click bait title implies something more pointed.", "id": "czz2z1o"}, {"comment": "Whatcha mean nowdays? In the begining Software was by default Open Source then there was this relatively brief period where it was neather proprietary nor open source by default (but lot of it was proprietary) and now it has returned to the earlier state of affairs.", "id": "czzky6q"}, {"comment": "You just resumed the article.", "id": "d006t15"}], [{"comment": "Horse shit written by a star eyed idiot. You didn't change anything. God DAMN I fucking hate \"startup culture\"", "id": "czyrbgv"}]]], "59olsh": ["Stalking people online for thought crimes! This is what the Go project has succumbed to!", "2016-10-27 19:32:02", 0, "https://groups.google.com/forum/m/#!topic/golang-dev/pOvceAZwLHY", [[15, "I have no part in Go, so from a complete outsider it looks like this:\n\n * The project called Iris has a bunch of stolen code.\n * Project was called out.\n * The resulting battle between two people, where both sides have above-basic English language skills, was called out.\n * That calling out was called out.\n * Then that was called out by the commenter.\n * The other parts of the community are calling out that call out and the original callout.\n\nWith all of the calling out and recursion, does this mean that the Go community is potentially Turing complete?\n\nIt also seems that the warning system in place is very short fused where any infraction causes a warning, no matter how minor it may be. A system such as this will quickly turn a community into a hostile and toxic environment, and may attract toxic entities who enter for fun and games. Also, anyone who is offended must be able to explain their offense. If someone is offended by someone else and cannot explain it, there should be no offense (otherwise you end up hating others for no reason at all).\n"], [13, "Wow! This makes PHP mailing list drama look meh in comparison.\nNext time I'll grab popcorn and read Go mailing list instead.\n\nKeep em coming CoC!"], [11, "This Sarah Adams wrote software that literally [assumes people's gender](https://github.com/adams-sarah/go-gender-stats).\n\nI suggest reporting her for transmisogyny."], [10, "This Code of Conduct crap is a pile of bullshit. If I ever get a \"Please consider this a warning\" from one of them wannabes I'll tell them to \"go fuck yourself\". "], [9, "Funny thing is, if the comment had been:\n\n> Their style is so convoluted I couldn't understand what was going on. So, what is going on? Why should I care?\n\nnobody would have batted an eyelid over it. \"But my writing style is part of my identity!\" would not be an effective defense."], [3, "This seems incredibly overblown.\n\nFirstly, the original comment was pretty ambiguous about who it was targeted at. I can see how it might have been misinterpreted as unnecessarily antagonistic. \n\nSecondly, this hyperbolic rant seems somewhat disproportional given that nothing was (or can be) actually enforced re: anyone's ability to comment. If the original comment had been removed, that would be an entirely different matter, but simply being asked to avoid exclusionary phrasing is not really a big deal. \n\nHonestly, this guy just come across like an asshole here."], [1, "This seems like public airing of personal spite, and hence more appropriate either on another subreddit, or somewhere else altogether"], [-4, "nobody cares about you trying to stir up drama"]], [[{"comment": "I have no part in Go, so from a complete outsider it looks like this:\n\n * The project called Iris has a bunch of stolen code.\n * Project was called out.\n * The resulting battle between two people, where both sides have above-basic English language skills, was called out.\n * That calling out was called out.\n * Then that was called out by the commenter.\n * The other parts of the community are calling out that call out and the original callout.\n\nWith all of the calling out and recursion, does this mean that the Go community is potentially Turing complete?\n\nIt also seems that the warning system in place is very short fused where any infraction causes a warning, no matter how minor it may be. A system such as this will quickly turn a community into a hostile and toxic environment, and may attract toxic entities who enter for fun and games. Also, anyone who is offended must be able to explain their offense. If someone is offended by someone else and cannot explain it, there should be no offense (otherwise you end up hating others for no reason at all).\n", "id": "d9a6yb7"}, {"comment": "You made me laugh. Here, have a cookie.", "id": "d9ajzep"}, {"comment": "Thanks for the gold!", "id": "d9akjx3"}, {"comment": "It's my pleasure.", "id": "d9aq5b0"}], [{"comment": "Wow! This makes PHP mailing list drama look meh in comparison.\nNext time I'll grab popcorn and read Go mailing list instead.\n\nKeep em coming CoC!", "id": "d9a56t0"}], [{"comment": "This Sarah Adams wrote software that literally [assumes people's gender](https://github.com/adams-sarah/go-gender-stats).\n\nI suggest reporting her for transmisogyny.", "id": "d9a80os"}], [{"comment": "This Code of Conduct crap is a pile of bullshit. If I ever get a \"Please consider this a warning\" from one of them wannabes I'll tell them to \"go fuck yourself\". ", "id": "d9a390x"}], [{"comment": "Funny thing is, if the comment had been:\n\n> Their style is so convoluted I couldn't understand what was going on. So, what is going on? Why should I care?\n\nnobody would have batted an eyelid over it. \"But my writing style is part of my identity!\" would not be an effective defense.", "id": "d9a67qn"}], [{"comment": "This seems incredibly overblown.\n\nFirstly, the original comment was pretty ambiguous about who it was targeted at. I can see how it might have been misinterpreted as unnecessarily antagonistic. \n\nSecondly, this hyperbolic rant seems somewhat disproportional given that nothing was (or can be) actually enforced re: anyone's ability to comment. If the original comment had been removed, that would be an entirely different matter, but simply being asked to avoid exclusionary phrasing is not really a big deal. \n\nHonestly, this guy just come across like an asshole here.", "id": "d9a3dvr"}, {"comment": "Exclusionary phrasing, really ? I don't think we read the same comment ", "id": "d9alnra"}, {"comment": "I wasn't stating that the original comment was exclusionary (I actually think it was a pretty objective observation), just that the response from the Golang Code of Conduct group was asking him to avoid exclusionary phrasing which seems reasonable in isolation. ", "id": "d9bnnuc"}], [{"comment": "This seems like public airing of personal spite, and hence more appropriate either on another subreddit, or somewhere else altogether", "id": "d9hfgy5"}], [{"comment": "nobody cares about you trying to stir up drama", "id": "d9a3bjj"}]]], "4fthid": ["Bootstrap 4 Cheat Sheet", "2016-04-21 19:29:39", 3, "http://hackerthemes.com/bootstrap-cheatsheet#dropdown", [[1, "I'm going to miss the 3.0 aesthetic"]], [[{"comment": "I'm going to miss the 3.0 aesthetic", "id": "d2c83ue"}]]], "42dxr7": ["CoC zealots are making Ruby their next front.", "2016-01-24 04:49:08", 164, "https://redmine.ruby-lang.org/issues/12004", [[154, "Can't wait for the community kangaroo courts without due process, just like they set up in Academia!\n\nHooray for politicization, witch-hunts, and endless abuse at the hands of the perpetually offended!"], [133, "[\"ph ph\" seems to be the voice of reason:](https://redmine.ruby-lang.org/issues/12004#note-311)\n> We will only ever have harmony if we concentrate on the technical nature of a \ntechnical community. Bring politic in and you are bound to have political issues."], [121, "[deleted]"], [82, "The Obvious Code of Conduct:\n\n1) Contribute good code.\n2) Don't be mean.\n\nNote which comes first."], [77, "In some respects, a CoC sounds great on paper. 'Be nice! No doxxing! Treat people with respect!' The problem is, it was conceived by people who can't stop getting their fucking feelings hurt. It's fine to try to be nice, and I think most people do... but for fucks sake, why do we need to bring political correctness into a realm where people are trying to get shit done?\n\nIf Donald Trump himself submitted a useful PR, I'd rather have that merged with the project than find a childish, moral/political reason why he shouldn't be allowed to contribute. It's just sad, really. Focus on writing good code and being useful rather than looking for reasons to get butthurt."], [81, "Well it looks like Matz shot them down on their insane coc. He has proposed another one which is much simpler less prone to being abused but if history is any indication Coraline will find a way to abuse it and twitter lynch somebody or another.\n\nShe has already taken some of these comments out of context and put them on twitter to try and rally her SJW lynch mob."], [57, "I guess every project undergoes those useless proposals. But the proposed form was already rejected by matz, so this variant won't go in.\n\nWhat I wonder is why some people invest so much energy into something as useless as this. What happened to good old programming? The evolution of ideas?\n\nWhat is wrong with these people?"], [56, "[deleted]"], [53, "I sincerely hope that the majority of the open source community rejects this nonsense (and looking at this thread it seems so). This is software - let's talk technical, not politics."], [48, "[deleted]"], [43, "Here I was, interest piqued by the idea that zealots of the Calculus of Constructions (a proof theory) were going to tackle verifying some part of Ruby. Imagine my disappointment when CoC here actually stands for Code of Conduct."], [29, "Great, I'll be pointing to this thread every time some scumbag suggests that \"SJWs are boogeymen and do not exist\"."], [34, "As much as one would like to support and sustain behaviors that promote the general welfare,  the word 'covenant' that the linked page uses is very troublesome.  In American law,  a covenant is a (the only?)  kind of agreement that can be enforced without adequate consideration.  If I give you something and you give me nothing, we have no contract, and my act of unilaterally giving something  to you usually brings no additional obligation for me,  beyond the normal obligations of not knowingly giving you poisoned food or a ticking bomb, etc.  However,  if I unilaterally give you a covenant and you give me in exchange nothing of value,  you might still sue me for not complying with the 'covenant'.  Even third parties might have rights to sue me.  Change the word at least."], [29, "I dislike a lot of the comments here, but I think adopting a code of conduct is almost always useless.\n\nLaws are only useful when you have judicial review and legal precedence. Without it, the ambiguities inherent in writing are going to collapse. Look at how heavily the US relies on precedent. Now look at how explicit US laws are compared to the contributor's covenant. Combine that with the fact that there is a subset of people who are too sensitive about things and you have a bit of a recipe for disaster. \n\nThe original poster of that issue is talking a lot on Twitter about supposed bad actors in the Ruby community, but she's not bringing up any concrete examples. I mean, I'd love to hear it if Matz called somebody a homophobic slur or something, but the total lack of any displayed examples suggests to me that there aren't any."], [26, "[Diff](https://gist.github.com/olivierlacan/84bd12d0ac13dfdd85d2/revisions?diff=split) of Matz\u2019s proposed edit of the Contributor Covenant CoC."], [23, "[deleted]"], [22, "Oh good, CoralineAda is back at it again again. It's been at least a few months since the last time she and her twitter mob attempted to extort a successful open source project into accepting this CoC.  \n\nIt looks like the patreon link on her site is a little more subtle this time. Classy."], [19, "This is a great train wreak. I cannot imagine why a 20+ year old community would suddenly \"need\" a CoC, as if the community was dying on the vine for it due to constant harassment, etc."], [16, "I don't need a CoC in order to not be a dick. Fuck off."], [15, "[deleted]"], [13, "I'd like all SJWs to get the fuck out of one of the few communities where a persons argument will be judged on technical merit alone rather some bullshit notions of \"equality\", \"fairness\", and whatever the hell is contained in that coc. \n\nDon't show up at my fucking doorstep and shove your ideology down my throat."], [12, ">TL;DR\n>gender is wrong. She means to use \"Sex\"\n>gender identity is what a person identifies as in life.\n\nThe fact that this discussion exists in an issue tracker for software bugs is emblematic of my problem with Codes of Conduct #offtopic\n"], [11, "I first read \"CoC\" as Calculus of Constructions. I was very disappointed."], [9, "A reason to use non-trendy languages like C, C++ and Fortran?\n\nSeriously, though, what a bikeshedding waste of time. If you've got enough spare time to worry about code of conduct stuff in a programming language, you're not programming enough."], [10, "I've been thinking about this a lot lately.  Whenever this comes up the discussion goes to shit, because one side assumes that the only valid reason to want a CoC is a political power grab and the other side assumes the only reason to oppose it is to be an asshole without consequences.  Neither of these are accurate positions, and they just stifle discussion.\n\nContributor Covenant is in a precarious position, with its creator both actively pushing it on OSS projects and having tried to have contributors removed for off-project behavior in the past.  I think it's scorched earth at this point.   But that doesn't mean that there's no valid reason to adopt a CoC.\n\nSo I started thinking about valid reasons.  The most often stated reason is that it will bring in contributions from marginalized people who were unwilling to contribute before without some guarantee of protection.  This is a bit suspect.  For one, these contributors and the potential value of their contributions are entirely hypothetical.  Second, why would anyone want contributors who will only participate if they are guaranteed the ability to initiate bans of other contributors arbitrarily?\n\nAll communities will have disagreements, and handling these disagreements is important to keeping the project running smoothly.  I'm not sure that open source projects really have mature and useful conflict resolution procedures.  What I've learned about interpersonal conflicts throughout my career is that usually one side is not completely in the right and some mediation is required.   Good mediation usually leads to a solution that neither party likes, but both can accept.   This is a far cry from some of these proposed CoCs which tend to set up procedures for banning people from the project.\n\nI don't think there are any legal reasons for an OSS project to adopt a CoC?  But there may be reasons still.  In a conflict it would be nice for both parties to be able to have their rights explicitly enumerated.  Ad hoc discipline tends to suck or be unfairly practiced.  Although a mature project could certainly go for decades without a formal discipline or conflict resolution procedure and be just fine.\n\nThe last point I think is interesting is that many of the CoCs require that the project police non-project spaces.  Which seems like madness to me.  For instance, why is it the Ruby project's job to police Twitter?  People rightly point out that harassers can and do use multiple avenues of approach, but Twitter is responsible for things that happen on Twitter.   Matz pointed out in the Ruby thread as well... banned users dedicated to harassing can just make new accounts and continue harassing.  On any service, project-sponsored or not.\n\nSo I think a useful code of conduct would specify acceptable behavior in project spaces, which amounts to professionalism, and possibly setup a formal process for mediation.  Mediation could lead to bans, but only in extreme cases.   It is a bit harder with OSS because there is no notion of hiring and firing like there is in real companies.   All of this could be ad hoc and work perfectly well, but some projects may wish to specify more formal procedures to ensure that disputes are handled fairly."], [9, "\nRemember, people, this is what this is all about (issue created by the author of CoC:\n\nhttps://github.com/opal/opal/issues/941\n\nLook at all the mayhem from a couple of posts. Very economical.\n"], [6, "Anything short of absolute and full anonymization will never get rid of these discrimination issues or convince SJWs (or anybody affected) that discrimination is not happening. Similarly, subconcious influencing of decisions (i.e. people that do not want to discriminate, but really aren't sure whether they're biased) cannot really be solved through any other way either. The internet is one of the rare places where you can actually anonymize yourself completely to other users and avoid these issues that way, so why not do it?\n\nJust generate a random string of letters/words and use it as your account name. And everybody should do that. Problem solved, peace of mind for all involved.\n\nYour name/gender/personality/nationality or anything else that could serve as a meaningful base for discrimination\\* has no business being brought up in a technical project anyway.\n\n\\* Except intendation style, but that's what `indent` is for."], [5, "I won't stop reading and enjoying Ender's books just because Orson Scott Card made some harsh statements about... can't really remember (I think he's a mormon and said something really awful about gay marriage or the like). You can see how much I care about Scott Card's opinions, btw. Like... zero. Nada. ;)\n\nNow I know the guy is a bigot and I will take that into account, and I give horse shit about what he thinks. But boyccoting the premiere of the movie based on the first book of the series (as it happened) seemed void to me. Even when it raised attention, which I suppose was the intention.\n\nJust... I don't know. My two cents."], [4, "First I've heard of this CoC thing. Ever read a mailing list?? The Linux kernel is not CoC compliant."], [5, "??? The mods must be asleep lol"], [4, "From the vote battle happening on this post and the discussion thread I think anyone who wants to pretend the community is largely in consensus on this topic (except for a few bad actors), is completely uncoupled from reality."], [3, "https://www.youtube.com/watch?v=MpPvGlrqhdA"], [1, "Can't someone just make their avatar icon into a female persona and tell this person, \"No\"?\n\nYes, taking a female person would be necessary to even begin down this road."], [1, "this will make Ruby illegal in Muslim countries and in Russia."], [1, "People are missing the meta-point to all this - you're not creating an environment of happiness, you're creating an environment of FEAR."], [1, "I wonder what these SJWs would make of the old joke \"Ruby is Perl's younger, and prettier, sister\". "]], [[{"comment": "Can't wait for the community kangaroo courts without due process, just like they set up in Academia!\n\nHooray for politicization, witch-hunts, and endless abuse at the hands of the perpetually offended!", "id": "cz9pjwg"}, {"comment": "\"endless abuse at the hands of the perpetually offended!\"\n\nI know anyone who has been following these SJW attacks on open source projects doesn't need me explaining this but for anyone who hasn't been and thinks this is just some overly sensitive people who if we just make them happy and 'safe' they will shut the fuck up and let the smart and competent people get back to creating amazing software.\n\nThese are PROFESSIONAL VICTIMS.\n\nTheir entire lives are spent online doing absolutely nothing productive having wasted their education on women's studies degrees or something similar.\n\nTheir complete self and online worth in the eyes of other SJWs is entirely defined by the level of victimhood and claimed or outright fabricated harassment.\n\n", "id": "cz9s10s"}, {"comment": "> if we just make them happy\n\n\"Don't negotiate with terrorists.\"", "id": "cza6m7u"}, {"comment": "The proposal was already rejected by matz so that ends it.\n\nHowever had he also said that he is not against a code of conduct per se, just not this variant.", "id": "cz9unpf"}, {"comment": "Did he reject it? Reading trough the thread, [his last post says](https://redmine.ruby-lang.org/issues/12004#note-159):\n> For me, avoiding bureaucracy is far immediate danger. Of course, I agree with you in part, so I agree to add kind of CoC for the community.", "id": "cza4mn6"}, {"comment": "I feel he was kinda bullied into agreeing with Coraline , since he started getting harassed on twitter by her supporters \n\nhttps://twitter.com/krainboltgreene/status/690437246059556864", "id": "cza6k2o"}, {"comment": "Moral of the story, don't use twitter. Its useless anyway. At least then any harassers will be forced to use email and you can /dev/null them.", "id": "cza7uze"}, {"comment": "People have turned \"safety\" into a [magic word](http://fredrikdeboer.com/2014/04/29/bingo-cards-go-both-ways/) that is supposed to just win you any argument automatically, so they get pissy when it doesn't.\n\nI doubt any of them could make a compelling objective argument about how a CoC leads to an increase in safety.", "id": "czak0a5"}, {"comment": "Just report them on twitter for being harassing towards another twitter account, if they use any sort of harassing or disrespectful language you can report it to twitter - not that I completely agree with such things but it does use their rhetoric against them.", "id": "czb2cl5"}, {"comment": "He has stated clearly that he is against establishing any kind of beurocratic process for handling complaints (I.e. He is willing to lay down guidelines but wants to rely on the community to be self-policing).\n\nThis is a non-starter for the people proposing the code, as their ultimate goal is to use it as leverage to exert pressure on their political enemies.\n\nA lot of open source devs live in foreign countries, so when they commit wrongspeak on Twitter it is difficult to get them fired or otherwise socially punish them. \n\nIf you can get a code of conduct accepted at a project they care about, suddenly you have leverage over them. See opalgate for a very clear example.", "id": "cza9zbu"}, {"comment": "Makes me want to build a super successful open source project just to be able to tell them to suck it when they come for it.", "id": "cz9weyr"}, {"comment": "It makes me want to see how Linus would react if they tried to push a code of conduct into the Linux kernel mailing list..", "id": "cz9xt0n"}, {"comment": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/CodeOfConflict\n\nhttp://geekfeminism.wikia.com/wiki/Linux_kernel_civility_discussion", "id": "cz9xvvl"}, {"comment": "Now this I don't mind. \"Be excellent to each other.\" is all a CoC needs to be.", "id": "czb3i4y"}, {"comment": ">[I\nsimply don't believe in being polite or politically correct.](http://marc.info/?l=linux-kernel&m=137391223711946&w=2)\n\nBased Linus.", "id": "czewyem"}, {"comment": "Didn't they try at some point? Of course the attempt was shut down so hard they couldn't create their usual chaos and lynch someone. Also they probably realized it is impossible to lynch Linus.", "id": "cz9ycmo"}, {"comment": "Yep. He \"can pretty much guarantee that\nI'll continue cursing\".   \nThat's why I love him.", "id": "cza0jpe"}, {"comment": "I thought most people used ncursing now days?\n\n/bad-pun", "id": "cza41w5"}, {"comment": "Rumor has it a feminist group hatched a plot to get a Linux COC by framing Linus for sexual harassment.\n\nNo one is safe from these people.", "id": "czaexll"}, {"comment": "Why build a new one? Find an existing cool one and jump on board!", "id": "cza31vj"}, {"comment": "It's gonna be sad if/when FOSS gets their first Tim Hunt moment. Well, I guess donglegate kinda was...", "id": "cz9wwpf"}, {"comment": "Brendan Eich?", "id": "cza6ccr"}, {"comment": ">Tim Hunt\n\n:(", "id": "cza24ng"}, {"comment": ">Can't wait for the community kangaroo courts without due process, just like they set up in Academia!\n\nExplain?", "id": "cza2296"}, {"comment": "Google \"title IX rape tribunals\" and prepare to be disgusted.", "id": "czaezpc"}], [{"comment": "[\"ph ph\" seems to be the voice of reason:](https://redmine.ruby-lang.org/issues/12004#note-311)\n> We will only ever have harmony if we concentrate on the technical nature of a \ntechnical community. Bring politic in and you are bound to have political issues.", "id": "cz9qdsi"}, {"comment": "I just don't see why CoCs need to be longer than 5 lines. \n\n1. Don't be a dick \n\n2. Keep relevant discussion on relevant threads. \n\n3. Personal information, or websites containing the personal information of a developer, including electronic addresses are only to be posted by the person they belong to. \n\n4. Keep discussion relevant to the project; how people conduct themselves in places other than the repo is not for us to pass judgement on. \n\n5. Mods have the final say and it's put in a moderation log. \n\nWhile shit like gender, race, and sexuality are important (and I say this as a bi nationalist guy in Northern Ireland though that probably doesn't score enough on the oppressionometer), it's not relevant to code. Your shit works and it's easy to look at, or it doesn't and into the trash it goes. ", "id": "cza77p3"}, {"comment": "I thought one line was enough : \"Be reasonable.\"", "id": "cza8t8d"}, {"comment": "You'd think that would be enough but it's probably a bit too subjective for most people. ", "id": "czaa0sr"}, {"comment": "Doesn't matter. Either people were dick by mistake (culture mismatch, misunderstanding, ...) and explaining them will do, or they are dick on purpose and few lines of html won't stop them.", "id": "czaug57"}, {"comment": "No, but it does give those who are victims of the dickishness a tool to stop the dickishness without having to leave the community.", "id": "czaz8ov"}, {"comment": ">Your shit works and it's easy to look at, or it doesn't and into the trash it goes.\n\nWell, a big part of open source development is having technical discussions. Being a dipshit to other contributors - particularly about race or gender or whatever - is counter-productive to technical discussion.\n\nI'm guessing this is common ground for both sides of this debate - no one thinks flame wars are productive.", "id": "czabssx"}, {"comment": "Don't be an asshole. Everybody has an asshole. (We used that one in bike polo since it conveys the same notion with no specific gender)", "id": "czatxr4"}, {"comment": "A lot of people don't know what \"don't be a dick\" entails and need a more explicit explanation. These explanations are important if you want to foster an environment that maximizes productivity, instead of inadvertently creating a harsh environment for potential contributors. I'm not sure if I agree CoCs are necessary when it comes to code contributor environments, but generally that's the reasoning behind the more specific language. ", "id": "czahcgg"}, {"comment": "Exactly.  There are way too many \"oppressed\" subgroups with too many shades of potential \"micro-aggressions\" that can be inflicted on them for most sane people to keep up with.  \n\nI'm not exactly a religious type, but i've been a pretty big fan of the Golden Rule as a means of abstracting over a lot of that nonsense.\n\nI say this as a gay minority male.", "id": "czawmca"}], [{"comment": "[deleted]", "id": "cz9uuw7"}, {"comment": "The mods of /r/programming  don't want people to see that text. Here is the story discussing it https://www.reddit.com/r/programming/comments/42e71v/an_anonymous_response_to_dangerous_foss_codes_of which was removed from the front page.", "id": "cz9xxcg"}, {"comment": "[deleted]", "id": "cz9yiu0"}, {"comment": "it's even worse than that: they're trying to destroy the most productive communities around, while giving back nothing.   \nI still have to see one fundamental contribution made by one of these guys\u2026   \nEDIT: ~~and here they come the downvoters\u2026  when will Reddit make up/down votes public?~~ they tried, they failed.   ", "id": "cz9z7vq"}, {"comment": "Maybe this is the only contribution they're willing to make, and when it is all in ashes they can celebrate.", "id": "cz9zho3"}, {"comment": "Maybe.   \nthat's another reason to kick'em off from any project you deeply care about", "id": "cza0vuo"}, {"comment": "> I still have to see one fundamental contribution made by one of these guys\u2026\n\n* Graydon Hoare (/u/graydon2) and Steve Klabnik (/u/steveklabnik1) are two of the main drivers behind the Rust programming language, and I'd say that their technical contributions are beyond questioning. They're also outspoken SJ activists.\n\n* The [Recurse Center](https://www.recurse.com/) is explicitly feminist and inclusionary.", "id": "cza1vn2"}, {"comment": "> /u/steveklabnik1\n\nhttps://harthur.wordpress.com/2013/01/24/771/    \nhttps://improprietaryinfluence.wordpress.com/2015/06/06/a-strange-loop/     \nwho needs a CoC now?    \nnobody asked Steven to be removed from his position after what he did (luckily)    \nBTW he then apoligized, because everybody make mistakes    \nMany of the SJW think they are just right and that apologizing means you're wrong and \"being inclusive\" means \"you have to agree with me\"   \nWithout ever contributing to the projects they propose to adopt their CoC to   \nI've never Seen steveklabnik1 trying to force some other project to adopt the CoC he wrote    \nThere are evidence, I'm not making these things up, you know\u2026         \n\n> /u/graydon2\n> The Recurse Center\n\npoint is these are not the people I was referring to   \nAnd the *general* amount of contributions by SJ advocates is still negligible   \nsome of them are probably understanding that technical merit is as important as politics.   \nGood for them, good for us!   \nBut can you show me some evidence that Coraline Ada made some important contribution, after storming many different projects, including the Ruby language itself?   ", "id": "cza2qca"}, {"comment": "[Rust has its own CoC, and it seems way more reasonable.](https://www.rust-lang.org/conduct.html)\n\nFeminism and social justice are important concepts, but it gets dangerous when you reinterpret the discourse as dogma.\n\nIf you're using post-strucuralism to criticize society, but reject its core notions of meaning by thinking you hold the absolute truth, and anyone who disagrees or has a different interpretation is fundamentally wrong, you either have no idea what you're saying, or you're a manipulative psychopath.", "id": "czalci2"}, {"comment": "I agree with all of the above. In fact, I singled out the Recurse Center because [their own code of conduct](https://www.recurse.com/manual#sec-environment) is lovely.", "id": "czaokex"}, {"comment": "I think this is an issue of CoC design and implementation, not whether or not CoCs ought to be adopted. A good CoC will make it clear that a community is safe and that there are certain values that the community holds. The ACM has a very simple one on its website that applies to all ACM Conferences. \n\n> The open exchange of ideas and the freedom of thought and expression are central to ACM\u2019s aims and goals. These require an environment that recognizes the inherent worth of every person and group, that fosters dignity, understanding, and mutual respect, and that embraces diversity. For these reasons, ACM is dedicated to providing a harassment-free experience for participants at our events and in our programs.\n\n> Harassment is unwelcome or hostile behavior, including speech that intimidates, creates discomfort, or interferes with a person's participation or opportunity for participation, in a conference, event or program. Harassment in any form, including but not limited to harassment based on alienage or citizenship, age, color, creed, disability, marital status, military status, national origin, pregnancy, childbirth - and pregnancy-related medical conditions, race, religion, sex, gender, veteran status, sexual orientation or any other status protected by laws in which the conference or program is being held, will not be tolerated. Harassment includes the use of abusive or degrading language,  intimidation, stalking, harassing photography or recording, inappropriate physical contact, sexual imagery and unwelcome sexual attention. A response that the participant was \u201cjust joking,\u201d or \u201cteasing,\u201d or being \u201cplayful,\u201d will not be accepted. Anyone witnessing or subject to unacceptable behavior should notify a conference committee member.\n\n> Individuals violating these standards may be sanctioned or excluded from further participation at the discretion of the organizers or responsible committee.\n\nA good committee isn't going to just kick someone out for accidentally making one off-color remark, because people screw up. I guess the problem there is that you need a *good committee*. Realistically, this results in a light reminder, followed by a stern warning with repetitive behavior, followed *then* by more forceful action. \n\nI guarantee you that identity politics in tech was not a \"non-issue\" a few years back; it was probably an issue people kept to themselves.\n\nI've had people make uncalled for sexual comments to me in professional environments before, or suggest that I only earned something (a job or getting into graduate schools) because of my gender, and it's really uncomfortable. A Code of Conduct in addition to [making it clear that the culture values the CoC](https://modelviewculture.com/pieces/a-code-of-conduct-is-not-enough) *definitely* helps create a warm environment. \n\nWhere are the politics here, anyways? Are there actually politics behind \"don't harass people\"? ", "id": "czaguy5"}, {"comment": "Completely agree with your entire comment. I guess my answer to your final question would be \"agitating to have someone kicked off an OSS project for reasons other than incompetence\" is political, _especially_ when the undesired behavior hasn't even taken place in media associated with the project.", "id": "czbfaay"}, {"comment": "The problem is that CoC can be used as a lever to apply pressure where it is unwarranted, unneeded or just plain vindictive.  The problem with a COC isn't the COC itself its when its used as a weapon not as a shield.", "id": "czapqoo"}, {"comment": "The politics are how one defines \"harassment\", and how an organization that claims to believe in \"the open exchange of ideas and the freedom of thought and expression\" squares that belief with a ban on \"speech that creates discomfort\"", "id": "czcc9xd"}, {"comment": "From the link:\n\n> The sentiment behind a CoC is that there is no excuse for being an ass, which sounds great until you realize that only a select few people get to decide who's an ass. So when open source leaders want to stop you from doing free work they can pretend that its your fault for violating their code instead of admitting they never really wanted to include just anybody.\n\nPart of the idea behind free software was decentralization. But by building communities around free software you have centralized it, and now people are squabbling for control of the community because it controls the software.", "id": "cza3ce9"}, {"comment": "Why would you have to centralize for building communities around free software?", "id": "cza3mcw"}, {"comment": "I don't know why you are using the subjunctive.\n\nIf one can speak meaningfully of *the* community of a piece of software, then clearly some centralization has occurred.\n\nFurthermore, the text I quoted suggested that if a person's submission was rejected then they felt their work had been rendered pointless. This implies they feel control has been centralized.", "id": "cza47du"}, {"comment": "I see.", "id": "cza4f6a"}, {"comment": "I suspect it's more they dislike the humengous and unproductive flamewar that occurs whenever this kind of thing gets brought up.", "id": "cz9zge5"}, {"comment": "Yebb, lets see some code or discussion about the code and not something not even related to the code.", "id": "cza3net"}, {"comment": "It's being discussed freely over here: https://www.reddit.com/r/opensource/comments/42f66l/an_anonymous_response_to_dangerous_foss_codes_of/", "id": "czadk5d"}, {"comment": ">The Geek Feminism community prioritizes marginalized people\u2019s safety over privileged people\u2019s comfort. The Geek Feminism Anti-Abuse Team will not act on complaints regarding: \u2018Reverse\u2019 -isms, including \u2018reverse racism,\u2019 \u2018reverse sexism,\u2019 and \u2018cisphobia\u2019 (because these things don\u2019t exist)...\n\nWhat in the world :/\n", "id": "cza2rmq"}, {"comment": "[deleted]", "id": "cza81d1"}, {"comment": "Thank you for the straightforward defense of _actual_ liberalism.", "id": "czbezno"}, {"comment": "> What in the world :/\n\nThe phrase you're searching for is \"leftist fascism.\"\n", "id": "czbeyds"}, {"comment": "This is defining a hierarchy. It would probably be best if the hierarchy were explicitly stated, and all categories listed not just one. Oh, we don't need to quibble if cis hetero white male's position is at the top or the bottom (power vs victimhood where victimhood is power?); but he's clearly at one end. But it would probably pay to lay out the full pecking order. What if people in the other categories come to blows - Who is more marginalized, and therefore who wins?\n", "id": "czdcuiw"}, {"comment": "https://github.com/opal/opal/issues/941", "id": "cz9yh28"}, {"comment": ">unless @elia is removed from the project, I cannot learn Ruby, and thus can't get a job in Ruby development\n\nPoe's law in action.", "id": "cza19jm"}, {"comment": "That is laughable; do people truly believe that nonsense?", "id": "cza2aq7"}, {"comment": "Wait, so, is that real or a parody!?", "id": "cza7ulx"}, {"comment": "It's absolutely real.", "id": "cza88o4"}, {"comment": "Good lord.", "id": "czawi6f"}, {"comment": "Bullshit.", "id": "czd8s6l"}, {"comment": "Uh, as in what I said is bullshit, or are you agreeing with me? You seem rather angry.", "id": "czdbbck"}, {"comment": "You seem rather bullshity.", "id": "czdjq2o"}, {"comment": "Remind me, what was Poe's law about again?", "id": "cza3l0z"}, {"comment": ">Poe's law is an Internet adage which states that, without a clear indicator of the author's intent, parodies of extreme views will be mistaken by some readers or viewers for sincere expressions of the parodied views.", "id": "cza3t8x"}, {"comment": "Thanks, was a bit too lazy to look it up.", "id": "cza4e5s"}, {"comment": "I only skimmed the comments and I'm pretty sure I now have cancer.", "id": "cza5uox"}, {"comment": "I can feel cancer dripping out of my ears as I type.\n\n*edit:* Is she *honestly* referencing the Gregory Allen Elliott trial (where the graphic designer was harassed, banned from using a computer for over 3 years, the accuser admitted under oath that her intent was to harm the man for something she knew he didn't do, and the jury found him not guilty) as an argument in her favor? I'm so confused. This is honestly toeing the line of being sociopathic. ", "id": "czaj0u9"}, {"comment": "Toeing? It is sociopathic. This thing is being wielded as a weapon with scare tactics to rush adoption.", "id": "czawch0"}, {"comment": ">Protip: you won't because you can't.\n\nrekt", "id": "cza8ow5"}, {"comment": "> now FOSS devs are concerned about making sure marginalized human beings feel \u201cwelcome,\u201d as if someone was trying to physically block newcomers. That opens the door to social justice and other buzzwords that prigs use to feel better about themselves, and utopian visions documented in \"Codes of Conduct,\u201d or CoC\n\nSee, it's hard to treat the piece as a fair treatment of the topic when the author starts out by saying this which suggests he is totally unable to come up with a reason why a CoC might be a decent idea.", "id": "cza44ex"}], [{"comment": "The Obvious Code of Conduct:\n\n1) Contribute good code.\n2) Don't be mean.\n\nNote which comes first.", "id": "cz9pmf9"}, {"comment": "The issue is that the professional victims have a ridiculous notion of what being \"mean\" is or what constitutes \"harassment\".\n\nI think most programmers would be against actual harassment but many of the CoC suckers claim things like sending a \"\\*hugs*\" is equivalent to unwanted physical touching or that a man correcting a woman's code is a \"microaggression\".\n\nAny project that adopts a professional victim backed CoC is going to stagnate as the non-masochist contributors get sick of walking on egg shells.", "id": "cz9ty8a"}, {"comment": "a better one (for me)   \n1) Contribute good code. 2) Don't like us? fork the project and ~~fuck off~~ may you live long and prosper far from here   ", "id": "cza0n31"}, {"comment": "The Better Code of Conduct:\n\n1) Contribute good code. 2) Don't be offended.\n\nNote which comes first.\n", "id": "cz9xxhb"}], [{"comment": "In some respects, a CoC sounds great on paper. 'Be nice! No doxxing! Treat people with respect!' The problem is, it was conceived by people who can't stop getting their fucking feelings hurt. It's fine to try to be nice, and I think most people do... but for fucks sake, why do we need to bring political correctness into a realm where people are trying to get shit done?\n\nIf Donald Trump himself submitted a useful PR, I'd rather have that merged with the project than find a childish, moral/political reason why he shouldn't be allowed to contribute. It's just sad, really. Focus on writing good code and being useful rather than looking for reasons to get butthurt.", "id": "cz9po64"}, {"comment": "> The problem is, it was conceived by people who can't stop getting their fucking feelings hurt.\n\nIt's worse that than, the CoC was specifically crafted to give twitter armies leverage against open source developers, since nobody in those hate mobs contributes to open source the armies previously had no power there. \n\nTo illustrate, the CoC was updated to v1.1 to better give an uninvolved twitter mob a way to attack an Opal developer for [disagreeing with gender reassignment surgery on kids](https://archive.is/U4MXZ) in a conversation that took place on a personal twitter account unrelated to Opal:\n\n* The attack begins [here](https://github.com/opal/opal/issues/941) - CoralineAda is the creator of the CoC and starts the above attack on the Opal developer. A twitter dog-pile is summoned into the Opal project to back her up (github accounts are free). Drama ensues. Opal are told they need to adopt a CoC to prevent such drama in the future. CoralineAda's already-established CoC is suggested, and Opal are receptive to the idea.\n* The authors of the CoC realise that version 1.0 of the CoC isn't going to give them enough teeth over open source projects such as Opal, since they don't use or contribute to Opal, and the comment was made in a personal account. Wanting to be able to demand the removal of their target from the Opal project, they add a new clause to the CoC which they believe can be sufficiently bent to that purpose, creating v1.1.\n* Before CoralineAda and co update their files to v1.1, Opal obliges on the CoC suggestion - ending up with v1.0 of the CoC.\n* To hurt their target, the authors of the CoC need the clause they added in v1.1, so [demand Opal update to 1.1](https://github.com/opal/opal/pull/948) under the pretense that the update is to \"include ethnicity\".\n* Opal looks at a diff between 1.0 and 1.1 and spots the trap (though meltheadorable also spilled the beans), they alter a copy of 1.1 to disarm it, adopting their own [\"fixed\" 1.1 CoC](https://github.com/opal/opal/commit/d010f51293ab650327af2335daa622f824aec377#diff-a1ee87dafebc22cbd96979f1b2b7e837).\n* The Opal devloper is now safe - if not chilled, but **the unaltered v1.1+ goes on to be adopted by everyone else** (atom etc), who assume CoCs are written by good people trying to do the right thing.\n* Another clause - *\"Project maintainers who do not follow the Code of Conduct may be removed from the project team\"* makes it personally risky for level-headed maintainers to rule sensibly against an outside mob's ideological demands - the maintainer must either acquiesce or become themselves the publicly smeared target of the mob. The way normal people read a CoC is not how the mobs bend and wield the clauses. Having said that, people seem to have defanged this clause a little in v1.4.\n\ntl;dr The historical *intent* behind CoC's is to enable uninvolved outside mobs to attack open source projects with teeth. Adopting a CoC is adopting politics, drama, and harassment.", "id": "cz9x5ff"}, {"comment": "What, that is like gangs extolling money out of the shop owners after they trashed the place.\n\n\"I'm sorry about what has happened, if only you would pay protection money, none of this would have happened.\"\n\nParasites, that's what they are.", "id": "cza42cx"}, {"comment": "But I thought that the CoC was rejected by Opal. I'm amazed that it was integrated and that the main devs still haven't fled or forked the project. ", "id": "cza0go2"}, {"comment": "Opal have adjusted their version to defang it, and the devs there have Elia's back, but at the time they were operating under the assumption they were dealing with reasonable people and that the CoC being requested was harmless and would help make peace and make the drama go away. \n\nI too assumed CoCs were written in good faith before watching that unfold. Opal now serves as a warning to others, and the people pushing CoCs have shown their true motivations.", "id": "cza1213"}, {"comment": "Speaking of Trump, people like these are likely a reason he's getting votes", "id": "cz9u1ae"}, {"comment": "How much doxxing happens around open-source software projects anyway?", "id": "czageu6"}], [{"comment": "Well it looks like Matz shot them down on their insane coc. He has proposed another one which is much simpler less prone to being abused but if history is any indication Coraline will find a way to abuse it and twitter lynch somebody or another.\n\nShe has already taken some of these comments out of context and put them on twitter to try and rally her SJW lynch mob.", "id": "cz9tds8"}], [{"comment": "I guess every project undergoes those useless proposals. But the proposed form was already rejected by matz, so this variant won't go in.\n\nWhat I wonder is why some people invest so much energy into something as useless as this. What happened to good old programming? The evolution of ideas?\n\nWhat is wrong with these people?", "id": "cz9un9f"}, {"comment": "These are not programmers investing energy. These are professional SJWs", "id": "cz9wran"}, {"comment": "Want tumbler meant to contain them out of sight?", "id": "cza3qlh"}, {"comment": "[deleted]", "id": "cz9wk4v"}, {"comment": "Exactly. The intention here is not a altruistic attempt to improve the lives of otherwise marginalized people, but rather an attempt by the author to gain notoriety. ", "id": "czaa681"}, {"comment": "Really? What about people that just want get stuff done?", "id": "cza3rff"}, {"comment": "Open source has gone corporate. The result is these people trying to get corporate attention and money for non-technical \"contributions\".", "id": "czah289"}, {"comment": "The side pushing CoCs and such are stronger, in that the owners of the projects submit to the loudest voices. The path of least resistance is to obey the loud voices so they can just go back to the project. They need some pain from the other side. One is that the some from demographics who actually write the software will just silently stay away from all this mess and do something else with their evenings. Perhaps if you tell the project owners that the CoC or environment dissuaded you from contributing they can see that submitting to SJWs is hurting them where it matters.\n\nI've seen one example of people attempting to fork a project into non-CoC branches. The more likely is people just forking into doing nothing.", "id": "czb5w81"}], [{"comment": "[deleted]", "id": "cz9vvai"}, {"comment": "These are the truly toxic people, not everyone else. Why does anyone take them seriously?", "id": "cza2hgn"}, {"comment": "\ud83c\udf46", "id": "cz9y46k"}], [{"comment": "I sincerely hope that the majority of the open source community rejects this nonsense (and looking at this thread it seems so). This is software - let's talk technical, not politics.", "id": "cz9woc9"}, {"comment": "Open Source projects maintained by individuals or unaffiliated communities may reject it but I guess projects maintained by big companies will have a hard time rejecting it since they have to handle P.R. for the company. How can Microsoft reject it and risk boycotts of their end-user products?", "id": "cz9zshz"}, {"comment": "There's a certain draw to just complying because mob tantrums from the perpetually offended can range from inconvenient and annoying to actually making a dent. The bigger the target, the easier it is to get people on board. ", "id": "cza3guz"}, {"comment": "Microsoft  has good lawyers on its payroll", "id": "czamfiy"}], [{"comment": "[deleted]", "id": "cz9mc7o"}], [{"comment": "Here I was, interest piqued by the idea that zealots of the Calculus of Constructions (a proof theory) were going to tackle verifying some part of Ruby. Imagine my disappointment when CoC here actually stands for Code of Conduct.", "id": "cza1sdc"}, {"comment": "RubyCert ", "id": "czah8vc"}, {"comment": "If that's a real certification effort, I can't find a link on Google.", "id": "czapian"}, {"comment": "Just a joke. Referencing CompCert. Was going to make a DeepSpec joke but figured CompCert was probably the only effort that made it outside of the verification community that I could joke about", "id": "czapk2c"}, {"comment": "I actually goggled for a moment that anyone would try to verify Ruby ala CompCert.", "id": "czapn9o"}, {"comment": "I thought it was about the Role-Playing Game \"Call of Cthulhu\".", "id": "czazw4a"}], [{"comment": "Great, I'll be pointing to this thread every time some scumbag suggests that \"SJWs are boogeymen and do not exist\".", "id": "cz9xy2k"}, {"comment": "The way I see it: SJWs kind of are boogeymen, but they do exist, and the ones who do exist are just as horrifying as the tales tell. Their voices are very loud online and in some college campuses, but the majority of the public doesn't really support them. We can only hope they don't grow in numbers.", "id": "cz9ya3s"}], [{"comment": "As much as one would like to support and sustain behaviors that promote the general welfare,  the word 'covenant' that the linked page uses is very troublesome.  In American law,  a covenant is a (the only?)  kind of agreement that can be enforced without adequate consideration.  If I give you something and you give me nothing, we have no contract, and my act of unilaterally giving something  to you usually brings no additional obligation for me,  beyond the normal obligations of not knowingly giving you poisoned food or a ticking bomb, etc.  However,  if I unilaterally give you a covenant and you give me in exchange nothing of value,  you might still sue me for not complying with the 'covenant'.  Even third parties might have rights to sue me.  Change the word at least.", "id": "cz9n812"}, {"comment": "\"Change the word at least.\"\n\nAre you joking?\n\nThe creepy SJW trying to force her CoC down the throats of the Ruby community is already harassing one of the community members who is not inline with her nutty SJW/identity politics by taking his quotes out of content and posting them on her Twitter account.\n\nIt doesn't matter what the text of the CoC that gets rammed down a development community's throats. All that matters is the breach has been created.\n\nFrom there the SJW/sexist/feminist/identity politics nutcase has a foundation to build upon.\n\nThe SJW will work night and day to 'revise' the CoC until the wording is close to the nutty original when they are no longer in the spotlight and all the competent people are back to contributing to the project and have long forgotten about the CoC distraction they never wanted or needed.\n\nThe SJW and their entire network of social media mob will now be relentlessly searching through the community member social media accounts looking for 'wrong think' and anyone not inline with their nutty identity politics.\n\nThe SJW and their social media mob will attack their ideological enemies identified from their social media postings and scream \"harassment!\" when they are responded to.\n\nOne sided chat or social media transcripts/screenshots will be spammed as evidence of 'harassment' and evidence that there \"is a problem\".\n\nSJWs/feminists in the media will pick up the fake stories of 'harassment' in the tech world with gnashing teeth and wailing cries of victimhood for the SJWs who have infiltrated the community.\n\nCries to update/fix the CoC and creation of CoC enforcement committees and calls to bring in CoC 'experts' aka the SJW's feminist/ideological allies.\n\nLinus has shown the only way to deal with attacks by SJWs - zero tolerance.\n\n", "id": "cz9qyxv"}, {"comment": "If anyone is still wondering how far radical feminists and 'SJW's' will go, read this transcript: http://blacktridentmedia.com/wp-content/uploads/2015/07/R-v-Elliott-Submissions-15-April-7.pdf\n\nIt's pretty long, but factual and eye opening.\n\nA little bit:\n\n>Q. You were trying to ruin Bendilin Spurr\u2019s life, correct?\n\n>A. I was trying to let as many people as possible know that this was\nsomething Bendilin Spurr had done. And if they believed it was wrong, and\nif they believed it was disgusting, and if they took action that subsequently\nruined Bendilin Spurr\u2019s life, then he was the one who ruined it and not me,\nMr. Murphy.\n\n>Q. Right. So ...\n\n>A. I was a messenger.\n\n>Q. So you were the messenger. So a 24 year-old kid in Sault Saint Marie\nmakes a face punch game for whatever reason he has to make it?\n\n>A. Are you suggesting there\u2019s a valid reason?\n\n>Q. If a kid makes a face punch game, and his life is ruined, and you\u2019re just the\nmessenger, that\u2019s a-okay with Stephanie Guthrie?\n\n>A. Well, 24 years old is not a kid. Certainly old enough to appreciate the\nseverity of your actions. And I would not feel sorry about that. If that\nhappened, that would be his actions that got him where he was. His\nchoices.\n\n>Q. So you being the messenger of a message that ruins Bendilin Spurr\u2019s\nlife is okay with you, yes or no?\n\n>A. Yes.\n\n>Q. Thank you", "id": "cz9wbta"}, {"comment": "So this guy lost $100 000, his job, and spent over 3 years without access to the Internet, because he argued with women online, and they decided they had to ruin his life because he didn't agree with them.\n\nIt's sad to see that the legal system is so terribly broken.", "id": "cza4mjf"}, {"comment": ">  The creepy SJW trying to force her CoC down the throats of the Ruby community is already harassing one of the community members who is not inline with her nutty SJW/identity politics by taking his quotes out of content and posting them on her Twitter account.\n\nhttps://github.com/contact?report=CoralineAda", "id": "cz9xjes"}, {"comment": ">  force her CoC down the throats\n\nKek, just realised the joke...", "id": "czazwg6"}, {"comment": "http://digitalclaritygroup.com/wordpress/wp-content/uploads/2012/08/trap.png", "id": "cza0oce"}], [{"comment": "I dislike a lot of the comments here, but I think adopting a code of conduct is almost always useless.\n\nLaws are only useful when you have judicial review and legal precedence. Without it, the ambiguities inherent in writing are going to collapse. Look at how heavily the US relies on precedent. Now look at how explicit US laws are compared to the contributor's covenant. Combine that with the fact that there is a subset of people who are too sensitive about things and you have a bit of a recipe for disaster. \n\nThe original poster of that issue is talking a lot on Twitter about supposed bad actors in the Ruby community, but she's not bringing up any concrete examples. I mean, I'd love to hear it if Matz called somebody a homophobic slur or something, but the total lack of any displayed examples suggests to me that there aren't any.", "id": "cz9ukwa"}, {"comment": "> but she's not bringing up any concrete examples.\n\nThat's pretty common or \"that thing happened once in that other project, let's add stupid rules so we can kick someone out of project if \"we\" dont like his/her twitter feed\"\n\n", "id": "czacrxq"}, {"comment": "And often that incident in that other project also turns out to be not as bad as it seems from the inside once you have understood the context.", "id": "czanydu"}, {"comment": "And it is not like CoC will actually *stop* that from happening in the first place, it is purely to be ablr to point a finger at at and say \"you are banned\" without trying to actually get to the root of problem.", "id": "czao4p9"}], [{"comment": "[Diff](https://gist.github.com/olivierlacan/84bd12d0ac13dfdd85d2/revisions?diff=split) of Matz\u2019s proposed edit of the Contributor Covenant CoC.", "id": "cz9v849"}, {"comment": "It looks like, Matz just removed those utterlu stupid parts of CoC and make it look like pretty nice. \n> \n> \n> Project maintainers have the right and responsibility to remove, edit, or\n> reject comments, commits, code, wiki edits, issues, and other contributions\n> that are not aligned to this Code of Conduct, **or to ban temporarily or\n> permanently any contributor for other behaviors that they deem inappropriate,\n> threatening, offensive, or harmful.**\n> \n> **By adopting this Code of Conduct, project maintainers commit themselves to\n> fairly and consistently applying these principles to every aspect of managing\n> this project.** **Project maintainers who do not follow or enforce** the Code of\n> Conduct may be **permanently removed** from the project team.\n> \n> This Code of Conduct applies **both** within **project spaces** and in **public spaces**\n> when an individual is representing the project or its community.    \n\nThose are removed parts. You can easily see, how much nonsensical it is. \nIt gives too much freedom for potential abusers. \n\n\nEDIT: Lack of meritocracy is one thing, second is connecting private life and work on project. \nI don't even try to understand, why any sane individual would adopt something so full of loopholes.\nNo sane law is based on hard feelings", "id": "cza1bc4"}, {"comment": "I think the worst part is the anti-meritocracy language.\n\nI get the feeling that Coraline is also a deeply toxic individual.", "id": "cza3krf"}, {"comment": "You are correct on both counts. ", "id": "cza7ld3"}, {"comment": "> Project maintainers have the right and **responsibility**\n\nLooks like an OSS maintainer can now be sued successfully because someone on the mailing list felt hurt. Hey Maintainer, it's in your terms, that you published, that you are responsible. Now you're fucked. Why would any sensible maintainer adopt this? It's chilling, as in, \"Sorry, folks. I am no longer a maintainer of this project due to pressure to adopt stupid terms that make me culpable for your bullshit.\" And then basically you have a hostile takeover of all communication by the technically incompetent social warriors.\n", "id": "cza4fxv"}], [{"comment": "[deleted]", "id": "cza01pn"}], [{"comment": "Oh good, CoralineAda is back at it again again. It's been at least a few months since the last time she and her twitter mob attempted to extort a successful open source project into accepting this CoC.  \n\nIt looks like the patreon link on her site is a little more subtle this time. Classy.", "id": "cza7g5p"}], [{"comment": "This is a great train wreak. I cannot imagine why a 20+ year old community would suddenly \"need\" a CoC, as if the community was dying on the vine for it due to constant harassment, etc.", "id": "czalm6m"}, {"comment": "It's what they want you to believe", "id": "czawm0z"}], [{"comment": "I don't need a CoC in order to not be a dick. Fuck off.", "id": "cza4ehe"}], [{"comment": "[deleted]", "id": "cza5gaw"}, {"comment": "The uproar has been for at least 6 months. Github CoC announcement was a mess (and they are trying to put it under the rug silently) and generated a lot of heated discussions.\n\nI didn't know about bundler and it seems to me that this is a very very bad thing. Someone should fork the project just to remove that part.", "id": "czacznq"}, {"comment": "Wow, CoC by default is something I just don't understand. Per @binarycleric on that first link:\n\n>I worry that developers won't understand or enforce what is included in their CoC. While I agree that projects having them is a good thing, having a CoC that is unenforced and ignored by the maintainer is dangerous.\n\nI'm going to scoot away from Ruby and never look back.", "id": "czapacu"}, {"comment": "Did you actually finish reading the thread? The default is no, you have to actively yes for it to include the CoC", "id": "czb058w"}], [{"comment": "I'd like all SJWs to get the fuck out of one of the few communities where a persons argument will be judged on technical merit alone rather some bullshit notions of \"equality\", \"fairness\", and whatever the hell is contained in that coc. \n\nDon't show up at my fucking doorstep and shove your ideology down my throat.", "id": "cza84g2"}], [{"comment": ">TL;DR\n>gender is wrong. She means to use \"Sex\"\n>gender identity is what a person identifies as in life.\n\nThe fact that this discussion exists in an issue tracker for software bugs is emblematic of my problem with Codes of Conduct #offtopic\n", "id": "czafr7l"}], [{"comment": "I first read \"CoC\" as Calculus of Constructions. I was very disappointed.", "id": "cza84eh"}, {"comment": "Dude, I wish there were Calculus of Constructions zealots.", "id": "czapf1i"}], [{"comment": "A reason to use non-trendy languages like C, C++ and Fortran?\n\nSeriously, though, what a bikeshedding waste of time. If you've got enough spare time to worry about code of conduct stuff in a programming language, you're not programming enough.", "id": "czanc6y"}, {"comment": "Perhaps you're writing an app, and you ask if it's OK (doesn't conflict with something else) to use \".bro\" for a file extension, and now suddenly you're getting hassle about \"gender bias in file extension\". \n\nAs what happened with the Brotli compression library, which isn't even a bro joke. It's a (German?) bread.\n\nNo human is a fully independent system that works in isolation.", "id": "czavomb"}, {"comment": "In this case, you could claim Anglophone ethnocentricity from the people claiming this is about gender bias - if it wasn't completely counter-productive to argue with them, because it's like wrestling with a pig.", "id": "czb6v8o"}, {"comment": "but hopefully now you see why the issue can still affect a person by filling up their mail and issue trackers even if they ignore it.", "id": "czb8nll"}, {"comment": "I can see your point - my complaint is at the people who initiate these pointless and time-wasting arguments in the first place.", "id": "czb8r8u"}, {"comment": "Furthermore, I'm reminded very heavily of this recent webcomic: http://terminallance.com/wp-content/uploads/comics/2016-01-08-Strip_New_Corps_web.jpg", "id": "czb6le7"}], [{"comment": "I've been thinking about this a lot lately.  Whenever this comes up the discussion goes to shit, because one side assumes that the only valid reason to want a CoC is a political power grab and the other side assumes the only reason to oppose it is to be an asshole without consequences.  Neither of these are accurate positions, and they just stifle discussion.\n\nContributor Covenant is in a precarious position, with its creator both actively pushing it on OSS projects and having tried to have contributors removed for off-project behavior in the past.  I think it's scorched earth at this point.   But that doesn't mean that there's no valid reason to adopt a CoC.\n\nSo I started thinking about valid reasons.  The most often stated reason is that it will bring in contributions from marginalized people who were unwilling to contribute before without some guarantee of protection.  This is a bit suspect.  For one, these contributors and the potential value of their contributions are entirely hypothetical.  Second, why would anyone want contributors who will only participate if they are guaranteed the ability to initiate bans of other contributors arbitrarily?\n\nAll communities will have disagreements, and handling these disagreements is important to keeping the project running smoothly.  I'm not sure that open source projects really have mature and useful conflict resolution procedures.  What I've learned about interpersonal conflicts throughout my career is that usually one side is not completely in the right and some mediation is required.   Good mediation usually leads to a solution that neither party likes, but both can accept.   This is a far cry from some of these proposed CoCs which tend to set up procedures for banning people from the project.\n\nI don't think there are any legal reasons for an OSS project to adopt a CoC?  But there may be reasons still.  In a conflict it would be nice for both parties to be able to have their rights explicitly enumerated.  Ad hoc discipline tends to suck or be unfairly practiced.  Although a mature project could certainly go for decades without a formal discipline or conflict resolution procedure and be just fine.\n\nThe last point I think is interesting is that many of the CoCs require that the project police non-project spaces.  Which seems like madness to me.  For instance, why is it the Ruby project's job to police Twitter?  People rightly point out that harassers can and do use multiple avenues of approach, but Twitter is responsible for things that happen on Twitter.   Matz pointed out in the Ruby thread as well... banned users dedicated to harassing can just make new accounts and continue harassing.  On any service, project-sponsored or not.\n\nSo I think a useful code of conduct would specify acceptable behavior in project spaces, which amounts to professionalism, and possibly setup a formal process for mediation.  Mediation could lead to bans, but only in extreme cases.   It is a bit harder with OSS because there is no notion of hiring and firing like there is in real companies.   All of this could be ad hoc and work perfectly well, but some projects may wish to specify more formal procedures to ensure that disputes are handled fairly.", "id": "czaj1qb"}, {"comment": "It is important to remember that software development is very similar to science in many ways. And for a science to work at all it is essential to be able to criticise anyone and anything freely and to be able to tell the idiots who they are. Yes, even with an R-word and all the other stuff that SJW suckers are getting butt burns from.\n\n Any science will collapse immediately as soon as any kind of code of conduct is introduced. There is no single valid reason to enforce any CoC whatsoever.", "id": "czb2hkm"}, {"comment": "This is where I'm coming from... sorry but it will be long.\n\nThis happened in some corner of the Ruby community last week:\n\nhttp://rubinius.com/2016/01/15/banning-mr-nutter-for-repeated-harassment/\n\nAny sane person would read that text and initially think that the author had gone way overboard.  It was just a small little comment on twitter.  I don't think it was an appropriate or professional one, but not really worth all this drama.\n\nExcept we (or at least I) don't know the history between these two.  I don't know either one of them but just looking at this the above it seems to have stemmed from repeated disagreements about technical stuff and a lack of mutual respect.\n\nI had a relationship like that in one of my actual jobs, and so I can kind of sympathize.  What I had, though, was a boss... a boss in whose best interest it was to deal with the problems his employees had with one another so that productive work could get done.   (As an aside, I didn't feel the mediation was satisfactory so I just left the job... go figure.)\n\nOSS doesn't typically have the equivalent of the boss in this scenario.  These two guys had a fractured working relationship and someone could or should have stepped in and helped them work it out before one went off the deep end and started yelling harassment (where none had occurred) and banning people.\n\nSo I'm sitting here thinking... if attracting hypothetical contributions isn't a great motivator for a CoC, and policing out of project behavior is a stupid idea, then what _would be_ a good thing for a CoC to do?  And the answer I came up with is to deal with these two dudes that can't get along.   I don't think these CoCs as stated are great, what I'm saying is that this is an area where this particular subsection of the Ruby community needed some help... and a CoC that spells out how exactly that happens could be a positive thing.\n\nThere was absolutely no need for any banning or anything in this situation... interpersonal conflicts usually involve two people with at least some blame rather than the rare one-way harassment types of situations contributor covenant wants to deal with where you can just ban someone and be done with it.  Those are the extreme cases and I don't know why you'd build policy around the extremes when there is a clear need for something better sitting right in front of you.\n\nSomeone on twitter suggested Code of Merit as an alternative.  I get it... that thing is designed to prevent SJW entryism and it would do a fine job there.  But in the context of my own personal struggles with coworker relationships across my career it's not worth a damn.\n\nThere's only rarely a clear best choice when comparing proposed solutions on strictly technical grounds.  Among competent professionals there will only rarely be idiotic solutions suggested. And yet as we see above two white guys can have such a strained relationship that a single word on twitter creates a drama storm.\n\nSo when I say CoCs might be an ok thing, or that they're not all bad... this is where I'm coming from.  That even in a pure meritocracy where only technical solutions are considered, occasions still arise where social problems should not be just ignored but should be dealt with for the good of the project as a whole.   Those situations are where a well-crafted Code of Conduct could help.", "id": "czb2w1a"}, {"comment": "Seriously, I think that a duel code would have helped to resolve this kind of issues much better than any enforced politeness. If it is a personal matter, no mediation would help anyway.\n\n A healthy community tend to distantiate from the toxic individuals anyway, without any enforced CoCs, so I do not see any problem here.", "id": "czb7ojh"}, {"comment": "That was a lovely post. Thanks for contributing <3", "id": "czbdyv8"}, {"comment": "Really? It's *impossible* to do science without the ability to call people the \"R-word\"? Unless you have *absolute* freedom of speech, it's literally impossible to gather data, test hypotheses and debate your results?\n\nI'm completely on your side here, but that's just needless hyperbole.", "id": "czb66ho"}, {"comment": "Ever seen a moderately heated debate? Even a slightest restriction on behaviour would grind it to a halt. And the problem with restrictions is that they tend to inflate. Ban R-word today, and in a couple of years you won't be able to say that someone is \"not entirely correct\".", "id": "czb7k72"}, {"comment": "This is by far my favorite comment in this thread.\n\n>one side assumes that the only valid reason to want a CoC is a political power grab and the other side assumes the only reason to oppose it is to be an asshole without consequences\n\nHit the nail on the head.", "id": "czaphqv"}], [{"comment": "\nRemember, people, this is what this is all about (issue created by the author of CoC:\n\nhttps://github.com/opal/opal/issues/941\n\nLook at all the mayhem from a couple of posts. Very economical.\n", "id": "czau9n8"}, {"comment": "Imagine the wasted productivity caused by that thread and all discussion surrounding it.  This shit is fucking frivolous.", "id": "czawryz"}, {"comment": "Also, for how the project is meant to benefit from the inclusion of certain groups at the expense of who the CoC is meant to vilify. . . remember, the former isn't that big a group, whereas the latter is the lions share. The vilified won't fight, they'll just slink away and find something to do in their evenings than work on your project.", "id": "czb5p8h"}, {"comment": "http://where.coraline.codes/blog/on-opalgate/\n\n\"Elia Schito is publicly calling trans people out for \"not accepting reality\" on Twitter.\"\n\nThat's what atheists accuse religious people of doing. Should an atheist be banned from contributing to open source projects based on outside posts? I'm sure religious people 'feel bad' when they read such things.\n\nRemember, this is all about specific targets on specific issues, with specific people getting to choose the targets.\n", "id": "czb6b4q"}, {"comment": "Well the thing here is that you just need to look up Elias twitter and see that he is devout catholic living in Italy. So it is an most likely an atheist person telling a religious one that the opinions he has are wrong. ", "id": "czbt10b"}, {"comment": "This also speaks to the imperialism of all this. People in the US may be enlightened enough to take marching orders and what they can say and think and who they should associate with from this CoC author's obvious qualifications. But maybe people from other cultures, who may have otherwise come for the programming stuff, could find better things to do with their time.", "id": "czbyeyw"}], [{"comment": "Anything short of absolute and full anonymization will never get rid of these discrimination issues or convince SJWs (or anybody affected) that discrimination is not happening. Similarly, subconcious influencing of decisions (i.e. people that do not want to discriminate, but really aren't sure whether they're biased) cannot really be solved through any other way either. The internet is one of the rare places where you can actually anonymize yourself completely to other users and avoid these issues that way, so why not do it?\n\nJust generate a random string of letters/words and use it as your account name. And everybody should do that. Problem solved, peace of mind for all involved.\n\nYour name/gender/personality/nationality or anything else that could serve as a meaningful base for discrimination\\* has no business being brought up in a technical project anyway.\n\n\\* Except intendation style, but that's what `indent` is for.", "id": "cza09uk"}, {"comment": "They don't care about *equality*. If they did, they wouldn't be pushing for insane things like this. They want special attention given to them.", "id": "cza6svs"}, {"comment": "Because in a programming community, you eventually collaborate face to face - e.g. at a developer conference or maybe pair remotely over Skype. If you have to hide basic facts about who you are like race and gender, you prevent yourself from doing this, and thus engaging with the community fully.\n\nThere's no such thing as a purely technical project when humans are involved.", "id": "czazoh7"}], [{"comment": "I won't stop reading and enjoying Ender's books just because Orson Scott Card made some harsh statements about... can't really remember (I think he's a mormon and said something really awful about gay marriage or the like). You can see how much I care about Scott Card's opinions, btw. Like... zero. Nada. ;)\n\nNow I know the guy is a bigot and I will take that into account, and I give horse shit about what he thinks. But boyccoting the premiere of the movie based on the first book of the series (as it happened) seemed void to me. Even when it raised attention, which I suppose was the intention.\n\nJust... I don't know. My two cents.", "id": "cza1uuv"}, {"comment": "I find it weird, because Ender's Game has some serious homoerotic undertones, Songmaster has an actual gay romance, and Speaker for the Dead is so full of compassion and tolerance that I can't reconcile it with the hateful bigot he is in real life.", "id": "cza75e5"}, {"comment": "Maybe he's not a hateful bigot after all.", "id": "czaeadk"}, {"comment": "Or the books are old and people change. ", "id": "czb1pj4"}, {"comment": "I heard once that most of his notable work was written during a period where he was nearly estranged from the church and heavily questioning his faith.", "id": "czaennt"}, {"comment": "Any qualified councillor or psychiatrist will say that the most hatred comes from repressed feelings that the person can't deal with. For a human to hate something, it has to be a perceived threat to them or their lifestyle - otherwise they're just \"meh, don't care about it\". So basically they're eternally worked up over it, as they are unsure if they have it in at least some small part, and don't want to have it.\n\nWe like to think the human condition isn't understood, but it is: just that the explanation makes some people angry enough to reject it.", "id": "czave4p"}], [{"comment": "First I've heard of this CoC thing. Ever read a mailing list?? The Linux kernel is not CoC compliant.", "id": "cza42rn"}, {"comment": "The LKML is notoriously known for being toxic, so that's not really a good example. ", "id": "czb0798"}], [{"comment": "??? The mods must be asleep lol", "id": "cza5c0m"}], [{"comment": "From the vote battle happening on this post and the discussion thread I think anyone who wants to pretend the community is largely in consensus on this topic (except for a few bad actors), is completely uncoupled from reality.", "id": "cza7lny"}, {"comment": "I'm coming to this hours later but the votes seem to have shaken out....I don't see any top rated posts in this thread saying the CoC is good or reasonable", "id": "czamo8h"}, {"comment": "Take a look at the registration dates/contributions of folks on the list, many of them registered on the day and/or have no/few contributions.  \n  \nPretty much its a flash mob attempting to force consensus on the community.  \n  \nThe ruby community said they trust Mat to be sensible, while outsiders in general are pushing their CoC in their faces.", "id": "czao5t3"}, {"comment": "There are many tiers of a community. Some are better than the others. Some are active OSS contributors, active researchers and engineers. They are mostly against any non-meritocratic trends. \n\nThen, there are the inferior folks, wannabes who cannot contribute constructively but yet want to be included for some reason and to be treated as equals. They are turning into SJWs very quickly, after the first legitimate criticism they get. Instead of learning from their mistakes and from the criticism, as any sane engineer would do, they are getting \"offended\", and this is exactly what makes them inferior.", "id": "czb2l8g"}], [{"comment": "https://www.youtube.com/watch?v=MpPvGlrqhdA", "id": "cza1ui1"}], [{"comment": "Can't someone just make their avatar icon into a female persona and tell this person, \"No\"?\n\nYes, taking a female person would be necessary to even begin down this road.", "id": "czb0bq9"}], [{"comment": "this will make Ruby illegal in Muslim countries and in Russia.", "id": "czbd9ug"}], [{"comment": "People are missing the meta-point to all this - you're not creating an environment of happiness, you're creating an environment of FEAR.", "id": "czbelvt"}], [{"comment": "I wonder what these SJWs would make of the old joke \"Ruby is Perl's younger, and prettier, sister\". ", "id": "czccqq3"}]]], "418q2q": ["Learn Software Security", "2016-01-16 18:01:41", 5, "http://www.codebashing.com/try-it", [[8, "This is a nice demo but it's a commercial product. Does this count as spam?\n\nanyway, hackthissite.org has a lot to teach for free"], [4, "doesn't it ask you for money after the first few 'taster' tasks?"], [1, "[deleted]"]], [[{"comment": "This is a nice demo but it's a commercial product. Does this count as spam?\n\nanyway, hackthissite.org has a lot to teach for free", "id": "cz0lq33"}, {"comment": ">  Does this count as spam?\n\nOP /u/blahb331 no longer exists.\n\nSo yes.", "id": "cz0pbab"}], [{"comment": "doesn't it ask you for money after the first few 'taster' tasks?", "id": "cz0lvr2"}, {"comment": "Unfortunately, yes. At least it provides a little insight but yea, I wish they would've mentioned this from the start.", "id": "cz0ois4"}], [{"comment": "[deleted]", "id": "cz0h7p2"}, {"comment": "it's spam.", "id": "cz0hl53"}, {"comment": "Ergo, it's probably spammed there too.", "id": "cz1d3vm"}]]], "530ryh": ["Useful for programmers: voucher \"grAPIboost\" adds 5000 credits on the free account and you can use the interface, the Rank Tracker API and others", "2016-09-16 11:16:59", 0, "https://www.georanker.com/ranktrackerapi", [[4, "5000 credits is actually a lot it seems; getting a report doesn't cost that much and initially a free account starts with only 500 credits. For whoever doesn't get it, you have to go to <Upgrade Account>, and at the bottom there's a \"Do you have a voucher?\" that needs to be clicked."], [0, "I'm not sure if an SEO API fits this subreddits' topic. Maybe borderline."], [-2, "This is spam."]], [[{"comment": "5000 credits is actually a lot it seems; getting a report doesn't cost that much and initially a free account starts with only 500 credits. For whoever doesn't get it, you have to go to <Upgrade Account>, and at the bottom there's a \"Do you have a voucher?\" that needs to be clicked.", "id": "d7oz0g0"}, {"comment": "r/HailCorporate/", "id": "d7pd1zs"}], [{"comment": "I'm not sure if an SEO API fits this subreddits' topic. Maybe borderline.", "id": "d7p21y3"}], [{"comment": "This is spam.", "id": "d7pdy6a"}]]], "49sqgf": ["6 reasons web developers need to learn JavaScript ES6 now", "2016-03-10 12:06:01", 0, "http://thenextweb.com/dd/2016/03/09/6-reasons-need-learn-javascript-es6-now-not-later/#gref", [], []], "50hhub": ["You're using HttpClient wrong and it is destabilizing your software", "2016-08-31 18:38:58", 1, "http://aspnetmonsters.com/2016/08/2016-08-27-httpclientwrong/", [[2, "For once, I'm glad I was writing bad code ;)"]], [[{"comment": "For once, I'm glad I was writing bad code ;)", "id": "d74ik7e"}]]], "4j0esb": ["Please do learn to code", "2016-05-12 16:24:42", 0, "https://medium.freecodecamp.com/please-do-learn-to-code-233597dd141c#.4rc9mn67m", [[3, "This article just tells you why coding is useful, not why it's necessary. Incidentally, plumbing is also useful, it's the way we talk to our water systems, but it's not necessary.\n\nMost humans talk to machines using GUIs, which we invented to make things easier. Only a small portion of people actually use scripts or code to do anything."], [2, "I'm not entirely sure I understand. MOST people talk to machines through user interfaces that programmers have created, and do not need to understand the mechanisms used to create those interfaces.\n\nKnowing how to \"talk to machines\" by knowing a few tricks of google's query system is very different from knowing how javascript's type system works.\n\nAnalogously, most Americans need to know how to drive, which they do through a carefully constructed interface designed for safety and convenience. Very few Americans actually need to know how the steering mechanism actually works."], [0, "[deleted]"], [-2, "Good read."]], [[{"comment": "This article just tells you why coding is useful, not why it's necessary. Incidentally, plumbing is also useful, it's the way we talk to our water systems, but it's not necessary.\n\nMost humans talk to machines using GUIs, which we invented to make things easier. Only a small portion of people actually use scripts or code to do anything.", "id": "d32xckr"}, {"comment": "> Only a small portion of people actually use scripts or code to do anything.\n\nWhat about Data Analysis?\n\nI write lots of scripts to calculate process execution time in embedded systems, and do stuff like graphing slocs/cyclomatic complexity for a codebase.  I also sometimes write small python scripts to grep things and generate a report.\n\nI also write Excel macros to help categorize my personal budget/spending (using data from Mint to e.g. generate monthly reports).\n\nAm I in the minority?", "id": "d32y8hu"}, {"comment": "> Am I in the minority?\r\n\r\nYes. Not even most people at my job know how to do that stuff and I work at a large webcompany. (where IT is not the biggest department).", "id": "d32yd24"}], [{"comment": "I'm not entirely sure I understand. MOST people talk to machines through user interfaces that programmers have created, and do not need to understand the mechanisms used to create those interfaces.\n\nKnowing how to \"talk to machines\" by knowing a few tricks of google's query system is very different from knowing how javascript's type system works.\n\nAnalogously, most Americans need to know how to drive, which they do through a carefully constructed interface designed for safety and convenience. Very few Americans actually need to know how the steering mechanism actually works.", "id": "d33bc6h"}], [{"comment": "[deleted]", "id": "d32mjl4"}, {"comment": "That's exactly what the article says", "id": "d32pp2h"}], [{"comment": "Good read.", "id": "d32lvy4"}]]], "470poo": ["The Little Language That Could", "2016-02-22 15:57:56", 0, "https://medium.com/p/the-little-language-that-could-61eaa62b5e0a", [[9, "It is getting to the point where I don't even bother reading things from Medium.com. This article may have been the last."], [4, "So far I've found Go to be more annoying than helpful.\n\nHowever, I love the compiler enforced formatting."]], [[{"comment": "It is getting to the point where I don't even bother reading things from Medium.com. This article may have been the last.", "id": "d09lsrk"}], [{"comment": "So far I've found Go to be more annoying than helpful.\n\nHowever, I love the compiler enforced formatting.", "id": "d09ahg8"}]]], "4aymnv": ["Twitter's Tech Stack - From JavaScript to Big Data", "2016-03-18 18:54:39", 7, "https://www.outlearn.com/learn/Teppo/twitter-dev-stack-from-javascript-to-big-data", [[6, "This is garbage. Completely uninformative and half of it requires a log in. "], [2, "Can someone explain why this website needs a loading page?"], [-11, "overall, great website"], [-16, "Great resource and insight ! "]], [[{"comment": "This is garbage. Completely uninformative and half of it requires a log in. ", "id": "d15isu1"}], [{"comment": "Can someone explain why this website needs a loading page?", "id": "d15oqwc"}], [{"comment": "overall, great website", "id": "d14t9id"}], [{"comment": "Great resource and insight ! ", "id": "d14lhoa"}]]], "4rfz30": ["Rant: Java 8 streams are too little too late", "2016-07-06 05:02:42", 34, "http://wrschneider.github.io/2016/06/26/java-8-too-little-too-late.html", [[70, "Meh. Coming back to python after a few months with java and kotlin, I have to say brevity is a code virtue I don't value too highly, if at all. I find myself looking at function signatures mostly these days and not bother reading the implementation. I just trust that the code does what the interface says. If I'm the one writing the implementation, I don't care how much ceremony I have to do (as long as it's reasonable). I only have to write it once. It's a problem of course if the language has no types. That's why I like kotlin: required types at the top level with little ceremony in the API."], [36, "    Stream.of(s.split(\",\")).map(Integer::parseInt).collect(Collectors.toList())\n\nAlmost half of this line is due to the `Collector` crud. If they had a convenience method, like they should, it'd be much shorter. Then if arrays had a `Collection` implementation, like they should, it'd be slightly shorter still.\n\n    s.split(\",\").stream().map(Integer::parseInt).toList()\n\nThat's not so bad, is it? It's just a shame we can't actually do this. It's nearly within the range of possibility for Java.\n\nEDIT: Regardless, Streams are still a very strong addition. Being able to pass streams around to compose collections of data efficiently is absolutely wonderful. I wouldn't say they're \"too little\". Just \"less than desired\"."], [19, "This makes me love C# even more.  I just find the C# way of doing stuff pretty awesome.  Java is pretty darn useful, but the syntax always seems clunky to me."], [13, "There is also http://www.javaslang.io/  for Java 8 that provides its own functional data structures with simpler sintax and better functional idioms."], [13, "The takeaway for me is this is false outrage clickbait. \n\nSo instead 300 bytes, now it takes 100 bytes, but he is peeved it isn't 80 bytes. "], [6, "Maybe I'm in the minority here, but of the examples the only one I actually find 100% clear and readable is the python list comprehension. I'd actually prefer the Java and C# versions to be written something like this:\n\n    List<Integer> result;\n    for (String x : s.split(\",\")) {\n        result.append(Integer::parseInt(x));\n    }\n\nIt's three more lines of code, and two extra type declarations, but it means that an unfamiliar reader scanning through the code can tell you the following two facts in literally half a second:\n\n1. We're building a list of integers.\n2. We're doing at least O(N) work in a loop.\n\nThose two facts are often important to me. Brevity is for the birds: write your code in a way that makes it easy to understand. The Java and C# versions require understanding the implementation of at least two library methods. The JavaScript version does too, but is probably the best way to write that code just because the alternatives all suck too (no foreach loops, etc).\n\nThe Python list comprehension is great because it is crystal clear, you learn every bit as much from a quick reading as you do the loop example above. That it is also brief is a nice bonus."], [5, "An article comparing Java and C#, is it still 2011?"], [1, "Huge C# fanboy and Java hater here, but honestly streams are not that bad.  So you have to do one extra step to get an \"enumerable\" from an array, and call a helper method to turn it back into a list at the end.  It really only hurts you in the simplest of examples where you one-line it all.  If you're doing more stuff, the meat of your code will be pretty much the same.\n\nI would probably have written the example like this:\n\n    List<int> result = Stream.of(s.split(\",\"))\n        .map(Integer::parseInt)\n        .collect(Collectors.toList());\n\nIt's really only the first and last lines that are affected.  The more stuff you put in the middle, the more similar it looks.  The lack of type inference in the above example bothers me more than the stream syntax."], [1, "The main thing that makes Java streams look verbose is the methods to convert collections to streams and streams back to collections.  I think the designers of the stream API did this on purpose because they wanted to clearly emphasize the barrier between streams and regular collections.  It makes the code a little more verbose, but I think it gives a lot more opportunity to optimize and forces users to write code that is amenable to those optimizations."], [1, "My main issue is not the verbosity, but that it is a royal pain to figure out how to use it, where all the classes and functions are for turning things into streams and back into collections. God help you if you want to stream an Array, I can never remember where the method to do that is. Googling gets you some horrible article on Oracle's site rather than the info you want 9 times out of 10.\n\nSo I'm left to rely Eclipse autocomplete and autoimport."], [1, "The major drawback in comparison with C# is that Java `Stream<T>` is akin to (yet-another) `IEnumerator<T>`, not `IEnumerable<T>`.  You'll notice the difference once you try to consume the same stream more than once.\n\nThe next major drawback is that in C# you can basically pass around any concrete generic collection as `IEnumerable<T>`, while in Java you must explicitly switch to streams.\n\nThe thing that actually looks the most like `IEnumerable<T>` is `Iterable<T>`, but although you can obtain a stream from it, you can't avoid boxing, e.g. there's no `IntIterable` like there's `IntStream`.  This shouldn't be a problem if you're getting streams from collections, since you'll have boxed values already.\n\nYou may be tempted to use `Iterable<T>` where `Stream<T>` is more common, to avoid the major drawbacks above.  However, the LINQ-like methods are on `Stream<T>`, so it doesn't really solve anything.\n\nAnd check out `flatMap()`, although it returns a new stream immediately, once it starts consuming its source, it tries to buffer all elements until the end instead of pipelining immediately, which is very problematic given a big collection, an I/O source or an infinite generator in any mapped stream.  Essentially, you can't short-circuit after `flatMap()`.\n\nSo, not only are streams too little too late, they're buggy and inferior to the existing art at the time of their creation."], [1, "rant: this is an ivory tower problem for most java devs who are still using 6 or 7 (because stability or entrenched or just not worth it).\nhttps://plumbr.eu/wp-content/uploads/2015/04/java-versions-2015.png"], [0, "In Groovy you've been able to do this for ages:\n\n    List<Integer> list = \"1,2,3\".split(',').collect{ Integer.parseInt(it) }\n\nIt's concise, clear and you can use typing if you want to. With simple things like this, Java feels extremely verbose in comparison."], [-6, "> Stream.of(s.split(\",\")).map(Integer::parseInt).collect(Collectors.toList())\n\nand how is this better than loop? Is it because it's new and sexy?"], [-8, "Its not too little too late.  It just sucks.  I like java and C# but streams are awful.  I'd rather use forloops the syntax is so bad.  I think streams will go the way of java beans, xpath and other good intentioned but failed patterns."]], [[{"comment": "Meh. Coming back to python after a few months with java and kotlin, I have to say brevity is a code virtue I don't value too highly, if at all. I find myself looking at function signatures mostly these days and not bother reading the implementation. I just trust that the code does what the interface says. If I'm the one writing the implementation, I don't care how much ceremony I have to do (as long as it's reasonable). I only have to write it once. It's a problem of course if the language has no types. That's why I like kotlin: required types at the top level with little ceremony in the API.", "id": "d50vtpt"}, {"comment": "I think Java hatred is coming full circle. I recently went back to Java for some new projects and suddenly realized how much I missed it. The reality of development is that you spend 95% of your time doing things other than typing, so the number of characters required to complete a task is pretty irrelevant. This is just something academics and religious nerds fight about but those of us with jobs and deadlines couldn't care less.\n\nFamiliarity is more important. Documentation is more important. Libraries are more important. Tools are more important. Java is still a leading competitor and will be for the foreseeable future. People just need to learn to deal with it.", "id": "d5124v7"}, {"comment": "It's not about how much text you have to type, it's about how much text you have to read. Boilerplate makes it harder to understand what the code is actually doing.", "id": "d512dml"}, {"comment": "No, it's not just about the quantity of text you have to read. There is a point of diminishing return where code that's too compact becomes harder to read.\n\n", "id": "d513389"}, {"comment": "why \u201cNo\u201d? your statement is completely compatible to /u/pavlik_enemy\u2019s, as he/she said:\n\n> Boilerplate makes it harder to understand\n\nit\u2019s not about the smartest, most elegant terse code, but about repeated-and-slightly-modified blocks.\n\nthose used to be the bane of java devs (idk how much they are still), and certainly are why i won\u2019t touch Go with a ten foot pole", "id": "d514lpd"}, {"comment": "Java encourages a lot of boilerplate hiding the intent of the code. Adding things like free functions would help a lot.", "id": "d513kp4"}, {"comment": "Obviously, it's not *only* about the amount of text.", "id": "d514x3u"}, {"comment": "I agree there's a point of diminishing and even negative return, but Java is pretty far from that, and languages like C# aren't past it.", "id": "d519wrn"}, {"comment": "It's usually not compact code that is the issue. But poor naming/documentation. Sometimes people will abbreviate their function/variable names past where they are informative.", "id": "d51pbmk"}, {"comment": "list comprehensions aren't exactly easy to understand, especially the more complex ones. Sometimes a for loop is actually better for readability because it better mimics how our mind works. And you always have to assume the next guy going over your code is an idiot that doesn't now list comprehensions, ternary operator and stuff like that.", "id": "d5160n8"}, {"comment": "> always have to assume the next guy going over your code is an idiot\n\nWhat else shouldn't we use? Generics? Exceptions? NIO? Futures?", "id": "d5170z2"}, {"comment": "Write it all in assembly\n\nWhen that idiot comes, he won't understand it, can't change it and thus won't break it", "id": "d51lq9l"}, {"comment": "> because it better mimics how our mind works\n\nany evidence for this? I think 1st language lerners have enough problems with iteration that this probably isn't true", "id": "d51bx1p"}, {"comment": "I think you just got into the habit of for loops. For me, LINQ like syntax is how I view modification of enumerables. Also assuming that the next guy is an idiot shouldn't necessarily limit what operators you use, it should just make you write clean code and not terrible hacks.", "id": "d51g8cn"}, {"comment": "Well the LINQ syntax in the example is about 100x times more readable than the Java equivalent but I don't use .net so that's abotu as much as I know about LINQ.\n\n```\nStream.of(s.split(\",\")).map(Integer::parseInt).collect(Collectors.toList()) \n```\n\nvs\n\n```\ns.Split(\",\").Select(int.Parse).ToList()\n```", "id": "d51i3uj"}, {"comment": "Yea the Java one is quite the mouth full. Shame they couldn't just copy LINQ, IMHO LINQ nailed it. ", "id": "d51uown"}, {"comment": "> it's about how much text you have to read\n\ntryapl.org", "id": "d5179kk"}, {"comment": "No it doesn't. Lack of familiarity with convention does. If you have spent years looking at Java code none of that matters. Mostly people who don't use Java everyday complain about Java. ", "id": "d51bgz0"}, {"comment": "> It's not about how much text you have to type, it's about how much text you have to read. Boilerplate makes it harder to understand what the code is actually doing.\n\nBrainf*ck anybody?", "id": "d51ps17"}, {"comment": "It's about how much text you have to read to get a gist of what's going on. You don't have to read the boilerplate if the point of the method is bolted on at the top.", "id": "d51zdei"}, {"comment": "Agreed. I like dynamic typing in certain circumstances, but declared types really need to be a requirement for APIs. It's one of my biggest frustrations when reading Ruby, Python, Groovy, etc. library docs.\n\nRuby's actually the worst of them, I swear half the Ruby libraries I've looked at have decided that \"documentation\" consists of listing worthless function signatures that tell me nothing and a link to the implementation.", "id": "d50y99g"}, {"comment": "by now i use [type annotations](https://docs.python.org/3/library/typing.html) for all my new python code.", "id": "d514odi"}, {"comment": "cc /u/mnjmn y'all should check out http://www.mypy-lang.org/", "id": "d50z8c6"}], [{"comment": "    Stream.of(s.split(\",\")).map(Integer::parseInt).collect(Collectors.toList())\n\nAlmost half of this line is due to the `Collector` crud. If they had a convenience method, like they should, it'd be much shorter. Then if arrays had a `Collection` implementation, like they should, it'd be slightly shorter still.\n\n    s.split(\",\").stream().map(Integer::parseInt).toList()\n\nThat's not so bad, is it? It's just a shame we can't actually do this. It's nearly within the range of possibility for Java.\n\nEDIT: Regardless, Streams are still a very strong addition. Being able to pass streams around to compose collections of data efficiently is absolutely wonderful. I wouldn't say they're \"too little\". Just \"less than desired\".", "id": "d50tyn8"}, {"comment": "If there was a convenience method for `toList()`, then we'd want one for `toSet()` and `toMap()` and eventually the entire `Collectors` class would be enclosed in the steam API.\n\nI think Java does a pretty good job of separating concerns and providing a robust API that doesn't try to be too much or guess what you want to do. With `Stream.collect()`, we can use or implement any type of collector we can imagine, and it doesn't look like a workaround or a second-class way of doing things.\n\nJava tends to be a bit verbose, but with that verbosity comes a lot of flexibility. I'm not saying it's perfect, but the trade-off never bothers me.", "id": "d50xf1b"}, {"comment": "I don't actually see any problem with having a convenience method for each of the default collectors. The usefulness of Collector is in the ability to define new ones; not the collection of default collectors", "id": "d50yljf"}, {"comment": "I suspect that convenience methods toList(), toSet(), and toArray() would cover almost all daily use of streams.\n", "id": "d50zhvi"}, {"comment": "Extension methods in Kotlin solve this problem. You can add a `.toList()` method to an existing type.", "id": "d510z2p"}, {"comment": "In C# as well, the .Net Framework ships with this extension method (as a part of LINQ) for anything that implements IEnumerable (~Java's stream). ", "id": "d515xaw"}, {"comment": "Type inference can solve it too. Similar thing in Rust:\n\n    let v : Vec<u32> = s.split(',').filter_map(|x| x.parse().ok()).collect();\n\n(In this case I decided to silently ignore items that fail parsing instead of failing with an error).\n\nSame with error handling on bad data:\n\n    let v : Result<Vec<u32>, _> = s.split(',').map(|x| x.parse()).collect();", "id": "d51czjq"}, {"comment": "Why doesn't this end up with a Vec<Result<u32,_>> if I might ask?", "id": "d51sv2y"}, {"comment": "Rust implements a collector from `Iterator<Result<T, E>>` into both `Vec<Result<T, E>>` as well as `Result<Vec<T>, E>`. Isn't that cool? :)", "id": "d51yho0"}, {"comment": "Good examples. I think this is more of a demonstration of the power of Rust's trait system than type inference. Java can infer a generic return type but it can't provide polymorphic behavior on it.", "id": "d51dgy8"}, {"comment": "Christ that's bad syntax.", "id": "d52eo2l"}, {"comment": "What makes it bad syntax?", "id": "d52h807"}, {"comment": "I don't know why people ask this question about Rust but just assume that Perl has bad syntax.", "id": "d52idv6"}, {"comment": "Sure. But you just replied to a comment which has pretty much exactly the same syntax as c# has. The only difference really here is the order of the type which is suffixed instead of prefixed.\n\nRust:\n\n```\nlet v : Result<Vec<u32>, T> = expr();\n```\n\nvs C#\n\n```\nResult<Vec<u32>, T> v = expr();\n```\n\nIs that what makes it bad syntax?", "id": "d52ih28"}, {"comment": "Except that's not the comparison. The expression in Rust is significantly more verbose than it would be in another language (and than it is in C# or Python or Haskell).\n\nHaving to express the type at all is frankly ridiculous. Expressing types on function signatures is fine, even in languages where that's optional people still do it. But here? Yuck.", "id": "d52il0b"}, {"comment": "You do not need to express the type in a larger function. In this self contained example it however clarifies it significantly because it works in isolation. ", "id": "d52jia2"}, {"comment": "Similarly, implicits in scala can as well. I think the consensus is that moving forward, no one really wants to deal with this how Java does. ", "id": "d51hgb5"}, {"comment": "Use a static import to get:\n\n    Stream.of(s.split(\",\")).map(Integer::parseInt).collect(toList()) \n", "id": "d512k55"}, {"comment": "But then you have to use static imports, which are forbidden in many code styles (for good reason).", "id": "d5144sl"}, {"comment": "> for good reason\n\nWhich is? If people want to use a more functional style, they'd better get used to static imports, which make perfect sense in that style.", "id": "d515no0"}, {"comment": "> If people want to use a more functional style, they'd better get used to static imports,\n\nReally, you define functional style by having a \"function\" name that is shorter (doesn't include the namespace/enclosing class)?   \n\nhttp://www.prdaily.com/Uploads/Public/i-do-not-think-it-means-what-you-think-it-means.jpg", "id": "d51pl58"}, {"comment": "Really, is that how you define \"define\"?\n\nhttp://www.prdaily.com/Uploads/Public/i-do-not-think-it-means-what-you-think-it-means.jpg\n\nIf in an OOP style it is acceptable to import the unit of abstraction, namely the class, so that its namespace need not be mentioned, in an FP style it must be acceptable to import the unit of abstraction, namely the function, so that its namespace (which, in Java, includes the name of the class where the function is defined as a static method) need not be mentioned. There is no good reason to forbid static imports if you want to use the functional style in Java.", "id": "d51qeyv"}, {"comment": "Static anything is hard to test. I prefer dependency injection instead as now I can mock other wise unmockable code. ", "id": "d51fq07"}, {"comment": "How and why would you test _import statements_?", "id": "d51nru9"}, {"comment": "You're not testing import statements. That's the purpose of DI. With injected mocks you can now test your code 100% independently from its dependencies. Without mocks this isn't possible. And DI is better than factories as you maintain a better separation of concerns. ", "id": "d51tmb1"}, {"comment": "You're going to use a static reference to the collector anyways. ", "id": "d51hi77"}, {"comment": "I was talking about why many coding styles forbid static imports. ", "id": "d51hyoo"}, {"comment": "Your specific comment that I replied to was about dependency injection, which is a separate topic...", "id": "d51jivp"}, {"comment": "No it's not. The reason you don't use static imports is because with them unit testing ONLY your code is now effectively impossible, as you are now testing your dependencies. This is where DI comes in, as you can now easily inject mocks. Boom, you can now unit test only your code. \n\nIf you want to static import things more power to you but you now can no longer unit test just YOUR code. In the case of importing things that are a part of the standard library more power to you as the standard library is so stable that it is worth the cost of having your unit tests covering other things. \n\nWithout having unit and integration tests CD is now impractical and your stuck wasting hours on deployment. \n\nIf you have any thoughts about how you can effectively test just your code and use static imports feel free to enlighten me. You might want to send your resume to all of the big 4 as they now all extensively rely on DI. ", "id": "d51ub4c"}, {"comment": "What the fuck are you talking about? With stream collectors, you're rarely going to inject them, and instead use them like Collectors.toList(), so it's not a big deal to use a static import in this case. \n\nEven further, if you're calling a static method anyways then it's by definition not instance specific, so injection is moot. ", "id": "d51ygtx"}, {"comment": "[deleted]", "id": "d51go35"}, {"comment": "If you have things set up correctly and you know your frameworks DI has a 0 readablilty cost. In fact it vastly improves it as you now have a separation of concerns with initialization of objects. \n\nDI enables bug free code as you can now easily do unit tests to ensure that modules work and integration tests to make sure modules interact correctly. Without DI it is very hard to test that every path works. Without DI you need factories ( or something like this ) to do unit tests for code that has any dependencies. \n\nI can assure you that in real world use cases DI doesn't lead to buggy code. See Google's guice. From my understanding it is used heavily internally. \n\nJava does allow you to mock at a level method. Look at the mockito framework. I'm not even a huge fan of Java but mockito is amazing. ", "id": "d51hksu"}, {"comment": "> bug free code \n\nFairytales.", "id": "d51vw6p"}, {"comment": "Well as far as I know this is the best way to create bug free code. I'm sure in 5 years from now we'll have something better. \n\nIf you have any ideas about how to make bug free code let me know. ", "id": "d5283d5"}, {"comment": "Assuming the code is viewed in an IDE (which is almost always the case with Java), then the actual definition of any variable or function is a mouse move away.  What _would_ be useful are _scoped static imports_, rather as you can have `using namespace foo` in a function body in C++.", "id": "d5165t5"}, {"comment": "I disagree thoroughly. It's often a lifesaver. Assert.*, mocks frameworks, verbose numerical APIs...", "id": "d5173t1"}, {"comment": "Terrifying how many people are defending static functions. They have no place in any devs arsonal as they make all unit tests into integration tests. (If you want to use some from standard libraries more power to you)", "id": "d51ug0e"}, {"comment": "no they don't, you just need to pass in the function as a dependency - same as any dependency injection", "id": "d52lyln"}, {"comment": "And why aren't all the .map() etc methods added as convenience to arrays and collections? .parallel() is hardly used anyway.\n\n    collection.map(...).toList()", "id": "d514cp3"}, {"comment": "In that case, I'd argue it's because we don't have higher kinded types to properly support Functors", "id": "d514i5w"}, {"comment": "> And why aren't all the .map() etc methods added as convenience to arrays and collections?\n\nI think it was in part due to worry of clashing with subclassed collections that already had them.", "id": "d514lnw"}, {"comment": "Sidenote: Parallel is not the only reason to use streams. Composing data structures with `flatMap` allows you to process data through a pipeline without having to allocate intermediate structures. It can be much more performant to use streams rather than mapping into then out of new lists that are just going to be immediately tossed.", "id": "d5153tg"}, {"comment": "Collections already have a .stream() method, which is at most a few extra characters.", "id": "d52dmy2"}, {"comment": "What about `Pattern#splitAsStream`?  Seems like any time you do a split in java, you're better off using a `Pattern` since under the hood, `String#split` compiles the delimiter as a regex anyway.", "id": "d51p8jt"}, {"comment": "In my projects I typically implement a class called \"Streams\" which mostly delegates one-to-one with the underlying stream, but I get to implement those verbose lines out. So my code looks like this:\n\n    Streams.of(a.split(\",\")).map(Integer::parseInt).toList();\n    Streams.of(a.split(\",\")).map(Integer::parseInt).toSet();\n\nIn addition to cleaning up the more verbose things, I can add my own methods to the API that I use all the time but don't want to wait for a future version of Java to implement:\n\n    // I can do this\n    Streams.of(tokens).contains(\"foo\");\n    // Instead of \n    tokens.stream().anyMatch(x -> Objects.equals(x, \"foo\"));\n\nMy code now passes Streams instances instead of Stream instances around and life is good - and when it's not, I can make it good. So yeah, the raw API is not as concise or complete as it could be, but wrap that up and you can make it as beautiful and robust as you like. ", "id": "d51jq5f"}, {"comment": "While it sucks to be verbose, putting each action on its own line increases readability and has the added benefit of being easier to debug.", "id": "d52dkh4"}, {"comment": "? I don't see any less readability or debug-ability in the \"improved\" line. In fact, I find it slightly more readable, since there are no nested parentheses.", "id": "d52dpml"}, {"comment": "The improved line is definitively more readable. I was just commenting that even the longer line is okay if you are willing to tolerate line breaks.", "id": "d52e4e1"}, {"comment": "Oh I see. I often just assume that comment replies on reddit are adversary =P My bad", "id": "d52e8z5"}, {"comment": "It should just be `s.split(\",\").map(parseInt).toList`.", "id": "d52eniw"}, {"comment": "\"Should\"? I don't totally agree. I dislike the notion of representing parameter-less method calls without parentheses in a language that otherwise always uses parentheses for method calls. It's just a silly inconsistency. And having `parseInt` without declaring the `Integer` namespace is quite contrary to Java's philosophy. If Java weren't rooted in this convention that everything is an object, I'd agree that being able to use functions as fundamental particles would be better. But since everything in Java is objects and classes, I think it makes more sense to namespace things by those objects and classes. Finally, it's somewhat obscure to have `split` return a `Stream`. If `split` is just going to construct a collection and return `internalCollection.stream()`, then it's strictly more powerful to simply return that collection, with zero drawbacks, except that users need to call `stream()`. I just think `Stream` is the more obscure thing to return in this case.", "id": "d52g2lp"}, {"comment": ">\"Should\"? I don't totally agree. I dislike the notion of representing parameter-less method calls without parentheses in a language that otherwise always uses parentheses for method calls.\n\nA function with no arguments is semantically equivalent to its return value, though.\n\n>And having parseInt without declaring the Integer namespace is quite contrary to Java's philosophy.\n\nJava's philosophy is crap, then.\n\n>Finally, it's somewhat obscure to have split return a Stream. If split is just going to construct a collection and return internalCollection.stream(), then it's strictly more powerful to simply return that collection, with zero drawbacks, except that users need to call stream(). I just think Stream is the more obscure thing to return in this case.\n\nIt's strictly more powerful to return a stream. Collect it into a collection if you wish. ", "id": "d52g53v"}, {"comment": "> A function with no arguments is semantically equivalent to its return value, though.\n\nNot even close in a language without referential transparency. Not by a long shot.\n\n> Java's philosophy is crap, then.\n\nI'd agree. But that doesn't mean we should write Java as though it's not Java.\n\n> It's strictly more powerful to return a stream. Collect it into a collection if you wish.\n\nNo. If I return `x.y()`, it is always strictly more powerful to return `x`, as that gives the receiver the same access by manually calling `y()`, and some extra by allowing them to use `x` itself. Forcing the user to collect the stream themselves is redundant and wastes memory / clock cycles.", "id": "d52gadz"}, {"comment": ">No. If I return x.y(), it is always strictly more powerful to return x, as that gives the receiver the same access by manually calling y(), and some extra by allowing them to use x itself. Forcing the user to collect the stream themselves is redundant and wastes memory / clock cycles.\n\nExcept that in general, when you're returning a stream in nearly all circumstances that's the natural object to return. To return a collection means first collecting the stream. \n\nYou're advocating returning `x` instead of `x.y()`. What you don't realise is that in nearly all situations, `x` is actually `y.x()`, and you end up advocating `y.x()` over `y.x().y()`, which is a bad comparison. I'm not advocating `x.y()`, I'm just advocating `y`. Streams are natural. Collections are not. ", "id": "d52ihmh"}, {"comment": "If a variant of `strip` were implemented in terms of `Stream`, I suppose you'd be right. But I'm not totally sure that this would be the natural implementation.", "id": "d52imv9"}, {"comment": "The difference between the two is pretty semantically important. Modifying an existing collection should be explicit. It really should be (if such a thing were syntactically possible in Java) possible to distinguish between\n\n    let stream = whatever.strip(); // and\n    whatever.strip!();", "id": "d52iqeh"}, {"comment": "That doesn't seem at all related. Where does mutation come into play here? `strip` is not a mutating method (not that it could be, since `String` is treated as an immutable class).", "id": "d52itu5"}, {"comment": "I dunno why I wrote that, I meant:\n\n    // partially obscured view of original\n    let stream = whatever.strip();\n\n    // new collection\n    let coll = whatever.strip!(); ", "id": "d52ni3k"}], [{"comment": "This makes me love C# even more.  I just find the C# way of doing stuff pretty awesome.  Java is pretty darn useful, but the syntax always seems clunky to me.", "id": "d50udu4"}, {"comment": "Then you should like Kotlin too:\n\n    \"1,2,3\".split(',').map { it.toInt() }\n\n_Update_: Improved the snippet.\n", "id": "d50uqac"}, {"comment": "[deleted]", "id": "d50z69n"}, {"comment": "or haskell:\n\n    map (read :: String->Int) $ splitOn \",\" \"1,2,3\"", "id": "d5112vp"}, {"comment": "or Perl\n\n    split ',', '1,2,3'\n", "id": "d517cwn"}, {"comment": "Or XPath/XQuery\n\n    \"1,2,3\" => tokenize(\",\") ! xs:integer(.)", "id": "d51fpv8"}, {"comment": "> split ',', '1,2,3'\n\nthats not the same thing as any of the above implementations", "id": "d51bm72"}, {"comment": "You just don't need explicit string-to-int conversion in Perl that is performed on demand.\n\n    perl -e 'print join \", \", map { $_ + 1 } split \",\", \"1,2,3\"'\n\n    > 2, 3, 4\n\nIf you need to check the string to be sure the conversion is possible, there is standard Scalar::Util module, which exports a function called looks_like_number( ) that uses the Perl compiler's own internal function of the same name.", "id": "d51cfwx"}, {"comment": "nevermind..", "id": "d52cqx6"}, {"comment": "> haskell\n\n    map (read @Int) (splitOn \",\" \"1,2,3\")\n\nvs\n\n    read @Int <$> splitOn \",\" \"1,2,3\"\n\nvs\n\n    [ read @Int num | num <- splitOn \",\" \"1,2,3\" ]\n", "id": "d51qwqe"}, {"comment": "thanks for the added extra, the @Int def cleaner; I like that middle one the most", "id": "d52ccsh"}, {"comment": "or Clojure:\n\n    (for [i (.split \"1,2,3\" \",\")] (Integer/parseInt i))", "id": "d510k3m"}, {"comment": "Or:\n\n    (map read-string (clojure.string/split \"1, 2, 3\" #\",\"))", "id": "d51md2z"}, {"comment": "Note that using `read-string` is kinda dangerous in general since it can execute code.", "id": "d51on0v"}, {"comment": "For Kotlin and Scala folks: Does this result in two collections being allocated? My fellow sibling commenters' examples in Haskell and Clojure are don't.", "id": "d5165ri"}, {"comment": "> Does this result in two collections being allocated?\n\nAs far as I remember, that's the case in Scala. If you're doing something like `xs.filter(_ > 0).map { x => x + 1 }.filter { x % 2 == 0 }.take(1)` where `xs` is an Array, List or Vector, a new collection will be allocated at each step. There is alsow a stream class that does lazy evaluation.\n\nIn C# all this stuff is lazily evaluated but it won't preserve types, converting everything to `IEnumerbale<T>`", "id": "d5197cn"}, {"comment": "I haven't worked with Scala for a while, so I don't remember the semantics. I think I can only answer with regards to Kotlin. I believe the above will allocate two collections. If you want to avoid that, you can do\n\n    \"1,2,3\".splitToSequence(\",\").map { it.toInt() }\n\nwhich returns a Sequence<Int>. In Kotlin, Sequence<T> represents a lazily evaluated collection, whereas composable operations on Iterable<T> will create intermediate allocations.\n\nI believe the distinction is there because in the vast majority of cases, creating intermediaries is not a performance issue, and it's a little more convenient to work with iterables rather than sequences. Hopefully someone can correct me if I'm wrong about this.\n\nEdit: The following Stackoverflow post seems to give some details for the reasons behind the distinction: http://stackoverflow.com/questions/35629159/kotlins-iterable-and-sequence-look-exactly-same-why-are-two-types-required", "id": "d518x0m"}, {"comment": "Or Javascript:\n\n    \"1,2,3\".split(\",\").map(Number)\n\n... No? Not Javascript?", "id": "d5154x3"}, {"comment": "That is nice!", "id": "d50uzmi"}, {"comment": "toInt() has been in the standard library since I've been using Kotlin (1.0).", "id": "d510trc"}, {"comment": "Doh, how did I miss that. I updated my post.\n\nThanks!\n", "id": "d5119hf"}, {"comment": "change `\",\"` to `','` for even faster code.  Sadly the double-quotes version compiles a regex under the hood.", "id": "d51pf9n"}, {"comment": "Good point, I updated the snippet. Thanks!", "id": "d51tklb"}, {"comment": "Does that use an external iterator, or does it create a new intermediate collection on each transformation?", "id": "d50zke5"}, {"comment": "External iterator.  Map etc. are extension methods on Iterable.", "id": "d510uwr"}, {"comment": "When is does it know to yield into a collection then? Is it lazily done when the value is accessed?", "id": "d515wzs"}, {"comment": "nostrademons is wrong about this. map() and similar return List<T>, so it will create intermediaries. See my comment above: https://www.reddit.com/r/programming/comments/4rfz30/rant_java_8_streams_are_too_little_too_late/d518x0m", "id": "d5190nb"}, {"comment": "Can you also get a counter within that map method?", "id": "d510pj8"}, {"comment": "Yup:\n\n    listOf(\"1\",\"2\").mapIndexed { index, value -> println(\"Index: $index value: $value\") }", "id": "d511f9h"}, {"comment": "Coolio!", "id": "d514clo"}, {"comment": "Just gonna plug Scala too: `\"1,2,3\" split ',' map (_.toInt)`", "id": "d50z5k9"}, {"comment": "Interesting how similar the Kotlin is:\n    \"1,2,3\".split(\",\").map { it.toInt() }", "id": "d511nuc"}, {"comment": "Or Rust `\"1,2,3\".split(',').map(str::parse)`    \nThe Type it's parsing to is inferred automatically (from how the resulting iterator is used).", "id": "d515s68"}, {"comment": "In the interests of honesty, note that this returns an iterator - to do the equivalent as the Java example you need to call `.collect()`. The difference is that Rust has better type inference, so usually it can infer the method of collection rather than having to specify it explicitly, eg:\n\n\n    fn vec123() -> Vec<i32> {\n        \"1,2,3\".split(',').map(str::parse).collect()\n    }", "id": "d51619u"}, {"comment": "That won't compile though, `str::parse` returns a Result, so you need to return a `Vec<Result<i32, ParseIntError>>` or a `Result<Vec<i32>, ParseIntError>` (because `Result` implements `FromIterator` by converting an iterator of results into a Result of FromIterators).", "id": "d51aq26"}, {"comment": "Oh, deuhh. Interesting how all the other languages gloss over that complexity.", "id": "d51atvh"}, {"comment": "Most of them use exception-based error reporting so they'll just blow up when they actually perform the conversion\n\nC# actually allows that distinction (with tryparse which is what you'd normally use to convert to ints) but that's really inconvenient for this specific case. ", "id": "d51b8m6"}, {"comment": "That's probably only one of about 15 one liners possible in Scala, amirite?", "id": "d51cgdh"}, {"comment": "Lol. Sure bud.", "id": "d51g3bm"}, {"comment": "Sure, you can also do `for (ch <- \"1,2,3\".split(\",\")) yield ch.toInt`.\n\nThen again, if you're so inclined you can do the equivalent in C# with `(from ch in \"1,2,3\".Split(',') select int.Parse(ch)).ToArray()`.\n\nMost languages have several ways of doing the same thing :)", "id": "d52lfzv"}, {"comment": "Ruby : \n\n    \"1,2,3,4\".split(/,/).map(&:to_i)", "id": "d51k16m"}, {"comment": "Why use a regular expression? Would it not be faster to do this?\n\n    \"1,2,3,4\".split(',').map(&:to_i)", "id": "d51rcrj"}, {"comment": "Yep, splitting on a string should be better. ", "id": "d51rym8"}, {"comment": "> This makes me love C# even more. I just find the C# way of doing stuff pretty awesome. Java is pretty darn useful, but the syntax always seems clunky to me.\n\nC# came a lot later, was based on Java so it obviously would have better syntax.  However it has a hell of a way to go before it's remotely as practical a platfrom.", "id": "d510wrr"}, {"comment": "I'd wager C# is already there. I guess you're referring to the ecosystem that is weaker than Java's.", "id": "d5131m4"}, {"comment": "C# in .NET 2.0 was pretty much identical to Java it was the introduction of Linq and more lambda features that brought C# past Java, in my eyes.\n\n>However it has a hell of a way to go before it's remotely as practical a platfrom.\n\nWait, what? Saying C# isn't practical?", "id": "d518omj"}, {"comment": "For web, for linux, you are correct, but C# is insanely useful where windows server or windows desktop is the deployment target.    \n\nMicrosoft seems a bit late to the .net cross platform game but they're seeking to make up for lost time now, and it's ironic that now it's Java that seems stalled. Java 8 is in a cycle of delays, and Java EE is stalled completely.\n\nI respect how insanely awesome the Java ecosystem of today really is, and how highly evolved it is, as an enterprise software platform.  It's just the java language standard which is irritatingly slow to move forward.\n", "id": "d51ce9o"}, {"comment": "LINQ was released almost a decade ago (2007) and it's still less verbose than Java's offering. With that much lead time you'd think that Java could improve LINQ like C# improved Java.", "id": "d51om15"}, {"comment": "If you don't care about backward compatibility, sure.   But lucky for us they do.", "id": "d51pbb9"}, {"comment": "Not free software tho.\n\nedit: I stand corrected, I am not actually sure if C# and all the stuff that you need for it is free(dom) software. Apache 2.0 is actually [okay](https://www.gnu.org/licenses/license-list.en.html).\n\nI hastily jumped on this comment since I generally don't trush Microsoft which is not good. In any case, everybody should be vigilant. Found this old aritcle which I wonder if it's still true:\n\n**C# is full of loopholes**: https://www.fsf.org/news/2009-07-mscp-mono", "id": "d50w5z3"}, {"comment": "C# is an ECMA and ISO standard, the Roslyn compiler is Apache licensed, mono is MIT and coreclr is MIT...\n\nWhat's not free?", "id": "d50x7oi"}, {"comment": "People are slow to trust Microsoft and quick to forget that Oracle acquired Sun and Java. Given both of their histories, I don't think that the caution around Microsoft is undeserved, but Oracle has gotten a good look at their old playbook as Microsoft has tried to become more like Google/Apple.", "id": "d5115pe"}, {"comment": "The Mono runtime, compilers and tools and most of the class libraries are licensed under the MIT license.\n\n\"Note that as of March 31st, 2016 the Mono runtime and tools have been relicensed to the MIT license.\"\n\nhttp://www.mono-project.com/docs/faq/licensing/", "id": "d510j2p"}, {"comment": "What is not free software? C# or Kotlin?\n\nC# is certainly Open Source (though I guess you could argue that Apache 2.0 is not \"free software\" in the way that the FSF means it).\nhttps://github.com/dotnet/roslyn\n\nIf that is what you mean, Kotlin has the exact same problem as it is also Apache 2.0 licensed:\nhttps://github.com/jetbrains/kotlin\n\nPersonally, I would much rather have Apache 2.0 over GPL. Apache even includes an explicit patent grant.\n", "id": "d50xv5x"}, {"comment": "[deleted]", "id": "d51agvi"}, {"comment": "free as in freedom defined by fsf.org?", "id": "d51j82t"}, {"comment": "You quote a 2009 article about Mono/C# now that Roslyn full C# 6 parser, compiler, and the full .net runtimes are open sourced?  And then there's asp.net core and .net core which is a full microsoft supported runtime for .net on Linux, Windows, and Mac.    Who cares about the 2009-era mono C# compiler?\n\nThese days Microsoft will fix any problem in the Mono compiler if it affects their premier Xamarin customers, but it's not likely it matters, since for server side development,  the effort from Microsoft is on .net core, and Roslyn.", "id": "d51chnm"}, {"comment": "[deleted]", "id": "d50wnoh"}, {"comment": "> it is if you have a .edu address\n\nHow long do you plan to be at a (non-alumni) .edu?", "id": "d510yt6"}], [{"comment": "There is also http://www.javaslang.io/  for Java 8 that provides its own functional data structures with simpler sintax and better functional idioms.", "id": "d50xhu5"}, {"comment": "Wow! This will definitely be my go-to in Java.", "id": "d50zaxp"}, {"comment": "Wow, that is nice.\n\n    java.util.List<Integer> result = iterator.map(String::length).toJavaList();\n\nAll they need to add is *var* instead of *java.util.List<Integer>* and it would be as friendly as C# (or Kotlin).", "id": "d510p8r"}, {"comment": "lombok?", "id": "d5145j3"}, {"comment": "Yep Lombok's Val is amazing", "id": "d51fs4v"}, {"comment": "There is a JEP for that now: http://openjdk.java.net/jeps/286 . With a little bit of luck, java 10 will have it.", "id": "d518805"}], [{"comment": "The takeaway for me is this is false outrage clickbait. \n\nSo instead 300 bytes, now it takes 100 bytes, but he is peeved it isn't 80 bytes. ", "id": "d516rty"}, {"comment": "[deleted]", "id": "d51glh3"}, {"comment": ">Or rather, it's 100 bytes multiplied by the number of times you want to process a collection in your career as a Java programmer.\n\n100 * 0 = 0", "id": "d52es4m"}], [{"comment": "Maybe I'm in the minority here, but of the examples the only one I actually find 100% clear and readable is the python list comprehension. I'd actually prefer the Java and C# versions to be written something like this:\n\n    List<Integer> result;\n    for (String x : s.split(\",\")) {\n        result.append(Integer::parseInt(x));\n    }\n\nIt's three more lines of code, and two extra type declarations, but it means that an unfamiliar reader scanning through the code can tell you the following two facts in literally half a second:\n\n1. We're building a list of integers.\n2. We're doing at least O(N) work in a loop.\n\nThose two facts are often important to me. Brevity is for the birds: write your code in a way that makes it easy to understand. The Java and C# versions require understanding the implementation of at least two library methods. The JavaScript version does too, but is probably the best way to write that code just because the alternatives all suck too (no foreach loops, etc).\n\nThe Python list comprehension is great because it is crystal clear, you learn every bit as much from a quick reading as you do the loop example above. That it is also brief is a nice bonus.", "id": "d514gtl"}, {"comment": "It's imperative style. It's mutable. It's not as multiprocessing-friendly. It loses semantic information. \n\nFunctional style may hide how things are done, but they show what is meant much better. And that is a much more important separation of concerns. ", "id": "d516pcv"}, {"comment": "> It's imperative style. It's mutable.\n\nYes, it is both of those things, but the mutability is very very local. When the loop concludes \"result\" will have a value that can be used immutably (or not).\n\n> It's not as multiprocessing-friendly.\n\nWhy not? This is a tight loop; no implementation of .map() should be silently introducing multi-processing either. The best implementation of this algorithm on any x86 or ARM processor is going to be roughly the same: keep the Integer::parseInt code hot in one CPU's instruction cache and iterate over the block of memory pointed to by s.split(). If there's anything this code is missing it's that .collect() or friends might be able to pre-allocate memory for the result instead of reallocating while appending, but this sounds like a premature optimization.\n\n> It loses semantic information.\n\nWhat information? The fact that \"result\" is a pure element-wise function of the input?\n\n1. This kind of thing in my experience is likely to change doing routine maintenance anyways. e.g. \"It would be useful to also know how many inputs are empty, please count them.\"\n2. You have the same problem with the .map().collect() versions as well. You still need to parse all of the code. Are you sure the callback you passed to .map() is a pure function and not a closure over some state?\n3. It's really not that difficult to reconstruct this information. Even if a loop gets long and hairy, all of its complexity is self-evident and in one place. This makes maintenance easy in my experience, even if the code has the potential to be less structured.\n\nI get that .map() implies more semantic information than a for-loop, because .map() is more restrictive. But the trade-off here is that as a reader I am stuck internalizing and recalling the pre- and post-conditions of a whole bunch of library functions like .map(), .reduce(), .filter() and .collect() instead of a single language construct.", "id": "d51p37e"}, {"comment": "map is just as good indicator that we are in O(n) as for when you are used to it", "id": "d5174by"}, {"comment": "> at least O(N) \n\nAt least O(N) pretty much means \"at least at most N\", as big-O denotes the upper boundaries of a function. If you perform at least N operations, you can write \u03a9(N) :)", "id": "d517huj"}, {"comment": "Good point. Though the common use of O(N) to mean \"approximate complexity\" and the rarity of \u03a9(N) means I think my way might be clearer, even if \"at least O(N)\" is something of a vacuous statement to a mathematician.\n\nThe best might be \"at least ~N\" since what I intend is \"\u0398(N), with other terms independent of N that may or not be significant in practice\".", "id": "d51pfmg"}], [{"comment": "An article comparing Java and C#, is it still 2011?", "id": "d5150f2"}], [{"comment": "Huge C# fanboy and Java hater here, but honestly streams are not that bad.  So you have to do one extra step to get an \"enumerable\" from an array, and call a helper method to turn it back into a list at the end.  It really only hurts you in the simplest of examples where you one-line it all.  If you're doing more stuff, the meat of your code will be pretty much the same.\n\nI would probably have written the example like this:\n\n    List<int> result = Stream.of(s.split(\",\"))\n        .map(Integer::parseInt)\n        .collect(Collectors.toList());\n\nIt's really only the first and last lines that are affected.  The more stuff you put in the middle, the more similar it looks.  The lack of type inference in the above example bothers me more than the stream syntax.", "id": "d51a5t3"}], [{"comment": "The main thing that makes Java streams look verbose is the methods to convert collections to streams and streams back to collections.  I think the designers of the stream API did this on purpose because they wanted to clearly emphasize the barrier between streams and regular collections.  It makes the code a little more verbose, but I think it gives a lot more opportunity to optimize and forces users to write code that is amenable to those optimizations.", "id": "d51d4mq"}], [{"comment": "My main issue is not the verbosity, but that it is a royal pain to figure out how to use it, where all the classes and functions are for turning things into streams and back into collections. God help you if you want to stream an Array, I can never remember where the method to do that is. Googling gets you some horrible article on Oracle's site rather than the info you want 9 times out of 10.\n\nSo I'm left to rely Eclipse autocomplete and autoimport.", "id": "d51d5wr"}], [{"comment": "The major drawback in comparison with C# is that Java `Stream<T>` is akin to (yet-another) `IEnumerator<T>`, not `IEnumerable<T>`.  You'll notice the difference once you try to consume the same stream more than once.\n\nThe next major drawback is that in C# you can basically pass around any concrete generic collection as `IEnumerable<T>`, while in Java you must explicitly switch to streams.\n\nThe thing that actually looks the most like `IEnumerable<T>` is `Iterable<T>`, but although you can obtain a stream from it, you can't avoid boxing, e.g. there's no `IntIterable` like there's `IntStream`.  This shouldn't be a problem if you're getting streams from collections, since you'll have boxed values already.\n\nYou may be tempted to use `Iterable<T>` where `Stream<T>` is more common, to avoid the major drawbacks above.  However, the LINQ-like methods are on `Stream<T>`, so it doesn't really solve anything.\n\nAnd check out `flatMap()`, although it returns a new stream immediately, once it starts consuming its source, it tries to buffer all elements until the end instead of pipelining immediately, which is very problematic given a big collection, an I/O source or an infinite generator in any mapped stream.  Essentially, you can't short-circuit after `flatMap()`.\n\nSo, not only are streams too little too late, they're buggy and inferior to the existing art at the time of their creation.", "id": "d51p34y"}], [{"comment": "rant: this is an ivory tower problem for most java devs who are still using 6 or 7 (because stability or entrenched or just not worth it).\nhttps://plumbr.eu/wp-content/uploads/2015/04/java-versions-2015.png", "id": "d5224xv"}], [{"comment": "In Groovy you've been able to do this for ages:\n\n    List<Integer> list = \"1,2,3\".split(',').collect{ Integer.parseInt(it) }\n\nIt's concise, clear and you can use typing if you want to. With simple things like this, Java feels extremely verbose in comparison.", "id": "d51avhi"}], [{"comment": "> Stream.of(s.split(\",\")).map(Integer::parseInt).collect(Collectors.toList())\n\nand how is this better than loop? Is it because it's new and sexy?", "id": "d5185rr"}, {"comment": "Well, it's achieving same result as loop with much less code, without compromising readability (arguably enhanced readability) and it can be parallelized simply by adding .parallel() before map.", "id": "d518rem"}, {"comment": "it's 76 bytes vs. 86 bytes (with unnecessary spaces removed), so it's not \"much less code.\"\n\nAs for readability, I personally like the loop better but only because that's what I'm \"used\" to seeing (just like many other developers).  As for making it operate in parallel, unless you're working on a single-core CPU, the CPU will context switch out when it wants.  And, if you're trying to make a long running process operate in parallel, then you can spin up a Thread (and yes, I realize it can take a few more lines of code to do that).\n\nThat said, I like the streams API and will use it for some brevity for menial tasks like the example.  But I'd also say that neither method seems terribly wrong depending on your situation.  I also type over 100wpm so adding an extra 10 bytes doesn't bother me.\n", "id": "d51adpa"}, {"comment": "When you start writing complicated data processing routines, streams greatly enhance readability. You can see in a few lines a step by step description of the \"pipeline\" the data flows through, rather than three or four independent for loops.", "id": "d52duns"}, {"comment": "It's neither new nor sexy.", "id": "d52ewli"}, {"comment": "what was point of your comment?\nquestion was - how is this better than loop?\nand your answer - \"It's neither new nor sexy.\", that's why it's better than loop?\n", "id": "d52kqxs"}, {"comment": "Your implication was that it was new and sexy. I disagree.", "id": "d52nh7e"}, {"comment": "not exactly, it was my surprise, that it might be \"better\" and only reason I could think that some people would see it as \"new and sexy\" (as most functional programming features, that aren't really new).", "id": "d53y3cu"}, {"comment": "Functional programming is not just popular because it's new, it's popular because it's objectively better.", "id": "d540p13"}, {"comment": "lol, yea right, another silver bullet. I guess it's so good it's even not silver, but golden..", "id": "d540xlq"}], [{"comment": "Its not too little too late.  It just sucks.  I like java and C# but streams are awful.  I'd rather use forloops the syntax is so bad.  I think streams will go the way of java beans, xpath and other good intentioned but failed patterns.", "id": "d513ste"}]]], "4nbhgp": ["Code is Suffering", "2016-06-09 20:04:42", 1, "https://dev.to/ben/code-is-suffering", [[24, "The hell is the point of this article? \"Quit your job\"? \"Kill yourself, programmer\"? What a pile of angsty bs."], [7, "Is this part of the four noble truths of Codism?"], [4, "The guy works with JS and rails. No wonder he thinks all code is pain."], [2, "The first thing I say to anyone who says they want to learn how to program is: Don't. It's horrible. Whatever you're doing now will probably lead you to a more fulfilled life than programming ever will. "], [1, "No matter how well you abstract your code, there will always remain one abstraction leak - performance.\n\nPerformance is the ultimate abstraction leak: it never goes away entirely, and only intensifies as you climb the abstraction ladder."]], [[{"comment": "The hell is the point of this article? \"Quit your job\"? \"Kill yourself, programmer\"? What a pile of angsty bs.", "id": "d42h6ra"}, {"comment": "Heh...it reads like my high school writing assignments. Goth was so deep then. ", "id": "d42ikum"}], [{"comment": "Is this part of the four noble truths of Codism?", "id": "d42h4bp"}, {"comment": "That was idea I was riffing off.", "id": "d42hfml"}, {"comment": "I think a better title would have been \"Coding is suffering\". The original title is was misleading for me. I expected another rant on things that are awfully wrong with code these days. Instead I got something else... I don't know what.", "id": "d43qq34"}], [{"comment": "The guy works with JS and rails. No wonder he thinks all code is pain.", "id": "d430slb"}, {"comment": "Herein lies the truth", "id": "d43ddxo"}], [{"comment": "The first thing I say to anyone who says they want to learn how to program is: Don't. It's horrible. Whatever you're doing now will probably lead you to a more fulfilled life than programming ever will. ", "id": "d42g532"}, {"comment": "that's why we get paid the big bucks.", "id": "d42garb"}, {"comment": "I have not seen these big bucks unfortunately :(", "id": "d42ldnv"}, {"comment": "You have stake out a good spot early in the morning, preferably down-wind, and be sure to conceal yourself with good camo. Stay quiet, lest you spook them. This is only sufficient to see the big bucks, so obviously your lack of negotiation skills will keep you underpaid relative to your coworkers.\n\nTo actually bring in the big bucks, you're going to have to own a good rifle and a truck.", "id": "d43hl0v"}, {"comment": "... Because people lie to keep people away and thus perpetuate the scarcity of programmers", "id": "d42gd3x"}, {"comment": "I was half kidding. I know most devs are not making big bux. We enjoy the pain!", "id": "d42gnkd"}, {"comment": "Bullshit. It's people trying to remove that natural scarcity for their own profit that would perpetuate complete misinformation like that.", "id": "d42ggak"}, {"comment": "Exactly.", "id": "d42gsdr"}, {"comment": "I think it highly depends on the person. There are definitely people who could never possibly find software development fulfilling. But then there are others like me, who find little to be more fulfilling than picking apart and solving tough problems.\n\nYes, not all of my job is made up of the \"solving tough problems\" bit that I love so much. But that could be said of any job. Every job involves tedium, the undesirable, the lackluster. There's a reason its called work. Very few people find every part of their career enjoyable and exciting.\n\nAt the end of the day, the question is: is it worth it? And by \"it,\" I mean the full package. A mostly fun job can be worth it, even with little pay. More difficult and stressful jobs may require higher pay, or other benefits, to be worth it.\n\nI think software development is *absolutely* worth it to those who have the knack and interest in it. I'd say it doesn't hurt for others to try it out either. And even though it can be hard and frustrating, that doesn't mean it can't also be enjoyable.\n\nPay aside, I enjoy being a software developer. I often solve coding challenges or work on personal project with absolutely no reward on the line. I simply enjoy the work.", "id": "d42haly"}, {"comment": "Learning how to program is totally fine, I encourage it actually. Making a career out of it expecting to become uber successful, or much more than a normal job, is unrealistic.\n\nI do it because I like the challenge of it, despite the complications that come with it. I'm fine with a programming job, I don't expect much, I just want to do something that I can enjoy at least part of the time.", "id": "d42ggaf"}, {"comment": "The first thing I say to anyone who says they want to learn how to /name of skill/ is: Don't. It's horrible. Whatever you're doing now will probably lead you to a more fulfilled life than /name of skill + ing/ ever will.", "id": "d42jeup"}, {"comment": "I second this advice: Do not go into the software development industry.", "id": "d42gpzb"}, {"comment": "just not web development\n\n\n", "id": "d42h918"}, {"comment": "But web developer have much better chances at working from home", "id": "d43ll88"}, {"comment": "That is not always a good thing!!!\n\n", "id": "d43mfa3"}], [{"comment": "No matter how well you abstract your code, there will always remain one abstraction leak - performance.\n\nPerformance is the ultimate abstraction leak: it never goes away entirely, and only intensifies as you climb the abstraction ladder.", "id": "d42qmno"}]]], "4hysna": ["What is the best programming language? Puzzle, puzzle, puzzle!", "2016-05-05 10:48:22", 4, "http://whatisthebestprogramminglanguage.com/", [[11, "One of two options.\n\n1. The language you are currently using  \n2. The language you are not currently using."], [4, "The brainfuck code becomes this:\n\n$A='A';$B='B';$C='C';$D='D';$E='E';$F='F';$G='G';$H='H';$I='I';$J='J';$K='K';$L='L';$M='M';$N='N';$O='O';$P='P';$Q='Q';$R='R';$S='S';$T='T';$U='U';$V='V';$W='W';$X='X';$Y='Y';$Z='Z';$a='a';$b='b';$c='c';$d='d';$e='e';$f='f';$g='g';$h='h';$i='i';$j='j';$k='k';$l='l';$m='m';$n='n';$o='o';$p='p';$q='q';$r='r';$s='s';$t='t';$u='u';$v='v';$w='w';$x='x';$y='y';$z='z';echo \"${H}4${s}${I}${C}${J}${B}${Q}${z}${F}${Y}${A}${A}3${d}${h}${d}${A}${C}${l}${U}${m}1${L}${w}${z}${A}${Q}/${i}2${m}${w}${t}${J}${b}${W}${y}${r}${K}${p}${J}${Z}+${k}${I}3${B}${E}${M}${V}${S}${F}${h}${d}${W}${n}${W}3${X}${L}${T}${W}1${g}${T}${G}${x}${d}${F}${j}/${u}${s}${l}${W}${x}${e}${E}2${E}${c}${P}${l}7${s}${m}95${S}${G}5${y}${O}${v}${Y}${H}${T}${f}${x}${E}${H}${J}${f}${W}${Z}${a}${n}${O}${D}${J}${N}${f}${Z}${V}4${w}${X}${K}${R}${F}${X}${N}${r}${t}${h}${D}${P}${X}${R}${Y}${t}${u}${m}${K}${a}4${h}${P}7${A}${S}${X}${z}${K}${i}1${r}${u}${O}${E}1${P}${x}7${E}${v}${A}${x}${f}${b}${L}${l}${m}${o}${o}${Y}${Q}${c}${Z}${t}${p}${c}${A}5${z}${X}${k}${F}${a}${F}${o}${A}${j}${h}${w}${y}${u}${e}${i}${a}${h}${Q}${c}9${Q}${y}${P}${W}${d}${c}${Y}${g}${I}${N}${g}${j}${W}${G}6${v}${M}${G}${n}8${B}${c}${y}27${U}${j}7${x}${J}${u}${O}7${y}9${g}${q}2${B}${n}/5${Z}${L}${t}${R}${v}${s}5${H}${K}${b}5${T}${x}${L}7${b}${v}${l}7${l}${x}9${E}9${r}${z}${n}${w}${X}${g}${D}${q}${M}${s}${c}${w}${x}${X}${O}${m}${J}${L}${e}${p}${E}+${I}${i}${N}${W}${H}${B}${k}${o}${N}${C}6${X}9${C}+${a}${w}9${r}${B}4${J}${C}${M}${a}${k}${A}${l}1${h}${X}${W}${f}535${x}${K}898${z}${K}${h}0${r}${S}${v}${l}${z}${u}${N}${N}${G}${r}${l}${W}${Y}${j}0${J}2${W}${F}${E}${h}${c}${q}${Y}${U}${A}${z}${J}${F}${K}${r}3${m}${t}${Z}${l}${f}${w}${q}${W}${H}${K}${g}${s}${L}${o}${F}${r}${d}${o}${j}${y}${d}${F}${a}${U}0${k}${E}${Y}${Z}${B}${C}2${z}${p}${q}${Y}${H}${L}${k}${j}${F}${r}${Z}${O}${P}${c}3${O}${N}${A}38${O}2${A}${a}${s}${p}${J}${m}${X}${i}+${X}${O}${N}${L}1${d}${v}${L}2${A}${Y}${x}${C}${Y}57${k}${A}${g}${A}${A}\";"], [3, "This is awesome!"], [1, "I got stuck decoding the text in the [2nd page puzzle spoiler](/s \"brainfuck -> php code in the svg image of the cow\"). Did anyone get further?"], [1, "I still don't know the answer."], [1, "Started doing the puzzle on my lunch break, it's now an hour past my lunch break and I'm still working on it.. going to have to work late today :D \n\nI'm stuck on the haskell part, has anybody finished the whole thing yet?\n\nEdit: I'm finished, now I can get back to work... "], [0, "C"]], [[{"comment": "One of two options.\n\n1. The language you are currently using  \n2. The language you are not currently using.", "id": "d2tlb5f"}], [{"comment": "The brainfuck code becomes this:\n\n$A='A';$B='B';$C='C';$D='D';$E='E';$F='F';$G='G';$H='H';$I='I';$J='J';$K='K';$L='L';$M='M';$N='N';$O='O';$P='P';$Q='Q';$R='R';$S='S';$T='T';$U='U';$V='V';$W='W';$X='X';$Y='Y';$Z='Z';$a='a';$b='b';$c='c';$d='d';$e='e';$f='f';$g='g';$h='h';$i='i';$j='j';$k='k';$l='l';$m='m';$n='n';$o='o';$p='p';$q='q';$r='r';$s='s';$t='t';$u='u';$v='v';$w='w';$x='x';$y='y';$z='z';echo \"${H}4${s}${I}${C}${J}${B}${Q}${z}${F}${Y}${A}${A}3${d}${h}${d}${A}${C}${l}${U}${m}1${L}${w}${z}${A}${Q}/${i}2${m}${w}${t}${J}${b}${W}${y}${r}${K}${p}${J}${Z}+${k}${I}3${B}${E}${M}${V}${S}${F}${h}${d}${W}${n}${W}3${X}${L}${T}${W}1${g}${T}${G}${x}${d}${F}${j}/${u}${s}${l}${W}${x}${e}${E}2${E}${c}${P}${l}7${s}${m}95${S}${G}5${y}${O}${v}${Y}${H}${T}${f}${x}${E}${H}${J}${f}${W}${Z}${a}${n}${O}${D}${J}${N}${f}${Z}${V}4${w}${X}${K}${R}${F}${X}${N}${r}${t}${h}${D}${P}${X}${R}${Y}${t}${u}${m}${K}${a}4${h}${P}7${A}${S}${X}${z}${K}${i}1${r}${u}${O}${E}1${P}${x}7${E}${v}${A}${x}${f}${b}${L}${l}${m}${o}${o}${Y}${Q}${c}${Z}${t}${p}${c}${A}5${z}${X}${k}${F}${a}${F}${o}${A}${j}${h}${w}${y}${u}${e}${i}${a}${h}${Q}${c}9${Q}${y}${P}${W}${d}${c}${Y}${g}${I}${N}${g}${j}${W}${G}6${v}${M}${G}${n}8${B}${c}${y}27${U}${j}7${x}${J}${u}${O}7${y}9${g}${q}2${B}${n}/5${Z}${L}${t}${R}${v}${s}5${H}${K}${b}5${T}${x}${L}7${b}${v}${l}7${l}${x}9${E}9${r}${z}${n}${w}${X}${g}${D}${q}${M}${s}${c}${w}${x}${X}${O}${m}${J}${L}${e}${p}${E}+${I}${i}${N}${W}${H}${B}${k}${o}${N}${C}6${X}9${C}+${a}${w}9${r}${B}4${J}${C}${M}${a}${k}${A}${l}1${h}${X}${W}${f}535${x}${K}898${z}${K}${h}0${r}${S}${v}${l}${z}${u}${N}${N}${G}${r}${l}${W}${Y}${j}0${J}2${W}${F}${E}${h}${c}${q}${Y}${U}${A}${z}${J}${F}${K}${r}3${m}${t}${Z}${l}${f}${w}${q}${W}${H}${K}${g}${s}${L}${o}${F}${r}${d}${o}${j}${y}${d}${F}${a}${U}0${k}${E}${Y}${Z}${B}${C}2${z}${p}${q}${Y}${H}${L}${k}${j}${F}${r}${Z}${O}${P}${c}3${O}${N}${A}38${O}2${A}${a}${s}${p}${J}${m}${X}${i}+${X}${O}${N}${L}1${d}${v}${L}2${A}${Y}${x}${C}${Y}57${k}${A}${g}${A}${A}\";", "id": "d2tqbzl"}, {"comment": "Which you can execute as php to become:\n\nH4sICJBQzFYAA3dhdAClUm1LwzAQ/i2mwtJbWyrKpJZ+kI3BEMVSFhdWnW3XLTW1gTGxdFj/uslWxeE2EcPl7sm95SG5yOvYHTfxEHJfWZanODJNfZV4wXKRFXNrthDPXRYtumKa4hP7ASXzKi1ruOE1Px7EvAxfbLlmooYQcZtpcA5zXkFaFoAjhwyueiahQc9QyPWdcYgINgjWG6vMGn8Bcy27Uj7xJuO7y9gq2Bn/5ZLtRvs5HKb5TxL7bvl7lx9E9rznwXgDqMscwxXOmJLepE+IiNWHBkoNC6X9C+aw9rB4JCMakAl1hXWf535xK898zKh0rSvlzuNNGrlWYj0J2WFEhcqYUAzJFKr3mtZlfwqWHKgsLoFrdojydFaU0kEYZBC2zpqYHLkjFrZOPc3ONA38O2AaspJmXi+XONL1dvL2AYxCY57kAgAA", "id": "d2tqd91"}, {"comment": "Which then you can base64 decode to become a gzip'd file.. which you can then gunzip to become some readable code again.", "id": "d2tqsf6"}, {"comment": "a=606;c=\"\";while(a--){c=String.fromCharCode(10^\"cgzex~*Nk~k$Ibkx\\u0000fo~*\\\"k0h#*7*gkz*exn*(a9VIKD-VYSD,VIKD;Q9[\\\"V(,V()\\\"V(,V(\\\"V()\\\"V(\\\"V()\\\"V(-V(-V(,V()\\\"V(,V(\\\"V()\\\"V(,V(\\\"V()-V(-V()\\\"V(,V(\\\"V(,V(,V()\\\"V(,V(-V(-V()\\\"V(,V(\\\"V(,V()\\\"V(\\\"V()\\\"V(-V(-V(,V()\\\"V(,V(,V(\\\"V(,V(,V()-V(-V(,V()\\\"V(,V(\\\"V()\\\"V(\\\"V()\\\"V(-V(-V(,V()\\\"V(,V(\\\"V(,V()\\\"V(,V(-V(-V()\\\"V(,V(\\\"V(,V()\\\"V(\\\"V()\\\"V(-V(-V(,V()\\\"V(,V(\\\"V()\\\"V(\\\"V()\\\"V(-V(-V()\\\"V(,V(\\\"V(,V()\\\"V(\\\"V()\\\"V(-V(-V(,V()\\\"V(,V(\\\"V(,V()\\\"V(,V(-V(-V(,V()\\\"V(,V(\\\"V()\\\"V(,V(,V(-V(-V(,V()\\\"V(,V(\\\"V()\\\"V(\\\"V()\\\"Y;h9,;o9[YVD_FVVobVYSDSVYSDUnVYSDQ:h9h+Un`VXYSV_Y;o.]llQnPVXYk[hYV_YVD_FVD_FlbUn`VXYVMYVMY.joUnVXYoV_YV_Y(*cd*z\u007f~Y~xFd*.*\\\"ibx*k#0\\\"lefnx*\\\"Vh*i*\\'4*\\\"ibx*\\\"k!h\\'3=#0i##*QW*h#\".charCodeAt(a))+c}", "id": "d2tr6jx"}, {"comment": "which you can process to become:\nimport Data.Char\\nlet (a:b) = map ord \\\"k3\\\\CAN'\\\\SYN&\\\\CAN1[3Q(\\\\\\\"&\\\\\\\"#(\\\\\\\"&\\\\\\\"(\\\\\\\"#(\\\\\\\"(\\\\\\\"#(\\\\\\\"'\\\\\\\"'\\\\\\\"&\\\\\\\"#(\\\\\\\"&\\\\\\\"(\\\\\\\"#(\\\\\\\"&\\\\\\\"(\\\\\\\"#'\\\\\\\"'\\\\\\\"#(\\\\\\\"&\\\\\\\"(\\\\\\\"&\\\\\\\"&\\\\\\\"#(\\\\\\\"&\\\\\\\"'\\\\\\\"'\\\\\\\"#(\\\\\\\"&\\\\\\\"(\\\\\\\"&\\\\\\\"#(\\\\\\\"(\\\\\\\"#(\\\\\\\"'\\\\\\\"'\\\\\\\"&\\\\\\\"#(\\\\\\\"&\\\\\\\"&\\\\\\\"(\\\\\\\"&\\\\\\\"&\\\\\\\"#'\\\\\\\"'\\\\\\\"&\\\\\\\"#(\\\\\\\"&\\\\\\\"(\\\\\\\"#(\\\\\\\"(\\\\\\\"#(\\\\\\\"'\\\\\\\"'\\\\\\\"&\\\\\\\"#(\\\\\\\"&\\\\\\\"(\\\\\\\"&\\\\\\\"#(\\\\\\\"&\\\\\\\"'\\\\\\\"'\\\\\\\"#(\\\\\\\"&\\\\\\\"(\\\\\\\"&\\\\\\\"#(\\\\\\\"(\\\\\\\"#(\\\\\\\"'\\\\\\\"'\\\\\\\"&\\\\\\\"#(\\\\\\\"&\\\\\\\"(\\\\\\\"#(\\\\\\\"(\\\\\\\"#(\\\\\\\"'\\\\\\\"'\\\\\\\"#(\\\\\\\"&\\\\\\\"(\\\\\\\"&\\\\\\\"#(\\\\\\\"(\\\\\\\"#(\\\\\\\"'\\\\\\\"'\\\\\\\"&\\\\\\\"#(\\\\\\\"&\\\\\\\"(\\\\\\\"&\\\\\\\"#(\\\\\\\"&\\\\\\\"'\\\\\\\"'\\\\\\\"&\\\\\\\"#(\\\\\\\"&\\\\\\\"(\\\\\\\"#(\\\\\\\"&\\\\\\\"&\\\\\\\"'\\\\\\\"'\\\\\\\"&\\\\\\\"#(\\\\\\\"&\\\\\\\"(\\\\\\\"#(\\\\\\\"(\\\\\\\"#(S1b3&1e3QS\\\\NUL\\\\\\\\eh\\\\SYNY\\\\SYN_d\\\\SYN[0b3b!_dj\\\\RSY\\\\US1e$Wff[dZ\\\\RSaQbS\\\\US\\\\NUL\\\\NULfh_dj\\\\RS\\\\GS\\\\GS$`e_d\\\\RSe\\\\US\\\\US\\\" in tStrLn $ (chr a):(foldr (\\\\b c -> (chr (a+b-97):c)) [] b)\\n\\n\n\nwhich appears to be haskell...", "id": "d2trb59"}, {"comment": "Yeah, it's haskell, but it's broken code. For example, you have \"tStrLn\", but the actual function is \"putStrLn\". I'm curious about how exactly you got this result, though, because I got a very similar result, which was also broken code, but my code was broken in slightly different ways.\n\nEdit: I actually managed to get completely correct haskell code by just using `base64` and `gunzip` on the commandline  (previously I did those operations in python)", "id": "d2trpmw"}, {"comment": "I just got rickrolled by a coding puzzle on the internet.. ", "id": "d2tsdhw"}, {"comment": "yeah... i'm seeing extraneous \\n's in there... and the code errors too... i'm doing it on commandline as well... hrm...\n", "id": "d2tsenj"}, {"comment": "It's template haskell, it returns:\n\nk=\"1 0\";e=[2,0,-2,0,2,-2,2,-2,1,1,0,-2,0,2,-2,0,2,-1,1,-2,0,2,0,0,-2,0,1,1,-2,0,2,0,-2,2,-2,1,1,0,-2,0,0,2,0,0,-1,1,0,-2,0,2,-2,2,-2,1,1,0,-2,0,2,0,-2,0,1,1,-2,0,2,0,-2,2,-2,1,1,0,-2,0,2,-2,2,-2,1,1,-2,0,2,0,-2,2,-2,1,1,0,-2,0,2,0,-2,0,1,1,0,-2,0,2,-2,0,0,1,1,0,-2,0,2,-2,2,-2];l=0;o=[]\nfor c in e:l=l+int(c);o.append(k[l])\n\nprint(''.join(o))\n\nwhich is python and that returns:\n00110101 00110110 01100011 01100101 00111000 00110101 00110011 01100101 00110101 01100101 00110011 00110111 00110101\n\nwhen converted to ascii:\n56ce853e5e375\n\nwhich happens that this works:\nhttp://whatisthebestprogramminglanguage.com/56ce853e5e375\n\nstuck after downloading the repo", "id": "d2tspqg"}, {"comment": "The puzzle file in the tar repository is a java class file (starts with \"cafebabe\")\n...well... thats my guess anyway... haven't been able to decode it yet.\n", "id": "d2tsvb7"}, {"comment": "When putting into a hex to ascii converter it appears there are clues, something to do with the diff of the commits? \n\nEDIT: Study the past if you would define the future", "id": "d2tszxx"}], [{"comment": "This is awesome!", "id": "d2to9br"}], [{"comment": "I got stuck decoding the text in the [2nd page puzzle spoiler](/s \"brainfuck -> php code in the svg image of the cow\"). Did anyone get further?", "id": "d2tljsq"}, {"comment": "link is broken. tell how did you solve the level 1.", "id": "d2tm5we"}, {"comment": "It's a spoiler, hover over it to see the spoiler text. If you're on mobile, my condolences.\n\nHere's how I 'solved' the first page: [1st page puzzle spoiler](/s \"I looked at the JavaScript and set the url of the browser to where the JavaScript would have redirected me had I checked all the boxes. I'm not sure if there's another, better solution.\")", "id": "d2tmb1b"}, {"comment": "Fire up the debugger of your favourite browser?", "id": "d2tma59"}, {"comment": "I found a \"Hint\" in html page. no idea how to continue.", "id": "d2tqb89"}], [{"comment": "I still don't know the answer.", "id": "d2tnw8c"}], [{"comment": "Started doing the puzzle on my lunch break, it's now an hour past my lunch break and I'm still working on it.. going to have to work late today :D \n\nI'm stuck on the haskell part, has anybody finished the whole thing yet?\n\nEdit: I'm finished, now I can get back to work... ", "id": "d2tqop7"}], [{"comment": "C", "id": "d2tjn55"}, {"comment": "D", "id": "d2tkssc"}, {"comment": "E", "id": "d2tlzcz"}, {"comment": "F#", "id": "d2tm5ii"}]]], "424q2u": ["Microsoft silenty adds Amazon root certificates to its CTL", "2016-01-22 11:38:30", 0, "http://hexatomium.github.io/2016/01/21/amazon-roots/", [[13, "Two things: ~~the Program Participants link is broken~~ (Edit: it was fixed), and Mozilla has [an open issue to add Amazon root certificates](https://bugzilla.mozilla.org/show_bug.cgi?id=1172401) (pending further discussion). Failing to mention that is simply misleading."], [13, "Amazon roots are cross signed by other roots, so they were already trusted by Microsoft. That's not exactly a huge change. See https://www.amazontrust.com/repository/\n\n"], [-24, "Clowns to the left of me, jokers to the right, here I am - man in the middle with yooouu! La la la...."]], [[{"comment": "Two things: ~~the Program Participants link is broken~~ (Edit: it was fixed), and Mozilla has [an open issue to add Amazon root certificates](https://bugzilla.mozilla.org/show_bug.cgi?id=1172401) (pending further discussion). Failing to mention that is simply misleading.", "id": "cz7lies"}, {"comment": "But muh FUD!", "id": "cz7ry2b"}], [{"comment": "Amazon roots are cross signed by other roots, so they were already trusted by Microsoft. That's not exactly a huge change. See https://www.amazontrust.com/repository/\n\n", "id": "cz7m4rw"}], [{"comment": "Clowns to the left of me, jokers to the right, here I am - man in the middle with yooouu! La la la....", "id": "cz7kyxd"}]]], "4fs4gg": ["How to turn Node.js projects into AWS Lambda microservices easily with ClaudiaJS", "2016-04-21 12:51:38", 2, "https://aws.amazon.com/blogs/compute/how-to-turn-node-js-projects-into-aws-lambda-microservices-easily-with-claudiajs/", [[2, "all of these new web frameworks that I don't want to learn are making it a lot harder to stay employed"], [1, "I'm headlong into a project using the severless framework/cli (which I love), but I'm going to give this a once over as well. Looks minimalistic which I often prefer. "], [1, "So.... what's the diff between this and say node-lambda? "]], [[{"comment": "all of these new web frameworks that I don't want to learn are making it a lot harder to stay employed", "id": "d2bmivl"}, {"comment": "You know the steam roller they talk about in software development? Turns out it looks more like the fucking [wonkamobile](http://www.imcdb.org/i053540.jpg).\n\n", "id": "d2bn2ol"}], [{"comment": "I'm headlong into a project using the severless framework/cli (which I love), but I'm going to give this a once over as well. Looks minimalistic which I often prefer. ", "id": "d2bj55p"}], [{"comment": "So.... what's the diff between this and say node-lambda? ", "id": "d2ctr0h"}]]], "4jsaxb": ["Why I don't spend time with Modern C++ anymore", "2016-05-17 22:14:50", 14, "https://www.linkedin.com/pulse/why-i-dont-spend-time-modern-c-anymore-henrique-bucher-phd", [[32, "* Those idioms aren't new, and the safe bool idiom is obsolete today.\n\n* Calling Intuitionistic Type Theory an inbreed is too much, and only time will tell whether it's a passing fad. It's also insulting (not to mention wrong) to imply that modern C++ was developed by young grads with an agenda to push intuitionistic TT.\n\n* Does the article imply that iostreams and strings are new modern additions to the language?\n\n* I wish I'd see some reliable sources that actually corroborate all those performance-related claims.\n\n* Assuming code is incorrect just because you don't understand an entire source code file in under a minute sounds like a terrible idea.\n\n* Do HFT traders really use Verilog and VHDL for their programming? Sounds like a slower development workflow, despite C++'s famed compile times imo. I'd be interested to see whether I misunderstood, or how this works in practice.\n\n* So who is this \"new technologist\" guy again? Are HFT traders, security guys, game developers and cloud architects all supposed to work with Verilog now?"], [27, "So he thinks C++ is complicated and that not understanding a C++ code file in 1 minute is a problem.\n\nAnd the solution is Verilog and VHDL???\n\nIf Verilog and VHDL are being touted as a alternatives to Modern C++, I am feeling much more confident about C++."], [12, "I hate this article because as a C++ hater it actually only gets about 3% right. C++ is a riot of accidental complexity but Vhdl is simpler? That fpga fueled future was du jour in about 2002. This guy is one of the fintech hft nuts. "], [11, "I'm surprised about the comments on efficiency. My anecdotal experience is C++ compilers have gotten pretty good at optimizing. Maybe he's referring to some domain-specific code such as linear algebra?"], [6, "> C++ today is like Fortran: it reached its limits.\n\nFinally someone said it.\n\nC++ is a convoluted abomination, and it will never get fixed due to backward compatibility.\n\nEvery standard tries to introduce new features to fix all the old features, but all that really happens is you have *more* potholes and compiler rules to juggle in your head. It's unsustainable.\n\nJust let it die.\n\nEdit: before you downvote me for pissing on your beloved holy language, ask yourself this:\n\nHave you memorized every rule for template type deduction? Auto type deduction? Decltype deduction?\n\nFrom memory, can you tell me precisely the differences?\n\nFrom memory, can you tell me the differences in behaviour for these features between different versions of GCC and Clang?\n\nUnless your name is Scott Meyers or Bjarne Stroustrup, the answer to all of those questions is no.\n\nIf you don't understand how the language works, how can you be trusted to use it effectively?\n\n\nOK, now you can downvote me because you're mad at being called out. Good day."], [5, "omg, so many things wrong with this article...\n\n> After 1970 ... This ended up forming the basic support layer for functional programming paradigms.\n\nLisp is *literally* the prototypical FP language, and it was written in 1958.\n\n> After enough time, C++ ... and performance was put aside.  ... several systems within C++ are inherently slow like iostreams\n\nWait wait wait.  Which is it?  Are iostreams inherently slow?  Or did they used to be fast and now they are slow?\n\n> Ask anyone in the committee about why this has not been resolved in almost two decades and the response is always the same: nobody has ever cared to submit a paper or proposal.\n\nWell what do you expect?  Everyone in the world should drop everything to work on your personal favorite bug?  The fact of the matter is that iostream performance is just not that important.  Honestly and truly, if iostream performance is the reason your program is slow, then either you're an outlier, or you're doing something wrong.  Most of the time it's not an issue.\n\n> This is where Fortran excels - because of the much simpler language, compilers are able to optimize it much more efficiently than the respective C/C++ code.\n\nFalse generalization.  C is actually an incredibly simple language.  It's barely a thin veneer over assembly.  But more to the point, it is actually possible, on occasion, for naive C++ code to produce faster binaries than the equivalent C code, due to C++'s additional complexity allowing it to take advantage of constraints which can be optimized on in situations where C's simpler model can't make the same guarantees.  Another example is the aliasing problem.  Solving the aliasing problem increases language complexity, but also enables more optimization.\n\n> If you have to hire a guru/expert to understand the code, either you have the wrong code or the wrong language.\n\nAll programmers are gurus/experts in programming, and you expect to hire programmers to understand code.\n\n> C++ cannot be used anymore because it is inherently serial\n\nMulti-threading is actually part of the standard now.  Holy crap, this dude knows nothing about the language he's bashing...\n\n> little $10 FPGAs that will require an astounding amount of qualified technologists to program them. And programming on RTL is hundreds of times more complex than coding C++, believe me\n\num... FPGAs are usually coded in C, although it's becoming much more common to use a sort of scaled down version of C++ that removes some of the most not-embedded-friendly features while still retaining most of the improvements in organization / abstraction.\n\n> it is showing its age, accelerated by inaction from the ISO committee\n\nIf this article had been written before the C++0x drafts started circulating, then maybe he'd have a point.  But C++ has seen a massive resurgence of activity in the last ten years, and particularly in the last 5 years.  \"Inaction\" by the committee?  They're more active now than ever."], [3, "you should use restricted, safe subset of c++ like serious companies do. I agree it jumped the shark with the feature addiction long ago ..which is unfortunate."], [0, "How come you guys know so much shit about programming languages? Jesus. I'm not sure whether to be glad I seem to get my work done just fine without knowing any of it, or scared because I've been programming for a decade in ignorance"], [1, "I agree that C++ is an exercise in serial thinking. If you are interested in an inherently parallel language look at http://clash-lang.org which is a functional, simple and while primarily intended for ASIC/FPGA, it is efficiently compilable to serial architectures."], [1, "One thing I don't understand. I am not a C++ developer, but from what I've seen and read C++ is essentially a superset of almost every other language out there. What stops people to write Java-like C++? Or C-like C++? Or whatever is your favorite thing is."], [1, "So his problem is with C++ machine efficiency not programmer productivity."]], [[{"comment": "* Those idioms aren't new, and the safe bool idiom is obsolete today.\n\n* Calling Intuitionistic Type Theory an inbreed is too much, and only time will tell whether it's a passing fad. It's also insulting (not to mention wrong) to imply that modern C++ was developed by young grads with an agenda to push intuitionistic TT.\n\n* Does the article imply that iostreams and strings are new modern additions to the language?\n\n* I wish I'd see some reliable sources that actually corroborate all those performance-related claims.\n\n* Assuming code is incorrect just because you don't understand an entire source code file in under a minute sounds like a terrible idea.\n\n* Do HFT traders really use Verilog and VHDL for their programming? Sounds like a slower development workflow, despite C++'s famed compile times imo. I'd be interested to see whether I misunderstood, or how this works in practice.\n\n* So who is this \"new technologist\" guy again? Are HFT traders, security guys, game developers and cloud architects all supposed to work with Verilog now?", "id": "d39av9v"}, {"comment": "> Calling Intuitionistic Type Theory an inbreed is too much, and only time will tell whether it's a passing fad.\n\nWe already know it isn't: it's the functional basis of the [Coq theorem prover](http://coq.inria.fr) and the [Idris programming language](http://idris-lang.org), and via the [Curry-Howard Isomorphism](https://www.youtube.com/watch?v=IOiZatlZtGU) informs our work in languages like OCaml, Haskell and, more mainstream, Scala. Simply put, when I reject a statically-typed language, it's because I've determined that its type system doesn't take adequate advantage of the Curry-Howard Isomorphism, which effectively means because it doesn't take adequate advantage of Intuitionistic Type Theory.\n\nC++ has problems, for sure, but they also fall into the category of \"this language was designed before we knew what we were doing.\" Template metaprogramming feels like an abomination because the only type you have at the meta-level is int, and because templates weren't intended for metaprogramming. But the concept templates introduce\u2014parametric polymorphism\u2014had been around in the ML family since the mid-1970s, and there was no need for C++ to half-ass it the way it did. But so it goes.\n\nAs for me, I last had a C++ gig well over a decade ago, and good riddance. If I weren't working on server software\u2014that is, if I needed to not target the JVM again\u2014I would insist on using a decent, rational language like OCaml or Haskell. If I had to write a Linux device driver, I'd use [ATS](http://ats-lang.org). Life is too short to accept ancient linguistic kludges like C++s, or the radical underfeaturedness and lack of safety of C. Maybe Rust will be OK; it's too early to tell, and I see a lot of emphasis on memory safety but not a lot on other aspects of safety (this may be due to my lack of investigation rather than any actual lack in Rust, to be fair).\n\nBut yeah. C, C++: nope, just nope right the hell on out of there.", "id": "d39iwqj"}, {"comment": ">We already know it isn't\n\nI meant it more in the areas of general-purpose programming. Sure, theorem provers use ITT, but it has yet to catch on in the general industry. I suppose Scala is relatively popular, but the most used languages are still Java, C++, Python etc.\n\nAs for C++, yes, it has problems, but I didn't see a good discussion of them in this article.\n\n>If I had to write a Linux device driver, I'd use ATS\n\nWhy would you go for ATS? Looking at its website, I'm not sure what sold you on it for device driver development (aside from its types).\n\n>Maybe Rust [...] I see a lot of emphasis on memory safety but not a lot on other aspects of safety\n\nNot sure what other aspects of safety you're looking for, that can't be part of a library or something?", "id": "d3a0193"}, {"comment": "> I suppose Scala is relatively popular, but the most used languages are still Java, C++, Python etc.\n\nBy \"not a passing fad,\" I only meant that languages like Scala, OCaml, and Haskell aren't going away, not that they're necessarily mainstream. And with the recent release of, e.g. [Reason](https://facebook.github.io/reason/), maybe we'll even see a bit of an uptick in OCaml adoption.\n\n> Why would you go for ATS? Looking at its website, I'm not sure what sold you on it for device driver development (aside from its types).\n\nA device driver has unusually stringent correctness requirements, in some cases even including the need to keep within CPU/memory/stack consumption bounds and the like. ATS is both a theorem prover and a language that ultimately generates C, so it's perfect for this sort of work. [This paper](https://pdfs.semanticscholar.org/05e9/5067441165b722a575034b74943fadf7401e.pdf) goes into some details on why and how. More generally, consider [this post](https://bluishcoder.co.nz/2014/04/11/preventing-heartbleed-bugs-with-safe-languages.html) on using ATS to avoid the heartbleed bug in OpenSSL.\n\n> Not sure what other aspects of safety you're looking for, that can't be part of a library or something?\n\nA more expressive type system, but again, I haven't spent enough time studying Rust to know for sure that Rust _doesn't_ measure up here. I strongly suspect that, a few years down the road, I'll be reading stuff about Rust and I'll think \"Rust can do that? Cool!\" I just haven't gotten there yet.\n\ntl;dr better languages are better.", "id": "d3a2ope"}, {"comment": "The height of computing began and ended with McCarthy and Lisp. Academic languages like Haskell are cool but they still come with all the complex warts that result from trailblazing.\n\nLisp is the most elegant implementation of the lambda calculus and no other language has come close.", "id": "d39s4ka"}, {"comment": "Lisp implements untyped lambda calculus which is hardly useful. Benefits of Curry-Howard and all the power of math lie in typed lambda calculus and there Haskell seems to be the best practical implementation. But of course if we want the full power of ITT we need proper dependently typed languages like Idris. ", "id": "d39tf3y"}, {"comment": "While Lisp was loosely inspired by the lambda calculus (most notably the simplicity of the core constructs), it fell far short of _implementing_ it. The language was dynamically scoped, for heaven's sake!\n\nMore modern lisps (such as Scheme) are different, mostly thanks to their lexical scoping.", "id": "d39xyph"}, {"comment": "> The height of computing began and ended with McCarthy and Lisp. Academic languages like Haskell are cool but they still come with all the complex warts that result from trailblazing.\n\nThat's _hilarious_.", "id": "d3a2k6n"}, {"comment": "> Do HFT traders really use Verilog and VHDL for their programming?\n\nA very small percentage do. But I have no idea what this guy is talking about and his paragraph about Verilog makes no sense.", "id": "d39benm"}, {"comment": "The only way it seems to make sense is that he's saying he's got a limited amount of time to spend on learning things and now he's going to go off and learn Verilog or VHDL and FPGA programming. If that's the case then it's not really an article about why people should give up on modern C++, only why this particular person is giving up on modern C++ to focus on other priorities. ", "id": "d39n1uw"}, {"comment": "That's exactly the title of an article.", "id": "d3a0e41"}, {"comment": "I haven't found a computational use case (I/O maybe) where fpga dominates GPU solutions.", "id": "d3bogq6"}, {"comment": "> Does the article imply that iostreams and strings are new modern additions to the language?\n\nFrom the post on /r/cpp it is more that their problems are praktically ignored while both language and standard library get extended for more modern features. From personal experience iostream performance can be horrible if you use the operators <<, >> as intended and it is still the best modern c++ has to offer for file IO.\n\n", "id": "d39iojz"}, {"comment": "> Are HFT traders, security guys, game developers and cloud architects all supposed to work with Verilog now?\n\nI dunno m8. What I do know is that working with C is perfectly viable and far from useless.\n\n", "id": "d3ay663"}], [{"comment": "So he thinks C++ is complicated and that not understanding a C++ code file in 1 minute is a problem.\n\nAnd the solution is Verilog and VHDL???\n\nIf Verilog and VHDL are being touted as a alternatives to Modern C++, I am feeling much more confident about C++.", "id": "d39ev20"}, {"comment": "As someone who was just hired into a firm full of EEs who do Verilog and VHDL on FPGAs and needed a dedicated software person who knows C/C++ I can say that yea... Anyone who thinks Verilog or VHDL is the solution is insane, unless you know, you are using Verilog and VHDL for what they are meant for (and even then it seems things like HLS or whatever name you want to give to cross-compilers/translators are going to produce just as good HDL code most of the time).", "id": "d39ksgl"}, {"comment": "From what I've seen, competent HDL persons seem to think that HLS is the future, and will come in due time.", "id": "d3a0vgn"}, {"comment": "Yeah, he's making a bizarre argument. Verilog and VHDL for FPGA programming have their niche, but they're never going to replace C++ (or similar general purpose programming languages) it's more like they'll be complementary.", "id": "d39n68i"}, {"comment": "Strange comparison indeed. C is essentially an interface over an abstract computational machine. C++ is sort of the same, with lots of fancy things on top. Vhdl and Verilog *create* the machine. \r\n\r\nAnd it is hard to glean how these... fpga description languages? i dunno what the category is called, but they certainly dont really have much to do with the merit, good or bad, of modern c++. apples and oranges.", "id": "d39t94m"}, {"comment": "usually Hardware Description Languages", "id": "d39zeah"}], [{"comment": "I hate this article because as a C++ hater it actually only gets about 3% right. C++ is a riot of accidental complexity but Vhdl is simpler? That fpga fueled future was du jour in about 2002. This guy is one of the fintech hft nuts. ", "id": "d39kb4j"}], [{"comment": "I'm surprised about the comments on efficiency. My anecdotal experience is C++ compilers have gotten pretty good at optimizing. Maybe he's referring to some domain-specific code such as linear algebra?", "id": "d39fqgl"}, {"comment": "Anytime anyone complains about new C++ features resulting in slow code without even _once_ touching on the distinction between purely compile-time abstractions vs. runtime abstractions, and offering specific examples of how using templates does or does not affect the optimization of the generated code for _your specific compiler_ with _your specific parameters_, you can, and should, safely ignore them, especially when, to this very day, the overwhelming majority of games (at least their underlying engines) are written in C++ using these \"modern\" techniques.", "id": "d39igit"}, {"comment": "My experience in scientific computing code is that compilers do a very good job inlining, eliminating compile time known branches in generic code and similar optimizations, but do a very poor job with vectorization for anything but the simplest loops with hints like restrict and about alignment.", "id": "d39u4iw"}, {"comment": "Thanks for the info!", "id": "d3a7ow9"}, {"comment": "Do you think Clik Plus helps with this?", "id": "d3a8w7n"}, {"comment": "I've never used it personally, but from the talks I've seen about it I thought it was primarily about threading not vectorization?", "id": "d3b3l2c"}], [{"comment": "> C++ today is like Fortran: it reached its limits.\n\nFinally someone said it.\n\nC++ is a convoluted abomination, and it will never get fixed due to backward compatibility.\n\nEvery standard tries to introduce new features to fix all the old features, but all that really happens is you have *more* potholes and compiler rules to juggle in your head. It's unsustainable.\n\nJust let it die.\n\nEdit: before you downvote me for pissing on your beloved holy language, ask yourself this:\n\nHave you memorized every rule for template type deduction? Auto type deduction? Decltype deduction?\n\nFrom memory, can you tell me precisely the differences?\n\nFrom memory, can you tell me the differences in behaviour for these features between different versions of GCC and Clang?\n\nUnless your name is Scott Meyers or Bjarne Stroustrup, the answer to all of those questions is no.\n\nIf you don't understand how the language works, how can you be trusted to use it effectively?\n\n\nOK, now you can downvote me because you're mad at being called out. Good day.", "id": "d397bqz"}, {"comment": "I've written a *lot* of c++ over the last 15 years, but haven't written any in the last 3 since I've been working primarily in ObjC/Java/Swift.\n\nI have an unfinished C++/OpenGL game in pre-C++11 which I was thinking about diving back into, and I thought, \"wouldn't this be a nice time to learn modern c++?\". So I bought Scott Meyer's \"Effective Modern C++\" and tore through it, with increasing sense of dread with every page I turned.\n\nI kind of understand now why C++ is an abomination. The cognitive hoops to jump through to handle universal references, to understand when an r-value will turn into something else, which constructor form to use and when, etc... it all stinks of a complicated system that will not be re-architected because it weighs too much.\n\nIf I need C++ performance in a new project, I strongly suspect I'll use Rust or D. It pains me, since I used to *love* C++ so much.\n\nEDIT: I should add, I was once proud of my home rolled signal/slots implementation. Now I look at it and think, \"this should never have been so awkward to do.\"", "id": "d399ivq"}, {"comment": "Exactly my experience as well.\n\nReading Meyer's (excellent) book was eye opening. You're introduced a new feature, shown how it works, then shown all the ways that it's subtly broken and how it can bite you in the ass.\n\nAt first I studied hard and practiced, then I thought, fuck this shit... There's no reason to deal with so much bullshit. I moved to Rust and never looked back.\n\nC++ is pure insanity.", "id": "d399y0l"}, {"comment": "> I moved to Rust and never looked back.\n\nThen your argument about template argument deduction, etc. is facetious. Not only are the complete rules for Rust, which you have alluded must be completely internalized before you can be \"trusted to use the language effectively\", not only are these rules not even _recorded_ anywhere, so that, in place of being Scott Meyers or Bjarne Stroustrup, you must be a rustc dev to even hope to know what they are, not only are these rules in flux within rustc at a rate much faster than g++'s or clang++'s, but these rules are quite possibly even more complicated than anything in C++. Certainly, if you think the rules for `decltype`, which is basically a simple bottom-up algorithm, are complicated, then Rust's rules for type inference, in which the type constraints propagate both vertically and horizontally along the syntax tree, where you can't even query the type of an expression like you can with `decltype`, must be positively baffling. Substitute \"Can you recite the precise coherence rules?\", \"Can you recite the precise rules for borrowck?\", etc.", "id": "d39jerp"}, {"comment": "> Then your argument about template argument deduction, etc. is facetious.\n\nYou are 100% correct. I'm just a stinker.", "id": "d39muly"}, {"comment": "> If I need C++ performance in a new project, I strongly suspect I'll use Rust or D. It pains me, since I used to love C++ so much.\nEDIT: I should add, I was once proud of my home rolled signal/slots implementation. Now I look at it and think, \"this should never have been so awkward to do.\"\n\nD I could understand, but are signal/slots in Rust really easier than in C++?", "id": "d39tu8f"}, {"comment": "Did the same when I first started using Python 6 years ago. Realizing that things don't need to be so complex was an eye opener for me, and furthermore all the time I save writing the thing in the first place can be put into optimisation ensuring my Python programs run faster than my C++ ever did!", "id": "d39hifh"}, {"comment": "If that last statement is true, it only hints at your low skill at C++, nothing else. ", "id": "d39wvey"}, {"comment": "edgy", "id": "d39ye3y"}, {"comment": "> If you don't understand how the language works, how can you be trusted to use it effectively?\n\nBecause a good developer should know when to look something up when they're not confident they're doing something correctly. \n\nYou see these kinds of \"hidden\" complexities in all languages through little gotchas and quirks which will bite all but the most experienced developers in that language. Just because languages let you steamroll over some of those quirks doesn't mean they're better than C++ or vice versa. \n\nFor example, is C# a bad language [because it's easy to accidentally create tons of garbage](https://www.reddit.com/r/gamedev/comments/4jrc2n/avoiding_hidden_garbage_in_c/) or because you don't have overload resolution rules committed to memory? No, of course not. Is Swift a bad langauge because [accidentally abusing the type deduction mechanism can increase compile times to 12 hours](https://spin.atomicobject.com/2016/04/26/swift-long-compile-time/)? No, of course not. Are they bad languages because they're more complicated than many people think they are? No, of course not. \n\nNot being able to commit parts of the C++ template system rules to memory isn't a symptom of it being a bad language, nor is not having memorized the difference in feature sets between gcc and clang. Is that any different than memorizing which browsers support which parts of ECMAscript or CSS3 or whatever?\n\nSo the language and tools are a little more complicated than more popular ones, big deal. That doesn't mean it's not an extremely powerful language and it certainly doesn't mean it has \"reached its limits\". If anything, it's easier to use than ever.", "id": "d39b7wr"}, {"comment": "Developers of C# seem to take the rule of least surprise seriously. Developers of C++... Well, I can't blame them, they work hard enough on adding new features to the language without breaking existing code/making grammar more ambiguous than it already is.\n\nBTW, the C# accidental garbage example you provided is lacking performance comparison. It could cause bad cache behavior, but that wasn't measured. .Net garbage collector has a special rule for short-lived objects, they are quickly disposed. http://stackoverflow.com/questions/631919/short-lived-objects", "id": "d39u859"}, {"comment": "> For example, is C# a bad language because it's easy to accidentally create tons of garbage or because you don't have overload resolution rules committed to memory?\n\nYes\n\n> Is Swift a bad langauge because accidentally abusing the type deduction mechanism can increase compile times to 12 hours?\n\nThis is a bug, not in the language standard. Unless you're implying that the current type deduction behaviour in C++ is a bug, then I agree.\n\n> Not being able to commit parts of the C++ template system rules to memory isn't a symptom of it being a bad language\n\nIt absolutely is. It means the programmer is fighting the complexity of the language when he should be fighting complexity in the solution.\n\n> Is that any different than memorizing which browsers support which parts of ECMAscript or CSS3 or whatever?\n\nYou can use transpilers and polyfills to get around this, so in practice it's not a problem at all.\n\n> That doesn't mean it's not an extremely powerful language\n\nI didn't say C++ was not extremely powerful. I said that it's an abomination.\n\nYou also seem to be under the impression that I don't think other languages are garbage too. Most are.\n\nC++ is nothing but three decades of failed abstractions.", "id": "d39bmkf"}, {"comment": "Nah, you are wrong on a lot of counts.\n\nFor example the template system in C++ is extremely complex, but 99% of what you are going to use it for is NOT complex at all. Template classes/functions are not complex, the syntax behind them is not complex, it is easy to commit to memory what you are going to need to do 99% of the time. That other 1% when you are wanting to write some crazy ass template metaprogramming then YES it is horrible, but it is also sorta pushing the limits of what it is designed to do. Are there problems? Yes! Is it a problem most of the time for most people? Hell no.", "id": "d39kwdk"}, {"comment": "> For example the template system in C++ is extremely complex, but 99% of what you are going to use it for is NOT complex at all.\n\nAh, that's a nice example. Let's compare C++ templates and Ocaml generics. Both C++ and Ocaml assume very little about generic types. The difference is, Ocaml forbids anything that might not work, while C++ allows anything that might work.\n\nThis is a big deal in practice: In Ocaml, if your generic function has the right type, you know any further type error would occur because you called it wrong. If you *defined* it wrong, the type system would have told you right away. Not so with C++ templates, which get most of their power by deferring decisions, and with them error messages. This also complicates error messages, which have to talk about the current instantiation of the template, instead of its generic definition.\n\nAs a result, Ocaml generic code is generally easier to write and use than non-generic code. C++ templates however are _harder_ to write and use than non-generic code. This changes everything.\n", "id": "d39zqc1"}, {"comment": "[deleted]", "id": "d397ye0"}, {"comment": "> Rust is interesting but it doesn't have 1/10 of the features of C++ at the moment.\n\nThat's a good thing. ", "id": "d39832o"}, {"comment": "This is a pretty epic c++ burn and all, but it's missing some important features. For example, the lack of values as generics parameters (ie, template<int N>).", "id": "d39hbue"}, {"comment": "Is it such a problem when Rust has a reasonable macro system instead?", "id": "d39hxke"}, {"comment": "I don't think a rust macro will help you write a template class that takes an int as a template parameter. I don't know too much about rust though so I wouldn't be surprised if I was wrong.", "id": "d39liad"}, {"comment": "I mean, Rust doesn't even have classes so it's hard to compare. And I'll admit I have no idea what an int as a template parameter is good for, other than making a fixed-size vector class.", "id": "d39oohs"}, {"comment": "The primary use that I know of is a b-tree: https://en.wikipedia.org/wiki/B-tree\n\nBasically, it's a generalization of the binary search tree designed for improved cache friendliness. You can use an integer template parameter to control the number of elements in each node. By performance testing different values, you can set it to whatever number performs best; a good initial guess might be whichever number makes the node fit inside a single cache line.\n\nBecause this sort of thing doesn't exist in rust, it's impossible to write a b-tree backed data structure that has this sort of flexibility, and both performance and maintainability will suffer as a result if you try to write one with a fixed node size.", "id": "d39q7qm"}, {"comment": "I've got couple of examples form my real code working with images (video frames). \n\n * When doing motion search we use 2D vectors of different precision: they can be in pixels of low-res image, in pixels of hi-res image, in half-pixels, in quarter-pixels etc. So they are all just 2D vectors, pairs of ints, but they mean different things and you don't want to accidentally use a vector in quarter-pixels instead of full-pixel vector, so we use integer template parameters as phantom types to make different precision vectors different types and have proper conversion methods that can go from type with precision P to one with P+1 by multiplying the x,y values by 2, for example. This is a correctness aid.\n \n * We also work with image blocks of different sizes like 4x4, 8x8 and 16x16 and perform the same operations with blocks of these sizes, sometimes recursively (so a routine working with 16x16 blocks can invoke itself recursively but for blocks of 8x8). When this block size is passed as a compile-time argument, as integer template parameter, the compiler can properly allocate the right sized blocks on stack and unroll the loops properly since number of iterations is statically known. Passing the size as a runtime value would make this code much slower.", "id": "d39uag1"}, {"comment": "It is useful to force constant folding, allows better loop unrolling, better inlining. Basically an optimization aid.", "id": "d3a0y9c"}, {"comment": "Another neat application is in approximation functions. Take this function which approximates the cosine function using its taylor series:\n\n    template<size_t NUM_TERMS>\n    float cosTaylorSeries(float x)\n    {\n        float result = 1;\n\n        for(size_t i = NUM_TERMS; i > 0; i--)\n        {\n            result = 1 - (x * x / ((2 * i - 1) * 2 * i)) * result;\n        }\n\n        return result;\n    }\n\nIn this function, the NUM_TERMS template parameter controls the accuracy of the approximation. If we just need a very poor approximation we can call cosTaylorSeries<4>(angle), and if we need a very good one we can call cosTaylorSeries<20>(angle).\n\nFor even greater flexibility, we could control the accuracy via a runtime argument to the function, IE float cosTaylorSeries(float x, int numTerms). But if the number of terms is a compile time constant, the compiler can unroll the loop for greater performance.\n\nSo in this case, using an integer as a template parameter offers a nice compromise between performance and flexibility.\n\n", "id": "d3bcnng"}, {"comment": "With D you can have a LLVM backend and codegen is simply very similar to what it would be with C++. The one difference I can think of is that signed overflow is not UB in D. GC can be mitigated but that point is usually very controversial around here.\n\nYou don't get ICC backend on the other hand. The Intel C++ compiler is a beast to beat.\n\nMy grief with C++ isn't really that it's complex, I find it quite beautiful. It's that it's not productive enough for me. If you take longer to develop a program, that's less time to optimize it too.", "id": "d39fd3d"}, {"comment": "[deleted]", "id": "d39ac3d"}, {"comment": "[deleted]", "id": "d39af3w"}, {"comment": "> The problem is that as a developer of high performance software there is no language which can give me the same level of performance as C++. \n\nWell, there is always C. It isn't perfect, but it is far saner than C++ and chances are you are already familiar with it :-P", "id": "d39nr00"}, {"comment": ">Finally someone said it.\n\nYes, OP's the first guy ever to have a bone to pick with C++, and you're the second one!\n\n>Unless your name is Scott Meyers or Bjarne Stroustrup, the answer to all of those questions is no.\n\nDon't forget Herb Sutter.\n\n>Have you memorized ...\n\nYes, all you have to do is memorize that stuff. Or read some books. Or keep up with GotW. auto and decltype aren't even complicated. What's really difficult is understanding TMP. If you had brought that up, you would have had a point.\n\n>From memory, can you tell me the differences in behaviour for these features between different versions of GCC and Clang?\n\nThat's just silly, all that matters is the currently used toolchains and we have changelogs for everything else. What do you program in? Do you know the entire history of your toolchain?\n\n>If you don't understand how the language works, how can you be trusted to use it effectively?\n\nI call it \"code review\". Also linting, debugging, performance profiling, unit testing etc. And oh yeah: **learning**. Either way, if by that you mean \"every little detail of the language\", I doubt that's the case for most programmers (except maybe for Scheme users or something), regardless of the languages they use. The C community is full of people who can't agree on what counts as \"portable\", or mistake implementation-specific extensions for standard features, or are electrical engineers who don't give a rat's ass about programming. I'd bet that the vast majority of devs who use managed languages have no idea how their virtual machines work, what gc algorithms they use etc. How many Scala devs do you figure know all the workings and features of Scala?\n\nIf your only argument is that C++ is complex, that's not enough to conclude anything. The only way to stop a language from growing is by actively preventing it.", "id": "d39cfjf"}], [{"comment": "omg, so many things wrong with this article...\n\n> After 1970 ... This ended up forming the basic support layer for functional programming paradigms.\n\nLisp is *literally* the prototypical FP language, and it was written in 1958.\n\n> After enough time, C++ ... and performance was put aside.  ... several systems within C++ are inherently slow like iostreams\n\nWait wait wait.  Which is it?  Are iostreams inherently slow?  Or did they used to be fast and now they are slow?\n\n> Ask anyone in the committee about why this has not been resolved in almost two decades and the response is always the same: nobody has ever cared to submit a paper or proposal.\n\nWell what do you expect?  Everyone in the world should drop everything to work on your personal favorite bug?  The fact of the matter is that iostream performance is just not that important.  Honestly and truly, if iostream performance is the reason your program is slow, then either you're an outlier, or you're doing something wrong.  Most of the time it's not an issue.\n\n> This is where Fortran excels - because of the much simpler language, compilers are able to optimize it much more efficiently than the respective C/C++ code.\n\nFalse generalization.  C is actually an incredibly simple language.  It's barely a thin veneer over assembly.  But more to the point, it is actually possible, on occasion, for naive C++ code to produce faster binaries than the equivalent C code, due to C++'s additional complexity allowing it to take advantage of constraints which can be optimized on in situations where C's simpler model can't make the same guarantees.  Another example is the aliasing problem.  Solving the aliasing problem increases language complexity, but also enables more optimization.\n\n> If you have to hire a guru/expert to understand the code, either you have the wrong code or the wrong language.\n\nAll programmers are gurus/experts in programming, and you expect to hire programmers to understand code.\n\n> C++ cannot be used anymore because it is inherently serial\n\nMulti-threading is actually part of the standard now.  Holy crap, this dude knows nothing about the language he's bashing...\n\n> little $10 FPGAs that will require an astounding amount of qualified technologists to program them. And programming on RTL is hundreds of times more complex than coding C++, believe me\n\num... FPGAs are usually coded in C, although it's becoming much more common to use a sort of scaled down version of C++ that removes some of the most not-embedded-friendly features while still retaining most of the improvements in organization / abstraction.\n\n> it is showing its age, accelerated by inaction from the ISO committee\n\nIf this article had been written before the C++0x drafts started circulating, then maybe he'd have a point.  But C++ has seen a massive resurgence of activity in the last ten years, and particularly in the last 5 years.  \"Inaction\" by the committee?  They're more active now than ever.", "id": "d3antrq"}], [{"comment": "you should use restricted, safe subset of c++ like serious companies do. I agree it jumped the shark with the feature addiction long ago ..which is unfortunate.", "id": "d39alrm"}, {"comment": "> you should use restricted, safe subset of c++\n\nWhich one?", "id": "d39avq5"}, {"comment": "I can't go into the specifics, but if your question is a prelude for tearing the argument apart, don't bother, I know it will never solve the problem it merely mitigates the harm. Nothing will ever solve it in my opinion, every language has pros and cons.  Moreover c++ and frankly almost any language should be advanced by taking away the bloat, not addig to it, but then who would buy the books and sponsor the conferences..", "id": "d39c9sr"}, {"comment": "> frankly almost any language should be advanced by taking away the bloat, not addig to it\n\nI hear this a lot.  But, has there *ever* been a widely used language that removed features progressively?  Doing that means none of your existing users can upgrade without expensive rework to remove their years of built-up utilization of the \"bloat\".\n\nOne example would be [Elm's recent update.](http://elm-lang.org/blog/farewell-to-frp)  But, Elm is still experimental and not at all widely used.\n\nAnother example might be Python 2 -> 3.  We all know how well that went... Released at the end of 2008 and only recently starting to pick up traction to actually replace 2.x in usage.", "id": "d39dwd5"}, {"comment": "Not only that, but c++11 actually did depcrecate and remove features.  So not only is /u/Lakerman's sentiment wrong in theory, it's also wrong in practice", "id": "d39icdr"}, {"comment": "bury me please I have nothing to live for. \nOnly for spelling you S t r a w m a n", "id": "d39nq0w"}, {"comment": "I don't know about removing but Lua has pretty successfully stuck to the strategy of keeping to the concept of the language, which is you create the structures of your program, nothing is forced on you.", "id": "d39e9c8"}, {"comment": "To add to that, Go has also followed that strategy quite successfully, I'd like to see more languages like Go and Lua.", "id": "d39nqh1"}, {"comment": "you can keep compatibility if you don't remove, just phase it out. \nWhen you restrict the language to a subset, you do it anyway. I wasn't clear I don't wanna imply that a committee should remove forcefully something, I think the standards ie best practices should be cut down, the features may stay, just three steps: first, try not to add bloat, second simplify, third some features are default off based on how problematic or dangerous they are and that can help leaving them behind. ", "id": "d39noh6"}, {"comment": "The subset which makes the most sense for your particular project. \n\nReally, that's simultaneously the biggest advantage of C++ (to seasoned developers) as well as the biggest issue.\n\nThe design philosophy is the exact opposite of Python, where Python is \"there's exactly 1 right way to do things\" and C++ is \"there are 10,000 ways to do this thing, choose wisely\".\n\nTo use C++ effectively, you choose the particular subset of features that are useful in your situation. It makes it a much harder language, but also a very flexible and scalable language, in my opinion.\n\nReally, people should start looking at C++ as more of a meta-language than a language in itself. It's such a overwhelmingly huge language that it's just better to think of it as a set of different paradigms you can choose from - you can write bare metal C-style code, big abstracted and architectural Java-style code, and even functional-style code, depending on what features you want to choose. This is the greatest advantage as well as the greatest flaw with C++.", "id": "d3a6iy2"}], [{"comment": "How come you guys know so much shit about programming languages? Jesus. I'm not sure whether to be glad I seem to get my work done just fine without knowing any of it, or scared because I've been programming for a decade in ignorance", "id": "d39vk00"}], [{"comment": "I agree that C++ is an exercise in serial thinking. If you are interested in an inherently parallel language look at http://clash-lang.org which is a functional, simple and while primarily intended for ASIC/FPGA, it is efficiently compilable to serial architectures.", "id": "d39zzmi"}], [{"comment": "One thing I don't understand. I am not a C++ developer, but from what I've seen and read C++ is essentially a superset of almost every other language out there. What stops people to write Java-like C++? Or C-like C++? Or whatever is your favorite thing is.", "id": "d3bfo9f"}], [{"comment": "So his problem is with C++ machine efficiency not programmer productivity.", "id": "d3bpt18"}]]], "4b37af": ["Six stages of debugging", "2016-03-19 18:07:55", 0, "https://twitter.com/christianmaioli/status/643044001793339393", [[2, "Like, how has that been broken on production for 4 years and nobody noticed?"], [1, "[**@christianmaioli**](https://twitter.com/christianmaioli):\n>[2015-09-13 12:50:11 UTC](https://twitter.com/christianmaioli/status/643044001793339393)\n\n>Six Stages of Debugging\n>\n>[*plasmasturm.org*](http://plasmasturm.org/log/6debug/)\n>\n>[#programming](https://twitter.com/search?q=%23programming) [#humor](https://twitter.com/search?q=%23humor) [*pic.twitter.com*](http://pbs.twimg.com/media/COyNHM-XAAAwwYk.png) [^[Imgur]](http://i.imgur.com/0MiaPIe.png)\n\n----\n\n[^[Mistake?]](/message/compose/?to=TweetPoster&subject=Error%20Report&message=/4b37af%0A%0APlease leave above link unaltered.)\n[^[Suggestion]](/message/compose/?to=TweetPoster&subject=Suggestion)\n[^[FAQ]](/r/TweetPoster/comments/13relk/)\n[^[Code]](https://github.com/joealcorn/TweetPoster)\n[^[Issues]](https://github.com/joealcorn/TweetPoster/issues)\n"], [1, "As an amateur never have I more related to anything in this sub."]], [[{"comment": "Like, how has that been broken on production for 4 years and nobody noticed?", "id": "d15ppfr"}], [{"comment": "[**@christianmaioli**](https://twitter.com/christianmaioli):\n>[2015-09-13 12:50:11 UTC](https://twitter.com/christianmaioli/status/643044001793339393)\n\n>Six Stages of Debugging\n>\n>[*plasmasturm.org*](http://plasmasturm.org/log/6debug/)\n>\n>[#programming](https://twitter.com/search?q=%23programming) [#humor](https://twitter.com/search?q=%23humor) [*pic.twitter.com*](http://pbs.twimg.com/media/COyNHM-XAAAwwYk.png) [^[Imgur]](http://i.imgur.com/0MiaPIe.png)\n\n----\n\n[^[Mistake?]](/message/compose/?to=TweetPoster&subject=Error%20Report&message=/4b37af%0A%0APlease leave above link unaltered.)\n[^[Suggestion]](/message/compose/?to=TweetPoster&subject=Suggestion)\n[^[FAQ]](/r/TweetPoster/comments/13relk/)\n[^[Code]](https://github.com/joealcorn/TweetPoster)\n[^[Issues]](https://github.com/joealcorn/TweetPoster/issues)\n", "id": "d15nvgq"}], [{"comment": "As an amateur never have I more related to anything in this sub.", "id": "d15pfge"}]]], "564oqs": ["The Rise and Fall of Scala", "2016-10-06 14:10:26", 0, "https://dzone.com/articles/the-rise-and-fall-of-scala", [[23, "Only evidence cited to support the premise that Scala popularity is declining is the [Tiobe Index](http://www.tiobe.com/tiobe-index), which also indicates that Assembly Language and Object Pascal are on the rise. It also has Ada and ABAP higher than Scala. It's meaningless.\n\nThe rest of the article seems to be more about why the author doesn't like Scala."], [6, "Clickbait title but I found arguments interesting nonetheless"], [5, "I'm not even a Java-related dev, but even I know Scala isn't going anywhere. It's saving Java along with Kotlin."], [2, "Wow, so many statements I disagree with in this post, I feel it would be a waste of time responding to them. Here are a few:\n\n* \"Scala includes Akka as a standard library\"...standard?\n* \"There are subtle differences in the ways Scala and Java support functional programming\"...subtle?\n* \"an average programmer\u2019s productivity, as measured by implemented functionality, will probably decline when transitioning from Java to Scala\"...completely disagree"], [2, "Well Scala clearly isnt falling, its becoming more popular and recognized nowadays. The beauty of scala is that it is an object functional language. It integrates the strength of OOP and FP and allows you to choose a combination of them. For me, OOP is and always will be the primary paradigm for any programs I design. But some FP concepts such as closures have been used extensively in OO code as well. With scala all is easy, and you can design your program to be OOP, FP or a mix of both. "], [2, "https://xkcd.com/386/"], [2, "All I read, made me to actually want to learn scala.\n\nI'm mathematically minded, and the avantages look great.\nFunctional programming is the paradigm that appeals most to me.\n\nso...\nhas anyone got pointers?"], [-3, "Scala isn't falling, retarded article"], [-8, "I agree with article. Scala seems to me a political coalition rather than technical excellence. Take along people who hate Java by calling Scala brand new language also take along Java developers by saying it is using good old JVM and can utilize all Java libraries.  What they end up is being hobbled by JVM shortcomings and less than enthusiastic welcome by Java and non-Java developers. "]], [[{"comment": "Only evidence cited to support the premise that Scala popularity is declining is the [Tiobe Index](http://www.tiobe.com/tiobe-index), which also indicates that Assembly Language and Object Pascal are on the rise. It also has Ada and ABAP higher than Scala. It's meaningless.\n\nThe rest of the article seems to be more about why the author doesn't like Scala.", "id": "d8g9jch"}, {"comment": "> Only evidence cited to support the premise that Scala popularity is declining is the Tiobe Index\n\nHe also mentioned a few prominent firms moving away from the language, and he mentions a lot more details altogether. While you certainly has a case that more data is better, you short-sell the blog post.\n\nBy the way, I'm taking the Scala course(s) on Coursera right now and don't feel any changed attitude after reading the article since I'm doing it more for the functional programming aspect than the language itself, but I still think it is a useful read.", "id": "d8gb85f"}, {"comment": "> He also mentioned a few prominent firms moving away from the language\n\nYes, he mentioned Yammer, who accidentally made a big noise about moving off Scala in **2011**. This is extremely old news and does not support his argument that Scala is currently losing popularity. LinkedIn appear to have stopped posting blog posts about Scala, but other than that I can't find a reliable source that indicates they're no longer using it. They have a June 2016 blog post about their Photon ML library. This runs on Apache Spark, which is written in Scala, so they're still using Scala indirectly if not directly. Again, nothing here supports to premise that Scala is currently losing popularity.\n\nThere are numerous other issues with the article, e.g.:\n\n> But, Java has surpassed Scala as the preeminent functional programming language\n\nJava is not a functional programming language, not at least using any meaningful definition of the term.\n\n> Scala is a difficult language to master because its principles are based on mathematical type theory\n\nOutlandish premise unsupported by any evidence.\n\nBasically it's opinion masquerading as analysis, like most blog posts.", "id": "d8gcbf0"}, {"comment": "> like most blog posts.\n\nOf course. Yet we keep reading them. I saw the lack of real data, yet I thought the time spent reading the text well-spent. Even without being able to take anything concrete form it that would lead to any action on my part.\n\nHere is a link in support of Scala at least for the UK: http://www.itjobswatch.co.uk/jobs/uk/scala.do", "id": "d8gcgm7"}, {"comment": "That scala course on coursera is the best programming course I've ever taken. Even if you don't want or need to ever use scala, it teaches a lot of cool concepts.\n\nIt changed my whole way of thinking and helped me finally \"get\" functional programming.\n\nInstead of conceptually thinking of a Set as a \"unique array\", it makes you think of it as a function that answers \"is this thing in the set or not\". ", "id": "d8gf3j0"}, {"comment": ">By the way, I'm taking the Scala course(s) on Coursera right now and don't feel any changed attitude after reading the article since I'm doing it more for the functional programming aspect than the language itself, but I still think it is a useful read.\n\nExactly me right now.", "id": "d8gcmjm"}, {"comment": "> that Assembly Language and Object Pascal are on the rise.\n\nThere was recently a new major version of Free Pascal after a few years of development which was followed by a new version of Lazarus. Lazarus itself is slowly expanding in mind share (although it still is an underdog), so this rise isn't weird.", "id": "d8gdutj"}, {"comment": "> The TIOBE index (www.tiobe.com) of software language popularity ranked Scala at #13 in 2012; now it\u2019s fallen to #32 in August 2016\n\nThis is also by the way absolute troll bullshit (and no coincidence it was posted here by Kotlin troll Nicolas Frankel). Although TIOBE is not a useful index, Scala was where it is, i.e. around 30th place, since several years:\n\nhttps://en.wikipedia.org/wiki/File:TIOBE_Scala_Ranking.png\n\n(the mere ripple of that graph gives you a sense of the soundness of TIOBE, before even taking into account that the number of languages indexed grew over the years).\n\nHere's another one for the curious reader: https://pypl.github.io/PYPL.html - oops, Scala's on the rise. \"Don't trust a statistics that you haven't forged yourself\" ;)", "id": "d8gfao0"}, {"comment": "Yes, the \"Clickbait title but I found arguments interesting nonetheless\" comment was a bit of a giveaway. I've noticed he likes to post Kotlin spam to the Java reddit from time to time.\n\nWhat is it with Kotlin that attracts basket cases like [this](https://www.reddit.com/r/scala/comments/454ahd/recent_dottyscala_fud/)? He's apparently still posting to Reddit under [various](https://www.reddit.com/user/seb_02) [pseudonyms](https://www.reddit.com/user/abhrainn).\n", "id": "d8ggo4v"}, {"comment": "Assembly Language and Pascal being on the rise does not seem ridiculous to me.", "id": "d8gemk1"}, {"comment": "At my last job we did a project in Scala and I got REALLY GOOD at Scala, even all the scalaz and akka stuff.  I was on the project for over a year.  Yes, I wrote monads,became an expert at flatMap and for comprehensions, got used to the quirkiness of Akka and ExecutionContexts... you name it, I've seen it.\n\nI loved that job but Scala drove me away.  I left that job thinking \"no more Scala, ever\".  I wouldn't even entertain interviews for companies that used Scala.  The experience was that bad for me.\n\nI guess you're right, the author doesn't really *prove* that Scala is declining.  I liked reading this because it echoed my opinions on Scala and why I left Scala for good and will never come back to it.", "id": "d8gxpt2"}], [{"comment": "Clickbait title but I found arguments interesting nonetheless", "id": "d8g93vs"}], [{"comment": "I'm not even a Java-related dev, but even I know Scala isn't going anywhere. It's saving Java along with Kotlin.", "id": "d8g9rgm"}, {"comment": "Java needs saving?", "id": "d8gbwzm"}, {"comment": "the jvm is worth saving. ", "id": "d8gcup2"}, {"comment": "Perfectly put.", "id": "d8hub4f"}, {"comment": "Java is still wildly popular, but most of the best and brightest people I've worked with that used it for a long time got tired of its ceremony.  Almost any task you want to be accomplish in Java can be accomplished in less than half as many lines of code in Scala, Kotlin, Ceylon, Groovy, or Clojure (to name five nice Java offshoots on the JVM) without sacrificing readability if you know the respective language.", "id": "d8gepuf"}, {"comment": ">... but even I know Scala isn't going anywhere\n\nThat's literally true. It is not declining but it also is not growing and with Kotlin taking part of the market things are getting more complicated.", "id": "d8ge28w"}], [{"comment": "Wow, so many statements I disagree with in this post, I feel it would be a waste of time responding to them. Here are a few:\n\n* \"Scala includes Akka as a standard library\"...standard?\n* \"There are subtle differences in the ways Scala and Java support functional programming\"...subtle?\n* \"an average programmer\u2019s productivity, as measured by implemented functionality, will probably decline when transitioning from Java to Scala\"...completely disagree", "id": "d8gp6de"}, {"comment": "Actually, that's something I'm trying to understand since a long time. It's obvious that functional programming is fun in Scala, but it feels a bit odd in Java 8. Why's that?", "id": "d8jnsut"}], [{"comment": "Well Scala clearly isnt falling, its becoming more popular and recognized nowadays. The beauty of scala is that it is an object functional language. It integrates the strength of OOP and FP and allows you to choose a combination of them. For me, OOP is and always will be the primary paradigm for any programs I design. But some FP concepts such as closures have been used extensively in OO code as well. With scala all is easy, and you can design your program to be OOP, FP or a mix of both. ", "id": "d8gff2s"}], [{"comment": "https://xkcd.com/386/", "id": "d8gya7m"}], [{"comment": "All I read, made me to actually want to learn scala.\n\nI'm mathematically minded, and the avantages look great.\nFunctional programming is the paradigm that appeals most to me.\n\nso...\nhas anyone got pointers?", "id": "d8hb065"}, {"comment": "although.. I guess the answer is of course not..\nno side effects :D", "id": "d8hbawe"}, {"comment": "The Coursera classes by Odersky et al. might be a good starter.", "id": "d8hn4pl"}], [{"comment": "Scala isn't falling, retarded article", "id": "d8g9ftp"}, {"comment": "The article is fool of dubious statements backed by lack of evidence. As someone else said - personal biased opinions (possibly with ulterior motives) masqueraded as analysis.", "id": "d8go1ab"}], [{"comment": "I agree with article. Scala seems to me a political coalition rather than technical excellence. Take along people who hate Java by calling Scala brand new language also take along Java developers by saying it is using good old JVM and can utilize all Java libraries.  What they end up is being hobbled by JVM shortcomings and less than enthusiastic welcome by Java and non-Java developers. ", "id": "d8gbzu2"}]]], "4yurss": ["Keawe Block: I hire Engineers at Google - here's what I look for (and why)", "2016-08-21 17:08:49", 75, "http://www.fastcompany.com/3062713/how-to-be-a-success-at-everything/i-hire-engineers-at-google-heres-what-i-look-for-and-why", [[134, "[deleted]"], [131, "We now hire all sorts of majors (but they need to basically be engineers) and we no longer look for coding robots only (but you still need to do our coding robot interview). Sounds like nothing has really changed"], [70, "seems like doctored article to get people to apply for google so they have more talent to pick from."], [52, "[deleted]"], [31, "[deleted]"], [18, "He forgot to mention: don't be over 30!\n\nAge discrimination is rampant.\n\nIt's also discriminating against your future self."], [18, "That's what gets me about these companies.  They tell us we need to practice for an interview.  That's interesting... so someone will cram in bunch of important knowledge just to squeeze by the interview process and then flush it all down the toilet.  Look at the educational system.  It has been proven over and over that tests are a pile of garbage and do not correctly reflect students' knowledge across the broad spectrum.  People cram for tests, know that information for a few days and then poof... gone just like that.  So, the entire process favors those that are good at short term memory and plenty of free time on their hands prior to an interview over those who actually possess valuable knowledge that perhaps may not be applicable to a few of their trick questions during the process.  I don't have an extensive experience (I actually don't know what would be considered extensive...) -- just over three years of experience with C# and WPF.  I do, however, know how to interact with the client to get the specification, establish a timeline, design custom controls in WPF, create tests, create documentation, use several important patterns, exercise good practices in both WPF and C#.... yet none of that is going to matter when they throw in some graph problem that I haven't \"prepared for.\"  I don't even think Google would hire a C#/WPF developer, but that's besides the point.\n\nEdit: Correction, I guess they do hire C# developers. "], [16, "Unless you actually are highly specialized, like, for instance, a PhD-holder in computer science. That degree is sought-after by google for the bragging rights, but the hiring process cares exactly zero what you're research is. Zero. PhD is all about research. Nobody does it for the fame, as is there isn't any.\n\nOnce you're hired as a \"software engineer\" (just like everyone is at google), they then start up gMatch (which takes 3 months for some reason), and you *hope* they have a project to pick that's sort of relevant to what you've spent a decade becoming the world leader in. \n\nCompared against traditional academic and research/industry jobs, which hire you because you're one of the best at the thing they want to do, both you and google have no idea what you're really getting from each other, and *google doesn't care.* "], [16, "It's okay to leave GPA off your resume not because they no longer use it, but because they want to see your transcript and can get it from there."], [8, "No thanks. I'd rather not sit through what I gather are multi-multi-multi stage interviews and have my knowledge and intelligence insulted at every step. I also don't want to work on some brilliant project just for Google to close it down after a few months because fuck users that's why."], [7, "**Not programming** (read the sidebar)"], [7, "Didn't have a great time interviewing with them, did my first test, got most of the questions right. Said I'd hear back in a week. I had to wait like 2 weeks before I email them and then they called me a week later. My only feedback was that my answers were \"borderline\" with no exppnation. I asked the HR guy to explain and that's all he knew and they decided to retest me like weeks later and got denied because my guy didn't understand how to do experimental mean statistics. I don't mind the denied part but the communication was terrible and random and filled with bad feedback. I don't think I'd apply to them again after that."], [4, "Would it impress you if I could jump over a chair?"], [4, "This feels very geared towards people graduating from school."], [5, "Do they still still have a rigorous and long, drawn out interview process? \n\nI'm not very interested in going through anything like that unless I'm desperate. I'm curious if there will be an industry trend away from over the top interviews.\n\n"], [4, "Google rejects 90% of the people that apply, and then they complain that they can't find enough people."], [1, "And I still haven't heard from my internship applications :( "], [1, "\"don't assume you're unqualified on the basis of your educational, professional, or personal background\" - so highschool dropouts with technical skills can apply too?"], [1, "Google should study the nature of talent and genius. Few organizations like talent agencies or human resource departments have given any thought to the matter of how to locate the really talented geniuses. I think this could be done using personality profiles and Internet history, since a genius will naturally gravitate to certain subjects and eventually seek out certain online resources. \n\nThis is the subject of a play I am writing which concerns the poaching of a technology worker by a recruiter in an unrelated industry. A lot of bright people drift into IT because it is the easiest way to be rewarded for your genius. The Information Technology has created a vast brain drain which robs other industries of vital talent. Cross industry poaching would be a creative way to solve this problem."], [1, "How about hiring people over 50, Google?\n  \nSomeone that's been programming since before you were born - and you're going to ask them data structure questions that anyone in their right mind is going to say: \"I use a library for that so I don't have to reinvent it every time\"\n"]], [[{"comment": "[deleted]", "id": "d6qm7kr"}, {"comment": "Or in my case, contacting me because my experience was a \"perfect fit for a project they're staffing\" despite my not having any experience in the programming language they wanted, repeatedly assuring me that it wouldn't be a problem, proceeding to interview me on that language, and then declining me because I \"lacked the required experience.\" Haven't bothered to respond to a Google recruiter email since. ", "id": "d6qmkyy"}, {"comment": "I think they implicitly expected you to become proficient at that language in the time between the emails and the interview.\n\nWhich is bullshit of course, people have other shit to do.", "id": "d6qo8tn"}, {"comment": "If you cannot master brainfsck in a few days and write a text editor in it, then we do not want you!", "id": "d6qp26k"}, {"comment": "I think they just want a big pipeline.  We have to get as many people to apply as possible so we can reject as many people as possible.", "id": "d6uhx7j"}, {"comment": ">contacting me because my experience was a \"perfect fit for a project they're staffing\" \n\nIsn't this recruiter-speak for \"I found your linkedin\"?", "id": "d6rs2oo"}, {"comment": "Close.  It is recruiter-speak for:  \"I desperately need another warm body.\"", "id": "d6uhxtv"}, {"comment": "Lol. Also plausible.\n\nI had a recruiter contact me on LinkedIn with a \"perfect fit\" email where they talked a bunch about how I've done so much UI work and my strong JavaScript background is great. Two problems:\n\n- The *second sentence* on my LinkedIn says I have no interest in UI work, little experience, and am terrible at it.\n- My only work related JavaScript experience is implementing a JS script parser for a 3d modeling engine... in C++.", "id": "d6ujiij"}, {"comment": "Ah, I used to work in a small consultancy company of about 7 people. After they successfully recruited one guy from the firm they continued to send emails to the rest of the team except me. Practically the whole firm went through the interview process with two guys passing it and one accepting the position.\n\nI had significantly less experience than the rest of the company so I wasn't too bothered about not being contacted.\n\nFew months later they sent me an email saying I'm a perfect match for one of their positions if I'm willing to relocate and if so I should send them my CV. \n\nI spent a whole day fixing my CV to look perfect from a Google POV just to get as an answer \"Thank you, but we will not consider your application as you are not qualified.\"\n\nConsidering how odd that reply was I looked at the recruiter's profile on LinkedIn just to find she specifically recruits for an AI research position for people with a vast C++ experience. I'm a front end developer mostly working with JavaScript... \n\nThey really need to take into consideration the fact that a recruitment email from an at Google address means much much more to people than a random LinkedIn spam that everyone expects to be untargeted mass sent bullshit offer.", "id": "d6qsqkg"}, {"comment": "> They really need to take into consideration the fact that a recruitment email from an at Google address means much much more to people than a random LinkedIn spam that everyone expects to be untargeted mass sent bullshit offer.\n\nIt should not.", "id": "d6uhym4"}, {"comment": "When I got one of these emails, I just assumed it was a scam.\n\nAfter all, my GitHub account is nothing more than game plugins for Valve games (written in a variant of the Pawn programming language) and incomplete test projects... certainly nothing that Google would be hiring people for.", "id": "d6qr80i"}, {"comment": "Google probably isn't interested in hiring you for your experience writing game plugins.\n\nGoogle probably is interested in hiring people who have a proven record of programming and delivering things.", "id": "d6qt4nq"}, {"comment": "I get these as well, and I don't even have any impressive online portfolio. Just recruiters being recruiters :(", "id": "d6rn7c4"}, {"comment": "Yeah they got me to interview years and years ago for a software engineering role. I *told* them I had been focusing very, very intently on security topics like reverse engineering, malware analysis, etc., for 2 years at that point, that my coding skills were sloppy, and that I didn't have time to practice them for the interview since this was at around midterm time in grad school. They still insisted, I did ok in the interview (although now that I've been, you know, coding as a focus for a while I would do 10x better), and then they passed me over but continue to hit me up over email like 4 times a year. Whenever they schedule a phone chat, they stand me up 2 or 3 times before we connect, every single time.\n\nI got what I wanted out of it: experience with their weird interview machine, a chance to visit family for free in the area, and a contracting gig with Netflix while I was over there that turned out to be awesome (working with Netflix people is seriously so nice). But I don't know that I would ever try it again, now that I actually am more of a software engineer, given how much their recruiters jerk people around.", "id": "d6qtr6q"}, {"comment": "It's some sort of automated mail-merge program. I have some Github work, but this one thing I contributed to was really minor (documentation and logging), but they were \"interested in my work on <X> in field <Y> and here's a paper related to <Y> that [they] published recently\".\n\nI wasn't interested anyway at the time, but the mail-merge ad-lib format would've made me a little resistant anyway.", "id": "d6qtvw0"}, {"comment": "Had a similar experience. A recruiter contacted me, I said I'd be happy to chat, took her a week to reply with a link to her calendar, I scheduled a time for a call and never heard from her again.\n", "id": "d6qvmy7"}, {"comment": "Same experience for me. But then on top of that I'd like to point out they emphasize point #3 above all the rest even though studies show that the coding exercises in interviews are exactly why #1 and #4 occur, and that they are not a good metric for telling what people can do.", "id": "d6r9d04"}, {"comment": "Asides the connected (a)meritocracy who is in it doing absolutely trivial stuff, what they are interested in is not expertise alone but enthusiasm so that they can piggyback on that to milk what you can give them once hired. Once you are off your \"noogler\" enthusiasm and the new car smell wears off... you will be wanting a _proper_ car because people have ambitions. The whole process of the interview is to mindgame candidates who they already know they fit the bill; that's why they play the \"ignore\" game. Their sheer size allows them to live off of inertia by basing themselves on _quantity_ of developers over _quality_. That doesn't mean they don't have some superb developers but they are an exception that validates the norm.", "id": "d6qvvh9"}, {"comment": "This is just about the exact opposite of reality. People who make hiring decisions are happy to pass on people who are borderline but who might be a good fit, in order to ensure that there are no \"mistake hires\". That's about as far from quantity over quality that you can get. Maybe you're thinking of the recruiting team, that does indeed want to get anyone they possibly can into the interviewing pipeline (same as at any profitable tech company)?", "id": "d6r7l4d"}], [{"comment": "We now hire all sorts of majors (but they need to basically be engineers) and we no longer look for coding robots only (but you still need to do our coding robot interview). Sounds like nothing has really changed", "id": "d6qlaqg"}, {"comment": "I understand that to hire a programmer it makes sense to watch them program. So I'm not opposed to programming things in interviews. It just seems like it's arbitrarily restrictive. Why can't they use a library or Internet at large? In the project they'll be working on do they not have access to either of those things?", "id": "d6qpgx6"}, {"comment": "Question creativity is usually the main problem with this. Many interviewers ask a generic algorithms/data structures question like \"find a loop in a linked list\". So when you have access to the internet your first search is (rightfully) going to be \"find a loop in a linked list\". The thing is, the interviewer isn't so much looking for you to give him/her the answer as wanting to see how you reason through a problem. A business problem is never as straightforward as \"find a loop in a linked list\", it's much more ambiguous, usually specific to the business you're working on, and there won't just be a StackOverflow answer for it. The questions are supposed to gauge how well you can figure out these problems on your own. \n\nNow obviously the solution here is to come up with questions that are a bit more like the problems you actually face and allow internet usage. And that might work well at a small company like CrowdStrike where there aren't hundreds of candidates every day, but at Google once you ask a question about fifteen times it's already on the internet verbatim with multiple solutions outlined. ", "id": "d6qs1fw"}, {"comment": "People are memorizing all of these algorithms and edge cases to get these jobs though?", "id": "d6qtbyj"}, {"comment": "Sure. Do you have a better solution though? This isn't a case of Google not realizing there are flaws, the problem is getting a better method that is both scalable and minimizes false positives. \n\nAnd if someone is good enough to memorize the hundred or so different algorithms that might be thrown at them, test cases, variations that are thrown at them afterwards, *and* can talk about pros and cons of their solution versus other possibilities? I'm honestly pretty ok with that person. ", "id": "d6qu8pk"}, {"comment": "Yeah that's true. It definitely takes a certain person and motivation to do it.and they're probably not bad employees. I think at that point your looking for a a different , not a problem solver or someone with that kind if intuition. ", "id": "d6r2mb1"}, {"comment": "Why not have practical questions?", "id": "d6rih95"}, {"comment": "That's not a solution. This is like saying you can solve world hunger by giving people more food. Sure, that is technically correct, but the problem is how to get there. \n\nWhat defines a \"practical\" question? How can you measurably show that these practical questions result in smaller false positives and higher average performance? How do you avoid the problems with people gaming these questions just like they already do with technical questions? How can you confine this practical question to be solvable in a reasonable amount of time?\n\nIt's not as simple as just asking better questions. ", "id": "d6rjyi3"}, {"comment": "And I never said it was. Yes, interviewing is hard work and lazy interviewers will resort to the classic interview questions we all loathe. Practical problems should be a small project that requires you to sit down and spend some time, maybe an hour, solving. Professors around the world assign these types of problems everyday for their students (mine did a rpn calculator and implementing a popular board game), so I'm sure professional developers can come up with similar problems relevant to their domain. \n\nFor a front-end dev applying for an angular position, give him an internet connection, and an hour or two to setup a very basic client that reads from a basic endpoint endpoint you setup. For a backend C# dev, have him create a web api 2 project that supports a few endpoints and some basic dependency injection, couple unit tests etc. It's not easy, but it's not rocket science.\n", "id": "d6rxt56"}, {"comment": "> For a front-end dev applying for an angular position\n\nGoogle doesn't hire for a role, they hire for the company. In fact, you don't usually start talking to teams until after you have an offer. I believe there are some exceptions to this (Software Engineer - Security, probably and probably higher level positions) but for the most part, you are just interviewing as a Software Engineer (though you do interview for a location, so there's that). This is so that an engineer can more freely move between teams and doesn't inherently set up an environment of \"team A has a higher bar than team B\" (though there certainly is elements for that)", "id": "d6u21b4"}, {"comment": "Then find a practical test for a more generic software engineering position. Like I said before, professors do this all time.", "id": "d6u24bv"}, {"comment": "According to another comment in this article, on any day the hotel lobby is full of people trying out for google.  This is how they maintain their high rejection rate.  That necessarily means that it is not that hard to find a rejected google applicant.\n\nTo get a google job:\n\n* Find rejected google applicants (preferably in your network of friends, colleagues, and acquaintances).\n\n* Get them to violate their NDA by telling you about their interview experience (probably not that hard).\n\n* Reverse engineer the standard question lineup and the process in general.\n\n* Find solutions to all problems.\n\n* Excel", "id": "d6uia3o"}, {"comment": "Oh don't worry they have those too.", "id": "d6sl8fc"}, {"comment": "I've been doing a *lot* of online coding tests recently when applying for jobs. I'm a self-taught programmer (>20 years now) with no CS background, so plenty of experience coding stuff that works, not so much in passing algorithmic puzzles on first-look.\n\nAfter averaging 90+% across multiple tests, I managed to score a (hilarious) 3%, where in one part I misunderstood the problem statement, and the other required math that I just *do not know*. In the post-test review it was suggested that I spend some time on some algorithm-practise sites to build my algorithmic skills *to pass the test*. \"Is this the kind of work I'll be doing if I get the job?\". \"No.\"\n\nI will set some time aside to work on it, it's a weakness so fair enough, but it seems a really daft way to hire people.", "id": "d6rnsb8"}, {"comment": "> The thing is, the interviewer isn't so much looking for you to give him/her the answer as wanting to see how you reason through a problem.\n\nIf your reasoning is anything other than \"this is a solved problem, let's go grab the solution off the shelf that's been vetted by 50,000 eyeballs\" then you're not a hirable developer.\n\nThe trouble is that any sort of problem for which there's not already a good solution is the sort that even geniuses take decades to solve. Or worse, probably mathematically impossible (P=NP).\n\nSo, if you can't ask them the hard questions, and if the not-hard questions can be found with at most 2 minutes of googling... they feel as if the only option left is to ask those not-hard questions but disallow googling.\n\nThis also puts interviewees on the spot. If they could reason through it in 20 minutes (the people who solved it originally probably spent months or more on it), what if you come up with the non-canonical answer? Sorry, you didn't recreate the canonical solution down to the tiniest detail.\n\nWhat if you go down one of the blind alleys (you only had 20 minutes)? Sorry, you *didn't even solve it* (though, no doubt the people who originally solved it probably went down the same blind alley).\n\nAll this is doing is rewarding uber-nerds who memorized every single compsci course they ever enrolled in. Obsessively. \n\nIt's not about how you \"reason\", it's about whether you can succeed at whatever hoop-jumping they come up with because they're so shitty at hiring that they don't even realize that hoop-jumping's not a good test.", "id": "d6r1ed0"}, {"comment": ">The trouble is that any sort of problem for which there's not already a good solution is the sort that even geniuses take decades to solve. Or worse, probably mathematically impossible (P=NP).\n\nThis is absolutely incorrect. Many (probably most) engineering problems are questions on what the best solution is given the *business problem* (not an esoteric computer science problem), the existing systems, established software contracts, user experience, and time. These problems definitely don't have a Google-able answer. ", "id": "d6r4cr2"}, {"comment": "You must have been a real hoot on school math exams.", "id": "d6rdndx"}, {"comment": "\"You don't understand, professor... it's a *solved problem*\"", "id": "d6rs4k2"}, {"comment": ">  Why can't they use a library or Internet at large?\n\nBecause they want to see how you deal with a problem if you have to come up with a solution yourself", "id": "d6qs9d5"}, {"comment": "I understand that. If that's what you want then ask me ways to approach the problem, not \"do x with y restriction so we can measure some other metric we've not told you\".", "id": "d6qsmw0"}, {"comment": "That's the other part. Seeing if the candidate can understand what 1000 other candidates can understand is a test of whether they need to be hand-held to understanding or if they're reasonably able to infer what's necessary. When one is asked \"How would you approach this problem?\" saying \"I'd google an answer\" is not acceptable, and knowing innately why this is the case is important. \nIf the candidate can't figure out implicit assumptions, standard communication is going to be very poor and you're going to have \"but you didn't tell me that it shouldn't allocate all the memory on the machine\" situations.\n\nEngineering teams, especially at Google, are not single-person entities and lacking the ability to understand the context based off the environment is a red flag. Engineers are not automatons that convert a fully-specified business logic document into code. They make decisions and trade-offs, and understanding the constraints the team is working under without having to be told is where a lot of the value is.", "id": "d6qu8p6"}, {"comment": "Even when you come up with a solution using google, you're still coming up with the keywords to use for the search \"by yourself\". In my experience, coming up with the keywords to get the right solution from google can require a bit of knowledge and experience.", "id": "d6qxscu"}, {"comment": "Very few of the problems non-entry level engineers will face have Google-able answers. Figuring out how to solve homework problems isnt really that useful when your problem is something specific to your business. ", "id": "d6r1ndr"}, {"comment": "> Very few of the problems non-entry level engineers will face have Google-able answers.\n\nMaybe not with one single google query. But every problem can be solved with a series of google searches. You do the first search, get a hit, read the content, then come up with leads for your next search. Rinse and repeat until the problem is solved.", "id": "d6r1sj0"}, {"comment": "OK, can you illustrate for my edification how you would google a solution to https://www.codechef.com/problems/ALLPOLY, if you assume for purposes of this exercise that the solutions you can look up on codechef don't exist (simulating a non-leaked interview question).", "id": "d6rdvn9"}, {"comment": "That problem doesn't represent an actual problem a programmer would face day-to-day at a commercial programming operation. Obviously you can't google to solve academic problems.", "id": "d6rpiyy"}, {"comment": "I can't think of any nontrivial actual problem I would face day to day that could be understood and solved and in working code by an engineer totally new to the codebase in 45 minutes.", "id": "d6rv28u"}, {"comment": ">Why can't they use a library or Internet at large? In the project they'll be working on do they not have access to either of those things?  \n\nA lot of \"testers\" or \"judges\" (for lack of a better word) fail to realize how unrealistic this is. It's like in college where you're taking a test in some engineering class and calculators are prohibited. After interning with an engineering firm for 3 semesters where I've seen and worked firsthand at using calculators on the job _in the real world_, part of doing that real job is knowing how to effectively use the tools you should be using. Restricting you of those tools makes you less prepared for the real world, not more prepared. At best, it forces you to learn how to work without those tools, but you'll be less productive and your work will be more time consuming.  \n\nIMO, the best way to judge someone's ability to do something is to make the scenario as realistic as possible. Let them use tools like they would if they were hired. You wouldn't judge someone in a scenario that would not likely happen if they were hired.\n\nIf you want to test someone's creativity and \"see how they think\", just give them a recent problem your team had with dealing, make it generic if you want to hide details pertaining to your company, and see how they work through that problem, not some bullshit like \"bubble sort an array of ints by their 2nd digit\" or \"turn the word `palindrome` into a palindrome\" or some algorithmic stuff like that. That's very unrealistic if they were actually hired, whereas my example of a good test question is very realistic.", "id": "d6qxsmv"}, {"comment": ">It's like in college where you're taking a test in some engineering class and calculators are prohibited\n\nIn my upper level physics and math classes we weren't allowed to use calculators. They weren't really useful either.", "id": "d6sleaw"}, {"comment": "i had an interesting professor who taught a couple of engineering classes without the use of hard numbers (everything involved just variables/letters). Calculators weren't needed (how could you use them?), and his teaching methods were based on solving stuff without the need for numbers. Which I felt was very effective in learning the class (if you understand where to put in numbers, the numbers don't matter. Put in any number and you get your desired result).  \n\nI feel that's the only acceptable means of banning calculators in such a course, when the usage of calculators would literally not help you at all.", "id": "d6slmux"}, {"comment": "> If you want to test someone's creativity and \"see how they think\", just give them a recent problem your team had with dealing, make it generic if you want to hide details pertaining to your company, and see how they work through that problem, not some bullshit like \"bubble sort an array of ints by their 2nd digit\" or \"turn the word palindrome into a palindrome\" or some algorithmic stuff like that. \n\nSure, but \"Write a new tooling for D because the memory profiler was insufficient to find a bug in the garbage collector\" isn't likely to get very many people through the interview. Neither is \"Implement a decision tree for fast packet classification and policy application\". Both of which are things I've done relatively recently for work.\n", "id": "d6rf80l"}, {"comment": "You could simplify those a bit possibly, for the sake of interviewing.\n\nBut if you're trying to hire someone to solve these problems on the job and they don't do a good job with a simplified version of that problem, I would think that tells you a lot about them in regards to your needs for that position in your company.", "id": "d6rfl0t"}, {"comment": "Logistics mostly I think. Consider the volume of interviewees and the number of engineering hours it takes to prep, conduct, and write feedback for all those interviews. They need to keep it as simple as possible.", "id": "d6rdhcu"}, {"comment": "> Why can't they use a library or Internet at large?\n\nOf course you can use libraries -- hell, I used to tell my interviewees that they don't even have to remember the libraries, they can make up functions that they think should exist as they go along.\n\nAs far as the internet at large: We're looking for your ability to understand and debug a new problem; We already are assuming you're smart enough to copy and paste.", "id": "d6reuyp"}, {"comment": "To quote the article:\n\n> Candidates should be able to answer three coding questions from scratch (without the help of a library function) within 45 minutes.\n\nIt's not exactly clear what is and is not allowed but there is the quote.", "id": "d6rf804"}, {"comment": "I think the idea is that if I say `implement find_substring_in_string()`, then saying \"I'd call `string.find()`\" is fine as a throwaway comment, but is not exactly a serious answer. But if it's a minor component of a larger problem? Go for it. If it's important, I may ask you how you'd implement it, as a follow up question.\n\nAnd yes, substring search is not a good question, but it's an example that obviously has an answer that can be found in a library.", "id": "d6rfbqg"}, {"comment": "> Why can't they use a library or Internet at large?\n\nBecause it makes it harder to come up with a problem that hasn't been solved aready.", "id": "d6rjush"}, {"comment": "I got scouted for a position as an engineering manager (SRE) recently despite not having a college degree (I studied music for 3 years, didn't finish), and being over 40. The technical interviews were pretty in-depth, but not really of the 'gotcha'-kind. I'm waiting for the final feedback, but I'm not sure if I'm ultimately going to take the position if they offer. In any case, compared to their reputation 10 years ago, they do seem to have mellowed down a lot in terms of hiring considerations. ", "id": "d6qose3"}, {"comment": "If that's a site reliability engineering position, you can get a decent feel for that type of work from their book about it: https://landing.google.com/sre/book.html\n\nIt's not every day you get a book to inform you about a specific position AND company you're considering.", "id": "d6qsaos"}, {"comment": "Good luck! For what it's worth, I know several excellent SREs who lack college degrees. It can often be helpful to have one to get to the initial interview, but is decidedly not necessary for being hired.", "id": "d6rbu3c"}, {"comment": "Well they are trolling reddit now as well as linked-in and github. So that changed.", "id": "d6qun9d"}], [{"comment": "seems like doctored article to get people to apply for google so they have more talent to pick from.", "id": "d6qle9e"}, {"comment": "I interviewed with google last month. I met like ~20 people who were also interviewing at google at the hotel breakfast. Some of them said they have been prepping for the interview everyday for past 4 months ( didn't help with my confidence :)). \n\nReception at the google was filled with people waiting for their turn to be picked up. And this was just one building among of many, many buildings.  \n\nLady at the reception at Avis car rental told me that sometimes they get 100's of people coming everyday for interview at google. \n\nIt was bizzare and surreal to experience 'interview industrial complex'  first hand.", "id": "d6qr32m"}, {"comment": "I wonder if Google has lost some of its glow as a being great company to work for. . .\n", "id": "d6qmfy5"}, {"comment": "I'm all for people trying to work at Google. Frees up interviews at lesser known places for guys like me.  \n\nI tried to interview for them twice. But given all the prep you have to do months ahead of time _even as a senior dev_, it's exhausting and not worth it. The company I work for now hired me based off of my resume, Github projects, and interviews tailored to the job I was applying for (and by that I mean, if I'm being hired as a senior mobile dev, don't ask me questions about backend databases or frontend libraries, wtf would I know about that as a _mobile_ dev? You wouldn't judge a quarterback based on how far he can kick a ball even though it's the same sport being played.) Now I get paid over $130k in the Portland area with full benefits plus stock.  \n\nMay not be as good as Google, but I'm satisfied where I am currently.", "id": "d6qxjmn"}, {"comment": "They take \"senior\" extremely seriously, unlike a lot of other companies. A person at a senior rank in the job ladder has the expectation to be cross functional to the point where they can contribute to all of the diverse coding environments used by any single application, or effectively lead a small team of engineers.", "id": "d6r7reo"}, {"comment": "no, since Google treats all non-Google experience as worthless and only values coding quizzes, it's not surprising most senior people I know don't even want to interview there, and the ones that have will never go back\n\n", "id": "d6rgasj"}, {"comment": "Wait, what does senior mean elsewhere? It seems that if you're senior, you should be able to actually maintain all of an application and have enough technical ability to take a tech lead role if needed -- this doesn't seem to be a high bar at all to me.", "id": "d6reh7y"}, {"comment": "My experience there as a senior hire led me to the opposite conclusion. ", "id": "d6rh1dp"}, {"comment": "> But given all the prep you have to do months ahead of time even as a senior dev, it's exhausting and not worth it. \n\nThat's exactly how I feel, if I went through all that trouble and didn't get a job at Google, I'd be pissed off.  Plus, as you mention, there are lots of excellent smaller companies to work for, Google was once one of those companies.\n\nYes, the whole Google interview process to me just comes off as elitist and cruel.  I interview lots of people for my company and I tell them up front \"I am not trying to trick you or trip you up, I want to see that you can write code, solve problems and most of all I want to see how you think.\"  I also tell candidates that I'd rather have them ask questions and actually finish the problems than be silent and get stuck.\n\n", "id": "d6r69ig"}, {"comment": "yup...I have interviewed hundreds of candidates over the years at various companies and I also promise them one phone screen, one day of on-site interviews, then offer/decline. From first contact I try to get it all done within two weeks. ", "id": "d6rgdm1"}, {"comment": "To be fair very few \"senior devs\" meet the bar of Google senior dev. It's much higher than at most companies.", "id": "d6rdf5q"}, {"comment": "Then they shouldn't bother contacting the candidate at all.\n\nGoogle recruiters do no homework, it's pathetic. You should be able to tell from a resume if a person is an obvious miss. My guess is the first-pass recruiters are contractors on commission.", "id": "d6rghlu"}, {"comment": "I don't mean they don't hire senior dev titled people, just that there is not an assumption that the title means anything during interviews, at least in my experience and what I've read of other people's experiences. And considering some of the very senior engineers I've worked with I would say they are correct to not trust the resume.", "id": "d6ro0is"}, {"comment": "> mobile dev\n\nWhat does being a \"mobile dev\" involve if it's not about backend or frontend? Just curious here.", "id": "d6rre83"}, {"comment": "Maybe he meant web frontend?", "id": "d6rsjw2"}, {"comment": "Ah that might make sense.", "id": "d6rtfyq"}, {"comment": "Mobile development, Android, iOS, etc. That's not the same as web development which is browser-based rather than device-based.\n\nThere have been a few interviews where I have been asked questions pertaining to backend or web development but the job was for a mobile dev. The questions weren't generic development questions and it's kinda hard to answer a question about a position you don't specialize in. Thus my metaphor about the quarterback kicking the ball. Quarterbacks and kickers play the same game but different positions, and thus have different roles to play. You can't judge one position based on the roles of others.", "id": "d6ruanw"}, {"comment": "Tom Brady is an excellent punter. Just saying...", "id": "d6t3fz6"}, {"comment": "Absolutely.", "id": "d6qq28g"}, {"comment": "The interview process undoubtedly sucks. Once you're in the door, though. . .", "id": "d6r7t69"}, {"comment": "Meh sorry, Google has churned enough now that you'll find plenty of roadkill with Google on their resumes. \n\nIn 2010 I would have agreed, not now.", "id": "d6rgjno"}, {"comment": "Absolutely. Civilians don't know it so every week I have friends telling me how I should work for them and are amazed when told that it's probably going to be a terrible job in which I'd be a small cog in someone's enormous machines instead of having almost unilateral authority over designs like I do today, and the interview process would be nothing other than Kafkaesque.", "id": "d6r6e1b"}], [{"comment": "[deleted]", "id": "d6qooka"}, {"comment": "Practicing!? For an interview?\n\nSchool taught him some horrible lessons.\n\nOr, this is just the result of too many people going through their process and they need hoops for them to jump through so generic recruiting folks can grade them. This also makes sense if they're seeking \"skilled but bland\" staff, rather than gifted individuals.\n", "id": "d6qrgyq"}, {"comment": "[deleted]", "id": "d6qrv0l"}, {"comment": "They actually have quite low turnover. I didn't see numbers in your link, just quora type questions.\n\nAh, and the confusion of tenure with turnover, which conflates rapid growth with dissatisfaction.\n\nIf a company doubles in size each year, even if no one leaves, the average tenure will stay under a year.", "id": "d6qthoq"}, {"comment": "Not to mention they do hire large numbers of temps and contractors, for whom turnover can indeed be very high because they're actually using temps and contractors according to labor laws: for temporary and contracting positions.", "id": "d6r7xxg"}, {"comment": "This. Notably all the numbers I've seen for any of the big tech companies make no distinction on job role (engineers, salespeople, recruiters, janitors, cooks, etc. are all lumped together) or by temp/full time status.", "id": "d6re5nv"}, {"comment": "If you have a Phd, high SAT/GRE/etc, a support role at Google, you'll get saturated of better job offers. That's why the turnover. And they don't care that much, obviously. They want young impressionable people to do the lesser jobs for their ad network.", "id": "d6qt8kf"}, {"comment": "> from scratch (without the help of a library function) \n\n\"Write a program that writes 'Hello world' on the standard input.\"\n\n    printf(\"Hello world\");\n\n\"No library functions.\"\n\n    write(0, \"Hello world\", 11);\n\n\"That is still a library function. I think you are not a good fit for this company.\"", "id": "d6qwjsr"}, {"comment": "    int main(int argc, char **args) {\n        char *wellFineThen = \"Hello world\\n\";\n\n    #if defined(__gnu_linux__)\n        __asm__ (\"movl $4, %%eax;\"\n                 \"movl $1, %%ebx;\"\n                 \"movl $12, %%edx;\"\n                 \"int $0x80;\"\n                 :\n                 : \"c\" (wellFineThen)\n        );\n    #elif defined(__APPLE__) && defined(__MACH__)\n        __asm__ (\"movl $0x2000004, %%eax;\"\n                 \"movl $1, %%edi;\"\n                 \"movl $12, %%edx;\"\n                 \"syscall;\"\n                 :\n                 : \"S\" (wellFineThen)\n        );\n    #else\n        #error Unsupported system\n    #endif\n\n        return 0;\n    }\n\nPortability may be affected.  Error handling is scheduled for milestone #2.  Tested on GNU/Linux x86_64 and OS/X 64-bit.", "id": "d6r7izp"}, {"comment": "> Tested on GNU/Linux x86_64\n\nAre you sure? 'int 0x80' is for 32 bit applications, and you're using 32 bit registers.\n\nAlso, you're still using __libc_start_main() or its equivalent on OSX.\n\n</nitpicking>", "id": "d6rgvy6"}, {"comment": "> Are you sure?\n\nI'm sure I tested it on that architecture, and I'm sure it \"seemed\" to work.\n\n> Also, you're still using __libc_start_main() or its equivalent on OSX.\n\nI'm not, the linker is.  The challenge didn't say I had to write my own linker, just not call library methods, and I don't call `__libc_start_main()`.  If you meant for a solution involving hex digits to be interpreted as a Mach-O executable, then you might have to give me a bit more time than this interview allows for, sorry.\n\nI am starting to see what people mean about the Google interview being intense!  :-)", "id": "d6ri7lg"}, {"comment": "I believe it will still work if you have a kernel compiled with CONFIG_IA32_EMULATION. I think all you have to do is  use the 64-bit `r` prefix registers, `syscall`, and the 64-bit `q` suffix instructions to make it work with that off.", "id": "d6rj628"}, {"comment": "[Release Candidate 2](https://github.com/codebje/nolibraries/blob/master/nolibraries.c) is looking much more concise!", "id": "d6rk3c4"}, {"comment": "Huh, I never really thought about it. I guess linux doesn't actually care about 32 vs 64 bit for how you enter the kernel, and doesn't use separate syscall numbers, so as long as your addresses are below 4 gigs, your 32 bit syscall ABI would work for 64 bit mode.\n\nFor reference, Linux, *BSD, and OSX all share a common calling convention for 64 bit system calls, although the numbers differ, and OSX/FreeBSD both have a few calls with funky ABIs, like lseek or gettimeofday which returns a 64 bit value in %eax:%edx, instead of in %rax, and pipe which returns a pair of FDs in %eax,%edx instead of using the array that you pass it.", "id": "d6rktrh"}, {"comment": "    //no #defines so I'm good right??\n    int main(int argc, char* argv[])\n    {\n           char * hello = \"Hello, world\\n\";\n           int i = 0;\n           for(; i< 13;i++)\n           {\n              putchar(hello[i]);\n            }\n           return 0;\n    }    \n\n**I've not written C in years** please don't laugh at me. I'm shocked it complied and correctly printed on the first try.\n\nTested on 3.16.0-4-amd64 #1 SMP Debian 3.16.7-ckt25-2 (2016-04-08) x86_64 GNU/Linux gcc version 4.9.2\n", "id": "d6rgyi3"}, {"comment": "Well of course it worked, but you used `putchar`, which is a standard library function, and you're not supposed to use any libraries!", "id": "d6ri8zn"}, {"comment": "> \"That is still a library function. I think you are not a good fit for this company.\"\n\nYou mean because you\u2019re calling the Glibc wrapper\nand not ``syscall(2)``? That\u2019s insidious ;) I would\nhave given the interviewer the finger and walked out \u2026", "id": "d6qxya0"}, {"comment": "`syscall` is a library function.\n\nAlso, you can't write to standard input...", "id": "d6r1jpg"}, {"comment": "> Also, you can't write to standard input...\n\nNot with _that_ attitude.  No hire!", "id": "d6r7mv3"}, {"comment": "I did wonder about the wisdom of mentioning it! After all, who likes a smartarse. (And anyway, there's two sides to stdin... input has to come from *somewhere*! Perhaps that's what was meant?)\n\nOf course, were the tables turned, the interviewee suggesting writing to stdin would be instantly shown the door, I am sure - and quite rightly so ;)", "id": "d6r8ls8"}, {"comment": "I think the whole point is to implement your own things, so:\n\n1) invent your own type of dark matter;\n\n2) invent materials from it;\n\n3) invent your own pc from your materials;\n\n4) write your own programming languages;\n\n5) write code in your language.", "id": "d6rkezt"}, {"comment": "Coding interviews are such nonsense. Like asking a chef the exact process to make steel because he uses a knife or asking a personal assistant the exact process to make paper because the job entails writing letters.", "id": "d6qui7f"}], [{"comment": "[deleted]", "id": "d6qm8p7"}, {"comment": "I was working on a start-up a couple years ago (pre-funding) in Mountain View. I went to visit a friend a Google for lunch. After working stressful 14 hours days and eating taco bell for dinner at 2am, stepping onto Google's campus seemed like the land of Oz. There were people playing beach volleyball. The food was free -- I mean you literally just take it off the shelves and leave. It was surreal. There were a dozen different cafeteria choices, each with a different cuisine. It was probably exhaustion, but I could feel tears welling up because it was just so overwhelming.", "id": "d6qobi8"}, {"comment": "All those things are tricks to get the young and impressionable to take a job for little money. Perks are cheap.\n\nEDIT: Google pays very well for the job, problem is they hire people way over-qualified who could land a job for a lot more money and more interesting. There are many jokes about Google hiring the best Phds to have them make, optimize, and support yet another online ad platform. \"World changing\"", "id": "d6qppld"}, {"comment": "[deleted]", "id": "d6qqs76"}, {"comment": "Ya I'm not sure what young and impressionable person wouldn't take $100k + stock fresh out of college, free snacks or otherwise. ", "id": "d6qsfx6"}, {"comment": "Well, there was that Google employee wage fixing scandal with a number of other companies such as Apple in the past.", "id": "d6r7eeo"}, {"comment": "I totally made $3500 off of that!  So, the employees got what was due to them eventually.\n\n$3500 / 4 years = $875 a year, probably, yeah, that's probably the amount they we're low on salary because of price fixing.  Not like $100-200k differences per year or something if they were to compete for desirable candidates...", "id": "d6rerrq"}, {"comment": "Not as tricky as the \"be your own boss!\" line that startups sell their employees, whom they pay even less money.", "id": "d6qqj4o"}, {"comment": "\"be your own boss... that reports to a boss\"", "id": "d6qrv1i"}, {"comment": "Translation: \"We expect you to do everything for a relatively small chunk of equity, and we expect you to be excited about it! We secretly wished you were a former google engineer, but we settled for what we could get. If you succeed, we'll let you hire your own boss to crack the whip for us! Startups are fun!  Unlimited vacation!\"\n\n", "id": "d6qspeg"}, {"comment": "We have a flex work policy! We'll be flexible and let you come in at 10 and leave at 9 to accommodate all of your passion.  It's passion not mismanagement and unreasonable deadlines. ", "id": "d6qrzdj"}, {"comment": "I typically do 10:30-10 or 12. It doesn't feel as grueling any more, mostly because everyone leaves at 6 (whereas in the early days people would stay 'till midnight.) The madness during normal business hours is the main source of stress. Everything beyond that is relatively serene, like time in a bottle. ", "id": "d6qtayv"}, {"comment": "I mean I'm glad you got some peaceful time, but when do you have time to do anything else?  I hate job becoming life.  I have better things to do then to spend most of my waking hours making some mba money. ", "id": "d6qu12z"}, {"comment": "I'm really ashamed to admit that I don't do anything else. I could probably try harder, but I've always lacked discipline around personal time management. I'm sure other people do much better (hit the gym after work, socialize with friends, tend to personal commitments/obligations.)\n\nI tell myself that I'm like the heroic little dutch boy with his finger in the dam, but it's actually a combination of laziness and hubris that keeps me going.", "id": "d6qucqa"}, {"comment": "Google pays better than Amazon and Amazon offers near zero perks like these.", "id": "d6qs55l"}, {"comment": "Amazon sucks but that doesn't make Google a good option, either.", "id": "d6qsep0"}, {"comment": "Why don't you try listing some of the few companies that are actually good to work for? Because your standards for good work are retardedly high", "id": "d6qu40g"}, {"comment": ">for little money\n\nWhat are you even saying? You've just been spreading misinformation all over this thread. Did you fail a google interview or something?", "id": "d6qu1en"}, {"comment": "For little money? That's silly. Total comp is well into the 130k range. \n\nIt is a way to get you to spend more time on campus with other Googlers though. Makes it much more likely you'll continue working. ", "id": "d6qsids"}, {"comment": "Yeah but you have to live in Silicon Valley where nearly 50% of that will go to rent alone. ", "id": "d6rb13z"}, {"comment": "Even if that were true, that's still $75k/year. Still quite a bit more than most out of college jobs. ", "id": "d6rcp3k"}, {"comment": "There are many jokes, but no data.", "id": "d6re9pk"}, {"comment": ">Not much different than working at any other big compan\n\nIt's neither here nor there. Large companies do differ a lot in terms of their work environments.", "id": "d6qpbx1"}, {"comment": "If you get on a good team (which is a bit of a crapshoot) the working conditions are very reasonable, pay is bonkers good, and the perks are pretty good.  Have a couple close friends that enjoy it.", "id": "d6r9ouk"}, {"comment": "I don't really understand this attitude.  What's wrong with wanting to work at a place with good pay, perks, stability, and has a strong reputation?", "id": "d6r9wm9"}, {"comment": "> It must've been fun 10 years ago but these days you're just another cog in the machine.\n\nNot to mention you\u2019re basically working in advertising.", "id": "d6qy19j"}, {"comment": "I'd rather work there than risk getting a job at another company that still concatenates user input to their SQL queries and writes tons of other shitty code that they expect me to write features with.", "id": "d6qstej"}, {"comment": "raises hand", "id": "d6slj10"}], [{"comment": "He forgot to mention: don't be over 30!\n\nAge discrimination is rampant.\n\nIt's also discriminating against your future self.", "id": "d6qn6dj"}, {"comment": "30! = 265252859812191058636308480000000\n\n_____________________\n\n^(Result from) ^[WolframAlpha](http://www.wolframalpha.com/). ^(You can harass my creator) ^[here](/u/ProudPiMP).", "id": "d6qn6fj"}, {"comment": "I have to be younger than *that*? Seriously, fuck Google.", "id": "d6qnfa6"}, {"comment": "This industry is seriously biased agains decillionaires^[1](https://en.wikipedia.org/wiki/Names_of_large_numbers) , it's sickening.", "id": "d6r5wu9"}, {"comment": "Decillionarians!", "id": "d6rhc7f"}, {"comment": "Age discriminating Doctor Who. Future, past, current doctor.", "id": "d6qnqe3"}, {"comment": "This is ridiculous. Maybe for the entry engineer position, they would look at years of experience, but most people I know who were hired at Google above the first couple levels were definitely in their 30s. \n\nWhich makes sense to a certain extent. If you have 15 years experience but you're only qualified for an entry level position at Google, there isn't much evidence you will grow there. You might be a perfectly fine entry level engineer but they are looking for people who will advance. And if you couldn't get there in 15 years, you probably won't get there soon. ", "id": "d6qsa50"}, {"comment": "You'll notice that nobody making the \"age discrimination is rampant\" claim (they always use that phrasing for some reason) has any data to back it up. You'd think if an entire industry were violating federal labor law on a massive scale, someone would have bothered to tabulate a spreadsheet.", "id": "d6remmn"}, {"comment": "Ya it's just a way for people to feel better about not getting an offer. They can point to all the people occupying low level positions and scream \"discrimination\"", "id": "d6rfde2"}, {"comment": "Seriously, if anything the stereotype nowadays is that people work at startups when they're young and then go get a job at Google when they want to start a family and have a stable paycheck.", "id": "d6r3v0t"}, {"comment": "Depends.  I got hired by them aged 38.\n", "id": "d6qsb2j"}, {"comment": "I got hired there at 36.", "id": "d6qwkmy"}, {"comment": "I'm 46 and waiting until I am 50 so I can offer myself as the token geezer they can put in their diversity ads.\n\nI'm only half joking...I really do expect companies to eventually hire token greybeards once ageism claims start to stick", "id": "d6rgvhn"}, {"comment": "I see job listings all the time from major companies that pretty much say to not apply if you're not \"young at heart\" or \"youthful in nature\".\n\nThey are skirting the very edge of age discrimination laws, but since they aren't setting an age limit, it's technically legal, but they will never hire you if you're over 30 and they don't have to give you a reason for not hiring, they just won't even contact you.", "id": "d6qrter"}, {"comment": "I thought it was telling they didn't mention age anywhere. Very graduate focused.", "id": "d6qpw9n"}], [{"comment": "That's what gets me about these companies.  They tell us we need to practice for an interview.  That's interesting... so someone will cram in bunch of important knowledge just to squeeze by the interview process and then flush it all down the toilet.  Look at the educational system.  It has been proven over and over that tests are a pile of garbage and do not correctly reflect students' knowledge across the broad spectrum.  People cram for tests, know that information for a few days and then poof... gone just like that.  So, the entire process favors those that are good at short term memory and plenty of free time on their hands prior to an interview over those who actually possess valuable knowledge that perhaps may not be applicable to a few of their trick questions during the process.  I don't have an extensive experience (I actually don't know what would be considered extensive...) -- just over three years of experience with C# and WPF.  I do, however, know how to interact with the client to get the specification, establish a timeline, design custom controls in WPF, create tests, create documentation, use several important patterns, exercise good practices in both WPF and C#.... yet none of that is going to matter when they throw in some graph problem that I haven't \"prepared for.\"  I don't even think Google would hire a C#/WPF developer, but that's besides the point.\n\nEdit: Correction, I guess they do hire C# developers. ", "id": "d6quraw"}, {"comment": "You are correct that competence is the thing they are looking for, and failing in every way to detect, or even specify as their desired result.\n\nThat's one of the reasons they can't find it, because they don't know what they're looking for.  They keep getting confused by shiny things, that \"seem important too\", when really they just need a bunch of competent people.\n\nCompetent people will have a good base, learn what they don't know, will get shit done, will evaluate it to do it better next time, will not waste resources, will make simple solutions to simple problems, will allow others that are better than them at things to do them, so that everyone gets the best results, etc.\n\nWhen you have to start getting into definitions of what \"a good base is\", you're already off the right path into the weeds, looking into a sewer hole, and deciding whether to crawl in.\n\nBasically, if you want good hires, get good people (like you), and do a quick ability test (\"tell me what you're good at, prove it to me\"), and then determine if they are someone \"like you\", in the sense that they are competent.  Repeat.", "id": "d6rf3ri"}, {"comment": "I cannot upvote you enough so sorry for just the one +1; you are quintessentially and infallibly correct!", "id": "d6rplgc"}], [{"comment": "Unless you actually are highly specialized, like, for instance, a PhD-holder in computer science. That degree is sought-after by google for the bragging rights, but the hiring process cares exactly zero what you're research is. Zero. PhD is all about research. Nobody does it for the fame, as is there isn't any.\n\nOnce you're hired as a \"software engineer\" (just like everyone is at google), they then start up gMatch (which takes 3 months for some reason), and you *hope* they have a project to pick that's sort of relevant to what you've spent a decade becoming the world leader in. \n\nCompared against traditional academic and research/industry jobs, which hire you because you're one of the best at the thing they want to do, both you and google have no idea what you're really getting from each other, and *google doesn't care.* ", "id": "d6quzog"}, {"comment": "Agreed, with a correction: _Google can afford not to care but you can't afford the same thing._", "id": "d6rpp16"}, {"comment": "Not always. I do have a small handful of friends who had no particular plan on what they wanted to work on, and google pays bank for you to roll with it. \n\nIt did result in one person with a higher degree in math running a logistics chain of buying hardware parts for a while... But only for a while.", "id": "d6rr7ih"}, {"comment": "Sure, I have nothing to add but that the exception confirms the norm.", "id": "d6sawq6"}, {"comment": "Well they've figured out that degrees don't necessarily correlate with performance. Correctly, imo.", "id": "d6slor0"}, {"comment": "Yet BA/BS and MA/MS in Computer Science or Engineering is still listed as the top minimum qualification on their job listings.", "id": "d6sq9ko"}], [{"comment": "It's okay to leave GPA off your resume not because they no longer use it, but because they want to see your transcript and can get it from there.", "id": "d6qoq1z"}, {"comment": "Or you don't have a GPA score because you're not American... GPA scores are ridiculous.", "id": "d6qosx4"}, {"comment": "You will still have some kind of overall grade average if you went to college outside the US, GPA is just the local parlance. ", "id": "d6qrj7a"}, {"comment": "> You will still have some kind of overall grade average if you went to college outside the US, GPA is just the local parlance.\n\nNot an average, only final grades determined by exams\nand the thesis. I guess you could calculate an average\n(mean? why not median?) but you\u2019d have a hard time\ndeciding which courses should count, let alone getting\nthose numbers from the university archives.\n", "id": "d6qy5ct"}, {"comment": "> Not an average, only final grades determined by exams and the thesis. I guess you could calculate an average (mean? why not median?) but you\u2019d have a hard time deciding which courses should count, let alone getting those numbers from the university archives.\n\nTake all your final grades and average them. There, you have a average of all your grade points.", "id": "d6rgted"}, {"comment": "Nope. Not true.", "id": "d6qvw4b"}, {"comment": "Do you get grades in your classes? Then I promise you there is a way to average them and get an idea of your overall academic performance.", "id": "d6qxqdi"}, {"comment": "Sure I get my grades but not those of others. People talk about them but so you know what's good and what's bad but this is hard to make precise and depends on field of study and university. Also, in plenty of classes no student gets 10/10 so it's unclear whether a 8.5/10 was the best grades in that class or just good. \n\nTechnically, I could put my grades in a calculator and get a number but it has no meaning. If I ballpark the GPA of the very best I'd say they would've a GPA between 3.00 and 3.33.", "id": "d6qyiyr"}, {"comment": "I mean if employers don't look at it in Europe, I believe you. Doesn't mean you literally don't have some mathematical equivalent of a GPA score. I never said anything about what it gets used for, just that it exists.", "id": "d6qz9cr"}, {"comment": "Sure we get grades and you can average those. So mathematically yes. However, a grade average is used but never as a filter, just as a little piece of information. ", "id": "d6r051c"}, {"comment": "Your final grades are used as filters though. ", "id": "d6r4yb8"}, {"comment": "With grade inflation these days, a GPA doesn't mean much anymore.", "id": "d6qql4d"}, {"comment": "With personal preferences being given, it never was a good indicator.\n\nIf you could classify someone as unlikable, and still having high scores, at least you might be able to reduce out that conflict, but...\n\nIn the middle or low-end of the pack, it doesn't matter, but at the head of the pack, it often matters.", "id": "d6rez13"}], [{"comment": "No thanks. I'd rather not sit through what I gather are multi-multi-multi stage interviews and have my knowledge and intelligence insulted at every step. I also don't want to work on some brilliant project just for Google to close it down after a few months because fuck users that's why.", "id": "d6qs4yv"}, {"comment": "Two phone interviews and a day on-site? Hardly unusual.", "id": "d6rhwel"}], [{"comment": "**Not programming** (read the sidebar)", "id": "d6qtag5"}, {"comment": "Even the bots quit.", "id": "d6rf84q"}], [{"comment": "Didn't have a great time interviewing with them, did my first test, got most of the questions right. Said I'd hear back in a week. I had to wait like 2 weeks before I email them and then they called me a week later. My only feedback was that my answers were \"borderline\" with no exppnation. I asked the HR guy to explain and that's all he knew and they decided to retest me like weeks later and got denied because my guy didn't understand how to do experimental mean statistics. I don't mind the denied part but the communication was terrible and random and filled with bad feedback. I don't think I'd apply to them again after that.", "id": "d6qsmu0"}], [{"comment": "Would it impress you if I could jump over a chair?", "id": "d6qtgnd"}], [{"comment": "This feels very geared towards people graduating from school.", "id": "d6qrlll"}, {"comment": "[It's the easiest time to hire a great engineer.](http://www.joelonsoftware.com/items/2005/01/27.html)", "id": "d6repqw"}], [{"comment": "Do they still still have a rigorous and long, drawn out interview process? \n\nI'm not very interested in going through anything like that unless I'm desperate. I'm curious if there will be an industry trend away from over the top interviews.\n\n", "id": "d6qwd7j"}, {"comment": "The industry trend seems clearly towards more Google-style interviews, not away.", "id": "d6requ3"}, {"comment": "What do you define as Google-style?", "id": "d6rh6g4"}, {"comment": "White boarding algorithmic or distributed systems design and implementation questions in hour blocks. The drawn out process part is probably not something the industry in general is going for though.", "id": "d6ro3gb"}], [{"comment": "Google rejects 90% of the people that apply, and then they complain that they can't find enough people.", "id": "d6r1zzn"}, {"comment": "Having studied at a university and knowing my classmates, I wouldn't hire 90% of them either. Group projects were always a horror.", "id": "d6r5lax"}, {"comment": "90%?  Try higher.", "id": "d6rbmip"}, {"comment": "I mean, they openly admit that their process has a high false negative rate. Mistake-hires (false positives) are too costly, so they understandably err on the side of caution.", "id": "d6rh1zf"}], [{"comment": "And I still haven't heard from my internship applications :( ", "id": "d6qos1i"}], [{"comment": "\"don't assume you're unqualified on the basis of your educational, professional, or personal background\" - so highschool dropouts with technical skills can apply too?", "id": "d6r54h0"}], [{"comment": "Google should study the nature of talent and genius. Few organizations like talent agencies or human resource departments have given any thought to the matter of how to locate the really talented geniuses. I think this could be done using personality profiles and Internet history, since a genius will naturally gravitate to certain subjects and eventually seek out certain online resources. \n\nThis is the subject of a play I am writing which concerns the poaching of a technology worker by a recruiter in an unrelated industry. A lot of bright people drift into IT because it is the easiest way to be rewarded for your genius. The Information Technology has created a vast brain drain which robs other industries of vital talent. Cross industry poaching would be a creative way to solve this problem.", "id": "d6rt3ln"}], [{"comment": "How about hiring people over 50, Google?\n  \nSomeone that's been programming since before you were born - and you're going to ask them data structure questions that anyone in their right mind is going to say: \"I use a library for that so I don't have to reinvent it every time\"\n", "id": "d6qtyo3"}]]], "4nv8x8": ["Vendors Must Cater To Developers Or Die", "2016-06-13 15:48:33", 0, "https://medium.com/@JoeEmison/vendors-must-cater-to-developers-or-die-7af7559dca70#.e0gqx4d95", [[1, "makes a bunch of questionable statements about the effectiveness of software and automation.\n\nhttp://www.economist.com/news/special-report/21621237-digital-revolution-has-yet-fulfil-its-promise-higher-productivity-and-better\nhttps://en.wikipedia.org/wiki/Productivity_paradox\n\nsoftware does seem inexpensive. but then we have a number of organizations that are stuck in a loop - switching from poor to poorer software at greater cost per iteration. [many have given up on 'upgrading' altogether](http://www.gao.gov/assets/680/677454.pdf), even when hardware long since has been out of production.\n\nthat nine billion dollar business is still pending to show a ROI. better climb onto the train before it goes off a cliff."], [1, "... Or Have A Monopoly Or Have You Vendor-Locked-In Already."], [0, "This article is about catering to a mass audience, e.g. a shopping mall setting.\n\nYes, it's different selling there than in than your Rodeo Drive boutique.\n\nMaybe get a trained marketer to deal with these things for you? It's a profession with a reason, however hard we might dislike it :-)."], [-2, "whats the TL;DR"]], [[{"comment": "makes a bunch of questionable statements about the effectiveness of software and automation.\n\nhttp://www.economist.com/news/special-report/21621237-digital-revolution-has-yet-fulfil-its-promise-higher-productivity-and-better\nhttps://en.wikipedia.org/wiki/Productivity_paradox\n\nsoftware does seem inexpensive. but then we have a number of organizations that are stuck in a loop - switching from poor to poorer software at greater cost per iteration. [many have given up on 'upgrading' altogether](http://www.gao.gov/assets/680/677454.pdf), even when hardware long since has been out of production.\n\nthat nine billion dollar business is still pending to show a ROI. better climb onto the train before it goes off a cliff.", "id": "d47b0dg"}], [{"comment": "... Or Have A Monopoly Or Have You Vendor-Locked-In Already.", "id": "d47bjlh"}], [{"comment": "This article is about catering to a mass audience, e.g. a shopping mall setting.\n\nYes, it's different selling there than in than your Rodeo Drive boutique.\n\nMaybe get a trained marketer to deal with these things for you? It's a profession with a reason, however hard we might dislike it :-).", "id": "d477oo6"}], [{"comment": "whats the TL;DR", "id": "d478c4c"}, {"comment": "If I have to contact sales to try your service you're out pretty much.", "id": "d479r9u"}, {"comment": "ahh thanks! definitely agree with that post!", "id": "d47a0vl"}]]], "40za29": ["4 Reasons why Java is still #1", "2016-01-14 22:52:50", 0, "http://azul.com/4-reasons-java-still-1", [[13, "Tiobe is not really worth talking about.  They have Javascript at #8 and assembly at #9.  Does anybody actually believe they are that close?  Or that Pascal is above R?  Or that Delphi is above Swift?"], [10, "I was surprised to see that the article didn't talk about Android at all. To me, Android is what \"saved\" Java. There was a long period in the middle, between Java 6 and Java 8 where the only real reason to use Java (for green-field development, at least) was because it was the preferred way for writing Android apps. The fact that you needed to know Java to write Android apps kept interest in Java high while development of the Java language itself languished."], [4, "Same reasons as javascript. Easier to learn, boat load of programmers, cross platform, great tools."], [4, "Is this an advertising article or something? \n\nLiterally every reason is bloated bs, along with the simple fact it's not been #1 for years.\n\nYou can beat a dead horse all you want, but it's not coming back to life. Devs and Companies alike have moved on."], [3, "The right tool for the right job."], [1, "I know people love to bash java.   and then bash it again.  \n\nBut actually point #1, should not be ignored.  I realize that some fraction of developers are bored/irritated with java.  Fine, move onto Haskell or Scala or perhaps Go.  The primary reason I like java is because an average or even below average programmer can write tolerable code with it.   I can also go back to code I wrote two years ago and understand it quickly.  Try that with a rats nest of javascript callbacks.\n\nA below average programmer writes crap in javascript or $php.  \n"], [-20, "[deleted]"]], [[{"comment": "Tiobe is not really worth talking about.  They have Javascript at #8 and assembly at #9.  Does anybody actually believe they are that close?  Or that Pascal is above R?  Or that Delphi is above Swift?", "id": "cyydwbe"}, {"comment": "From what I understand, TIOBE tracks something like 'total historical interest' rather than 'current interest'.  The issue is that they don't exactly advertise that well.", "id": "cyyflb6"}, {"comment": "I don't know about Pascal and R, or assembly and Javascript, but I have no trouble believing that Delphi is above Swift. Swift is an incredibly young language. Despite all the headlines on Reddit and Hacker News, most iOS developers have not yet moved onto Swift. Delphi, on the other hand, has been around for decades and there are lots of line-of-business applications chugging away that were written in Delphi. Those applications still need maintenance and support, even if it isn't necessarily cost-effective to rewrite them in a more modern language.", "id": "cyyj8nc"}, {"comment": "Do you know how the TIOBE index is calculated? Do you think you have a solid intuitive understanding of the entire world's consumption and use of programming languages in every software project everywhere?\n\nSpoiler: you don't, and no one does. The results are legitimate for the definition of the index ranking and definitely shine a light into the other kinds of software work being done outside of whatever particle bubble you live in.\n\nEdit to add additional detail:\n\nThe definition is here: http://www.tiobe.com/index.php/content/paperinfo/tpci/programminglanguages_definition.html\n\nAs pipocaQuemada pointed out, it is biased in terms of historical interest, but only to the extent that search engine algorithms include results to old web pages (something which they are loathe to do). If you can come up with a better system, please publish it and share your brilliance with the world.", "id": "cyyn4i0"}, {"comment": "> As pipocaQuemada pointed out, it is biased in terms of historical interest, but only to the extent that search engine algorithms include results to old web pages (something which they are loathe to do).\n\nSearch engines actively *delist* old results instead of pushing them down the rankings?\n\n> If you can come up with a better system, please publish it and share your brilliance with the world.\n\n[Redmonk seems a bit better for measuring more recent interest.](https://redmonk.com/sogrady/category/programming-languages/)", "id": "cyz7sd2"}, {"comment": "It's definitely another way to approach it, and their numbers are very different- but redmonk calculates the total number of github projects for a given language not recent count. You can also imagine that github and SO might have certain biases towards languages and away from others like Delphi.", "id": "cyz8oej"}, {"comment": "Apparently Pascal/Delphi are very popular in Russia.", "id": "cyyrm5y"}, {"comment": "Actually yes. On both counts.", "id": "cyyipz2"}, {"comment": "Pascal has traditionally been a language used in teaching programming. So I'm not surprised.", "id": "cyykqde"}, {"comment": "Sure, it was, more than 20 years ago. But it's been a very long time since anyone bothered to teach Pascal, whereas R is now being taught in statistics courses all over the place.", "id": "cyymdas"}], [{"comment": "I was surprised to see that the article didn't talk about Android at all. To me, Android is what \"saved\" Java. There was a long period in the middle, between Java 6 and Java 8 where the only real reason to use Java (for green-field development, at least) was because it was the preferred way for writing Android apps. The fact that you needed to know Java to write Android apps kept interest in Java high while development of the Java language itself languished.", "id": "cyyjeje"}, {"comment": "\"Saved\" might be a bit exaggerated. Java was already in the top three languages consistently before Android came around.\n\nAndroid has certainly expanded Java's appeal to an even larger pool of developers.\n", "id": "cyylxjd"}, {"comment": "If I wrote this article, it would look something like:\n\n1. Android\n2. Android\n3. Android\n4. Android\n", "id": "cyyk14e"}, {"comment": "I was expecting:\n\n1. Momentum\n2. Momentum\n3. Momentum\n4. Momentum", "id": "cyz1epo"}, {"comment": "Much of the software that runs the world -- from banks to governments, power plants, military etc. is written in Java. Google, Amazon, IBM, Netflix, eBay write much/most/all of their software in Java. Android accounts for a rather small portion of Java use.", "id": "cyyun05"}, {"comment": "Doesn't Netflix use a lot of Scala?  And Google uses a combination of C++, Java, Python, Javascript and Go.  Is 'much' of their software really Java?", "id": "cyz7fag"}, {"comment": "> Doesn't Netflix use a lot of Scala?\n\nNo. They use Java and some Groovy.\n\n>  Is 'much' of their software really Java?\n\nYes. They use C++ for shared libraries and critical infrastructure (as well as search), JS for the client, Python for some non-critical stuff and Java for applications. Go is used sparingly (mostly as a fast Python alternative).", "id": "cyzamc2"}, {"comment": ">> Doesn't Netflix use a lot of Scala?\n\n> No. They use Java and some Groovy\n\nThat must be why they presented at the [Commercial Users of Functional Programming](http://cufp.org/2013/jafar-husain-netflix-end-end-reactive-programming.html) and [the Scala Bay Meetup](https://speakerdeck.com/mpandit/scala-at-netflix).  Or why they gave a talk at skillsmatter entitled [Netflix + Scala](https://skillsmatter.com/skillscasts/5424-netflix-scala).  Because they don't use it.  Got it.", "id": "cyzb7ud"}, {"comment": "They used it when these presentations happened, which was more than two years ago.\n\nJust like LinkedIn, they have been moving away from Scala back to Java recently (if you look at their job board, you will find zero Scala positions and plenty of Java ones).", "id": "cyzh1tl"}, {"comment": "The question was whether they use \"a lot of Scala\". Maybe they use it a little, but they mostly use Java and Groovy (at least that was the case when I visited a year or so ago). Also, you should know that in the Bay Area it is common among Java shops to have a small team doing Scala or Clojure to attract developers that are drawn to new languages.", "id": "cyzl811"}, {"comment": "> I was surprised to see that the article didn't talk about Android at all. To me, Android is what \"saved\" Java.\n\nIndeed.  I literally never used Java professionally until I got my first Android phone. ", "id": "cyyk9y5"}, {"comment": "I'm unaware of any point in time where development of Java languished. Java drives most of the internet and has done for many years.", "id": "cyyksbu"}, {"comment": "> Java drives most of the internet and has done for many years.\n\nWhat do you mean by this?  Where does Java play a dominant role on the internet?", "id": "cyyppd8"}, {"comment": "Google, Amazon, Netflix, eBay, Spotify write much/most/all of their software in Java. Twitter is also nearly 100% JVM, as is Box and an unending list of smaller players.", "id": "cyyulb3"}, {"comment": "They might use the JVM, but I don't think they're all writing Java. Twitter, from what I've read, has written significant portions of its infrastructure in Scala. Scala does run on the JVM, and has nice backwards compatibility with Java, but it is not Java.\n\nAmazon does write a lot of Java, speaking from personal experience. Google, from what I can tell is pretty heterogenous. They certainly do have a lot of Java code, but they also have a lot of Python code, and an increasing amount of code that's written in Go, or Dart. I don't know anything about Netflix's infrastructure. It's conceivable that it could all be Java.\n\nThat said, that's not the point that I was trying to make. The point I was trying to make was that while there was plenty of code being written in Java, that code increasingly was limited to legacy projects in the enterprise. That is to say, few people were choosing to use Java as the preferred programming language for new development. If you looked at smaller companies, they were (rightly or wrongly) perceiving Java web stacks as requiring a lot of overhead and maintenance, and choosing other programming languages and frameworks (like Ruby/Rails) for new development.\n\nAnd then along comes Android and all that turns around. Now smaller companies and hobbyists have a compelling reason to use Java - they need to write mobile apps. ", "id": "cyyxuf4"}, {"comment": "> They might use the JVM, but I don't think they're all writing Java.\n\nAll alternative JVM languages combined hardly account for 5-10% of the platform.\n\n> that code increasingly was limited to legacy projects in the enterprise\n\nI understand, but that's just not true. As someone who was at one time a decision-maker in a very big, very serious software shop (defense related), I can tell you that Java -- from about 2000 to this day -- hasn't had any serious competition when it comes to large, important, \"serious\" software. Not only was the competition not slowly taking over, but there has hardly never been serious competition. \n\n> Now smaller companies and hobbyists have a compelling reason to use Java - they need to write mobile apps. \n\nWith that I can agree, but the \"small software\" space hasn't been dominated by Java pretty much ever. Even when Java was first introduced, \"small software\" was written in VB and other RAD tools (as we used to call them). It is those domains where there's a lot of competition. There was a time in the first half of the previous decade when for a brief amount of time, small-software developers have switched from RAD to Java, and it is those developers (or domains) that later switched to Ruby/Python etc.. Another interesting shift has been from Matlab to Python, in the scientific computation space (although I believe Matlab still dominates).\n\nThe biggest change hasn't been in Java's dominance, but in Silicon Valley's focus. Silicon Valley -- while never a large portion of the software industry, but a very visible one for quite some time now -- has migrated from large-software to small-software, and therefore has felt Java decline. But that was no more than observation bias. Even in Silicon Valley, Java pretty much dominates \"big software\".", "id": "cyyy3qk"}, {"comment": "You have a very strange view of this industry.\n\nBy all criteria examinable, Ruby/Rails has been in sharp decline these past five years and Java has continued to be the top language, even increasing its mind share and its role as the default language that new companies use.\n\nJava 8 has only accelerated that trend.", "id": "cyzhelv"}, {"comment": "> I don't know anything about Netflix's infrastructure. It's conceivable that it could all be Java.\n\n[Netflix, like Twitter, uses a lot of Scala.](http://www.slideshare.net/lobster1234/scala-at-netflix-26048254)", "id": "cyz7ljm"}, {"comment": "[deleted]", "id": "cyzhnwo"}, {"comment": "When did this happen, and why?", "id": "cyzj930"}, {"comment": "to suggest that JVM == Java at this point is disingenuous  \nEdit:  \nShould have been clearer, I meant that twitter pretty famously is heavily invested in Scala which makes it a poor example of a company using Java.", "id": "cyyxk9l"}, {"comment": "I didn't. The biggest players use Java the language. All alternative JVM languages combined account for no more than 5-10% of the platform (and that's a generous estimate). ", "id": "cyyxmqr"}, {"comment": "Java is > 95% of the JVM, so it's reasonable to equate them.\n", "id": "cyzhc1j"}, {"comment": "Back-end server processing on the most critical parts of our infrastructure? All the banking and government stuff I've seen it's jvm based", "id": "cyyqyol"}, {"comment": "I don't know about government stuff, but banks tend to have pretty heterogenous computing stacks, from what I've seen, mainly because they never throw anything away. So you have COBOL-running mainframes from the '60s talking to C++-running Unix boxes talking to the Java \"Enterprise Service Bus\" that some middle manager was snookered into buying talking to the Python toy project that the intern wrote last weekend.", "id": "cyyxez3"}, {"comment": "I was talking about development of the language itself. Of course there was new code being written in Java, but the Java language itself entered sort of a lull period between the release of Java 6 and Java 8. This was right around the time Sun was going bankrupt and getting bought by Oracle.\n\nAt that time, it seemed to me that there was a real danger that Java would end up like COBOL. Used extensively for enterprise applications, but not so much for consumer facing code, and ultimately slowly fading into irrelevancy.\n\nAnd then Android came along...", "id": "cyyxcwv"}, {"comment": "Java 7 came in between 6 and 8. And it has more new language, jvm and library features than 8 did. \n\nYou also have your android history not quite right. Android was based on Apache harmony which was in turn based on a Java 5 spec. Although it has since been updated, it has an older history than you think.", "id": "cyz17ac"}, {"comment": "The lull was only in versions: a long time went by between Java 6 and Java 7 but Java itself continued to be dominant during that time (and even increased its mind share). Also, you have your time line wrong because Android was already around during that time.", "id": "cyzhinc"}], [{"comment": "Same reasons as javascript. Easier to learn, boat load of programmers, cross platform, great tools.", "id": "cyyjx4q"}], [{"comment": "Is this an advertising article or something? \n\nLiterally every reason is bloated bs, along with the simple fact it's not been #1 for years.\n\nYou can beat a dead horse all you want, but it's not coming back to life. Devs and Companies alike have moved on.", "id": "cyymmrx"}, {"comment": "Could you care to share the list?", "id": "cz27svg"}], [{"comment": "The right tool for the right job.", "id": "cyyd7ms"}], [{"comment": "I know people love to bash java.   and then bash it again.  \n\nBut actually point #1, should not be ignored.  I realize that some fraction of developers are bored/irritated with java.  Fine, move onto Haskell or Scala or perhaps Go.  The primary reason I like java is because an average or even below average programmer can write tolerable code with it.   I can also go back to code I wrote two years ago and understand it quickly.  Try that with a rats nest of javascript callbacks.\n\nA below average programmer writes crap in javascript or $php.  \n", "id": "cyynmfp"}], [{"comment": "[deleted]", "id": "cyybt1o"}, {"comment": "Why didn't you just create agleiv_18 instead of this new name?", "id": "cyyc46e"}, {"comment": "Backwards name is less immediately obvious.", "id": "cyymji7"}, {"comment": "We are adults and behave as such.", "id": "cyyd28x"}, {"comment": "[deleted]", "id": "cyyhccb"}, {"comment": "Why don't you just delete this account and create a new one.", "id": "cyyhe1a"}, {"comment": "[deleted]", "id": "cyyhs3f"}, {"comment": "I'll let you get around to backing up your claims so that I have something to counter.", "id": "cyyi88u"}, {"comment": "> Anyways, how do you java guys manage to code without throwing up every 50 seconds?\n\nWhen they get that urge, they take a break and write some XML.", "id": "cyymeo6"}, {"comment": "I take in food intravenously and just in front of my keyboard is a self-cleaning chute that flushes into the sewer system and mists the air around with a light dilution of Febreze.  Fortunately, 50 seconds is roughly equivalent to the amount of time I need to write a short, atomic piece of code and need more time to vomit/think of the next piece.\n\nFor the uninitiated, this is a joke.", "id": "cyyg83x"}]]], "4g370v": ["PLB - My programming language written in C#", "2016-04-23 15:55:57", 4, "http://abunogames.com/PLB.html", [[7, "I wish my 14-year-old kid could do that.\nWell done! Keep experimenting and have fun."], [4, "Great project and good work ! Have you thought of releasing your work on github ? This way someone may give you a feedback on your code (especially if you write a post in r/learnprogramming)."], [3, "Dude, 14 and writing your own programming language?! That's awesome, I wish I had your work ethic when I was 14!\n\nGetting feedback by releasing your code on github (as others have suggested) is a fantastic way to get some constructive criticism on your code. Other than that, keep up the great work!"], [2, "Nice project! It looks very cool. Like /u/twbmsp suggested, maybe you should put the source code on GitHub at some point so people can make suggestions.\n\nKeep experimenting!"], [1, "I made a YouTube video for it!\nhttps://youtu.be/UfCaWCPsqgc **The quality might be bad right now, it was just uploaded!**"], [1, "Back in the day, there was a language called \"Simon's Basic\" for C64. It was written by a 16 years old.\n\nhttps://en.wikipedia.org/wiki/Simons'_BASIC\n\nAnyway, well done."], [-4, "[deleted]"]], [[{"comment": "I wish my 14-year-old kid could do that.\nWell done! Keep experimenting and have fun.", "id": "d2ebzuq"}, {"comment": "Thank you! :D", "id": "d2eeyni"}], [{"comment": "Great project and good work ! Have you thought of releasing your work on github ? This way someone may give you a feedback on your code (especially if you write a post in r/learnprogramming).", "id": "d2eijls"}, {"comment": "Good idea! I might do that. Btw, it's possible to change to WinForms now, and add controls with events!", "id": "d2eomdx"}], [{"comment": "Dude, 14 and writing your own programming language?! That's awesome, I wish I had your work ethic when I was 14!\n\nGetting feedback by releasing your code on github (as others have suggested) is a fantastic way to get some constructive criticism on your code. Other than that, keep up the great work!", "id": "d2epsqn"}, {"comment": "Thanks, and yes. I might that!", "id": "d2eu5iu"}], [{"comment": "Nice project! It looks very cool. Like /u/twbmsp suggested, maybe you should put the source code on GitHub at some point so people can make suggestions.\n\nKeep experimenting!", "id": "d2eim84"}], [{"comment": "I made a YouTube video for it!\nhttps://youtu.be/UfCaWCPsqgc **The quality might be bad right now, it was just uploaded!**", "id": "d2fbv55"}], [{"comment": "Back in the day, there was a language called \"Simon's Basic\" for C64. It was written by a 16 years old.\n\nhttps://en.wikipedia.org/wiki/Simons'_BASIC\n\nAnyway, well done.", "id": "d2hmqju"}], [{"comment": "[deleted]", "id": "d2eq4nh"}, {"comment": "Haha, well. Yes, that's kinda true if you look at my school class... Bernie Sanders? He says USA should be more like Scandinavia :P so, I don't think he's that bad(I'm Swedish), but I don't think he should win though. Hehe, nah, but I'm not really like everyone else in my class...", "id": "d2eu4ru"}]]], "58goml": ["A tribute to Humblefool, the best coder that ever lived in India", "2016-10-20 16:58:38", 2, "https://yourstory.com/2014/06/techie-tuesdays-humblefool/", [], []], "5fhpz1": ["A collection of useful Regex patterns", "2016-11-29 12:14:18", 3, "https://projects.lukehaas.me/regexhub/", [[34, "So... much... wrong...\n\n> **HTML Tags**\n\n> `/^<([a-z1-6]+)([^<]+)*(?:>(.*)<\\/\\1>|\\s+\\/>)$/`\n\n[Famous answer](http://stackoverflow.com/a/1732454/215042)\n\n> **Hex Value**\n\n> `/^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/`\n\nHex HTML/CSS *color* value maybe, but 0xDEADBEAF is a perfectly valid hex value.\n\n> **Password**\n\n> `/^[a-zA-Z0-9+_-]{6,32}$/`\n\nSlowly we're moving the world to [password *phrases*](https://xkcd.com/936/) and everybody should be hashing their passwords. Then why the 32 char limit? And why, for Pete's sake, are we only allowing `a-zA-Z0-9+_-` and nothing else? \\**cries*\\*\n\n> **Email**\n\n> `/^([a-z0-9+_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,24})$/`\n\nYeah. Just. No. [Another famous answer](http://stackoverflow.com/a/201378/215042)\n\n> **Positive number**\n\n> `/^\\d*\\.?\\d+$/`\n\nWe don't all live in the US. (`1,234.56` v.s. `1.234,56`)\n\n> **Phonenumber**\n\n> `/^\\+?[\\d\\s]{3,}$/`\n\n+123 is a valid phonenumber? Where? Phonenumbers are [notoriously hard](https://en.wikipedia.org/wiki/Telephone_numbering_plan) to validate (hence [libphonenumber](https://github.com/googlei18n/libphonenumber) for example).\n\n> **Date in format dd/mm/yyyy**\n\n> `/^(0?[1-9]|[12][0-9]|3[01])([ \\/\\-])(0?[1-9]|1[012])\\2(19[0-9][0-9]|20[0-9][0-9])$/`\n\nFailed the very first 'edge case' I could come up with: 30/02/2016 but also 1852 or 2150 fail...\n\n> *Some people, when confronted with a problem, think \"I know, I'll use regular expressions.\" Now they have two problems.* - Jamie Zawinski"]], [[{"comment": "So... much... wrong...\n\n> **HTML Tags**\n\n> `/^<([a-z1-6]+)([^<]+)*(?:>(.*)<\\/\\1>|\\s+\\/>)$/`\n\n[Famous answer](http://stackoverflow.com/a/1732454/215042)\n\n> **Hex Value**\n\n> `/^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/`\n\nHex HTML/CSS *color* value maybe, but 0xDEADBEAF is a perfectly valid hex value.\n\n> **Password**\n\n> `/^[a-zA-Z0-9+_-]{6,32}$/`\n\nSlowly we're moving the world to [password *phrases*](https://xkcd.com/936/) and everybody should be hashing their passwords. Then why the 32 char limit? And why, for Pete's sake, are we only allowing `a-zA-Z0-9+_-` and nothing else? \\**cries*\\*\n\n> **Email**\n\n> `/^([a-z0-9+_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,24})$/`\n\nYeah. Just. No. [Another famous answer](http://stackoverflow.com/a/201378/215042)\n\n> **Positive number**\n\n> `/^\\d*\\.?\\d+$/`\n\nWe don't all live in the US. (`1,234.56` v.s. `1.234,56`)\n\n> **Phonenumber**\n\n> `/^\\+?[\\d\\s]{3,}$/`\n\n+123 is a valid phonenumber? Where? Phonenumbers are [notoriously hard](https://en.wikipedia.org/wiki/Telephone_numbering_plan) to validate (hence [libphonenumber](https://github.com/googlei18n/libphonenumber) for example).\n\n> **Date in format dd/mm/yyyy**\n\n> `/^(0?[1-9]|[12][0-9]|3[01])([ \\/\\-])(0?[1-9]|1[012])\\2(19[0-9][0-9]|20[0-9][0-9])$/`\n\nFailed the very first 'edge case' I could come up with: 30/02/2016 but also 1852 or 2150 fail...\n\n> *Some people, when confronted with a problem, think \"I know, I'll use regular expressions.\" Now they have two problems.* - Jamie Zawinski", "id": "dakbu35"}]]], "41qkau": ["More comments != Better Code", "2016-01-19 23:30:04", 0, "http://layer0.authentise.com/more-comments-better-code.html", [[14, "LPT: Never comment what the code does. It is written right there in the code what it does. Document, why it does that."], [4, "I don't think I'm alone when I'm reading through someone else's code and thinking \"Why the fuck haven't you comment what shit is doing?\"\n\nBut then when I come to write my own, I can never be bothered."], [3, "I would very much love to see more articles here that, like this one, take some code and improve on it. "], [3, "[Code comments IRL](http://imgur.com/ewcS4dz)"], [3, "> #A Note On Comments\n>\n>\n> Comments are not bad. When used properly they will clarify tricky to understand bits of code, but they should only be used as a last resort. They should only be used after refactoring and renaming of functions/variables has failed to clarify the code.\n\nThere's two other cases [where you should use comments] which are sadly overlooked by most developers:\n\n0. *Conversions*, especially for data-import/-export.\n0. *Standards*, this is to say you should cite the requirements you're implementing (and the location: document, para/page #, etc).\n"], [1, "No, interestingly if you want to improve the code, you have to change the code."], [0, "+1\n\nWas writing something for myself that wasn't even going to be seen or used by other people. My comments made it look like a disaster."]], [[{"comment": "LPT: Never comment what the code does. It is written right there in the code what it does. Document, why it does that.", "id": "cz4dz78"}], [{"comment": "I don't think I'm alone when I'm reading through someone else's code and thinking \"Why the fuck haven't you comment what shit is doing?\"\n\nBut then when I come to write my own, I can never be bothered.", "id": "cz4demt"}, {"comment": "> I don't think I'm alone when I'm reading through someone else's code and thinking \"Why the fuck haven't you comment what shit is doing?\"\n\nI hope you are. The code should tell you what it's doing. You're writing truly terrible code if I can't figure out *what* is going on without comments. Comments should be reserved for explaining non-obvious *whys* behind your code.", "id": "cz4hzyz"}, {"comment": "If you can't read and understand code; why are you a developer?\n\nI've worked with 100s of developers, and reviewed probably hundreds of thousands of lines of code. I can probably count on 2 hands the lines of comments I've seen. It rarely bugs me, there is probably 1 in 100 cases where I'm like \"What the fuck is this doing\", and in those cases I'm usually hungover. Feel free to say I'm not a good developer for not commenting my code or encouraging an environment where commenting is essential - I'd rather read the code itself, and actually use my brain to figure stuff out. If that makes me a dick, then I'm a dick - as long as I stay a very well paid dick - I couldn't care less who comments what.", "id": "cz4icgl"}, {"comment": "I'm really confused... You just said pretty much the opposite of what you said in your original comment.", "id": "cz4jjml"}, {"comment": "> If you can't read and understand code, why are you a developer?\n\nHave you worked with non-English-speaking developers?  Sometimes being able to read and understand what the code is doing is just a small tiny piece of the puzzle.\n\nI can say that this code calls Update_Value, and it only happens if these two things are true, or this is invalid and that is true.  However, when your developers have named things \"Update_Value\", \"good_value\", and \"is_invalid_processed\", you can still have no idea about what the code does if it's sufficiently complex, and you have logic spread throughout three different files.", "id": "cz4jdg0"}, {"comment": "Well then surely that's bad practice? You should be designing your code so that it is easy to read and makes logical sense, and using a standard of naming conventions for variables and function names. I appreciate \"var myVariableStoresThis int;\" would mean nothing in uncommented code, but at the same time you should be giving logical variable names. Such as \"var totalNoOfResponses int;\" why would you make it hard work for other developers by giving shitty variable names but justifying it with a comment explaining what it does? Why dont you make it make sense to start with so that it doesn't need explaining? \n\nOn the language front, realistically...as English as my only language why would I be reviewing code written in German? Or why would my manager pass that down to me? I imagine it may happen in a small number of cases, but realistically. Probably not going to happen.", "id": "cz4k15l"}, {"comment": "> On the language front, realistically...as English as my only language why would I be reviewing code written in German\n\nWhoops, meant to say developers without English as a primary language (i.e. they speak English, but not well).\n\nI'm not arguing whether these developers have written good code, but rather that when you're encountering code in the wild, and making changes to that code, sometimes it makes more sense to add comments to try to explain, rather than refactoring (more than simply renaming) and possibly breaking things.", "id": "cz4kag1"}], [{"comment": "I would very much love to see more articles here that, like this one, take some code and improve on it. ", "id": "cz4egf1"}], [{"comment": "[Code comments IRL](http://imgur.com/ewcS4dz)", "id": "cz50gwo"}], [{"comment": "> #A Note On Comments\n>\n>\n> Comments are not bad. When used properly they will clarify tricky to understand bits of code, but they should only be used as a last resort. They should only be used after refactoring and renaming of functions/variables has failed to clarify the code.\n\nThere's two other cases [where you should use comments] which are sadly overlooked by most developers:\n\n0. *Conversions*, especially for data-import/-export.\n0. *Standards*, this is to say you should cite the requirements you're implementing (and the location: document, para/page #, etc).\n", "id": "cz4l79b"}, {"comment": "> Standards, this is to say you should cite the requirements you're implementing (and the location: document, para/page #, etc).\n\nSo everyone will need a copy of every iteration of the standard the the program has worked with?", "id": "cz4rkol"}, {"comment": "> So everyone will need a copy of every iteration of the standard the the program has worked with?\n\nHow hard is it to have something like this:\n\n    -- The LISP 1.5 manual is available here:\n    -- http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf\n    \n    -- ....\n    \n    -- Page 4 gives the comma-separated list as equivalent the\n    -- space separated list. (Though the comma-space sequence\n    -- ought to be read as a single delimiter; as per the paper.)\n    SEPARATOR : constant Standard.String := \", \";\n\nIt shows *exactly* why your definition is `\", \"`, as well as where to find it in the standard, and what standard is being used.\n\nAlso, isn't that a reason for version control?  \nOr are you insinuating that standards are entirely too volatile to document in an implementation?", "id": "cz4ysnc"}, {"comment": "And when the standard changes? Are you going to go through every reference and update them?", "id": "cz509se"}, {"comment": "If the standard changes and your code is no longer compliant you'd have to go back and change things either way...", "id": "cz50jeq"}, {"comment": "But not all at once.", "id": "cz50r87"}, {"comment": "That's not, strictly speaking, true -- in the case of a new version, it's merely conformant to a prior standard. (Technical Corrigenda & \"binding interpretations\", for example, ***do*** fit the \"no longer compliant\" category though.)", "id": "cz51av4"}, {"comment": "Oh for sure, I'm not disagreeing with you regarding these types of comments.", "id": "cz51mhm"}, {"comment": "It depends.\n\n* You could have a implementation conformant to some previous standard.^1 (e.g. it's perfectly valid to make a C99 compiler, or Ada 95 compiler, or a LISP 1.5 interpreter and simply *not* support later standards.)\n* You could do some sort of incremental development. (Like what you propose.)\n* You could write from scratch the new implementation.^2 (This might be needed in high-integrity applications.)\n\n^1 -- This might be necessary because the new standard cuts against the goals that drive your use -- if, for example, the new standard added dynamic memory management to the language but you work in a field where dynamic memory wasn't allowed. (Certain embedded systems, and certain real-time systems, have this restriction.)  \n^2 -- While code reuse is great, there are limitations -- the Ariane 5 rocket incident was due to reusing the Ariane 4 code with a different set physical parameters (the Ariane 5).", "id": "cz518zq"}], [{"comment": "No, interestingly if you want to improve the code, you have to change the code.", "id": "cz4ohva"}], [{"comment": "+1\n\nWas writing something for myself that wasn't even going to be seen or used by other people. My comments made it look like a disaster.", "id": "cz4bwuj"}]]], "4pwz80": ["I Was Wrong About TypeScript, Here is Why", "2016-06-26 12:56:17", 5, "https://www.triplet.fi/blog/i-was-wrong-about-typescript-here-is-why", [[30, "[deleted]"], [17, "> \\* I had to Google \"slam dunk.\" It seems to be a basketball term for an easy shot, one that is difficult to miss.\n\nOuch."], [11, "I think Typescript is the future. People can bitch about it looking too much like C# or whatever, but being able to shift runtime errors to compile time is an enormous improvement for real-world apps, especially if you force proper null handling."], [4, "And dynamic typing zealots still argue with me when I tell them their IDEs are shitty."], [1, "This is actually kind of important, mostly for the browser js developers IMHO (really can't justify js spattered all over the server).  I've switched to the typescript compiler myself for client code, after ignoring it, and while it still lets you shoot yourself in the foot, it gives you the the option not to.\n\n"], [3, "Anders Heljsberg is behind it. All the naysayers were wrong from day 1. No matter how convincing of an argument they thought they were making."], [-2, "In other news, someone just lost the keys somewhere in the kitchen. The search continues and now wife is involved as well."], [-5, "In other news, someone just lost the keys somewhere in the kitchen. The search continues and now wife is involved as well."], [-6, "I'm sort of amazed there's large advocacy for type annotations and compile-time typing.\n\nThe way I see it. You got a historical limitation that was debilitating. That limitation was erased long time ago for most but very specialized software. Now you see people introducing the same old limitations, to support their crippled workflow.\n\nYou could stop doing class-per-file or otherwise giving class for every damn concept you have. You could stop renaming things with number postfixes to facilitate backwards compatibility. You could stop uncontrolled leaking of namespaces in compile unit. You could stop thinking about code as single compile unit that runs at start of a process. You could stop thinking about code as nouns and start thinking about code as activity on data.\n\nInstead I see you embracing things I see as handicaps."], [-9, "Sometimes I'm wrong too... doesn't mean that need to write about."], [-17, "[deleted]"]], [[{"comment": "[deleted]", "id": "d4oo292"}, {"comment": "\\+ type inference, modules, classes, interfaces, object literals & functions", "id": "d4oyw8z"}, {"comment": "Yes, but Typescript doesn't add modules, classes, or literals; those are part of ECMAScript.", "id": "d4p5pm5"}, {"comment": "Everything has types, even without TypeScript.", "id": "d4pno8h"}, {"comment": "[deleted]", "id": "d4pnwdh"}, {"comment": "> compile time type checker\n\nThat's perfect, much more objective.", "id": "d4pnxyg"}, {"comment": "Name a useful language without at least one type...\n\n(I have to specify useful, because languages like HQ9+ don't have anything that could be called a type)", "id": "d4pnp10"}], [{"comment": "> \\* I had to Google \"slam dunk.\" It seems to be a basketball term for an easy shot, one that is difficult to miss.\n\nOuch.", "id": "d4ovee9"}, {"comment": "It honestly annoys me that the author is bragging about his own ignorance.  He does not seem like the type of person I would ever hang out with. ", "id": "d4pgk32"}, {"comment": "It should be the type of person to hang out with, because bragging about ignorance is the best thing one can do, all because of the [Growth Mindset](http://cdn2.business2community.com/wp-content/uploads/2016/05/fixedvsgrowth-670x821.jpg.jpg).", "id": "d4pneeu"}, {"comment": "The difference is this author only added that footnote to convey his disdain for basketball and probably sports in general. He has no interest in learning about basketball.", "id": "d4py9vx"}], [{"comment": "I think Typescript is the future. People can bitch about it looking too much like C# or whatever, but being able to shift runtime errors to compile time is an enormous improvement for real-world apps, especially if you force proper null handling.", "id": "d4ol5pf"}, {"comment": "Why would anyone bitch about something looking like C#?  It truly is one of the most beautiful languages ever created.", "id": "d4pgjh4"}, {"comment": "WPF/XAML on the other hand...", "id": "d4pq1z0"}, {"comment": "I could see people thinking it's too verbose.  People who have only ever written small scripts and don't understand the sanity that the extra type verbosity gives you in a large project .", "id": "d4py6y7"}, {"comment": "Which TS will do for you with --strictNullChecks https://github.com/Microsoft/TypeScript/pull/7140\n\nEven C# can't do that but it's also being worked on.", "id": "d4p16xc"}, {"comment": "Strict null checks are however useless if the mapping files have not been prepped for it.", "id": "d4p1vug"}, {"comment": "Flow already did this. And it only works if you don't have legacy TS code you need to fix because it seems it will take another 20 years, before releasing a language with the word 'type' is the name, would have a complete and actually consistent type checker. \n\n> Even C# can't do that but it's also being worked on.\n\nEven? Java and C# are not considered 'properly typed languages'. But more the enterprise anal rape of the notion of type checking, while fisting a bag of buzzwords.\n\nPS. Typescript is written by one of C# leading authors. Hence why it has so many issues ignoring the knowledge already available to us for the last 30 years. (Hindley-Milner types-ystems). Which should be considered the absolute minimum, if you want to go ahead and bother with types in the first place.", "id": "d4vqrnv"}, {"comment": "I said even C# because it's what /u/pinnr was using as a reference.\n\n\"Flow already did this\", well yes, it did, and now so does TypeScipt, look at that!\n\n> And it only works if you don't have legacy TS code you need to \nfix\n\nNot really true, I've converted large amounts of code with no changes whatsoever.\n", "id": "d4vti3k"}, {"comment": "What a sensationalism.\n\nTypeScript is not \"the future\". It's like... \"Progressive Web Apps are the future\", \"AI is the future\", \"Mars is the future\"... TypeScript just helps a little, anyone can live without it. JavaScript has been living without it since forever\n\n\u00af\\\\\\_(\u30c4)\\_/\u00af", "id": "d4pnqta"}, {"comment": "We lived without modules, const, variable expansion, and the spread operator for a very long time too...\n\n\nIMO, The next improvements for JS will come from type systems and better immutable data structures.", "id": "d4pso15"}, {"comment": "I think you were trying to make this \u00af\\\\\\_(\u30c4)\\_/\u00af!  \n  Type it like this \u00af\\\\\\\\\\\\\\_(\u30c4)\\\\_/\u00af  \n  ^^I ^^am ^^a ^^bot, ^^visit ^^/r/ArmFixerBot ^^for ^^more ^^info!", "id": "d4pnqwu"}, {"comment": "LOL, REDDIT HAS A BOT FOR THAT!", "id": "d4pnta2"}], [{"comment": "And dynamic typing zealots still argue with me when I tell them their IDEs are shitty.", "id": "d4oy42d"}, {"comment": "No one can argue with you that dynamic languages have shitty IDEs and no refactoring capabilities. I love Ruby but it's not designed for large scale projects. For anything large enough you absolutely need some kind of type system. Plus, modern dynamic languages are not that great. The only environment that I've seen fully utilize dynamism has been SmallTalk.", "id": "d4pir1k"}, {"comment": "I've experienced that myself.", "id": "d4p553e"}, {"comment": "If they argue with you, they are maybe not experienced enough dynamic typing zealots", "id": "d4pi42r"}], [{"comment": "This is actually kind of important, mostly for the browser js developers IMHO (really can't justify js spattered all over the server).  I've switched to the typescript compiler myself for client code, after ignoring it, and while it still lets you shoot yourself in the foot, it gives you the the option not to.\n\n", "id": "d4ojpub"}], [{"comment": "Anders Heljsberg is behind it. All the naysayers were wrong from day 1. No matter how convincing of an argument they thought they were making.", "id": "d4pipii"}, {"comment": "You shouldn't care about the author, for that [Personal Experience Doesn't Matter](https://medium.com/@fagnerbrack/personal-experience-doesnt-matter-cb060b42f99a)", "id": "d4pnffe"}, {"comment": "> Do not judge the person by the experience. Rather, judge the argument by the content.\n\nThere are some very legitimate cases where someone with a track record for producing well analysed, well designed, well thought out content should likely be given the benefit of the doubt.\n\nIf you disagree with such an individual, the responsibility is much more strongly you as the opposing opinion to prove your position.\n\nPersonal experience may not matter... but historical success *does* matter.", "id": "d4pp6f7"}, {"comment": "> Personal experience may not matter... but historical success does matter.\n\nHistorical success might drive one to check the proposal, but should never be used to blindly follow a pattern, practice or tool, just because of the person that is doing it.\n\nIf someone has a track record of producing well analysed, well designed, well thought content, then keep in mind that person has failed many times until being able to do so, and that person can fail again. Just because someone has a track record of producing well analysed, well designed, well thought content, it doesn't mean that all content that person produces will achieve the same result.\n\nNobody knows the answer for everything, it is all about trial and error, and in order to find the error, it is necessary to judge the argument, not the person.\n\nThat is the whole fundamental of \"Personal Experience Doesn't Matter\": Focus in the argument to find mistakes and make the author and yourself learn from it. Focusing on the person yields no valuable result.", "id": "d4prc2r"}, {"comment": "> Historical success might drive one to check the proposal, but should never be used to blindly follow a pattern, practice or tool, just because of the person that is doing it.\n\nYep. We're in complete agreement on this point... blind faith is definitely a bad thing!\n\n> Nobody knows the answer for everything, it is all about trial and error, and in order to find the error, it is necessary to judge the argument, not the person.\n\nI disagree that the argument can be divorced completely from the person. What are the chances your doctor gives great advice about cars, or your mechanic gives you good advice about medical conditions?\n\nWe do agree that a discussion should **never (edit)** be dismissed outright because of the individual.  But, to say that you should never consider any factor about the source of the information seems to be really claiming that *you* are always the best person to judge the veracity of an argument.\n\nPersonally, I know that there's a lot I don't know, so I will happily defer the role of expert to those with proven track records.", "id": "d4sihzh"}, {"comment": "> We do agree that a discussion should be dismissed outright because of the individual\n\nWe don't. The article I posted explains why. No discussion should be dismissed because of the individual, unless one don't have patience to make the other understand.\n\n> But, to say that you should never consider any factor about the source of the information seems to be really claiming that you are always the best person to judge the veracity of an argument.\n\nIf it is an objective argument, you can use the scientific method to demand evidence. It is not about \"we\" being the judge, it is about reality and independent experiments being the judge.\n\n> What are the chances your doctor gives great advice about cars, or your mechanic gives you good advice about medical conditions?\n\nThe chances of a doctor giving a wrong medical suggestion is the same as any human.\n\nIf a doctor tells me something I will ask why and will demand detailed explanations of what that is in details in words that I can understand. One day there was this person that went to do a surgery. If she didn't do some stuff the doctor said it would double her chances of complications. She asked what is the probability of implications if she didn't do that, it was 1 in 1 million. The double would be 2 in 1 million. She chose not to do it and go with the chances, even when the doctor believed it was a big deal, because she didn't wanted to for whatever reason that was.\n(That is the summary of a TED talk that I have no time to look for, sorry)\n\nDoctors can be biased, as anyone who claims to be an expert that instead of providing objective arguments starts throwing some opinions that have no ground.\n\nFactual anecdotals depend on the credibility though, and it doesn't even qualify as ad-hominem.", "id": "d4tq2bs"}, {"comment": "> The chances of a doctor giving a wrong medical suggestion is the same as any human.\n\nIf that's your experience on the matter... I suggest you need to move to a country with tighter licensing around doctors ;-)\n\nYes, doctors are fallible. Yes... people are fallible. But your whole assertion is that we should basically always forget history, because history can't guarantee the future.\n\nWhich, from an absolutist sense I agree. Past performance is no guarantee of future behaviour. However, you assume laws of gravity will still apply today, the same way they did yesterday.\n\nAnywho... been an interesting discussion, even if neither of us really has changed perspective. On the upside for me, you theoretically won't hold this disagreement against me in future :D", "id": "d4v3t5f"}, {"comment": "> I suggest you need to move to a country with tighter licensing around doctors ;-)\n\nIt is not about competence, it is about being human. Humans are not reliable to make decisions. Scientists are more capable than anyone to make decisions because they work with manageable pieces of knowledge. A doctor should not make a decision, it should leave the decision to the patient, they should be able to provide the information, though.\n\nBecause of how we work we can't ask for every detail of everything that the doctor suggest us. That's why we need to rely on their judgement for the sake of convenience and cost, we have professionals and specialists for that. The one thing that professional or specialist should do is not fall into the traps of the personal experience and judge the information they receive incorrectly.\n\nA user of a system won't ask how that system was developed, they will ask how it works and will trust it will work, even if it doesn't. That's not the same. The judgement on what should be done or not lies on the producer not the consumer, because the consumer will not have the capabilities and context of the producer (or it will cost too much to have that).\n\nIdeally we should ask for details, but our capacity doesn't allow that.\n\n> But your whole assertion is that we should basically always forget history because history can't guarantee the future.\n\nWe don't forget history. We just don't rely on it to make judgements, we rely on the content of the argument.\n\n> However, you assume laws of gravity will still apply today, the same way they did yesterday.\n\nHuman behavior is not a concept like gravity, that's an analogy that doesn't make any sense. Gravity represents a physical effect that is assumed to not have any external interference other than the physical reality because there is no evidence of an external interference other than physical. There is no human in the equation.\n\n> On the upside for me, you theoretically won't hold this disagreement against me in future :D\n\nWhich disagreements are you refering to? Why wouldn't I hold it in the future? This is not clear.", "id": "d4vhwo5"}, {"comment": "> We do agree that a discussion should be dismissed outright because of the individual\n\nWhups! That was my typo. I meant to say \"we both agree that something SHOULDN'T be dismissed outright\". My bad!", "id": "d4v3ttf"}], [{"comment": "In other news, someone just lost the keys somewhere in the kitchen. The search continues and now wife is involved as well.", "id": "d4pga6d"}], [{"comment": "In other news, someone just lost the keys somewhere in the kitchen. The search continues and now wife is involved as well.", "id": "d4pgakd"}], [{"comment": "I'm sort of amazed there's large advocacy for type annotations and compile-time typing.\n\nThe way I see it. You got a historical limitation that was debilitating. That limitation was erased long time ago for most but very specialized software. Now you see people introducing the same old limitations, to support their crippled workflow.\n\nYou could stop doing class-per-file or otherwise giving class for every damn concept you have. You could stop renaming things with number postfixes to facilitate backwards compatibility. You could stop uncontrolled leaking of namespaces in compile unit. You could stop thinking about code as single compile unit that runs at start of a process. You could stop thinking about code as nouns and start thinking about code as activity on data.\n\nInstead I see you embracing things I see as handicaps.", "id": "d4phtcr"}, {"comment": "> The way I see it. You got a historical limitation that was debilitating. That limitation was erased long time ago for most but very specialized software. Now you see people introducing the same old limitations, to support their crippled workflow.\n\nThere is no limitation. Either way you have to deal with contracts and types, the difference here is that the type system makes sure that they are correct _for you_. Static typing provides heaps of benefits. I can't really think of any benefits for dynamic typing, other than \"it's easy to learn\".\n\nDynamic typing is not something new. It has existed since the dawn of programming, and is the default implementation for any programming language. Making a dynamic type system is easy, making a static one is hard.\n\n> You could stop doing class-per-file or otherwise giving class for every damn concept you have. \n\nNo. Long pieces of continuous code is bad. Short pieces of code is good. Any function or method should only do one thing. Any class should only have only one area of responsibility.\nThat's just good programming.\n\n> You could stop renaming things with number postfixes to facilitate backwards compatibility. \n\nThis is never necessary.\n\n> You could stop uncontrolled leaking of namespaces in compile unit. \n\nWhat does this even mean?\n\n> You could stop thinking about code as single compile unit that runs at start of a process. \n\nThis is not how it works.\n\n> You could stop thinking about code as nouns and start thinking about code as activity on data.\n\nWhat?\n\n> Instead I see you embracing things I see as handicaps.\n\nTry to embrace them as a language features instead of handicaps, because they are there to help you.", "id": "d4plsrz"}, {"comment": "> It's a handicap to you, because you're very obviously inexperienced.\n\nYou are right with everything else you said, except this one. Please, [don't destroy the discussion](https://medium.com/@fagnerbrack/personal-experience-doesnt-matter-cb060b42f99a).", "id": "d4pni61"}, {"comment": "Ok, fixed :P", "id": "d4pnosa"}, {"comment": ";D", "id": "d4pns4t"}, {"comment": "> Dynamic typing is not something new. It has existed since the dawn of programming, and is the default implementation for any programming language. Making a dynamic type system is easy, making a static one is hard.\n\nStatic typing with type annotations is roughly as old as dynamic typing, and you don't have default typing when implementing a programming language. Any bias you have is introduced by tools you use to implement your language. I've found satisfying dynamic typing to be non-trivial to implement. But I don't know if static typing is yet harder.\n\n> There is no limitation. Either way you have to deal with contracts and types, the difference here is that the type system makes sure that they are correct for you. Static typing provides heaps of benefits. I can't really think of any benefits for dynamic typing, other than \"it's easy to learn\".\n\nThe limitation I refer to was the performance limitations. There used to be time when you had to write code in C, or in some assembly code, or in the early variation of BASIC to get the code to perform. All of them are very finicky with the typing of a program. Today people can afford runtime typing and then static typing on top of that. Most people don't find such made programs bad or wrong.\n\nThe main reason why I use dynamic typing is that it provides very low coupling into code by default.  Only things the code absolutely requires to complete will restrict what you can put in. For example list sort only requires that items inside the list can be compared with each other in respect to some attribute. To see why this is useful, you could see why JSON became so handsomely popular in such short time.\n\nYou may argue that templating solves the problem of generic structures. But actually you miss the point that way. The key benefit is the low coupling, and templating increases coupling between code.\n\nThe low coupling provides an advantage that it allows relatively well-isolated systems to work well together: The list with bunch of stuff inside it can go through any system that accepts a container with bunch of stuff. Every program fragment only needs to worry about qualities that are necessary for that specific fragment to run. Therefore programs are constrained by the actions that are taken, rather than the shape of the data you put in.\n\nAnother distinct advantage provided by dynamic typing is the flexibility of evaluation. The default there is that you're not limited into single compile-unit per process. Rather, you can start the code that is correct and run your work-in-progress code several times. This kind of interactive programming really gives you additional view to what your code is actually doing. It can drastically reduce the amount of thought you have to put in to get the same results.\n\n> No. Long pieces of continuous code is bad. Short pieces of code is good. Any function or method should only do one thing. Any class should only have only one area of responsibility. That's just good programming.\n\nUh. You get this all wrong. Long piece of continuous code is actually the easiest code to read. Every class, function or other abstraction that introduces an indirection will burden your mind and require you to jump while you read the code.\n\nThe thumb of rule is that if there's no good reason to introduce a function. You should avoid it because having to name function and having to remember what this and that function did can be larger burden than actually just reading the original long piece of code.\n\nAdditionally doing abstractions late as possible lets you most likely pick the best and most valuable abstractions when you do so.\n\n> \"You could stop uncontrolled leaking of namespaces in compile unit.\"\n> What does this even mean?\n\nThis means the default that happens when you've got your C# project and the namespace is shared across every file. It's one of those things that forces you into class hierarchies because you don't have other way to \"fix\" it there. In javascript it's so bad design flaw that you decorate stuff with (function(){})(); to prevent namespace from leaking into another script. Namespace leaking between compile units or files is utterly shit practice that defeats the purpose of files and compile units, and it should be stopped.", "id": "d4pyncd"}], [{"comment": "Sometimes I'm wrong too... doesn't mean that need to write about.", "id": "d4oilg6"}, {"comment": "> Sometimes I'm wrong too... doesn't mean that need to write about.\n\nIt would be nice if you could, this way folks could learn something about your experience and tradeoffs.", "id": "d4ojmno"}, {"comment": "[deleted]", "id": "d4ojrdk"}, {"comment": "It teaches us to never bet against Anders (Hallowed be His name)", "id": "d4p0bya"}, {"comment": "\nStop with the reversed psychology.\n", "id": "d4p0ip5"}], [{"comment": "[deleted]", "id": "d4ojbuk"}, {"comment": "He's a human being. Nothing more required. ", "id": "d4okcau"}, {"comment": "Even this is irrelevant. Even if the OP is a dog or a bot, the points he made are still valid.", "id": "d4owrm5"}, {"comment": "clap clap clap", "id": "d4pnkqg"}, {"comment": "Why wouldn't it matter?", "id": "d4ojr78"}, {"comment": "[deleted]", "id": "d4ojurw"}, {"comment": "Is it relevant to you that Anders Hejlsberg, a major figure in programming, has created a typed layer over JavaScript to help people write safer code?", "id": "d4ovviq"}, {"comment": "I see the benefits of TypeScript, but I [don't care](https://medium.com/@fagnerbrack/personal-experience-doesnt-matter-cb060b42f99a) if it is Anders Hejlsberg or Madonna that wrote the thing. We should focus on the content.", "id": "d4pnk0l"}, {"comment": "This is irrelevant. What invalid point did you find in OP's thesis?", "id": "d4oy6sq"}]]], "4ax9as": ["C to Assembly Language: First look", "2016-03-18 11:06:55", 1, "https://medium.com/@bilalak90/c-to-assembly-language-first-look-2e04ed74abf3#.bksj7orfe", [[11, "[deleted]"], [5, "medium spam"], [6, "I like assembly, but this article is bad and you should feel bad."], [2, "Kind of personal issue but I hate it when tutorials and other code explanations posts uses single letter variable names. I'm one of those (few?) who have difficulties remembering what each letter means. In this case I have to keep in mind that p is pointer, n is number, a is array which sounds trivial but it helps immensely if it was at least ptr, num, arr. It annoys me because I'm sure those who are good at this can do both."]], [[{"comment": "[deleted]", "id": "d14bdf3"}, {"comment": "Yes and no. \"really understand\" doesn't necessarily mean \"understand enough to use it well\", they seem to mean \"understand to the fullest extent possible\" and in that case, yeah, it probably does help to understand the assembly (or intermediate) produced.", "id": "d14idcs"}], [{"comment": "medium spam", "id": "d14blwv"}, {"comment": "[deleted]", "id": "d14bp6d"}, {"comment": "Too much time but too little actual thinking.", "id": "d15hy4c"}, {"comment": "I wish this sub would ban medium posts ", "id": "d14butw"}], [{"comment": "I like assembly, but this article is bad and you should feel bad.", "id": "d14bs8s"}], [{"comment": "Kind of personal issue but I hate it when tutorials and other code explanations posts uses single letter variable names. I'm one of those (few?) who have difficulties remembering what each letter means. In this case I have to keep in mind that p is pointer, n is number, a is array which sounds trivial but it helps immensely if it was at least ptr, num, arr. It annoys me because I'm sure those who are good at this can do both.", "id": "d14c084"}, {"comment": "Single letter variable identifiers are generally considered to be bad practice, in the majority of cases, so it's not just you.\n\nBecause this is an example, though, we probably can't assume that this is how that person writes code. With that being said, it wouldn't have been if I had written it, and you are right, it would help with readability.", "id": "d14i8a9"}, {"comment": "So Math formulas which are almost exclusively single letter variable names, are also bad?\n\nThe reason for single letter variable names in Math is because the variable is less important than the relationship between those variables. In general, if the formula uses multiple variables, there is a legend to say what that letter actually stands for. What would be wrong with defining a variable at the top of your function with a comment that would be the equivalent of a legend (even though I think it is ok to do this, most of my variable names are greater than 1 letter)?\n\nI use a few single letter variables often (i, j, k) as iterators for arrays. Are you saying that is bad practice?\n\nIn general, I use many different methods of naming variables so that my code is readable and maintainable at a later time but doesn't take a lot of time to create.\n\nMaking a blanket statement about 1 letter variables is like looking at the world in only black and white when the world is actually all shades of grey.", "id": "d14llvl"}, {"comment": "> So Math formulas which are almost exclusively single letter variable names, are also bad?\n\nNo, I didn't say that...\n\n> Making a blanket statement about 1 letter variables is like looking at the world in only black and white when the world is actually all shades of grey.\n\nI didn't make a blanket statement. I said, \"In most cases\", which explicitly disqualifies it as a \"blanket statement\" by allowing for exceptions. Math variables are one of the exceptions I had in mind, the other main one being things like lambda parameters.", "id": "d14mlqj"}, {"comment": "I sometimes use 1 letter variables as well for my own readability's sake but I try not to when I post code online exclusively for others to read.", "id": "d14w9iz"}]]], "4clb2f": ["Ubuntu Linux Is Coming To Windows 10 \u2014 Microsoft Partners With Canonical", "2016-03-30 19:40:01", 0, "http://fossbytes.com/microsoft-canonical-bring-ubuntu-linux-on-windows-10/", [[2, "Who would want this? Serious question. What is the use case scenario?"]], [[{"comment": "Who would want this? Serious question. What is the use case scenario?", "id": "d1j9rvb"}, {"comment": "I need MS tools at work for corporate stuff, Outlook, Share Point, Power Point. IT gives everyone Windows desktops. But my job is Linux server based. Being able to run linux containers, have bash, and other linux apps on my desktop without a virtual machine could help. But if its not easy and seamless then a virtual machine is going to be better", "id": "d1jdxd7"}, {"comment": "Yeah, I suppose. My situation is exactly the opposite. Linux desktops but I have to support windows stuff too. I just spin up KVM virtual machines for testing and whatnot. I would suppose you do the same currently for Linux servers. Still, what problem are canonical and Microsoft trying to solve by having ubuntu run in a container? I'm always suspicious of people \"partnering\" with Microsoft. Guess we'll wait and see what happens.", "id": "d1ju4gc"}, {"comment": "Being suspicious of this is a good thing. It sounds a lot like a page from their \"Embrace, extend, extinguish\" playbook. ", "id": "d1jvovr"}]]], "50ui0n": ["Why not PLT for Language Design?", "2016-09-02 21:48:42", 0, "https://medium.com/@bryanedds/why-not-plt-for-language-design-846b2443bfc8", [[18, "This article doesn't say much of anything.\n\nIs it trying to show that jai has problems that PLT would help solve? If so, which problems?\n\nOr is it trying to claim that someone who didn't study PLT can't design a useful, practical language? Is that really true? I'm not so sure.\n\nOr is it trying to claim that without a solid PLT foundation, one ends up with something as complex as C++? Is that really true? I'm not so sure.\n\nI don't have any skin in this game one way or another, but I'm not sure why this article is here, except to say \"I think one requires PLT before one can design a good language\" with nothing to back that up."], [12, "> Experience shows that the only scalable approach is to leverage, to the highest degree possible, programming language theory (PLT).\n\nWhat does this mean? What experience? Is there a language that has leveraged PLT to any significant extent and also been used as heavily as C++, JavaScript, PHP, or any other screwball mainstream language? Obviously there are plenty of avoidable mistakes in language design, but it's wishful to believe that more theory makes a better language, when you're comparing a thoroughly tested language like C++ against a language which has been used so little in comparison. Don't mistake the mere lack of a spotted track record for the presence of a great track record. It's like Stroustrup said: There are only two kinds of languages: the ones people complain about and the ones nobody uses. (Although there's actually another kind: languages so against the grain that people criticize them for even existing. APL, Forth, Lisp, being examples.)"], [5, "Lots to be said here, but one lightweight way to work on language semantics is this tool: https://redex.racket-lang.org"], [4, "Does PLT discuss pragmatic issues such as IDE support? \n\nThings like robust partial compilation (i.e. when there are syntax errors) and code completion are a must have for modern programming languages. And we go to great pains to make languages such as C#, Java, and SQL have even basic support for this. "], [2, "Yo u/bryanedds. In your article you linked to two textbooks, but it looks like you meant to link three. Asking because I'd like to know what the third is, if there is one :)"], [1, "Could the OP list languages he feels are successful results of this philosophy?\n\nIf there are successful results of this philosophy, why are there no languages that AAA level game programmers are happy with (other than C/C++)?\n\nIf the set to people subscribing your philosophy could please apply your sacred knowledge to making a better high performance language, we would appreciate it.\n\n\n"], [1, "> Jon\u2019s approach is seen as one that violates a most important rule in programming \u2014 \u2018Don\u2019t be clever.\u2019\n\nHa! The *whole point* of Jai is that Blow is sick of people being clever. He's basically writing KISS-the-language, because PLT theorists are too busy adding leaky layers of abstraction on top of leaky layers of abstraction to actually produce anything he can use in his domain."], [1, "> like writing an object-oriented program without knowledge of Design Patterns\n\nThat seems mostly fine -- the design patterns I end up using aren't exactly what's documented somewhere. It's helpful to read about examples, but I don't really get the fetishization of design patterns as some kind of divinely inspired knowledge. It's all stuff anyone can come up with on their own if they think carefully about the problem at hand."], [0, "[deleted]"]], [[{"comment": "This article doesn't say much of anything.\n\nIs it trying to show that jai has problems that PLT would help solve? If so, which problems?\n\nOr is it trying to claim that someone who didn't study PLT can't design a useful, practical language? Is that really true? I'm not so sure.\n\nOr is it trying to claim that without a solid PLT foundation, one ends up with something as complex as C++? Is that really true? I'm not so sure.\n\nI don't have any skin in this game one way or another, but I'm not sure why this article is here, except to say \"I think one requires PLT before one can design a good language\" with nothing to back that up.", "id": "d776o4q"}, {"comment": "Can't say for sure what's in the author's mind, but taking a stab at some of your questions:\n\n> Is it trying to show that jai has problems that PLT would help solve? If so, which problems?\n\nI know nothing about jai.  Perhaps it's hard to parse, or hard to compile, or hard for the compiler to optimise, or hard to understand.\n\n> Or is it trying to claim that someone who didn't study PLT can't design a useful, practical language?\n\nIt might be, though the less hyperbolic way to approach this is that trying to design a programming language without programming language theory is like trying to design an aircraft without aerodynamics: it's _possible_, but you're ignoring a ton of work people have already done that could save you a lot of bother.\n\n> Or is it trying to claim that without a solid PLT foundation, one ends up with something as complex as C++? \n\nI read it more as C++ is complex, and you don't want to be that complex.  And C++ definitely didn't benefit from large amounts of modern PLT during its design, as large amounts of PLT didn't exist then.\n\n> I'm not sure why this article is here\u2026\n\nTo me, it just reads like the sort of rant you might expect from someone who's experienced in some field watching amateurs at play.\n\n> This article doesn't say much of anything.\n\nNot really, no :-)  It's not exactly rocket surgery to say that PLT can help you make a better PL.", "id": "d77lsol"}, {"comment": "> Perhaps it's hard to parse, or hard to compile, or hard for the compiler to optimise, or hard to understand.\n\nNone of these things seem to be remotely true. In converse, PLT languages tend to be hard to compile, hard for the compiler to optimize and hard to understand, which is why Blow's been stuck with C and C++ for so long and needs to make his own language to remedy it.\n\n> To me, it just reads like the sort of rant you might expect from someone who's experienced in some field watching amateurs at play.\n\nI normally expect people with experience to actually make points.", "id": "d77uh1k"}, {"comment": "I seriously doubt you could claim C++ has pragmatic basing in PLT (that's what you're implying when you suggest that PLT is to blame for being stuck with C/C++, right?).  For one, it's based on C, and C is *really* old, and made without the knowledge collected since; and indeed made without knowledge technically available then but only identified as foundational since.\n\nSecondly, ... it's based on C, and that means it's not a clean slate.  Whether a clean and simple design might have been possible (to some problems) is a bit of a moot point, since C syntax was a given, and clearly C wasn't designed with modern C++ in mind.\n\nThirdly, C++ itself is old.  Modern C++ has many, many features that took years to work out; obviously the language designed before those many years could not entirely predict the issues design choices back then impose on features in the now (and future) C++.\n\nIf anything, your argument suggests that Jai is repeating C and C++'s mistakes.\n\nThat may not be terrible.  It's not like C/C++ have been unmitigated failures.  There are mitigating factors, such as that they're arguably the most successful languages of all time.\n\nAlso, you claims that PLT languages \"tend\" to be hard to compile, hard to optimize and hard to understand seems non-obvious.  I'd imagine the reverse to be true, and from my very limited experience, at least the \"hard to compile\" bit is completely wrong.  Do you have an argument or reference supporting the claim that theory is worthless in these respects?", "id": "d77unzf"}, {"comment": "> I seriously doubt you could claim C++ has pragmatic basing in PLT.\n\nI'm not and I don't. I'm saying that if PLT languages offered an alternative to C or C++, Blow would have loved to switch, but they didn't so he couldn't.\n\n> Also, you claims that PLT languages \"tend\" to be hard to compile, hard to optimize and hard to understand seems non-obvious.\n\nConsider any fancy PLT language. Note how it's either\n\n1. much slower than C and C++, or\n2. Rust.\n\nObviously any language in category 1 is there because it's hard to optimize. Most of these languages involve hard-to-compile techniques - Haskell in particular gets compiled in the most mind-boggling manner. Even simpler languages require complex runtimes like GC and dynamic dispatch with hidden tables and pervasive reference types to avoid falling apart. Blow's language needs to be simple and have a direct correspondence to machine code, so these kinds of things will not work.\n\nCategory 2 contains one language, which is complex and has way more language overhead than C, in terms of the language syntax, the language features (both necessary to work and those that are optional) and in user-level types that involve far more complexity in order to work with the complex type system. Further, Rust is anything but easy to compile.\n\nContrast to Jai, which has none of this complexity. Most things in Jai are dead simple, and power comes from low-level (albeit unsafe) hooks. These hooks would be basically impossible to offer the same way in Rust because of Rust's guarantees - guarantees that are absolutely the right choice for building a *web browser* but perhaps not the right ones for Jai.\n\nEven if you ignore Jai, the languages which get closest to a C++ replacement tend to be ones that are more practically oriented, like D and Nim. It's also worth noting that Rust absolutely *did* have to discard a ton of PLT in order to get as far as it did - for instance Rust only just got abstract return types and they're not even real abstract return types.", "id": "d77uts4"}, {"comment": "I don't think we have a shared understanding of what \"a PLT\" language is. Does that really exist? I interpret this more as trying to learn from \"PLT\".  But it's not a complete story, nor is it prescriptive - just a bunch of knowledge.  PLT isn't *just* concerned with safety; I don't think it's fair blame PLT for the the complexities of memory safety. If anything, that wish comes from pragmatism. Almost all languages that become successful are memory safe, so it's something reasonable to want if you're selling your hot new language.  And as a programmer (and PLT researcher - sure), it makes sense to want memory safety; it just makes your life easier.\n\nAnd let's be fair - the article is about Jai and PLT, but success isn't that trivial. Jai certainly has not been the first C-like language since C, and it's not surprising that competing with C isn't easy, especially with C++ in the mix. Suggesting that if only people ignored PLT, we'd have had a C successor seems wildly optimistic and ignores all the languages that tried to do just that.\n\nOf course, *most* languages have been about productivity, not about low level.  But that's probably simply because that's what people that make languages care about.  And naturally so - that impacts the programmer directly, whereas a more efficient low level language simply makes things faster.\n\nIMHO, all this talk of PLT has little to do with programming language success.  That doesn't mean it's irrelevant - it may well be easier to make a language with PLT, or easier to evolve - but nor should it be overemphasized.", "id": "d77v6dr"}, {"comment": "> I don't think we have a shared understanding of what \"a PLT\" language is.\n\nThe definition of \"PLT language\" I'm using is a language derived primarily from ideas that come from PLT. If you put them on a scale, PHP and C++ would be on the far left, whereas Coq and Idris would be on the far right.\n\n> I don't think it's fair blame PLT for the the complexities of memory safety.\n\nIt's not PLT's *fault*, but most PLT does *require* GC (and a host of other unwanted overheads) to work. So if you don't use GC or a bandaid like Rust's borrow checker, most PLT just simply can't apply.\n\n> Almost all languages that become successful are memory safe\n\nBlow is making a language for desktop games, the core of which are almost exclusively in C and C++. It's a different domain.\n\n> Suggesting that if only people ignored PLT, we'd have had a C successor seems wildly optimistic\n\nIgnoring PLT doesn't solve any problems except the ones caused by following it. The road ahead is still long and hard, it's just that it's filled with practicalities rather than dead researchers.\n", "id": "d77vfng"}, {"comment": "> So if you don't use GC or a bandaid like Rust's borrow checker\n\nWhat is the borrow checker a bandaid for?", "id": "d7c0ral"}, {"comment": "\"bandaid\" probably has the wrong nuance, but to run with the metaphor, Rust's borrow checker is working around a lack of a GC and usage of mutable, referenceable value types by giving you a list of things you can't do. It's not solving the core difficulty of not having a GC, it's just building a wall around it so you can't fall in the pit at runtime.", "id": "d7c2gsq"}, {"comment": "> It's not solving the core difficulty of not having a GC,  it's just building a wall around it so you can't fall in the pit at runtime.\n\nWhat exactly is the difference between those two things?  \nAs far as I know, it runs fine without GC, so what's the core difficulty you're alluding to?", "id": "d7c2pa8"}, {"comment": "I think the problem with arguments like these is that it's assumed there are a set of PLT-approved best practices for programming languages and any language that doesn't abide by those rules is dumb. Usually people use this argument when someone has the audacity to make a language that have their pet feature, be it type inference or pattern matching or whatever. ", "id": "d77c0mx"}, {"comment": "> This article doesn't say much of anything.\n\n> \"I think one requires PLT before one can design a good language\" with nothing to back that up.\n\nIt's just people justifying the time they put into learning this stuff. It outrages people when they think some upstart can come in, ignore everything they studied and succeed where they have failed. And they HAVE failed. Blow has made it very clear he'd rather be making video games than writing his own language, but he's fed up with C++ and nothing else out there gives him what he needs.", "id": "d77nvkr"}], [{"comment": "> Experience shows that the only scalable approach is to leverage, to the highest degree possible, programming language theory (PLT).\n\nWhat does this mean? What experience? Is there a language that has leveraged PLT to any significant extent and also been used as heavily as C++, JavaScript, PHP, or any other screwball mainstream language? Obviously there are plenty of avoidable mistakes in language design, but it's wishful to believe that more theory makes a better language, when you're comparing a thoroughly tested language like C++ against a language which has been used so little in comparison. Don't mistake the mere lack of a spotted track record for the presence of a great track record. It's like Stroustrup said: There are only two kinds of languages: the ones people complain about and the ones nobody uses. (Although there's actually another kind: languages so against the grain that people criticize them for even existing. APL, Forth, Lisp, being examples.)", "id": "d775uro"}, {"comment": "You had me going until you got to the Stroustrup quote. That always struck me as a cop-out for avoiding actually discussing the design problems in his language.", "id": "d776kye"}, {"comment": "> That always struck me as a cop-out for avoiding actually discussing the design problems in his language.\n\nIt is, and normally it bothers me. But we can also take it as a reminder not to get too smug about our design until it's as well-used as C++ was when he said it.", "id": "d776w7v"}, {"comment": "By the time your language has even a small fraction of the use of C++, it's too late to significantly change the design - and extremely difficult to even maintain aim extend it.\n\nPLT is about getting the language design correct before it's too late to learn from your mistakes - which can be awfully sudden if your language happens to see real adoption.", "id": "d77afqs"}, {"comment": "That's a great aim.", "id": "d77aly4"}, {"comment": "Scheme has leveraged PLT to a significant extent and has had massive pervasiveness http://philosecurity.org/2009/01/12/interview-with-an-adware-author :)", "id": "d77a1t0"}, {"comment": "And don't forget the entire ML family of programming languages. With the advent of F#, Rust, and Scala, PLT-designed languages are threatening to eat up C++'s market share.", "id": "d77an9y"}, {"comment": "> F# [...] and Scala [...] are threatening to eat up C++'s market share.\n\nHow on earth would they do that?", "id": "d77uhtq"}, {"comment": "> How [...] earth would [...] do that?\n\nEarth is pretty determined, sometimes.\n\n", "id": "d77uurx"}, {"comment": "Your objection would make sense if you didn't have the full quote a centimetre above my shorthand that demonstrated that my redactions don't change the meaning of the parts I quoted.\n", "id": "d77uyxk"}, {"comment": "Your redactions completely changed the *scope* of what was suggested.  \n\nI mean, I still think it's fanciful to suggest that ML-family languages, and more broadly \"PLT\" languages are about to eat C/C++'s market share.  But it's certainly a more reasonable prediction than to expect that of *just* F# and scala. \n\nBut C/C++ *have* been on a long slow decline, and perhaps more soundly designed languages have played their part in that.  Not eating market share up, but eating into market share.  Maybe.\n\nPersonally, I suspect PLT is just incidental: memory safety matters, and memory safety both enables and to some extent leverages PLT. So I don't expect Jai to be successful either, though I wish it would be.  It's just hard for a new language with no memory-safety story to gain a serious foothold.", "id": "d77vieo"}, {"comment": "My qualm wasn't with F# and Scala not being sufficient to \"eat up C++'s market share\", my problem was that those languages aren't even in the same ballpark. It's like saying \"With the advent of sponges, reinforced titanium and cardboard, modern materials are threatening to displace older materials in sword making.\"", "id": "d77vni4"}, {"comment": "Nevertheless, even languages like python are displacing C to some extent.  Because even code that needs to be efficient doesn't necessarily need *everything* to be highly efficient. Fast, small kernels can be sufficient. Lots of games use scripting engines for most of their code - even if most cycles are spent in a small native core.\n\nTo use a slightly different analogy: although steel is still present in every car (AFAIK), some modern cars use very little.", "id": "d77x8ox"}, {"comment": "But APL is amazing :(\n\nNot that I use it ", "id": "d799mkg"}], [{"comment": "Lots to be said here, but one lightweight way to work on language semantics is this tool: https://redex.racket-lang.org", "id": "d772q1m"}], [{"comment": "Does PLT discuss pragmatic issues such as IDE support? \n\nThings like robust partial compilation (i.e. when there are syntax errors) and code completion are a must have for modern programming languages. And we go to great pains to make languages such as C#, Java, and SQL have even basic support for this. ", "id": "d777ae7"}, {"comment": "It depends what you're talking about. Programming language theory doesn't have a subfield called 'IDE support', but things like partial compilation, continuation of compilation upon encountering errors, code completion, etc. are all heavily researched in, in academia. ", "id": "d77fnts"}, {"comment": "Of course. The relevant part of PLT is called \"Type theory\".", "id": "d778dmf"}, {"comment": "It isn't a type issue, but rather syntax. ", "id": "d779rzx"}, {"comment": "Well, it's both. If you can statically figure the types you can narrow the completions quite a bit. Though that doesn't make type theory a substitute for programmer experience kind of stuff. In PLT researchers' dreams.", "id": "d77cfg2"}, {"comment": "Why? Syntax is not a problem at all, you can parse efficiently pretty much any syntax imaginable. What makes a huge difference for an IDE support is exactly how type system is working. For a strict static type system an IDE can infer anything, all the context relevant completion suggestions, etc. For a shitty dynamic type system, IDE is deaf and blind.", "id": "d77ac5h"}, {"comment": "I find it hard to believe that you aren't just trolling me. But for the sake of argument, consider these fragments. (I'll use x to represent the cursor.)\n\n    FROM TableName SELECT x\n    SELECT x\n\nIn the first syntax you are limited to global functions and columns in `TableName`. For the second, you have to show the list of all columns across all tables across all schema across all databases on the server. Clearly one is more tenable than the other.\n\nNext example:\n\n    var localVar x\n    x\n\nThe first example uses the VB/Go/TypeScript style where in the variable precedes the type name. This allows you to limit the possible items to just types.\n\nIn the second example (C, C++, C#, Java) you have to show every type and every variable. That is, you would except you don't have a triggering event so code completion wouldn't even start yet. (Triggering events are usually dot, space, parens, and some mathematical operators.)\n\n***\n\nAnd then there is the missing end-bracket issue in C-based languages, where in it is very hard to determine where the missing token belongs. This is something that you don't see in languages like VB or FORTRAN because each construct end is distinct (e.g. END FUNCTION vs END IF).\n", "id": "d77aqt2"}, {"comment": "All such things are pretty minor in comparison with the typing issue. Showing identifiers or types first is nothing vs. not knowing *anything* at all about what type the value can take.\n\n\n\n", "id": "d77b1kk"}, {"comment": "That sounds like PLT research has been essentially dead since the mid-90's, if not earlier. \n\nDon't get me wrong, I do believe that a robust type system is part of the equation. But if that's the only thing you are considering then you aren't really talking about programming language design.\n ", "id": "d77cbit"}, {"comment": "wikipedia suggests the same.", "id": "d77dj6z"}, {"comment": "You should have noticed already that I look down on anything syntax. I do not count syntax as anything important at all.\n\nBut you're right, we're still digging through the piles of shit left by the late 80-s - early 90-s PLT research. And will keep doing so for at least a couple more decades.", "id": "d77ew73"}, {"comment": "Wow, you sound exactly like a caricature of the Ivory Tower Idiot. How does it feel to be a living stereotype?", "id": "d77gk1c"}, {"comment": "Just look at all the *successful* IDEs out there and you'll see that I am right. I am far more practical than anyone who's mumbling about syntax.", "id": "d77h3gw"}, {"comment": "Quite the opposite, though. He's not 'ivory tower' at all. He has no respect whatsoever for academic research.", "id": "d77z5z9"}, {"comment": "It only sounds like PLT research has been 'essentially dead since the mid-90's' if you're being mislead by /u/combinatorylogic to think that PLT research consists entirely of type theory research. But he's an idiot.", "id": "d77fstm"}, {"comment": "That's good to hear, but at the same time it's sad that he's slandering a whole academic discipline for his own ego's sake.", "id": "d77gtle"}, {"comment": "I have him RES-tagged as 'retard' for good reason.", "id": "d77y3wc"}, {"comment": "Can you read at all, pleb?\n\nOnly the type theory is relevant to the IDE shit There is a lot of other irrelevant shit in the PL research which is also dead since mid 90s.", "id": "d77ga5h"}, {"comment": ">Can you read at all, pleb?\n\nCan you?\n\n>Only the type theory is relevant to the IDE shit\n\nFirstly, type theory isn't part of programming language theory.  \nSecondly, type theory is not the only thing relevant to 'the IDE shit', by which I assume you mean language tooling research for IDEs.\n\n>There is a lot of other irrelevant shit in the PL research which is also dead since mid 90s.\n\nYou're biased and stupid.", "id": "d77y3q6"}, {"comment": "> FROM TableName SELECT x\n\n> SELECT x\n\nThat's not just a difference in syntax.  One of the two expressions has more information.", "id": "d7c0vg4"}, {"comment": "Something you seem to be misunderstanding is that neither of those is a complete statement; the programmer is still in the process of typing the line. \n\nThe `x` is the keyboard cursor, not a column name.\n\n\n", "id": "d7c29li"}, {"comment": "Type theory isn't a part of programming language theory. Programming language theory is its own thing, and it draws on type theory somewhat, but they are distinct areas of research. Programming language theory is practical computer science, type theory is mathematics.", "id": "d77fqsr"}, {"comment": "To answer your question, no, it does not really. PLT is generally concerned with designs in the languages themselves, and while concerns like IDE support and partial compilation might fall under that umbrella, the focus of most research is generally on making something innovative rather than usable. \n\nI would say that with most PL research you get a language specification and if you're lucky a buggy proof of concept compiler/interpreter. Tooling is generally not considered unless the tooling happens to be the point of your research.", "id": "d77bcgg"}, {"comment": "What a load of rubbish. Yes you might not get a whole lot of that stuff from the people studying Haskell, but there's a hell of a lot more to programming language research than Haskell. Of course there are people out there looking at how to design languages to be more easily partially compiled, for example.\n\n>I would say that with most PL research you get a language specification and if you're lucky a buggy proof of concept compiler/interpreter. Tooling is generally not considered unless the tooling happens to be the point of your research.\n\nNobody researches 'tooling'. People research specific aspects of tooling. The vast majority of programming language research is about existing languages, not about creating brand new languages. ", "id": "d77fpks"}, {"comment": "> Tooling is generally not considered \n\nThat doesn't sound very promising. Tooling support has been a major part of applied language design since at least the late 90's with the Visual Basic series. Possibly earlier in stuff like Turbo Pascal, but I can't remember that far back.", "id": "d77ck1i"}, {"comment": "It shouldn't sound either promising or worrying to you: that's just the name of the game. Programming language theory is obviously not concerned with the pragmatic business of making things really usable, since that stuff is pragmatic and not theoretical.", "id": "d77dbkm"}, {"comment": "Programming language research certainly can be concerned with usability. In fact there is a hell of a lot of research out there on what aspects of languages make them more or less usable. ", "id": "d77fqh5"}, {"comment": "That's like saying it's ok for aerospace engineers to completely ignore the wings because engine design is more interesting, with the inevitable result of building engines that can't be mounted.", "id": "d77grmk"}], [{"comment": "Yo u/bryanedds. In your article you linked to two textbooks, but it looks like you meant to link three. Asking because I'd like to know what the third is, if there is one :)", "id": "d77cc90"}, {"comment": "Thank you - fixed :)", "id": "d77d1td"}], [{"comment": "Could the OP list languages he feels are successful results of this philosophy?\n\nIf there are successful results of this philosophy, why are there no languages that AAA level game programmers are happy with (other than C/C++)?\n\nIf the set to people subscribing your philosophy could please apply your sacred knowledge to making a better high performance language, we would appreciate it.\n\n\n", "id": "d779jv0"}, {"comment": "I think a lot of successful modern languages are the result of very accomplished researchers trying to find a compromise between popular languages and wisdom gained from PLT research.\n\n* One of C#'s biggest advantages over Java is its support for reified generics, from which many other advantages emerged. I believe it was Don Syme (a PLT researcher now better known for creating F#) who pushed for this very expensive but forward-thinking design. There's also a costly mistake in C#'s array semantics, which came from ignoring PLT (it was debated internally at the time).\n\n* Java was a disappointment to many of the original OOP researchers, but much of its success came from research in language runtime technology which made its way into the JVM.\n\n* Typescript is a pretty big success now, and is basically an incredibly clever application of PLT to javascript.\n\n* Scala is obviously very polarizing, but also very successful. It's all PLT, compromised to work with the JVM.\n\n* Swift is obviously very heavily based on research languages in the ML family, again compromised to work with legacy systems.\n\nYou're right that almost every new programming language ignores the whole area of soft-realtime, high-throughput systems. There is actually a lot of research relevant to the problem, and quite a few abandoned research languages. I think the problem is that there wasn't much commercial interest in the research, which means academic funding starts to dry up too.\n\nThis changed recently, with Mozilla's investment in Rust (which was created largely by scavenging the corpses of dead research languages). Rust obviously isn't to everyone's liking, but I prefer to view it as the first step, rather than the answer to all our problems. Incidentally, I have my own plans to apply PLT to the creation of a better language for games, and I'm sure I'm not the only one.", "id": "d77foms"}, {"comment": "I've just begun to delve into Rust, but performance wise it is indeed very promising so far.\n", "id": "d77gptb"}, {"comment": "> There's also a costly mistake in C#'s array semantics, which came from ignoring PLT (it was debated internally at the time).\n\nNo, that came from the requirement to be compatible with Java array semantics. They knew what they were giving up.", "id": "d77gm7v"}, {"comment": "I didn't mean to suggest they ignored it with no good reason. It's only a mistake because that business requirement evaporated, which isn't their fault. My point was just that they were very academic people who knew the ins and outs of the decisions they were making.", "id": "d77i7l0"}, {"comment": "I'm not sure that you can say that the reason evaporated. IKVM is still a thing.", "id": "d77n4nv"}, {"comment": "No a thing that's worth a lot, I suspect.  Nor a thing that couldn't be emulated even on a VM with slightly different semantics.\n\nI'm surprised that they even considered it an advantage at the time. It sounds like classic premature optimzation/being too clever.  As if \"minor\" semantic tweaks are enough to subsume the JVM, or that VM's and programming languages are simple enough that you can mash two semantics into one VM (and not suffer the consequences). Oh well.", "id": "d77uszo"}, {"comment": "> why are there no languages that AAA level game programmers are happy with (other than C/C++)?\n\nAAA game developers require a compiler that's had far more engineering work put into it than PL academia can afford.", "id": "d77co1n"}, {"comment": "Plus everything else in the ecosystem: libraries, a large community, tooling (e.g. IDE, package manager), etc.", "id": "d77cxhk"}, {"comment": "lot of c++ guys dont use the ide or package managers as is.  the huge set of libs of course, is big.", "id": "d77dk93"}, {"comment": "IDEs and package managers are certainly not requirements for AAA game developers.", "id": "d77flzn"}, {"comment": "llvm solves a lot of that.", "id": "d77djay"}, {"comment": "> why are there no languages that AAA level game programmers are happy with (other than C/C++)?\n\nI would say: because apart from Rust, languages created by academics come with a GC/heavy runtime and do not perform as well as C/C++... and Rust is still too young to be widespread enough.\n\nI would point that the mindset of AAA level game programmers is very much performance (over anything else) oriented. As an example, see the design of the Nim programming language, which elides a number of checks in release mode because it slows things down (much like Rust elides overflow checks).\n\nFor an AAA game performance is an essential feature, so its developers are ready to compromise on safety/ergonomy/... so long as they get it.", "id": "d77jl59"}, {"comment": "I suppose I would say 'the many of languages of the ML and Lisp families' - \n\nhttps://en.wikipedia.org/wiki/ML_(programming_language)\n\nhttps://en.wikipedia.org/wiki/Lisp_(programming_language)", "id": "d779xk4"}, {"comment": "I'm not sure I'd count Lisp.  Maybe some of the more modern variants such as Scheme, but classical Lisp with unhygenic macros and dynamic scope (or a mix of dynamic and lexical scope, in Common Lisp) could have stood to learn a lot from modern programming language theory.  It does have the excuse, though, of being nearly 60 years old, so predating most of what we think of as PLT today.", "id": "d77bftb"}, {"comment": "> classical Lisp with unhygenic macros and dynamic scope (or a mix of dynamic and lexical scope, in Common Lisp)\n\nThose aren't really the right things to call out. Macro-writing can benefit from some helpers to avoid unintended capture bugs (at the very least a `with-gensyms` macro), but one reason Lisp macros are great is because they're dead simple. You know why \"hygienic\" macros have that name? Because they're not a big enough deal to stand on their own, without a little verbal punch to help out.\n\nDynamic scope has proved a poor default, but it's undeniably a useful midpoint between a local variable and a global variable. Not a mistake at all IMO.", "id": "d77hj6n"}, {"comment": "Unhygenic macros are superior to hygenic macros though.", "id": "d77fmi8"}, {"comment": "Hygienic macros are retarded. Any true and practically useful macro system must be unhygienic.", "id": "d78x99p"}, {"comment": "Uohhh, kinky.", "id": "d79eia6"}, {"comment": "an ML language is one of my favorites but i wouldnt try to use it for doom5.", "id": "d77dian"}, {"comment": "How about Rust? It's like ML with curly braces.", "id": "d77u8g1"}, {"comment": "And, more importantly, a drastically different resource management strategy.", "id": "d785zsz"}, {"comment": "> If there are successful results of this philosophy, why are there no languages that AAA level game programmers are happy with (other than C/C++)?\n\nI think we're on the cusp of seeing this, thanks to the Unreal 4 Technology and [Blueprints](https://docs.unrealengine.com/latest/INT/Engine/Blueprints/). The theoretical underpinnings of Blueprints almost certainly derive from [Lambda calculus plus letrec](http://ix.cs.uoregon.edu/~ariola/cycles.html). The reason I say this (apart from familiarity with the content) is that it was Tim Sweeney who made me aware of the paper.", "id": "d77rjbf"}, {"comment": "Tim Sweeny has been doing a lot of javascript lately...not sure what THAT means!", "id": "d77vdna"}, {"comment": "JavaScript is the x86 of the internet: spectacularly ugly, ubiquitous, and unavoidably a target. Tim would be negligent not to explore, e.g. [emscripten](https://kripken.github.io/emscripten-site/) and/or other JavaScript-targeting options.", "id": "d78355m"}], [{"comment": "> Jon\u2019s approach is seen as one that violates a most important rule in programming \u2014 \u2018Don\u2019t be clever.\u2019\n\nHa! The *whole point* of Jai is that Blow is sick of people being clever. He's basically writing KISS-the-language, because PLT theorists are too busy adding leaky layers of abstraction on top of leaky layers of abstraction to actually produce anything he can use in his domain.", "id": "d77ujtd"}], [{"comment": "> like writing an object-oriented program without knowledge of Design Patterns\n\nThat seems mostly fine -- the design patterns I end up using aren't exactly what's documented somewhere. It's helpful to read about examples, but I don't really get the fetishization of design patterns as some kind of divinely inspired knowledge. It's all stuff anyone can come up with on their own if they think carefully about the problem at hand.", "id": "d78u1pn"}], [{"comment": "[deleted]", "id": "d77esl7"}]]], "4kie62": ["To Write Better Code, Read Virginia Woolf (NYT)", "2016-05-22 16:38:03", 0, "http://www.nytimes.com/2016/05/22/opinion/sunday/to-write-software-read-novels.html", [[85, "This one passage, in particular, caused me to cringe:\n\n> Instead of freezing up over the logical permutations behind each A and S, she found that these symbols put her in the mind of musical notes. As notes, they could be made to work in concert. They could be orchestrated.\n\nI have no doubt that their music major found the solution to their problem, and I have no doubt that her background in music was helpful. But the author paints a picture of the \"A\" and \"S\" symbols coming together into a beautiful symphony under the guidance of this music major. In practice, I doubt that there was anything aesthetically pleasing or particularly musical about the specific arrangement of the \"A\" and \"S\" symbols. The goal was almost certainly not to bring the \"A\"s and \"S\"s into harmony, but rather to get them arranged according to specific and somewhat arbitrary rules. \n\nThis passage was equally frustrating:\n\n> On a subsequent project, our problem was pointers. In programming language, a pointer is an object that refers to some master value stored elsewhere. This might sound straightforward, but pointers are like ghosts in the system. A single misdirected one can crash a program. Our pointer wizard was a philosophy major who had no trouble at all with the idea of a named \u201cthing\u201d being a transient stand-in for some other unseen Thing. For a Plato man, this was mother\u2019s milk.\n\nSure, I'm sure that a philosophy major will have experience with naming and symbols. But the author seems to suggest that the philosophy background that made this person uniquely suited to dealing with pointers. You know who else has to deal with indirection and symbolic names? *Computer science majors!* Many common data structures involve some amount of indirection. We deal with symbolic names all the time. \n\nIncidentally, the real problem with pointers isn't creating them or dereferencing them. The real problem is lifetime management. In a GC language, you can more or less ignore the problem, but in a language like C, it becomes very important to understand how long the pointed-to value will last and who is responsible for cleaning things up. I could be wrong, but I don't think a background in philosophy will better prepare one to deal with these problems than any other background would.\n\nThis article is a rebuttal to the idea that STEM is king and that the humanities are an unnecessary luxury. That's fine. But it goes to far. It seems to say that programming is easy, and can be mastered by pretty much anybody in a relatively short period of time. \n\n> But if anything can be treated as a plug-in, it\u2019s learning how to code. It took me 18 months to become proficient as a developer.\n\nI doubt this. I'm sure that, after 18 months, a certain level of proficiency was reached. The author is probably saying \"after 18 months, I was proficient enough to do the work that I needed to do\". But 18 months is barely enough time to see how a system changes over time. A huge part of software engineering is in understanding how future (and currently unknown) needs will likely affect the system, and to design things with enough flexibility that the system can accept those future changes without falling apart (and equally, to not go overboard with adding that flexibility up front). You can't possibly understand these things in a mere 18 months.\n\nI think it's great to have a variety of backgrounds on a team. We have a few aesthetically-minded people on my team, and it's wonderful. I'd love more of that. I'd love a wider variety of perspectives. But that's how you argue for the continued study of the humanities - explain how different backgrounds bring truly unique perspectives that are unknowable to people lacking that background. Instead, this article seems to say that liberal arts students not only have knowledge in their domain of study, but they are naturally better at computer science than people who had been studying computer science for years. That seems highly suspicious."], [19, "It is, unfortunately, part of the breakdown in the US education system that Americans think that university is no more and no less than a vocational school.\n\nA lot of it is that US post-secondary education is so ruinously expensive that you have to justify it as an investment in your career.\n\nI went to university in Canada starting in the 70s.  There was a completely different attitude - you studied things that made you a better all-round person, which as a side-effect made you more employable.\n\nI took whatever I pleased - mostly pure math and electronic music courses, but with a lot of programming.  I learned far more about how to _learn_ difficult things than I would have if I had gone to a school to teach me how to write programs than anything else.  \n\nI've never regretted it for an instant, I know that it has made me a much better person (and incidentally a better worker) and I think the current education crisis is going to be very bad for the future of the United States (friends of mine who hire semi-skilled labor tell me that when the \"No Child Left Behind\" generation hit, they almost overnight had issues finding people who could even count change).\n\n"], [16, "I have an English degree and 25 year career in software engineering. I have worked with and hired dozens of people with non-traditional degrees, and they have disappointed me at about the same rate as those with computer science backgrounds.\n\nLiberal arts programs should do exactly as good of a job of teaching critical thinking, reason and logic as any that is science-based, and it may even be the case that the former do a slightly better job at preparing students to think outside of and challenge the norms and tropes of their professions."], [15, "I tried to read Virginia Woolf once but gave up after a dozen pages. Jacob's Room is now used as a monitor support which kind of helps me write better code. So there's that."], [12, "Yep. Everybody misrepresents that damned Jobs quote -\"Everyone should learn how to program a computer\". The important thing is learning to *think*, and it is indeed far easier to teach code to people who have done that. There are certainly a lot of liberal arts programs that don't require thought, but I've met plenty of engineers incapable of it as well. "], [10, "why do people think liberal arts and humanities degrees enable someone to become a more \"abstract\" thinker?\n\nliberal arts degrees are as rote and mechanical as any other....your professor has an answer they want and that had better appear on your exam\n\nin many cases in undergrad history, I diverged from the prescribed course agenda with rational material that simply wasn't sourced from the texts we were reading.....bzzzt! the professor in each case correctly informed me that the point of the exam was to see if I read the books, not if I had an opinion\n\nthe \"abstract thinker\" trope has emerged as humanities programs desperately search for some way to sell increasingly pointless material to the PARENTS of undergrads who are forking out $40k per year for junior"], [10, "I am a former English teacher turned programmer who has been working in the industry for about five years. \n\nI minored in Philosophy and in the study of philosophical texts, I practiced imagining things out to their logical conclusions. When Wittgenstein asks \"Can a baby lie?\" there are so many potential implications and subtleties in the question that it takes a degree of creativity to doggedly pursue a question like this as far as you can take it (sometimes for hundreds of pages of analysis). This kind of imaginative practice is a skill I use on a daily basis as a programmer. Indeed, it prepared me to be able to imagine many of the places where my applications can fail or to ask questions when speccing out new product features. However, I would never recommend this as a generic way to train developers.\n\nWhile I think there is a strong argument to be made about programming (engineering as well) as a creative endeavor, and I also think an argument may be made that studying the Humanities can foster creative thinking, I am unsure how universal it is that a humanities-based education would prepare someone for a career as a developer. It just happened to work for me.\n\nThe best I can say is that a specialized education is probably more limiting to someone's career options than being forced to study a broad array of different things. In other words, creative thinking and the ability to learn things independently trump all other skills. \n\nCan these two things be taught? If so, probably the best way to do so is to force someone to step out of a single area of specialization, to challenge themselves, and to take on different mental models and perspectives."], [9, "So if humanities graduates are less like to engage in mechanical thinking and understand nuance, why do they cling to mechanical and un-nuanced ideas like the presumption that their degree makes them better qualified to work abstractly?\n\nSounds a lot like the dry, inflexible, categorical assertions they accuse computer science graduates of engaging....\n\nMaybe its just time to admit that this idea is something they heard a college recruiter or department head mention, and they've been repeating it without any supporting argument ever since....despite apparently having such a superior ability to reason abstractly and form an argument."], [5, "If only I had a philosophy major, I would have understood pointers more easily, drats"], [3, "Code is never about aestethics, it's about solving a problem. If you read Virginia Woolf to write better code, you're not going to write very useful programs. The code is not the goal."], [2, "in related reading, see the almost classic article by paul graham - [hackers and painters](http://www.paulgraham.com/hp.html)"], [1, "Link to original discussion: https://news.ycombinator.com/item?id=11746297"], [-7, "lame!!"]], [[{"comment": "This one passage, in particular, caused me to cringe:\n\n> Instead of freezing up over the logical permutations behind each A and S, she found that these symbols put her in the mind of musical notes. As notes, they could be made to work in concert. They could be orchestrated.\n\nI have no doubt that their music major found the solution to their problem, and I have no doubt that her background in music was helpful. But the author paints a picture of the \"A\" and \"S\" symbols coming together into a beautiful symphony under the guidance of this music major. In practice, I doubt that there was anything aesthetically pleasing or particularly musical about the specific arrangement of the \"A\" and \"S\" symbols. The goal was almost certainly not to bring the \"A\"s and \"S\"s into harmony, but rather to get them arranged according to specific and somewhat arbitrary rules. \n\nThis passage was equally frustrating:\n\n> On a subsequent project, our problem was pointers. In programming language, a pointer is an object that refers to some master value stored elsewhere. This might sound straightforward, but pointers are like ghosts in the system. A single misdirected one can crash a program. Our pointer wizard was a philosophy major who had no trouble at all with the idea of a named \u201cthing\u201d being a transient stand-in for some other unseen Thing. For a Plato man, this was mother\u2019s milk.\n\nSure, I'm sure that a philosophy major will have experience with naming and symbols. But the author seems to suggest that the philosophy background that made this person uniquely suited to dealing with pointers. You know who else has to deal with indirection and symbolic names? *Computer science majors!* Many common data structures involve some amount of indirection. We deal with symbolic names all the time. \n\nIncidentally, the real problem with pointers isn't creating them or dereferencing them. The real problem is lifetime management. In a GC language, you can more or less ignore the problem, but in a language like C, it becomes very important to understand how long the pointed-to value will last and who is responsible for cleaning things up. I could be wrong, but I don't think a background in philosophy will better prepare one to deal with these problems than any other background would.\n\nThis article is a rebuttal to the idea that STEM is king and that the humanities are an unnecessary luxury. That's fine. But it goes to far. It seems to say that programming is easy, and can be mastered by pretty much anybody in a relatively short period of time. \n\n> But if anything can be treated as a plug-in, it\u2019s learning how to code. It took me 18 months to become proficient as a developer.\n\nI doubt this. I'm sure that, after 18 months, a certain level of proficiency was reached. The author is probably saying \"after 18 months, I was proficient enough to do the work that I needed to do\". But 18 months is barely enough time to see how a system changes over time. A huge part of software engineering is in understanding how future (and currently unknown) needs will likely affect the system, and to design things with enough flexibility that the system can accept those future changes without falling apart (and equally, to not go overboard with adding that flexibility up front). You can't possibly understand these things in a mere 18 months.\n\nI think it's great to have a variety of backgrounds on a team. We have a few aesthetically-minded people on my team, and it's wonderful. I'd love more of that. I'd love a wider variety of perspectives. But that's how you argue for the continued study of the humanities - explain how different backgrounds bring truly unique perspectives that are unknowable to people lacking that background. Instead, this article seems to say that liberal arts students not only have knowledge in their domain of study, but they are naturally better at computer science than people who had been studying computer science for years. That seems highly suspicious.", "id": "d3f9dfw"}, {"comment": "I agree. Expert beginners are dangerous.", "id": "d3fcn1o"}, {"comment": "This is true, and each of us as developers surely can look back in retrospect and chagrin at those moments where we claimed premature expertise which now look absurdly amateurish and arrogant.", "id": "d3fdmcg"}, {"comment": "This entire article is pure garbage.  If they think 18 months is enough then I beg them to put their money where their mouth is and let me interview them.  I have had no problems seperating a competent software engineer from those that program as a means to an end. Humanties can help you gain insight but is not a replacement for the engineering rigor. Developing software isnt just programming, you have to have discipline, forsight, diligent documentation practices, knowledge of version control.  You could be the God of C++ but if you lack the other skills you arent really useful on large scale projects.", "id": "d3fbd2s"}, {"comment": "Doesn't everyone program as a means to an end though?", "id": "d3fg6z2"}, {"comment": "In pretty much every creative field, there's two types of people: those who are most concerned with the result and those who are most concerned with the process. That is not to say that the former group doesn't care about the process and vice versa, but that fundamentally each camp is drawn to the task at hand for a different reason.", "id": "d3fk2i2"}, {"comment": "I actually enjoy writing code. So no, its not a means to an end, at least for me.  I know there are more with a similar view point. ", "id": "d3fhpl6"}, {"comment": "This entire article exists to massage away the writer's own insecurities, and to reassure the millions of young Americans going into six-figures of debt to get Sociology degrees. \n\nIts true, one day you, as a Sociology graduate, may be able grasp Derrida and Foucalt...and a programmer you encounter may not....but that won't matter, because your job will be to make that programmer a latte that they enjoy.", "id": "d3fdjq6"}, {"comment": "...and now we've gone too far in the other direction. \n\nGoddammit reddit, stay on target. ", "id": "d3fl7vw"}, {"comment": "Thank you for this!  I worked at a consultancy where the bosses were self-taught and had an outspoken distaste for formal education in computer science, despite neither of them being able to articulate what computer science even is (without any sense of irony about this).  They would proudly proclaim that a bachelor's in CS counted against potential hires, and would prefer a bootcamper without experience.  Before I left, they put someone with 3-months of (part time) bootcamp education in charge of my project, someone who'd get frustrated with me about using the words \"getter\"and \"setter\".  You can imagine how well that went.  I felt like I was taking crazy pills working there.\n\nIt's so strange to me that there's an industry with a vocal contingent of people who denigrate specialist education *for that industry*.  Maybe it's not uncommon, but I've never read a NYT article about how philosophers are particularly well-suited to being mechanics or painters.  I don't believe you need a 4 year degree to be a brilliant software engineer, but it's bizarre to contend that such education is not useful or detrimental.", "id": "d3fkg67"}, {"comment": "What I don't get is how they think these skills are unique to people involved in a particular major. Only philosophy majors can understand concepts like \"two names referring to the same concept\"? Except \"A rose by any other name smells as sweet\" is one of the most popular quotes in the English language, and I'm pretty sure other major languages have similar quotations.\n\nThey're still ascribing to a system by which people in a major or a trade are symbolic *of* that trade, which is a very romantic viewpoint, and a comfortable one, but the reality is that Computer Science majors are taught to think about things a particular way that is suited to issuing commands to a computer which follows a set of rules to make decisions. Hilariously, this makes CS majors capable of effectively learning *any other major* and replicating their decision-making. I could just as easily write an article about how humanities is useless because any CS major could replicate their roles, but I won't because I'm not a twat desperate to prove I'm still relevant.", "id": "d3fmdp5"}, {"comment": "Exactly, I think we need more poet engineers than engineering poets.", "id": "d3fb60d"}, {"comment": "[deleted]", "id": "d3ff76k"}, {"comment": "I'm not really that into poetry, but I think this just proves that the (modern, anyway) perception of poetry is mostly arbitrary rather than that AI is genuinely good at writing poetry.", "id": "d3fhdoy"}, {"comment": "[deleted]", "id": "d3fl7m4"}, {"comment": "You're right. Additionally, empirical evidence can't be used to *prove* anything either. ;P", "id": "d3fxevf"}, {"comment": "Ordinarily I'm not one for flippant comments but.... #rekt", "id": "d3flgcn"}], [{"comment": "It is, unfortunately, part of the breakdown in the US education system that Americans think that university is no more and no less than a vocational school.\n\nA lot of it is that US post-secondary education is so ruinously expensive that you have to justify it as an investment in your career.\n\nI went to university in Canada starting in the 70s.  There was a completely different attitude - you studied things that made you a better all-round person, which as a side-effect made you more employable.\n\nI took whatever I pleased - mostly pure math and electronic music courses, but with a lot of programming.  I learned far more about how to _learn_ difficult things than I would have if I had gone to a school to teach me how to write programs than anything else.  \n\nI've never regretted it for an instant, I know that it has made me a much better person (and incidentally a better worker) and I think the current education crisis is going to be very bad for the future of the United States (friends of mine who hire semi-skilled labor tell me that when the \"No Child Left Behind\" generation hit, they almost overnight had issues finding people who could even count change).\n\n", "id": "d3f8uiz"}, {"comment": "As someone who used to teach, it is a matter of both laziness of teachers and the complaining of students and parents that has led to this situation.\n\nI could test students on critical thought and creativity. But they would just bitch. Their parents would bitch. So I just test them on if they can read and regurgitate information. I teach them accordingly.", "id": "d3fa908"}, {"comment": "Exactly! Students don't want to learn, they want high grades. I figured that out as a TA in grad school marking papers.\n\nCan you blame them? High grades will serve them better in their immediate post-graduate state than actual learning will.", "id": "d3fdodc"}, {"comment": "> I went to university in Canada starting in the 70s. \n\nlong before Canadians and everyone else had to compete with the ENTIRE WORLD....and university was dirt cheap\n\ni went to university in Canada in the 80s and it was so cheap that even my blue-collar parents could pay for it with a minimal of savings. i think my tuition was $2700 a year....at those prices, and with a fair expectation of a waiting job, any degree can be justified\n\ntimes have changed! go look at what your university is charging now....\n\nits very easy to justify a humanities degree for $20k. for $200k, it is harder...", "id": "d3fck1l"}, {"comment": "Yup. I went to school around the same time and didn't know anyone who borrowed money to go to school. I didn't even know student loans were a thing until the 90s when new coworkers would complain about their debts.", "id": "d3fdq8y"}, {"comment": "In terms of the only actual concrete, measurable, part of your post, it is exactly the opposite. Canadian undergraduate degrees are much more specialized with fewer courses expected for breadth compared to the U.S.. A typical physics major in the US will take about half non technical distribution courses . In Canada it will be close to eighty percent technical. I did undergrad at Toronto and ta'ed at UIUC, so I got to see it first hand. \n\nI definitely prefer the Canadian way, I'd rather be able to specialize in what I already know I like instead of being forced to take a bunch of classes based on memorization or bullshitting. ", "id": "d3fhoxa"}, {"comment": "That varies based on school and major. At my US school, math and pure science students were lumped together with the humanities people, so they had the same distribution requirements. CS and engineers were about 80% technical subjects with 20% social science s and humanities.", "id": "d3fklv2"}], [{"comment": "I have an English degree and 25 year career in software engineering. I have worked with and hired dozens of people with non-traditional degrees, and they have disappointed me at about the same rate as those with computer science backgrounds.\n\nLiberal arts programs should do exactly as good of a job of teaching critical thinking, reason and logic as any that is science-based, and it may even be the case that the former do a slightly better job at preparing students to think outside of and challenge the norms and tropes of their professions.", "id": "d3f5dvu"}, {"comment": "exactly, and this is more indicative of the uselessness of many undergrad compsci programs.\n\ni have found it very common that many new grads have exceptionally weak coding skills. colleges should start streaming students into special degrees like \"software engineering\" that focus more on practical matters but continue to impose rigor. then students who wish to focus more on theory can study \"computer science\" or \"informatics\" or whatever without creating an expectation that they are productive coders\n\nthis distinction already exists in other fields - for example my college offered both \"physics\" and \"engineering physics\", without judgement or rank....they simply had different goals for graduates", "id": "d3f8fcy"}, {"comment": "Just look at the courses they took.  Databases and Network Security?  Could be a poor programmer.  Compilers and Computer Graphics?  Definitely worked their ass off.", "id": "d3fa1lr"}, {"comment": "Computer Graphics was fucking easy at my University.\n\nBut Compilers was fun and difficult", "id": "d3fer1h"}, {"comment": "What was your computer graphics course like?\n\nMine had 5 projects, starting with a 2d overhead view of a (very basic) city, and leading up to a 3d program with ray-tracing, phong shading, loading in models from *.obj files, and a simple controllable camera.", "id": "d3flsbj"}, {"comment": "We had three projects (4 for grad students) They were:\n\n1. A simple I with animation. Also had to have a toggle to show the wireframe\n\n2. A flight simulator with randomly generated terrain (using the diamond-squares algorithm) and quaternion based controls. And shading on the terrain\n\n3. Loading the teapot from an obj file and doing reflections on it. Also textures and changing the height of the floor underneath the teapot using the texture \n\n4. Particle effects (I didn't do this because I was an undergrad)\n\n\nBesides those projects we had exams that were multiple choice and really easy\n\nEDIT: I feel weird putting my website on here but you can see my projects [here](http://thomasnelson.me/webgl)", "id": "d3fm3j7"}, {"comment": "Probably better if students take initiative and work on open source projects. That is how I got hired.", "id": "d3fa1ua"}, {"comment": "[deleted]", "id": "d3fb4fl"}, {"comment": ">there is little time \n\nThat's kinda the point. If you are taking so long on your homework and tests, you are probably not going to be as capable as someone who can finish the work in half the time. This is why colleges factor in extracirricular activities. If you are able to do all these things and make good grades, you are probably a fast learner and more capable person.", "id": "d3flop6"}, {"comment": "i agree! today its not about who you know, what you know...its about what you've DONE\n\nbring me a resume with commits to a well-known open source project and you automatically advance to the bonus round...", "id": "d3fcnc8"}, {"comment": "I agree with this, wholeheartedly. Regardless of what your major is, demonstrable work is a huge leg up when interviewing.\n\nMy decision to major in English while planning to pursue work in programming was greatly aided by being able to spend four years working for the college making changes to the Registrar and Bursar software.\n\nMy high school had a VAX 11/780, and that allowed my to wrangle a gig working full time in during the Summer and Winter breaks getting practical experience as a working developer. Back then, the Internet was only email and USENET and open source was anything that you put into a shar archive and posted in comp.source.whatever.\n\nBut today, when I am looking over a resume from a recent graduate or a young person looking to get out of their first job, if I see that they have included a profile on GitHub or elsewhere, I immediately look at it and check out what they have created.", "id": "d3fex00"}, {"comment": ">exactly, and this is more indicative of the uselessness of many undergrad compsci programs.  \n\nI think it's more indicative of the uselessness of pedagogy as far as instilling tangible skill at anything.", "id": "d3fjxxx"}], [{"comment": "I tried to read Virginia Woolf once but gave up after a dozen pages. Jacob's Room is now used as a monitor support which kind of helps me write better code. So there's that.", "id": "d3f7q4z"}], [{"comment": "Yep. Everybody misrepresents that damned Jobs quote -\"Everyone should learn how to program a computer\". The important thing is learning to *think*, and it is indeed far easier to teach code to people who have done that. There are certainly a lot of liberal arts programs that don't require thought, but I've met plenty of engineers incapable of it as well. ", "id": "d3f4nda"}, {"comment": "[deleted]", "id": "d3f4rz3"}, {"comment": "i have a degree in drama with a major in journalism. It required bugger all thought. To be fair, the entire point of that sentence was that you can also get an engineering degree without doing much beyond cranking the handle on the given formulae (I have most of one of those as well).", "id": "d3f4v72"}, {"comment": "To be fair isn't that the difference between an engineer and a mathematician wrt maths?", "id": "d3f513o"}, {"comment": "Engineers are supposed to actually think about application. I'm talking about \"recognise textbook problem, find textbook formula, plug in numbers\", which is easy to teach and learn, but creates \"engineers\" who can't solve problems they haven't seen in the textbook. It's not so much \"can't derive LaPlace from first principles\", which is indeed not something they should need. It's more \"don't understand why we use this formula but it worked in the exam\".\n", "id": "d3f56rf"}, {"comment": "I would argue that mathematicians are engineers too. Both fields require the same skill set. Understanding a problem, derive a solution, neglect what can be neglected or assumed.\n\nThey differ in the level of abstraction and complexity. Math is way more abstract but mostly not as complex (from my perspective). Engineers have a whole system to think about, constraints that can not be abstracted in a way as in math.", "id": "d3f9ih3"}, {"comment": "\"Math is way more abstract but mostly not as complex (from my perspective).\"\n\nAs someone with a Math degree and an Engineering degree, you have absolutely no idea what you're talking about.\n", "id": "d3fi75b"}, {"comment": "What if thought is just cranking the handle on a given formulae?\n\n", "id": "d3f53dt"}, {"comment": "> \"Everyone should learn how to program a computer\"\n\nOr learn to write a recipe for your favorite food. It depends on your background, but yes, everyone should understand a procedure and be able to pass it on to be repeated. ", "id": "d3f55ij"}], [{"comment": "why do people think liberal arts and humanities degrees enable someone to become a more \"abstract\" thinker?\n\nliberal arts degrees are as rote and mechanical as any other....your professor has an answer they want and that had better appear on your exam\n\nin many cases in undergrad history, I diverged from the prescribed course agenda with rational material that simply wasn't sourced from the texts we were reading.....bzzzt! the professor in each case correctly informed me that the point of the exam was to see if I read the books, not if I had an opinion\n\nthe \"abstract thinker\" trope has emerged as humanities programs desperately search for some way to sell increasingly pointless material to the PARENTS of undergrads who are forking out $40k per year for junior", "id": "d3f7cer"}, {"comment": "> in many cases in undergrad history, I diverged from the prescribed course agenda with rational material that simply wasn't sourced from the texts we were reading.....bzzzt! the professor in each case correctly informed me that the point of the exam was to see if I read the books, not if I had an opinion\n\nAs somebody with a CS degree with a philosophy minor, this sounds more like a shitty teacher than a condemnation of liberal arts as a whole. \n\nThough I suppose this likely differs depending on how far you are into your arts education, I could see a 100 level class wanting to make sure students read the material as a way to ensure that students know how to engage with it, which will be necessary for later courses. Once I got into the 3 and 400 level classes my professors generally didn't care too much about the contents of my arguments as long as it was largely on topic, well researched, and well argued.\n\nAside from that, I'd argue that there's a large similarity between the kind of algorithmic thinking needed for programming and the kind of thinking required for proper argumentation. People around here constantly bring up the example of telling a computer how to make a sandwich (or some other menial task) and then explaining that you'd have to define to the computer what it means to get bread, what bread is, how to get the toppings, how to put them on a sandwich, does the order matter, etc. \n\nDeveloping a strong argument is extremely similar (in fact equivalent via Curry-Howard correspondence if your argument is rigorous enough). If you're making an argument about what it means to live a good life you first have to define what you mean when you say \"good\". Much like in programming you have to define everything you mean (within reason) or else the audience won't be able to follow your argument (or worse, your argument may be invalid.\n\nI don't know if I'd say that humanities develops a better sense of abstract argumentation than straight STEM education but it certainly isn't orthogonal. Maybe it's simply correlation that those who develop this kind of abstract thinking tend to end up in (and do well in) either humanities or STEM, rather than that STEM/humanities breeds this kind of thought process.", "id": "d3f8gm7"}, {"comment": "> As somebody with a CS degree with a philosophy minor, \n\nplease, we all have degrees (i have three, assume most people here have more than one), you are not uniquely qualified\n\n> this sounds more like a shitty teacher than a condemnation of liberal arts as a whole.\n\nnope, it was a simple matter of me learning about ww2 from the History Channel instead of reading the assigned texts. the professor was right, i should have followed the course directions. as an undergrad, what basis did i have for substituting my own material? none. sorry to all the little \"Good Will Huntings\" out there, you are not a hidden genius who knows more than the person who has taught the material for decades....\n\n> Developing a strong argument is extremely similar\n\nright, except most undergrad humanities material focuses on a review of the body of knowledge, not developing new knowledge. no one in an undergrad psych degree program is expected to make new contributions to the field, but they are expected to know the existing body of work\n\ni think most humanities majors look back at their degree work with rose-colored glasses...conjuring up false memories of intellectuals sitting at a round table engaged in probing discussions....in reality they spent most of their time transcribing anything the professor said. ", "id": "d3fcq1i"}, {"comment": "[deleted]", "id": "d3ffwyo"}, {"comment": "and yet here I am with a phd", "id": "d3fk7eu"}, {"comment": "Because a lot of people get those degrees and they need someone to tell them they are useful.", "id": "d3fhz2k"}, {"comment": "I taught Literature for awhile and when performing critical analysis of texts, I never had any answers prepared in advance. In fact, I would assign books that I thought were interesting but puzzling because I knew that with a class working on them with me, I'd end up learning a lot more about them.", "id": "d3fc9d4"}], [{"comment": "I am a former English teacher turned programmer who has been working in the industry for about five years. \n\nI minored in Philosophy and in the study of philosophical texts, I practiced imagining things out to their logical conclusions. When Wittgenstein asks \"Can a baby lie?\" there are so many potential implications and subtleties in the question that it takes a degree of creativity to doggedly pursue a question like this as far as you can take it (sometimes for hundreds of pages of analysis). This kind of imaginative practice is a skill I use on a daily basis as a programmer. Indeed, it prepared me to be able to imagine many of the places where my applications can fail or to ask questions when speccing out new product features. However, I would never recommend this as a generic way to train developers.\n\nWhile I think there is a strong argument to be made about programming (engineering as well) as a creative endeavor, and I also think an argument may be made that studying the Humanities can foster creative thinking, I am unsure how universal it is that a humanities-based education would prepare someone for a career as a developer. It just happened to work for me.\n\nThe best I can say is that a specialized education is probably more limiting to someone's career options than being forced to study a broad array of different things. In other words, creative thinking and the ability to learn things independently trump all other skills. \n\nCan these two things be taught? If so, probably the best way to do so is to force someone to step out of a single area of specialization, to challenge themselves, and to take on different mental models and perspectives.", "id": "d3fcnhr"}, {"comment": "> I minored in Philosophy and in the study of philosophical texts, I practiced imagining things out to their logical conclusions. When Wittgenstein asks \"Can a baby lie?\" there are so many potential implications and subtleties in the question that it takes a degree of creativity to doggedly pursue a question like this as far as you can take\n\nYou are assuming that you \"learned\" creativity as part of your degree work. Maybe you are innately creative. Isn't it possible that a creative mindset is unteachable? We certainly don't have a surplus of creative thinkers in society, despite having a massive surplus of people whose degrees supposedly endow them with this skill. Indeed, if you look at many methods that are popularly employed to \"teach\" creativity, most have virtually nothing to do with tradition academic pursuits at all. I think in your quote above you were merely exceptionally diligent, which is nothing to sneeze at and a great life skill...but ants are also diligent.\n\nWith all due respect I think you are simply leaning on the *assumption* that the humanities magically grant creative and abstract abilities without any supporting argument. Isn't this the type of categorical assertion the article claims only afflicts lowly programmers?", "id": "d3fdwr8"}, {"comment": "I wrote the following:\n\n> I also think an argument may be made that studying the Humanities can foster creative thinking...\n\n\"Foster\" does not typically mean \"imbue\". \n\nIn addition, I used the phrase \"imaginative practice\" to describe studying Philosophy, (emphasis on the \"practice\").\n\nLastly, you seem to have missed the question I ended with: \"Can these things be taught?\" This is an open question, in my opinion.\n\nIn short, I do not hold the assumptions you appear to have found in my comments. Thus, I'm not sure what categorical assertions you are talking about.", "id": "d3feptm"}, {"comment": "But in fairness, you never explain why the humanities foster creativity thinking either....you present it as an assertion and proceed after a trivial qualification.", "id": "d3fk5gq"}], [{"comment": "So if humanities graduates are less like to engage in mechanical thinking and understand nuance, why do they cling to mechanical and un-nuanced ideas like the presumption that their degree makes them better qualified to work abstractly?\n\nSounds a lot like the dry, inflexible, categorical assertions they accuse computer science graduates of engaging....\n\nMaybe its just time to admit that this idea is something they heard a college recruiter or department head mention, and they've been repeating it without any supporting argument ever since....despite apparently having such a superior ability to reason abstractly and form an argument.", "id": "d3fdbfe"}], [{"comment": "If only I had a philosophy major, I would have understood pointers more easily, drats", "id": "d3f93pk"}, {"comment": "What is it about pointers that is hard to understand? I see it mentioned every now and then as 'confusing to beginners', but I can't say I understand how it could be seen as such. I'm asking as someone who's trying to get better at teaching others.", "id": "d3fa7kt"}, {"comment": "It was more of a joke that taking a philosophy major would be worth it to understand them easily. Maybe I would have saved 30 minutes or so.", "id": "d3faig6"}, {"comment": "He was joking. Pointers have nothing to do with philosophy. ", "id": "d3flfhb"}, {"comment": "Yeah, it was obvious that he was joking, but he could still have meant that the concept of pointers is difficult to understand.", "id": "d3g5k3g"}], [{"comment": "Code is never about aestethics, it's about solving a problem. If you read Virginia Woolf to write better code, you're not going to write very useful programs. The code is not the goal.", "id": "d3fi0mj"}], [{"comment": "in related reading, see the almost classic article by paul graham - [hackers and painters](http://www.paulgraham.com/hp.html)", "id": "d3f5oom"}, {"comment": "Also see the rebuttal, [Dabblers And Blowhards](http://idlewords.com/2005/04/dabblers_and_blowhards.htm) by another guy who paints and codes. ", "id": "d3fleb0"}, {"comment": "Further commentary on the matter: https://blog.carlmjohnson.net/post/2016-05-10-geek-sublime/", "id": "d3flvj9"}, {"comment": "Thank you!", "id": "d3fc8s0"}], [{"comment": "Link to original discussion: https://news.ycombinator.com/item?id=11746297", "id": "d3fjs2l"}], [{"comment": "lame!!", "id": "d3fa6a2"}]]], "4zj5km": ["MVVM is lipstick on a pig", "2016-08-25 19:46:31", 0, "https://sharpfivesoftware.com/2016/07/20/mvvm-is-lipstick-on-a-pig/", [[10, "The article fails to present a single coherent argument against MVVM.\n\nThe overall attitude seems to be \"I was told MVVM is a silver bullet for solving **everything**... but **it isn't**!\"."], [7, "> Once a fading pattern used in .NET client development\n\nI can't remember a time when MVVM was fading since I first heard of it. First it was growing because XAML apps were growing and then just as Silverlight was fading it was adopted by users of knockout.js then angular.js, etc."], [2, "Having dealt with MVC and MVVM architectures, I see quite often that the major stumbling blocks seem to come out of poor abstractions in the View layer, which in of itself seems to comes from code-reuse via inheritance. I never see inheritance with controllers, since there's nothing to be reused, as they represent the ever changing business logic. Models aren't supposed to contain code, so they tend to be safe.\n\nTo put it another way: don't inherit QWidget."], [2, "So MVVM is the lipstick, MVC is the pig and the \"better way\" is... MVC by default, but with \"clearly defined classes\" according to \"patterns that will reveal themselves\" (and exactly how UIKit/.NET/Rails/whatever-specific is this blog post aiming to be), because the VM is \"yet another class\"?\n\nFrankly, I'm not fond of either (though it may just be my distaste of WPF in particular talking) and I'm still unsure what this article adds to the conversation. My personal preference is Qt's MV(D?), but I've yet to see something that \"just makes sense\" for a wide variety of UIs."], [-1, "I'm not sure we are talking about the same thing. But I don't feel like MVVM would be bad. For example the GUI-building stuff in Angular.js is actually pretty nice, and it appears to be categorized to MVVM.\n\n\nBut then I have rip my hair at WPF too. It's just inconsistent and everything you don't want is easy but specifically what you want is difficult.\n\nUpdate: Nothing is documented anywhere. I cannot determine whether MVVM refers to what I think it does. Therefore you're right. MVVM sucks. It's the alias for GUI framework with \"there's no one correct way lets not document our internals\" -architecture.\n\n"]], [[{"comment": "The article fails to present a single coherent argument against MVVM.\n\nThe overall attitude seems to be \"I was told MVVM is a silver bullet for solving **everything**... but **it isn't**!\".", "id": "d6wm0zs"}, {"comment": "Yeah he also goes on to make supporting arguments of MVVM while not realizing it. For instance, being flexible to support changing business needs. That's one great thing about using an MVVM pattern because it further separates your model and view concerns - allowing you to quickly iterate on either or both. The decoupling also provides more modularity which helps keep your code clean and focused.", "id": "d6wre7p"}], [{"comment": "> Once a fading pattern used in .NET client development\n\nI can't remember a time when MVVM was fading since I first heard of it. First it was growing because XAML apps were growing and then just as Silverlight was fading it was adopted by users of knockout.js then angular.js, etc.", "id": "d6wlzcr"}], [{"comment": "Having dealt with MVC and MVVM architectures, I see quite often that the major stumbling blocks seem to come out of poor abstractions in the View layer, which in of itself seems to comes from code-reuse via inheritance. I never see inheritance with controllers, since there's nothing to be reused, as they represent the ever changing business logic. Models aren't supposed to contain code, so they tend to be safe.\n\nTo put it another way: don't inherit QWidget.", "id": "d6w7tmu"}, {"comment": "> [controllers] represent the ever changing business logic. Models aren't supposed to contain code\n\nIn principle, the models should contain the bulk of the code for business logic:\n\nhttps://en.wikipedia.org/wiki/Business_logic#Business_logic_and_tiers.2Flayers  \nhttp://stackoverflow.com/questions/4415904/business-logic-in-mvc  \nhttp://stackoverflow.com/questions/18563229/mvc-where-to-put-business-logic  \nhttp://programmers.stackexchange.com/questions/176639/why-put-the-business-logic-in-the-model-what-happens-when-i-have-multiple-types  \nhttp://programmers.stackexchange.com/questions/165444/where-to-put-business-logic-in-mvc-design\n\nThe fact this tends to not be the case with a typical desktop app simply reveals that what they implement can neither be called MVC nor MVVM. Now is that good or bad, I'll not take a side. But the constant complaints that .NET / OS X / iOS apps easily turn into a mess speak loud on their own.\n\nHeavy controllers can come from inexperience. Because the controller handles events coming from the view, the natural inclination of a beginner is to put all logic in event handlers, organically growing those poor controllers into shapeless, state-heavy monsters. The domain is never isolated, and so the domain becomes intertwined with display logic. I used to do that in Delphi in a previous life.\n\nAlso I never see it clearly articulated that MVC should be thought of more as... MMVC. There are always two distinct models in MVC-style architectures:\n\n- Domain models (they model the business logic).\n- View models (a view-specific model).\n\nDepending on the architecture, the view model may itself be mapping a domain model to a standard view-model interface for display purposes. In a slightly different factoring, the controller is the one building and updating the view-model, based on a domain model.\n\nBut long story short is, if the domain is not in a model on its own, you're setting yourself up for architectural trouble down the line.", "id": "d6wq8dy"}, {"comment": "It's really depends.  Following SOLID principals would tend towards an anemic domain model but allows for decoupling such that future introductions or changes are easy to implement. ", "id": "d6wr4g7"}, {"comment": ">  Following SOLID principals would tend towards an anemic domain model\n\nI don't see how that follows. A domain model has just one responsibility: model the domain. As with any other object in OOP, this doesn't mean only naked domain state, but also domain behavior.", "id": "d6wr67b"}, {"comment": "https://blog.inf.ed.ac.uk/sapm/2014/02/04/the-anaemic-domain-model-is-no-anti-pattern-its-a-solid-design/", "id": "d6wrafa"}, {"comment": "The blog author confuses his terminology a bit. What he calls his \"anemic domain models\" are in fact not models, but DTO, which indeed are disposable representations for input or output from the model. \n\nWhy aren't they domain models? Because they don't keep and maintain the actual canonical state of the *domain*. They're just snapshots of data that anyone can puppeteer and send around.\n\nThe model is therefore the service that takes and produces said DTO, and holds both the canonical domain *state*, and defines the canonical domain *behavior*. And it's anything bit anemic.\n\nHow you structure the domain is up to the specifics of the domain. But an \"anemic model\" would mean that I can take naked state, mutate it directly from a client's controller, and say \"this is now *the canonical state of this entity* at the domain\". And this means the business logic for mutating domain state is scattered around the client application. And this is why \"anemic model\" is frowned upon.", "id": "d6wrm7d"}], [{"comment": "So MVVM is the lipstick, MVC is the pig and the \"better way\" is... MVC by default, but with \"clearly defined classes\" according to \"patterns that will reveal themselves\" (and exactly how UIKit/.NET/Rails/whatever-specific is this blog post aiming to be), because the VM is \"yet another class\"?\n\nFrankly, I'm not fond of either (though it may just be my distaste of WPF in particular talking) and I'm still unsure what this article adds to the conversation. My personal preference is Qt's MV(D?), but I've yet to see something that \"just makes sense\" for a wide variety of UIs.", "id": "d6w9cwd"}], [{"comment": "I'm not sure we are talking about the same thing. But I don't feel like MVVM would be bad. For example the GUI-building stuff in Angular.js is actually pretty nice, and it appears to be categorized to MVVM.\n\n\nBut then I have rip my hair at WPF too. It's just inconsistent and everything you don't want is easy but specifically what you want is difficult.\n\nUpdate: Nothing is documented anywhere. I cannot determine whether MVVM refers to what I think it does. Therefore you're right. MVVM sucks. It's the alias for GUI framework with \"there's no one correct way lets not document our internals\" -architecture.\n\n", "id": "d6wbhdk"}]]], "41cyu5": ["Wolfenstein in 600 Lines of Code", "2016-01-17 13:16:15", 0, "http://hackaday.com/2016/01/15/wolfenstein-in-600-lines-of-code/", [[10, "Wellllllllllllllll, not exactly! Remember Windows 95 had a screensaver which did this kind of thing (without any interraction though)"], [4, "Wow, and it's not even written in Rust! \\s"]], [[{"comment": "Wellllllllllllllll, not exactly! Remember Windows 95 had a screensaver which did this kind of thing (without any interraction though)", "id": "cz1ejci"}], [{"comment": "Wow, and it's not even written in Rust! \\s", "id": "cz1iotp"}]]], "56yn1s": ["Proper Interview Prep -- Some Tips", "2016-10-11 19:44:23", 0, "https://www.lucidchart.com/techblog/2016/10/11/acing-the-engineering-interview-proper-preparation/", [[8, "I've got to disagree about the GPA. I'm almost 40.... putting my GPA on my resume seems silly considering I've got 2 decades of experience to talk about."], [8, "I swear some people just write because they have a bloody target or something. That article was about as refreshing and useful as a bucket of codswallop."], [5, "TL;DR: Come prepared"], [5, "I don't downvote often, but this is just a completely hollow article that is probably more of an advertisement than anything.\n"]], [[{"comment": "I've got to disagree about the GPA. I'm almost 40.... putting my GPA on my resume seems silly considering I've got 2 decades of experience to talk about.", "id": "d8nh1rf"}, {"comment": "We are in the height of student recruiting season at Lucid and the majority of interviews happening right now are students.  The point about GPA is, as you suggest, more relevant to students than someone with 20 years experience.  When a student doesn't have a GPA on their resume, our experience has been that is for good reason-- we assume a low GPA when GPA is absent on a student resume.", "id": "d8nhqq8"}, {"comment": "Do you have any data on how well GPA predicts performance?  I ask because [Google](https://www.linkedin.com/pulse/20130620142512-35894743-on-gpas-and-brain-teasers-new-insights-from-google-on-recruiting-and-hiring) doesn't seem to think they predict anything well.", "id": "d8nkon0"}, {"comment": "How come even your senior engineering positions that require 3+ years of experience also want a 3.7+ gpa? Seems like it's considered relevant no matter how much experience ", "id": "d8nofu1"}], [{"comment": "I swear some people just write because they have a bloody target or something. That article was about as refreshing and useful as a bucket of codswallop.", "id": "d8nhqc2"}, {"comment": "Yeah, seriously. This article is just a redundant, lower quality version of all the existing articles. Just adding more noise for company exposure.", "id": "d8nmj5m"}], [{"comment": "TL;DR: Come prepared", "id": "d8ngw5n"}, {"comment": "But remember to read their book! =/", "id": "d8nh4nc"}, {"comment": "Their book? They recommended ctci, which is a very famous book that has nothing to do with lucid ", "id": "d8nmqqq"}], [{"comment": "I don't downvote often, but this is just a completely hollow article that is probably more of an advertisement than anything.\n", "id": "d8nr1ex"}]]], "4yix1v": ["There are 31 Of The Best Kept Secrets Of Great Programmers", "2016-08-19 17:29:39", 0, "https://medium.com/@arpingajjar/there-are-31-of-the-best-kept-secrets-of-great-programmers-a182c6b95425", [[5, "Some generally good advice in here, despite the clickbait title and it being hosted on medium."], [2, "The single best kept secret of great programmers is still secret."]], [[{"comment": "Some generally good advice in here, despite the clickbait title and it being hosted on medium.", "id": "d6o1obh"}, {"comment": "Y, I have to agree, although they're not secrets and they're a hodge-podge.", "id": "d6o3riq"}, {"comment": "Ditto, I was pleasantly surprised.", "id": "d6o51rm"}, {"comment": "Turns out, this is an answer from Quora https://www.quora.com/What-are-the-best-kept-secrets-of-great-programmers?ref=inc&rel_pos=1#!n=12", "id": "d6t4lhw"}, {"comment": "Wow, Arpin Gajjar is a scumbag. I guess the headline on [his profile](https://medium.com/@arpingajjar) should have been a clue:\n\n> @AdWords & @Analytics Certified Professional\n\nGot anything to say /u/arpin22 ?", "id": "d6t6uq7"}, {"comment": "So what [/u/avindra](https://www.reddit.com/u/avindra). I am a IT Engineer. It's my achievement. I think you are scumbag here to take down people. Don't you.", "id": "d6ucz5d"}, {"comment": "I fail to see how taking other people's work and not giving them any credit for it is an \"achievement.\" Perhaps you can enlighten me", "id": "d6ulyia"}, {"comment": "FYI i have already added courtesy at bottom of my article. Even you read article carefully? Looks like Beggars are here. Hi 5", "id": "d6us7yn"}], [{"comment": "The single best kept secret of great programmers is still secret.", "id": "d6oafa3"}, {"comment": "Like what?", "id": "d6rhl9l"}]]], "47dhef": ["The Fall of the House of Node", "2016-02-24 19:43:55", 3, "https://medium.com/javascript-non-grata/the-fall-of-the-house-of-node-43697fd56a6", [[22, "> ...They need to be written in powerful languages that afford you solid engineering capabilities, such as sophisticated debugging and testing, and economical maintainability (i.e., producing a code base imbued with clarity and readability and the ability to reason easily). Does that sound like JavaScript or the Go language?\n\nNeither? ;)"], [13, "TJ's 'announcement' was from 2014 and Node's house hasn't collapsed yet."], [7, "Since JS is by far and away the most ubiquitous language in use, I doubt Node is disappearing any time soon.  People have been saying C outlived it's usefulness for 30 years (at least), and people still write brand new code in C.\n"], [4, "Yeah ok maybe you're right but this is a very weak article providing no real evidence or comparison with other languages, rehashing a debate that has been going on since node came out and your argument seems to boil down to Go is better than node because TJ says so but he was talking about distributed systems. Also the 'debugging is hell' article is out of date - ES6 has a solution for callback hell and the whole debate over the ecosystem seems to have been solved after the io.js debacle was resolved.\n\nYou also cannot claim that node is purely driven by front end developers I know back end devs who have switched to it from other server side languages."], [3, ">Whatever happened to the axiom, \u201cUse the best tool for the job\u201d? JavaScript on the server side is NEVER the best tool for the job. The only reason people cite for using JS is that it saves them the effort of learning another language. Wow, how lazy can you be?!\n\nAnother big reason, sharing code between the frontend and the backend. Also, there are plenty of sane languages that compile to Js nowadays, so it's not like you can't use a better language on top of Node. For example, [core.async](http://www.braveclojure.com/core-async/) in Clojure provides very similar semantics to Go.\n\nIn my current project, we're seeing a lot of value using Clojure with ClojureScript in our app. We can share all the validation logic, report generation and so on. Had we used two separate languages, then we'd have to duplicate that with the potential for discrepancies and errors along the way.\n\nJs runtime is pretty ubiquitous, and now with React Native, you can even target mobile with the same language. Again, any language that compiles to Js gets the benefits.\n\nI think there's also value in having a single language in your codebase. Yes, you can learn and use different languages, but you certainly end up with more mental overhead, and lots of edge cases translating data between them."], [3, "I have to agree with this sentiment. I can't think of a good reason to bother trying to build server-side application code in JS. There's a half-dozen better alternatives with robust frameworks intact and ready to go. \n\nNoobs should be warned: Node is fun, but it ain't ready for prime time applications development, and probably never will be."], [4, "> The only reason people cite for using JS is that it saves them the effort of learning another language. Wow, how lazy can you be?!\n\nAnd once they lit that strawman on fire, I stopped reading.  \n"], [4, "Node will always be useful...\n\n...for build tooling."], [2, "This \"post\" is just a copy pasta of two other peoples articles with some snark added."], [1, "[deleted]"], [1, "If you're new product you're trying to reach product market fit in as short a period of time as possible. This means getting code out the door quickly and iterating as needed. When this happens you're perfectly happy to sacrifice long term maintainability and performance. \n\nNode on the backend excels at this."], [1, "well that was a shitty read\n\nSomeone writes something of value\n\nthis guy goes \"HEY EVERYONE LOOK AT WHAT THAT GUY SAID, ITS SO TRUE! FUCK JAVASCRIPT ITS SO BAD GO DIAF IF U USE IT\"\n\ngood contribution @richardeng, good contribution"], [1, "Just the usual rant ...\n\nI used nearly all maintream languages in the last decade, and I currently really enjoy node due to being really productive with it. However I'm not using JS directly but Typescript (which even has a much better type system than Go - and a REAL debugger ;))"], [0, "I hate these type of trash posts. It hasn't fallen. Actually there are things in the roadmap that TJ complained about that the TSC is pushing forward on like better error handling, debugging, etc.\n\nSource: I'm friends with someone on the Node.js TSC."], [-5, "> JavaScript on the server side is NEVER the best tool for the job.\n\nSheesh. Why did we have to repeat that for 5+ years for someone to finally start listening?"]], [[{"comment": "> ...They need to be written in powerful languages that afford you solid engineering capabilities, such as sophisticated debugging and testing, and economical maintainability (i.e., producing a code base imbued with clarity and readability and the ability to reason easily). Does that sound like JavaScript or the Go language?\n\nNeither? ;)", "id": "d0c4sfo"}, {"comment": "I agree.\n\nI like using Go but it has its fair share of problems and feels like a toy language. Debugging Go programs is a terrible experience and I would hardly turn to Go for 'solid engineering capabilities'. Also readability and maintainability can be hurt by insane error handling and code duplication due to lack of generics.", "id": "d0c5aew"}, {"comment": "Strange that so many of the [world's top tech companies](https://github.com/golang/go/wiki/GoUsers) are turning to Go to solve their engineering problems.", "id": "d0c7b03"}, {"comment": "Hype (especially from a company like Google) is a helluva drug.", "id": "d0c8g3j"}, {"comment": "Hype is a real thing, but a lot of these companies are a bit more pragmatic when it comes to their time, money, performance, and resources, and they have guru level engineers making infrastructure decisions.\n\n", "id": "d0c93y2"}, {"comment": "Is not clear what kind of software most of them are writing with it, maybe some small internal tools or big stuff?", "id": "d0ca9qb"}, {"comment": "From what I've read, and from my own experience, Go is being mostly used to fill in the cracks. It's the duct tape of languages. It's a good choice when you need a fast and reliable daemon, microservice, or networking utility. The kind of app you install and forget about, and it just does its job. Like memcached for example. It's kind of an unglamorous language, which has very few tools in the way of build systems, package management, deployment systems, etc, because it _doesn't need them_.\n\nI think it actually is a \"solid engineering\" language, because you spend more time fixing problems than dicking around with frameworks and crazy tooling, and writing error free code is surprisingly easy. Must be all that \"error handling\" some developers complain about.", "id": "d0cbe18"}, {"comment": ">  small internal tools or big stuff?\n\nSeems like a pretty extreme dichotomy...\n\n   * By \"big stuff\" - do you mean some corporate monster with 200+ people on the project, an entire OS, Microsoft Office, etc?   Or maybe 5-10 people, and maybe 250,000 - 1m lines of code?\n   * How about medium-sized applications?  Maybe an ETL layer or adapter to help get data for product x into hadoop?\n   * Can there be small, external tools?", "id": "d0cn6gy"}, {"comment": "Let's rephrase the question to see if it appears to you less ambiguous: What relevance has Go in those companies and how is being used relative to the length of the list?", "id": "d0cojlq"}, {"comment": "That's a giant list of companies/groups that have used go for something. It isn't exclusively \"the world's top tech companies\" and it also largely isn't projects that are solving important engineering problems for these companies.\n\nNetflix, for example, is listed by one open source project with this as the beginning of the Readme: \"Note: This is an early stage project under active development. It is not yet in widespread use in Netflix. It is going to change quite a bit from the current state before it is ready. Consider it pre-alpha.\"\n\nThe New Relic listing is a HN job posting with this in the description: \"Stack: NodeJS, React, and Java. And there's room to mix things up on the data ingest side (Golang welcome)!\"\n\nI'm sure there are plenty of legitimate listings in there (SendGrid, for example, claims to be moving everything over) but largely this list is the output of a giant hype circlejerk.", "id": "d0cf03y"}, {"comment": "I'm confident a list doesn't exist that couldn't be torn apart by a programmer who's looking to validate their existing ideas.\n\nIf companies like Google, Facebook, Basecamp, CloudFlare, Comcast, Docker, GitHub, IBM, YouTube, SpaceX, and yes, even Netflix, are not top tech companies in your book, I'm not going to argue. You're clearly seeing what you want to see.\n\nI'm also not sure how you concluded these companies aren't, \"solving important engineering problems\", after what I'm sure was a 5-10 minute cursory glance at the list. Everything Basecamp is using Go for solves engineering problems. Part of the SpaceX telemetry system is written in Go. If you have awfully high standards if you don't think that's solving engineering problems.\n\nSome of the credit given to Go on the list is a bit flakey, e.g. some are just client libraries written in Go, but most of them aren't. There are a lot of companies on that list solving real problems, and very often they're ditching their prefered language for Go. ", "id": "d0cir6o"}, {"comment": "> If companies like Google, Facebook, Basecamp, CloudFlare, Comcast, Docker, GitHub, IBM, YouTube, SpaceX, and yes, even Netflix, are not top tech companies in your book, I'm not going to argue.\n\nThat's a fantastic dismissal of an argument I never made. Good job! For bonus points you even managed to ignore my dispute of how Netflix \"qualified\" for that list.\n\n> I'm also not sure how you concluded these companies aren't, \"solving important engineering problems\", after what I'm sure was a 5-10 minute cursory glance at the list.\n\nIt looks like we both went through the list and cherry picked some examples. I did it specifically to highlight the essential problem with these kinds of lists. You seem to be doing it in defense of accusations I wasn't making.\n\nIn what world do an experimental prototype and a job posting that lists Go as a nice-to-have qualify as \"solving important engineering problems\"? I'm not attacking Go here, just pointing out that the list you're citing and the claims you're making against it don't quite line up. You'd probably have been better off going through the list yourself and picking out some of the better examples instead of trying to wow us with a big list.", "id": "d0ckvj9"}, {"comment": "> That's a fantastic dismissal of an argument I never made.\n\nSo kinda like how I said, \"**so many** of the world's top tech companies\", and you followed that up by saying, \"It **isn't exclusively** the world's top tech companies\". Just so we're clear, is that the kind of dismissal of arguments that were never made that you're talking about?\n\n> For bonus points you even managed to ignore my dispute of how Netflix \"qualified\" for that list.\n\nIt was a lame point, and you know it. Their use is bad because you say it's bad. What is there to dispute? Okay, I disagree with you. Happy?\n\n>  I did it specifically to highlight the essential problem with these kinds of lists\n\nOh, you've got an excuse for your bias. How cute. Hey everybody, he's got an excuse, so it doesn't count.\n\n> In what world do an experimental prototype and a job posting that lists Go as a nice-to-have qualify as \"solving important engineering problems\"? \n\nDude, your follow up to an argument against cherry picking and ignoring disputes is to ignore disputes and cherry pick some more? I dunno, in what way is using the language for rocket telemetry not important engineering? Are we just going to go back and forth where you ignore everything I said, and then accuse me of ignoring everything you said?\n\n> You'd probably have been better off going through the list yourself and picking out some of the better examples instead of trying to wow us with a big list.\n\nOh, I probably should have said something like, \"Everything Basecamp is using Go for solves engineering problems. Part of the SpaceX telemetry system is written in Go.\" Examples like that probably would have helped my argument. I'll keep that in mind.", "id": "d0clknq"}, {"comment": "...what argument were you making again? That the world's top tech companies are solving real world engineering problems with Go? Yet somehow a laundry list of companies that have uttered anything about the language is \"good evidence\" for that argument?\n\n\"Hey, go look through this giant list for something that kinda maybe supports my point\" isn't really making your point. It's odd that you can find so much time to defend yourself against someone calling you out on that, but couldn't have found the time to just come up with some concrete examples in the first place.\n\nBut please, do continue to assume that you're perfect, I'm an idiot, and there's absolutely nothing of value you could take from this experience. I'm sure that will assist you in your future attempts at Go advocacy.", "id": "d0cm9lj"}, {"comment": "Jesus, you're an idiot.", "id": "d0cmlul"}, {"comment": "> But please, do continue to assume that you're perfect, I'm an idiot, and there's absolutely nothing of value you could take from this experience.\n\nWell, glad you listened to something I said...", "id": "d0cn6po"}, {"comment": "Strange that you don't address the issues I raised. Or these: http://nomad.so/2015/03/why-gos-design-is-a-disservice-to-intelligent-programmers/", "id": "d0chzl0"}, {"comment": "I have. Further along in this thread, but it's not like you made a point which can be addressed.\n\n>  http://nomad.so/2015/03/why-gos-design-is-a-disservice-to-intelligent-programmers/\n\nWhy would I have addressed problems in an article you're just now showing me?", "id": "d0cj2ns"}, {"comment": "Ha. That bothered me too. In the intro he mentioned a node guru jumping ship to Go. The implication being that we should follow him, but then coming to the end of the article it turns that Go is not very good either. So what gives? Come on op you can't just leave us hanging dry out here.", "id": "d0c5gmh"}, {"comment": "TJ has gone back to Node since he wrote that article over a year ago.", "id": "d0c6pxu"}, {"comment": "Source? He recently released APEX that allows you to run Go on AWS Lambda. (https://medium.com/@tjholowaychuk/introducing-apex-800824ffaa70#.vahemy2xt) Yes it's written in JS, but it suggests he needed it for his Go programs. :)", "id": "d0c6v2d"}, {"comment": "I didn't say he didn't still write Go. He's just active in both communities. Which is good, we need less tribalism.", "id": "d0c77dg"}, {"comment": "I'm confused, that's exactly what TJ's 'Farewell Node' post said originally. 'Gone back' suggests something entirely different.", "id": "d0c84ml"}, {"comment": "This is correct. TJ made an exception for web stuff when he 'left' Node.\n\nStill, at the very end of TJ's post, he says this:\n\n> Moral of the story, don\u2019t get stuck in your own bubble! See what else is out there, you just might enjoy programming again. There are a lot of awesome solutions out there, my mistake was waiting too long to play around with them!\n\nQuoting him in an article that basically boils down to \"Node is trash for front-end developers who are too lazy to learn a real language\" seems to be a bit far from the spirit of TJ's post. Maybe if the author had actually given Node a chance he would have realized that it's not as terrible as he imagined it to be, and that Node actually has its own merits aside from using the same language as the browser.", "id": "d0cnjtz"}], [{"comment": "TJ's 'announcement' was from 2014 and Node's house hasn't collapsed yet.", "id": "d0c621q"}, {"comment": "Yeah, he's since come back to Node and written [an even more minimalist web framework](http://koajs.com/), and Node is getting even more popular. So the first sentence is basically wrong.", "id": "d0c6o10"}, {"comment": "Why do you keep saying stuff like this? His Farewell Node.js post specifically mentions Koa.js as the one Node thing he's continuing to working on. Makes me think you haven't actually read what you're talking about.", "id": "d0c878m"}, {"comment": "It's been a pretty long time since I last read it, let me take a look...\n\nYeah that sounds about right. I'm still not entirely sure why the article even quoted him though, besides being able to point a finger and go \"*See! This guy was a big Node guy and now he uses something else! Node must be bad!*\" There's plenty of people who have switched *to* Node from other platforms (including myself) because they found it to be a much better experience, but at best it's anecdotal either way.", "id": "d0cnhz9"}], [{"comment": "Since JS is by far and away the most ubiquitous language in use, I doubt Node is disappearing any time soon.  People have been saying C outlived it's usefulness for 30 years (at least), and people still write brand new code in C.\n", "id": "d0c4urq"}, {"comment": "Because in the areas where C/C++ is mostly used, it's still the best available tool (graphics programming, operating systems)\n", "id": "d0c6awt"}], [{"comment": "Yeah ok maybe you're right but this is a very weak article providing no real evidence or comparison with other languages, rehashing a debate that has been going on since node came out and your argument seems to boil down to Go is better than node because TJ says so but he was talking about distributed systems. Also the 'debugging is hell' article is out of date - ES6 has a solution for callback hell and the whole debate over the ecosystem seems to have been solved after the io.js debacle was resolved.\n\nYou also cannot claim that node is purely driven by front end developers I know back end devs who have switched to it from other server side languages.", "id": "d0c98rf"}], [{"comment": ">Whatever happened to the axiom, \u201cUse the best tool for the job\u201d? JavaScript on the server side is NEVER the best tool for the job. The only reason people cite for using JS is that it saves them the effort of learning another language. Wow, how lazy can you be?!\n\nAnother big reason, sharing code between the frontend and the backend. Also, there are plenty of sane languages that compile to Js nowadays, so it's not like you can't use a better language on top of Node. For example, [core.async](http://www.braveclojure.com/core-async/) in Clojure provides very similar semantics to Go.\n\nIn my current project, we're seeing a lot of value using Clojure with ClojureScript in our app. We can share all the validation logic, report generation and so on. Had we used two separate languages, then we'd have to duplicate that with the potential for discrepancies and errors along the way.\n\nJs runtime is pretty ubiquitous, and now with React Native, you can even target mobile with the same language. Again, any language that compiles to Js gets the benefits.\n\nI think there's also value in having a single language in your codebase. Yes, you can learn and use different languages, but you certainly end up with more mental overhead, and lots of edge cases translating data between them.", "id": "d0c4ydc"}, {"comment": "> sharing code between the frontend and the backend\n\nThis shouldn't always be said as if the benefits are indisputable. Sharing code across application boundaries isn't always a good thing, and it can be an especially bad choice as your infrastructure grows, and you have a ton of micro-services and front ends which are tightly coupled due to shared code.\n\nThe benefits you gain from breaking everything up into APIs and client side controllers goes out the window when you start sharing code between them.", "id": "d0c89l8"}, {"comment": "That has nothing to do with code sharing, but with how you design your apps. Most of our code is written as libraries that get included in frontend and backend projects. There's absolutely no coupling going on there.", "id": "d0camk9"}, {"comment": "You're coupling, and you don't even know it. How many of your services now _have_ to be written in Javascript because the library the whole company uses is written in Javascript?\n\nHere's a good talk from a Netflix engineer on the dangers of shared code. It's worth a watch.\n\nhttp://www.microservices.com/ben-christensen-do-not-build-a-distributed-monolith", "id": "d0cbld3"}, {"comment": "First of all we're using Clojure and ClojureScript, but picking a particular platform to work with is not really my definition of coupling anything. Also, if you are building things as services, then you can start making new services in whatever you like. Naturally, there would have to be incentive to do that though.", "id": "d0cct5w"}, {"comment": "> you can start making new services in whatever you like\n\nClojure isn't always going to be the best tool for the job, but you're going to end up using it anyway, because you've already invested time and energy into creating libraries written in Clojure.\n\nI'm sure you're not in a position to watch the video at the moment, or have the inclination (because I probably wouldn't) so I'll reproduce some of the transcript here, which speaks directly to your design choices.\n\n> So for example, if you\u2019re in the Java world and you adopted Tomcat years ago and it made sense then, but you want to adopt Netty now, can you actually do so without upgrading the entire company at once? Or can you just simply upgrade to the newest version of Guava because you want to use some new functionality in it, but you can\u2019t because **some core central platform is transitably holding you to three versions ago. But isn\u2019t shared code the right thing to do?** This is what we\u2019ve been taught from our earliest times learning how to write code.\n\n> And I want to argue that it\u2019s not always actually the right thing or the best thing to do. And it\u2019s because **it\u2019s not necessarily the right principle to prioritize when we\u2019re talking about distributed systems**. So I\u2019m going to go to an authority other than me. \u201cBuilding Microservices\u201d is a book by Sam Newman. He\u2019s got a few great quotes on this. So first of all you lose true technology heterogeneity. **And so this is about if I\u2019m taking all my business logic or the particular domain of how something should work and I\u2019m putting it in shared code, then the only way for anybody to actually access that is by running the exact same technology stack so that they can use that shared code**.\n\n> Well, one of the reasons why we actually do microservice architecture is so that we can avoid coupling the producer, the service, from the consumers, so that when one changes the other ones don\u2019t all have to change. **And if we favor the DRY principle, we can start to break this very benefit of microservices.** This is an important statement. So if your use of shared code ever leaks outside of your service boundary of introduce coupling. So shared code, in and of itself, is not problematic when you\u2019re using it inside for your implementation.\n\n> But as soon as it starts to leak across your network boundaries and across your service boundaries, that\u2019s when it starts to become a problem, when it couples those systems together. **And I agree with this statement that the evils of too much coupling between services are far worse than that caused by code duplication.**\n\n> Another one is the ability to deploy changes in isolation. So if I\u2019ve got my business logic sitting in a shared library, and I have a bug or I need to put new behavior into it, and that requires me getting 10 other teams to set my change and then deploy, I\u2019m not doing a microservice architecture. That\u2019s a distributed monolith and I\u2019m having to synchronize the deployments of everybody to get my change out. And then this one actually hit me close, is that **once you start having shared code as the thing that propagates behavior, the seams in your system are really difficult to tackle.**\n\n> You can do it all in the name of performance and just ignore, actually fixing my networking libraries, and just say that I can shave off some time here or it\u2019s just easier to make a conditional check in the client. And all of a sudden, I\u2019m starting to actually run a lot of my service in the client. This then leads to the fact that it basically **becomes impossible to adopt any new architectures and languages because the entire system is tightly coupled through these formal client libraries that have already made the decision** of what the architecture and language and tech stack is, and I have to use them.\n\n> **And so if I ever want to adopt anything new, I actually have to figure out what to do with the dozens of clients that are all based upon a decision years ago.** And these ultimately lead to pretty far reaching effects over time. So for one thing, the consuming team is now at the mercy of the service owner. Whatever the service owner chooses to do, whatever code they choose to put in their client, whatever their deployment cycle is, or whenever they need to fix a bug, the consuming team basically has no choice except to accept what they give.", "id": "d0cg7ry"}, {"comment": ">Clojure isn't always going to be the best tool for the job, but you're going to end up using it anyway, because you've already invested time and energy into creating libraries written in Clojure.\n\nI don't think you understand how hosted languages work. The whole point with Clojure is that it provides interop with the host platform. I can easily expose Clojure libraries to any language that runs on the same platform. The JVM and Js runtimes are some of the most ubiquitous platforms out there. I highly doubt we're painting ourselves into some sort of a corner targeting them.\n\nFurthermore, this is a problem for any language you pick. Except, when you pick languages that can target less runtimes you're limiting yourself further.\n\nFrankly, I think this argument is completely inane. The fact of the matter is that once you have a large enough platform, then you're necessarily going to be tied to it. Has nothing to do with the fact that language targets multiple runtimes. The effort you put into developing the functionality is what's keeping you there.\n\nSpending more effort creating these same libraries in two separate languages buys you absolutely nothing.\n\nOnce again, there's no actual coupling going on between the services themselves. They simply leverage the libraries you wrote. Libraries that you would've had to write regardless of what language you picked. Libraries you would've had to write **twice**, had you picked two separate languages for front and back.\n\nThe whole talk is about how you architect your project and using the same language to target the frontend and the backend is a huge red herring there.\n", "id": "d0ch9y0"}, {"comment": "This seems like a good place to mention [Links](http://groups.inf.ed.ac.uk/links/): a single language that compiles to client-side, server-side, *and* database-side (is that a thing?) code, so you can more-or-less pretend it's all running as a single process. You can annotate functions as server-side or client-side, in which case passing control between the different \"locations\" is as simple as any other function call; or you can write \"non-located\" functions, which can run in the browser if that's where their caller's running, and on the server likewise.\n\nI get the impression it's more of a research project / academic curiosity than something to use in production, but I love it for the sheer boldness of vision. It's a beautiful goal to strive for.", "id": "d0c615j"}, {"comment": "You make a half-valid point about code sharing. However, it's six of one and half a dozen of the other. What you gain from avoiding \"duplication\", you lose in terms of server-side robustness and power (from using a much more powerful language). Software engineering is all about trade-offs; no solution is perfect. On the server side, I'd rather use something that let's me write industrial strength software, for example, Go or C# or Java or Scala.", "id": "d0c8k4x"}, {"comment": ">What you gain from avoiding \"duplication\", you lose in terms of server-side robustness and power (from using a much more powerful language).\n\nI wasn't talking about Node specifically there. As I clearly stated, my team uses Clojure that runs on the JVM on the server. The JVM is one of the most robust platforms out there, and has much better tooling than Node or Go. So, I don't have to sacrifice \"industrial strength\" or language power to get the benefits of running the same code on the client and the server.", "id": "d0cajlz"}, {"comment": "Go itself compiles to JS", "id": "d0c8wsf"}, {"comment": "[deleted]", "id": "d0ccd35"}, {"comment": "I've heard good things in a few places. I was surprised by the positive feedback; I figured compiling Go down to JS (particularly a language with concurrency semantics) would be even less pleasant than JS. But I don't recall hearing about its use in any major projects.", "id": "d0ckbn2"}], [{"comment": "I have to agree with this sentiment. I can't think of a good reason to bother trying to build server-side application code in JS. There's a half-dozen better alternatives with robust frameworks intact and ready to go. \n\nNoobs should be warned: Node is fun, but it ain't ready for prime time applications development, and probably never will be.", "id": "d0c6d5w"}, {"comment": "It\u2019s used in a large number of \u2018prime time applications\u2019. It\u2019s certainly got its problems, but let\u2019s not get silly.", "id": "d0cha1i"}], [{"comment": "> The only reason people cite for using JS is that it saves them the effort of learning another language. Wow, how lazy can you be?!\n\nAnd once they lit that strawman on fire, I stopped reading.  \n", "id": "d0c9dzo"}], [{"comment": "Node will always be useful...\n\n...for build tooling.", "id": "d0c4n86"}, {"comment": "...which go out of date like milk.", "id": "d0c50yb"}, {"comment": "You mean for ~~bower~~, ~~grunt~~, ~~gulp~~, ~~webpack~~, system.js? I'd rather not rewrite my build scripts every 5 minutes.", "id": "d0c5haa"}, {"comment": "As long as browsers use Javascript, you can bet the next big build tool will still run on Node.", "id": "d0c5ind"}, {"comment": "Most of the non-JS world has been using the same build tools for years, and actual new entrants that gain popularity are fairly few.", "id": "d0canab"}, {"comment": "It's simply a matter of using a high abstraction to agnostically write build scripts that are compiled to the flavour of the week build library.  ", "id": "d0c8z29"}, {"comment": "Ah yes, all we need is autotools for Node. ", "id": "d0c9sm5"}, {"comment": "[It seems that the sane few of us are indeed very few.](https://www.reddit.com/r/elixir/comments/471rc2/programming_phoenix_step_1_erlang_step_2_elixir/)", "id": "d0c74p7"}, {"comment": "man you were unreasonably mad lol", "id": "d0c99hi"}, {"comment": "I wouldn't be upset that I needed Node. I'd be upset that I needed Brunch. I find Gulp better. ", "id": "d0ccu1s"}, {"comment": "Why would you link to that? How can you possibly be proud of behaviour like that, Node issues aside?", "id": "d0cd6gn"}, {"comment": "...which in many times is subpar.", "id": "d0can3q"}], [{"comment": "This \"post\" is just a copy pasta of two other peoples articles with some snark added.", "id": "d0c6iwc"}], [{"comment": "[deleted]", "id": "d0c7cxe"}, {"comment": "you didn't think es6 was an improvement?", "id": "d0c9bdc"}, {"comment": "[deleted]", "id": "d0cad9h"}, {"comment": "Arrow functions", "id": "d0cda95"}, {"comment": "[deleted]", "id": "d0cdiyv"}, {"comment": "I don't use `this` or classes either, but they're still a small readability win in some situations.", "id": "d0cnt2g"}, {"comment": "[deleted]", "id": "d0co8bu"}, {"comment": "Here's an example from some code I'm working on: http://imgur.com/i94AjXa\n\nFor the last two anonymous functions I'd say it's about the readability is about the same, but for the first two I find the arrow version much easier to read. The `function` keyword can blend in due to it being on the left, so they almost ready like `Promise(function` and `net.createServer(function`. With the arrows it's clear as soon as you hit the opening paren that it's an anonymous function, and the arrow is always right next to it to reinforce it.\n\nObviously none of this is objective in the least so your mileage may vary.", "id": "d0cqw4h"}, {"comment": "Don't take it bad and you are free to see me as a dick if you want to. But I am sorry that you have to waste energy on typing such irrelevancy. If we are talking about \"readability\" I would argue that `function` is orders of magnitude more readable than `()=>` to newcomers, of course once you know what the notation do, is more **convenient to type** but typing is not the problem (my IDE does that job for me). At the end of the day comes down to preference and is not worth discussing it (at least for me). Hell there wouldn't be need of an \"arrow function\" on the first place if JS wasn't such crap, and at that point revolves my rationale.\n", "id": "d0crf85"}, {"comment": "Oh, I don't care about typing at all, I only care about how the code reads. I don't know about newcomers, but I'd imagine it's not a huge difficulty to learn to read arrow functions.\n\nI still like the idea of there being a lightweight function literal syntax in addition to the heavier `function` keyword, like in other scripting languages (`lambda` in Python and blocks in Ruby come to mind).\n\nIf you view arrow functions as just a fix for `this` not playing well with callbacks (better solution would have been to never have weird, pseudo-Java object oriented stuff in the first place) then I understand why you would see it as a hack on top of a hack, since it is also that.", "id": "d0ctrsp"}, {"comment": "There are lots of great languages that compile to Js nowadays. I see it more as a compile target than anything else.", "id": "d0caouf"}, {"comment": "[deleted]", "id": "d0eufyd"}, {"comment": "Right, but you don't have to work with Js to develop web apps nowadays. My team has been working with ClojureScript exclusively for the past year, and we're very happy. The fact that the app compiles to Js is completely incidental to us. ClojureScript isn't just syntax sugar on top Js, it has its own language semantics and the fact that it compiles to Js is incidental to how it works. Until something like WebAssembly becomes standard, compiling to Js is the best option.", "id": "d0ex2cq"}], [{"comment": "If you're new product you're trying to reach product market fit in as short a period of time as possible. This means getting code out the door quickly and iterating as needed. When this happens you're perfectly happy to sacrifice long term maintainability and performance. \n\nNode on the backend excels at this.", "id": "d0c72s5"}], [{"comment": "well that was a shitty read\n\nSomeone writes something of value\n\nthis guy goes \"HEY EVERYONE LOOK AT WHAT THAT GUY SAID, ITS SO TRUE! FUCK JAVASCRIPT ITS SO BAD GO DIAF IF U USE IT\"\n\ngood contribution @richardeng, good contribution", "id": "d0c8ixw"}], [{"comment": "Just the usual rant ...\n\nI used nearly all maintream languages in the last decade, and I currently really enjoy node due to being really productive with it. However I'm not using JS directly but Typescript (which even has a much better type system than Go - and a REAL debugger ;))", "id": "d0ccczv"}], [{"comment": "I hate these type of trash posts. It hasn't fallen. Actually there are things in the roadmap that TJ complained about that the TSC is pushing forward on like better error handling, debugging, etc.\n\nSource: I'm friends with someone on the Node.js TSC.", "id": "d0d0c1s"}], [{"comment": "> JavaScript on the server side is NEVER the best tool for the job.\n\nSheesh. Why did we have to repeat that for 5+ years for someone to finally start listening?", "id": "d0c63pu"}, {"comment": "Because it's not true?\n\nAt least in the days of PHP there were few good alternatives; today almost every language is trying to sell itself as a server-side language and Node is still winning. Have you ever considered that maybe people are still using it because it works well?\n\nHaving gone from hating Node and JavaScript to them being my favourite platform, you guys really need to give stuff a try before proclaiming that it's \"*NEVER the best tool for the job*\". You might be surprised.", "id": "d0c6kom"}]]], "4x1lmr": ["Why Most Programmers Get Pagination Wrong", "2016-08-10 15:04:12", 4, "https://blog.jooq.org/2016/08/10/why-most-programmers-get-pagination-wrong/", [[15, "> Moreover, I never ever ever want to jump to page 317 right from the beginning. There\u2019s absolutely no use case out there, where I search for something, and then I say, hey, I believe my search result will be item #3175 in the current sort order\n\nSorry, but that's wrong. It's super important to be able to see how many pages there are and being able to jump because you want to be able to do trivial binary searches when the filtering isn't up to snuff (which is surprisingly often!) or where you want to find where in the result some thing changes. Those are from the top of my head. There are probably more. \n\nThings programmers (the author) get wrong about pagination: assuming you know the use case. "], [7, "Hum the Oracle license forbids benchmarking? \n\nIn which liberal country is it forbidden to compare products and try to have a fair access to the actual capacity of a product? Russia? China? "], [3, "[deleted]"], [2, "It's still depends on what kind of application we are building.. But this is a good article how to optimize the sql queries"]], [[{"comment": "> Moreover, I never ever ever want to jump to page 317 right from the beginning. There\u2019s absolutely no use case out there, where I search for something, and then I say, hey, I believe my search result will be item #3175 in the current sort order\n\nSorry, but that's wrong. It's super important to be able to see how many pages there are and being able to jump because you want to be able to do trivial binary searches when the filtering isn't up to snuff (which is surprisingly often!) or where you want to find where in the result some thing changes. Those are from the top of my head. There are probably more. \n\nThings programmers (the author) get wrong about pagination: assuming you know the use case. ", "id": "d6bugtv"}, {"comment": "For some app that we developed, we didn't even use the RDBMS for searching and pagination. We were using Full-text search with Apache SOLR and it's so much faster. And we could combine any filtering criteria without worrying about performance or having the right indexes.", "id": "d6bvyko"}, {"comment": "Sure. Even if the search language is powerful enough the article also assumes that you don't need the exact number. Why? Maybe that's all you want. ", "id": "d6bwxiv"}, {"comment": "With full-text search on top of Lucene we even got the exact number of matched entries. It's a pity that pagination is still a complex topic in RDBMS.", "id": "d6bxhay"}, {"comment": "Well, you know my proposition...\n\n    SELECT col1, col2\n    FROM tab\n    WHERE something\n    ORDER BY a, b\n    SEEK :last_value_for_a_on_previous_page, :last_value_for_b_on_previous_page\n    LIMIT 10 -- or, FETCH NEXT 10 ROWS ONLY, if you prefer\n\nThe number of columns and the types in `ORDER BY` and `SEEK` would have to match. This would work for both `ASC`, `DESC`, and mixed sorting. [That's what jOOQ emulates, in fact](http://www.jooq.org/doc/latest/manual/sql-building/sql-statements/select-statement/seek-clause/), as mentioned also in the article.", "id": "d6bzyhj"}, {"comment": "Was it lucene or elastic search that lost data all the time?", "id": "d6bxqb1"}, {"comment": "Even synchronizing it with the DB is done in async mode, so it's not strongly consistent anyway. It's analogous to an application-level caching solution like Redis or Memcached because it provides low latency even if you pay the price for not having strong consistency.", "id": "d6bxxfd"}, {"comment": "Weeeelll.. that didn't answer the question. I noticed.", "id": "d6byh79"}, {"comment": "[It was ElasticSearch to answer your question](https://aphyr.com/posts/323-call-me-maybe-elasticsearch-1-5-0). However, every time is not correct. It loses data in network partitions and split-brain scenarios when recovering from a partition.", "id": "d6bzpfh"}, {"comment": "Well. Partitions can be GC pauses so that's bad. ", "id": "d6c1aes"}, {"comment": "I like that they are working hard to address all the issue. [This is the page which records their progress](https://www.elastic.co/guide/en/elasticsearch/resiliency/current/index.html).", "id": "d6d1k3r"}, {"comment": "Binary searches... That's what happens if technical folks design user interfaces. If I explain the concept of a binary search to my wife and why she should apply it on some website, then she'll throw the computer out the window (and me right after).\n\nWe can do better in UX, no?", "id": "d6bvr1q"}, {"comment": "It's a valid workaround for bad UX is all I'm saying. People do binary searches all the time, they just do it on instinct and not theory. ", "id": "d6bwgoo"}, {"comment": "And the UX is bad because of OFFSET pagination. We've come full circle ;)", "id": "d6bxaaa"}], [{"comment": "Hum the Oracle license forbids benchmarking? \n\nIn which liberal country is it forbidden to compare products and try to have a fair access to the actual capacity of a product? Russia? China? ", "id": "d6bu06x"}, {"comment": "As I understand the license (and discussions on the web):\n\n1. You may benchmark the database, but you may not publish the results.\n2. It is not generally forbidden (e.g. there are the TPC benchmarks, which are public), but it certainly is under the terms of the OTN license.\n\nOf course, IANAL.", "id": "d6bu3lp"}, {"comment": "And everyone find this normal? It is a clear way of preventing a free rational choice of consumers. It is a disloyal practice biasing the possibility to do a fair trade. \n\nIn my \u00abso called communist country\u00bb by some north Americans citizens, in convinis we have the price tags of everything per kilogram (milk, wine, potatoes, meats, biscuits) and it really help to be able to benchmark to have a competitive market.\n\nPublicly available information that helps compare products are the very core of economical liberalism, no? ", "id": "d6bzz74"}, {"comment": "What's \"normal\"? Any vendor can write anything in their license texts. If you download the software, you are bound by the license texts, above all by the imposed jurisdiction and law. If you don't agree with Larry, feel free to publish a benchmark and get ready for trial. If you're willing to take Larry to the U.S. Supreme Court (after passing through all levels of U.S. jurisdiction), you might actually win this and prove your point. But at what price?", "id": "d6c0czo"}, {"comment": "Come on! In USA you seem to have all the judicial arsenal to fight back Oracle:\n\n\nSeverability : this clause can be sided out of the contract (and would not affect the other clauses if voided including the \u00abownership\u00bb of the product)\n\nMisrepresentation: by limiting benchmarking it affects the capacity of buyers to choose fairly (with potential claim for financial loss)\n\nFederal Trade Commission: the right to regulate the market (10th amendment)\n\nOne sided//illegal clauses: they void the clause of the contract if going against a higher legal hierachy (ex: constitution, international treaty (like fair trade...))\n\nClass actions: enough companies can mutualize their claim to found a solid case against Oracle.\n\n\nI know Oracle is respected, but USA constitution was actually written to prevent the strongest to impose its will against the common interest//people. Limiting the capacity to make a fair choice by the consumers is clearly a distortion of competition.\n\n\nWhat worth is it to have rights given to the whole people if only a minority can actually have them enforced?\n\n", "id": "d6c2f5g"}, {"comment": "Morally, you're right.\n\nRealistically, legal action is *expensive*.", "id": "d6c3l4h"}, {"comment": "Hey. I'm just a small man with no stake in this. But you seem to be determined, so do it!", "id": "d6cw4vd"}, {"comment": "You'd probably be fine with it anyways.", "id": "d6bzmmn"}, {"comment": "I'd be fine with the tech folks at Oracle. But I'm not sure if the lawyers care about the tech folks' opinions...", "id": "d6c02ze"}, {"comment": "You'd be fine with your government though. It's one of those clauses that'd be QUITE hard to enforce. Essentially it'd have to be slander (so incorrect) but they could come after you anyways if it was slander.\n\nI'm not 100% familiar with US law but with Canadian law you have the right to do lots of things with software for the sake of interoperability and evaluation. I can't see any Canadian court deciding in favour of not allowing publishing performance analysis's, and I don't think US would be that far off.\n\nThat said the usual IANAL disclaimer.", "id": "d6d5mg3"}, {"comment": "And everyone find this normal? It is a clear way of preventing a free rational choice of consumers. It is a disloyal practice biasing the possibility to do a fair trade. \n\nIn my \u00abso called communist country\u00bb by some north Americans citizens, in convinis we have the price tags of everything per kilogram (milk, wine, potatoes, meats, biscuits) and it really help to be able to benchmark to have a competitive market.\n\nPublicly available information that helps compare products are the very core of economical liberalism, no? ", "id": "d6bzyzx"}, {"comment": "It's the DeWitt clause:\n \nhttps://en.wikipedia.org/wiki/David_DeWitt", "id": "d6bucsa"}], [{"comment": "[deleted]", "id": "d6bolfx"}, {"comment": "[deleted]", "id": "d6bpb0g"}, {"comment": "It's a click-bait title, but the article is good.", "id": "d6bpgsj"}, {"comment": "[deleted]", "id": "d6bpq6d"}, {"comment": "You're lucky then. In my trainings, I always ask people if they heard about the OFFSET pagination issue, and almost nobody has ever heard of it.", "id": "d6bptpc"}, {"comment": "[deleted]", "id": "d6bpwqb"}, {"comment": "Which RDBMS handles it well then? Can you give an example?", "id": "d6bpyzu"}, {"comment": "[deleted]", "id": "d6bq441"}, {"comment": "And does the computed index solution for PostgreSQL outperforms Keyset pagination? I'd love to see a benchmark because I'm not convinced.", "id": "d6bq75a"}, {"comment": "[deleted]", "id": "d6bqc7y"}, {"comment": "[deleted]", "id": "d6bpj30"}, {"comment": "Please elaborate. Is the OFFSET pagination a good choice?", "id": "d6bpnpq"}, {"comment": "[deleted]", "id": "d6bpujr"}, {"comment": "Can you provide an example when OFFSET is a good choice?", "id": "d6bpx5l"}, {"comment": "[deleted]", "id": "d6bpzfh"}, {"comment": "Do you mean keeping a cursor upon along with the database connection? That would take a great toll on scalability.", "id": "d6bq3c3"}, {"comment": "According to this ad-hoc poll: https://twitter.com/MarkusWinand/status/763355769693765632", "id": "d6bq3x7"}, {"comment": "[deleted]", "id": "d6bq5tj"}, {"comment": "OFFSET has two problems:\n- drifting results\n- performance for large OFFSETS\n\nThus, offset is only safe you don't have large OFFSETS AND your data is static for the duration of the pagination.", "id": "d6bqapm"}, {"comment": "[deleted]", "id": "d6bqe64"}, {"comment": "Interesting article, thanks for sharing!", "id": "d6bsrxx"}, {"comment": "Very good article. The `ctid` method is pure genius.", "id": "d6bt78j"}, {"comment": "If only Google will only return Keyset pagination results. If you google Java database pagination, you'll find many solutions using the OFFSET pagination, which does not scale especially for infinite scroll. ", "id": "d6boryb"}, {"comment": "[deleted]", "id": "d6bp9j1"}, {"comment": "Let's [Google JPA pagination](https://www.google.ro/webhp?sourceid=chrome-instant&ion=1&espv=2&ie=UTF-8#q=pagination%20jpa) and take any result.\n\n[Like this SO answer with 24 upvotes](http://stackoverflow.com/questions/16088949/jpa-query-to-select-based-on-criteria-alongwith-pagination).\n\n    return em.createNamedQuery(\"yourqueryname\", YourEntity.class)\n      .setMaxResults(noOfRecords)\n      .setFirstResult(pageIndex * noOfRecords));\n      .getResultList();\n    List <Foo> fooList = query.getResultList();\n\nIt's using OFFSET pagination which does not scale. But how many Java developers know about this issue? [Unless you previously read Markus Winand's article from 2014](http://use-the-index-luke.com/no-offset), chances are you'll never know about it until you hit a performance issue in your production system.", "id": "d6bplbi"}, {"comment": "[deleted]", "id": "d6bpno6"}, {"comment": "There aren't many frameworks to offer Keyset pagination. Which one of those are you currently using in production?", "id": "d6bpr02"}, {"comment": "[deleted]", "id": "d6bpt6i"}, {"comment": "Spam you say? I don't think so. \n\nThe article does not have a terrible Karma, so I guess there are people that find it interesting after all.", "id": "d6bt938"}], [{"comment": "It's still depends on what kind of application we are building.. But this is a good article how to optimize the sql queries", "id": "d6bqcfh"}]]], "4h1apr": ["The first random number generator was a roulette wheel strapped to a computer", "2016-04-30 00:15:54", 0, "https://en.wikipedia.org/wiki/A_Million_Random_Digits_with_100,000_Normal_Deviates", [[11, "It was an *electronic simulation* of a roulette wheel, not a literal roulette wheel.  In one of the reference links, the actual method used is discussed:\n\n> Note: The barely mentioned \"random frequency pulse source\" is in fact the critical heart of their system. Willis Ware wrote, in a history of RAND accomplishments, that it was \"probably an ordinary gas voltage regulator tube\". Not a very forceful statement; however the most [common random-noise source](http://www.worldpowersystems.com/projects/million/Noise-Gen-6D4-Cobine-Curry-1946.pdf) in the late 1940's was the 6D4 triode thyratron, wired as a diode (grid tied to cathode). If RAND did not use a 6D4, it seems certain that they used the same principle -- a gas-filled electron tube operating in a transverse magnetic field. (Corrected 21 May 2009)\n"], [7, ">an electronic simulation of a roulette wheel attached to a computer,\n\nI'm not sure what this means, but it doesn't sound like it was literally a roulette wheel."], [5, "Cannot decide if I should upvote because the article is mildly interesting or to downvote because the title is lying."], [2, "In a similar vein, [The Beginning of the Monte Carlo method](https://fas.org/sgp/othergov/doe/lanl/pubs/00326866.pdf) by Nicholas Metropolis"], [1, "This is so cool.  I was born in 1963 and my parents moved out of their bedroom to make it *my* bedroom, leaving behind a bookshelf full of Time-Life nature-and-science books.  One of them -- I forget exactly which -- contained an excerpt from \"a book of random numbers,\" as an example of the notion that only a computer can generate truly random numbers -- \"humans are too full of associations...\"  And now this completes the picture.  Bravo!  \n  \n**PS - additional mental upvote for spelling \"fluoro\" correctly, in your username.  So sick of seeing \"flouro\" everywhere.**"], [-3, "[deleted]"]], [[{"comment": "It was an *electronic simulation* of a roulette wheel, not a literal roulette wheel.  In one of the reference links, the actual method used is discussed:\n\n> Note: The barely mentioned \"random frequency pulse source\" is in fact the critical heart of their system. Willis Ware wrote, in a history of RAND accomplishments, that it was \"probably an ordinary gas voltage regulator tube\". Not a very forceful statement; however the most [common random-noise source](http://www.worldpowersystems.com/projects/million/Noise-Gen-6D4-Cobine-Curry-1946.pdf) in the late 1940's was the 6D4 triode thyratron, wired as a diode (grid tied to cathode). If RAND did not use a 6D4, it seems certain that they used the same principle -- a gas-filled electron tube operating in a transverse magnetic field. (Corrected 21 May 2009)\n", "id": "d2mknvo"}, {"comment": "Cool. Thanks for the source bro", "id": "d2mktu8"}], [{"comment": ">an electronic simulation of a roulette wheel attached to a computer,\n\nI'm not sure what this means, but it doesn't sound like it was literally a roulette wheel.", "id": "d2mj4ip"}], [{"comment": "Cannot decide if I should upvote because the article is mildly interesting or to downvote because the title is lying.", "id": "d2mo0vw"}, {"comment": "Downvote it. I posted it actually just to save it to my reddit favorites, and maybe get some more info. Mission accomplished. (Also I was just 1 upvote away from a round number - it was 999 - had to even it out) Will delete it later when I no longer need the handy bookmark.", "id": "d2moc87"}], [{"comment": "In a similar vein, [The Beginning of the Monte Carlo method](https://fas.org/sgp/othergov/doe/lanl/pubs/00326866.pdf) by Nicholas Metropolis", "id": "d2mm713"}], [{"comment": "This is so cool.  I was born in 1963 and my parents moved out of their bedroom to make it *my* bedroom, leaving behind a bookshelf full of Time-Life nature-and-science books.  One of them -- I forget exactly which -- contained an excerpt from \"a book of random numbers,\" as an example of the notion that only a computer can generate truly random numbers -- \"humans are too full of associations...\"  And now this completes the picture.  Bravo!  \n  \n**PS - additional mental upvote for spelling \"fluoro\" correctly, in your username.  So sick of seeing \"flouro\" everywhere.**", "id": "d2o4p8q"}], [{"comment": "[deleted]", "id": "d2mior0"}, {"comment": ">[The RAND name originated as a contraction of research and development.](http://www.rand.org/about/faq.html)", "id": "d2mo03k"}]]], "4cpnkg": [".NET Logging options in XXI century", "2016-03-31 15:47:46", 0, "https://devblog.dymel.pl/2016/03/31/net-logging-options-in-xxi-century/", [[6, "System.Out.WriteLine? \n\nWhy not System.Diagnostics.TraceSource and friends, the built-in logging options are actually quite good."], [4, "With no essentially discussion of the differences between these loggers, this amounts to little more than \"*Have you heard of NLog, Log4Net or Serilog?*\", unfortunately."], [2, "No mention of [Serilog](http://serilog.net/)?"], [2, "No love for ETW logs?"], [1, "There is a new built in set off lightweight contracts for loggers. In the interest of good design it seems better to depend on these contracts rather than on a particular single implementation."]], [[{"comment": "System.Out.WriteLine? \n\nWhy not System.Diagnostics.TraceSource and friends, the built-in logging options are actually quite good.", "id": "d1kkelj"}, {"comment": "I was never a fan of these. I find them cumbersome - especially for reading logs. ", "id": "d1kkpuj"}], [{"comment": "With no essentially discussion of the differences between these loggers, this amounts to little more than \"*Have you heard of NLog, Log4Net or Serilog?*\", unfortunately.", "id": "d1kgtpd"}, {"comment": "The purpose of this was more to highlight targets (logentries, exceptionless) than logging frameworks. As is said in the post, imo they don't differ much (except from serilog), but using proper tools to gather and analyze your logs is still rare practice. Especially in smaller projects. ", "id": "d1kgxfw"}], [{"comment": "No mention of [Serilog](http://serilog.net/)?", "id": "d1kbu47"}, {"comment": "I never used it, so couldn't recommend it :) \nThere are many applications like that (Sentry, Stackify, Raygun, Papertrail, NewRelic). Everyone has their favourites... ", "id": "d1kc5uv"}, {"comment": "> I never used it, so couldn't recommend it :) There are many applications like that (Sentry, Stackify, Raygun, Papertrail, NewRelic). Everyone has their favourites...\n\nugh - just noticed it's a framework. And I know it - got up too early today I guess :) I forgot about this one - will add it to the post later. Thanks! ", "id": "d1kc6wc"}, {"comment": "updated ", "id": "d1kcbga"}, {"comment": "There seems to be a copy/paste error: the link you added for Serilog actually points to log4net at present.", "id": "d1kdzgr"}, {"comment": "Ah! Visual edit in wordpress ;) Thanks! ", "id": "d1kequ4"}], [{"comment": "No love for ETW logs?", "id": "d1kpdhw"}, {"comment": "I love the idea, but I never managed to get them to work right.", "id": "d1ks402"}], [{"comment": "There is a new built in set off lightweight contracts for loggers. In the interest of good design it seems better to depend on these contracts rather than on a particular single implementation.", "id": "d1loc59"}]]], "3xzlqs": ["Google's Angular 2 Release Is A Big Step Toward Turning Web Developers Into App Developers", "2015-12-23 21:18:22", 0, "http://www.wired.com/2015/12/googles-angular-2-release-helps-push-javascript-beyond-the-browser/?utm_medium=social-owned", [[14, "I'm not sure if I should take offense..."], [9, "It's a puff piece that managers will read. In the next meeting they'll chime in \"Have you looked into Angular 2? I think we should be  looking in that direction\"."], [6, "Somehow I feel this is just 'damage control' or pr from angular side that it is just as capable as react. So my question is, has this been in public road maps or any docs previously or was it just recently announced?"], [6, ">Meanwhile, Google\u2019s Go language\u2014which streamlines coding in other ways\u2014is moving the other direction, from servers onto mobile devices.\n\nI see [Go does have a mobile library](https://godoc.org/golang.org/x/mobile/app), but is it actually being used in production anywhere?"]], [[{"comment": "I'm not sure if I should take offense...", "id": "cy961zl"}], [{"comment": "It's a puff piece that managers will read. In the next meeting they'll chime in \"Have you looked into Angular 2? I think we should be  looking in that direction\".", "id": "cy9k943"}], [{"comment": "Somehow I feel this is just 'damage control' or pr from angular side that it is just as capable as react. So my question is, has this been in public road maps or any docs previously or was it just recently announced?", "id": "cy99js2"}, {"comment": "I don't know if Google has any plans to create a mobile-version of Angular a la React Native. However, having used Angular 2 alpha, I can say that Angular 2 is very similar to React in that it is component based, and it could theoretically be modified for use in mobile apps since it isn't tightly coupled with the DOM. Of course, Google did recently announce [Flutter](http://flutter.io/) which is a direct competitor to React Native, but it wouldn't be the first time Google has had two directly competing products on the market (e.g. Dart and Go), so this doesn't rule out the possibility of an \"Angular Native\".", "id": "cy9a8u6"}, {"comment": "> Dart and Go\n\nDoart was supposed to be a javascript replacement, while Go is almost a system laguage, I don't think those are competing.", "id": "cy9bxxk"}, {"comment": "I wouldn't call Go a systems language. The fact that it's a garbage collected language makes it unsuitable for embedded systems (compared to something like C or Rust). I've seen Go used more for Web backends than anything. Although that being said, you do have a point in that it seems more like Dart and Go are meant to be used together (as frontend and backend). ", "id": "cy9f8eg"}, {"comment": "Go is intended for the same things as Node: highly concurrent server-side software.", "id": "cy9udft"}, {"comment": "> while Go is almost a system laguage\n\nGo will never be a system language, not even almost.", "id": "cy9yllw"}, {"comment": "It's not Google-written but there is an Angular environment for writing mobile apps: http://ionicframework.com - but I don't think it's native in the same way React Native is (disclaimer: haven't actually used it...)", "id": "cy9o4kt"}, {"comment": "It uses phonegap/Cordova method of developing a mobile app.", "id": "cya5wyv"}], [{"comment": ">Meanwhile, Google\u2019s Go language\u2014which streamlines coding in other ways\u2014is moving the other direction, from servers onto mobile devices.\n\nI see [Go does have a mobile library](https://godoc.org/golang.org/x/mobile/app), but is it actually being used in production anywhere?", "id": "cy99k1x"}, {"comment": "Mobile support is experimental at the moment as far as I know so nope.\n\nWill improve with 1.6 I guess but being in production .... don't think so.", "id": "cy9yky9"}]]], "46ag7w": ["We're making a NN algorithm that can generate music that people like. But we need your help!", "2016-02-17 22:22:24", 4, "https://www.youtube.com/watch?v=d2dz3BoWyTM", [[3, "Pretty neat. [Here](http://www.judgemysound.com/) you can actually judge the sound. Has tunes better than I expected."], [2, "Where is the code for this?"]], [[{"comment": "Pretty neat. [Here](http://www.judgemysound.com/) you can actually judge the sound. Has tunes better than I expected.", "id": "d03lm80"}], [{"comment": "Where is the code for this?", "id": "d042nnw"}]]], "45u20o": ["A Modern App Developer and An Old-Timer System Developer Walk Into a Bar", "2016-02-15 04:12:57", 5, "http://zhen.org/blog/two-developers-walk-into-a-bar/", [[73, ">Old-Timer Developer:\n>\n>    I will use Go. \n\nlol"], [34, "HN go worship is leaking again."], [26, "Clearly Modern App Developers are incapable of selecting appropriate tools for a job, or knowing basic Boolean algebra. 0/10 article."], [10, "I weirded a young'n out when I whipped up a mmaped database in Python that used bit-offsets to organize its fixed-length records. "], [9, "I'm a green developer (2-3 yrs xp) so help me understand this. \n\nWhy can't I just use a database to store all that info? Why would I use json or a bit mapped file? I can just use the database to generate my reports and then scrap it next month.\n\nWhy would Python or Go make a difference? It has to be done once a month, either should fine as long as the code is relatively clean and maintainable, right?"], [10, "Both answers suck. The bottleneck on this will be your memory reading and writing speed. The greybeard's solution uses 32GB to keep a 4 billion element array holding only (we're told) 300 million nonzero records.\n\nA better encoding would be a sorted list of only the IPs that are up, packing 4 bytes for the IP address and 3 bytes for the open ports. 7bytes*300m = 2.1GB.\n\nSo all the whole-array operations have only 2GB instead of 32GB to process, and hence become approximately 15x faster - and probably more, since 32GB probably doesn't fit in main memory and will have to page to disk.\n\nAdmittedly, finding a record for a specific IP becomes slightly slower (it's a binary search instead of a direct lookup, so O(log(N) instead of O(1).)\n\n(Edit: ah, just noticed they're actually storing 60 bits of data for the ports, because even though none of the tasks need it, they're recording more about each port than simply open/closed. And moreover only one of the tasks involves the port information, so most of them will only be reading the 500MB IP bit array. In that case the one-bit-per IP array is a good solution. Operations involving the ports array will still be unnecessarily slow though. The encoding I suggested would get it down to 4bytes for the IP + 8bytes for the ports * 300m = 3.6GB."], [8, "\"I hate young developers!\" - Article"], [5, "Haha, excellent!\n\nThere is more than one way to skin a cat, and in software, they are wildly different.\n\nThey also wildly depend on the requirements. For example: 4 billion ip addresses and some flags, that ain't no Big Data I wouldn't think. However, one simple question: \"what about IPv6\" changes that considerably.\n\nAside 1: old timer said he will use Go? TFA is just being funny there.\n\nAside 2: *very first* thing to decide on is the implementation language!? *Really!?* It is so random at this stage, might as well use a dice."], [5, "> They will port scan all of the IPv4 address (2^32=4,294,967,296) on a monthly basis\n\nI remember in some countries these kind of activities are in fact illegal."], [2, "While it's not exactly the greatest decision for the article's \"Old Timer's solution\", usage of bits themselves as very efficient means of data storage has caught my eye and makes me want to do some more research to understand how and when it's a good solution for a problem. \n\nYay for being young and new to the field."], [1, "I'm with the old-timey developer"], [0, "What a waste of five perfectly good minutes."]], [[{"comment": ">Old-Timer Developer:\n>\n>    I will use Go. \n\nlol", "id": "d008x0p"}, {"comment": "Nah man, every greybeard uses Go, didn't you read that blog post on Hacker News about it?", "id": "d00bmca"}, {"comment": "Go has both the rich typing system of C combined with the reliable garbage collection of LISP.", "id": "d00cmsi"}, {"comment": ">  the rich typing system of C\n\nYes, very rich, compared to Assembly.", "id": "d00h8sb"}, {"comment": "whoosh", "id": "d00v7tp"}, {"comment": "Ooh, I like it.", "id": "d00dgq3"}, {"comment": "an old timer developer is going to pick the tool he is most familiar with\n\ngo has been around for years and has a mature ecosystem and it's just a really great language\n\nonly the most deluded C fanbeard old-timer is going to pick something other than go or swift", "id": "d00f1k5"}, {"comment": "\"Around for years\". Seven, in fact. Seven years. It's younger than the \"modern\" language in the example by 357%.\n\nHere's a nickel, kid. Go buy yourself a real computer.", "id": "d00hcl1"}], [{"comment": "HN go worship is leaking again.", "id": "d007uxr"}], [{"comment": "Clearly Modern App Developers are incapable of selecting appropriate tools for a job, or knowing basic Boolean algebra. 0/10 article.", "id": "d00aepj"}, {"comment": "Was that really supposed to be the point of the article? Old timer's design seems hopelessly naive - it would only work single-homed without significant extra work, so can't be extended much at all. What happens when you decide you need ports scanned daily? Hourly? What happens when the disk spindle breaks halfway through the scan? ISP goes down?\n\nThe \"modern app developer\"'s solution is sloppy but at least has some hope of handling the above.", "id": "d00deym"}, {"comment": "> Was that really supposed to be the point of the article? Old timer's design seems hopelessly naive - it would only work single-homed without significant extra work, so can't be extended much at all. What happens when you decide you need ports scanned daily? Hourly? What happens when the disk spindle breaks halfway through the scan? ISP goes down?\n\nDoes it really ? All it needs to (assuming sequential) do to save a state of scan is to save uint32 with currently scanned IP and fsync in right place.  Hourly scan is just open few more files if the other scan haven't finished yet.\n\nAnd it could be scaled in same way, by adding nodes and delegating tasks for them. Just add some light api on top of it\n\n> The \"modern app developer\"'s solution is sloppy but at least has some hope of handling the above.\n\nIt really does not except 'put results in central db'\n\nOverall, both of those ways are fucking awful and naive ways of doing it, just in different way\n\n", "id": "d00h57n"}], [{"comment": "I weirded a young'n out when I whipped up a mmaped database in Python that used bit-offsets to organize its fixed-length records. ", "id": "d005rw3"}, {"comment": "The cffi module is really fun - finally I can write C in Python! (I'm only half joking, it is actually genuinely nice in some cases like writing a library wrapper to a C library.)", "id": "d010u96"}], [{"comment": "I'm a green developer (2-3 yrs xp) so help me understand this. \n\nWhy can't I just use a database to store all that info? Why would I use json or a bit mapped file? I can just use the database to generate my reports and then scrap it next month.\n\nWhy would Python or Go make a difference? It has to be done once a month, either should fine as long as the code is relatively clean and maintainable, right?", "id": "d00ekhl"}, {"comment": "It's just hyperbole.\n\nPeople just wanna feel like their \"elite\" knowledge of the fact that there are 8 bits in a byte is still impressive when there are so many efficient and helpful software tools that 99% of the time no one will need to bother with a memory-mapped file. That kind of bit fiddling was common in the 80s and 90s but Moore's law as well as rapidly increasing drive space and RAM has made worrying about that kind of stuff mostly pointless today.\n\nAs you suggest, a database seems by far the best fit. And most databases use plenty of bit fiddling to keep their implementations super fast.\n\nWhich is a win for everyone. Your app code stays simple. The database can use all sorts of crazy micro-optimizations and hide that from you behind a well defined interface (namely SQL).\n\nOnly the most dense code monkey would go \"Oh yeah, 100+GB of JSON? Looks like I'm on the right track.\"\n\n(Ironically enough I *do* know someone who made exactly that type of statement. But he is simply an incompetent programmer. There are plenty of those types of programmers now, and there were plenty of those in the olden days, too.)\n\nEDIT: A more realistic article, comparing two programmers of equal technical skill, might be something like this:\n\nModern app developer: Makes reasonable choices and writes code that is easy for his teammates to work on.\n\nOld timer MacGyver developer: Makes a super efficient memory-mapped bit packed ad-hoc data format that all team members will have to take a few hours if not days trying to understand and which breaks horribly once the requirements change, cuing all maintenance programmers to eventually mutter \"Why the fuck did they do this using a memory-mapped file instead of a database?\"", "id": "d00fpmm"}, {"comment": "> Only the most dense code monkey would go \"Oh yeah, 100+GB of JSON? Looks like I'm on the right track.\"\n\nROFL :-)", "id": "d00j9r8"}, {"comment": "Performance and cost. The old timer's approach assumes that CPU/RAM/Storage are expensive and slow, the web app dev assumes that they're cheap and fast. The old timer uses as few components as possible to reduce complexity, the web app dev uses as many canned solutions as possible to leverage existing code.", "id": "d00ll0z"}, {"comment": "Welcome to the world of programming forums/subs/articles, where articles with no other point than making your own language of choice appear better than the rest are staple.\n \nYou will start to notice strong resemblance to sports forums/subs/articles, people defend their club/stack in all subjects, approach issues with a biased view, wear their teams jersey/t-shirt hate on a specific club/stack that is seen as a rival.", "id": "d00i3tr"}, {"comment": "Yes, you can *easily* use a database there, and that would be a \"middle\" solution wrt storage space.\n\nPython vs Go is completely random, *especially* as a first implementation decision.", "id": "d00fj60"}, {"comment": "The choice of language was indeed random, and had exactly zero impact on either naive implementation. Seemed like it was just another attempt to stoke the fires. ", "id": "d00gmm4"}, {"comment": "Hey! We seem to be downvoted by a random Python or Go bigot! ;-)", "id": "d00likt"}, {"comment": "> Why can't I just use a database to store all that info?\n\nhttps://www.jwz.org/doc/mailsum.html  \nhttps://www.jwz.org/blog/2011/07/mork-keeps-on-giving-when-the-database-worms-eat-into-your-murder-trial/\n\nThe same guy also wrote [The Insidious Big Brother Database](https://www.jwz.org/bbdb/).", "id": "d00zl8m"}], [{"comment": "Both answers suck. The bottleneck on this will be your memory reading and writing speed. The greybeard's solution uses 32GB to keep a 4 billion element array holding only (we're told) 300 million nonzero records.\n\nA better encoding would be a sorted list of only the IPs that are up, packing 4 bytes for the IP address and 3 bytes for the open ports. 7bytes*300m = 2.1GB.\n\nSo all the whole-array operations have only 2GB instead of 32GB to process, and hence become approximately 15x faster - and probably more, since 32GB probably doesn't fit in main memory and will have to page to disk.\n\nAdmittedly, finding a record for a specific IP becomes slightly slower (it's a binary search instead of a direct lookup, so O(log(N) instead of O(1).)\n\n(Edit: ah, just noticed they're actually storing 60 bits of data for the ports, because even though none of the tasks need it, they're recording more about each port than simply open/closed. And moreover only one of the tasks involves the port information, so most of them will only be reading the 500MB IP bit array. In that case the one-bit-per IP array is a good solution. Operations involving the ports array will still be unnecessarily slow though. The encoding I suggested would get it down to 4bytes for the IP + 8bytes for the ports * 300m = 3.6GB.", "id": "d00jo1i"}, {"comment": "While I don't agree that both answers suck - I'd say the old timer's approach is the correct place to start.\n\nBut have an upvote for actually applying reasoning and design to the problem instead of just claiming the author is arrogant, elitist and or out of touch.", "id": "d00lo8n"}, {"comment": "Yes, granted my initial assessment was a little harsh (see edit). The old timer is on the right track; the \"modern app developer\"'s solution seems more like a parody.", "id": "d00oqgv"}, {"comment": "> the \"modern app developer\"'s solution seems more like a parody.\n\nI've seen some things, terrible terrible things.\n\nAnd yeah, I've seen people spin up hundred node clusters to index 1GB of data.", "id": "d00r4g2"}, {"comment": "I wouldn't be that sure: http://aadrake.com/command-line-tools-can-be-235x-faster-than-your-hadoop-cluster.html", "id": "d01479s"}], [{"comment": "\"I hate young developers!\" - Article", "id": "d00c48q"}, {"comment": "And our system requirements will never change, nor will what we want to do with this data - we're content with just counting bits...forever.", "id": "d00dcgd"}], [{"comment": "Haha, excellent!\n\nThere is more than one way to skin a cat, and in software, they are wildly different.\n\nThey also wildly depend on the requirements. For example: 4 billion ip addresses and some flags, that ain't no Big Data I wouldn't think. However, one simple question: \"what about IPv6\" changes that considerably.\n\nAside 1: old timer said he will use Go? TFA is just being funny there.\n\nAside 2: *very first* thing to decide on is the implementation language!? *Really!?* It is so random at this stage, might as well use a dice.", "id": "d00fg98"}, {"comment": "> Aside 2: very first thing to decide on is the implementation language!? Really!? It is so random at this stage, might as well use a dice.\n\nAnnoyingly this is kinda required in most projects, you've got to write some code (the correct answer is usually use the language you know). Even more annoyingly the zeroth thing to decide is the project's name, as you have to decide what to call the directory to put it in.", "id": "d00lpf3"}], [{"comment": "> They will port scan all of the IPv4 address (2^32=4,294,967,296) on a monthly basis\n\nI remember in some countries these kind of activities are in fact illegal.", "id": "d00ha42"}, {"comment": "Yeah, or at the very least your ISP will block you.\n\nMaybe that's the subtext here... neither developer questioned the premise.", "id": "d00je3y"}], [{"comment": "While it's not exactly the greatest decision for the article's \"Old Timer's solution\", usage of bits themselves as very efficient means of data storage has caught my eye and makes me want to do some more research to understand how and when it's a good solution for a problem. \n\nYay for being young and new to the field.", "id": "d00gngc"}, {"comment": "showing off your L33T bit-flipping skills is a great way to write unmaintainable code. ", "id": "d012hoz"}, {"comment": "That doesn't make any sense to me though. \n\nFirst, I specifically mentioned I wanted to learn when it'd be a good solution. Maintainability is generally a criteria of \"good\" code, is it not?\n\nSecond, just because something is complex, clever, rarely done, or perhaps more difficult to understand conceptually doesn't mean it's going to be hard to maintain. This goes hand in hand with proper documentation and commenting of code. \n\nThird, showing off a \"skill\" in any situation or any field is generally going to lead to a bad time, isn't it? The emphasis is on a good solution. Making something unnecessarily complex is not a good solution. However, if you can solve a complex problem with some nifty bit logic (which the article used an extreme example of) and have it be only a few lines long and/or perform extremely well (taking care to comment/document), would it not be preferable?\n\nEDIT: Also, before I'm attacked for living in an ideal world where everything is commented and documented well, this is merely a discussion on proper solutions, not just hacking something together so it works. I don't like that. :(", "id": "d013h46"}, {"comment": ">usage of bits themselves as very efficient means of data storage has caught my eye and makes me want to do some more research to understand how and when it's a good solution for a problem.\n\nWhen you have genuinely big data (Like at the very least a few hundred million data points) managing to pack 2+ values into 1 byte instead of using a 4 byte integer primitive for each can be worthwhile.\n\nWhen you have data very unlikely to change its 'shape'. (Packing a 5bit integer and 3 bit integer into a byte only works as long as 5 and 3 bits are enough bits to store all possible values of what you need to represent. If things change, changing the meaning of bits is a huge hassle.)\n\nWhen you expect the solution to be long-lasting enough to warrant such a specialized solution. Being 5 times less space efficient than is theoretically possible doesn't matter much for something you'll only do for 2 weeks. If it's something that will probably be around for decades the payoffs of involved craftiness increase a whole lot while the difficulty of maintaining such non-standard craftiness remains constant.", "id": "d010ni7"}], [{"comment": "I'm with the old-timey developer", "id": "d02lt2x"}], [{"comment": "What a waste of five perfectly good minutes.", "id": "d00hd15"}]]], "4k7pnp": ["Minecraft Server with a Bitcoin-denominated monetary system", "2016-05-20 15:00:33", 2, "http://bitquest.co/", [[2, "Isn't this against the mojang terms of service?"], [1, "Your donation banner says, \"Suppor Us.\"\n\nEdit: ~~Also, if the bitcoins are stored in a wallet, does this also mean they could be transferred to another wallet as an actual currency?~~"]], [[{"comment": "Isn't this against the mojang terms of service?", "id": "d3d6qdp"}, {"comment": "I was trying to figure out what part you were referring to. Looks like:\n\n> [You cannot charge real-world cash for in-game currency](https://mojang.com/2014/06/lets-talk-server-monetisation/)\n\npretty clearly prohibits this.", "id": "d3dtz2m"}, {"comment": "[Bitcoin is property not a currency](http://www.bloomberg.com/news/articles/2014-03-25/bitcoin-is-property-not-currency-in-tax-system-irs-says) as defined by the IRS so it's all good.", "id": "d3e34j2"}, {"comment": "Unfortunately, per that same page:\n\n> Hard currency is real money or anything that can be converted into real money, including Bitcoins. ", "id": "d3ejzc8"}, {"comment": "Welp if it's explicitly stated.", "id": "d3eqx0v"}], [{"comment": "Your donation banner says, \"Suppor Us.\"\n\nEdit: ~~Also, if the bitcoins are stored in a wallet, does this also mean they could be transferred to another wallet as an actual currency?~~", "id": "d3d51dr"}]]], "4yod8y": ["JBoss WildFly 10.1 released!", "2016-08-20 14:16:21", 0, "http://wildfly.org/news/2016/08/19/WildFly10-1-Released", [], []], "4ilnnp": ["I hate almost all software", "2016-05-10 00:49:47", 0, "http://tinyclouds.org/rant.html", [[25, "Meh, I don't get the point of this rant. Nobody likes unnecessary complexity. Go ahead and find me ten programmers that can agree some piece of complexity is indeed unnecessary and I'll happily adapt to its removal. I won't hold my breath.\n\nIt seems to be a unique attribute of computers that we expect *everything* to be dead simple to pick up and use. Oh, figuring out the right way to configure Node took you *a whole hour*? Boo hoo, go watch how long it takes a crane operator to be ready to use a different model of crane.\n\nIt's indeed cathartic to complain and dream about the demise of projects that are making your life difficult, but at the end of the day those that are a net negative value *do* eventually die off."], [14, "> [...] if you spend time configuring your window manager or editor, [...] if you are doing anything beyond just solving the problem - you don't understand how fucked the whole thing is.\n\n> The only thing that matters in software is the experience of the user.\n\nUnless that user is a programmer, apparently, in which case their experience doesn't matter either."], [10, "I'm not sure what point the author is trying to make.\n\nAre some things overly complicated?  Yes.  However, a lot of the complexity and messiness is actually due to people not caring about the implementation and just focusing on getting something out there that works.  If you're facing the choice between building on some old system in a non-elegant way, or re-writing the old system from scratch, it often makes sense to choose the former.\n\nAlso, often things are complicated to accommodate use cases for other people.  Just because you want to use some tool in one way doesn't mean everyone will.  And maybe you'll have to read a bit about how to configure it.  It doesn't mean its a bad tool - it just probably wasn't invented to serve your specific need exactly.  "], [9, "[deleted]"], [6, "I almost lost it at \"details of a programming language\" followed by \"if NaN does or does not equal NULL\"."], [5, "I go out of my way to statically build all the software I make public.  Telling people to install dependencies or bundling dependencies that may interfere with previously installed dependencies is bad UX."], [4, "In my experience, the starting point of unnecessary complexity comes from abstraction, and the inability for one person to see the full picture of a project or software or solution. No matter how much you plan and design a project, you'll never catch every use case, exception, and direction the project may at some point have to support. Because of this, there will come a point where a system you previously created is now at a crossroads where it can't support a new feature you need it to using only foundations you already have. When this happens, new layers are added that increase the complexity of the system, of in a way that's unnecessary had you written your initial system in a different way. Now, a rational thing to say is that the foundation should be rewritten at that point, and it should. However, if this were the solution in every case that this happened, no code would ever stay written and would constantly be in limbo being rewritten. That's just not how the world functions unfortunately. In code, as in life, we are in a constant balancing act between building on things that came before us, and in some cases rebuilding them from scratch to handle new challenges in the current moment."], [2, "He has some good points but also some weaker points.\n\n\"The complexity was not contained. Instead I deal with DBus and /usr/lib and Boost and ioctls\"\n\nWell. Boost is because of C++ being so complex that it needs to absorb the world.\n\nDbus is the shit that eventually led to systemd which is even more shit.\n\nThe principle UNIX idea is fine. Everything is a file. Pipe your data and manipulate it.\n\nIt did not translate well into GUIs, mostly because nobody was really integrating \nthings cleanly. Where were object-oriented pipes? Some crappy part of Microsoft hmmm.\nNothing on unix really. Hmmmm. And a lot of inertia too.\n\nAs for /usr/lib, well - GoboLinux and nixos. I like the idea in gobolinux more because it\nis simpler, but the nixos concept is more advanced and ultimately more \"durable\". Just\nnot simple.\n\nYou also can not only just do \"simple\" software. Look at the libreoffice suite. It has a\nlot of features. How could you do it in a simple way anyway? Abiword? But only few\nuse abiword these days. Libreoffice attracts more people.\n\ncgit.freedesktop.org/libreoffice/core/log/\n\n\"and dpkg and autoconf\"\n\nWell, don't use dpkg - it is crap. And uses perl.\n\nMost package managers are crap and extremely specific to any particular distribution.\n\nAutoconf is absolutely horrid but what is the alternative? Cmake has other problems.\n\nWhat is more useable.... ./configure --prefix=/usr or the cmake -D_PREFIX_SOMETHING=/usr .\n\nI can not even remember the latter.\n\n\"Not only do you have to understand $LD_LIBRARY_PATH to make your system work\"\n\nNo you don't. Use Gobolinx - ok, it is not really healthy anymore but years ago that would\nhave been fine. The problem is that the distributions are built around the awful FHS, which\noriginated out of laziness because typing \"cd /usr\" or just \"/usr\" TAB is so much easier.\nIncluding the C language with its #include /usr/include whatever. That design arose out of\nLAZINESS. Whoever was the first, was the lazy one. Then others who were lazy copied\nfrom it. \n\n\"There will come a point where the accumulated complexity of our existing systems is greater\nthan the complexity of creating a new one.\"\n\nYah well. You heard the people say that for years. Welcome to systemd where people inflate\ntheir egos AND sell their knowledge.\n\nThis is how things \"evolve\" in Linux.\n\n\"you just don't yet understand how utterly fucked the whole thing is\"\n\nNo I understand it very well. But to who would I be preaching? I use Ruby and Ruby is just\nlike the original UNIX philosophy. Everything is a file. Everything is an object.\n\nNow I just need to combine all of this and everything is magic. And beautiful. (If I'd just\nhave the time to do it all myself.)\n\n\"if you spend time configuring your window manager or editor\"\n\nNo I don't. I usually try to find out where the shitty window manager keeps configuration\noptions stored. Then I use ruby scripts to either autogenerate config files, out of \nyaml files for me. Or just keep a backup of the config files that I use (and have ruby\ncopy these to the correct files). But in fairness, I tend to use fluxbox mostly and fluxbox\nis fairly simple. \n\nAs for editors, thankfully I abandoned vim many years ago, after having used it for years.\n\nI never regretted it. I still have a lot of fun with the emacs versus vim war since both\neditors are so utterly useless yet there are people out there who think that emacs is\nbetter than vim. When we all know that vim is better than emacs. Plus, why compare\nan operating system with an archaic editor anyway?"], [3, "It's the same with any environment. \n\nInstead of Linux/C/Node, I fight with Java weirdness, broken maven dependencies, JRE weirdness, badly signed certificates, broken REST APIs, database resource issues, Spring problems, ...\n\nAny kind of programming is complex."], [1, "....And if you can't maintain the users codebase when they ask for changes then their fucked because you didn't care about those other things."], [0, "Rants like this cause me to reflect on the fact that a $500 smart phone is orders of magnitude more powerful than a $10K workstation computer from just 10-15 years ago, yet computers are not dramatically easier to program. It can still take hours to compile a large code base. Loading a particularly bad web page can slow the browser to a crawl. A fancy IDE still takes 10 minutes to index a not particularly large project \u2014 on a machine with solid state storage no less.\n\nIt's surprising to me that no matter how fast, or well equipped modern computers are, they still aren't really making our lives as developers much easier. Indeed it seems that some areas in particular such as web programming, it's much _harder_ to do software development.\n\nStrange times..."], [0, "This is seriously a great message to developers about how to develop stuff.\n\nIf you ever think of adding complexity like `\\N{CHECK MARK}` to a string in your code. Stop.\n\nIf you want to know how your language of choice works, because it allows you to prevent bugs occuring before they happen. Stop, don't do that.\n\nThinking about statically/dynamically linking? And the trade off between being able to rely on the distro's security patches vs portability? amongst so many other issues? Stop, just stop.\n\n/s\n\n- - -\n\nedit: politeified my sarcasm, also wow harsh crowd, apparently thinking an article is wrong is bad now. edit2: wow im back"], [-1, "More of this!"]], [[{"comment": "Meh, I don't get the point of this rant. Nobody likes unnecessary complexity. Go ahead and find me ten programmers that can agree some piece of complexity is indeed unnecessary and I'll happily adapt to its removal. I won't hold my breath.\n\nIt seems to be a unique attribute of computers that we expect *everything* to be dead simple to pick up and use. Oh, figuring out the right way to configure Node took you *a whole hour*? Boo hoo, go watch how long it takes a crane operator to be ready to use a different model of crane.\n\nIt's indeed cathartic to complain and dream about the demise of projects that are making your life difficult, but at the end of the day those that are a net negative value *do* eventually die off.", "id": "d2z4mmx"}, {"comment": "> ..but at the end of the day those that are a net negative value do eventually die off.\n\nThey don't though. This node-is-cancer post is from 2011 but Node has done nothing but metastasize since then.", "id": "d2z88je"}, {"comment": "If you take my grandparent's post as truth, and note that Node is still around, then that can only mean that Node's net worth is not negative.", "id": "d2zenpn"}, {"comment": "Lots of things that are a net negative are still around: MongoDB, MySQL, Javascript, Safari, Real Player, QuickTime, I really like the OP's sentiment on this - we've kind of been drowning in our own feces for decades.", "id": "d2zfbjh"}, {"comment": "I like javascript.", "id": "d2zhq35"}, {"comment": "Your bias shows. This could also be read as a C/glib/Boost/Unix-is-cancer post.", "id": "d2zf1am"}, {"comment": "[deleted]", "id": "d2zh6dm"}, {"comment": "gfody's bias. As far as I know, gfody did not author the article.", "id": "d2zhcbm"}], [{"comment": "> [...] if you spend time configuring your window manager or editor, [...] if you are doing anything beyond just solving the problem - you don't understand how fucked the whole thing is.\n\n> The only thing that matters in software is the experience of the user.\n\nUnless that user is a programmer, apparently, in which case their experience doesn't matter either.", "id": "d2z5src"}], [{"comment": "I'm not sure what point the author is trying to make.\n\nAre some things overly complicated?  Yes.  However, a lot of the complexity and messiness is actually due to people not caring about the implementation and just focusing on getting something out there that works.  If you're facing the choice between building on some old system in a non-elegant way, or re-writing the old system from scratch, it often makes sense to choose the former.\n\nAlso, often things are complicated to accommodate use cases for other people.  Just because you want to use some tool in one way doesn't mean everyone will.  And maybe you'll have to read a bit about how to configure it.  It doesn't mean its a bad tool - it just probably wasn't invented to serve your specific need exactly.  ", "id": "d2z50dc"}], [{"comment": "[deleted]", "id": "d2z2txz"}, {"comment": "I wanted to create my own operating system as a kid, because yeah.\n\nThen I grew up and realized that I'm not smart/capable enough to accomplish this.", "id": "d2z5z1v"}, {"comment": "Clearly TempleOS is the answer.", "id": "d2zcojj"}, {"comment": "There was GoboLinux, but I don't know how far they really got.", "id": "d2z66tf"}, {"comment": "Getting rid of the [FHS](https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard) was pretty awesome in GoboLinux. Too bad none of the common distributions took that path. ", "id": "d2z6c5t"}, {"comment": "[deleted]", "id": "d2z6y0h"}, {"comment": "Oh yes, I love Homebrew. Too bad Linuxbrew doesn't have as many packages as distros :-/", "id": "d2z7dev"}, {"comment": "Or NixOS. ", "id": "d2z8q5z"}, {"comment": "Semi relevant xkcd:  http://xkcd.com/927/\n\n", "id": "d2z4l11"}, {"comment": "Also semi relevant xkcd: http://xkcd.com/1425/", "id": "d2z69ai"}, {"comment": "try a bsd. New problem is 80 percent of linux stuff builds and 20 % wont or hangs or something.", "id": "d2zbgvy"}, {"comment": "[deleted]", "id": "d2zcpb1"}, {"comment": "And what has escaped from this? Nothing? So you really do mean start from scratch? Or is there ANYTHING that exists that is not a pile of wank in your opinion?\n", "id": "d2zd7nc"}, {"comment": "Dreams of grandeur. I'm willing to bet/guess your main problem would be an unfinished shitty operating system. ", "id": "d2zbjsa"}, {"comment": "[deleted]", "id": "d2zcnpq"}, {"comment": "Have at it then mate, and let us know when it's done. I was thinking about the effort required rather than your capability.", "id": "d2zqmxd"}, {"comment": "Or, you can realize that the hardware and software we have achieved is freaking amazing. Room for enhancement, of course, but it's not reasonable to be so high and mighty about it. ", "id": "d2zd79b"}], [{"comment": "I almost lost it at \"details of a programming language\" followed by \"if NaN does or does not equal NULL\".", "id": "d2z5fvx"}], [{"comment": "I go out of my way to statically build all the software I make public.  Telling people to install dependencies or bundling dependencies that may interfere with previously installed dependencies is bad UX.", "id": "d2z922p"}, {"comment": "Yep, same here. Static binaries are also much faster since you can inline across functions. ", "id": "d2zdd3n"}], [{"comment": "In my experience, the starting point of unnecessary complexity comes from abstraction, and the inability for one person to see the full picture of a project or software or solution. No matter how much you plan and design a project, you'll never catch every use case, exception, and direction the project may at some point have to support. Because of this, there will come a point where a system you previously created is now at a crossroads where it can't support a new feature you need it to using only foundations you already have. When this happens, new layers are added that increase the complexity of the system, of in a way that's unnecessary had you written your initial system in a different way. Now, a rational thing to say is that the foundation should be rewritten at that point, and it should. However, if this were the solution in every case that this happened, no code would ever stay written and would constantly be in limbo being rewritten. That's just not how the world functions unfortunately. In code, as in life, we are in a constant balancing act between building on things that came before us, and in some cases rebuilding them from scratch to handle new challenges in the current moment.", "id": "d2zdycl"}], [{"comment": "He has some good points but also some weaker points.\n\n\"The complexity was not contained. Instead I deal with DBus and /usr/lib and Boost and ioctls\"\n\nWell. Boost is because of C++ being so complex that it needs to absorb the world.\n\nDbus is the shit that eventually led to systemd which is even more shit.\n\nThe principle UNIX idea is fine. Everything is a file. Pipe your data and manipulate it.\n\nIt did not translate well into GUIs, mostly because nobody was really integrating \nthings cleanly. Where were object-oriented pipes? Some crappy part of Microsoft hmmm.\nNothing on unix really. Hmmmm. And a lot of inertia too.\n\nAs for /usr/lib, well - GoboLinux and nixos. I like the idea in gobolinux more because it\nis simpler, but the nixos concept is more advanced and ultimately more \"durable\". Just\nnot simple.\n\nYou also can not only just do \"simple\" software. Look at the libreoffice suite. It has a\nlot of features. How could you do it in a simple way anyway? Abiword? But only few\nuse abiword these days. Libreoffice attracts more people.\n\ncgit.freedesktop.org/libreoffice/core/log/\n\n\"and dpkg and autoconf\"\n\nWell, don't use dpkg - it is crap. And uses perl.\n\nMost package managers are crap and extremely specific to any particular distribution.\n\nAutoconf is absolutely horrid but what is the alternative? Cmake has other problems.\n\nWhat is more useable.... ./configure --prefix=/usr or the cmake -D_PREFIX_SOMETHING=/usr .\n\nI can not even remember the latter.\n\n\"Not only do you have to understand $LD_LIBRARY_PATH to make your system work\"\n\nNo you don't. Use Gobolinx - ok, it is not really healthy anymore but years ago that would\nhave been fine. The problem is that the distributions are built around the awful FHS, which\noriginated out of laziness because typing \"cd /usr\" or just \"/usr\" TAB is so much easier.\nIncluding the C language with its #include /usr/include whatever. That design arose out of\nLAZINESS. Whoever was the first, was the lazy one. Then others who were lazy copied\nfrom it. \n\n\"There will come a point where the accumulated complexity of our existing systems is greater\nthan the complexity of creating a new one.\"\n\nYah well. You heard the people say that for years. Welcome to systemd where people inflate\ntheir egos AND sell their knowledge.\n\nThis is how things \"evolve\" in Linux.\n\n\"you just don't yet understand how utterly fucked the whole thing is\"\n\nNo I understand it very well. But to who would I be preaching? I use Ruby and Ruby is just\nlike the original UNIX philosophy. Everything is a file. Everything is an object.\n\nNow I just need to combine all of this and everything is magic. And beautiful. (If I'd just\nhave the time to do it all myself.)\n\n\"if you spend time configuring your window manager or editor\"\n\nNo I don't. I usually try to find out where the shitty window manager keeps configuration\noptions stored. Then I use ruby scripts to either autogenerate config files, out of \nyaml files for me. Or just keep a backup of the config files that I use (and have ruby\ncopy these to the correct files). But in fairness, I tend to use fluxbox mostly and fluxbox\nis fairly simple. \n\nAs for editors, thankfully I abandoned vim many years ago, after having used it for years.\n\nI never regretted it. I still have a lot of fun with the emacs versus vim war since both\neditors are so utterly useless yet there are people out there who think that emacs is\nbetter than vim. When we all know that vim is better than emacs. Plus, why compare\nan operating system with an archaic editor anyway?", "id": "d2z7usc"}, {"comment": "Gilded you. Now reformat those quotes with `>` so people can read your response. \n\n>Like this.", "id": "d2zdamx"}], [{"comment": "It's the same with any environment. \n\nInstead of Linux/C/Node, I fight with Java weirdness, broken maven dependencies, JRE weirdness, badly signed certificates, broken REST APIs, database resource issues, Spring problems, ...\n\nAny kind of programming is complex.", "id": "d2zbsr2"}], [{"comment": "....And if you can't maintain the users codebase when they ask for changes then their fucked because you didn't care about those other things.", "id": "d2zeyzt"}], [{"comment": "Rants like this cause me to reflect on the fact that a $500 smart phone is orders of magnitude more powerful than a $10K workstation computer from just 10-15 years ago, yet computers are not dramatically easier to program. It can still take hours to compile a large code base. Loading a particularly bad web page can slow the browser to a crawl. A fancy IDE still takes 10 minutes to index a not particularly large project \u2014 on a machine with solid state storage no less.\n\nIt's surprising to me that no matter how fast, or well equipped modern computers are, they still aren't really making our lives as developers much easier. Indeed it seems that some areas in particular such as web programming, it's much _harder_ to do software development.\n\nStrange times...", "id": "d2zl6rv"}, {"comment": "> a $500 smart phone is orders of magnitude more powerful than a $10K workstation computer from just 10-15 years ago,\n\nWrong. \n\n * 15 years ago you could buy a Pentium III Tualatine-based computer for about $1000. With clock rate of 1-1.4 GHz and a single core, it was probably slower than your smart phonem but not an order of magnitude slower.\n * 10 years ago you could buy a Core 2 Duo-based computer for $500-$1000. With 2+ GHz and two cores it might be actually more powerful than your smartphone. If that's not enough there were also quad-core CPUs for a slightly higher price.\n\n> yet computers are not dramatically easier to program.\n\nWrong. They are, thanks to node.js. <ducks>\n\nPlease hear me out. 10-15 years ago I was using C++ on Windows. To start programming you have to install Visual Studio, that alone takes maybe an hour. Then you need to install libraries. It's usually a huge PITA: you might need to compile a library manually. It might be for a different version of VS, then you need to convert the project. You need to configure paths and so on.\n\nSetting up a project can easily take a day...\n\nNow with node.js... installing node.js on Linux takes like 30 seconds. You get it with a package manager. You download your project and run `npm install`, which automatically installs all dependencies. So in two minutes your project is up and running. That feels like magic.\n\nTwo minutes vs two days. It's dramatically easier now.\n\nMoreover, a C++ project with hundreds of dependencies sounds borderline impossible. Certainly there are projects like that, but they have dedicated 'build' teams which take care of dependency and build management.\n\nWith node.js you can easily run a project with hundreds of dependencies (it is in fact pretty common) and you don't need a dedicated team to manage it, it is all managed automatically by npm.\n\n> . It can still take hours to compile a large code base.\n\nThat's because you keep using outdated shit like C++. <ducks>\n\n> Indeed it seems that some areas in particular such as web programming, it's much harder to do software development.\n\nWeb programming have changed a lot. 15-20 years ago web programming was mostly things like guestbooks. The shit you can now write in 15 minutes.\n\nWeb apps are now as complex as desktop apps, or sometimes even more complex. No wonder it feels harder.\n\n", "id": "d2zp5m2"}], [{"comment": "This is seriously a great message to developers about how to develop stuff.\n\nIf you ever think of adding complexity like `\\N{CHECK MARK}` to a string in your code. Stop.\n\nIf you want to know how your language of choice works, because it allows you to prevent bugs occuring before they happen. Stop, don't do that.\n\nThinking about statically/dynamically linking? And the trade off between being able to rely on the distro's security patches vs portability? amongst so many other issues? Stop, just stop.\n\n/s\n\n- - -\n\nedit: politeified my sarcasm, also wow harsh crowd, apparently thinking an article is wrong is bad now. edit2: wow im back", "id": "d2z5ecc"}, {"comment": "wot", "id": "d2z5tdc"}, {"comment": "don't worry I changed it, so its englisher", "id": "d2z5vvt"}, {"comment": "Poor author just wants to create something complex without having to deal with complexity :p", "id": "d2z9cdq"}, {"comment": "I upvoted you because your nick has ruby in it and also because they are bullying you.\n\nI don't agree with all points of the original author either. But a few comments are perfectly fine.\n\nHe should write more though. There is not a lot of intrinsic explanation as to why something sucks.", "id": "d2z7wfw"}, {"comment": "actually my name is a reference to MLP, not the programming language\n\nmore downvotes please", "id": "d2z8myg"}], [{"comment": "More of this!", "id": "d2z30kj"}]]], "5fp3u8": ["A curated awesome list of lists of interview questions.", "2016-11-30 14:24:52", 400, "https://github.com/MaximAbramchuck/awesome-interview-questions", [[275, "Hm, I'm JavaScript dev. Let's see what they have for me. \"[Top 85 JavaScript Interview Questions ](http://career.guru99.com/top-85-javascript-interview-questions/)\". \n\n> Between JavaScript and an ASP script, which is faster?\n\n> JavaScript is faster. JavaScript is a client-side language and thus it does not need the assistance of the web server to execute. On the other hand, ASP is a server-side language and hence is always slower than JavaScript.  Javascript now is also a server side language (nodejs).\n\n\nVery curated, very awesome, wow."], [220, "> 2. Name and describe a different Linux/Unix command for each letter of the alphabet. But also, describe how a common flush toilet works.\n\nRight - I'd like to smack this curator upside the head with a shovel"], [208, "You mean a curated list of SHITTY interview questions?"], [169, "Oh, this should be quite successful. We all know how much reddit loves lists of resources that they can save, and (at least in my case) never come back to. Thanks, OP"], [160, "I'm sorry, this is shit. I clicked on the first set of C interview questions, just out of curiosity, and found this:\n\n> How do you construct an increment statement or decrement statement in C?\n\nMaybe you're interviewing different coders than I am, but if I find myself seriously wondering whether you even know how to increment something, I think we can safely end the conversation right there. Thank you for your time, but this isn't a good fit.\n\n> Some coders debug their programs by placing comment symbols on some codes instead of deleting it. How does this aid in debugging?\n\nSeriously? Not only are we asking \"why would you comment things out while debugging\", but you phrase it as \"placing comment symbols on some codes\"?\n\n>  Can I use \u0093int\u0094 data type to store the value 32768? Why?\n\n> Answer:No. \u0093int\u0094 data type is capable of storing values from -32768 to 32767.\n\nWhile, yes, I concede that int is only required to be able to store 16-bit values, systems on which int is less than 32 bit are a rarity in today's world. There's a big difference between \"this might not work on embedded systems\" and \"no, you can't do that\". If you want to know whether the interviewee knows the required range of int according to the C spec, then *ask him that*.\n\n> Can two or more operators such as \\n and \\t be combined in a single line of program code\n\nTHOSE AREN'T OPERATORS JESUS FUCKING CHRIST\n\n> What is wrong in this statement?  scanf(\u0093%d\u0094,whatnumber);\n\n> Answer: An ampersand & symbol must be placed before the variable name whatnumber. \n\nAnd here I thought the missing quotes around %d were the problem. And given that you don't show the declaration of `whatnumber`, how am I supposed to know that isn't a pointer in the first place?\n\n> How do you generate random numbers in C?\n\nWell, I'd probably use a well-tested library such as Mersenne Twister, or maybe a... oh. You want me to say \"rand()\". Ok.\n\n> What is wrong with this statement? myName = \u0093Robin\u0094;\n\n> Answer:You cannot use the = sign to assign values to a string variable. Instead, use the strcpy function. The correct statement would be: strcpy(myName, \u0093Robin\u0094);\n\nUhh. Ok. I was going to write up a scathing critique of just how dumb this is, starting with the fact that there is no such thing as a \"string variable\" in C, but... I give. I'm stopping here. I lack the strength to finish."], [54, "What's it curated by, a regex? Here's the first link I followed for Postgres questions: http://nazafbtemplate.blogspot.co.uk/2014/06/frequently-asked-basic-postgresql.html"], [46, "How long until we get a curated list of lists of lists of interview questions?"], [35, ">Write a program to show the singleton pattern used in python.\nSingleton patter is used to provide a mechanism that limits the number of instances that can be used by one class. It also allows the same object to be shared between many different parts of the code. This allows the global variables to be used as the actual data that is used is hidden by the singleton class interface. The singleton class interface can have only one public member and one class method Handle. Private constructors are not used to create an object that is used outside the class. The process waits for the static member function to create new instances and return the singleton object.\nThe code that is used to call the singleton object is:\n\n    Singleton& Singleton::Handle()\n    {\n       if( !psingle )\n       {\n           psingle = new Singleton;\n       }\n       return *psingle;\n    }\n\nI..... what?"], [38, "Over the past five years, I have developed a set of heuristics I would like to believe help me wade through the enormous range of programming resources I am bombarded with every day. They are simple rules of thumb to help sort the wheat from the chaff. I am of course but a journeyman, not a master, and I cannot say these heuristics shall always hold true. And I use them sceptically - we must always be vigilant that the habits and prejudices we establish do not wall us off from fresh perspectives and new ways of thinking.\n\nNevertheless, I think there is one heuristic I can bet on safely. It is this:\n\n> All programming articles whose titles employ the word 'awesome' are hot, molten clumps of real human excrement\n\nThe second I would tender to this community is as follows:\n\n> The self-serving arrogance and self-assuredness of the term 'curated' indicates the the author is a purveyor of hot, molten clumps of real human excrement.\n\nAnd a final, tentative rule of thumb I have alighted upon over the years:\n\n> Any company that interviews engineers using 'language pearls' questionnaires is hopelessly unqualified to manage them. Any job there will be akin to lowering your head into a pneumatic tube firing hot, molten clumps of real human excrement."], [24, "Had a look at some of the lists for C. One of the questions was \"Write a program that outputs \"Hello World\" without using a semi-colon\".\n\nWhy would you ever need to do that to solve a real problem? Although, I suppose it tests your problem solving skills...\n\nFor reference, a possible solution:\n\n    #include <stdio.h>\n    int main() {\n        if (printf(\"Hello World!\\n\")) {}\n    }"], [23, "That this is #1 on /r/programming this morning sort of highlights exactly why I don't visit this sub much anymore. I'm only here now because I clicked through to this post from the front page.\n\nAlso, most of the best discussions are posted here hours after they're posted on HN.\n\nIn before \"Unsubscribe then\"."], [13, "Hmmm. Let's see, for Java\n\n> 20 Essential Java Interview Questions\n\nhttp://www.toptal.com/java/interview-questions\n\nFirst thing they do is ask me a billion questions about my name, my company's name, who I am trying to hire, my email, my skype name... Nope.\n\nNot curated. Not reasonable. Useless list."], [13, "> **What does ruby name refers to?**\n\n> * Ruby names refer to the classes, variables, methods, constants and modules that help in the creation of the program. \n>\n> * These are the names that distinguish other names with the specified ruby names that are being mentioned above.\n> * Ruby names are useful and used to be written as it is shown. They are useful in the context of writing the programs and while generating the module. \n> * Ruby names refer to the classes that has to be built and through which the objects will be declared, and methods that will perform on the data that is given.\n> * The names are reserved such that they can\u2019t be used anywhere else and for any other purpose. The name that is used can be in lower or upper case, letter, number or an underscore.\n\nThis made me stupider.\n"], [14, "I had a cursory glance at the C++ questions, and I feel like a lot of what is asked is technicalities about the language and none of which helps you understand if the candidate can write or design good software."], [12, "it s shit"], [12, "One of the C++ ones:\n\n> Do you think the following code is fine? If not, what is the problem?\n\n> T *p = 0;\n> delete p;\n\n> \\- No, the code has a problem. The program will crash in an attempt to delete a null pointer.\n\nWhat ? No it won't..."], [12, "Looking at some of the languages I am proficient in, I can honestly say the \"curator(s)\" do not understand the languages in question.  Stop up-voting this crap."], [10, "I read some java interview questions and they were crap, considering how people from the other languages are complaining I'd say a removal of the \"awesome\" seems fitting"], [7, "Followed through to the first list of Python questions: [Python interview questions and answers - freshers, experienced](http://www.careerride.com/python-interview-questions.aspx)\n\nFirst of all, 100% of the code examples are formatted incorrectly. Is part of the prep fixing their examples?\n\nThe author is universally unclear, ere are some good examples:\n\nWhat are the ways to write a function using call by reference?\n\n* In the function?  Call the function by reference? What the writer actually means is \"How can you write a function that takes a reference to an object as its argument?\"\n\nHow can the ternary operators be used in python?\n\n* They can't, Python has no ternary operator.  It has a logical expression with similar results, which is what the author mentions.\n\nHow the string does get converted to a number?\n\n* Typically when asked this question, I would expect the interviewer to want some insight into how the actually code works - i.e. the \"How\".  The question the author answers here is \"What should you do to convert a string to a number?\"\n\nPast this point in the article the questions look like copy/pasted code from the internet combined with literally nonsensical questions and answers.\n\nPerhaps the later entries are better, couldn't be bothered to look any further."], [4, "OK I am not a programmer per trade but I found this in one of the question involving C++\n\n> Which type is best suited to represent the logical values?\n> \n> a) integer\n> \n> b) boolean\n> \n> c) character\n> \n> d) all of the mentioned\n\nI would say depending on the situation a and b.\n\nSince an int can be evaluated like a bool as false if 0 and true if different than 0 one can associate different instances of success or failure to an int, since by default if( var ) is equivalent of if( var!=0 )\n\nPlus, from personal experience, maybe because I am terrible at coding, in some cases vector<bool> might not be great because the structure is adapted for low memory footprint by getting only one bit per entry in the vector, which depending on the machinery that you have around, might cause issues."], [4, "> Which is used to tell the computer that where a pointer is pointing to?"], [4, "I took a look and agree with the general sentiment here that what I saw was... less than good. But I didn't downvote it for one reason: real-life employers actually ask these questions and it's handy to know answers to some of the weird ones. Something something \"but if they ask silly questions the job can't be that good\" I hear someone say. Not true. For some reason really competent engineers at good companies I'd like to work for still ask reaaaaaly bad interview questions.\n\nI think it's akin to the problem I see with people teaching natural languages: they always seem to teach a language they don't speak themselves in daily life, only in polite circumstances (think a speech). Then the student goes into a pub after a year of learning, say, German, and doesn't understand anything anyone says."], [5, "Here's a good interview question:\n\n\"Tell me about the most interesting thing you worked on or most interesting problem you had to solve?\"\n\nAnd then discuss.\n"], [3, "\"Would you rather fight one horse-sized duck, or 100 duck-sized horses?\""], [3, "Is there a curated awesome list of curated awesome lists?"], [3, "Wow, these are really bad. "], [3, "Everyone (including myself) agrees this list is shit. Which demands this question: is there a non-shit curated list like this?"], [3, "This list isn't curated..."], [2, "and of all the things programmers and redditors need, nothing about soft skills."], [2, "SQL Lite. "], [1, "Some of the C# questions were good. "], [2, "I would like to see a list of interview excercises, or do-it-at-home excercises to give to an interviewee. Excercises are often more useful and give a better indication of one's skills then some interview questions or quiz."], [2, "This isn't a curated list. It's just a list of hundreds of links to hundreds of questions. No commentary whatsoever. Useless. "], [2, "OP forgot a /s at the end of the title.\n"], [2, "Lots of mistakes in the \"C\" list.  Small errors, outdated assumptions, typos that would change the context.\nI have not looked into the rest yet.\n"], [2, "> 21) What is wrong with this statement? myName = \u0093Robin\u0094;\n\n>Answer:You cannot use the = sign to assign values to a string variable. Instead, use the strcpy function. The correct statement would be: strcpy(myName, \u0093Robin\u0094);\n\nWho said it was a string? I see no declarations of either of those fields, for all I know they were defined with scalar types and are perfectly valid."], [1, "Checked out the C# ones, I can see some of them being useful.\n\nI find these questions are very subjective. It's more much interesting and engaing if you pair programme with the interviewer and attempt to solve a problem together.\n\nThat establishes whether or not you can problem solve and pair with another programmer which would show some semblance of interpersonal skills."], [1, "Curated."], [1, "Looking at some of the languages i was like \"Fuck yea. I know these stuff so i can get a job\" came to the comments...i see i was wrong."], [1, "maybe good for studying to answer interviewer's bad questions, but don't ask these yourself"], [1, "So as a learning developer I have no idea why this is apparently a terrible list, having never interviewed. Can anyone point me to an actually awesome list of interview questions instead? (Note: I'm learning C# and .Net) "], [1, "[\"I've never killed a man.\"](https://www.youtube.com/watch?v=ngu0RKsv3qE&t=30s)"], [1, "Well, why all of this hate on this post? I'm not a professional programmer, I'm phd student and I use python in my daily work. I found some of the [related questions](https://www.toptal.com/python/interview-questions) really interesting."]], [[{"comment": "Hm, I'm JavaScript dev. Let's see what they have for me. \"[Top 85 JavaScript Interview Questions ](http://career.guru99.com/top-85-javascript-interview-questions/)\". \n\n> Between JavaScript and an ASP script, which is faster?\n\n> JavaScript is faster. JavaScript is a client-side language and thus it does not need the assistance of the web server to execute. On the other hand, ASP is a server-side language and hence is always slower than JavaScript.  Javascript now is also a server side language (nodejs).\n\n\nVery curated, very awesome, wow.", "id": "dam10ww"}, {"comment": "Today I learned that 227 people clicked the upvote button before looking at any of the questions on this \"curated\" list.", "id": "dam4abq"}, {"comment": "I just looked at languages I am proficient in and found *glaring* errors and grammar/spelling issues.  It's fucking useless.", "id": "dam57be"}, {"comment": "OMG the real fear/danger here is that \"tech recruiters\" will use this list.\n\nIf you give a (correct) answer that is not exactly the same as what they see on this list, \"Sorry\".\n\nThey really need to put this on wikipedia or some better site where experts can evolve it closer towards truth.  Github isn't nearly as fluid in that process.", "id": "dam7zrc"}, {"comment": "Any company who picks recruiters that are that dumb is going to have equally stupid people in engineering roles since their hiring process isn't screening out the right candidates. Such a company is not one I want to work for anyway.", "id": "dame3fm"}, {"comment": "Amen", "id": "damncyb"}, {"comment": "Well, trying be fair, it has 11K stars on GitHub, a thousand of forks and 45 contributors.\n\nIt may become ~~not shit~~ better one day, who knows.\n\n", "id": "damgt3i"}, {"comment": "With something this bad, it's better to just start afresh.", "id": "dami0e3"}, {"comment": "Sure. And some day a million monkeys will finally bash out the script to Hamlet.", "id": "damjfvh"}, {"comment": "In the meantime, an endless supply of Perl scripts are being produced.", "id": "dang672"}, {"comment": "Still rising. Maybe there's enough good questions in there that people might find it useful. I doubt it though.", "id": "damk3p8"}, {"comment": "How about [Top 20 GO Programming (Golang) Interview Questions & Answers](http://career.guru99.com/top-20-go-programming-interview-questions/):\n\n> **2) What is syntax like in GO?**\n\n> Syntax in GO is specified using Extended Backus-Naur Form (EBNF)\n\n> Production = production_name \u201c=\u201d [ Expression ]  \n> Expression = Alternative { \u201cl\u201d Alternative }  \n> Alternative = Term { Term }  \n> Term = Production_name l token [ \u201c\u2026\u201dtoken] l Group l Option l Repetition  \n> Group = \u201c ( \u201c Expression\u201d)\u201d  \n> Option = \u201c [ \u201c Expression \u201c ]\u201d  \n> Repetition = \u201c {\u201c Expression \u201c}\u201d\n\nSome obvious problems:\n\n1. Nobody capitalizes it as \"GO\", which immediately puts the author's experience into question.\n2. The answer provided is a definition of EBNF syntax itself and completely unrelated to Go.\n3. Even if the answer had been the syntax for Go, it wouldn't offer any insight into your ability to write Go, which is why nobody will ask you this question.", "id": "dam3u6b"}, {"comment": "Also, nobody would ask this in an interview.\n\nWait... some idiot in HR would ask this after finding the question on a \"curated list of awesome interview questions\".\n\nIf somebody did ask, I would just say its syntax was in the C-style family of languages.", "id": "dam74t6"}, {"comment": "It's disturbing to me that someone even thought of this question.", "id": "dame5dv"}, {"comment": "If some jackass asked me to write EBNF syntax for language X during an interview it would be interview over. I've fielded all sorts of idiotic whiteboard questions before - from writing programs in brainfuck to counting missing numbers in near infinite lists - but that would be my breaking point. \n\nHell, throw the entirety of programming pearls at me if it makes you feel like more of a man, I can take it. Just don't expect me to get the syntax right every time.", "id": "dam8t96"}, {"comment": "\"near infinite lists\"...?  I imagine that would nearly take a pretty long time.\n", "id": "dam9o0x"}, {"comment": "You're thinking inside the box. You need to switch up some paradigms, show you're a team player, and solve this problem. BTW I've just decided I'm not going to hire you and this is now being done for my amusement... and I'm bored... you can tell because I'm yawning and talking in a tone that suggests I think you're inferior to me.", "id": "damawv9"}, {"comment": "> Is it possible to break JavaScript Code into several lines?\n\nWell, I really hope you don't have to put all your JavaScript Code into a single line!", "id": "dam60rr"}, {"comment": "Well, you want to minimize the size of your javascript. And it's not like there's any software to do it, so\n\nFuck, I can't find a way to phrase this joke without it sounding too real.", "id": "dam6gjx"}, {"comment": "You don't write your javascript minified from the get-go?!  ", "id": "dambwxf"}, {"comment": "This doesn't surprise me. My first thought after reading the title was \"Wow, 'awesome list of...' is becoming the go-to title for ~~blog~~ github posts and is probably meaningless by now\".\n\n/r/programming doesn't have a whole lot of quality control, likely because the submitted content usually takes a long time to digest, so instead it's upvoted based on titles and initial feelings. I see a ton of really quality content get immediately downvoted here.", "id": "dam6y5e"}, {"comment": "Yeah it's odd.  You'd think that, given the comments, this would be sitting at zero.  Nope, people are up-voting blindly, because they're not even looking at the site, nor the comments.", "id": "dambz4z"}, {"comment": "Wait, you mean the up-arrow isn't a bookmark?", "id": "damiheq"}, {"comment": "That's what the save feature is for. ", "id": "dan6r7s"}, {"comment": "Roll down a little, look at this:\n \n> **69. Write the point of difference between web-garden and a web-farm?**\n \n>Both web-garden and web-farm are web hosting systems. The only difference is that web-garden is a setup that includes many processors in a single server while web-farm is a larger setup that uses more than one server.", "id": "damb2g9"}, {"comment": "I've literally never heard of those expressions. Server farm is the only even remotely similar. I guess I should just fucking quit my job.", "id": "damp8p8"}, {"comment": "\"Web-garden\" is adorable.", "id": "damm1gq"}, {"comment": "You can write asp and asp.net in javascript. ", "id": "dam17oq"}, {"comment": "Wow, they haven't seen truly crappy JS...\n\nBut seriously, I get what they're saying: if there's something that *can* be computed client-side, it's almost certainly going to be faster to do it client-side rather than making one extra request/response cycle to get it, even if the server computes it a lot faster.", "id": "damot0n"}], [{"comment": "> 2. Name and describe a different Linux/Unix command for each letter of the alphabet. But also, describe how a common flush toilet works.\n\nRight - I'd like to smack this curator upside the head with a shovel", "id": "dam255o"}, {"comment": "\"T\", as in \"Thanks for your time, I have other interviews to attend\" - this kind of question just screams \"unprofessional\".", "id": "dam3kxz"}, {"comment": "Have you guys gone to a lot of interviews? This is *exactly* the kind of questions that come up; I would expect the first one in a written exam and the second one asked by the project manager to see how eloquently you can describe a mechanism.\n\nAs for \"thanks for your time\", is the job market really that great again? ", "id": "damf6zr"}, {"comment": "The toilet thing seems like a relative of the \"break down what happens when you enter an URL into your browser\" question, except simpler and for plumbers.", "id": "damgl9c"}, {"comment": "Plumbing Administrators, thankyou.", "id": "damqcer"}, {"comment": "I've done a ton of tech interviews, and never had anything like this. I would definitely TFYT any interviewer that did this to me.\n\nBoth times I've looked for jobs in the past 3 years I've had 3-4 competing offers after about 3-6 months of looking. So that seems pretty good.", "id": "damh5oi"}, {"comment": "Happy to hear about the job market :) \n\nI've never had plumbing questions either, but several baseball- themed ones (luckily, not about baseball itself, but it broke down to statistics).", "id": "damhj5k"}, {"comment": "I mean, statistics and probability are fine questions.", "id": "damhku5"}, {"comment": "> Have you guys gone to a lot of interviews?\n\nI interview for jobs once or twice a year, even if I have no intention of leaving my current job - gotta keep that interview game strong. Besides, maybe they'll offer something too good to pass up, you never know.\n\n>As for \"thanks for your time\", is the job market really that great again?\n\nI have yet to go more than 2-3 weeks without a job offer when I'm actually looking.", "id": "daml09f"}, {"comment": "I'll give you the second one (I've heard variations of that in various \"Google-esque\" interviews, usually in a technical context), but I strongly object to the first one. This is an interview, not a game-show (though I wouldn't be opposed to a programmer gameshow).", "id": "damt4vd"}, {"comment": "> This is exactly the kind of questions that come up\n\nWhere are you interviewing?", "id": "damtxhk"}, {"comment": "Finance in New York. Last major bank I applied to, I talked to *eight* people total who were smitten with me, and one who was not - didn't get the job. Also part of this was a 1 hour written exam.", "id": "dan3x7e"}, {"comment": "The market where I live is certainly good enough for developers to be picky during interviews. I also have never witnessed any questions as stupid as those, but I guess it could happen.", "id": "danowuy"}, {"comment": "I've interviewed at a lot of places and never encountered a question that dumb. And yes, it's absolutely a candidate's market today.", "id": "dao2w02"}, {"comment": "    alias a=\"ls\"\n    alias b=\"ls\"\n    alias c=\"ls\"\n    alias d=\"ls\"\n    alias e=\"ls\"\n    alias f=\"ls\"\n    alias g=\"ls\"\n    alias h=\"ls\"\n    alias i=\"ls\"\n    alias j=\"ls\"\n    alias k=\"ls\"\n    alias l=\"ls\"\n    alias m=\"ls\"\n    alias n=\"ls\"\n    alias o=\"ls\"\n    alias p=\"ls\"\n    alias q=\"ls\"\n    alias r=\"ls\"\n    alias s=\"ls\"\n    alias t=\"ls\"\n    alias u=\"ls\"\n    alias v=\"ls\"\n    alias w=\"ls\"\n    alias x=\"ls\"\n    alias y=\"ls\"\n    alias z=\"ls\"", "id": "damfocy"}, {"comment": "Bonus points if you wrote a shell script to generate those.\n", "id": "damh65z"}, {"comment": "    for i in $(seq 97 122); do printf \"alias \\x$(printf %x $i)='ls'\\n\"; done", "id": "dan5w0i"}, {"comment": "for letter in {a..z}; do alias ${letter}=ls; done", "id": "dan7an6"}, {"comment": "my man!   \n(edit: or my woman, I really don't know)", "id": "damkut8"}, {"comment": "Slow down!", "id": "dampoyk"}, {"comment": "You forgot to describe the works of a common flush toilet.\n\n", "id": "danuha0"}, {"comment": "Awk  \nBz (i feel like this is a command but I'm not sure)  \nCat  \nDd  \nEcho  \nFsck  \nGrep   \nIfconfig  \nJava maybe?  \nKill  \nLs  \nMan  \nNano  \nPs  \nRm  \nSed  \nTmux (not installed by default but still awesome)  \nUniq  \nVim  \nWc  \nYum  \nZip  \n\nThat's all I got\n\nEdit: formatting", "id": "dam3doq"}, {"comment": "You spelled \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\sed\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ wrong. Remember, if there are fewer than 50 backslash escapes, your sed command isn't ready yet.", "id": "dam3zck"}, {"comment": "You can also use various other chars to separate things, I personally like `|`s.", "id": "dam5kyb"}, {"comment": "\\\\|", "id": "dam6rc5"}, {"comment": "Using the extended regex flag to eliminate the need for all of those escapes really boosted my sanity", "id": "dam70s0"}, {"comment": "I always give up, do inline perl instead.\n\nAnd after a week of that, I end up rewriting the entire shell script in perl after telling myself \"it's just a quick and dirty bash script\". It never is.", "id": "dam8rnr"}, {"comment": "I regularly make fun of my one coworker who's a perl fan, but using `perl -i -pe` over `sed` has saved me a lot of sanity...", "id": "dami32g"}, {"comment": "For personal use, I write alot of webscrapers. WWW::Mechanize is... there are no words.\n\nI tried to write one in python once, to give it a chance. But it's not nearly as usable. Not a jab at python, it's serviceable enough when I'm writing plex plugins.", "id": "damip6v"}, {"comment": "I generally use perl too unless it's columns then I just use awk since the syntax is simpler.", "id": "damsatn"}, {"comment": "I'm sorry, but we won't be progressing your application. You failed to explain how a flush toilet works.", "id": "dam48sv"}, {"comment": "Well, you see, when you press the flush button the bowl is flooded with the tears of former applicants for this role. Once Gravity has drained the cistern of the bitter tears of inconsolable sadness it is slowly refilled until a float attached to a mechanical solenoid stems the flow again. \n\nAfter the cistern is at capacity, new tears are simply mashed into the office carpet by HR managers while they write condescending emails telling applicants to study hard and try again in six months if they want a chance to pass the Google-esque interviews used to screen prospective developers who want to work on the in-house shopping cart software written in PHP4 by functionally retarded outsourced programmers in 2004. \n\nThey only hire the best and brightest here, after all. Being able to implement merge sort flawlessly from memory or regurgitate the Sieve of Eratosthenes in brainfuck on a whiteboard is critical to avoiding unexpected T_PAAMAYIM_NEKUDOTAYIMs. Plus they hired that one Google reject years ago and put him in charge of hiring, and... well... does he ever have an axe to grind and something to prove.", "id": "dam9gsc"}, {"comment": "I wish to subscribe to your newsletter", "id": "damat3k"}, {"comment": ">Bz \n\nYou may be thinking of `bc` the calculator", "id": "dam3ycd"}, {"comment": "I was thinking of bz compression. Did not know about the calculator ", "id": "dam5int"}, {"comment": "bzip2", "id": "damgiy5"}, {"comment": "More likely the bzip2 utility for making .bz2 files.", "id": "dam6l5h"}, {"comment": "bzcat\n\nAlso, none of those commands will work unless you make an initial case insensitive command line.", "id": "dam6y3n"}, {"comment": "> not installed by default but still awesome\n\nA lot of other things you mention aren't installed \"by default\" across all Unix and Linux flavors.\n\nThere are basically two baselines you could go by... POSIX (more relevant for Unix) and GNU (more relevant for Linux). ~~OSX doesn't comply with either by default, so there you go.~~ (yeah they do, thanks /u/NSCFType)\n\nFollowing that standard, your incorrect guesses are:\n\nbz fsck ifconfig java nano tmux vim yum zip\n\nThe following is a list of all shell commands that are both in POSIX and GNU (edit, removed if and for which are not really shell commands):\n\nalias\n\nawk\n\nbasename\n\nbc\n\nbg\n\ncal\n\ncat\n\ncd\n\nchgrp\n\nchmod\n\nchown\n\ncksum\n\ncmp\n\ncomm\n\ncommand\n\ncp\n\ncron\n\ncrontab\n\ncsplit\n\ncut\n\ndate\n\ndd\n\ndf\n\ndiff\n\ndir\n\ndirname\n\ndu\n\necho\n\nenv\n\nexpand\n\nexpr\n\nfalse\n\nfg\n\nfile\n\nfind\n\nfold\n\nfuser\n\ngetopts\n\ngrep\n\nhash\n\nhead\n\niconv\n\nid\n\nip\n\njobs\n\njoin\n\nkill\n\nlink\n\nln\n\nlocal\n\nlogname\n\nls\n\nmake\n\nman\n\nmkdir\n\nmkfifo\n\nmore\n\nmv\n\nnc\n\nnice\n\nnl\n\nnohup\n\nop\n\npaste\n\npathchk\n\npr\n\nprintf\n\nps\n\npwd\n\nread\n\nrenice\n\nrm\n\nrmdir\n\nsed\n\nselect\n\nsleep\n\nsort\n\nsplit\n\nss\n\nstat\n\nsu\n\nsum\n\ntail\n\ntee\n\ntest\n\ntime\n\ntouch\n\ntop\n\ntput\n\ntr\n\ntrue\n\ntsort\n\ntty\n\ntype\n\nulimit\n\numask\n\nunalias\n\nuname\n\nunexpand\n\nuniq\n\nuuencode\n\nuudecode\n\nvi\n\nwait\n\nwc\n\nwho\n\nwrite\n\nxargs\n", "id": "damdnrs"}, {"comment": "> OSX doesn't comply with either by default\n\n[macOS](http://www.opengroup.org/openbrand/register/brand3627.htm) has conformed to the [Single Unix Specification](https://en.wikipedia.org/wiki/Single_UNIX_Specification), a superset of POSIX, since 2007.\n\n\n\n", "id": "dameq9f"}, {"comment": "huh, til", "id": "damf2m4"}, {"comment": "So, this list doesn't cover q and y. I'd expect 'quota' and 'yacc' to be commonly acceptable, even though they apparently don't pass your (POSIX && GNU) test. ", "id": "damfzp3"}, {"comment": "'yes' is fairly pervasive as well. Maybe there's a better standard to apply. `yes` and `quota` are GNU, `yacc` is POSIX. I think anything in POSIX || GNU is reasonable, although I figured that doing an && would really ensure those scripts were available almost anywhere... of course, I'm sure a handful of the above aren't available on a clean Ubuntu install, for example.", "id": "damjh2h"}, {"comment": "Missing ones: head, od (had to look that one up, o is hard), quota, xargs.", "id": "dam78zv"}, {"comment": "You missed head. Also jobs for j.", "id": "dam9ztf"}, {"comment": "bash\n\njoin\n\nod\n\nxargs\n\nAnd my goto Q command is\n\nqemu-img", "id": "damb18g"}, {"comment": "Prefer Jq - it's awk/sed/less for JSON.", "id": "damec89"}, {"comment": "What about O?", "id": "damhbkf"}, {"comment": "> Tmux (not installed by default but still awesome)\n> \n\ntee\n\nif you want something installed by default", "id": "damp36u"}, {"comment": "That's a fun question to ask, without the describe or toilet part. It's surprisingly telling of someone's background in Linux. ", "id": "dam93xc"}, {"comment": "Yes, but with the toilet part, it's an annoying question that is not respectful of the candidate or their time. It doesn't tell you anything about whether or not they can do the job unless you're building an IoST (Internet of Shitty Things). It doesn't tell you if they will do the job. All it _might_ tell you is whether  they'd fit in with your environment, and there are far better ways to ask this.\n\nThis curated list of questions is unfortunately littered with similarly bad ones. ", "id": "dam9jxa"}, {"comment": "    ag\n    bash\n    cp\n    dd\n    echo\n    finger\n    grep\n    head\n    ip\n    jq\n    killall\n    ls\n    man\n    nc\n    objdump\n    perl\n    qmake\n    ruby\n    ssh\n    tcpdump\n    uname\n    VBoxManage\n    which\n    xz\n    yes\n    zsh", "id": "damh2cb"}, {"comment": "    alias a=alias\n    a b=a\n    b c=b\n    c d=c\n", "id": "dan6nwz"}, {"comment": "I'm really confused how these two sentences relate to each other?", "id": "damtp0a"}], [{"comment": "You mean a curated list of SHITTY interview questions?", "id": "dam2dx9"}, {"comment": "It's amazing how many votes this post has, huh?\n\nThis is a horrendous list of lists of horrendous questions.\n\nAnd I've been on reddit since it was programming focused - so, really early days. Since that day, to this day, the commenters on this site and then this sub when we switched to subreddits... fucking hate these stupid types of interview questions (rightfully so!).", "id": "damdhph"}, {"comment": "Seriously. I bookmarked it at first, then read some of the questions...\n\nAn endless stream of questions with \"correct\" answers.\n\nWho gives a fuck if you've memorized the behaviour of <language> in <specific corner-case>?\n\nToo many questions with not enough problems.", "id": "damtn3d"}, {"comment": "I think the awesomeness is the volume.\nIf they were going for quality at the top they would design it that way, it would be a ranking not a list", "id": "dan9ugr"}, {"comment": "At the risk of sounding snarky - are there any \"awesome\" lists that aren't terrible? I don't think I've ever seen that sunglasses button attached to any quality content on Github.\n\nIf I'm choosing a library, I'd like to know how long it has been around, how large the dev team is, whether dev efforts are waning, what test coverage is like, how many other projects use it, etc. To keep the promise of curation, you should also be reviewing said library, and weighing pros and cons, and pointing out limitations or pitfalls.\n\nBut I never see any of that. Most seem like an upturned wheelbarrow of search results, with no actual indication of curation.", "id": "damikuq"}, {"comment": "These lists are a a way of farming Github stars/forks to make one's github profile look \"interesting\". ", "id": "damkel6"}, {"comment": "So *that's* why I can't find work in an industry that's allegedly starved for talent.", "id": "dan546p"}, {"comment": "Coming soon to library shelves, \"The Click-Bait Resume: 47 tricks to maximize exposure\".", "id": "daqg0r2"}, {"comment": "> At the risk of sounding snarky - are there any \"awesome\" lists that aren't terrible?\n\nThe problem is that there aren't any awesome questions that exist without context.  Good questions tend to directly relate to the job you would be doing.  A good question for a, say, web developer working on an event ticketing platform won't be a good question for an embedded systems programmer working on microcontrollers for dishwashing machines.  Yeah they could both probably answer a \"how do you implement a circularly linked list\" question but it has no bearing on the work they've done in the past or will do for your company.", "id": "dampr1k"}, {"comment": "Ah, I'm not really talking about the questions. \"Awesome\" lists have been a (dodgy) Github trend for years, and they span many topics.", "id": "dampwd2"}, {"comment": "Oh, I gotcha.  That was a rhetorical question not an actual \"please send me lists of questions that aren't terrible\"", "id": "dampy1c"}, {"comment": "Well, really, that list will be useful in preparing for an interview for precisely that reason.  Though that's probably not intended.", "id": "damoyfm"}], [{"comment": "Oh, this should be quite successful. We all know how much reddit loves lists of resources that they can save, and (at least in my case) never come back to. Thanks, OP", "id": "dalwucb"}, {"comment": "It's extra successful because you can tell everyone who is upvoting this didn't even look at the exceptionally poor quality of questions on the list.", "id": "dam57bo"}, {"comment": "It's curated, it must be good.", "id": "dameanx"}, {"comment": "Curation process:\n\n\"Is there a question mark on the page? If yes, add to curated list.\"", "id": "damefny"}, {"comment": "r/me_irl", "id": "dam0j5k"}, {"comment": "Me too thanks \n\nq_q", "id": "dam5o8g"}, {"comment": "Hey atleast I check the comments if the list is worth it.", "id": "dam5l4g"}, {"comment": "If more than 5 recruiters get their hands on this list, it'll set this industry back another 5 years.  ", "id": "dambjvq"}, {"comment": "Thankfully this is a particular resource you're better off not saving or ever visiting again.", "id": "dam58fj"}], [{"comment": "I'm sorry, this is shit. I clicked on the first set of C interview questions, just out of curiosity, and found this:\n\n> How do you construct an increment statement or decrement statement in C?\n\nMaybe you're interviewing different coders than I am, but if I find myself seriously wondering whether you even know how to increment something, I think we can safely end the conversation right there. Thank you for your time, but this isn't a good fit.\n\n> Some coders debug their programs by placing comment symbols on some codes instead of deleting it. How does this aid in debugging?\n\nSeriously? Not only are we asking \"why would you comment things out while debugging\", but you phrase it as \"placing comment symbols on some codes\"?\n\n>  Can I use \u0093int\u0094 data type to store the value 32768? Why?\n\n> Answer:No. \u0093int\u0094 data type is capable of storing values from -32768 to 32767.\n\nWhile, yes, I concede that int is only required to be able to store 16-bit values, systems on which int is less than 32 bit are a rarity in today's world. There's a big difference between \"this might not work on embedded systems\" and \"no, you can't do that\". If you want to know whether the interviewee knows the required range of int according to the C spec, then *ask him that*.\n\n> Can two or more operators such as \\n and \\t be combined in a single line of program code\n\nTHOSE AREN'T OPERATORS JESUS FUCKING CHRIST\n\n> What is wrong in this statement?  scanf(\u0093%d\u0094,whatnumber);\n\n> Answer: An ampersand & symbol must be placed before the variable name whatnumber. \n\nAnd here I thought the missing quotes around %d were the problem. And given that you don't show the declaration of `whatnumber`, how am I supposed to know that isn't a pointer in the first place?\n\n> How do you generate random numbers in C?\n\nWell, I'd probably use a well-tested library such as Mersenne Twister, or maybe a... oh. You want me to say \"rand()\". Ok.\n\n> What is wrong with this statement? myName = \u0093Robin\u0094;\n\n> Answer:You cannot use the = sign to assign values to a string variable. Instead, use the strcpy function. The correct statement would be: strcpy(myName, \u0093Robin\u0094);\n\nUhh. Ok. I was going to write up a scathing critique of just how dumb this is, starting with the fact that there is no such thing as a \"string variable\" in C, but... I give. I'm stopping here. I lack the strength to finish.", "id": "dam5uoj"}, {"comment": "You made it farther down the list then I did... I lost it when they wanted to convert a for-loop to a while-loop, and figuerd it was better to increment the variable inside the while-loop rather than in the condition. Also, they forgot to declare the variable as an int.", "id": "dam8ytl"}, {"comment": "Actually, omitting the type is valid in C, it always defaults to int (which is why the program `main;` compiles, surprisingly).", "id": "damer25"}, {"comment": "Uh, I did not know that (but now I do). But in any case, I guess we can all agree that it's bad practice.", "id": "dami0cl"}, {"comment": "This misfeature was removed in C99 though.", "id": "dan0tii"}, {"comment": "That's only true for global identifiers, which this was not.\n\nTBF, though, the for loop doesn't include the `int` keyword either, so presumably we are meant to assume the variable to have been defined previously in the function.", "id": "dan04gk"}, {"comment": "ANSI C, requires it to work for locals as well. IRL, I've only ever seen it used with 'unsigned' and 'register', but it definitely has its place.", "id": "dancajv"}, {"comment": "I love this post. Not on its own, but all the comments pointing out how badly curated this \"awesome\" list is are so entertaining to read. Thanks for taking the time!", "id": "dam9pih"}, {"comment": "I usually skim the Reddit comments first to see whether it's worthwhile reading the actual article...  Thanks for saving me some time!  :)", "id": "dama0jh"}, {"comment": "There's some real gems in there if you want to farn karma over at /r/badcode (though /r/badinterviews might be better if that's a thing) ", "id": "danuydr"}, {"comment": "> Maybe you're interviewing different coders than I am, but if I find myself seriously wondering whether you even know how to increment something, I think we can safely end the conversation right there. Thank you for your time, but this isn't a good fit.\n\nI was asked \"how do you declare a pointer?\" *(scratching my head looking for the trap)* \"Er... with a star?\" \"Correct!\". After 20 years of C programming :-/    (and I didn't get the job.)", "id": "damqpb6"}, {"comment": "    for (a=1; a<=5; i++) {\n        for (b=1; b<=a; b++)\n            printf(\"%d\",b);\n        printf(\"\\n\");\n    }\n\nROTFL.", "id": "damrd3w"}, {"comment": "Haven't even read the list yet... but your telling me I shouldn't even if I just had my first technical interview last week?", "id": "damnke1"}, {"comment": "Find a different list. This list is just plain nonsense. ", "id": "damtoge"}], [{"comment": "What's it curated by, a regex? Here's the first link I followed for Postgres questions: http://nazafbtemplate.blogspot.co.uk/2014/06/frequently-asked-basic-postgresql.html", "id": "dalzr0z"}, {"comment": "Also it seems very much focused on languages, when (imo) the ideal interview question doesn't really care about the language you use. ", "id": "dam0ws0"}, {"comment": "Yeah, but who's ever been asked an ideal interview question?", "id": "damjh4g"}, {"comment": "Depends on the position and the resume", "id": "danfdmb"}], [{"comment": "How long until we get a curated list of lists of lists of interview questions?", "id": "daly3pg"}, {"comment": "As soon as some undergrad receives an answer to the question: \"but how about sorting _lists of lists of lists_?\"", "id": "dam0q3z"}, {"comment": "inb4 list of types of lists", "id": "dam0z1u"}, {"comment": "Don't be silly, that's far too much abstraction.", "id": "dalz3rc"}, {"comment": "Is this [meta](https://www.reddit.com/r/programming/comments/5fpghn/zerocost_abstractions/)?", "id": "dam1chs"}, {"comment": "May I present you [awesome-awesome](https://github.com/bayandin/awesome-awesomeness)?", "id": "dam15f7"}, {"comment": "> awesome-awesome\n\nPlease don't.", "id": "dam9g4n"}, {"comment": "> awesome-awesomeness\n\nFTFY", "id": "damkvh2"}, {"comment": "How long until they're actually curated?", "id": "dam6u4h"}], [{"comment": ">Write a program to show the singleton pattern used in python.\nSingleton patter is used to provide a mechanism that limits the number of instances that can be used by one class. It also allows the same object to be shared between many different parts of the code. This allows the global variables to be used as the actual data that is used is hidden by the singleton class interface. The singleton class interface can have only one public member and one class method Handle. Private constructors are not used to create an object that is used outside the class. The process waits for the static member function to create new instances and return the singleton object.\nThe code that is used to call the singleton object is:\n\n    Singleton& Singleton::Handle()\n    {\n       if( !psingle )\n       {\n           psingle = new Singleton;\n       }\n       return *psingle;\n    }\n\nI..... what?", "id": "dam26fg"}, {"comment": "I think that's a C++ example you're supposed to convert to Python? Maybe? \n\nExcept the idea of singletons in Python (or any other language that allows for easy monkey patching) makes me cringe really hard.", "id": "dam3xob"}, {"comment": ">Except the idea of singletons ~~in Python (or any other language that allows for easy monkey patching)~~ makes me cringe really hard.\n\njk jk, they have their place.", "id": "dam49lu"}, {"comment": "Only by virtue of occasionally being the least bad solution ", "id": "dam5k0g"}, {"comment": "I don't know, I can count the use cases on the fingers of... one finger (Null Object Pattern).", "id": "damvnik"}, {"comment": "It's not even a *good* singleton in the wrong language!\n\n    Singleton& Singleton::Handle() {\n        static Singleton instance;\n        return instance;\n    }\n\nThere. Short, simple, easy to read, thread safe, exception safe, and no dynamic allocation. Still not Python, though.", "id": "damasv4"}, {"comment": "There's a weird edge case there with  destruction order where if someone keeps a pointer to the instance, you can get unexpected errors at program exit. Slightly safer is:\n\n    Singleton& Singleton::Handle() {\n      static auto* instance = new Singleton;\n      return *instance;\n    }", "id": "dambqi4"}, {"comment": "And who deletes `instance`?\n\nI'm of the opinion that if you're hanging on to a pointer and using it past the destruction of a static class you get what's coming to you, unless I'm missing something :P", "id": "damcagx"}, {"comment": "Unless Singleton represents something that has to be destructed for external reasons (e.g., its destructor makes a call to finalize state in a database, although that would be weird for a singleton), it doesn't matter - the OS cleans up the leaked memory and so forth at process termination.\n\nThe problem only arises in certain cases where you've given a pointer to the singleton instance to another static-lifetime object, so it's mostly academic anyway.", "id": "damchyb"}, {"comment": "Eh, I can see that advantage of that - weird edge-case agreed - but valid nonetheless!", "id": "damcqsj"}, {"comment": "We have this issue because we do leak checking at shutdown - got around it by having a registry for Singletons and destructing them in reverse order.", "id": "damf3qd"}, {"comment": "Care to elaborate or link an article? Is the problem just that static objects are torn down in an unspecified order?", "id": "damloqr"}], [{"comment": "Over the past five years, I have developed a set of heuristics I would like to believe help me wade through the enormous range of programming resources I am bombarded with every day. They are simple rules of thumb to help sort the wheat from the chaff. I am of course but a journeyman, not a master, and I cannot say these heuristics shall always hold true. And I use them sceptically - we must always be vigilant that the habits and prejudices we establish do not wall us off from fresh perspectives and new ways of thinking.\n\nNevertheless, I think there is one heuristic I can bet on safely. It is this:\n\n> All programming articles whose titles employ the word 'awesome' are hot, molten clumps of real human excrement\n\nThe second I would tender to this community is as follows:\n\n> The self-serving arrogance and self-assuredness of the term 'curated' indicates the the author is a purveyor of hot, molten clumps of real human excrement.\n\nAnd a final, tentative rule of thumb I have alighted upon over the years:\n\n> Any company that interviews engineers using 'language pearls' questionnaires is hopelessly unqualified to manage them. Any job there will be akin to lowering your head into a pneumatic tube firing hot, molten clumps of real human excrement.", "id": "dam98qx"}], [{"comment": "Had a look at some of the lists for C. One of the questions was \"Write a program that outputs \"Hello World\" without using a semi-colon\".\n\nWhy would you ever need to do that to solve a real problem? Although, I suppose it tests your problem solving skills...\n\nFor reference, a possible solution:\n\n    #include <stdio.h>\n    int main() {\n        if (printf(\"Hello World!\\n\")) {}\n    }", "id": "dam4q28"}, {"comment": "And just for the lolz, [here's the solution it actually suggests](http://quiz.geeksforgeeks.org/commonly-asked-c-programming-interview-questions-set-1/):\n\n    int main(void)\n    {\n        if (printf(\"Hello World\")) ;\n    }\n\n\"Curated\" is the wrong word. \"Spewed\" seems more appropriate.", "id": "dam5iaz"}], [{"comment": "That this is #1 on /r/programming this morning sort of highlights exactly why I don't visit this sub much anymore. I'm only here now because I clicked through to this post from the front page.\n\nAlso, most of the best discussions are posted here hours after they're posted on HN.\n\nIn before \"Unsubscribe then\".", "id": "dam7g5d"}, {"comment": "Serious question: Ya, signal to noise on /r/programing is variable but where do you find a diverse community of opinion? HN has it's own echo chamber. Various language or platform specific subs have their scope limitations. ", "id": "dam9lca"}, {"comment": "Yeah, I really don't know.\n\nHN has its issues, but thinking about it I believe one reason I like it is that it's a fairly good one-stop-shop for generic tech news. I.e. right now there is some good discussion about all of the AWS announcements coming out of AWS re:Invent conference.\n\nReddit can sort of do that if I subscribe to the right subreddits, and if they don't degrade to image macro shitposting. But it takes a lot more management on my end to find, subscribe, maybe make multi-reddits (like the idea of this feature, but have ended up not using it for whatever reason), etc.\n\nhttps://lobste.rs/ is pretty cool, as you get a generic front page, but you can dig into areas of interest through the tags. I would be very happy if that site took off. Or if HN stole that feature.", "id": "damev4z"}, {"comment": "I upvoted this submission because it is hilariously bad.", "id": "damfmq2"}], [{"comment": "Hmmm. Let's see, for Java\n\n> 20 Essential Java Interview Questions\n\nhttp://www.toptal.com/java/interview-questions\n\nFirst thing they do is ask me a billion questions about my name, my company's name, who I am trying to hire, my email, my skype name... Nope.\n\nNot curated. Not reasonable. Useless list.", "id": "dam47s4"}], [{"comment": "> **What does ruby name refers to?**\n\n> * Ruby names refer to the classes, variables, methods, constants and modules that help in the creation of the program. \n>\n> * These are the names that distinguish other names with the specified ruby names that are being mentioned above.\n> * Ruby names are useful and used to be written as it is shown. They are useful in the context of writing the programs and while generating the module. \n> * Ruby names refer to the classes that has to be built and through which the objects will be declared, and methods that will perform on the data that is given.\n> * The names are reserved such that they can\u2019t be used anywhere else and for any other purpose. The name that is used can be in lower or upper case, letter, number or an underscore.\n\nThis made me stupider.\n", "id": "dame0i2"}], [{"comment": "I had a cursory glance at the C++ questions, and I feel like a lot of what is asked is technicalities about the language and none of which helps you understand if the candidate can write or design good software.", "id": "dam2lqp"}], [{"comment": "it s shit", "id": "dam3wvs"}], [{"comment": "One of the C++ ones:\n\n> Do you think the following code is fine? If not, what is the problem?\n\n> T *p = 0;\n> delete p;\n\n> \\- No, the code has a problem. The program will crash in an attempt to delete a null pointer.\n\nWhat ? No it won't...", "id": "dambsxw"}], [{"comment": "Looking at some of the languages I am proficient in, I can honestly say the \"curator(s)\" do not understand the languages in question.  Stop up-voting this crap.", "id": "dam5646"}], [{"comment": "I read some java interview questions and they were crap, considering how people from the other languages are complaining I'd say a removal of the \"awesome\" seems fitting", "id": "dam3mw2"}], [{"comment": "Followed through to the first list of Python questions: [Python interview questions and answers - freshers, experienced](http://www.careerride.com/python-interview-questions.aspx)\n\nFirst of all, 100% of the code examples are formatted incorrectly. Is part of the prep fixing their examples?\n\nThe author is universally unclear, ere are some good examples:\n\nWhat are the ways to write a function using call by reference?\n\n* In the function?  Call the function by reference? What the writer actually means is \"How can you write a function that takes a reference to an object as its argument?\"\n\nHow can the ternary operators be used in python?\n\n* They can't, Python has no ternary operator.  It has a logical expression with similar results, which is what the author mentions.\n\nHow the string does get converted to a number?\n\n* Typically when asked this question, I would expect the interviewer to want some insight into how the actually code works - i.e. the \"How\".  The question the author answers here is \"What should you do to convert a string to a number?\"\n\nPast this point in the article the questions look like copy/pasted code from the internet combined with literally nonsensical questions and answers.\n\nPerhaps the later entries are better, couldn't be bothered to look any further.", "id": "dam56e4"}, {"comment": "> **How is \u201cself\u201d explicitly defined in a method?**  \n> \u201cSelf\u201d is a reference variable and an instance attribute that is used instead of the local variable inside the class. The function or the variable of the self like self.x or self.meth() can be used in case the class is not known. There are no variables declared as local. It doesn\u2019t have any syntax and it allow the reference to be passed explicity or call the method for the class that is in use. The use of writebaseclass.methodname(self, <argument list>) shows that the method of \\_init\\_() can be extended to the base class methods. This also solves the problem that is syntactic by using the assignment and the local variables. This tells a way to the interpreter the values that are to be used for the instance variables and local variables. The use of explicit self.var solves the problem mentioned above.", "id": "damxk80"}], [{"comment": "OK I am not a programmer per trade but I found this in one of the question involving C++\n\n> Which type is best suited to represent the logical values?\n> \n> a) integer\n> \n> b) boolean\n> \n> c) character\n> \n> d) all of the mentioned\n\nI would say depending on the situation a and b.\n\nSince an int can be evaluated like a bool as false if 0 and true if different than 0 one can associate different instances of success or failure to an int, since by default if( var ) is equivalent of if( var!=0 )\n\nPlus, from personal experience, maybe because I am terrible at coding, in some cases vector<bool> might not be great because the structure is adapted for low memory footprint by getting only one bit per entry in the vector, which depending on the machinery that you have around, might cause issues.", "id": "dam2yz4"}], [{"comment": "> Which is used to tell the computer that where a pointer is pointing to?", "id": "dam6ifb"}], [{"comment": "I took a look and agree with the general sentiment here that what I saw was... less than good. But I didn't downvote it for one reason: real-life employers actually ask these questions and it's handy to know answers to some of the weird ones. Something something \"but if they ask silly questions the job can't be that good\" I hear someone say. Not true. For some reason really competent engineers at good companies I'd like to work for still ask reaaaaaly bad interview questions.\n\nI think it's akin to the problem I see with people teaching natural languages: they always seem to teach a language they don't speak themselves in daily life, only in polite circumstances (think a speech). Then the student goes into a pub after a year of learning, say, German, and doesn't understand anything anyone says.", "id": "dam9xze"}], [{"comment": "Here's a good interview question:\n\n\"Tell me about the most interesting thing you worked on or most interesting problem you had to solve?\"\n\nAnd then discuss.\n", "id": "damfrrt"}, {"comment": "That's the one I ask.  I thought I invented it! :)", "id": "damizku"}, {"comment": "I wish I invented it.  It's just what I converged on after hundreds of interviews.  I usually ask a few tech questions but mostly to figure out if they know how a computer works.  Most software people don't anecdotally (I don't hold it against them but it's nice if they do).\n\n", "id": "damkjq7"}], [{"comment": "\"Would you rather fight one horse-sized duck, or 100 duck-sized horses?\"", "id": "damq8di"}], [{"comment": "Is there a curated awesome list of curated awesome lists?", "id": "dam3gd1"}, {"comment": "\nThere's a curated list of awesome lists of awesome lists.\n\nhttps://github.com/sindresorhus/awesome-awesome-awesome-awesome", "id": "dam3i54"}], [{"comment": "Wow, these are really bad. ", "id": "damct2e"}], [{"comment": "Everyone (including myself) agrees this list is shit. Which demands this question: is there a non-shit curated list like this?", "id": "dame2rj"}, {"comment": "No, interview questions aren't something you should need to study for.", "id": "damqbrt"}], [{"comment": "This list isn't curated...", "id": "damv7bz"}], [{"comment": "and of all the things programmers and redditors need, nothing about soft skills.", "id": "dalz3d3"}], [{"comment": "SQL Lite. ", "id": "dam7et9"}], [{"comment": "Some of the C# questions were good. ", "id": "damaqax"}], [{"comment": "I would like to see a list of interview excercises, or do-it-at-home excercises to give to an interviewee. Excercises are often more useful and give a better indication of one's skills then some interview questions or quiz.", "id": "damdp7p"}], [{"comment": "This isn't a curated list. It's just a list of hundreds of links to hundreds of questions. No commentary whatsoever. Useless. ", "id": "damh4s6"}], [{"comment": "OP forgot a /s at the end of the title.\n", "id": "damh572"}], [{"comment": "Lots of mistakes in the \"C\" list.  Small errors, outdated assumptions, typos that would change the context.\nI have not looked into the rest yet.\n", "id": "damiy1q"}], [{"comment": "> 21) What is wrong with this statement? myName = \u0093Robin\u0094;\n\n>Answer:You cannot use the = sign to assign values to a string variable. Instead, use the strcpy function. The correct statement would be: strcpy(myName, \u0093Robin\u0094);\n\nWho said it was a string? I see no declarations of either of those fields, for all I know they were defined with scalar types and are perfectly valid.", "id": "damr3dy"}, {"comment": "Answer: `;` is used to begin a comment in an INI file but has no special meaning the end according to `GetPrivateProfileString`. You must put comments on their own lines in INI files.", "id": "dand9g9"}], [{"comment": "Checked out the C# ones, I can see some of them being useful.\n\nI find these questions are very subjective. It's more much interesting and engaing if you pair programme with the interviewer and attempt to solve a problem together.\n\nThat establishes whether or not you can problem solve and pair with another programmer which would show some semblance of interpersonal skills.", "id": "dam45lb"}, {"comment": "The C# ones are medicore to terrible, other than the first link which is actually fairly reasonable.", "id": "dam7fwy"}, {"comment": "No, this is hot garbage. At best they are generic programming questions that have no bearing on candidates knowledge of c#. At worst they are trying to obfuscate a question about some language feature. ", "id": "dam9fj8"}], [{"comment": "Curated.", "id": "dam76ks"}], [{"comment": "Looking at some of the languages i was like \"Fuck yea. I know these stuff so i can get a job\" came to the comments...i see i was wrong.", "id": "damfsmw"}], [{"comment": "maybe good for studying to answer interviewer's bad questions, but don't ask these yourself", "id": "dami6x2"}], [{"comment": "So as a learning developer I have no idea why this is apparently a terrible list, having never interviewed. Can anyone point me to an actually awesome list of interview questions instead? (Note: I'm learning C# and .Net) ", "id": "damidnb"}, {"comment": "\"Tell me about the most interesting technical problem you've solved, and how you did so\"\n\n\"Explain to me how computers / the internet / your operating system actually works\"\n\n\"How do you stay on top of changes in the industry?\"\n\n\"Tell me about a time someone changed your mind regarding a technical decision\"\n\n\"Why are you a programmer?\"\n\n\"Why are you learning C# and .net? How do they compare to other technologies?\"\n\n\"When does performance matter?\"", "id": "dammiyk"}, {"comment": "Keep learning and coding, you shouldn't have to study specifically for interview questions and when your a junior it's OK to not be an expert on every vague language feature.", "id": "damqgu3"}], [{"comment": "[\"I've never killed a man.\"](https://www.youtube.com/watch?v=ngu0RKsv3qE&t=30s)", "id": "dandobz"}], [{"comment": "Well, why all of this hate on this post? I'm not a professional programmer, I'm phd student and I use python in my daily work. I found some of the [related questions](https://www.toptal.com/python/interview-questions) really interesting.", "id": "daneuf2"}]]], "4egj8z": ["BitBucket's 5 year old request to make the codebase searchable online, still unfulfilled.", "2016-04-12 19:14:57", 0, "https://bitbucket.org/site/master/issues/2874/ability-to-search-source-code-bb-39", [[18, "It's a feature \"request\" not a \"demand\" or \"order\""], [1, "I'm not sure if the users have considered that they are not high priority. GitHub has probably eaten up a majority of the marketshare that pays for hosting and Bitbucket and others get the leftovers. It's just conjecture, but it looks like they're investing a majority of their resources to products that are more worthwhile."], [0, "Oh Atlassian. "]], [[{"comment": "It's a feature \"request\" not a \"demand\" or \"order\"", "id": "d1zz6ne"}, {"comment": "And to add to that, they are currently working on it.\n\n> Update / 2016-01-23 / Dan Bennett\n\n> Please read all comments from staff for back history as there's quite a bit.\n\n> Current status is that we are preparing the ElasticSearch infrastructure necessary to provide search and developers are working on the indexing and search integration this quarter. My gut feel is that we'll be done with all of this by July 1, 2016, however that should be viewed less as an ETA and more of a goal.", "id": "d200swn"}, {"comment": "Indeed we are. As a matter of fact, you can see some of the initial work already released as part of Bitbucket Server ([blog post](https://blog.bitbucket.org/2016/03/24/introducing-code-search-for-bitbucket-server/)).\n\n\nI'm due for a 3 month update to the ticket in a week or so where I'll say the same thing.", "id": "d2029y2"}], [{"comment": "I'm not sure if the users have considered that they are not high priority. GitHub has probably eaten up a majority of the marketshare that pays for hosting and Bitbucket and others get the leftovers. It's just conjecture, but it looks like they're investing a majority of their resources to products that are more worthwhile.", "id": "d208a3k"}, {"comment": "That would make a lot of sense. ", "id": "d20905y"}], [{"comment": "Oh Atlassian. ", "id": "d207rry"}]]], "4ebci2": ["Handmade Hero | Stroustrup has no idea what he is doing", "2016-04-11 20:03:57", 6, "https://youtu.be/1i4-e1okZtw", [[24, "It is toally ok to not agree with Bjarne Stroustrup, of course, but saying he's got no idea what he is doing, makes you look like a complete idiot."], [13, "[deleted]"], [8, "As C++ was first introduced into the programming world,  \nit had all kinds of additions to C.  \nIt started with classes, multiple inheritance.  \nThen operator overloading, templates... etc.\n\nEach addition added more problems to the C language. That is because the C language needed strict management of memory and pointers. The additions made this more hidden, and often more difficult. And some of these problems only appear in multithreading.\n\nThe object oriented programming was a mess, and needed special patterns to organize the classes. Other languages like Smalltalk were easier to use due to closures and their dynamic binding.  \nTemplates removed the need for some dynamic binding, but added a whole new world of possible problems. Ever tried to make a fully functioning template library?   \n\nThe STL tried to solve these problems by avoiding the structures common in OOP and replacing them with stack based structures.  \nThis introduced the trend not to use OOP in projects. Which is often a good idea for C++ projects.  \n\nModern C++ improved this negative trend, by trying to actually solve the problems of C and C++. Or \"promising\" to solve the problems.\n\nThe popularity of C++ is basically due to its compatibility with C, which is like the assembly language for every computer. And due to the popularity of object-oriented-programming, that was on its height due to the success of python and ruby and some other languages.\n\nThe programmers that worked with C, were used to do hard work and hard debugging. The C++ did improve some stuff from their perspective. I did not see any commercial success with C++ in the beginning. Instead programmers programmed C in C++, with some bits of extras. C in C++ still allowed fast execution, so it was popular for system development and games.  \n\nMany large companies invested a lot of money in ++. Some success of real C++ came when we had very advanced IDEs and compilers, and most of the code is written automatically.  \n\nYou can see a same trend in Javascript. A lot of web-code is generated. So while Javascript is not a very well designed language, everyone makes programs in it. History is simply repeating itself.  \nAnyone who states that C++ is so good, because it is popular, should also say that Javascript is good. \n\nAnd I think that Stroustup should have first solved the basic problems of C with the following steps:  \n1) Add real modules, like in Object Pascal. Most people have no idea how fast it compiles.  \n2) Restricted pointer usages.   \n3) Better organized memory management.  \n4) Better type system.  \n5) No mixing of integers and pointers.  \n\nIf you want to use some of the problematic features for C compatibility, the compiler can still allow it if you use the #fckme option.  \nBut my point is: only after removing problems, you can start to add some features. \n\nThe creators of Rust are actually solving some problems that we see in C (and C++). Sadly 20+ years too late.\n"], [6, "I can't tell if this is serious or extremely clever satire/trolling..."], [5, "I work with some people who attend the C++ committee meetings, and it's pretty clear that C++ hasn't belonged to Stroustrup for a long time. The C++ committee has, in recent years, done a fantastic job of bringing in new core C++ and new libraries. Sure, they don't please everyone, but on the whole they think carefully about it, they accept libraries only after demonstration versions (boost, I'm looking at you) have not just been made and tested but have been in use for years, and they keep an eye on the past and and eye on the future. They balance the tricky mix of idealism and pragmatism and over the last few years I think they've done a solid job. C++11 was like a whole new language, with a decade's worth of learning put into it.\n\nHaters gonna hate."], [1, "WTF. The guy talking in the video just repeated \"Stroustrup has no experience at all\" in ten different ways... No data, no evidence, no logic, no sense, big time wasting, and no fun."], [2, "Right or not, he comes across as a huge asshole."], [-5, "Ignorance strong in this one. I've been programming C++ since 1996 for fun and profit. Everything in C++ is a compromise, and some of them worse than others. It started out as a Simula like extension to C and continued to become a multiparadigm programming language. \n\nIs it the end all be all of programming languages? Hell no! I don't want to touch it anymore after 20 years, unless I really have to. Putting my personal feelings aside, it is a suprisingly usable tool. "]], [[{"comment": "It is toally ok to not agree with Bjarne Stroustrup, of course, but saying he's got no idea what he is doing, makes you look like a complete idiot.", "id": "d1yt8c7"}, {"comment": "Well, if you go down that route, Stroustrup himself sounds like a complete idiot when he says C [\"doesn't get into the business of expressing abstractions\"](https://www.youtube.com/watch?v=KlPC3O1DVcg) (right after mentioning data types and functions). Except he doesn't, because he's Bjarne freaking Stroustrup.\n\n(\"Abstraction\". He uses that word often. I don't think it means what he thinks it means.)\n", "id": "d1zkvag"}, {"comment": "[deleted]", "id": "d1zwkhc"}, {"comment": "Obviously.\n\nStill, Stroustrup sounded like a thing called \"abstraction\", that functions and structures don't do. This wording is self serving. By distinguishing C and C++ thus, he can pretend C++ is high level, while in fact it's low level, with high-level-ish mechanisms. You can often *pretend* C++ is high level, but you often can't.\n", "id": "d20fpoz"}, {"comment": "[deleted]", "id": "d1z8a0c"}, {"comment": "You could just look at Stroustrups background jobs and projects and it completely contradicts what vexe says in the first 3 minutes. ", "id": "d1zgwne"}, {"comment": "vexe didn't say anything. He extracted moments from Casay Muratori's [Handmade Hero series](https://www.youtube.com/user/handmadeheroarchive/videos).", "id": "d1zkwnc"}, {"comment": "I designed a language in school AND I USED IT. When Google announced Go! I knew exactly why they made some of their syntax decisions because I found syntax ambiguities and considered making the same decisions. My first two thoughts were 1. No one will ever use this language for anything with serious complicity and I'm glad google is saying it should be used for simple things like simple servers. 2. Their so backwards people are going to have a LOT of problems with no templates/generics or inheritance. Guess the top complaint about go is? It ain't exceptions.\n\nYou're calling the language that is the de facto standard of anything that needs performance 'shit'. Do you know how machines work? Do you have any clue how to write C++? Do you even program? C++ was created in the 80s and [of the top 10 languages](http://www.tiobe.com/tiobe_index) it's the ONLY ONE that guarantees a pointer WILL NOT BE NULL. C doesn't guarantee it, assembly doesn't, nothing else does and EVERYONE thinks NULL is a huge problem.\n\nDo you even understand my reply? Think before you speak I don't think you grasp any part of C++ if you think it's poorly designed. \n\nI'll add one thing bc I know someone will comment. A language not optimized (templates are slow, C compatibility is a tradeoff and can cause problems) means it isn't optimized. Not optimized isn't automatically poor designed (many languages fail that test including Java and C# for memory(java) and speed (C#) reasons). Maybe C++22 will have fast compiling generics. We'll know in the future", "id": "d1zbfil"}, {"comment": "> it's the ONLY ONE that guarantees a pointer WILL NOT BE NULL\n\nWhat are you talking about? C++ can easily have nullptrs.", "id": "d1zcroh"}, {"comment": "He means references. The standard says references will never be null and it's hard to accidentally do it. I can't remember a single time I had an error due to a reference being null although I am sure it's possible if there is a inconsistent codebase which has some functions using a type as a ptr and another as a reference.", "id": "d1zdrox"}, {"comment": "References don't protect you from deallocating the source object; I've seen this go bad places.\n\nI certainly wouldn't call C++ *AMAHZAING* based upon them.", "id": "d1zgnbk"}, {"comment": "[deleted]", "id": "d1zfw72"}, {"comment": "Hey how about stating verifiable facts. Do you want to deny having no nulls is useful? Or contest that Google Go isn't shitty? How about telling us what a well designed language is? I have some serious complaints about python, Javascript, ruby and C (one of the few languages that using gotos is a good practice) and I don't think I need to mention Java.\n\nAre you the guy in the video? You sound like an asshole in both of your comments. If you're the guy in the video I'm going to call you triple A, triple asshole. (paging /r/SiliconValleyHBO)", "id": "d1zg8k7"}, {"comment": "C++ has many, [many](http://yosefk.com/c++fqa/) warts besides the null references it neatly avoids. It inherited C's every mistakes for one (switches that fall through, complicated syntax for types, contextual grammar, header files, textual macros\u2026)\n\nYou can do one thing right and still be crap.", "id": "d1zl06q"}, {"comment": "It does have many warts but null references is an example. Templates are also good and pretty well thought out. However the way we're abusing it today has gotten out of control and we need something to fix it. People also have been asking for modules as well.\n\nYou're not really suppose to use C when writing C++ code. Void* doesn't really happen and we're suppose to use `<something>_cast` instead of the C style casting. It's recommended not to use `new` and to use `make_unique`. If you're doing it in a very C++ way the amount of memory errors goes down a lot.\n\nEvery language is crap. I am sure I can tell you 10+ legitimate reasons why any language is crap. But I can tell you why C++ and C# are one of the more well design languages. Rust is shaping up but I feel like D stumbled in a few places last time I checked I couldn't say this object is null it kept converting it to an empty/default value of the type which isn't what I wanted.", "id": "d208n0w"}, {"comment": "> Templates are also good and pretty well thought out\n\nI'm not sure: they do involve re-compiling the same code over and over. Hopefully modules will fix that in\u2026 2020? Also, they involve serious [trade-offs](https://www.reddit.com/r/programming/comments/4cv133/the_go2_project_aims_to_bring_generics_to_go/d1ltvtn).", "id": "d20ghs9"}, {"comment": "Yep although it was intentional. It's suppose to recompile (IIRC it compiles once per type per cpp file) and suppose to generate code to run as fast possible. Unfortunately years later we abused it. I want generics. I'm positive we can do something like it now but it has template compile speeds :(", "id": "d20o0pa"}, {"comment": "> Yep although it was intentional\n\nThe trade-offs, sure. Recompilation on the other hand doesn't always make sense. Why would you recompile `std::vector` twice if you use it on 2 different compilation units, but with `float` both times? Worst case, you bloat the generated object code, and best case, you eliminate it after the fact (and you still waste some time compiling it).", "id": "d20v9aj"}], [{"comment": "[deleted]", "id": "d1yu0ul"}, {"comment": "I'm not commenting on whether or not Bjarne Stroustrup knows what's up, but these points:\n\n- is a computer scientist\n- [is] a mathematician\n- [is] a distinguished research professor\n- [is] a highly praised author\n\ndo not inherently demonstrate competence in software engineering.\n\nThese do:\n\n- created one of the most popular languages in the world\n- [created the] first [C++] compiler\n\n...with some some qualifications.\n\nThe first two points don't really address quality. Brendan Eich made *the most* popular language in the world, but that's not what would make him competent since he has himself addressed that it was poorly designed. Eich is not competent because he created javascript, that just makes him famous. Same applies to Stroustrup.\n\nCreating a compiler for your language probably means you do not suck at programming, but students also make compilers with enough work, and you probably wouldn't give them the same sort of deference that you give Stroustrup.\n\nThis one:\n\n- [is a] successful managing director at Morgan Stanley.\n\nprobably does demonstrate competence, but I don't know what it means to be a managing director of technology at Morgan Stanley, and his [profile page](http://www.morganstanley.com/profiles/bjarne-stroustrup-managing-director-technology) doesn't have much to say about it.\n\nSo it's hard to say objectively. At least in the video Casey suggests you go and read his proposals and make your mind up for yourself.\n\nThere's a third option here: say you have opinions of things you like and dislike in C++, say you don't really know that much about Bjarne Stroustrup other than his writing and speaking, and decide you don't really care about that much about Bjarne Stroustrup beyond new proposals he puts forth for C++.", "id": "d1ywjav"}, {"comment": "[deleted]", "id": "d1yy3it"}, {"comment": "Obviously \"has no idea what he is doing\" is supposed to apply to the design of C++. Like, \"C++ is crappy, and getting crappier by the day, therefore Stroustrup doesn't know what he's doing\".\n\n---\n\nPersonally, I think Stroustroup did know what he was doing, and he choose to make a popular language instead of a good one.\n\nMore specifically, he chose to make a compiler that could compile most existing C source code, out of the box. That was technically unnecessary. You don't need header files to have separate compilation \u2014see proposals for modules. You don't need source compatibility to achieve binary interoperation \u2014C and C++ are no longer source compatible.\n\nStroustroup didn't trust the programmers of his time to learn a new syntax, or use 2 compilers instead of one in the course of adopting C-with-classes. So he carved the easiest route possible, even if it meant reproducing all of C's mistakes.\n\nI'm not sure if I should resent him for giving us such tempting crap. I fear that if he did the better language, it wouldn't be nearly as popular.", "id": "d1yzb8w"}, {"comment": "> Personally, I think Stroustroup did know what he was doing, and he choose to make a popular language instead of a good one.\n\nWorked with the man, this is really the only right answer here.\n\nC++ was designed from the ground up to be backwards-compatible with C, while allowing new features to be added.  It's at it's core a pragmatic solution.\n\nContrast with what the Unix/Plan9 guys did.  They tried to make a new language from scratch; which failed:\n\nhttps://en.wikipedia.org/wiki/Alef_(programming_language)\n\nThey then tried to make a new dialect of C for their new, non-backwards compatible OS, Plan9.  Which also failed in the marketplace.  As did the Inferno project.\n\n>I'm not sure if I should resent him for giving us such tempting crap. I fear that if he did the better language, it wouldn't be nearly as popular.\n\nThere are two types of programming languages.  Ones that people complain about and ones nobody uses. ", "id": "d1zdw8r"}, {"comment": "> There are two types of programming languages.\n\nI really dislike this quote, it sounds too dismissive. It kind of assumes the only useful languages are the popular ones. Sure, something nobody uses is useless. But that doesn't mean it's bad either.\n\nThe more interesting question is *why* don't we use the good languages? The state of the art from 20 years ago is often better than the current mainstream, how ridiculous is that?", "id": "d1zjekn"}, {"comment": "> I really dislike this quote, it sounds too dismissive. It kind of assumes the only useful languages are the popular ones. Sure, something nobody uses is useless. But that doesn't mean it's bad either.\n\nWhat's so ridiculous about the complaints of the author is that C++ itself was a reaction to \"academic\" languages like simula; that where esoterically pleasing yet difficult to use practically.  \n\nThere is also a history of languages invented by computer scientists, vs. programmers, like CSP and Z (that were not popular with industry):\n\nhttps://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions\n\n>The more interesting question is why don't we use the good languages? The state of the art from 20 years ago is often better than the current mainstream, how ridiculous is that?\n\nWe do use good languages.  The marketplace is always right.\n\nC++ is the best current language for complex, real-time systems.  \n\nJavascript is the best language for embedding a web browser.\n\nThere is lots of competition for GP scripting languages, but Python seems to be winning in that regard.\n\nJava is currently filling a niche in my opinion, but it still has some uses as a platform independent systems language.  \n\nThe more interesting question I think is why more people don't understand that software engineering is, by it's nature, inherently difficult. ", "id": "d1zx53e"}, {"comment": "> The marketplace is always right.\n\nI don't hold this right-wing libertarian assumption. One reason (among many) is the continued popularity of the Qwerty layout and the [staggered keys](http://loup-vaillant.fr/articles/better-keyboards). The market is just wrong here. (Just in case you want to enlighten me, I [know](https://www.utdallas.edu/~liebowit/keys1.html) the [debate](http://dvorak.mwbrooks.com/dissent.html).)\n\n> Javascript is the best language for embedding a web browser.\n\nThat's just ridiculous. Lua is objectively better, if only because it is cleaner (no equality operator so fucked up it's not even transitive, for instance). JavaScript is yet another example of path dependence through network effects.\n", "id": "d20g8sc"}, {"comment": "> I don't hold this right-wing libertarian assumption. One reason (among many) is the continued popularity of the Qwerty layout and the staggered keys. The market is just wrong here. (Just in case you want to enlighten me, I know the debate.)\n\nIt's not even a debate.  There is simply no evidence that Dvorak is superior to Qwerty to a degree that would influence market adoption:\n\nhttps://en.wikipedia.org/wiki/Dvorak_Simplified_Keyboard#Controversies_and_criticism\n\nIt's apples and oranges. \n\n>That's just ridiculous. Lua is objectively better, if only because it is cleaner (no equality operator so fucked up it's not even transitive, for instance). JavaScript is yet another example of path dependence through network effects.\n\nJavascript is 'denser' and can be compiled easier as it's a simpler language.  This is why it's popular with outfits like Google that are running their entire platform on Ajax.  Every byte/cycle counts. ", "id": "d21f9p9"}, {"comment": "> to a degree that would influence market adoption:\n\nObviously, the market was not influenced. Dvorak is still better \u2014more comfortable and easier to learn, mostly. By the way, the focus on typing speed is utterly ridiculous. From where I stand, raw speed isn't the main advantage of sane layouts.\n\nThe market sometimes make mistakes. Of course it does Markets are a human social construct, and we humans make mistakes all the time.\n\n> Javascript is 'denser' and can be compiled easier as it's a simpler language.\n\nWhat? The two languages have the same core semantics!\n\n> This is why it's popular with [whatever]\n\nJavaScript is popular because it was first. Once it took root as a cross-vendor scripting engine, there was no way to remove it.\n", "id": "d21vjzi"}, {"comment": "[deleted]", "id": "d1zx535"}, {"comment": "There's a reason nobody uses them.  It's usually a combination of performance and lack of decent libraries. ", "id": "d1zzweb"}, {"comment": "There's a reason for crappy performance and lack of decent libraries: it's usually because nobody uses the language.\n\nChicken and egg.", "id": "d20fc9w"}, {"comment": "Well, it's also inherent in the design of the language.\n\nWhen a Sun rep came by Bell Labs in the 1990's, he claimed that \"eventually\" that Java was going to be \"just as fast as C++\".\n\nBjarne walked up to a whiteboard and then proved, in a scientific sense, why that would never, ever happen.  It was brilliant.\n\nSometimes you have to make compromises one way or the other.  C++ can never be truly memory safe, but by the same token Java can never have a predictable garbage collector or equivalent performance. ", "id": "d20fp02"}, {"comment": "[deleted]", "id": "d1yzryb"}, {"comment": "I hope that someday, you'll be able to judge words on their own merits, regardless of who you think is behind them.\n\nIn the meantime\u2026 I can show [this](http://loup-vaillant.fr/tutorials/earley-parsing/).", "id": "d1z0u1b"}, {"comment": "> You can make the exact same claim about Dennis Richie\n\nNot really, since Richie also did a lot of publicly visible work on Unix.\n\n> one of Ritchie's most important contributions to Unix was its porting to different machines and platforms  \n> (from https://en.wikipedia.org/wiki/Dennis_Ritchie#Career )\n\n[Stroustrup's wiki page](https://en.wikipedia.org/wiki/Bjarne_Stroustrup#Career) talks mostly about C++, and then mentions him being head of \"AT&T Bell Labs' Large-scale Programming Research department\". It's a pity there's not more info on that page about what the Large-scale Programming Research department was and what he did in that position. I assume it was cool stuff.\n\n> and a host of other language designers.\n\nI's definitely wrong to discount the work of language designers. However, languages made by people who have had to solve lots of difficult real-world problems are usually better designed for solving those problems (isn't that what Ritchie was doing?), so I think it's worth talking about. Maybe with less bile and vitriol, sure, but don't stop the conversation.", "id": "d1z0faq"}, {"comment": "> Stroustrup's wiki page talks mostly about C++, and then mentions him being head of \"AT&T Bell Labs' Large-scale Programming Research department\". It's a pity there's not more info on that page about what the Large-scale Programming Research department was and what he did in that position. I assume it was cool stuff.\n\nI worked for them for a few years in the 1990's.  AMA.", "id": "d1z1qew"}, {"comment": "Awesome! I guess what I'm interested in knowing is mainly what does \"Large-scale Programming Research\" entail and what goals did the group have? Is it about team size / scope of project?", "id": "d1z3vw8"}, {"comment": "Basically what you would be calling \"Big Data\" research today.  Or just building big, complex systems in general. \n\nC++ was used internally @AT&T for things like call detail data and large real-time systems.  Like networks of 5ESS switches.\n\nAT&T also made some money off of Unix licenses in the 1980's/1990's, so there were external customers (like Sun and SGI) that were using C++ as well.  And developing their own compilers for their respective hardware.\n\nRe: goals, that wasn't how Bell Labs culture worked.  The researchers just worked on whatever they felt was interesting, with some limited direction from their management.  When I was there Bjarne travelled a lot to conferences/standards committee meetings.\n\n", "id": "d1z4hs1"}, {"comment": "[deleted]", "id": "d1yy76q"}, {"comment": "Please consider that I don't necessarily share the opinion of the guy in the video.", "id": "d1z0n2j"}, {"comment": "Well, it's not like it's _false_, right? How is it \"too much\"?", "id": "d1yzff2"}, {"comment": "[deleted]", "id": "d1yzrea"}, {"comment": "So, student's don't make compilers? What about compiler courses?", "id": "d1z0voq"}, {"comment": ">It is false\n\nI certainly wrote a compiler back in college in 1996.  Even still have the dragon book, which was the course textbook.", "id": "d1z4o6u"}, {"comment": "Just say you're the guy from the video.", "id": "d1yyb5p"}, {"comment": "[Casey Muratory](http://mollyrocket.com/casey/about.html) is _probably_ too busy to spend much time here\u2026", "id": "d1yzidg"}, {"comment": "[deleted]", "id": "d1yzubh"}, {"comment": "You mean this [truckload of videos](https://www.youtube.com/user/handmadeheroarchive/videos)? Where he writes a game from scratch, live, while explaining how he does it to the audience?\n\nDo your research for 5 minutes, will you?\n", "id": "d1z12nm"}, {"comment": "In response to him saying bjarne has no experience writing real industrial grade software and has just spent time in theory and developing languages/compilers... you quote his experience in academia and compiler writing... okay. Seems you missed the point.", "id": "d1z85df"}, {"comment": "This guy has no idea how complicated & hard language design is. Languages made by \"Joe the programmer\" typically end up looking like PHP.", "id": "d1yubts"}, {"comment": "What's hard about it? Could you tell us about the difficulties you faced? (If not you, someone you know. A link about that would be most awesome.)\n\nI have the feeling you just *assume* language design is some kind of black art. My intuition disagrees: I feel like with the right courses, any programmer can learn in in a couple semesters. It's just rarely taught.", "id": "d1z1dq8"}, {"comment": "Take a look at Javascript, it was written in 10 days or something and has _tons_ of pitfalls on every level: parser, semantics, OO, builtin types. It's like a manual of what not to do.\n", "id": "d1z4ji1"}, {"comment": "> I feel like with the right courses, any programmer can learn in in a couple semesters.\n\nJup, after a few semesters of any programmer can create Python or Rust or Scala or Haskell or ML or C#. /s\n", "id": "d1z2are"}, {"comment": "Or if you're using Scheme, you can write a fully-functional metacircular evaluator on [four blackboards](https://www.youtube.com/watch?v=0m6hoOelZH8) in a one hour lecture.", "id": "d1z5ift"}, {"comment": "Great argument, I guess that's why we're all programming in Scheme now.", "id": "d20chcu"}, {"comment": "I guess being able to roll a fully-fledged PL interpreter in a half hour doesn't offset the fact that Scheme has a weak ecosystem and atrocious portability across implementations.\n\nAlso, parentheses scare people.", "id": "d20ewji"}, {"comment": "That's kind of like saying any architect can learn skyscraper design in a couple of semesters. It's not that it's a black art, but it's not just a matter of taking some classes. It's that there are many tradeoffs and problems that require a diversity of knowledge and experience.", "id": "d1z2j6c"}, {"comment": "We need to let go of the idea of a general purpose language. Such a thing doesn't exist. A language is supposed to fill a niche. The narrower the niche, the easier the language.\n\nSure, making a good language is not easy. On the other hand, many mistakes we see in actual languages could have been avoided by a semester-long course in programming languages. Things like dynamic scoping, the lack of tail calls, or the absence of generics. Moreover, we now have a host of examples of things that worked, and things that didn't. We don't necessarily have to *live* the experience to draw from it.\n", "id": "d1zj6gw"}, {"comment": "> I feel like with the right courses, any programmer can learn in in a couple semesters. It's just rarely taught.\n\nWow, how completely ignorant. \n", "id": "d1zgxub"}, {"comment": "Of what? Teach me, dammit.", "id": "d1zjfcg"}, {"comment": "> Teach me\n\nThat is the exact problem with your thought process. Not everything known has been written. ", "id": "d1zjwel"}, {"comment": "As if you couldn't _at least_ point out the areas of my supposed ignorance. As if I was beyond teaching.\n\nWhen I can find the time, I'll write my own damn language. We'll see how it goes.", "id": "d1zkp6x"}, {"comment": "> Languages made by \"Joe the programmer\" typically end up looking like PHP.\n\nOr Perl. ", "id": "d1zdx3f"}], [{"comment": "As C++ was first introduced into the programming world,  \nit had all kinds of additions to C.  \nIt started with classes, multiple inheritance.  \nThen operator overloading, templates... etc.\n\nEach addition added more problems to the C language. That is because the C language needed strict management of memory and pointers. The additions made this more hidden, and often more difficult. And some of these problems only appear in multithreading.\n\nThe object oriented programming was a mess, and needed special patterns to organize the classes. Other languages like Smalltalk were easier to use due to closures and their dynamic binding.  \nTemplates removed the need for some dynamic binding, but added a whole new world of possible problems. Ever tried to make a fully functioning template library?   \n\nThe STL tried to solve these problems by avoiding the structures common in OOP and replacing them with stack based structures.  \nThis introduced the trend not to use OOP in projects. Which is often a good idea for C++ projects.  \n\nModern C++ improved this negative trend, by trying to actually solve the problems of C and C++. Or \"promising\" to solve the problems.\n\nThe popularity of C++ is basically due to its compatibility with C, which is like the assembly language for every computer. And due to the popularity of object-oriented-programming, that was on its height due to the success of python and ruby and some other languages.\n\nThe programmers that worked with C, were used to do hard work and hard debugging. The C++ did improve some stuff from their perspective. I did not see any commercial success with C++ in the beginning. Instead programmers programmed C in C++, with some bits of extras. C in C++ still allowed fast execution, so it was popular for system development and games.  \n\nMany large companies invested a lot of money in ++. Some success of real C++ came when we had very advanced IDEs and compilers, and most of the code is written automatically.  \n\nYou can see a same trend in Javascript. A lot of web-code is generated. So while Javascript is not a very well designed language, everyone makes programs in it. History is simply repeating itself.  \nAnyone who states that C++ is so good, because it is popular, should also say that Javascript is good. \n\nAnd I think that Stroustup should have first solved the basic problems of C with the following steps:  \n1) Add real modules, like in Object Pascal. Most people have no idea how fast it compiles.  \n2) Restricted pointer usages.   \n3) Better organized memory management.  \n4) Better type system.  \n5) No mixing of integers and pointers.  \n\nIf you want to use some of the problematic features for C compatibility, the compiler can still allow it if you use the #fckme option.  \nBut my point is: only after removing problems, you can start to add some features. \n\nThe creators of Rust are actually solving some problems that we see in C (and C++). Sadly 20+ years too late.\n", "id": "d1z4229"}, {"comment": "I like using pointers, don't restrict my pointers please. (I actually don't know what you mean by 'restricted pointer usages', it seems a bit nebulous)", "id": "d1z8esn"}, {"comment": "More like other languages, and better types of pointers.  \nRust is a good example.\n\nAlternatively, in pascal I can use different pointer-types.  \n\n    var a:array[0..100] of Integer;  \n    var pa:^Integer;  \n    var x:Pointer;  \n    begin  \n      pa:= @a[19];  \n      x:= @a[19];  \n\nit would not be hard to implement pointer offsets:  \n\n    pa:= MovePointer(pa,5);  \n\nfor c magic you can add:  \n\n    #fckme  \n    x:= x +random(100)*sizeof(Integer);  \n\nSo you lose nothing, it restricts a bit the extreme usage that can create problems like weak typing, alignment and lsb/msb, aliasing, etc..\n\n", "id": "d1zayyq"}], [{"comment": "I can't tell if this is serious or extremely clever satire/trolling...", "id": "d1ypb6w"}, {"comment": "Pretty sure it's 100% serious. In gamedev industry, the C++ STL is widely hated and rarely used, and it's pretty common to avoid the fancy parts of C++ as well.", "id": "d1yq4kc"}, {"comment": "In gamedev, the only thing hated more than the STL would be Boost.", "id": "d1yqivv"}, {"comment": "[deleted]", "id": "d1yt7dd"}, {"comment": "Sure. Okay. But I don't really consider gamedev and gamedev tooling to be the same thing. Sorry. STL and Boost may very well be used in tools for game dev. ", "id": "d1yybub"}, {"comment": "That attitude exists but it is not universal nor held with the same (hyperbolic) fervor by those who agree with that sentiment to some degree.  The STL (or close analogues like EASTL) are widely used in the video game industry.  I've been using C++11/14 features in production code on AAA games since they were available in shipping Microsoft compilers.  The code bases I've worked with in the industry run the gamut from \"C with Classes\" style C++ to generic libraries exploiting variadic templates and template metaprogramming techniques.\n\nWhile I would be comfortable saying the video game industry is fairly conservative and measured in its adoption of new techniques, Casey Muratori's opinion here is not representative of the entire industry (though to be fair it is one shared by some thought leaders in the industry).", "id": "d1yqsoo"}, {"comment": "I was just referring to \"the\" STL, not EASTL or etc.\n\n> Casey Muratori's opinion here is not representative of the entire industry\n\nWell sure, no one person could possibly represent the entire industry. :) In his own 5 minute video he stresses that it's just his opinion.", "id": "d1yr6b8"}, {"comment": "Why on Earth would you avoid the STL? Genuinely curious.", "id": "d1yzhoy"}, {"comment": "Here's the seminal doc about EASTL (EA's replacement for STL). Scroll down a bit to the Movation section. http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html", "id": "d1z0ke9"}, {"comment": "Ah, I see. Mostly a portability issue, which makes a lot of sense given that you want to compile your code for multiple different architectures.", "id": "d1zc11q"}, {"comment": "I was looking to see if it was filmed on April 1. ", "id": "d1ypt7e"}], [{"comment": "I work with some people who attend the C++ committee meetings, and it's pretty clear that C++ hasn't belonged to Stroustrup for a long time. The C++ committee has, in recent years, done a fantastic job of bringing in new core C++ and new libraries. Sure, they don't please everyone, but on the whole they think carefully about it, they accept libraries only after demonstration versions (boost, I'm looking at you) have not just been made and tested but have been in use for years, and they keep an eye on the past and and eye on the future. They balance the tricky mix of idealism and pragmatism and over the last few years I think they've done a solid job. C++11 was like a whole new language, with a decade's worth of learning put into it.\n\nHaters gonna hate.", "id": "d1zpidr"}], [{"comment": "WTF. The guy talking in the video just repeated \"Stroustrup has no experience at all\" in ten different ways... No data, no evidence, no logic, no sense, big time wasting, and no fun.", "id": "d1yqr6d"}], [{"comment": "Right or not, he comes across as a huge asshole.", "id": "d1zbrb2"}], [{"comment": "Ignorance strong in this one. I've been programming C++ since 1996 for fun and profit. Everything in C++ is a compromise, and some of them worse than others. It started out as a Simula like extension to C and continued to become a multiparadigm programming language. \n\nIs it the end all be all of programming languages? Hell no! I don't want to touch it anymore after 20 years, unless I really have to. Putting my personal feelings aside, it is a suprisingly usable tool. ", "id": "d1yw3gn"}, {"comment": "Have you done real time interactive simulations? like game engines? That's a highly specific field. Your respective experience is probably very different.\n\n(Also, I think Casey Muratory doesn't want to touch C++ either. He just feels he has no choice.)", "id": "d1z1h4e"}, {"comment": "Seriously calling C++ an academic ivory tower is misguided. But then I need to start a pissing match about my C++ chops after 20 years. No thanks I'll rather take the down votes from the sock puppets. Especially when I've given up on C++.", "id": "d1z2y3y"}, {"comment": "I'm not sure who you're calling a sock puppet, but I suggest you take a look at the comment histories first.\n\nI wasn't disputing your abilities with C++ (by the way, I'm giving up on it too). I was wondering about the _nature_ of your experience with it. My own for instance have shown a strong tendency to use it when inappropriate (no real need for extreme performance, mostly). I don't really _know_ what C++ is good for, since it was bad at everything I threw at it.\n", "id": "d1zizvv"}, {"comment": "But the video is an ad hominem devoid of actual examples of what is wrong. It is about blaming the creator of the language for decisions other have made. No actual examples and pinning the decisions on stroustrup. \n\nI don't like some of the decisions in STL but you don't see me attacking Stepanov for those. std::remove is a fantastic example of a cruel practical joke to people who sees it on their auto-complete and don't read the documentation. But calling them names isn't on my radar. \n\nC++ is a usable tool if bother to learn in it. Beware of the razor blades hidden in the corners. Leaving the razor blades was pragmatic decisions and not because they are stupid or malicious. Compromises were made! ", "id": "d1zlb16"}, {"comment": "> C++ is a usable tool if bother to learn in it.\n\nOver 10 years of learning and using C++, and I still learn stuff about its syntax or semantics. This is crazy, no programming language can justify such complexity without a heavy dose of path dependence.\n\n> pragmatic decisions\n\nFrom what I have read (from Stroustrup himself), the main \"pragmatic\" decision was to make a compiler that could compile most of existing C code, so you could pretend you programmed in C (with a few extensions). But the sacrifice is too big:\n\n* We're still stuck with header files. We need proper modules (which existed at the time).\n* Switch statements still fall through by default, even though that feature was rarely used.\n* The syntax of types still sucks, and still causes ambiguities without a symbol table.\n* We still have that crappy text based pre-processor. We want to act on the AST, not on the text. And the macro language to be the same as the host language.\n\nThat's not pragmatism, that's short term thinking. Perhaps even short sightedness.", "id": "d1zlwbg"}, {"comment": ">Over 10 years of learning and using C++, and I still learn stuff about its syntax or semantics. This is crazy, no programming language can justify such complexity without a heavy dose of path dependence.\n\nSo, I'm still learning about after almost two decades. There aren't many languages you can learn completely. Try that with Haskell or Perl and get back to me. \n\n>That's not pragmatism, that's short term thinking. Perhaps even short sightedness. \n\nAnd you bring up all the stuff that is backwards compatibility with C and call it myopic. But this is where our opinions differ, the backwards compatibility to C was crucial to the success of C++, things are happening at the standardization board to adress some of the issues. Like modules and macros in the same language(constexpr and better templating). ", "id": "d1zmsjb"}, {"comment": "> Try that with Haskell or Perl and get back to me.\n\nThen they're crazy as well. The fundamentals of programming languages are small.  A reference implementation optimised for simplicity shouldn't exceed 10K lines, or the semantics are likely too big. And I don't care few languages besides Lua meet that criterion. Even C is too big for its own good.\n\nI can understand learning *how to use* a language even after 10 years. But learning yet another trivia about its definition itself? Something's wrong.\n\n> you bring up all the stuff that is backwards compatibility with C and call it myopic\n\nIt was. Binary compatibility I can understand, source compatibility however was really unnecessary (case in point: C and C++ are no longer source compatible).\n\n> the backwards compatibility to C was crucial to the success of C++\n\nI'm afraid so. Stroustrup himself was probably not myopic but the programmers he was selling C++ to definitely were. How the hell was there even a C++ *market*?\n\n> things are happening at the standardization board to address some of the issues\n\nToo slow. 30 years later, C++ is still fixing its own problems. I give up. The only reasonable way out is a clean break.\n", "id": "d1znkox"}, {"comment": "So we have both given up on it. But my view of the past is a little more sympathetic. But the areas for C++ has diminished, so unless something that needs to interact closely with memory and system calls there is no need to learn C++. Building a graphics engine... well then you can use C++. Building a new VM for some highlevel language use C++. And a few other select areas. \n\n\n", "id": "d1zp0mx"}, {"comment": "> That's not pragmatism, that's short term thinking. Perhaps even short sightedness.\n\nIt was pragmatic in the early 1980's, when those decisions were made.\n\n", "id": "d20001g"}]]], "543fys": ["[Best Comparison] Ruby vs Python, the Definitive FAQ", "2016-09-23 10:28:59", 93, "https://hackernoon.com/ruby-vs-python-the-definitive-faq-5cb0046292be#.ggwuvtb0n", [[57, "* Please try to keep submissions on topic and of high quality.\n* Just because it has a computer in it doesn't make it programming.\n* If there is no code in your link, it probably doesn't belong here.\n\nThis is a great fit for /r/programmerhumor, though!"], [21, "About as helpful as most real comparison articles"], [19, "The last few times I chose between Ruby and Python in my projects, it was because of a library that I found in one language or the other that made it convenient.\n\nI would suggest that the primary difference between the two is the communities around the language."], [12, "[deleted]"], [7, "Ah, I remember when Ruby vs Python was a thing. And it seemed important at the time"], [3, "**Package Management**\n\nBoth python and ruby can be put into package and managed to stay inside. For ruby it's easier - it's just a *gem*, after all. Python might slither out of package, so you could *pip* inside to make it think there is a bird there."], [4, "The fact that Ruby is whitespace insensitive makes it much better by default to me."], [0, "Why is Ruby considered to be more elegant?\n\nIt has lots of syntactic sugar and and lets you do pretty weird things. Isn't that the opposite of elegant?\n\nPython is rather dull and unsurprising, though. That does not sound like elegant. I guess both languages are very inelegant when compared to Haskell? (I meant to say Elm, but Elm actually isn't that elegant because of its multi-part program structure and verbosity.) "], [2, "These comparisons are mostly dumb, but here's something I really do care about - Python's convention of being explicit. The implicit returning in Ruby functions something I don't appreciate."], [2, "the funniest thing about this (by far) is the number of people who didn't read it"], [1, "can we ban this type of content in here? mods please?"], [-12, "Some people laugh at Ruby and consider Python to be a more serious programming language. But I laugh much more about the Pythons than I will ever laugh about Rubies."]], [[{"comment": "* Please try to keep submissions on topic and of high quality.\n* Just because it has a computer in it doesn't make it programming.\n* If there is no code in your link, it probably doesn't belong here.\n\nThis is a great fit for /r/programmerhumor, though!", "id": "d7yn4y9"}, {"comment": "Oops sorry about that. I'll keep that in mind :)", "id": "d7yx355"}], [{"comment": "About as helpful as most real comparison articles", "id": "d7z30pd"}], [{"comment": "The last few times I chose between Ruby and Python in my projects, it was because of a library that I found in one language or the other that made it convenient.\n\nI would suggest that the primary difference between the two is the communities around the language.", "id": "d7yldxq"}, {"comment": "I would suggest that the primary difference between the two is that one is a mineral and the other is an amphibian", "id": "d7ymbsl"}, {"comment": "I am sure your comment is very wise but I confess I don't understand it. ", "id": "d7ymihy"}, {"comment": "Ruby - a variety of a natural occuring mineral.\n\nAnd he's wrong about pythons being amphibians, they're just reptiles.", "id": "d7ymuve"}, {"comment": "> they're **just** reptiles\n\nAre you looking for trouble?", "id": "d7z4nd5"}, {"comment": "You didn't read the article, did you?", "id": "d7yodw3"}, {"comment": "Does anyone?", "id": "d7yt3n5"}, {"comment": "For me it was even simpler: AWS lambda doesn't support Ruby.", "id": "d7yo1r2"}, {"comment": "I don't know.\n\nFor me it was the philosophy. That was the deciding factor for me. I always pull out matz' interview from 2003 I think. I could not find a similar interview with guido though. Plus matz is cool, he is like always smiling when he does a presentation like a little buddha (he says it is because he is nervous but he actually is a funny guy, you can see it in some of his slides - see the animated duck for instance; by the way, that mechanized duck, that actually was used to \"feel real\" like a duck in ... I think 1800 something... I forgot the date but you can look it up in wikipedia, that was pretty creative to try to build a duck that can \"eat\" and \"digest\"...)\n\nWhether there is a great community or not, well - perl may have a great community but I left perl a long time ago because the language itself was inferior to ruby and python (I actually switched to PHP after perl but I abandoned PHP eventually; oddly enough I was more productive in PHP than I was in \nperl).\n\n", "id": "d7yt4v1"}, {"comment": "Yeah, philosophy is what I meant (partly) by community. ", "id": "d7z4b5o"}], [{"comment": "[deleted]", "id": "d7yny0z"}, {"comment": "While we are already ranting: I don't want your stupid social media buttons when I highlight text.", "id": "d7yojj2"}, {"comment": "A good programmer or sysadmin uses automation to make their life easier. Can't you just implement a bot to solve the CAPTCHA?", "id": "d7yt4ry"}, {"comment": "I have used Tor with Cloudflare; the CAPTCHAs are solvable.", "id": "d7yo9hj"}, {"comment": "[deleted]", "id": "d7z595o"}, {"comment": "I have used many websites with Cloudflare through Tor, and the CAPTCHA works fine about 75% of the time (sometimes there are connection problems).\n\nCould you explain what happens? Does the CAPTCHA load?", "id": "d7z5vmc"}], [{"comment": "Ah, I remember when Ruby vs Python was a thing. And it seemed important at the time", "id": "d7z5fef"}], [{"comment": "**Package Management**\n\nBoth python and ruby can be put into package and managed to stay inside. For ruby it's easier - it's just a *gem*, after all. Python might slither out of package, so you could *pip* inside to make it think there is a bird there.", "id": "d7zw6ne"}], [{"comment": "The fact that Ruby is whitespace insensitive makes it much better by default to me.", "id": "d7ys2qo"}, {"comment": "The fact that python is white space sensitive is one of the many reasons I love it. Code bases are so much easier to use when everyone in the community uses the same practices. ", "id": "d7yst4l"}, {"comment": "Pity it chose the wrong type of whitespace", "id": "d7z8ypk"}, {"comment": "What do you mean by this?", "id": "d818lwv"}, {"comment": "The thing is, the Ruby community is actually [more consistent](http://ukupat.github.io/tabs-or-spaces/?) than the Python community when it comes to indentation.\n", "id": "d7ze5xq"}, {"comment": "But you should be indenting with tabs anyway so that everyone can choose their own indent width.", "id": "d7zg2c0"}, {"comment": "But you Ruby guys all indent the same anyway ... so WTF is this even?", "id": "d80y1qs"}, {"comment": "I'm not a Ruby dude... I'm a C dude...", "id": "d89lr5e"}, {"comment": "Why? Do you like inconsistently indented code?", "id": "d7zvwm2"}, {"comment": "No", "id": "d7z8sy4"}, {"comment": "Yes.", "id": "d7zpd0k"}], [{"comment": "Why is Ruby considered to be more elegant?\n\nIt has lots of syntactic sugar and and lets you do pretty weird things. Isn't that the opposite of elegant?\n\nPython is rather dull and unsurprising, though. That does not sound like elegant. I guess both languages are very inelegant when compared to Haskell? (I meant to say Elm, but Elm actually isn't that elegant because of its multi-part program structure and verbosity.) ", "id": "d7z8jtv"}], [{"comment": "These comparisons are mostly dumb, but here's something I really do care about - Python's convention of being explicit. The implicit returning in Ruby functions something I don't appreciate.", "id": "d808305"}], [{"comment": "the funniest thing about this (by far) is the number of people who didn't read it", "id": "d80tx30"}], [{"comment": "can we ban this type of content in here? mods please?", "id": "d7yqedg"}, {"comment": "Yeah we should forbid poking fun at ourselves once in a while. This is no place for levity.", "id": "d7zhurn"}, {"comment": "I concur\n\nthat's the one case where shooting the messenger makes total sense", "id": "d7z0zo5"}], [{"comment": "Some people laugh at Ruby and consider Python to be a more serious programming language. But I laugh much more about the Pythons than I will ever laugh about Rubies.", "id": "d7ymwtd"}, {"comment": "This post, lacking any and all content or contribution to the discussion, gets upvotes?\n\nI weep for the state of reddit.", "id": "d7ynq2c"}, {"comment": "That explains why you didn't get the joke. Must be all the tears in your eyes.", "id": "d7yoocu"}, {"comment": "No, I think *actually having a sense of humor* is the culprit there.", "id": "d7yot6u"}, {"comment": "[They're not funny at all](https://www.youtube.com/watch?v=ZPfEWVbBcgY ).", "id": "d7yocah"}]]], "46jxzk": ["Deadly Linux Bug Puts Millions Of Systems At Risk, Patch Now Available", "2016-02-19 13:10:21", 0, "http://www.techtimes.com/articles/134191/20160217/deadly-linux-bug-puts-millions-of-systems-at-risk-patch-now-available.htm", [[12, "\"Deadly\"...\n\n> Payloads needed for exploiting this for code execution are probably not going to be well-formed responses and will likely get dropped en route\n\nhttps://www.grahamcluley.com/2016/02/years-old-critical-gnu-library-vulnerability-patched-open-source-providers/"], [8, "Deadly hyperbole spreads fear to trillions of internet users."], [0, "Another day, another buffer overflow...\n\nhttps://googleonlinesecurity.blogspot.co.uk/2016/02/cve-2015-7547-glibc-getaddrinfo-stack.html"]], [[{"comment": "\"Deadly\"...\n\n> Payloads needed for exploiting this for code execution are probably not going to be well-formed responses and will likely get dropped en route\n\nhttps://www.grahamcluley.com/2016/02/years-old-critical-gnu-library-vulnerability-patched-open-source-providers/", "id": "d05rn4c"}], [{"comment": "Deadly hyperbole spreads fear to trillions of internet users.", "id": "d05tsys"}], [{"comment": "Another day, another buffer overflow...\n\nhttps://googleonlinesecurity.blogspot.co.uk/2016/02/cve-2015-7547-glibc-getaddrinfo-stack.html", "id": "d05prl5"}, {"comment": "I wonder if there's some way to implement libc in a memory-safe language? Is there some reason that libc *must* itself be written in C?", "id": "d05slo9"}, {"comment": "It's possible; libc is mostly there to allow programs to call system calls in a slightly nicer manner. You can write a shim for other languages that don't use libc, but they'd need to be written in a language that allowed particularly low level manipulation of memory and registers and to call particular CPU instructions to perform the jump from user space to kernel space. You could write that shim in assembly if you were feeling particularly brave. Once you have that, and any associated infrastructure, there's no reason why you couldn't live without libc. \n\nhttp://www.usna.edu/Users/cs/aviv/classes/ic221/s14/lec/08/lec.html has a little more information.", "id": "d05uey6"}, {"comment": "1. A lot of what libc does involves handling raw pointers and not handling cases where doing the wrong thing becomes possible, or even necessary (e.g. casting random `int`s to `char *` and passing them to `strlen()`). You could create a sort of pass-through layer with `extern C` with a safe language before handing things off to the hardware or kernel, but\n\n2. Performance is a big deal. A lot of the C standard library is even written in assembly to squeeze an extra couple of instructions out of things like loops (have a look at the implementations of string functions, for example).", "id": "d05xhg5"}, {"comment": "Could you expand on this? Is there any such language that comes to your mind?", "id": "d05t9up"}, {"comment": "Rust, D, Ada\u2026 Even C++ can be kind of coerced into being sorta-safe.", "id": "d05tera"}, {"comment": "But can they call specific CPU instructions, modify specific registers, and individual words in memory? Because without that, they are unable to call kernel system calls, and then your program wouldn't be able to do anything. \n\nC++ would obviously be able to do so.", "id": "d05uk8s"}, {"comment": "If it can call C functions, it can also call a hand-written assembly routine for issuing a system call. Doesn't mean the whole library has to be written in assembly.", "id": "d05uvld"}, {"comment": "I didn't say it all had to be written in assembly. If you see my comment above, I said you needed a shim. You'd need some method of calling from your language to system calls. Unless your language has some native way of making the system calls, you need to link to something that can. For most languages currently, that's libc. My point is that you can't write it all in a language that doesn't support those features. You need support from something like libc. \n\nThose languages you listed do have inline assemby support, which is what I was asking you.", "id": "d0676ah"}]]], "48wnhi": ["Frequently Rediscovered Technologies", "2016-03-04 12:25:22", 0, "http://www.johndcook.com/blog/2016/03/01/frequently-rediscovered-technologies/", [[4, "Not even an article on the subject, just a post asking for commenters to suggest frequently rediscovered technologies in programming."]], [[{"comment": "Not even an article on the subject, just a post asking for commenters to suggest frequently rediscovered technologies in programming.", "id": "d0nbkcd"}]]], "4192z1": ["Thank you GitHub -- Open letter", "2016-01-16 19:34:39", 0, "https://github.com/thank-you-github/thank-you-github", [[8, "> Full Stack Engineer Top ranked in USA\n\nSo this is some kind of ad?"], [6, "This seems to be an indirect reply to [Dear GitHub](https://github.com/dear-github/dear-github)..."], [3, "It'd be nice if the annotations of the tag were in a git annotated tag.... Right now if you tag a repo in the GUI, github will make a lightweight tag, and the annotations will be stored in githubs db. "], [-19, "I love GitHub, but I wish it would have been SubversionHub or MercurialHub instead, heck, even TFSVCHub would have been better than shitting GitHub."]], [[{"comment": "> Full Stack Engineer Top ranked in USA\n\nSo this is some kind of ad?", "id": "cz0ofr1"}, {"comment": "Click the link. Seems to be an entirely pointless set of rankings based on GitHub data. Apparently I'm the 5th best Smalltalk developer in the UK (there are 6 of us it seems). I've never written a single line of Smalltalk, so number 6 must be really useless.", "id": "cz0q7wo"}, {"comment": "Then you've cloned, or contributed to repositories which use Smalltalk. Pretty simple stuff.", "id": "cz1ca4z"}, {"comment": "No, I've got one repository that has files with an .st extension, none of which are actual Smalltalk files (they are StringTemplate template files).", "id": "cz1fke4"}], [{"comment": "This seems to be an indirect reply to [Dear GitHub](https://github.com/dear-github/dear-github)...", "id": "cz0hkut"}, {"comment": "Most likely. And that's why it comes off as more of an asshole move than appreciative. The timing effectively sends the message, \"Hey! We appreciate you! As opposed to those curmudgeons that wrote an open letter asking for improvements...\" \n\nWhich wouldn't be the impression if the repository came up at another time. But then again it wouldn't have been so popular.", "id": "cz0kzb0"}, {"comment": "Not particularly. I'm not sucking Github's dick or anything, but some of the wording in that Dear Github bullshit was just stupid.\n\n> Issues and pull requests are often created without any adherence to the CONTRIBUTING.md contribution guidelines, __due to the inconspicuous nature of the \u201cguidelines for contributing\u201d link when creating an issue__\n\n[How the fuck is this giant yellow fucking div inconspicuous](https://d.maxfile.ro/vrbkmchjay.png)? Then it goes on to say;\n\n> and the fact that it often contains a lot of information that isn\u2019t relevant to opening issues\n\nThe contents of `CONTRIBUTING.md` is __entirely__ controlled by the project maintainer. How __the fuck__ is this an issue with Github? It's literally blowing my mind.", "id": "cz1cd9x"}, {"comment": "You know how it is, a \"response\" to literally anything can make you \"famous\".", "id": "cz0hwfx"}], [{"comment": "It'd be nice if the annotations of the tag were in a git annotated tag.... Right now if you tag a repo in the GUI, github will make a lightweight tag, and the annotations will be stored in githubs db. ", "id": "cz0kcel"}, {"comment": "You can't make non-lightweight tags without signing them, I thought?", "id": "cz0o8su"}, {"comment": "Can be signed, but are not required.\n\nThey are stored just like any other object would be; checksummed with name, email, date", "id": "cz0tivk"}], [{"comment": "I love GitHub, but I wish it would have been SubversionHub or MercurialHub instead, heck, even TFSVCHub would have been better than shitting GitHub.", "id": "cz0i0py"}, {"comment": "I shivered at TFSVCHub. Microsoft already provides Visual Studio Team Services for those brave enough.", "id": "cz0lokg"}, {"comment": "I use it for every project I get to make the choice and am super happy with it. However they do not provide a way to open source stuff hosted there (no public access and you have to grant permissions to people you want to access the project) so Visual Studio Online (as it is now called due to Microsoft's obsession with renaming things) won't do as a replacement for GitHub even for those brave enough.", "id": "cz0r98l"}, {"comment": "I know that feeling. I catch myself muttering \"fucking TFS\" or some derivative thereof far too many times per week. ", "id": "cz108lc"}]]], "3xyrxp": ["Cool is a stupid metric for tech", "2015-12-23 17:27:56", 2, "http://scionsoftware.com/Blog/cool-is-a-stupid-metric-for-tech/", [[7, "The low level factor...ah the low level factor. I chuckled a bit when I hit that section.\n\nI can't even count how many times someone has trumped or one up'd me in a conversation with the fact that they can \"code machine language\". Not sure how that makes you better than someone else. Not sure why its always the trump card in someones pocket either. Yeah, it is as you say, a flavor of \"cool\" (Cool being a very subjective term)...but people I have encountered just make it sound annoying and cocky. \n\nBut if it works for them, hey, that is cool. "], [8, "But... But if I can't lord the fact that I wrote my company's entire web infrastructure in Haskell and am serving it through a reverse proxy written in ASM, how will I ever prove that I'm better than those filthy PHPeasants? /s"], [6, "\"Let your problem choose\" is a content-free mantra for tech."]], [[{"comment": "The low level factor...ah the low level factor. I chuckled a bit when I hit that section.\n\nI can't even count how many times someone has trumped or one up'd me in a conversation with the fact that they can \"code machine language\". Not sure how that makes you better than someone else. Not sure why its always the trump card in someones pocket either. Yeah, it is as you say, a flavor of \"cool\" (Cool being a very subjective term)...but people I have encountered just make it sound annoying and cocky. \n\nBut if it works for them, hey, that is cool. ", "id": "cy8y9mw"}, {"comment": "Ask them if they also kill their own food?\n\nDid they forge the knife to do that ?\n\nDid they mine the ore to forge the knive ?\n\nWhere did the tools to mine that ore come from?  They'd didn't use their bare hands ?\n\nThis is mostly certainly the path of hipsterism. FWIW, I do keep my own chickens.  So there!\n\nSO yeah, coding in machine language is useful for understanding. All those gobs of different techniques to handle concurrency come down to, in most cases, the atomic test and set. But really, I haven't coded one of those in assembly since 1990. I stand on the shoulders of others and I'm darn glad I do.  Mining ore is awful work.", "id": "cy96piq"}, {"comment": "Edit: I replied to the wrong message. Your message is cogent and reasonable. Sorry for misattribution.", "id": "cy9bcux"}, {"comment": "When someone says that, just ask them how much \"machine code\" they written that's actually in production.", "id": "cy9691w"}, {"comment": "So, what, because most drivers can't make a car it's irrelevant to make cars?\n\nYou've chosen a limited skill set and it's working for you. Don't be salty that you rely on the work of others to get you where you're going.", "id": "cy9bjmz"}, {"comment": "I think you missed my point.  Someone trying to be cool by saying they can build a car, doesn't mean a whole lot if they haven't actually built a car.", "id": "cy9ca6r"}, {"comment": "You should encourage them, not dig at their na\u00efvet\u00e9. \n\nFor my part, I'd hire a self-taught assembly coder over many college graduates. Every product I've built has needed some level of machine intimacy, which is a skill that is much harder to acquire than are basic algorithms or data structures.", "id": "cybqcz6"}, {"comment": "[deleted]", "id": "cy97jj5"}, {"comment": "Said another way: not every driver needs to know how to repair their car.", "id": "cy9bkkx"}, {"comment": "I never expected to have to read or write assembly outside of my educational experience. When it came up professionally and was the tool for the problem at hand, it was awful. It worked, but was unpleasant and difficult to maintain.\n\nWhenever someone mentions \"writing in assembler\" or \"machine language\" I mentally substitute \"earring shit\" and carry on.  ", "id": "cy98sqz"}], [{"comment": "But... But if I can't lord the fact that I wrote my company's entire web infrastructure in Haskell and am serving it through a reverse proxy written in ASM, how will I ever prove that I'm better than those filthy PHPeasants? /s", "id": "cy8zogn"}, {"comment": "Careful. Those peasants are legion.", "id": "cy98hfb"}], [{"comment": "\"Let your problem choose\" is a content-free mantra for tech.", "id": "cy8zl11"}]]], "54lqpd": ["There Is No \u201cUser\u201d", "2016-09-26 21:24:09", 15, "https://blog.eventsourcing.com/there-is-no-user-acb7d367469f", [[33, "This felt like an exercise of how to say absolutely nothing in as many words as possible.\n\nA user is an identity that can use the application, be it a machine or a person. It's not that f\\*\\*king complex."], [32, ">But, if everybody and everything has this role, isn\u2019t this an equivalent of not having it at all?\n\nThis seems rather existential.   But, no.  I don't agree.  It's a classification.  A bucket.  \n\nAdmin, owner, etc are all types of users.  Things you would surround with a circle titled \"users\" in an Euler diagram.  "], [19, "\"There are only two hard things in Computer Science: cache invalidation and naming things.\"\n\n-- Phil Karlton"], [4, "> One of the interesting aspects of introducing something into existence by merely referencing it is that it allows you to decide just _what that was_ later, if ever!\n\nThat's great. In the meantime, I'm just going to store this new record in my `user` table.\n\nSeriously, how do you even persist this anti-model in a traditional structured/typed data store? Have we finally found the poster child use-case for NoSQL persistence?"], [3, "https://www.youtube.com/watch?v=dzm8kTIj_0M"], [3, "Avdi Grimm has an excellent Tapas episode on this very issue of 'User':\nhttps://www.rubytapas.com/2015/10/01/episode-346-user-model/"]], [[{"comment": "This felt like an exercise of how to say absolutely nothing in as many words as possible.\n\nA user is an identity that can use the application, be it a machine or a person. It's not that f\\*\\*king complex.", "id": "d833fin"}, {"comment": "I thought the title and intro was going somewhere interesting, then it ended and I was left wondering, what the hell was he trying to say? ", "id": "d83dr5u"}, {"comment": "I was trying to say that there is no user, that we use some of the models because of the inertia and convention \u2014 and it is interesting to  deconstruct things; challenge the notion of rigid, set and non-piuralistic domain models.", "id": "d83e1uj"}, {"comment": "I understand you're getting a lot of hate and not a lot of feedback. People read your article hoping to find something tangible they can do to become a better developer, or at the very least learn something new.\n\nInstead, I was left wondering what you were trying to say.", "id": "d83ennw"}], [{"comment": ">But, if everybody and everything has this role, isn\u2019t this an equivalent of not having it at all?\n\nThis seems rather existential.   But, no.  I don't agree.  It's a classification.  A bucket.  \n\nAdmin, owner, etc are all types of users.  Things you would surround with a circle titled \"users\" in an Euler diagram.  ", "id": "d82y8v9"}, {"comment": "Sure, a classification/bucket. But, if absolutely everyone has that Admin classification \u2014 how meaningful this classification really is? If we all can now modifying anything, what does it *mean* to be an admin?", "id": "d82yp9e"}, {"comment": "That there's only one type of user on that system. \n\nIf there are only going to be admin users, and nothing else, then, sure, it's pointless to create/specify a user bucket/base permissions.  But in the fast-paced library systems of today that would probably take more effort than just simply sticking with the user model.  ", "id": "d82zbgf"}, {"comment": "> That there's only one type of user on that system.\n\nThis statement could be read as equally 'existential' (whatever that designation might imply) as the statement you just condemned.\n\nI think it would be very difficult to argue, both from a concrete as well as a philosophical (dare I say... *existential*) view that the 'single-bucket distinction' isn't one at all. The existence of a particular culture of libraries and the people who write them gives us a very limited view into how 'justifiable' such a system is.", "id": "d83aicm"}, {"comment": "Are you mixing authentication and authorisation?", "id": "d832x5p"}, {"comment": "\"User\" is a record against which you authenticate someone or something, and give them access to your application. They can \"use\" your application. Some users have special roles such as \"administrator,\" and they can do things other users can't, such as configure the application. The parent comment is 100% on point. OP and the author must be smoking something that makes them question reality. Probably DMT.", "id": "d83539r"}, {"comment": "You don't even need different roles. Different users don't have the same rights to all the same actions & resources. E.g. each user can create/read/edit/delete their own messages and no others', even if all users can create/read/edit/delete messages as a general feature.\n\nYou're not likely to start calling them MessagesWithOwningAuthorizationTokens.", "id": "d83835i"}, {"comment": "What about moderators of a forum? Should they be unable to censor or delete someone else's posts? I give that as an example. What if the system doesn't include this ability at all? You are thinking too narrow. You arent going to use permissions to grant administrators rights to all posts. You would use roles.", "id": "d83au0y"}, {"comment": "> But, if absolutely everyone has that Admin classification \u2014 how meaningful this classification really is? If we all can now modifying anything, what does it mean to be an admin?\n\nBut not absolutely everyone is an Admin, and not absolutely everyone is a \"User\". To be a user, you need to create an identity for yourself at the application (or use an identity created elsewhere, that the app accepts). This identity makes you unique by definition, and that's the purpose of there being \"users\".", "id": "d833r1r"}], [{"comment": "\"There are only two hard things in Computer Science: cache invalidation and naming things.\"\n\n-- Phil Karlton", "id": "d82z1kq"}, {"comment": "\"There are only two hard things in Computer Science: cache invalidation, naming things and off-by-one errors.\"\n\n-- Leon Bambrick", "id": "d8312dk"}, {"comment": "\"There are only two things in Computer Science: cache invalidation, naming things, and zero-based numbering.\"\n\n-- Michael Scott", "id": "d839lsf"}, {"comment": "The count is still three, regardless of indexing. ", "id": "d83rabu"}, {"comment": "\"The upper bound of things in Computer Science is two.\"", "id": "d83v0w8"}, {"comment": "\"There are only three hard things in Computer Science:  naming things and cache invalidation.\"\n\nis a slightly terser way to accomplish the statement that I've always liked.  ", "id": "d83d064"}, {"comment": "Cache invalidation, and naming things. , race conditions", "id": "d836siz"}, {"comment": "By contrast, there's only one hard thing in Norse mythology: Thor's hammer, Mj\u00f6lnir.", "id": "d836vot"}, {"comment": "What about remembering that you like doing your work, you really do, and that if this damn bug would just show itself then everything would be just fine?", "id": "d83q1o6"}], [{"comment": "> One of the interesting aspects of introducing something into existence by merely referencing it is that it allows you to decide just _what that was_ later, if ever!\n\nThat's great. In the meantime, I'm just going to store this new record in my `user` table.\n\nSeriously, how do you even persist this anti-model in a traditional structured/typed data store? Have we finally found the poster child use-case for NoSQL persistence?", "id": "d834pgl"}, {"comment": "I actually avoid the word \"user\" in my auth model, not because I mind the word, but simply because it has some connotations that are incorrect in my model, or too ambiguous.\n\nInstead, I call it an \"identity\". So an app that can call my API has an identity, and a person who uses the app also has an identity, and every API call is sent with an auth record containing:\n\n- principalTokenId (typically the person using the app to access my API)\n- agentTokenId (typically the app using my API on behalf of the principal)\n\nAnd then I can have other identities in the actual API parameters, such as \"ownerId\" for a resource which is fetched or modified.\n\nIt's more specific than simply having a \"user\" as it's clear which role I'm referring to at every field (principal, agent, owner, etc.). I had a more interesting reason to avoid the word \"user\" but I forgot what it is. Whoops.", "id": "d835hxv"}, {"comment": "Yeah, this seems like a useful distinction. It bugs me, for example, when I have to create 'users' in Linux to serve some system need (run a daemon, allow remote access, sync data, whatever). It's annoying to clutter the /home dir with system accounts, and it's equally annoying for a 'user' not to have a home dir to store settings (ssh keys, for example). Users masquerading as other users via sudo/su is ugly, and group permissions are a pain in the ass to maintain.\n\nAltogether, it seems like (at least) two ideas are being conflated: identity, and role. Maybe you could throw in 'actor', I dunno. But I think the OP has a point, 'user' is a massively overloaded term.\n\nedit: thanks for the gold!", "id": "d83ahev"}, {"comment": "Perhaps systems should have owners instead of users, and some owners can have a flag that prevents the creation of a home directory, making them homeless.  `chown` would make more intuitive sense.\n\nAlso, rename root to god, or something else that supercedes/ignores ownership (robot_overlord perhaps?).  root is too confusing with root directories.", "id": "d83wkrb"}, {"comment": "I don't hate this.", "id": "d8399on"}, {"comment": "\"Have we finally found the poster child ~~use~~(thing that is not a use)-case\"", "id": "d841mvb"}], [{"comment": "https://www.youtube.com/watch?v=dzm8kTIj_0M", "id": "d830irg"}], [{"comment": "Avdi Grimm has an excellent Tapas episode on this very issue of 'User':\nhttps://www.rubytapas.com/2015/10/01/episode-346-user-model/", "id": "d83o1p4"}]]], "4s37sq": ["TIOBE's Language-Popularity Index Sees A New Top 10 Language: Assembly", "2016-07-10 04:57:07", 1, "https://developers.slashdot.org/story/16/07/09/2112255/tiobes-language-popularity-index-sees-a-new-top-10-language-assembly", [[13, "when are people going to stop listening to this silly report?"], [5, "> Even your toothbrush or coffee machine are running assembly code nowadays.   \n\nErr, I'm sure that has always been the case since compiled languages usually compile to assembly in the form of object code. Even the distinction between assembly and machine code is nearly pure semantics (besides asm macros and microcoding, they are textual and binary representations of the same thing)."]], [[{"comment": "when are people going to stop listening to this silly report?", "id": "d567jl7"}, {"comment": "Yes! You're absolutely right that this index is so flawed that people should stop referring to it. Personally, I much prefer the [Programming Language Popularity Chart](http://langpop.corger.nl/), although I'm not sure how frequently it is updated. I suppose any such chart is going to be flawed in some way.", "id": "d56nhq9"}, {"comment": "It makes it sound like they have access to a complex data set and do quality analysis (if you read nothing more than the description on the page), but if you click the 'how we calculate' link, you'll see that they are just running some filters on search results on a bunch of search engines.\n\nBasically, they are calculating how much SEO money or effort is spent on each language. While I'm sure there is some modest correlation, what they are claiming the TIOBE language index is good for and what it actually measures are completely different things.", "id": "d570gdy"}], [{"comment": "> Even your toothbrush or coffee machine are running assembly code nowadays.   \n\nErr, I'm sure that has always been the case since compiled languages usually compile to assembly in the form of object code. Even the distinction between assembly and machine code is nearly pure semantics (besides asm macros and microcoding, they are textual and binary representations of the same thing).", "id": "d5658wc"}, {"comment": "There's a significant difference between *mov ax, 1234* and *a=1234*, though. Assembler is different on each machine, whereas \"compiled (high level) languages\" are more or less the same on every machine; assembly isn't one language, but many.\n\nOne thing the comment doesn't mention about why it is surprising is that it is generally considered that C (aka \"the portable assembler\") compilers are generally considered to be better at generating optimal code, partly because nobody wants to specialize in programming in assembler because it won't get you a job because C is good enough for low-level programming. It's a catch-22.\n\nOne explanation of this surprising rise might be the popularity of the ARM platform: it is a large family of processors that share the same basic assembler and it is often used in embedded products where efficiency matters (not only speed or size, but also power consumption).", "id": "d56fce5"}, {"comment": "Regarding ARM (warning, tangent follows), most of the Cortex-M parts are between 1 and 10 dollars, nearer $1 for Cortex-M0/M0+ and closer to $5 and $10 for Cortex-M3/4/7. I found out the other day that for one of the projects I'm involved in uses an MSP430 priced somewhere around $10! You can have a part meant to run an automotive entertainment system but they are using a part that is comparable to a Cortex-M0+.\n\nThe point, it is hard to choose a part that *isn't* ARM these days.", "id": "d56n2fj"}, {"comment": "I think the point is that your previous toothbrush did *not* run code.", "id": "d565ajw"}]]], "4kj04x": ["The Only Correct Indent Style", "2016-05-22 19:29:42", 0, "http://www.terminally-incoherent.com/blog/2009/04/10/the-only-correct-indent-style/", [[21, "I never understood why people prefer Allman style.  \nSeems like a waste of space to have the braces on different lines.  \n  \nBut to each their own, I guess."], [20, "This little quiz leaves out the correct answer: \"Whatever style is already present.\" Brace style is a trivial thing, you can adjust to whatever-- but when people switch styles within the same function, ow."], [13, "I started with Allman style but found myself \"evolving\" to K&R. It's less wasted whitespace and I can read it better. It also feels more natural too."], [5, "Notably missing is [Arthur](http://www.nsl.com/papers/origins.htm)."], [4, "Horstman & Pico fail to separate structure from content.\n\nAllman, Whitesmith, & GNU waste vertical space, limiting onscreen code.\n\nGNU wastes horizontal space, limiting (sensible) line length. \n\nI kind of like how Whitesmith & Banner look... but the point of braces is that they're *outside* the code. They define scope. They shouldn't be placed as though they're part of the scope. \n\nK&R means never having to say you're sorry."], [3, "Whitesmiths. Rationale: I see braces part of a scope block, and sice we're indenting blocks, braces should be, too. "], [2, "Modified K&R, braces on statement, but closing branch on own line:\n\n    if (thing) {\n         do thing\n    }\n    else if (thing) {\n         do thing\n    }"], [2, "K&R for Javascript for reasons  such as:\n\n    return \n    { \n        not: 'what you think'\n    };"], [2, "K&R\n\nBut when I open up someone else's code, I'm just happy to see an indentation style."], [1, "Modified K&R, braces on statement, but closing branch on own line:\n\n    if (thing) {\n         do thing\n    }\n    else if (thing) {\n         do thing\n    }"], [0, "I do not believe that people still argue about it. Python solved this problem long ago."]], [[{"comment": "I never understood why people prefer Allman style.  \nSeems like a waste of space to have the braces on different lines.  \n  \nBut to each their own, I guess.", "id": "d3f9lzu"}, {"comment": "It's an excellent visual indicator of scope boundaries.  If the opening brace and closing brace are in the same column, its much easier to see where a block starts and ends.  This is particularly helpful when you have a lot of nesting.  \n\nI think more than anything though, it's the way people are taught that influences a lot of these habits.  If your teachers used single letter variable names, you will too.  If your teachers put a space between the function name and the opening parentheses, so will you.  If your teacher leaves off curly braces for single statement conditionals, you will too.  ", "id": "d3fd9o1"}, {"comment": "More often I care about what sort of block it is than where it begins. K&R is far superior in that setting.", "id": "d3feg5u"}, {"comment": "Could you give an example?  ", "id": "d3ffs09"}, {"comment": "No because it's a false argument.\n\nThere's nothing fundamentally more informative about \n\n    if (1=1) {\n        // ...\n    }\n\nthan \n  \n    if (1=1)\n    {\n        // ...\n    }\n\nIn both cases it's absolutely unambiguous that the block is an if statement. The former does nothing more than the latter to directly convey this fact.\n\nAs an aside, though nested flow control statements can often be a sign of larger structural issues, the K&R style can actually be more ambiguous with nested blocks. Example (using 2 space indent for exaggerated demonstration effect):\n\n    if (someVariable = someCondition) {\n      for (int i=0; i<10; i++) {\n        while (state == something) {\n        }\n      }\n    } else {\n    }\n\nIn this case, the Allman style has a clear advantage in separating code blocks visually:\n\n    if (someVariable = someCondition) \n    {\n      for (int i=0; i<10; i++) \n      {\n        while (state == something) \n        {\n        }\n      }\n    } \n    else \n    {\n    }\n    ", "id": "d3fgh80"}, {"comment": "The Allman style is so verbose I can barely see what is going on. Add a few \"edge-case\" ifs to make the problem worse.", "id": "d3fhkps"}, {"comment": "While Allman is cleaner, it also has a lot to do with what you're used to.  When I look at the above example, the K&R code is a jumbled mess, while I can parse the whole Alman version with a single glance.  ", "id": "d3fjx60"}, {"comment": "The K&R style is so smashed together, I can barely see what is going on.", "id": "d3fl6td"}, {"comment": "Oh you edgy", "id": "d3flt96"}, {"comment": "Indent the braces, too. Makes it clearer. ;)", "id": "d3fruir"}, {"comment": "> This is particularly helpful when you ~~have a lot of nesting~~ write bad code", "id": "d3fpbku"}, {"comment": "    using (var something = new Something()) {\n      using (var somethingElse = new SomethingElse(something) {\n        using (var SprocketOrAnother = new ScopingDedicatedAdapter (somethingElse, new DataScrambler(simething, true)) {\n          SprocketOrAnother.doMenialWork(someArgs, addAConstantHere, Util.ReadSomePreferences());\n         }\n      }\n    }\n\nOr magnificent patterns like that. Nesting is bad?", "id": "d3frcop"}, {"comment": "    using (var something = new Something())   \n    using (var somethingElse = new SomethingElse(something)  \n    using (var SprocketOrAnother = new ScopingDedicatedAdapter (somethingElse, new DataScrambler(simething, true))\n    {\n        SprocketOrAnother.doMenialWork(someArgs, addAConstantHere, Util.ReadSomePreferences());\n    }\n\nThere's no need for nesting here.", "id": "d3g5eex"}, {"comment": "So you'd never indent using statements? What would bother me is the cases where the curly brackets are necessary:\n\n    using (...) {\n    do a bunch of things\n    do more things\n    using (...) {\n    more things nested\n    more and more\n    }\n    }\n\nBut yes, when the code blocks only have one statements and the curly brackets aren't necessary, it's a lot better to omit them.", "id": "d3gg16c"}, {"comment": "> Seems like a waste of space\n\nare you paying for them ? :)", "id": "d3faqqs"}, {"comment": "I do, actually: with time needed to scroll through them.", "id": "d3fcvxv"}, {"comment": "Paying for what?", "id": "d3farvn"}, {"comment": "The lines.", "id": "d3fc1gm"}, {"comment": "Sometimes you print code, and being able to fit a function on one page is important for legibility.  In that case wasting lines does matter.\n\nAny style that puts code on the same line as control is dangerous.  Braces should be o. The same line as the control code (k&r) or totally separate (Allan).  I worry less about the indents than about logic errors introduced by having to move braces when adding code.", "id": "d3fgi98"}, {"comment": "You do what? I sure hope your code doesn't have to be copied into your TPS reports.", "id": "d3fh3er"}, {"comment": "Good grief, printing code out to read it isn't strange. We'd still do it often if we hadn't let code size spiral so far out of control. You're never going to get a monitor with as much real-estate as a bunch of sheets of paper (I will happily eat my words when wall-sized monitors get cheap).", "id": "d3fl3nd"}, {"comment": "I often work out new code by pseudocoding on paper, but I have never printed existing code in my working career.", "id": "d3fxdqw"}, {"comment": "Try it!", "id": "d3fxwmh"}, {"comment": "I personally can't stand K&R.  I find the fact that the matching brackets are not lined up, mildly infuriating.  I do have my biases, given that I do most of my work in C#, and Allman is the default Visual Studio style.", "id": "d3fc84p"}, {"comment": "[deleted]", "id": "d3fh23u"}, {"comment": "The only reason I can stand K&R in JS is because there are actual syntax reasons for placing the { on the same line.", "id": "d3fkvgf"}, {"comment": "VS also squishes the line a bit when there's only a curly brace, saving some space", "id": "d3fft86"}, {"comment": "My personal preference: \n\nK&R for single line conditionals. (Which should cover the majority of uses).\n\nAllman for multi-line ones", "id": "d3fg3d4"}, {"comment": "Take that too far and you'll indent like a Lisper.\n\n    int foo() {\n        bar();\n        baz();\n        return quux;}", "id": "d3fa6y1"}, {"comment": "I personally write this as\n\n    int foo() { bar(); baz(); return quux; }\n\nThe biggest disadvantage of this style is that debuggers are usually line-oriented. But I can see much more code on the screen at once and it encourages short functions, which is why I currently prefer the \"1 line = 1 function\" style.", "id": "d3fcm50"}, {"comment": "Me too, but mostly because our tools suck and can't do stuff like:\n\n    (defun i-am-done-with-c-for-today (and here is a function)\n      (which has fairly long lines))\n                    |                           |\n    (defun tiny ()  |  (defun small ()          |  (defun also-tiny ()\n      (bar))        |    (still pretty small))  |    (we fit like this))\n                    |                           |\n\nIt's so dumb that we're obsessing over vertical space rather than just using horizontal space properly, like this and by having a multi-column view in our editors.\n", "id": "d3fd5ng"}, {"comment": "Honestly, I think that looks better than Allman;  \nIt reminds me of python... With extra bits stuck on.", "id": "d3faagf"}], [{"comment": "This little quiz leaves out the correct answer: \"Whatever style is already present.\" Brace style is a trivial thing, you can adjust to whatever-- but when people switch styles within the same function, ow.", "id": "d3f9yg3"}, {"comment": "Even more preferably, \"whatever style the automatic formatter is set up to use\".", "id": "d3fae53"}, {"comment": "So much this. I use visual studio from at least 3 locations on a daily basis (home, work, laptop) and even I have trouble avoiding the automatic format hell sometimes. Asking an entire development team to standardize to something NON-default is just begging for trouble.\n\nUnless it's tabs vs. spaces (4 space represent!)", "id": "d3fg9qf"}, {"comment": "We check in a Resharper settings file that helps keep people on track.", "id": "d3flb4b"}, {"comment": "All the while resharper bogs down your developer machines. \n\nI get it. The features are nice. But I've tried numerous versions and all suffer from the same \"get in your way\" nature of overarching plugins.", "id": "d3flehm"}, {"comment": "Performance was a problem in VS 2005 with Resharper... I dunno, 4?  It hasn't been a problem for me for years.", "id": "d3flfs5"}, {"comment": "Last I tried was 2013 with v6. Won't even bother installing it on my 2015/Win10 box.", "id": "d3flk7m"}, {"comment": "Well there's your problem.  R#6 didn't support VS2013.", "id": "d3flnk5"}, {"comment": "Yeah that's not true at all. ", "id": "d3fp0cl"}, {"comment": "https://www.jetbrains.com/resharper/documentation/resharper7_vs_resharper6.html", "id": "d3fp76q"}, {"comment": "Tab is a character that literally means \"one level of indentation\"! Its appearance can be customized on any editor. There is no reason to ever not use tabs!", "id": "d3ic5qy"}, {"comment": "I can agree with that, if everyone on a team is required to use tabs. ", "id": "d3icki3"}, {"comment": "Why press a button four times when you can press a button once?", "id": "d3fm831"}, {"comment": "Why code in Notepad when in any other editor that wouldn't be required?", "id": "d3fmrw9"}, {"comment": "Use tabs. But tell your editor to replace it with 4 spaces. Most handle shift+tab equally as smart.", "id": "d3fp0ul"}, {"comment": "\n> but when people switch styles within the same function, ow\n\nEven if brace style stays consistent within a file, inconsistency between files in project is still a major issue.\n\nA. Forcing editors/IDE to switch between styles is a major hassle\n\nB. Some styles are outright incompatible with each other reading wise. E.g I can read whitesmith and K&R easily but I cannot switch between them easily as closing brace placement sends different signals\n\nC. GNU style is just ridiculous: visually jagged (too many levels) and just too artificial\n\nD. Do you really want every developer to have to go through learning curve/setting adjustments.. \n\nWhich basically means that K&R and Allman are the only sane choices..", "id": "d3fghcv"}, {"comment": "I said \"within the same function\" because I've seen that *done*. I used to have a printed page from the source of the Windows clipboard viewer, with four different brace styles showing up in the same twenty-line section of code...", "id": "d3fy1vi"}], [{"comment": "I started with Allman style but found myself \"evolving\" to K&R. It's less wasted whitespace and I can read it better. It also feels more natural too.", "id": "d3ffqb4"}, {"comment": "Yeah same here. Seems like most C and C++ projects I've seen are K&R, and working with Go (`go fmt`) and Python (no braces) might have something to do with me preferring K&R. Looks like the Rust community is also heavily favoring K&R style.\n\nEdit: Allman style seems to be most common in the Windows, C# and PHP community.", "id": "d3fia32"}, {"comment": "Yep, Visual Studio reinforced Allman for me, but then I stopped doing so much Windows/VS/C# dev and started doing more *nix and OS X development and that's when the tools let me explore my own style and I settled on a mostly K&R style.", "id": "d3fmawn"}, {"comment": "> I started with Allman style but found myself \"evolving\" to K&R.\n\nSame here.  For years I used Allman, but switched to K&R a couple of years ago.  It's a bit more compact, yet still easy to read.", "id": "d3fiqxn"}, {"comment": "Ditto.  I used Allman in my C code for 20+ years, but a few years of working with Java has finally made me a K&R convert.\n", "id": "d3iq8bu"}], [{"comment": "Notably missing is [Arthur](http://www.nsl.com/papers/origins.htm).", "id": "d3feryr"}], [{"comment": "Horstman & Pico fail to separate structure from content.\n\nAllman, Whitesmith, & GNU waste vertical space, limiting onscreen code.\n\nGNU wastes horizontal space, limiting (sensible) line length. \n\nI kind of like how Whitesmith & Banner look... but the point of braces is that they're *outside* the code. They define scope. They shouldn't be placed as though they're part of the scope. \n\nK&R means never having to say you're sorry.", "id": "d3fg58q"}], [{"comment": "Whitesmiths. Rationale: I see braces part of a scope block, and sice we're indenting blocks, braces should be, too. ", "id": "d3fdkst"}], [{"comment": "Modified K&R, braces on statement, but closing branch on own line:\n\n    if (thing) {\n         do thing\n    }\n    else if (thing) {\n         do thing\n    }", "id": "d3fr4xa"}], [{"comment": "K&R for Javascript for reasons  such as:\n\n    return \n    { \n        not: 'what you think'\n    };", "id": "d3frh2f"}], [{"comment": "K&R\n\nBut when I open up someone else's code, I'm just happy to see an indentation style.", "id": "d3fukeb"}], [{"comment": "Modified K&R, braces on statement, but closing branch on own line:\n\n    if (thing) {\n         do thing\n    }\n    else if (thing) {\n         do thing\n    }", "id": "d3fr4xb"}], [{"comment": "I do not believe that people still argue about it. Python solved this problem long ago.", "id": "d3fhali"}, {"comment": "I think you mean it moved the problem from the water cooler to the debugging session.", "id": "d3fipoz"}, {"comment": "Indentation style problem is artificial. If you indent your code properly you can almost completely ignore braces, because indentation level itself contains all information you need to understand code.", "id": "d3fjdoz"}]]], "45kzd0": ["ASP.NET Monsters (Channel 9)", "2016-02-13 18:42:47", 0, "https://channel9.msdn.com/Series/aspnetmonsters", [], []], "43rxqg": ["The Cat Feeder (great dev interview question)", "2016-02-02 04:48:34", 5, "http://gojoule.com/blog/catfeeder", [[25, "I think it's a useless question. Anyone that owns a cat would surely have a different answer than someday who doesn't, which isn't exactly the level setting I want in an interview question. \n\nWorse, the supposed answer assumes that cats maintain the same behavior / eat the same when their environment changes, which is just not how cats work."], [20, "God I hate these kind of interview questions. \n\nThe answer in context is clear because naturally that's the only thing that will work with the cats behavior, as well as the mechanical limitations of the machine. \n\nBut it's fucking useless. It's a queue consumer optimization question and even if someone gets it right they might have no fucking idea how to make a performant queue consumer implementation. \n\nI have literally never run into any situation remotely like this in my 22 years of programming experience where you have to change the queue input to optimize for the consumers. \n\nThis is why I won't interview with anyone who screens with this kind of shit. "], [8, "If the idea is to encourage solution discovery and agile thinking, then excluding the \"spoiler\" answers and only having one correct, straightforward, boring answer is kind of missing the point.  \n\nReminds me of the classic [barometer problem](http://www.snopes.com/college/exam/barometer.asp)"], [8, "I suppose I wouldn't get hired if my answer were \"Get rid of the cats\" or \"Find friends that can feed your cats while you're gone\"."], [8, ">Creative solutions that don\u2019t violate these rules are greatly appreciated and exploring them is encouraged to learn more about the interviewee, but any solution not conforming with the one below should ultimately be roadblocked.\n\nThis sounds like a terrible interview.  You will give me the exact answer I'm looking for or you are wrong.  How about instead, if they have a reasonable and valid answer, give them your answer and then discuss the trade offs.  You know, like you should do.\n\n&nbsp;\n\nHaving to have a long discussion about the interviewers cats, during the interview?  Nope, thanks for making this easy.  Not saying I have a problem with cat people, but if you do this during an interviewee I know I'll have to hear about your cats all the time."], [8, "What the fuck is an 'auger'?\n"], [7, "Why in the ever-loving fuck does pressing Esc redirect to a Squarespace login?"], [4, "It appears you can get people to try solving your arbitrary puzzles by offering them the prospect of employment."], [2, "For a moment I was going for a full-blown RFID solution."], [1, "What happens to me with brain teasers: I start feeding my right brain. As soon as something begins to emerge, the interviewer says something, and it goes *poof*. This really hurts me if there's a time limit"], [1, "Cat."], [0, "I had the solution in mind before the prompt even finished. Am I silly in thinking it isn't even that difficult? I'm starting to think there are lots off people that try to over complicate things even more than myself.\n\nI'm curious what the interviewer did in these situations; he acknowledges a number of people get the correct solution right out of the gate. Does he not hire them because there was no discussion or did he augment the prompt further? Sounds to me like the interviewer just wants reassurance that they're the boss and are more intelligent than they really are and the candidate will be a productive, subservient employee. I guess it just demonstrates that this wouldn't be a good fit for me, which is fine since there would be plenty of better fitting jobs and if this test was used on a majority of candidates I'm sure they'd all work together well."]], [[{"comment": "I think it's a useless question. Anyone that owns a cat would surely have a different answer than someday who doesn't, which isn't exactly the level setting I want in an interview question. \n\nWorse, the supposed answer assumes that cats maintain the same behavior / eat the same when their environment changes, which is just not how cats work.", "id": "czkqv71"}, {"comment": "Why wouldn't FC just purge and then have immediate seconds?  If the cats' behaviors don't change, then FC would take every opportunity to eat food available, and the \"solution\" doesn't work either.\n\nEdit: As /u/immibis shows, the purging would only happen if FC got full.  There is no indication that the first batch was enough for the cat to be full.", "id": "czkryxj"}, {"comment": "> If they got full during the process, they would go find a dark place to vomit", "id": "czksgl9"}, {"comment": "> the purging would only happen if FC got full. There is no indication that the first batch was enough for the cat to be full.\n\nNot what I meant - the cat can't purge immediately because it has to go and find a dark place first, which gives the other cat time to eat its share.\n\nBut you're also right - what if a cat can eat 20 grams before it's full?", "id": "czkt335"}, {"comment": "The fat cat doesn't have access to the auger because he can't hack the system. The skinny cat can access the auger, but is scared of by the fat cat. ", "id": "czktuvy"}, {"comment": "Because the fat cat can't hack the system so he only has access to 10 grams, which is the whole point of the solution. The skinny cat is the only one that could eat 20 grams. ", "id": "czkttm1"}, {"comment": "Apparently you missed the point of the article - a point I wholeheartedly agree with: It's not about the answer. \n\n> *How do they analyze a complicated and poorly told story problem? What types of questions do they ask? Do they prefer purely technical solutions? Do they get bored and disengage during the info dump? Do they cling to a solution even when presented with evidence that it won\u2019t work? Can they handle being subjected to a long and boring story about a grown man\u2019s cats without foaming at the mouth? In short, are they a creative collaborator?*\n\nAuthor observes (correctly) that an instantaneous correct answer means the question has failed.\n\n\n", "id": "czkui8y"}, {"comment": "> Apparently you missed the point of the article - a point I wholeheartedly agree with: It's not about the answer.\n\nYeah that'd be true if there wasn't actually a preferred answer. An answer that's counter-intuitive to actual cat owners.\n\nIt's a bad question.", "id": "czl3c8h"}, {"comment": "Why get hung up so much on the actual question? \n\n&nbsp;  \n\nRating the candidate only on whether or not they arrived at the preferred answer makes the interviewer bad - not the question. \n\nFor discussing with a candidate, open-ended-or-not doesn't matter much.\n\nThe only downside of a question with a distinct answer would be: if you underestimate the candidate, you get nothing from the exercise.  (Response: move to the next harder question, you lost a few minutes. Or nudge them for revealing their thought process - e.g. by asking: is this the only solution?)\n\nOTOH, a question with a distinct solution feels \"fairer\" to the candidate at least in retrospect. It doesn't matter much (for the interviewer), but *\"I didn't find 'the' solution\"* might leave a failing candidate with a better impression of the company than *\"they ask weird questions that can't be answered\"*. \n\nOr to put it differently, **tl;dr:** a good interviewer can get excellent results with a bad question. A bad interviewer can't be saved by an excellent question. \n", "id": "czl4w6h"}, {"comment": "It is obvious that SC figured out how to hack the system.  So I apply a solution and SC (or FC) will figure a hack on that.  Rinse and repeat.\n\nOf course this happens in the business world too.", "id": "czmt6nn"}], [{"comment": "God I hate these kind of interview questions. \n\nThe answer in context is clear because naturally that's the only thing that will work with the cats behavior, as well as the mechanical limitations of the machine. \n\nBut it's fucking useless. It's a queue consumer optimization question and even if someone gets it right they might have no fucking idea how to make a performant queue consumer implementation. \n\nI have literally never run into any situation remotely like this in my 22 years of programming experience where you have to change the queue input to optimize for the consumers. \n\nThis is why I won't interview with anyone who screens with this kind of shit. ", "id": "czkrkom"}, {"comment": "I'm with you. And I'd also like to know why it seems, as a \"profession\", we're fixated on this line of questioning for interviews. Surely we're not the only \"profession\" that requires problem solving skills. Yet I'm left to wonder if this type of thing goes on in other field's interviews.\n\nMaybe I'm completely uninformed about how other disciplines conduct interviews. But by our \"profession's\" line of reasoning about the efficacy of these types of questions they'd seem to be as applicable for screening lawyers or heart surgeons; assuming the premise of how one thinks on their feet is important.\n\nAgain, maybe I'm clueless about other fields but I have this vision in my mind of actually taking time to vet references. Actually finding out from past colleagues what the candidate is about, what they've delivered, what roles they've played and what the thoughts were on their overall competencies with respect to the position.\n\nIn fact, at the higher levels my guess is the interview process does resemble something more normal. For example, my guess is Rob Pike wasn't asked this kind of crap when interviewing with Google. ", "id": "czl0xiw"}, {"comment": "What situation is this supposed to be an analogy to?  Two consumers that I have no control over, but where one of them can flush the queue, and they both with only take 10 units off the queue? And I simultaneously have the power to change only the buffer and the frequency of the producer?\n\nWhat situation is that?", "id": "cznbh6b"}], [{"comment": "If the idea is to encourage solution discovery and agile thinking, then excluding the \"spoiler\" answers and only having one correct, straightforward, boring answer is kind of missing the point.  \n\nReminds me of the classic [barometer problem](http://www.snopes.com/college/exam/barometer.asp)", "id": "czkrkm6"}, {"comment": "Depends on how you judge it. It you have an automaton interviewer who gives 7 points for the correct answer, and zero otherwise, the interviewer has failed. \n\nThe interviewer wants to engage in a discussion.\n\nIMO the author does focus somewhat to much on *the* solution, rather than *a*. I also find the question a bit long winded, a more brief one would be better to get the interviewee to talk. \n", "id": "czkulr6"}], [{"comment": "I suppose I wouldn't get hired if my answer were \"Get rid of the cats\" or \"Find friends that can feed your cats while you're gone\".", "id": "czkqh7o"}], [{"comment": ">Creative solutions that don\u2019t violate these rules are greatly appreciated and exploring them is encouraged to learn more about the interviewee, but any solution not conforming with the one below should ultimately be roadblocked.\n\nThis sounds like a terrible interview.  You will give me the exact answer I'm looking for or you are wrong.  How about instead, if they have a reasonable and valid answer, give them your answer and then discuss the trade offs.  You know, like you should do.\n\n&nbsp;\n\nHaving to have a long discussion about the interviewers cats, during the interview?  Nope, thanks for making this easy.  Not saying I have a problem with cat people, but if you do this during an interviewee I know I'll have to hear about your cats all the time.", "id": "czks3y4"}, {"comment": "Isn't the point of the 'roadblocks' to simulate what non-technical clients often do in product meetings. In such meetings it's common to suggest ideas only to be told 'no, that won't work because <some previously omitted criteria>'.\n\nThe whole point of the question is to see how you react to this type of situation, rather than the specific answer. You need to be able to ask the right sort of questions to tease out parts of a specification that wouldn't occur to a non-technical person.", "id": "czkvcdl"}, {"comment": ">any solution not conforming with the one below should ultimately be roadblocked.\n\nDoesn't matter according to the article, there is only one answer.  Yes, the question is intintionally left vague so the interviewee has to ask more questions to find all the requirements, but any answer that's not the \"one true answer\" is not allowed.  Even after you've teased out all the unstated details.", "id": "czl0ij9"}, {"comment": ">The process doesn\u2019t always go smoothly. I\u2019ve had a couple very intelligent applicants spit out the ideal solution immediately after I\u2019d completed explaining the problem. **The point isn\u2019t the solution, its how you get there.** As the interviewer, you need to asses candidates to ensure you\u2019re leaving out enough information so there is room to discuss the problem.\n\n", "id": "czl0pya"}, {"comment": "Which is followed up with the bit about there being only one answer.  Instead they shouldn't roadblock valid answers and have a discussion of trade offs, another very important skill.  By shutting down other valid answers you are missing out on a great opportunity to get more depth on evaluating the candidate.", "id": "czl172l"}, {"comment": "But the whole point isn't answering the question. The point is simulating what happens in real jobs with real clients who do roadblock you", "id": "czl1ana"}, {"comment": "If they already know the answer, why are you there?", "id": "czl1csx"}, {"comment": "Me personally, in my current job? To take what a non-technical client has in mind, and ask the right questions to create a technical specification for the software I'm going to build them. Very often asking certain questions leads them to shut down ideas because it reveals some problem which they hadn't already anticipated.\n\nI am a software engineer at a small company. Being a small company with few employees, I'm not only responsible for building software, but also liaising with clients, gathering requirements, drawing up specifications, and lots of other things.\n\nI certainly do a fair amount of finding novel solutions to interesting problems, but this question seemed very apt to get at a lot of the other important but non-programming skills I use on a daily basis.", "id": "czl1mo6"}, {"comment": "The best candidate (from the point of view of this assessment) knows the answer right away, but also is smart enough to hit the roadblocks for just the right amount of time.  Maybe he will fake not know the answer so he will not get labelled a non-communicative rock star.", "id": "czmto6k"}, {"comment": "What is wrong with this? If I'm meeting to discuss specifications with clients, even if I have a good idea of what the final system will be like from the outset, I will always exhaust many lines of enquiry to try and learn as much as I can.\n\nSure, I might jump in with the correct answer first (and I just as easily might not). But I wouldn't just leave it at that, I would continue asking questions, because it is clear by the way it is presented, that this question is not purely about a technical solution.\n\nYou don't learn new things by reaffirming what you think you know. You learn new things by trying disprove what you think you know.", "id": "czmv338"}, {"comment": "There is no universal right or wrong.  What is your goal? Is your method helping you achieve this goal?\n\nIf you are a candidate and your goal is to get hired, the best method may include fake not knowing the answer so you can flatter the interviewer by basking in his all knowing intellect.", "id": "czmx1cl"}], [{"comment": "What the fuck is an 'auger'?\n", "id": "czkv3wq"}, {"comment": "Someone that determines the omens of the gods through observation of nature.\n\nThat or a sort of corkscrew elevator like an Archimedes' screw or [this](http://www.discountfence.com/images/little%20beaver%20mechanical%20auger.jpg)", "id": "czl04me"}], [{"comment": "Why in the ever-loving fuck does pressing Esc redirect to a Squarespace login?", "id": "czkrp9t"}, {"comment": "Its a Squarespace \"[Hack](http://blog.squarespace.com/blog/2009/3/12/squarespace-hack-esc-to-login.html)\".", "id": "czl0oug"}], [{"comment": "It appears you can get people to try solving your arbitrary puzzles by offering them the prospect of employment.", "id": "czktr78"}], [{"comment": "For a moment I was going for a full-blown RFID solution.", "id": "czkwaav"}], [{"comment": "What happens to me with brain teasers: I start feeding my right brain. As soon as something begins to emerge, the interviewer says something, and it goes *poof*. This really hurts me if there's a time limit", "id": "czkrh3y"}], [{"comment": "Cat.", "id": "czm1u39"}], [{"comment": "I had the solution in mind before the prompt even finished. Am I silly in thinking it isn't even that difficult? I'm starting to think there are lots off people that try to over complicate things even more than myself.\n\nI'm curious what the interviewer did in these situations; he acknowledges a number of people get the correct solution right out of the gate. Does he not hire them because there was no discussion or did he augment the prompt further? Sounds to me like the interviewer just wants reassurance that they're the boss and are more intelligent than they really are and the candidate will be a productive, subservient employee. I guess it just demonstrates that this wouldn't be a good fit for me, which is fine since there would be plenty of better fitting jobs and if this test was used on a majority of candidates I'm sure they'd all work together well.", "id": "czl021y"}, {"comment": "You are better than me.  I read the thing and still don't understand the problem.  Maybe I'm just not a cat person.\n\nOr maybe you are a non-communicative rock star and I am a better team player.", "id": "czmtqg7"}, {"comment": "I'm really a robot. All I have is mechanical, analytical processing.", "id": "cznip5f"}]]], "4w5374": ["The secret for 100% test coverage: remove code", "2016-08-04 19:34:34", 2, "https://many-cores.com/2014/02/21/the-secret-for-100-test-coverage-remove-code/", [[7, "[deleted]"], [1, "Code coverage is bullshit. Its only benefits are:\n\n- it's easy to compute\n- non-technical people (ie managers) can understand it\n\nStill, you can achieve 100% CC with assertless testing.\n\nIf you're interested in the quality of your tests AND you need metrics, you should get into Mutation Testing ([intro there](https://blog.frankel.ch/introduction-to-mutation-testing/))"], [-1, "This sort of dogmatic bullshit is why I hate everyone who talks about test coverage."]], [[{"comment": "[deleted]", "id": "d646m9s"}, {"comment": "Haha funny article. \"I write Java and Java always contain totally useless code so <100% is actually 100%\"\n\nIn a language where people don't write useless code at 15% if all code or more this entire article is moot. ", "id": "d6521oe"}], [{"comment": "Code coverage is bullshit. Its only benefits are:\n\n- it's easy to compute\n- non-technical people (ie managers) can understand it\n\nStill, you can achieve 100% CC with assertless testing.\n\nIf you're interested in the quality of your tests AND you need metrics, you should get into Mutation Testing ([intro there](https://blog.frankel.ch/introduction-to-mutation-testing/))", "id": "d64ceiy"}, {"comment": "It's also easy to see what parts aren't tested (not that there's anything wrong with that). Although it can't reliably tell you what is tested.", "id": "d64i743"}, {"comment": "Yes, that's my point. Code coverage tells you about the maximum level of trust that you can have in your code.\nSo if you have 0%, at least you're afraid. If you have 100%, you feel confident regardless of the truth. This IMHO is worse that the first  case.", "id": "d64k1y3"}, {"comment": "That's going to depend on the code base. If the tests are good then the confidence is justified.", "id": "d64k80e"}, {"comment": "There really is no alternative though. Your suggestion to do mutation testing is nonsensical. Mutation testing without coverage means nothing. You have no idea what you've tested. \n\nCoverage as a number isn't useful. Coverage as in showing what lines exactly were never hit by any tests (mutation, unit, integration, etc) is very useful. ", "id": "d6524g9"}, {"comment": "Actually, mutation testing is arguably the best coverage tool we could have to assess the quality of your tests, as it assess the capacity of your test harness to identify code change.\nBut the tooling is still in its infancy as of today: it significantly impact testing duration (logical) and can evaluate a limited set of change scenario.", "id": "d6552kp"}, {"comment": "Yea.... But without 100% coverage for your tests you will by definition be able to survive some mutations. So it must mean logically that to even do mutation testing you must first have full coverage for your tests. Probably branch level too, AND be complete. How do you work towards that goal if you can't use coverage tools and your time is actually worth something?", "id": "d65644v"}, {"comment": "I am probably wrong, but your comment gives me the impression that you are not very familiar with mutation testing. Actually, if you have no test whatsoever (or assertless tests), mutation testing will fail, which is a sign that you have bad testing/coverage.\n\nOne must keep in mind that mutation testing works in reverse:\n- code is mutated\n- tests are run\n- if all tests are ok, (mutation) testing have FAILED\n- if at least one test fails, (mutation testing) is successful\n\n", "id": "d65amis"}, {"comment": "Yea ok but my point stands. You need 100% branch coverage for mutation testing to succeed as you've described it. And if you're adding it on top of a lib that is nontrivial, working towards the goal of mutation testing even theoretically succeeding you must first achieve 100% coverage for your tests. By definition. \n\nAnd working towards that with mutation testing alone must be hell. ", "id": "d65jko6"}, {"comment": "Ok, now I get your point: using mutation testing will enforce 100% coverage as it should fail otherwise, since some mutants can pass through. Very good point, thank you for raising it!\nAs a corollary, judging by the typical mindset of developers, this requirement is a significant roadblock to mutation testing adoption.\nI need to post a followup on my article", "id": "d68v5wo"}, {"comment": "And using just testing plus coverage is gonna be much nicer and faster to get the first part of the way.  \n\nI've been thinking about mutation testing more and it seems like it should be possible to use coverage data to radically speed up mutation testing: you can use coverage tools to know which tests hit a certain line and only run those for mutations for that line. ", "id": "d68vjjv"}, {"comment": "Yes, mutation testing is definitely a better tool than code coverage.\nYes, you can achieve 100% coverage assert less. But I have also seen 60% coverage with assert less tests.\nIf we go down that road, why bother...", "id": "d64khpz"}, {"comment": "A nail is definitely better than a bar of soap. That's what that sounded like.  \n\nMutation testing without outputting coverage data (exact lines, not just a percentage) is not worth much. Just like just looking at unit tests coverage percentage is worth nothing. \n\nThese are tools that need to be used together. ", "id": "d6526sc"}, {"comment": "You mean it's impossible to do mutation testing and miss entire chunks of your code? ", "id": "d651tld"}, {"comment": "Just try!", "id": "d652arx"}, {"comment": "I was being sarcastic. ", "id": "d652mbp"}], [{"comment": "This sort of dogmatic bullshit is why I hate everyone who talks about test coverage.", "id": "d64htwe"}, {"comment": "Maybe you didn't read the article?", "id": "d651sqk"}, {"comment": "Um, how does my comment make any sense if I had only read the headline?\n\nI'm talking about the entire point of this blog post which is this:\n\n> This is important, so let me restate that: a line of code that is not covered is not maintainable, must be seen as not working and must be removed!\n\nUnless the whole thing is supposed to be satire.  In which case I argue Poe's Law.", "id": "d653536"}, {"comment": "I appreciate you strongly disagree, to the point of calling it bullshit, but could you please elaborate why you see this as so wrong?", "id": "d654vw7"}, {"comment": "Because it's idiotic.  100% test coverage isn't desirable.  It means that the code must be etched in stone because literally *any* change is a breaking change.\n\nIt also means a huge chunk of your tests are testing primitive language features, which is just a huge waste of everyone's time.\n\nFinally, I'd argue 100% test coverage is actually impossible.. why?  Because tests are code... and they're *untested* code by their very nature.", "id": "d655khq"}, {"comment": "I don't see how you can possibly have tests that are just \"testing primitive language features\". Unless you're literally testing that add works or whatever. And if you're doing that, I guess that's what you want. ", "id": "d655z81"}, {"comment": "You seem to be confused as to what 100% coverage means. It does NOT mean any change breaks the tests, it means that any change that doesn't break the tests is either:\n1) testing an edge case the tests didn't cover but that had coverage (example: you can test a simple calculation but you didn't test when one of the numbers is NaN)\n2) adding new features so the coverage goes down (until you add tests for the new things)", "id": "d65620q"}, {"comment": "Hi, I don't understand your statement: \"It means that the code must be etched in stone because literally any change is a breaking change.\". \n\nIndeed, if your UNIT tests are properly testing behaviors instead of testing implementation details like methods (bad, because leading to fragile and painful tests), you are then free to change lots of your implementation details without breaking change.", "id": "d65dkj6"}, {"comment": "I wouldn't pay that dude much mind. ", "id": "d655zzz"}]]], "51hi8g": ["curl http://justaforkbomb.com/ | bash", "2016-09-07 01:13:10", 0, "http://justaforkbomb.com/", [[12, "I solemnly swear to use this only if the effect would be really really funny."], [7, "I tried it and it just gave me ASCII art of a middle finger.  Is there some kind of user agent trick?"], [8, "Always run 3rd party scripts you get via unencrypted channels without checking! That's the only true way!"], [4, "https://en.wikipedia.org/wiki/Fork_bomb"], [0, "Errorism!"]], [[{"comment": "I solemnly swear to use this only if the effect would be really really funny.", "id": "d7bz9rf"}], [{"comment": "I tried it and it just gave me ASCII art of a middle finger.  Is there some kind of user agent trick?", "id": "d7ce5nr"}, {"comment": "curl does send an identifying user agent. I remember seeing an article some time ago about a more in depth \"trick\" to display one script when you curl and another when curl is piped to sh, but I can't for the life of me find it again.", "id": "d7ci084"}, {"comment": "This one? https://www.idontplaydarts.com/2016/04/detecting-curl-pipe-bash-server-side/", "id": "d7cl7eu"}, {"comment": "Yep! That was the one.", "id": "d7cqehm"}], [{"comment": "Always run 3rd party scripts you get via unencrypted channels without checking! That's the only true way!", "id": "d7cfj0y"}, {"comment": "Because not using TLS is the biggest issue with this.", "id": "d7cg8ld"}, {"comment": "But its secure if you have SSL/TLS", "id": "d7cw2n1"}, {"comment": "No worries, there's an [open issue](https://github.com/jer/justaforkbomb.com/issues/1) so hopefully it'll be fixed soon and we can rest easy", "id": "d7dgri8"}], [{"comment": "https://en.wikipedia.org/wiki/Fork_bomb", "id": "d7c03f2"}], [{"comment": "Errorism!", "id": "d7c25f4"}]]], "4h9p95": ["Clean Coder Blog - Type Wars", "2016-05-01 20:02:44", 2, "http://blog.cleancoder.com/uncle-bob/2016/05/01/TypeWars.html", [[20, "[deleted]"], [16, "Uncle Bob is a crackpot who makes his living preaching to rubyist-TDD enthusiasts, so this post is no surprise.  "], [17, "I disagree with the notion. TDD isn't a replacement for types. Types give you a base layer of safety. On top of that, we also get much better tooling support for things like autocomplete and refactoring. Adding to that, we also get some free basic documentation with types."], [13, "I never understood how dynamic languages are supposed to be superior because of TDC.   Testing can be done in statically typed languages, too. "], [11, "\"You don't need static type checking if you have 100% unit test coverage\"\n\nYou cannot be serious Uncle Bob ... ?"], [9, "Looking forward to the \"I was wrong\" post ~3-5 years from now."], [8, "Using Java as a synonym for static typing and then complaining that it takes too long to write in statically typed languages isn't really fair. The issue is that Java is really verbose. "], [6, "lol this guy is crazy ; i hope i dont have to work with 100% test coverage whackos"], [5, "This was a very nice short history of types.... but the conclusion really does not look reasonable...\n\n> The pendulum is quickly swinging towards dynamic typing. \n\nWat? Is this 2002?\n\n> And yet, the new languages that are appearing, languages like go and swift appear to be reasserting static typing? \n\nYes, and this has been going on for a while... there seems to be a consensus that types are necessary to write software, at least in large teams... Rust, Kotlin, Swift, Go, TypeScript (not 100%, but the whole point of it being to add types to JS as it's generally agreed JS needs them)... you name it, all strongly typed. The only counterexample I can think of is Clojure... and perhaps, Elixir... but they are really the exception to the rule.\n"], [3, "My guess is that in the future we will use more languages that are strongly typed but with a very strong type inference so that writing the types becomes mostly optional. You see small steps in that direction with c# for example with the \"var\" keyword. Languages such as Elm already have a strong type inference, so using types is mostly optional in there even though it is strongly typed."], [3, "100% test coverage meaning what, exactly?\n\nIn practice the real benefit of fancier type systems is in creating abstractions and compositions that won't hold together in systems without fancy static typing.\n\nThis aspect gets past dynamic language fanatics because they are outside the scope of what you can reliably build and maintain in such languages on a regular basis.\n\nAll this said it is just a he cognitive relief to not have to worry about either \"what happens if someone gives this function a number where it expects a string?\" and also \"how should I document this function only works if you give it a string?\"\n\nJust...let the compiler deal with such stuff."], [1, "I kind of question that programmers jumped to dynamic languages because of TDD or testing. Seeing that testing isn't necessarily done in the most prominent of dynamic language [JavaScript](http://ashleynolan.co.uk/assets/img/blog/tooling-survey/2015/q7.jpg)."], [1, "> Learning swift has been an interesting experience. The language is very opinionated about type safety.\n\nWhich really doesn't work well with the legacy Objective C frameworks.\n\nI wish they would've taken the opportunity to redo them (they claim that swift 3 will fix a lot of this).\n\nI've actually seen some UIKit functions that return an optional array of optional elements.  Fuck off with that.  You should never return an optional array instead of an empty array, and you shouldn't include nil in an array when you can just omit it."]], [[{"comment": "[deleted]", "id": "d2ol4wj"}, {"comment": "The way I see it, a type system moves contracts out of comments and into the type system, where they can be verified by the compiler. When I write Python, I find myself writing documentation comments like \u201cargument x is a list of strings\u201d. In C++ I find myself writing comments like \u201cthe returned pointer must not be used after this object goes out of scope\u201d. In Rust I find myself writing comments like \u201cthis function panics if the index is out of bounds\u201d. And [even that can be prevented by a strong type system](http://docs.idris-lang.org/en/latest/tutorial/typesfuns.html#the-finite-sets).\n\nUltimately, it is a trade-off between convenience and development speed, and robustness. With a type system that encodes the behaviour of the software very well, it is hard to write code that typechecks, but at least the contracts encoded in the type system are never violated. In a less fine-grained type system it is easier to write something that runs, but as a result it can only prevent basic bugs (such as trying to add an integer to a string, although some insane languages tolerate even that).\n\nAs a concrete example: it is very easy to quickly write a Python program that prints the contents of a file to stdout. But the program will likely crash if the file does not exist. Or if the file is on a network drive and your network connection fails when reading the file. If you try the same thing in Rust, you\u2019ll be forced by the type system to handle the cases of IO error. You cannot move as fast when you are being forced to think about all those edge cases all the time. But in the end your program does handle the edge cases, instead of crashing.\n\nTesting is no full substitute for a type system, because you still have to think about all the edge cases before you can write a test for them. On the other hand, anything that you cannot encode in the type system still needs tests.", "id": "d2oqg5g"}], [{"comment": "Uncle Bob is a crackpot who makes his living preaching to rubyist-TDD enthusiasts, so this post is no surprise.  ", "id": "d2omgzo"}], [{"comment": "I disagree with the notion. TDD isn't a replacement for types. Types give you a base layer of safety. On top of that, we also get much better tooling support for things like autocomplete and refactoring. Adding to that, we also get some free basic documentation with types.", "id": "d2on6fr"}, {"comment": "> Adding to that, we also get some free basic documentation with types.\n\nThis is a nice one indeed. A great example is [Hoogle](https://www.haskell.org/hoogle) for Haskell. I regularly find myself in a situation like \u201cI have a `[IO a]`, but I need an `IO [a]`. And Hoogle will happily tell me [\u2018Oh, you need `sequence`.\u2019](https://www.haskell.org/hoogle/?hoogle=[IO+a]+-%3E+IO+[a])\u201d", "id": "d2oqreq"}], [{"comment": "I never understood how dynamic languages are supposed to be superior because of TDC.   Testing can be done in statically typed languages, too. ", "id": "d2oldxw"}], [{"comment": "\"You don't need static type checking if you have 100% unit test coverage\"\n\nYou cannot be serious Uncle Bob ... ?", "id": "d2osw2z"}, {"comment": "> You cannot be serious Uncle Bob ... ?\n\nHe has been serious [for at least 5 years now](https://skillsmatter.com/skillscasts/2323-bobs-last-language)...", "id": "d2pvpq4"}], [{"comment": "Looking forward to the \"I was wrong\" post ~3-5 years from now.", "id": "d2ovxag"}], [{"comment": "Using Java as a synonym for static typing and then complaining that it takes too long to write in statically typed languages isn't really fair. The issue is that Java is really verbose. ", "id": "d2oopmw"}], [{"comment": "lol this guy is crazy ; i hope i dont have to work with 100% test coverage whackos", "id": "d2opcdi"}, {"comment": "You better not work on safety-critical software then.", "id": "d2oxd2z"}, {"comment": "And how 100% test coverage can ensure safety? Basic logic, giving one example (and that's what unit testing is) is not a proof of anything.\n\nOnly using languages with advanced type systems (ML-family, Haskell, languages with dependent types) supplemented by property based testing can proof that program behaves correctly.  ", "id": "d2q0x6c"}, {"comment": "It does not, only further testing all the way up to compliance testing can begin to give assurances that the software is safe.\n\nIn place of the type systems of the likes of Haskell there are solutions that involve annotation of the code to prove that the flow of data through the system is as specified.", "id": "d2q2gfb"}], [{"comment": "This was a very nice short history of types.... but the conclusion really does not look reasonable...\n\n> The pendulum is quickly swinging towards dynamic typing. \n\nWat? Is this 2002?\n\n> And yet, the new languages that are appearing, languages like go and swift appear to be reasserting static typing? \n\nYes, and this has been going on for a while... there seems to be a consensus that types are necessary to write software, at least in large teams... Rust, Kotlin, Swift, Go, TypeScript (not 100%, but the whole point of it being to add types to JS as it's generally agreed JS needs them)... you name it, all strongly typed. The only counterexample I can think of is Clojure... and perhaps, Elixir... but they are really the exception to the rule.\n", "id": "d2pvuki"}], [{"comment": "My guess is that in the future we will use more languages that are strongly typed but with a very strong type inference so that writing the types becomes mostly optional. You see small steps in that direction with c# for example with the \"var\" keyword. Languages such as Elm already have a strong type inference, so using types is mostly optional in there even though it is strongly typed.", "id": "d2pi5x8"}], [{"comment": "100% test coverage meaning what, exactly?\n\nIn practice the real benefit of fancier type systems is in creating abstractions and compositions that won't hold together in systems without fancy static typing.\n\nThis aspect gets past dynamic language fanatics because they are outside the scope of what you can reliably build and maintain in such languages on a regular basis.\n\nAll this said it is just a he cognitive relief to not have to worry about either \"what happens if someone gives this function a number where it expects a string?\" and also \"how should I document this function only works if you give it a string?\"\n\nJust...let the compiler deal with such stuff.", "id": "d2s19d7"}], [{"comment": "I kind of question that programmers jumped to dynamic languages because of TDD or testing. Seeing that testing isn't necessarily done in the most prominent of dynamic language [JavaScript](http://ashleynolan.co.uk/assets/img/blog/tooling-survey/2015/q7.jpg).", "id": "d2ojj63"}], [{"comment": "> Learning swift has been an interesting experience. The language is very opinionated about type safety.\n\nWhich really doesn't work well with the legacy Objective C frameworks.\n\nI wish they would've taken the opportunity to redo them (they claim that swift 3 will fix a lot of this).\n\nI've actually seen some UIKit functions that return an optional array of optional elements.  Fuck off with that.  You should never return an optional array instead of an empty array, and you shouldn't include nil in an array when you can just omit it.", "id": "d2q68iv"}, {"comment": "Some uses of NSNull are due to the lack of optionals, essentially. I forget any concrete examples but anything where you need to preserve the size and indices of an array vis-a-vis another array would typically use NSNull out of necessity.\n\nCurious which APIs return that directly into swift right now. Some KVC thing?", "id": "d2s16ji"}]]], "4akkkf": ["Apparently, you can build the Uber UI in 5 minutes with this. The video shows a guy doing just that.", "2016-03-16 01:30:09", 3, "https://www.decosoftware.com/?r=btMLX", [[5, "Apparently, advertisers can't learn to phrase things in a way that doesn't just sound like they are shilling their new product."], [3, "Smart use of a referral URL :P\n\nThe software looks really cool though."], [1, "ah, reminds me of the visual basic 6 studio days, only without the drag and drop..  :D"]], [[{"comment": "Apparently, advertisers can't learn to phrase things in a way that doesn't just sound like they are shilling their new product.", "id": "d117z6x"}, {"comment": "haha definitely not a shill.. I just learned about the company and product today", "id": "d11c3oa"}, {"comment": "I signed up to download because it looked interesting and I have a client that might want to start a project using it, but their stupid queue system is probably going to make this project use something else", "id": "d11d4hh"}], [{"comment": "Smart use of a referral URL :P\n\nThe software looks really cool though.", "id": "d11c0lt"}], [{"comment": "ah, reminds me of the visual basic 6 studio days, only without the drag and drop..  :D", "id": "d116ted"}]]], "424kvj": ["Why an Ex-Google Coder Makes Twice as Much Freelancing", "2016-01-22 10:44:46", 3, "http://www.bloomberg.com/news/articles/2016-01-19/why-an-ex-google-coder-makes-twice-as-much-freelancing", [[11, "Freelancing is amazing, I went from making 150k/year to unbelievably obscene amounts and I am still growing.  But this article isn't a real article, it's just an ad for 10x and toptal."], [13, "I'd reckon a lot of us could make more money freelancing and would overall have more freedom with our jobs but it also ultimately comes with more risks and more responsibilities that you must be willing and *able* to tackle.\n\nMy current employment situation is very similar to a freelance job, but my employer handles all the stuff I definitely wouldn't be able to handle myself, which allows for a bit more peace of mind and a steady and secure income, even if it might be a fair bit lower than freelancing myself."], [4, "Ad."], [3, "Pulling down one and a half to twice as much freelancing as when employed? That ... doesn't sound _that_ good, really. After all, your costs will have gone up as well, as has your level of personal risk (and at the same time your support system for dealing with risks and mitigating negative consequences is pretty much gone.) Don't forget to include the extra non-productive work involved either (contract negotiations, handling invoices and so on.) Then (depending on where you live) you have to factor in the value of things such as pension points, paid maternity / paternity leave, unemployment benefits and any relevant perks provided by the previous job.\n\n(What is the legal status re indemnity for a freelance coder, anyway?)"]], [[{"comment": "Freelancing is amazing, I went from making 150k/year to unbelievably obscene amounts and I am still growing.  But this article isn't a real article, it's just an ad for 10x and toptal.", "id": "cz7ov9m"}, {"comment": "More to the point, working through an agency like that more resembles temping than does \"true\" freelancing. There's nothing wrong with that, but being handed projects by an agency is a lot different working for yourself.", "id": "cz7p3uy"}, {"comment": "Yeah I never do agency.  I work on my rep alone.", "id": "cz7type"}, {"comment": "I tried it once and earned 100\u20ac  &#3232;\\_&#3232;\n\n ", "id": "cz82np9"}, {"comment": "Wow! How many years experience do you have and in what field? That's insane...", "id": "cz7pijp"}, {"comment": "It changes per client, but I went from platform building to reliability engineering to now clients are having me productize their infrastructure and sell it back to them, which is crazy money.   I have been in the industry for more than 15+ years, and started my business about 6 years ago.  I have done this primarily from ethical business practices -- absolutely never cheating a customer, promising what I can deliver and actually delivering what I promise when it is to be delivered and the quality that I have promised.  I also will not work on anything that is unethical or for someone that is unethical.  That helped me focus my business on the right clients who were going places.\n\nHowever it cost me a lot to start because my competitors do lie, cheat and steal like its a card game on a Louisiana riverboat, but the rep bonus I eventually got + the loyalty from customers really paid off in the end.  I got to pick and choose my clients and the projects I worked on and nothing I don't.   So its a good place to be in.", "id": "cz7uqbp"}, {"comment": "Haha I wish I was motivated :(", "id": "cz7vnxn"}, {"comment": "How did you get started?\n\nI currently contract through multiple agencies, which is still higher paying and more flexible than going the employee route, but I'm not sure how to transition away from that.", "id": "cz7xqzc"}, {"comment": "Look through job ads, postings etc. companies have needs out there that need to be filled.  A lot of them will look at contract work because they need something done right then.  Reach out to them.  \n\nI suggest you read up on being a consultant.  Agency work is crap.  They use your rep for their own, and will do as they will with it.  Never go agent.  It's paying someone for doing very little real work ", "id": "cz7yl85"}, {"comment": "[How to Succeed in Business Without Really Lying](https://en.wikipedia.org/wiki/How_to_Succeed_in_Business_Without_Really_Trying) ;)\n", "id": "cz8b657"}, {"comment": "10X sounds like it might have a decent competency to shoot for if you want to make that kind of money.", "id": "cz7qhsz"}], [{"comment": "I'd reckon a lot of us could make more money freelancing and would overall have more freedom with our jobs but it also ultimately comes with more risks and more responsibilities that you must be willing and *able* to tackle.\n\nMy current employment situation is very similar to a freelance job, but my employer handles all the stuff I definitely wouldn't be able to handle myself, which allows for a bit more peace of mind and a steady and secure income, even if it might be a fair bit lower than freelancing myself.", "id": "cz7ms7b"}, {"comment": "Yeah, there's a trade off. I'm not sure where the tipping point is. \n\nOne thing that puts me off freelancing is that, in my experience, projects that hire freelancers are more likely to be troubled projects. You have to be AAA grade freelance, and have decade-long track record, to get hired by your reputation at places that didn't even know they needed your help. Most freelancing is emergency \"we need twelve people to get this out the door\" projects. \n\nMore interesting projects tend to be free of freelancers, well freelance developers anyway. ", "id": "cz7ndyj"}], [{"comment": "Ad.", "id": "cz7qtv5"}], [{"comment": "Pulling down one and a half to twice as much freelancing as when employed? That ... doesn't sound _that_ good, really. After all, your costs will have gone up as well, as has your level of personal risk (and at the same time your support system for dealing with risks and mitigating negative consequences is pretty much gone.) Don't forget to include the extra non-productive work involved either (contract negotiations, handling invoices and so on.) Then (depending on where you live) you have to factor in the value of things such as pension points, paid maternity / paternity leave, unemployment benefits and any relevant perks provided by the previous job.\n\n(What is the legal status re indemnity for a freelance coder, anyway?)", "id": "cz7o4xy"}, {"comment": "UK based contractor/freelancer here. I'm an Android dev. Pretty much all the contracts & recruitment agencies have required me to have indemnity insurance before starting. I've never looked into this (so take with a pinch of salt) but the contracts aren't with myself, they're with my limited company so I would have thought I'm not personally liable if anything did go wrong. Perhaps the indemnity insurance requirement is more to cover them rather than you, as they can recover some costs. Hopefully I'll never have to find out :)\n\nIn response to the rest of your post. My experience so far has been 'double the money, same job'. Actually I'd go one further and say it's made the job better, or at least my attitude healthier. At my previous permanent job I'd end up working 12+ hr days for months on end. Everyone else did it so I followed suit. When I started my first contract, the rest of the contractors were very much of the attitude, 'if you want us to work longer hours you'll be paying us for them'. To me this seems fair, remuneration for extra hours worked. It's allowed me to take a month off here and there between contracts which is quite nice. \n\nYou're right though, there are downsides. I'd say the admin is a little bit of a pain but it's probably negligible if you're the slightest bit organised + get a contractor accountant. The biggest thing for me is not feeling part of the company you're working for. You miss out a bit if the company has social outings + nothing overt but a little resentment from some permanent employees, even the odd Glassdoor review stating how the contractors don't care as much. For the most part though, people are people and you make friends, some of them I'm still in touch with.", "id": "cz7qvie"}, {"comment": "> indemnity insurance\n\nTIL: in first world countries indemnity insurance doesn't cost 100k $ per year and it's affordable for freelancer.\n\nAs contractor from Poland I had to reject few well paid jobs because I didn't want to take such risk.\n\n", "id": "cz7xhkd"}, {"comment": "I'm in Ireland, my accountant threw in the insurance for free as part of doing my books. I pay him a flat fee of 100 euro a month. ", "id": "czahsbt"}, {"comment": "I couldn't find anything cheaper than 2000\u20ac per month... \nJust wow. ", "id": "czam2dk"}]]], "576x7c": ["Upgrading to MacOS Sierra will break your SSH keys and lock you out of your own servers", "2016-10-13 02:23:52", 1, "https://medium.freecodecamp.com/upgrading-to-macos-sierra-will-break-your-ssh-keys-and-lock-you-out-of-your-own-servers-f413ac96139a", [[15, "Stop being so dramatic.\n\nI upgraded to Sierra, had an issue connecting to a few devices, Google'd the error ssh gave me, and had it fixed within 30 seconds.\n\n\"lock you out of your own servers\" is factually incorrect."], [6, "What does the article mean by \"forcing 2048-bit keys?\" Are less secure keys ignored or deleted? Are DSA and weak RSA disabled completely in OpenSSH?\n\nI'm not sure I can really sympathize with people still using 1024-bit keys today. OpenSSH has been set up to generate 2048-bit keys by default since version 4.2 from 2005. It has been long enough."], [3, "Copy and pasting is okay but I highly recommend using [ssh-copy-id](https://linux.die.net/man/1/ssh-copy-id) instead.\n\nIts available in pretty much every package repo. It will also make sure your file permissions are on the up and up."], [2, "WTF. Who wasn't using 2048 SHA256 RSA in the first place? That's literally the one that gets created when you follow, for example, the \"how to use github with ssh\" guide. \n\nIf you were still using DSA keys up until now... that's your own damn fault. "], [0, "It can also trash your disk. I updated to Sierra yesterday. This evening I rebooted and the OS stopped loading. Recovery mode Disk Utility said it couldn't repair the disk. I had to delete the partition table in order to install Ubuntu."], [1, "Apple is moving towards secure defaults everywhere.  They also removed PPTP VPN support, which has been breakable for a decade.\n\nApple basically went through every application, and reviewed."]], [[{"comment": "Stop being so dramatic.\n\nI upgraded to Sierra, had an issue connecting to a few devices, Google'd the error ssh gave me, and had it fixed within 30 seconds.\n\n\"lock you out of your own servers\" is factually incorrect.", "id": "d8psqn3"}, {"comment": "well technically you were locked out of your servers for those 30 seconds.", "id": "d8pyf2z"}, {"comment": "Well technically you're an obnoxious pedant.", "id": "d8qjfb7"}, {"comment": "Because I made a joke?", "id": "d8qjz7g"}], [{"comment": "What does the article mean by \"forcing 2048-bit keys?\" Are less secure keys ignored or deleted? Are DSA and weak RSA disabled completely in OpenSSH?\n\nI'm not sure I can really sympathize with people still using 1024-bit keys today. OpenSSH has been set up to generate 2048-bit keys by default since version 4.2 from 2005. It has been long enough.", "id": "d8pl6cg"}, {"comment": "Indeed.  I had a similar reaction when reading the article, only that I was just wondering whether it's really Apple who did this or OpenSSH.  Googling a bit reveals [this page from the OpenSSH site](https://www.openssh.com/legacy.html), which tells us:\n\n> OpenSSH 7.0 and greater similarly disable the ssh-dss (DSA) public key algorithm. It too is weak and we recommend against its use. \n\nAnd as I haven't upgraded to Sierra yet, I can demonstrate that in older OS X they're using OpenSSH 6.x:\n\n    $ ssh -v\n    OpenSSH_6.2p2, OSSLShim 0.9.8r 8 Dec 2011\n\nSo it looks like what Apple did is move up to OpenSSH 7.x, which disables DSA by default\u2014[and they're not the only ones who've done it](https://www.gentoo.org/support/news-items/2015-08-13-openssh-weak-keys.html).\n\nThe OpenSSH Legacy Options page I linked then shows you how to log in to a remote server in those circumstances:\n\n> [ssh-dss] can be re-enabled using the `HostKeyAlgorithms` configuration option:\n>\n>     ssh -oHostKeyAlgorithms=+ssh-dss user@legacyhost\n\nSo if you've upgraded it seems you should still be able to log in to those old machines.  (I haven't actually tried it, though, since I'm not on Sierra yet.)\n\nSo I'd say don't let this issue be a showstopper or major obstacle if you want to upgrade to Sierra. Just take note of the workaround, and if you encounter the error message, treat it as an *opportunity* to switch to a newer, more secure key.", "id": "d8pludz"}, {"comment": "On Sierra:\n\nssh -V\nOpenSSH_7.2p2, LibreSSL 2.4.1", "id": "d8ppqu9"}], [{"comment": "Copy and pasting is okay but I highly recommend using [ssh-copy-id](https://linux.die.net/man/1/ssh-copy-id) instead.\n\nIts available in pretty much every package repo. It will also make sure your file permissions are on the up and up.", "id": "d8pmpfz"}, {"comment": "Why the hell this isn't included on Macs by default is completely beyond me.", "id": "d8qsm6t"}, {"comment": "It is with Sierra\n\n    $ which ssh-copy-id \n    /usr/bin/ssh-copy-id\n", "id": "d8vqmlw"}], [{"comment": "WTF. Who wasn't using 2048 SHA256 RSA in the first place? That's literally the one that gets created when you follow, for example, the \"how to use github with ssh\" guide. \n\nIf you were still using DSA keys up until now... that's your own damn fault. ", "id": "d8qj8xc"}], [{"comment": "It can also trash your disk. I updated to Sierra yesterday. This evening I rebooted and the OS stopped loading. Recovery mode Disk Utility said it couldn't repair the disk. I had to delete the partition table in order to install Ubuntu.", "id": "d8pis59"}, {"comment": "Damn, I didn't upgrade since Siri is mostly useless for me (it hardly gets what I'm asking for), and given this and other news, I don't think I'll be upgrading anytime soon. Funnily enough, this is the complete opposite from my Ubuntu days, where I'd happily download the newest version a few hours after release...", "id": "d8pj2vq"}, {"comment": "Yeah, it was a complete surprise for me. Especially since I had to do Internet Recovery to get Mavericks and upgrade. El Capitan Time Machine didn't like my backup either. Time to spend some serious effort on tweaking the trackpad. That was the only thing keeping me in OS X.", "id": "d8pjd9p"}, {"comment": "Yeah, I have some hardware that no longer works in Sierra, either. The hardware manufacturer is working on an update, fortunately; but it's kind of lame to break drivers with an OS update. Owners of other types of hardware will not be as lucky as me. ", "id": "d8pqtvn"}, {"comment": "Something similar happened to me today. Casually using Fusion when all of a sudden all folders were owned by root and wheel. Finders freaking out, all users affected. Really strange.", "id": "d8qqxp3"}], [{"comment": "Apple is moving towards secure defaults everywhere.  They also removed PPTP VPN support, which has been breakable for a decade.\n\nApple basically went through every application, and reviewed.", "id": "d8qjphn"}]]], "402sph": ["Notch recreating Doom in Dart (stream excerpt)", "2016-01-08 23:04:37", 0, "https://www.youtube.com/watch?v=6p-Z6TXoN10", [[-5, "He should start a new company that uses Dart and lets people work remotely I will apply.  I don't care about video games but I'll learn them to use Dart full time, Notch pls."]], [[{"comment": "He should start a new company that uses Dart and lets people work remotely I will apply.  I don't care about video games but I'll learn them to use Dart full time, Notch pls.", "id": "cyrj8io"}]]], "4e21om": ["Booleans as a Service (BaaS)", "2016-04-09 21:06:02", 0, "https://booleans.io/", [[3, "Was this supposed to be funny?"], [3, "But can it left-pad them?"], [1, "Needs some Swagger API documentation"], [1, "This would be awesome, to bad it's missing FILE_NOT_FOUND."], [1, "0/10 no HATEOAS"]], [[{"comment": "Was this supposed to be funny?", "id": "d1wc3wn"}, {"comment": "    # curl -s https://api.booleans.io/6aa0cfd2-1b76-4ee8-9ac8-2144b3c1e7a9 | jshon -e val\n    true", "id": "d1wd046"}], [{"comment": "But can it left-pad them?", "id": "d1x5bxc"}], [{"comment": "Needs some Swagger API documentation", "id": "d1wfbrc"}], [{"comment": "This would be awesome, to bad it's missing FILE_NOT_FOUND.", "id": "d1whp38"}, {"comment": "No, it is not\n\nDisconnect your internet and\n\n    $  curl https://api.booleans.io/6aa0cfd2-1b76-4ee8-9ac8-2144b3c1e7a9\n     curl: (6) Could not resolve host: api.booleans.io\n\n", "id": "d1x5bse"}], [{"comment": "0/10 no HATEOAS", "id": "d1xubb5"}]]], "5fxio6": ["Bro, do you even map? MapReduce demystified", "2016-12-01 19:34:43", 6, "https://dev.to/aurelherve/bro-do-you-even-map-mapreduce-demystified", [[24, "This article is about the map and reduce functions provided by most modern languages.  It is not about MapReduce."], [5, "> We will use typescript for even more readability\n\nHahaha. cry."], [5, "Good article. One critique - you should state what programming language your examples are using. The 1st example took me a second to realize it was javascript - the boolean operation confused me until I realized it was JS and a zero is equivalent to false in an if statement.\n\nIf anyone wants a [Ruby map/reduce example](https://github.com/pgibler/map_reduce_expenditures), I have one in my github repo you can try out :) ."], [1, "Any thoughts on the first example taking only 5 iterations of a list, whereas the 2nd is 11 (I assume)."]], [[{"comment": "This article is about the map and reduce functions provided by most modern languages.  It is not about MapReduce.", "id": "danuaxn"}, {"comment": "The programming model is roughly the same, or at least the terminology has been borrowed.  Yet I agree, that is click bait.   \n\nWhen you say \"MapReduce\", we're talking parallel/distributed functions manipulating data in a cluster, which comes with far more steps and terminology than simply writing Javascript filter/map/reduce functions.  The former you could spend a day just getting set up, the latter as this article has shown, can be written in 2 minutes.\n\nShould have just called it \"Functional Programming demystified\".  Even then, it says nothing on the topics of mutability, state... *sigh*", "id": "dao0pd1"}], [{"comment": "> We will use typescript for even more readability\n\nHahaha. cry.", "id": "danw2ct"}, {"comment": "I liked the article, but in this case, at least, typescript just added a bunch of noise ...", "id": "dao229w"}], [{"comment": "Good article. One critique - you should state what programming language your examples are using. The 1st example took me a second to realize it was javascript - the boolean operation confused me until I realized it was JS and a zero is equivalent to false in an if statement.\n\nIf anyone wants a [Ruby map/reduce example](https://github.com/pgibler/map_reduce_expenditures), I have one in my github repo you can try out :) .", "id": "dantqj4"}], [{"comment": "Any thoughts on the first example taking only 5 iterations of a list, whereas the 2nd is 11 (I assume).", "id": "dany6v6"}, {"comment": "Unoptimized, yes the first is way faster. Languages with strong FP can optimize things like this pretty easily though.\n\nScala offers streams that given a large chain of map/filter/fold/whatever functions, will only be traversed once when called.", "id": "dao0rbx"}, {"comment": "purefunctional languages will most likely lazily evaluate and iterate once. JS isn't one of those languages. I believe c# does something like that with linq but I'm not sure, even though c# isn't purely functional.", "id": "dao8apr"}]]], "530vey": ["What is Webix?", "2016-09-16 11:55:56", 3, "http://www.discoversdk.com/products/webix#/product-analysis", [[2, "This seems a framework that want to achieve everything with automagic.  Automagic is not usually how programmers write stuff. \n\nPerhaps a reason is because we want designers to design interfaces and we want programmers to program them.  If the layout is directed by source code, the designers will have to convince the programmers to make changes when they are neccesary. And a changes in layout  may break code that worked before. \n\nIt could be useful for a single person doing everything, if the framework already do everything this person need, but them this person will still have to learn how to use this framework, when he can just drop whatever jQuery plugin he need + whatever he already know."], [2, "If the headline can't give me a rough idea of what problem the product solves, it's likely because it doesn't solve any problem."], [1, "A tasty cereal..."]], [[{"comment": "This seems a framework that want to achieve everything with automagic.  Automagic is not usually how programmers write stuff. \n\nPerhaps a reason is because we want designers to design interfaces and we want programmers to program them.  If the layout is directed by source code, the designers will have to convince the programmers to make changes when they are neccesary. And a changes in layout  may break code that worked before. \n\nIt could be useful for a single person doing everything, if the framework already do everything this person need, but them this person will still have to learn how to use this framework, when he can just drop whatever jQuery plugin he need + whatever he already know.", "id": "d7p71bh"}, {"comment": "also react has it all in one code (javascript , JSX - HTML and styles). it is a front end framework", "id": "d7p7u45"}], [{"comment": "If the headline can't give me a rough idea of what problem the product solves, it's likely because it doesn't solve any problem.", "id": "d7pbtoj"}], [{"comment": "A tasty cereal...", "id": "d7t12bd"}]]], "48sfmb": ["Tilt Brush by Google", "2016-03-03 18:28:45", 5, "http://www.tiltbrush.com/", [[17, "While it's a very cool demo that I'm looking forward to trying myself, it doesn't really seem related to programming. Why did you post it here?"], [2, "I got queasy watching the demo on my PC monitor, let alone in VR..."], [2, "It's been years since I did 3D modeling, but it seems like there would be an application of this for 3D mesh \"sculpting\".\n\nBut yeah, not programming..."], [-2, "VR is now where the web was in 1995. neat startup idea: do ANYTHING VR and wait to get acquired"]], [[{"comment": "While it's a very cool demo that I'm looking forward to trying myself, it doesn't really seem related to programming. Why did you post it here?", "id": "d0m5goe"}, {"comment": "I'm guessing because it's on hacker news. If you haven't noticed this sub is almost a mirror of hacker news.", "id": "d0m6j86"}, {"comment": "I tried it on Vive. It felt amazing. My favorite VR demo so far. ", "id": "d0mjtmx"}], [{"comment": "I got queasy watching the demo on my PC monitor, let alone in VR...", "id": "d0ma6re"}, {"comment": "The key difference is that the movement will be *your* movement with a VR headset.", "id": "d0mc2db"}, {"comment": "I tried Tilt Brush with the HTC Verve, and the head/body tracking was good enough that I didn't feel sick at all (and I often get sick with other similar VR demos).  \n\nReally, it was a pretty amazing experience.  First time I felt like VR really worked.", "id": "d0mdtd0"}], [{"comment": "It's been years since I did 3D modeling, but it seems like there would be an application of this for 3D mesh \"sculpting\".\n\nBut yeah, not programming...", "id": "d0mfzx8"}], [{"comment": "VR is now where the web was in 1995. neat startup idea: do ANYTHING VR and wait to get acquired", "id": "d0mc4my"}]]], "48go1f": ["TempleOS: Talking SETI's Demands on the Industry", "2016-03-01 17:25:44", 0, "https://www.youtube.com/watch?v=RvL7T4gIJN8&feature=youtu.be", [], []], "53o3dc": ["Why Vue (Not React) Is the New jQuery", "2016-09-20 20:06:35", 7, "http://anyonecanlearntocode.com/blog_posts/why-vue-not-react-is-the-new-jquery", [[47, "jQuery is the new jQuery... it's also the old jQuery."], [41, "The JavaScript development scene is asinine"], [24, "I've recently started getting into the JS world because I hate having this huge knowledge gap, but I'm already sick of it :("], [15, "> Vue provides an answer to the issue of JavaScript fatigue, and it is a worthy successor to the legacy of jQuery as the ideal entry point for beginners to the world of modern frontend development.\n\nProvides an answer to, or is contributing to? Hint: it's the latter."], [13, "fuck me, another one?"], [11, "Vue.js is a fantastic mashup of React and Angular 1 with a growing community.  However, jQuery is jQuery due to the overwhelming amount of developers out there who have used it.  Vue.js is not the new jQuery, today.  I question if we will see a new jQuery anytime soon."], [4, "I use vue and I like it. Of course it is not the best or something, it still has quirks and gotchas. But the learning curve is ok and the tooling is ok. And the devs go into the right directions. (See change v1 vs v2)."], [4, "It seems as if the biggest argument is that JSX requires compilation.\n\nThis didn't stop TypeScript from growing a huge community. And TypeScript supports JSX out of the box, so you don't need Babel just for JSX.\n\nTypeScript and JSX/React together provide so much value, the pain of setting up a modest compiler watch is negligible in comparison.\n\nAdditionally if learning curve is a problem, JSX doesn't recreate JavaScript by adding its own attributes for loops and conditions, an error too often repeated by templating systems. In JSX you can use plain JavaScript to build and map nodes. So JSX is a far easier thing to learn than Vue."], [4, "Someone correct me if I'm wrong, but jQuery is not designed to do the same things as easily or simply as React or Vue do, right?\n\nThey were designed for different things, as far as I see it. So why do people keep comparing two dissimilar things?"], [2, "This is my own perspective, but I believe that there's a small problem with this opinion. It looks like your argument stems from a historical comparison to jQuery. In 2006, jQuery was released amidst a slush of other (comparatively) more well-established frameworks at the time. Over the next two years, in spite of the existence of many incumbents, jQuery more or less became the de-facto framework for the web-development ecosystem. Why did this happen? I agree with your premise,\n\n> jQuery was made for people who don't program, everything else seems like it wasn't.\n\nIt makes a lot of sense; 2005 was an inflection point for web-based technology. The crater left behind by the bubble stopped expanding; internet adoption and bandwidth were finally moving past the slow dial-up/AOL days; the browser segments finally started to standardize. Amateurs and businesses alike were beginning to reinvest into the web (hence the 2.0 craze). Without a de-facto handbook of how to make websites, everyone basically started at the same point. It doesn't matter if you've been in the software-development scene for decades, you still have to make a relatively sizable time-investment to get into the new craze. jQuery makes it easy for everyone (both beginners and professionals alike) to do what they need to do, and that's why it succeeded over the others.\n\nHowever, I don't think that carries as much weight today.\n\nThe web-development scene is considerably more mature now and it has shifted its priorities accordingly. It's ten years later, and there are more battle-hardened developers with different needs. Now, I can't speak much on what these priorities are since I don't dabble in this industry, but my gut tells me that Javascript development has gotten to the point where the ecosystem is no longer optimizing along the smoothness of the learning curve. Tooling and support are likely much more important to the industry these days, as well as complexity management.\n\nNow, I'm not writing off the needs of beginners here, but I don't think it would be realistic to say that the framework that is the easiest to pick up will run the gamut these days. Having self-contained frameworks that are easy to learn is still extremely important."], [3, "I tried Vue and I liked it in comparison to Angular. That said, I prefer React and Redux or Elm over Vue. It's just the habits that React and Redux (with immutable) or Elm enforce. I like functional programming paradigms and immutability better than imperative mutability because it makes you rethink the problem in a different way and it gives you nice guard rails while not making the problem too easy to solve or too slow to be competitive.\n\nThat said, Vue is a great framework introducing people to front end development. It's simple and does a lot of the things larger frameworks, like Angular, do without drowning you in the complexity."], [2, "heh i picture the new jquery as being better languages that i compile to js and use underlying concepts of react to help with the essentials"], [2, "How does vue compare to knockout? It looks like another wheel reinvention.\n\nAnd if that's the case, how does it replace jquery? Knockout and jquery have always worked well together."], [2, "And It doesn't support  TypeScript. Next please..."], [1, "Vue isn't comparable to Angularjs: \u00abVue.js itself is not a full-blown framework - it is focused on the view layer only\u00bb (the doc). Angular does async http calls, works with APIs easily, provides a testing framework, etc. Hello world in angular: https://angularjs.org/\n\nI don't know React."], [1, "JQuery is fiiiineeeeee"], [0, "Interesting argument..."], [-12, "Fascinating how people on /r/programming are so ready to shit on anything JavaScript. Here's a thought: if you don't understand these trends, maybe it's because you don't have enough experience in front-end development to see their value."]], [[{"comment": "jQuery is the new jQuery... it's also the old jQuery.", "id": "d7urin9"}, {"comment": "I can't agree more. Why does everybody hate on jQuery? I always hear arguments about how it ends up making your code too complex / unmaintainable, but that seems like rubbish to me. \n\nMeanwhile, the proposed replacements (angular, ember, react) are literally  rewriting their core code because either it got too complex / unmaintainable or some other major deal-breaking flaws ocurred. \n\nnew and shiny != dependable and battle-tested", "id": "d7v2vy2"}, {"comment": "To me, comparing Angular or React to jQuery makes no sense whatsoever. Those frameworks work on wholy different level of abstraction than jQuery, which is much more low-leve. It's almost like comparing assembly to Python.\n", "id": "d7v7d8s"}, {"comment": "If you think jQuery  resembles assembly, you are definitely doing it wrong.", "id": "d7vy788"}, {"comment": "I said no such thing.", "id": "d7w0bup"}, {"comment": "I guess I just can't see how someone can think that jQuery is low-level.", "id": "d7w0pd3"}, {"comment": "Well, those frameworks are meant for organizing and structuring whole applications (or at least the view part), they work with whole bundles of data (ie. of application state, etc.). AFAIK jQuery does none of that, it just lets you do stuff like DOM manipulation, AJAX, etc, basically, it rectifies browser API shortcommings, but that's it. I can easily imagine an application framework designed on top of jQuery, using its DOM manipulation abilities and such under the hood.\n\n(btw for the record, I didn't downvote you.)\n", "id": "d7w81ud"}, {"comment": "I mean, most of my js framework experience was in ember and it was super frustrating. The documentation was crap and it was very difficult to find help elsewhere. Not only that, but they would constantly deprecate parts of their api and rebuilt their rendering engine twice. It feels like building on quicksand while every new major problem you run into is new and unique to you. Nothing on SO. \n\nOh, but you can pay a consulting company that employs the core members $250 / hour base rate for training or help. :|", "id": "d7w8dw5"}, {"comment": "because \"low level \" is relative.\n\nassembly is high level to an intel engineer and low level to a software developer.\n\nThe point that was being made is that jquery is on a lower abstraction level than the other technologies.\n\nBut you knew that didn't you?", "id": "d7w8uv0"}, {"comment": "> jquery is on a lower abstraction level than the other technologies\n\nIf that was the case, I would see your point. I am of the opinion jQuery is the lowest barrier to entry for (web) app development. If you know html/css selectors well, you're well on your way to knowing jQuery. That's not the case with most of these emerging frameworks. Couple that with the fact that I can google any problem with jquery and have ten pages of other people who have solved my problem. Try googling common problems with a brand new framework.", "id": "d7wa1w7"}, {"comment": "> If you know html/css selectors well, you're well on your way to knowing jQuery. That's not the case with most of these emerging frameworks\n\nIn other words, jquery is very close to the \"metal\" (in this case the browser/DOM) whereas the other frameworks operate at a higher level of abstraction... exactly as has been stated already.\n\nstop being obtuse, disliking these frameworks is no excuse to be blind.", "id": "d7wa5r4"}, {"comment": "Can you give me a concrete example of what you're talking about? When building a web app front end you basically have to do two things minimum: make http requests and manipulate the dom. jQuery makes both of those things abundantly easy. Whichever shiny new unspecified framework you're saying makes life simpler will probably cause more pain than it claims to fix.", "id": "d7wakmb"}, {"comment": "[deleted]", "id": "d7v88jr"}, {"comment": "Wait, which one of those is supposed to be the pile of horse feces? /s", "id": "d7v8qgv"}, {"comment": "You missed the main point of the article: code *written with jQuery* is hard to maintain. You're talking about jQuery itself, which obviously became more robust in the past decade.", "id": "d7v777b"}, {"comment": "> code written with jQuery is hard to maintain. \n\nI call bullshit on that one. jQuery's been around about a decade now and has lots of mature projects out in the wild. Come talk to me in another 5-7 years when everyone starts calling React hard to maintain. Hell, with Angular it took less than 3 years.", "id": "d7vbwtw"}, {"comment": "> I call bullshit on that one. jQuery's been around about a decade now and has lots of mature projects out in the wild. Come talk to me in another 5-7 years when everyone starts calling React hard to maintain. Hell, with Angular it took less than 3 years.\n\nReact is fundamentally different in that it's a stateless functional one-way pipeline, which is inherently easier to manage, compared to APIs like jQuery and Vue are, which are used to drive spaghetti-prone state machines.\n\nI'm not blaming jQuery or Vue for being stateful, but state always allows people to mess up, and then they blame their tools. React takes that opportunity away through its architecture.\n\nRegarding Angular, I saw the criticism for Angular coming before it even existed. It was architecturally flawed from the very start, and I don't know why libraries keep trying to make two-way binding happen. It won't happen. Not in Angular, not in Vue. It'll always be fragile, limited and perform poorly.\n\nReact will never get that kind of infamy. It might be bashed for being limited maybe, or god knows what, but it's stateless and it's not two-way binding, so just this alone puts it in a better category.", "id": "d7vveju"}, {"comment": "It started becoming more robust once they started pulling out the compatibility stuff for older IE versions in jQuery 2.0.\n\nThen again, it also became less useful when said support was pulled because modern browsers tend to do things in a more standards-compliant way and you no longer need all the compatibility hacks.", "id": "d7v8tu5"}, {"comment": "> You missed the main point of the article: code written with jQuery is hard to maintain.\n\nPoor craftsmen blame their tools.", "id": "d7vvd0m"}, {"comment": "Obviously a good carpenter *could* build something relatively good with bad/unsuited tools.\n\nBut because he's a good carpenter, he'll decide to use better ones.", "id": "d7vvr60"}, {"comment": "jQuery is just a thin wrapper over browser APIs and some of their quirks. The only thing it does is allow you to express the same intent more compactly and with less edge cases.\n\nTo blame someone's code quality on the fact they used jQuery is non-sense, insofar jQuery doesn't prescribe a specific architecture for you, it simply improves access to browser APIs.\n\nIf someone can't code right unless their tools force them to, maybe they need something more elaborate, like a framework, to be their training wheels. But jQuery never set out to be a framework, so it makes no sense to blame it for not being a framework.", "id": "d7vvv75"}, {"comment": "Its abstractions are in my experience well suited for one-shot DOM manipulations, but not for frameworky stuff.\n\nTherefore you're right: it's a bad idea too use it for that. And since we were talking about bigger sites/applications, that means i was right too, and jQuery leads to unmaintainable code there.", "id": "d7vxlfq"}, {"comment": "That's not what I said. I said it's a library without opinion that is as capable as the person using it. Its goal is to make DOM and AJAX more compact and predictable across browsers.\n\nIt can be used in apps ranging small to giant. It can be used ranging horribly to excellently. It's not a \"bad idea\" to use it for large apps. It's only a bad idea in the hands of someone who feels clueless about how to design their own app. And sure I've seen juniors mess horribly with jQuery. I've also seen them do better after some training. That's why experience matters in programming.\n\nIt's a sad state of affairs that we've become so dependent on someone else thinking for us, that we insist that every library under the sun should be a massive and rigid hand-holding framework.\n\nSome of us can code, you know. We're fine with being allowed the liberty of architecting on our own.", "id": "d7vxym5"}, {"comment": "d3 is something with a selector and batch modifying API that lends itself to building bigger things IMHO.\n\nElse I just tend to create my own data structures if I work low level", "id": "d7vyj54"}, {"comment": "I personally hate jQuery because it's completely obsolete. Anything you can do in jQuery can be done using HTML5 methods with a similar amount of code. Using `$` as a cross-platform way to select with a CSS selector 5 years ago may have been amazing, but today you can implement that with just `var $ = document.querySelector` or `querySelectorAll`. The fetch API is going to be just as good as jQuery's ajax API. The DOM manipulation stuff has mostly been replaced by MVCs like Angular, React, Vue, Mithril, etc. All jQuery really does at this point is add a whole bunch of bloat.", "id": "d7vai7z"}, {"comment": "(Best viewed in HTML5 supporting browsers)\n\nIt must be nice to be able to turn down lucrative legacy maintenance-code gigs.", "id": "d7z4lc3"}, {"comment": "most of the features I'm talking about have been supported for a while. Queryselector is since ie8.", "id": "d7z5jnz"}, {"comment": "Falling back to ie8 is not the degree of legacy support that I'm referring to.", "id": "d7z7pma"}, {"comment": "Well, what kind of legacy support are you referring to then?", "id": "d7z94uq"}], [{"comment": "The JavaScript development scene is asinine", "id": "d7uvwz8"}, {"comment": "Good contribution ", "id": "d7vkczl"}], [{"comment": "I've recently started getting into the JS world because I hate having this huge knowledge gap, but I'm already sick of it :(", "id": "d7uv4la"}, {"comment": "If you're just now making your foray into the JS ecosystem, I would really advocate focusing solely on learning the language itself and its quirks (preferably ES2015 and how its features can be achieved in ES5). These frameworks and their time in the limelight can't be relied upon, but having a good idea of what's going on underneath will be invaluable.", "id": "d7uz4rc"}, {"comment": "This this this this this this. There is only one semi-consistent object in JS land: JS. Everything else is vaporware. Actually Angular 1 has been doing alright (been around for 7 years and still going!). Component-based development is the other thing I recommend looking into now too - something Angular 1, React, etc all can do.\n\nI've put my money on Angular 1 as the go-to framework I need, and so far it's been paying off. Only use frameworks that have been around for like 2+ years and don't bother with anything else.", "id": "d7v0eg5"}, {"comment": "So what are you going to do when angular 1 gets deprecated?", "id": "d7v64gq"}, {"comment": "Angular 1 and Angular 2 are completely separate products. That's like saying \"what are you going to do when JavaScript gets deprecated?\" when talking about Web Assembly. I will continue to use Angular 1. I will continue to use JavaScript.", "id": "d7v6rkx"}, {"comment": "Right, but there will be a point at which google will stop maintaining angular 1. I don't see that happening with javascript or angular 2 until google decides to rewrite again.", "id": "d7vy3ly"}, {"comment": "Do you have a book, site, or resource that you feel gives a good overview on learning the language itself?\n\nI'm a back end web developer, but I'd love to learn more about JS than I know now. Because right now it's basically... well it's jQuery, if I'm honest.", "id": "d7v3edl"}, {"comment": "Nicholas Zakas' books are great and in depth overviews of Javascript language and how it works behind the scenes. Professional Javascript for Web Developers and Understanding Ecmascript 6 are pretty good imo.", "id": "d7v3m5j"}, {"comment": "Awesome, thank you! I'll take a look at them!", "id": "d7v457p"}, {"comment": "Understanding Ecmascript is actually [free to read online](https://leanpub.com/understandinges6/read) However, it is mostly about new stuff of ES6/ES2015 so it assumes some pre-existing knowledge of JS though imo not too much so you might want to pick the other books first.", "id": "d7v6951"}], [{"comment": "> Vue provides an answer to the issue of JavaScript fatigue, and it is a worthy successor to the legacy of jQuery as the ideal entry point for beginners to the world of modern frontend development.\n\nProvides an answer to, or is contributing to? Hint: it's the latter.", "id": "d7urhm3"}, {"comment": "There are only a few genuinely common frameworks these days and many other attempts to refine them with vastly smaller communities.  This is hardly a problem.  The real irritants are the marketing/hype and the short-lived nature of them.  The solution is simple: use one of the common frameworks.  Ignore the rest of them unless you feel like seeing someone else's take.", "id": "d7uvl7r"}, {"comment": "Pretty sure there's a relevant xkcd for this.", "id": "d7v2xbj"}, {"comment": "###[Irrelevant xkcd](http://xkcd.com/111/)\n\n\n\n**********\n\n I'm a bot bleep, bloop", "id": "d7v2xcq"}, {"comment": "I get your point since it's another JS framework that adds to the list of annoyingly endless options in JS ecosystem.\n\nHowever Vue in my opinion differentiates itself with a minimal API with an easy learning curve and requiring no magic build step and confusing you with server side rendering, pollyfills, transpilations etc. I used in a school project once and it just worked outside the box.\n\nConsider Angular completely breaking its user space in v2, and having a daunting documentation including stuff like \"transclusion\" (as a non-native speaker, a few of these were enough to scold me off Angular); or React which expects you to learn JSX syntax and transpile your code and learn all its Flux / Redux / High order components. I'm a huge fan of React, but none of these issues happened to me with Vue so it definitely has a chance to decrease  JavaScript fatigue if it follows in the current direction.", "id": "d7vlvy7"}, {"comment": "> I get your point since it's another JS framework that adds to the list of annoyingly endless options in JS ecosystem.\n\nRight on.\n\n\n> However Vue in my opinion differentiates itself with a minimal API with an easy learning curve and requiring no magic build step and confusing you with server side rendering, pollyfills, transpilations etc. I used in a school project once and it just worked outside the box.\n\n\nNothing you listed is required for React development. You're totally free to include the JSX transpiler in your browser and not ever build it locally. You're also free to not use JSX at all (although that'd be silly). Server Side rendering is especially not required.\n\n> Consider Angular completely breaking its user space in v2, and having a daunting documentation including stuff like \"transclusion\" (as a non-native speaker, a few of these were enough to scold me off Angular); \n\nAngular 1.0 is utter garbage. Nobody is arguing with that. It has inefficient rendering, the API is awful, the paradigms aren't good, etc. It's just a giant piece of technical debt.\n\n> or React which expects you to learn JSX syntax and transpile your code and learn all its Flux / Redux / High order components.\n\nAgain, React does not expect you to do any of that. You're totally free to build out your app however you want.\n\n> I'm a huge fan of React, but none of these issues happened to me with Vue so it definitely has a chance to decrease JavaScript fatigue if it follows in the current direction.\n\n\"I like it so it reduces JavaScript fatigue.\"  This is not what JS Fatigue means. You've chosen a thing and stuck with it, regardless of hype. That's the absolutely correct mindset. Pick a thing and stick with it, even if the internet decides it's not the best thing.\n\nThe problem is that every day a new library pops up and says \"Hey, I don't like how we've solved this problem in the past, here's my slight offshoot of some other library.\"  As in, the goal of Vue was to easily create UI-components that render quickly and does not assume anything about the rest of your stack.  What else has the exact same goal? React. In my opinion, the solution to this problem is fork/fix/merge, not \"I wrote a new library from scratch that has largely the same but slightly different syntax/paradigms/etc\"\n\nSo, great, you love Vue, I'm happy for you. But Vue (and every other JS library) is not solving \"JS fatigue\" or fixing the ecosystem.", "id": "d7w8ks0"}, {"comment": "> You're totally free to include the JSX transpiler in your browser \n\nYeah and keep getting annoying warnings in your console\n\n> React does not expect you to do any of that.\n\nThe ecosystem is clearly defined honestly. These are not required but I don't see beginner tutorial these days that don't add Redux / Jest / Router to the project. There a fuck ton of Medium posts out there missing the requirements of a beginner and just adding dependency after dependency, they're contributing immensily to at least my JS fatigue.\n\n> the solution to this problem is fork/fix/merge\n\nIf someone thinks they can do better, I'm fine with them inventing their own. Facebook didn't fix Angular or Backbone, they redefined their front end.\n\n> Pick a thing and stick with it\n\nTo be clear I am currently using only React in production, not Vue. I haven't used used Vue enough to love it, but I absolutely see their selling point. JS fatigue is not just about new libraries coming up and blurring the ecosystem, it's also about having a reasonably understandable API and not pull out your hair while you're debugging it.\n\n\n\n", "id": "d7w96f2"}, {"comment": "> JS fatigue is not just about new libraries coming up and blurring the ecosystem, it's also about having a reasonably understandable API and not pull out your hair while you're debugging it.\n\n[No, its not](https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4#.bo6n1ncgw)", "id": "d7x3bvt"}, {"comment": "The blog you posted already mentions what I'm saying, so I'm not sure how you're rejecting my point.\n\n> Application developers should not have to become experts in the underpinnings of the library just to use it.\n\nSeriously though, most JS libraries documentations are either very sparse or very broken. I don't have this issue when I'm working in Ruby or Objective-C/iOS ecosystems. I don't need to see the internals to understand what's going on while debugging.\n\nAlso, oh, someone else's Medium post that has lots of shares, I'm sure I'll take it as a definitive guide on JS fatigue and not have my own opinions /s\n\nEdit: Found this following links from the Medium Post https://twitter.com/floydophone/status/680226147213426688\n\n> I think you can blame lacking docs, lacking tooling, over/underopinionated-ness of popular projects, etc\n\n.\n\n> webpack was really hard for me to get down. I feel like docs are lacking. Still don't understand diff srcmaps\n\n.\n\n> the tooling involved in most \"modern\" apps (react/redux/webpack/babel/etc) is pretty bonkers and involves a lot of arcane magic", "id": "d7x5kz7"}, {"comment": "You're right, you're totally allowed to define any word or phrase however you want. I guess my point is you're not using the phrase as everyone else uses it, which is kind of the  whole point of language in the first place.", "id": "d7xr3ev"}], [{"comment": "fuck me, another one?", "id": "d7v0yma"}, {"comment": "vue.js been around for a while", "id": "d7vgrqs"}], [{"comment": "Vue.js is a fantastic mashup of React and Angular 1 with a growing community.  However, jQuery is jQuery due to the overwhelming amount of developers out there who have used it.  Vue.js is not the new jQuery, today.  I question if we will see a new jQuery anytime soon.", "id": "d7uve3j"}], [{"comment": "I use vue and I like it. Of course it is not the best or something, it still has quirks and gotchas. But the learning curve is ok and the tooling is ok. And the devs go into the right directions. (See change v1 vs v2).", "id": "d7usdk0"}, {"comment": "I don't think they are. I started using it recently and reported a few bugs. Every time the response was \"v2 will be out soon\" or \"v2 doesn't have that feature\" - I wasn't reporting bugs in the next version, but the current one! They are doing the same thing as everyone else and abandoning support for their own code before the newer less capable version is even out. Fixes at least should be done for major versions for at least the next one major version.", "id": "d7v167q"}, {"comment": "so like any open source project", "id": "d7vovfc"}], [{"comment": "It seems as if the biggest argument is that JSX requires compilation.\n\nThis didn't stop TypeScript from growing a huge community. And TypeScript supports JSX out of the box, so you don't need Babel just for JSX.\n\nTypeScript and JSX/React together provide so much value, the pain of setting up a modest compiler watch is negligible in comparison.\n\nAdditionally if learning curve is a problem, JSX doesn't recreate JavaScript by adding its own attributes for loops and conditions, an error too often repeated by templating systems. In JSX you can use plain JavaScript to build and map nodes. So JSX is a far easier thing to learn than Vue.", "id": "d7uzpy9"}, {"comment": "[deleted]", "id": "d7v0mtp"}, {"comment": "> But React isn't. \n\nReact is very simple. You write JSX, and you call ReactDOM.render(jsx, node) to render it in DOM. Everything else is optional, and I'd argue often unnecessary.\n\nIf you thought React is complex, congratulations. You just learned React.\n\n> Plus no matter how long I work with it, JSX always feels wrong to see in code, while .vue files at least give you a clear impression of concern separation.\n\nJSX is a very thin abstraction over building a tree of objects that represent virtual DOM. It is code.\n\nAnd while I can't do anything to change how you *feel* per se, always remember that concerns should be separated through *architectural boundaries*, not through *syntactical ones*.\n\nReinventing JavaScript like Vue does through \"directives\" and \"filters\" doesn't separate concerns. It just pointlessly introduces a \"baby\" version of features that already have a more flexible and mature alternative in JavaScript.", "id": "d7v1482"}, {"comment": "You missed all the compile steps and leaky abstractions, it doesn't look like vue suffers from these.", "id": "d7v7y9c"}, {"comment": "Indeed I forgot all the leaky abstractions. Thanks for being so specific.", "id": "d7v8tzo"}, {"comment": "You forgot about all the compilation steps turning what you code in into something other than what you debug in?", "id": "d7v9m9d"}, {"comment": "source maps are your friend :)", "id": "d7v9to5"}, {"comment": "Source maps are a patch on the leak. What about when things don't compile 1 to 1?", "id": "d7va02f"}, {"comment": "> Source maps are a patch on the leak. What about when things don't compile 1 to 1?\n\nDo you even understand how debugging works and what source maps are?\n\nIt may shock you, but your browser doesn't run JavaScript code directly in its virtual machine, either. It compiles it to opcodes and machine code and uses an internal *source map* while debugging.\n\nThe source and the result are topologically the same. Nothing in JSX or TypeScript would arbitrarily refactor your code to something else the source map can't make sense of. So in that sense, it's all \"1:1\".", "id": "d7vvbfx"}, {"comment": "> It seems as if the biggest argument is that JSX requires compilation.\n\nIt's not that it requires compilation, it's that JS build tools required to make said compilation happen SUCK. I haven't used build tools this bad since a small game team I was on decided to write our own in python.", "id": "d7vc0iq"}, {"comment": "Why in the world I would want to compile JavaScript to JavaScript?!", "id": "d7vgvkj"}, {"comment": "EXACTLY! If we're going to use JS as a build target, we might as well go all the way and use a language with static typing.", "id": "d7vhchj"}, {"comment": "Agreed, \n\nWhat I feel we are needlessly making things too complicated. ", "id": "d7vi3ql"}, {"comment": "Like TypeScript, which I mentioned in my first comment...?", "id": "d7vv5e1"}, {"comment": "A language designed with static typing in mind from the start, not JS with a static type system bolted on top. Something similar to Kotlin, Nim or Swift, but that compiles to JS instead of the JVM or C.", "id": "d7vzati"}, {"comment": "I see, so welcome to a decade ago, when Delphi, C#, Basic and so on came out with JavaScript compilers. And Google had GWT that compiled Java to JavaScript. Those who don't know their history are doomed to repeat it.\n\nDo you know why they failed? Because JavaScript doesn't exist in isolation. There's an ecosystem around it. Libraries written for JavaScript and APIs designed for JavaScript. Not to mention how reliant JavaScript is on dynamic data coming from servers and so on. Ignoring all this makes JavaScript a lot less useful.\n\nThis is why Microsoft abandoned their C#-to-JavaScript strategy in favor of TypeScript. And Google went with something closer to your ideal, Dart, and what came out of it? Nothing. Google's own libraries are written in TypeScript now (Angular 2).\n\nTypeScript's type system is not simply \"bolted on top\" mind you. The type system reflects precisely the nature of JavaScript's implied types. This is why all the existing JS libraries can be expressed perfectly as TS libraries:\n\nSee this: https://github.com/DefinitelyTyped/DefinitelyTyped\n\nYou may want to dismiss TypeScript as some half-hearted effort, but it was designed carefully by the experienced minds who created Delphi and C#, so it only does a disservice to you to be so ignorant about it. I'm actually quite impressed at *how well its design fits to JavaScript*. I can't think of anything forced or leaky about it. It's natural.", "id": "d7w05ev"}, {"comment": "I wouldn't say GWT was a failure. And AdWords is written in Angular2 Dart now. There's actually a decent amount off Dart stuff in production, but it's mostly enterprise, huge application stuff. You're never going to see Dart gain JS users for just doing web work. ", "id": "d7wxxjs"}, {"comment": "Yeah, that's pretty much Dart. Language designed to take over server side duties of Java, but a scripting language that easiliy compiles to JS. And it basically gets berated by the entire JS community, even though it has some of the best tooling out there. Dartium with the Dart VM in it lets you do hot reloads without compiling to JS. They're working on clean ES6 output, a TS definition > Dart converter, and incremental JS compile too. But it's community has largely plateaued and stagnated b/c of TypeScript.", "id": "d7wxsp3"}, {"comment": "you compile JSX not JS", "id": "d7vr3nd"}, {"comment": "> build tools required to make said compilation happen SUCK. I haven't used build tools this bad since a small game team I was on decided to write our own in python.\n\nDo you realize your comment is entirely void of information? What \"sucks\" in build tools? What is \"bad\" about them?\n\nIf you'll bother posting a comment, at least try to say something.", "id": "d7vv7ns"}, {"comment": "Vue competes in the realm of green field applications, typescript in the opposite of that. Requiring a build process (compilation) isn't an issue when the entire purpose of typescript is to add static type checking.", "id": "d7vfry4"}], [{"comment": "Someone correct me if I'm wrong, but jQuery is not designed to do the same things as easily or simply as React or Vue do, right?\n\nThey were designed for different things, as far as I see it. So why do people keep comparing two dissimilar things?", "id": "d7v5595"}, {"comment": "No. jQuery wasn't designed to be be the same thing (or vice versa). jQuery is more of a selector engine, an extensible library and a plugin architecture. jQuery was originally designed to take a lot of the pain away from interacting with the DOM at a time where browser compatibility was crap and the code you wrote with one browser in mind would break on another.\n\nReact was designed with the intent for writing highly performant javascript applications by using a virtual DOM, rather than you interacting with the DOM directly.\n\nVueJS is very similar in that regards. They are tools more suited for building front-end applications than jQuery is.\n\nSo, yeah, you are right. They were designed for different things.\n\nI think the point the author was trying to make, however, is that the author thinks that if you are considering jumping on the \"Reactive Components\" train (ie. ReactJS), maybe you should consider VueJS instead because its easier to get ramped up on and is pretty solid - just like jQuery was when it gained popularity over its alternatives I guess.", "id": "d7vhanj"}], [{"comment": "This is my own perspective, but I believe that there's a small problem with this opinion. It looks like your argument stems from a historical comparison to jQuery. In 2006, jQuery was released amidst a slush of other (comparatively) more well-established frameworks at the time. Over the next two years, in spite of the existence of many incumbents, jQuery more or less became the de-facto framework for the web-development ecosystem. Why did this happen? I agree with your premise,\n\n> jQuery was made for people who don't program, everything else seems like it wasn't.\n\nIt makes a lot of sense; 2005 was an inflection point for web-based technology. The crater left behind by the bubble stopped expanding; internet adoption and bandwidth were finally moving past the slow dial-up/AOL days; the browser segments finally started to standardize. Amateurs and businesses alike were beginning to reinvest into the web (hence the 2.0 craze). Without a de-facto handbook of how to make websites, everyone basically started at the same point. It doesn't matter if you've been in the software-development scene for decades, you still have to make a relatively sizable time-investment to get into the new craze. jQuery makes it easy for everyone (both beginners and professionals alike) to do what they need to do, and that's why it succeeded over the others.\n\nHowever, I don't think that carries as much weight today.\n\nThe web-development scene is considerably more mature now and it has shifted its priorities accordingly. It's ten years later, and there are more battle-hardened developers with different needs. Now, I can't speak much on what these priorities are since I don't dabble in this industry, but my gut tells me that Javascript development has gotten to the point where the ecosystem is no longer optimizing along the smoothness of the learning curve. Tooling and support are likely much more important to the industry these days, as well as complexity management.\n\nNow, I'm not writing off the needs of beginners here, but I don't think it would be realistic to say that the framework that is the easiest to pick up will run the gamut these days. Having self-contained frameworks that are easy to learn is still extremely important.", "id": "d7uvxs3"}, {"comment": "Very true, the web development scene is vastly different than when jQuery took over, and the needs of the industry have changed greatly. But I do like to think that the web will always have a special place for beginners to get their first taste of software development. So many battle-hardened developers got their start long ago from seeing a cool website and inspecting its source. \n\nI see jQuery as a tool that in some sense democratized the web even further, as it was indeed used by both beginners and professionals alike. I don't necessarily see that with React, Angular 2, etc., which are designed by giant companies solving giant needs. So many beginners come in wanting to use \"real\" tools, because it's kind of depressing to learn a \"beginner\" framework only to have to learn a new one that's more \"professional\". \n\nSo in this sense, I see Vue as a framework that has the same potential as jQuery to bridge the needs of both beginners and professionals. Perhaps I'm unrealistic in the sense of it's potential to win the same mindshare as jQuery, but as of now Vue is the framework that I recommend without hesitation to a beginner looking to get started in web development. I'm hoping that frameworks like Vue can keep the beginner-friendly spirit of the web alive.", "id": "d7uzfmh"}, {"comment": "Plus Prototype was shit. Like seriously, that's part of why jQuery won. Today's holy war is Angular 2 vs React. That's pretty minor compared to Prototype vs jQuery.\n\nPrototype had `$()`, `$$()`, and `$F()`, for selectors. It also had `$A()`, `$H()`, `$R()`, and `$w()`, which are totally unrelated. It added methods and properties to the in-built prototypes. It's utility methods, like Ajax, was more verbose. All of it was more verbose.\n\nFor animations you had to use script.aculo.us. It was as shit as it's name, and the results looked as crappy as it's logo. Verbose API that ran badly. Many complex animations I had to do by hand with my own vanilla code because it was the only way to get them to run well.\n\njQuery had the nicest DOM API of the time. It had the nicest animations API at the time. It's API worked, and worked well. It did more, did it better, in less code, and that code was more readable. There is not a single redeeming feature about Prototype.\n\nand then the killer feature ... plugins! jQuery would not be jQuery without the plugins. Every programmer and their dog has written a plugin for jQuery.\n\nI remember on one of my first jobs I worked on a Rails site, and Rails used Prototype at the time. I would look at a page of code using Prototype and think *\"this could be replaced with 2 or 3 lines of jQuery.\"* I ended up ripping Prototype and script.what.ever out, and that was the last time I ever used Prototype. Good riddance.", "id": "d7v5a2k"}, {"comment": "You also forgot to mention cross-browser compatibility was a big deal back then.\n\n(Also, I wouldn't call jQuery a framework...)", "id": "d7vhmum"}], [{"comment": "I tried Vue and I liked it in comparison to Angular. That said, I prefer React and Redux or Elm over Vue. It's just the habits that React and Redux (with immutable) or Elm enforce. I like functional programming paradigms and immutability better than imperative mutability because it makes you rethink the problem in a different way and it gives you nice guard rails while not making the problem too easy to solve or too slow to be competitive.\n\nThat said, Vue is a great framework introducing people to front end development. It's simple and does a lot of the things larger frameworks, like Angular, do without drowning you in the complexity.", "id": "d7vjvpw"}], [{"comment": "heh i picture the new jquery as being better languages that i compile to js and use underlying concepts of react to help with the essentials", "id": "d7v19cs"}], [{"comment": "How does vue compare to knockout? It looks like another wheel reinvention.\n\nAnd if that's the case, how does it replace jquery? Knockout and jquery have always worked well together.", "id": "d7v8a18"}], [{"comment": "And It doesn't support  TypeScript. Next please...", "id": "d7vaglz"}], [{"comment": "Vue isn't comparable to Angularjs: \u00abVue.js itself is not a full-blown framework - it is focused on the view layer only\u00bb (the doc). Angular does async http calls, works with APIs easily, provides a testing framework, etc. Hello world in angular: https://angularjs.org/\n\nI don't know React.", "id": "d7uyibo"}, {"comment": "Vue takes a modular approach instead of cramming everything into core, which IMO is better since you can choose to use Vue's router or you can use another one that you like better. Just Vue is based on the view layer, but it's got [a router](https://github.com/vuejs/vue-router), [an http client](https://github.com/vuejs/vue-resource), [a flux implementation](https://github.com/vuejs/vuex), [an async data loading plugin](https://github.com/vuejs/vue-async-data), etc, all official and by the Vue dev.\n\nFor testing, it just allows you to use the same testing tools [that everyone else uses](http://vuejs.org/guide/unit-testing.html)", "id": "d7v3iuv"}, {"comment": "I am speachless :) and glad to hear that ! ", "id": "d7vs8ff"}, {"comment": "> Angular does async http calls\n\nYour browser already does this (XMLHttpRequest). I think what you are thinking of is two-way data binding?", "id": "d7vhepj"}, {"comment": "No he means async http calls. No one wants to use deal with XMLHttpRequest directly for simple crud operations, so they use jQuery's Ajax calls or Angular's [$http](https://docs.angularjs.org/api/ng/service/$http). Vue does not give you a full blown front end stack for stuff outside view operations such as Ajax", "id": "d7vm76u"}, {"comment": "Ah, ok. Well, I guess I never really thought of that as a selling feature for a framework. Angular has some more powerful selling points, if you are making the argument that it is a full blown framework vs something that isn't, in my opinion.", "id": "d7vnsfw"}], [{"comment": "JQuery is fiiiineeeeee", "id": "d7vue4q"}], [{"comment": "Interesting argument...", "id": "d7utdk7"}], [{"comment": "Fascinating how people on /r/programming are so ready to shit on anything JavaScript. Here's a thought: if you don't understand these trends, maybe it's because you don't have enough experience in front-end development to see their value.", "id": "d7uymhy"}]]], "426pg1": ["Guy builds an amazing digital home assistant.", "2016-01-22 21:00:16", 0, "https://www.youtube.com/watch?v=13b0-uhZ5Rc", [], []], "5dgg93": ["ClojureScript saved me 100 hours", "2016-11-17 18:42:44", 25, "https://dev.to/buntine/clojurescript-saved-me-100-hours", [[46, "This is a pretty empty article, I wonder why it's getting so many upvotes.\n\nIt's literally just \"I ported a game written in clojure to clojurescript with minimal changes and it worked\"."], [7, "> And they were immutable and persistent, which gave them both the thread safety of immutability and the performance characteristics of mutability. \n\nI wonder where this is coming from. You can't make immutable data structures with performance characteristics of mutable ones."], [4, "Looks very very cool!"], [2, "MoonDweller didn't understand 90% of my commands. Pretty bummed."], [1, "The author of this article is /u/buntine, not OP."]], [[{"comment": "This is a pretty empty article, I wonder why it's getting so many upvotes.\n\nIt's literally just \"I ported a game written in clojure to clojurescript with minimal changes and it worked\".", "id": "da4dcj1"}, {"comment": "Well that is one advantage of full stack languages but i guess its not very special to clojure since every reputable language now has a \"to javascript\" option. Would have been more interesting if he used reader conditionals to have cross (host) platform clojure code.\n\nBut the game is pretty fun!!", "id": "da4h6sd"}, {"comment": "Check out OP's post history. Pretty quiet/normal account with very few submissions up until 3 days ago. In 3 days he's posted over 525 new submissions. To be clear I'm not accusing OP of anything specific, only that some weird behavior has popped up recently. ", "id": "da4m212"}, {"comment": "OP didn't write this article because /u/buntine already has his own account. **Edit:** /u/buntine is now /u/andy_panzer.", "id": "da4ow6c"}, {"comment": "Hmm? I know he didn't write it, sorry if my comment was unclear. /u/ryeguy said `I wonder why it's getting so many upvotes.` I mentioned OP's recent change in posting behavior as it could be related. ", "id": "da4qday"}, {"comment": "Hey, I am the author of the article and Moon Dweller. \n\nI wrote this post over a year ago. Last night I moved a bunch of old blog articles across to dev.to, I guess this one got picked for some reason. I've got no idea why it was posted here.\n\nAnd, for the record, I totally agree that it's really not a post-to-reddit kind of article! So, I apologise for the spam! :)", "id": "da4sq28"}, {"comment": "> I wonder why it's getting so many upvotes.\n\n/r/programming standard practice. If if the title speaks favorably of your favorite language, you upvote it.", "id": "da4sm4m"}], [{"comment": "> And they were immutable and persistent, which gave them both the thread safety of immutability and the performance characteristics of mutability. \n\nI wonder where this is coming from. You can't make immutable data structures with performance characteristics of mutable ones.", "id": "da4d368"}, {"comment": "Purely functional data-structures aren't that much worse (typically just a constant-factor or log-N difference from their mutable counterparts)\n\nWhen adding an element to an immutable array, it isn't necessary to allocate space for an entire new array, just the new item and an extra pointer (ie. the \"new array\" == pointer-to-old-array + pointer-to-new-item)\n\nYes, there is some overhead, which for memory or performance sensitive applications may be prohibitive (say, embedded devices or game engines), but for many applications the overhead is negligible (game logic, ui code, web app server code).  \n\nhttps://en.wikipedia.org/wiki/Purely_functional_data_structure", "id": "da4dovq"}, {"comment": "His point was the performance characteristics are *not* the same. Not that immutable data structures can't be decently fast.", "id": "da4hw2g"}, {"comment": "Realloc+memcpy is cheap. Change random elements in an array and we have a different story. Also consider the resulting non-flat memory structures (bad for cpu cache)", "id": "da4f6bj"}, {"comment": "Yeaaaa.. trying to say it's not bad by saying it's a linked list (which are pretty bad) is not very convincing. ", "id": "da70h43"}, {"comment": "You can if the branching factor of your bitmap trie is 32.", "id": "da4xl0v"}], [{"comment": "Looks very very cool!", "id": "da4c2pd"}], [{"comment": "MoonDweller didn't understand 90% of my commands. Pretty bummed.", "id": "da4ck84"}, {"comment": "I don't understand that.", "id": "da4d7mx"}, {"comment": ":)", "id": "da4dco6"}, {"comment": "Well for me the commands were very intuitive to guess. Maybe you are way more creative than i am :)\nEDIT: Dammit i got shot by an arrow.", "id": "da4hyds"}], [{"comment": "The author of this article is /u/buntine, not OP.", "id": "da4otr7"}, {"comment": "Now /u/andy_panzer.", "id": "da5item"}, {"comment": "Thanks for the update.", "id": "da5kbiy"}]]], "3vxvnm": ["Learn to Code: It\u2019s A LOT Harder Than You Think - All the evidence shows that programming requires a high level of aptitude that only a small percentage of the population possess", "2015-12-08 18:46:04", 0, "http://blog.debugme.eu/learn-to-code/", [[17, "Relevant comments from below the [original article](http://mikehadlow.blogspot.hu/2015/12/learn-to-code-its-harder-than-you-think.html), in my opinion:\n\n    This post is garbage. Conflating learning basic programming, which would help many people, with becoming a professional which programmer, which many people don't even want to do, is pointless. Saying that people don't have \"aptitude\" based on pass rates of awful introductory programming courses is awful. You're also conflating computer science, which is what universities teach, with programming, which they don't, really. This post is harmful to people who want to try something new but are having trouble. The other comment talking about \"aptitude\" for drawing hasn't seen what happens to art students who are properly instructed -- their work dramatically improves in a matter of days or weeks. We teach reading and writing even though most people will never become novelists. Programming is no different. Stop saying discouraging, stupid shit like this. -- Anonymous\n\nAnd, regarding the shoddy evidence provided for the argument:\n\n    The \"double hump\" study has been retracted. http://retractionwatch.com/2014/07/18/the-camel-doesnt-have-two-humps-programming-aptitude-test-canned-for-overzealous-conclusion/ -- Laurent Bossavit\n\nBoth sum up my thoughts on this pretty well. Lack of evidence, conflation of unrelated topics, false dichotomy, etc. Sure, I don't agree with saying \"_everyone_ should code\" or \"_everyone_ can code\", but that doesn't mean we shouldn't try to expose more people to a field that might interest them if they wouldn't otherwise be exposed to it..."], [10, "Paraphrasing the Pixar film *Ratatouille*: Anyone can code! This doesn't mean everyone can be a great programmer, but that a great programmer can come from anywhere.\n\nThe barrier to entry for programmers has never been lower. Given the existence of GC'd languages with lots of syntactic sugar, it is incredibly trivial to get a program working in short order. Hell, you can even code, compile and debug in a web browser!\n\nNo, the problem isn't finding programmers, it's *finding good programmers at a low price*. \n\nProgramming becomes hard is when it involves engineering skills -- the ability to understand the systems, technology, and the requirements well enough such that a single person can balance these criteria and make the necessary trade-offs to design a good architecture.  \n\nIn the software space, both the technology and the requirements change so rapidly that no one is able to develop that level of understanding, so they make terrible engineering choices that result in crappy software.\n\nThere are a few people who can do it, however: those people who have been around long enough to see the Big Wheel turn and recognize that the \"new hotness\" of this year is the same as the \"old and busted\" from ten years ago but with a new coat of paint. They've also dealt with changing requirements long enough that they can predict with utmost accuracy the unspoken and unknown requirements from business. The problem is that these are the guys who are too expensive, and businesses would rather have two or three shitty programmers pumping out crap software giving the *illusion of progress* than pay the salary of one programmer who actually knows something.\n\nTinfoil Hat Time: I've said this elsewhere, but I fully believe programmer shortage is made up -- it's a non-existent problem imagined by companies to drive employee costs down.  First it was discovered that programmers were cheaper in India, so companies outsourced. Then companies discovered that this didn't work because communication was the limited, so they pushed for things like worker visas to import Indians to work at lower costs (a win for globalization -- now a first-world programmer can compete with a second-world programmer on wages!). When governments limited worker visas, companies went after women because women are typically paid less than men. And when women didn't flock to call, they pushed it all the way down into primary school. However, the curricula I've seen use non-standard tools: there is no C++/C#/Java, just some made-up simple language like Scratch that has no place in business. But even if they did use standard tools, those tools would be out of date by the time the child graduated and was ready for work. In effect, the plans to grow the next generation of programmers will lead to the same conditions deplored today: no one graduating will have any experience using the tools employers will eventually require! Their master plans fix nothing!\n"], [10, ">The evidence points to a very obvious conclusion: there are two populations: one that finds programming a relatively painless and indeed enjoyable thing to learn and another that can\u2019t learn no matter how good the teaching\n\nI saw this personally in my first programming class in 1972 at UCSD\n\nI learned the material easily, and enjoyed it\n\nMost of the rest of the class struggled, failed and dropped out"], [9, "I was expecting some kind of empirical or statistical evidence for the claim that only a small part of the population has some kind of inherent ability to code, but nope, all I found was extremely flawed reasoning"], [6, "I'm by no means a great developer... I consider myself passable at best. Looking at my coworkers I've got to say, programming must be almost impossibly hard for a lot of people."], [5, "Let's all stroke our immense egos together"], [5, "Post is bullshit. Been programming since I was 14 and am now 21. It's more about the effort and the time you put in than your actual aptitude. I know a guy who sucked at programming and after a few courses he really started to recognize patterns. He worked his ass of to understand it; he is by no means super smart, just a hard worker. "], [2, "It is 2015... people actually still believe \"innate ability\" is a thing? Guys, two things contribute to making you good at something. Instruction and practice. *That's it.* That's all there has ever been. People who seem naturally gifted in a skill were just exposed to it earlier, encouraged in it more, or had better teachers. This creates a feedback loop -- when you excel at something, you get satisfaction from it, and when you enjoy something, you work harder at it; when you suck at something, you get discouraged, impatient, and resentful, and when you dislike something, you're unlikely to improve in it. This can be overcome. And, especially as we get older, we get scared of trying new things, scared of failure, and that fact alone guarantees that almost everyone who tries anything will soon give up and chalk it up to \"I just didn't have a knack for it\". This can also be overcome. The truth is that anyone who is willing to look past their own pride and put their shoulder to the plow can learn a new skill. *Any* new skill. You don't lack Aptitude, you just lack experience."], [3, "I`ve tried teaching mere mortals to code (gf, family, non tech-savy friends). First they get surprised by how complex software really is. Then they start to feel dumb and mentally handicapped no matter how patient I am. Then they get frustrated and angry. Final stage is when they give up and proceed to netflix and chill."]], [[{"comment": "Relevant comments from below the [original article](http://mikehadlow.blogspot.hu/2015/12/learn-to-code-its-harder-than-you-think.html), in my opinion:\n\n    This post is garbage. Conflating learning basic programming, which would help many people, with becoming a professional which programmer, which many people don't even want to do, is pointless. Saying that people don't have \"aptitude\" based on pass rates of awful introductory programming courses is awful. You're also conflating computer science, which is what universities teach, with programming, which they don't, really. This post is harmful to people who want to try something new but are having trouble. The other comment talking about \"aptitude\" for drawing hasn't seen what happens to art students who are properly instructed -- their work dramatically improves in a matter of days or weeks. We teach reading and writing even though most people will never become novelists. Programming is no different. Stop saying discouraging, stupid shit like this. -- Anonymous\n\nAnd, regarding the shoddy evidence provided for the argument:\n\n    The \"double hump\" study has been retracted. http://retractionwatch.com/2014/07/18/the-camel-doesnt-have-two-humps-programming-aptitude-test-canned-for-overzealous-conclusion/ -- Laurent Bossavit\n\nBoth sum up my thoughts on this pretty well. Lack of evidence, conflation of unrelated topics, false dichotomy, etc. Sure, I don't agree with saying \"_everyone_ should code\" or \"_everyone_ can code\", but that doesn't mean we shouldn't try to expose more people to a field that might interest them if they wouldn't otherwise be exposed to it...", "id": "cxrms4e"}, {"comment": "What people don't realize is that we don't need more coders. \nReading and writing are useful for comunication, not for writing novels.\nCoding is useful just for coding.\nMeanwhile we still eat  potatoes and we still need someone farming them.  \nReading help farmers, coding does not.   \nOne day farming will be fully automated and we'll need somebody capable of understanding how to operate and eventually fix the machinery, but only rarely it will require coding abilities.   \nCoding is just like being novelists, while the equivalent of writing and reading is being able to use some app...\n", "id": "cxsk9xn"}], [{"comment": "Paraphrasing the Pixar film *Ratatouille*: Anyone can code! This doesn't mean everyone can be a great programmer, but that a great programmer can come from anywhere.\n\nThe barrier to entry for programmers has never been lower. Given the existence of GC'd languages with lots of syntactic sugar, it is incredibly trivial to get a program working in short order. Hell, you can even code, compile and debug in a web browser!\n\nNo, the problem isn't finding programmers, it's *finding good programmers at a low price*. \n\nProgramming becomes hard is when it involves engineering skills -- the ability to understand the systems, technology, and the requirements well enough such that a single person can balance these criteria and make the necessary trade-offs to design a good architecture.  \n\nIn the software space, both the technology and the requirements change so rapidly that no one is able to develop that level of understanding, so they make terrible engineering choices that result in crappy software.\n\nThere are a few people who can do it, however: those people who have been around long enough to see the Big Wheel turn and recognize that the \"new hotness\" of this year is the same as the \"old and busted\" from ten years ago but with a new coat of paint. They've also dealt with changing requirements long enough that they can predict with utmost accuracy the unspoken and unknown requirements from business. The problem is that these are the guys who are too expensive, and businesses would rather have two or three shitty programmers pumping out crap software giving the *illusion of progress* than pay the salary of one programmer who actually knows something.\n\nTinfoil Hat Time: I've said this elsewhere, but I fully believe programmer shortage is made up -- it's a non-existent problem imagined by companies to drive employee costs down.  First it was discovered that programmers were cheaper in India, so companies outsourced. Then companies discovered that this didn't work because communication was the limited, so they pushed for things like worker visas to import Indians to work at lower costs (a win for globalization -- now a first-world programmer can compete with a second-world programmer on wages!). When governments limited worker visas, companies went after women because women are typically paid less than men. And when women didn't flock to call, they pushed it all the way down into primary school. However, the curricula I've seen use non-standard tools: there is no C++/C#/Java, just some made-up simple language like Scratch that has no place in business. But even if they did use standard tools, those tools would be out of date by the time the child graduated and was ready for work. In effect, the plans to grow the next generation of programmers will lead to the same conditions deplored today: no one graduating will have any experience using the tools employers will eventually require! Their master plans fix nothing!\n", "id": "cxro3cd"}], [{"comment": ">The evidence points to a very obvious conclusion: there are two populations: one that finds programming a relatively painless and indeed enjoyable thing to learn and another that can\u2019t learn no matter how good the teaching\n\nI saw this personally in my first programming class in 1972 at UCSD\n\nI learned the material easily, and enjoyed it\n\nMost of the rest of the class struggled, failed and dropped out", "id": "cxrndi2"}], [{"comment": "I was expecting some kind of empirical or statistical evidence for the claim that only a small part of the population has some kind of inherent ability to code, but nope, all I found was extremely flawed reasoning", "id": "cxrnq7c"}], [{"comment": "I'm by no means a great developer... I consider myself passable at best. Looking at my coworkers I've got to say, programming must be almost impossibly hard for a lot of people.", "id": "cxrm8cq"}], [{"comment": "Let's all stroke our immense egos together", "id": "cxrnxd9"}, {"comment": "It's not ego. It's relative strengths. I'm never going to be a nurse or fighter pilot. Not just because I haven't taken a \"how to care\" or \"how to fly\" class, but because I don't have any aptitude for doing the stuff that nurses and fighter pilots do every day. I'm OK with that.\n\nEven many of my coworkers have terrible debugging skills and they've been doing this for decades! It's apparently hard, even with practice.", "id": "cxroe2g"}], [{"comment": "Post is bullshit. Been programming since I was 14 and am now 21. It's more about the effort and the time you put in than your actual aptitude. I know a guy who sucked at programming and after a few courses he really started to recognize patterns. He worked his ass of to understand it; he is by no means super smart, just a hard worker. ", "id": "cxrqd4e"}], [{"comment": "It is 2015... people actually still believe \"innate ability\" is a thing? Guys, two things contribute to making you good at something. Instruction and practice. *That's it.* That's all there has ever been. People who seem naturally gifted in a skill were just exposed to it earlier, encouraged in it more, or had better teachers. This creates a feedback loop -- when you excel at something, you get satisfaction from it, and when you enjoy something, you work harder at it; when you suck at something, you get discouraged, impatient, and resentful, and when you dislike something, you're unlikely to improve in it. This can be overcome. And, especially as we get older, we get scared of trying new things, scared of failure, and that fact alone guarantees that almost everyone who tries anything will soon give up and chalk it up to \"I just didn't have a knack for it\". This can also be overcome. The truth is that anyone who is willing to look past their own pride and put their shoulder to the plow can learn a new skill. *Any* new skill. You don't lack Aptitude, you just lack experience.", "id": "cxrqgpo"}, {"comment": "False.   \nI've been exposed to free hand drawing all my life and still I can't do it properly.   \nI find coding easy because it suits my mental model.   \nBut there's more, drawing frustrates me while coding do not.  .A lot of people I know can code, but they don't want to.  That's the kind of attitude you need. My parents were both nurses, dad worked in oncology and my mom worked in infective diseases . Being a nurse is easy, wanting to work in oncology for 20 years or with HIV patients in the 80s that died and nobody knew why or getting tubercolosis  from one of them and still keep doing it, requires a certain aptitude, not everybody can do that.   \nSo yes, coding can be teached, but without the attitude it's just like maths, 90% of the students don't get maths even after 15 years of studying it at school.\n", "id": "cxskifc"}, {"comment": "[deleted]", "id": "cxste5a"}, {"comment": "I think there are two sides of the story.   \nMusic is a good example: one can become a great performer, but a terrible musician, or a great musician, but a terrible performer.     \nOf course it is most probable that you will end up somewhere in the middle of it.   \nProgramming can be seen as someone who code very well or someone who gets it.   \nSometimes the two parts are bound together in the same person, sometimes they are not.    \nBut at the end of the story coding is not easy, it is conceptually simple, but not easy.    ", "id": "cxsvvwa"}], [{"comment": "I`ve tried teaching mere mortals to code (gf, family, non tech-savy friends). First they get surprised by how complex software really is. Then they start to feel dumb and mentally handicapped no matter how patient I am. Then they get frustrated and angry. Final stage is when they give up and proceed to netflix and chill.", "id": "cxs716x"}]]], "3xk6zj": ["The Dangers of Super Smart Compilers", "2015-12-20 11:36:43", 0, "http://hacksoflife.blogspot.com/2015/12/the-dangers-of-super-smart-compilers.html", [[54, "The Dangers of Using Undefined Behavior Hacks in Your Code"], [37, "The compiler does not seem at fault at all here. This is the problem with optimizing around undefined behavior."], [23, "Bugs in compiler happens.\nHowever, you should not consider the compiler is at fault because the odds are much, much lower than the simple explanation : your code is bogus.\nWhich is the case here.\n\nYou can't just knowingly rely on UB and complain about it.\n\n> This one is also doing illegal undefined stuff (&* on a null ptr = bad) but Clang can\u2019t tell in advance that this is bad, so the optimizer doesn\u2019t hammer our code. Instead it shortens this to a pointer compare and we win.\n\nOh gosh.\n"], [15, "This _optimization_ has nothing to do with undefined behaviour. The language specification guarantees that `&whatever` cannot return a null pointer value, so `&whatever == NULL` is always false. And if `whatever` has no side-effect (`*ptr` has no side-effect in C++ for a pointer type) then you don't need to execute it at all. \n\nThis is like optimizing `whatever || true`: you can just drop `whatever` if it has no side-effects."], [3, "Replace this:\n\n    if(pts->buddy == NULL)\n\nWith this:\n\n    if(!pts->buddy)\n\nThe latter naturally works only when the \"handle\" has a meaningful bool operator or is otherwise convertable."], [2, "The whole point of a language having undefined behaviour (as opposed to just unspecified behaviour) is that it allows these kinds of optimizations. If you don't want the optimizations, don't use C++.\n\n"], [2, "Or just don't use C."], [1, "The smart pointers provided by STL have method get() which return the bare pointer. And as far as I understand it is legal for it to be null. So you'd better use the method instead of \"&*\""], [-10, "If the spec for the programming language has undefined behaviour then that spec is incomplete and shouldnt be relied on."]], [[{"comment": "The Dangers of Using Undefined Behavior Hacks in Your Code", "id": "cy5dc39"}], [{"comment": "The compiler does not seem at fault at all here. This is the problem with optimizing around undefined behavior.", "id": "cy5d7pp"}, {"comment": "Other than every other compiler in existence doesn't pull crap like this.\n", "id": "cy5dcze"}, {"comment": "That's not true - gcc does stuff like this too, just apparently not on exactly this example.  And I'd be very surprised if only gcc and clang did things like this. Frankly, `&*x` is a *really* nasty hack - it's not even that obvious that this works even at -O0, since it relies on the fact that `*x` isn't *actually* dereferenced, which is not guaranteed.  A truly \"stupid\" `-O0` implementation that really isn't optimizing might crash at runtime with a null pointer deref.", "id": "cy5dlmj"}, {"comment": "Actually the standard mandates that x and &*x are exactly equal even if x is the NULL pointer.", "id": "cy7o419"}, {"comment": "Then clang's behavior would be a bug. Do you have a citation for that claim?\n\nEdit: I was mistaken, this is a bit of a side track: x isn't a pointer, so whatever any standard says about `&*x` for null pointers isn't relevant.", "id": "cy7qomz"}, {"comment": "Somewhere in the standard. I'm going to look it up when I'm at home.", "id": "cy7rfku"}, {"comment": "See ISO 9899:2011 \u00a76.5.3.2 \u00b63:\n\n> The unary `&` operator yields the address of its operand. If the operand has type \u201c*type*\u201d, the result has type \u201cpointer to *type*\u201d. If the operand is the result of a unary `*` operator, neither that operator nor the `&` operator is evaluated and the result is as if both were omitted, except that the constraints on the operators still apply and the result is not an\nlvalue. Similarly, if the operand is the result of a `[]` operator, neither the `&` operator nor the unary `*` that is implied by the `[]` is evaluated and the result is as if the `&` operator were removed and the `[]` operator were changed to a `+` operator. Otherwise, the result is a pointer to the object or function designated by its operand.\n\nFootnote 102 affirms the behaviour regarding null pointers:\n\n> 102) Thus, `&*E` is equivalent to `E` (even if `E` is a null pointer), and `&(E1[E2])` to `((E1)+(E2))`. It is always true that if `E` is a function designator or an lvalue that is a valid operand of the unary `&` operator, `*&E` is a function designator or an lvalue equal to `E`. If `*P` is an lvalue and `T` is the name of an object pointer type, `*(T)P` is an lvalue that has a type compatible with that to which `T` points.\n>\n> Among the invalid values for dereferencing a pointer by the unary `*` operator are a null pointer, an address inappropriately aligned for the type of object pointed to, and the address of an object after the end of its lifetime.", "id": "cy8aec4"}, {"comment": "That's the C standard, not the C++ standard (the OP's code is clearly C++, dealing with smart pointers and templates).  C++ is not entirely backwards compatible, and it sounds like this may be an area where they differ; see comment: https://www.reddit.com/r/programming/comments/3xk6zj/the_dangers_of_super_smart_compilers/cy7k1fu\n\nBTW: super-thanks for the standard ref (even though it turns out there's something else going on) - it's great to learn new stuff like this :-).\n\nIn particular note that in the OP's `&*E` equivalent the real `E` isn't a pointer - it's a templated smart pointer, and `*E` is calling an overloaded operator, it's not the builtin pointer dereferencing operator.  Even if C++11 also includes the short-circuiting logic making `&*E` legal for pointers, it wouldn't apply to the OP's code.\n\nEdit: right, so a few seconds of googling suggest this is an iterator type for some CGAL datastructure, but I could find a definition online.  \n\nThe underlying real problem here is that the OP want's to compare with NULL in the first place.  Why is he comparing a smart pointer with a normal pointer?  It's not at all given that's even meaningful, which is why he needs these tricky hacks to access some implementation details which look like they might be changed by CGAL on a whim (e.g. an empty or past-the-end iterator might be represented as null, but it might be represented differently too).\n", "id": "cy8bd7v"}, {"comment": "Oh, I didn't know this was about C++. Well, whatever, one more reason not to program in C++.\n\nSimple resolution: Don't program in C++. The language is too complex to reason about.", "id": "cy8bmig"}, {"comment": "In fairness: what the guy is trying to do is just weird.  I mean, C++ is complex and all, but why go around implementing hacks that allow templated data structures to be compared with NULL?  Kind of the whole point about smart pointers is that they abstract away underlying pointers to the extent that there might not even be an underlying pointer.  It's just a data structure, not a pointer at all - it might be an index in an array, for instance, or a counter, or a argument for a function.\n\nIt's sort of like getting a `void*` from some library in C, and then going meddling around in memory whereever that happens to point to, and then being surprised when a few upgrades later it turns out that the library has changed its internals, and your code breaks.  You can't do it accidentally either, he needed to manually code that `==` operator - C++ won't convert between smart pointers and naked pointers implicitly.", "id": "cy8c96d"}, {"comment": "You're funny, because you don't realize that on a bunch of non 0x86 architectures attempting to access memory location zero doesn't produce a seg fault. Its totally legal. So the optimizer is assuming things about the architecture that may or may not be true, and then failing to compile code based on that. \n\nIt's a bug. Sure it's willful on the part of the Clang developers, but it's bug.\n", "id": "cy5e3re"}, {"comment": "> So the optimizer is assuming things about the architecture that may or may not be true\n\nOf course it is, it's the whole point of an optimizer. That's why you specify target architecture to the compiler, for it to be able to enable architecture-specific instruction sets (SSE, MMX, ...) and other optimizations.\n\nMoreover, the problem here is the code using undefined behaviour, the optimizer just putting that in the light.", "id": "cy5eo0h"}, {"comment": "No the Clang optimizer is silently discarding code with no warnings at all. I've talked to various people about this and the responses fall into three camps.\n\n1. Academics that don't deal with code in the wild who think programming as a form of mathematics.\n2. Professional programmers that use C/C++ who think this is terrible.\n3. Programmers that have only used languages like Java, PHP and JS who think it's perfectly okay.\n", "id": "cy5fcae"}, {"comment": "What people say is totally irrelevant. What _is_ relevant is the C++ standard. The C++ standard states that this is undefined behaviour, so the compiler can do whatever it wishes to. Period.", "id": "cy5gvfq"}, {"comment": "Perhaps the people that maintain the C++ standard should fix this loophole because it's dangerous.\n", "id": "cy5wta3"}, {"comment": "Perhaps we should fix the highways because running blinded on them is dangerous.", "id": "cy5xt8y"}, {"comment": "It's pretty obvious that you don't actually use C++ or C so why do you care about this?\n", "id": "cy605u5"}, {"comment": "Perhaps you should ask them?\n\nAnd it's not a loophole, it's intended.", "id": "cy82eqc"}, {"comment": "The language standard enables these optimizations. If you do not want compilers to perform these optimizations, go ask the relevant standard committees to change the standard.", "id": "cy5gacj"}, {"comment": ">2. Professional programmers that use C/C++ who think this is terrible.\n\nThat hurts my opinion of C/C++ programmers more than it helps your argument.", "id": "cy5h8ne"}, {"comment": "Professional programmers who rely on undefined behavior shouldn't call themselves professionals.", "id": "cy64cr9"}, {"comment": "Okay what does this do? Please answer.\n\n    uint32_t *ptr = (uint32_t *) 0x40064000;\n    *ptr |= 0x1;\n\nNote this isn't defined at all by the standard. Maybe the optimizer should just fail to compile it without a warning? Why yes this absolutely the correct course of action.\n\nProblem is it's getting harder or impossible to trust the compiler will produce the required side effects. Because of optimizations of dubious utility. Especially future compilers. Currently for this is huge problem for people doing cryptographic work.  Want to clear a section of memory so that data doesn't leak? Why yes the compiler will helpfully and silently discard that code. Want to check if it works? The compiler will silently and helpfully not discard that code.\n\nSeriously if you want a language where side effects are verboten by design, there are languages like Java for that.\n", "id": "cy67k1b"}, {"comment": "Maybe you should make a dumb compiler that will do no optimizations if that is what you want.", "id": "cy6v11n"}, {"comment": "The fundamental point is not everyone cases about speed at the expensive of programming safety especially in a language like C++/C. There is also a question whether these sorts of optimizations will continue to be relevant on modern high performance processors.\n\n", "id": "cy7142e"}, {"comment": ">So the optimizer is assuming things about the architecture that may or may not be true\n\nNo it isn't. It's a C++ compiler compiling C++, and C++ defines that deferencing a NULL pointer is **always** illegal. ", "id": "cy5wdyj"}, {"comment": "This has nothing to do with address 0 being protected. (The optimization does not care)\n\nIt is in fact very lucky that addr 0 is protected exactly because of code like this. This could have been a memory corruption vulnerability but instead it was downgraded to segfault.", "id": "cy61hct"}, {"comment": "And on such architectures, address 0 and NULL might be different values. Or if NULL does have the value 0, then conformant C programs are not allowed to access address 0. Or it might be allowed as an implementation extension.\n\nEven if address 0 is allowed, and equal to NULL, it might be treated as NULL in some contexts, and a valid address in others! The optimizer would be allowed to assume `*(int*)NULL` never executes, but `*reinterpret_cast<int*>(0)` would be okay (with the pointer->integer conversion being defined by the implementation of course).", "id": "cy82ani"}, {"comment": "You know how NULL is defined?\n\n    #define NULL ( (void *) 0)\n", "id": "cy84u2e"}, {"comment": "Is that the definition of NULL according to the language standard, or according to your implementation?", "id": "cy8nhg2"}, {"comment": "Standard\n", "id": "cy8nvnx"}, {"comment": "Except it might do it in the future... When you rely on undefined behaviour you can't complain when it breaks at some point in the future.", "id": "cy5dl9r"}, {"comment": "Which you can't rely on at all.", "id": "cy5detc"}, {"comment": "https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633", "id": "cy673hl"}], [{"comment": "Bugs in compiler happens.\nHowever, you should not consider the compiler is at fault because the odds are much, much lower than the simple explanation : your code is bogus.\nWhich is the case here.\n\nYou can't just knowingly rely on UB and complain about it.\n\n> This one is also doing illegal undefined stuff (&* on a null ptr = bad) but Clang can\u2019t tell in advance that this is bad, so the optimizer doesn\u2019t hammer our code. Instead it shortens this to a pointer compare and we win.\n\nOh gosh.\n", "id": "cy5dt18"}], [{"comment": "This _optimization_ has nothing to do with undefined behaviour. The language specification guarantees that `&whatever` cannot return a null pointer value, so `&whatever == NULL` is always false. And if `whatever` has no side-effect (`*ptr` has no side-effect in C++ for a pointer type) then you don't need to execute it at all. \n\nThis is like optimizing `whatever || true`: you can just drop `whatever` if it has no side-effects.", "id": "cy5eebf"}, {"comment": "> `&whatever == NULL` is always false\n\nIs that really the case? At least in C, `&*p == NULL` is well-defined and always true when `p == NULL`.\n\n", "id": "cy5g7uf"}, {"comment": "Is that really true? Isn't dereferencing a null pointer in C undefined behavior, making that expression not well defined?", "id": "cy5gdf0"}, {"comment": "Yes, the dereferencing never happens. The relevant quotes from the [standard](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf):\n\n6.5.3.2 Unary arithmetic operators, Semantics, paragraph 3:\n\n> The unary `&` operator yields the address of its operand. [...] If the operand is the result of a unary `*` operator, neither that operator nor the & operator is evaluated and the result is as if both were omitted, except that the constraints on the operators still apply and the result is not an lvalue.\n\nand footnote 102:\n\n>  Thus, `&*E` is equivalent to `E` (even if `E` is a null pointer) [...]", "id": "cy5gi1t"}, {"comment": "Interesting. ", "id": "cy5hnie"}, {"comment": "What does \"except that the constraints on the operators still apply\" mean then? I would have though one of the constraints on the dereference operator is that the pointer cannot be null, but the footnote seems to negate this.\n\nWell, almost. The same footnote also says \"Among the invalid values for dereferencing a pointer by the unary * operator are a null pointer,..\" It sounds like it is saying that it is invalid to have `&*nullptr` (because it is invalid to have `*nullptr`), but the expression will produce `nullptr` anyway. Seems like a weird loophole that would be better closed and just called undefined. The [C++ standard](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf) fixes this by omitting the &* NOP wording and related footnote (see 5.3.1 for the equivalent section).", "id": "cy8snk3"}, {"comment": "But C has no overloaded functions and operators, which are the reason why I can't imagine that this would be the case in C++ too.", "id": "cy61bbc"}, {"comment": "Yep, operator overloading is at fault here. It appears that it is [legal in C++ for raw pointers](http://stackoverflow.com/a/7928897), but I'm assuming we have something like\n\n    T& operator*() { return *m_ptr; }\n\nIn this case, the undefined behavior happens because we've created a reference to NULL. That we later apply `&` to it doesn't matter, because the damage has already been done.\n\nThe line `&*rhs == NULL` doesn't invoke undefined behavior per se, but the function call `rhs.operator*()` does.\n\n*Edit: syntax*", "id": "cy7k1fu"}, {"comment": "What if rhs is a non-NULL pointer to an object with a NULL m_ptr member?", "id": "cy82hu2"}, {"comment": "`rhs` is a (reference to a) smart pointer, so it is always non-NULL.\n\nThat is a typo in my post - I originally had `this->operator*` but forgot to change the arrow to a dot when I changed this to rhs.", "id": "cy83gil"}, {"comment": "Thanks for putting it in perspective. I was looking at the code and thinking how it made any sense to compare the result of & with NULL.", "id": "cy5fgix"}, {"comment": "please explain this to klocwork!", "id": "cy67534"}], [{"comment": "Replace this:\n\n    if(pts->buddy == NULL)\n\nWith this:\n\n    if(!pts->buddy)\n\nThe latter naturally works only when the \"handle\" has a meaningful bool operator or is otherwise convertable.", "id": "cy5jmtx"}, {"comment": "the bool operator might have the very same implementation, with same issue", "id": "cy6euhc"}, {"comment": "While possible, the impl. of the \"handle\" seems weird. Even the simplest managed ptrs typically have a well-functioning bool op, e.g. std::auto_ptr. Maybe I'm missing something from the original problem - it's difficult to debate without seeing the implementation of buddy's type.", "id": "cy6fp6q"}], [{"comment": "The whole point of a language having undefined behaviour (as opposed to just unspecified behaviour) is that it allows these kinds of optimizations. If you don't want the optimizations, don't use C++.\n\n", "id": "cy5lbas"}], [{"comment": "Or just don't use C.", "id": "cy6t4tr"}], [{"comment": "The smart pointers provided by STL have method get() which return the bare pointer. And as far as I understand it is legal for it to be null. So you'd better use the method instead of \"&*\"", "id": "cy6evnn"}], [{"comment": "If the spec for the programming language has undefined behaviour then that spec is incomplete and shouldnt be relied on.", "id": "cy5gqj5"}, {"comment": "[deleted]", "id": "cy5ibxf"}, {"comment": "> UB is in the spec because to define the behavior of some things forces the runtime to have checks in it. For instance, accessing memory outside the bounds of an array. Different systems react to this differently.\n\nThat merely requires implementation-defined behaviour, FWIW, which tends to be a lot less \"scary\".", "id": "cy5l8xu"}, {"comment": "What if the implementation defined the behaviour to be \"unpredictable things will happen; don't do this\"?", "id": "cy82lkq"}, {"comment": "Counter-intuitively, that's *still* better than undefined behaviour, since it talks about future behaviours. Undefined behaviour can time-travel.\n\nConsider a program which printed \"About to invoke undefined behaviour!!\", slept for a minute and dereferenced null.\n\n* If a null dereference is defined but \"unpredictable\", the warning must at least show in time for you to burn the computer down.\n\n* If a null dereference is undefined behaviour, the program is *not valid C*, so the compiled program need not print anything at all. It can start hacking NASA before you've even had a chance to reach for the propane.", "id": "cy842n4"}, {"comment": "It's worse than that; because C and C++ are designed to run on almost-literally anything, the Standard can make no assumptions about the hardware or the operating system. The only way to have a meaningful cross-platform language standard without undefined or unspecified behavior is to define a single standard platform and have every non-standard system emulate it. All languages do this to a point; in C and C++, that point is just well within the intersection of most systems.", "id": "cy5m4q4"}, {"comment": "What's your favourite language?\n\nEven things like Java have undefined behaviour, although not in the language itself - for example, whether adding an item to a List updates subList views of that list.", "id": "cy82mwn"}]]], "4uw4qz": ["The Churn (Uncle Bob) - Clean Coder Blog", "2016-07-27 22:30:20", 0, "http://blog.cleancoder.com/uncle-bob/2016/07/27/TheChurn.html", [[6, "i suspect this conversation never happened. "], [5, "He does have a point. Each paradigm and language is a tool. For the most part you can achieve anything in any programming paradigm and in most languages. Some languages are better suited to some problems than others.\n\nIf we invest in a handful of things that solve our problems, instead of creating thousands of different things that all have minimal investment, those few things can be improved and built around to increase productivity immensely.\n\nHowever, the other talker does have some points of their own, mainly, if people are experimenting and creating new things we wont move forward if there is something there to still be \"discovered\" that can revolutionize things.\n\nI suspect the correct ground to take between these sides, is probably somewhere in the middle."], [2, "I dislike the attitude. First of all, I've never heard any credible people saying \"OO is dead\" like they mean it. Second, while I agree developers should not blindly chase the \"new shiny\", but that mean new tooling doesn't have its place. Bear in mind, 5 years ago, Clojure would considered this \"new shiny\" and 10 years ago, Ruby, both languages heavily favoured by uncle Bob himself. Turning back 20 years, Java was the \"new shiny\" on the block when C++ worked just fine... if everyone has this attitude, there won't be Java, Ruby, or Clojure... all of which uncle Bob loved...\n\nI don't agree with the attitude of this article..."], [1, "This is coming from a person who wrote that we should be spending our 20 hours a week learning new languages.\n\nLearning new languages (saw sharpening) with no intent of using them (chasing shiny new) would be to me a cognitive dissonance. "]], [[{"comment": "i suspect this conversation never happened. ", "id": "d5tchxn"}, {"comment": "Yep. Me too.\n\nI don't know why Uncle Bob writes that way. I actually *really* dislike it. Mostly, I posted the link here to see what other people think about it.", "id": "d5td9re"}, {"comment": "I found it quite pertinent, was even going to guild the poster :)\n\nit's especially relevant if you've spent any time in JS land.", "id": "d5u09uh"}, {"comment": "What does \"guild\" mean in that context?", "id": "d5u0wgr"}, {"comment": "sorry, meant gild, as in give gold.", "id": "d5u17o4"}, {"comment": "I see. I've heard some of this gold thing here on reddit, but tbh I also don't know what it is. I'll look it up.", "id": "d5u1hn5"}], [{"comment": "He does have a point. Each paradigm and language is a tool. For the most part you can achieve anything in any programming paradigm and in most languages. Some languages are better suited to some problems than others.\n\nIf we invest in a handful of things that solve our problems, instead of creating thousands of different things that all have minimal investment, those few things can be improved and built around to increase productivity immensely.\n\nHowever, the other talker does have some points of their own, mainly, if people are experimenting and creating new things we wont move forward if there is something there to still be \"discovered\" that can revolutionize things.\n\nI suspect the correct ground to take between these sides, is probably somewhere in the middle.", "id": "d5tfnjm"}, {"comment": "Maybe, in a sense, what he's saying is a reiteration of the \"no silver bullet\" statement by Fred Brooks.", "id": "d5tfz70"}], [{"comment": "I dislike the attitude. First of all, I've never heard any credible people saying \"OO is dead\" like they mean it. Second, while I agree developers should not blindly chase the \"new shiny\", but that mean new tooling doesn't have its place. Bear in mind, 5 years ago, Clojure would considered this \"new shiny\" and 10 years ago, Ruby, both languages heavily favoured by uncle Bob himself. Turning back 20 years, Java was the \"new shiny\" on the block when C++ worked just fine... if everyone has this attitude, there won't be Java, Ruby, or Clojure... all of which uncle Bob loved...\n\nI don't agree with the attitude of this article...", "id": "d69rb80"}], [{"comment": "This is coming from a person who wrote that we should be spending our 20 hours a week learning new languages.\n\nLearning new languages (saw sharpening) with no intent of using them (chasing shiny new) would be to me a cognitive dissonance. ", "id": "d5tmv9o"}]]], "4cok3j": ["TIL Windows has a POSIX compliant Unix subsystem", "2016-03-31 08:40:57", 0, "https://en.wikipedia.org/wiki/Interix", [[22, "Had."], [7, "It was pretty much there only to satisfy the (really poorly thought out) requirements on certain government contracts. \n\nAnd as others have pointed out \"was\" is the operative word here."], [6, "In other news, Microsoft once upon a time had the most widely distributed flavor of unix. [Xenix](http://www.softpanorama.org/People/Torvalds/Finland_period/xenix_microsoft_shortlived_love_affair_with_unix.shtml)"], [1, "And spoiler alert it sucks"], [1, "And they were big investors in SCO and their linux lawsuits.\n\nDon't forget, people..."]], [[{"comment": "Had.", "id": "d1k3ozs"}, {"comment": "They also had a UNIX distribution called Xenix. Microsoft is no stranger to Unix.", "id": "d1k4dm5"}, {"comment": "No, they're not. But the POSIX subsystem was fairly useless, much like IE on Solaris.", "id": "d1k4fra"}, {"comment": "Such a monstrosity existed?!", "id": "d1k5vhd"}, {"comment": "Yes. I used it around 2001. It was a thing. It was even useful, if you wanted to do online banking or so.", "id": "d1kauiu"}, {"comment": "Now they have native ubuntu bash with most of its utilities in Windows 10.", "id": "d1k5oj9"}, {"comment": "Yep. By the time I learned about it, I had already upgraded to Windows 8.1 which had removed it as an option.", "id": "d1k7bun"}], [{"comment": "It was pretty much there only to satisfy the (really poorly thought out) requirements on certain government contracts. \n\nAnd as others have pointed out \"was\" is the operative word here.", "id": "d1k5wro"}], [{"comment": "In other news, Microsoft once upon a time had the most widely distributed flavor of unix. [Xenix](http://www.softpanorama.org/People/Torvalds/Finland_period/xenix_microsoft_shortlived_love_affair_with_unix.shtml)", "id": "d1k4ecm"}], [{"comment": "And spoiler alert it sucks", "id": "d1k4wh7"}], [{"comment": "And they were big investors in SCO and their linux lawsuits.\n\nDon't forget, people...", "id": "d1kly2s"}, {"comment": "It's true, and they backed the BSA.  But... that era is over.  You can harbor blood blood over that if you like, but those times are gone and those players have moved on.", "id": "d1lf7hy"}]]], "4aulqi": ["Being a Female Developer", "2016-03-17 23:06:06", 91, "https://medium.com/art-marketing/being-a-female-developer-6f0dd6692598#.cwbkminuz", [[144, "> and getting equal respect and consideration, just as any other person on the team\n\nThis isn't something that happens enough even among just men, but I agree with her point.\n\n-edit-\n\nThe site this is on...if you do [this](http://imgur.com/O3kWe6R) with your site, then you deserve to get fucked with a bronzed pineapple. Seriously, I can't be the only person who highlights while reading and has a blinding hatred of sites that make highlighting equivalent to an ad click through.\n\n-follow up-\n\nI was highlighting when reading and accidentally  hit the highlighting button that shows up when you have text highlighted. I mistook an actual feature for a rage inducing pop-up."], [94, "> after all, diversifying the tech workforce can only benefit the industry at large.\n\nThis is an argument I have never understood. Sure, we can all agree that discrimination is bad: not hiring someone because of their race or gender is a shitty thing to do. But I don't get why people go around acting as if diversity is an inherent good.\n\nLack of discrimination does not necessarily mean great diversity."], [89, ">your skills will speak louder than your gender\n\nthis"], [69, "> Overall, to become a female developer, you only have to do what any other smart dev would do. Spend weekends and late nights in front of your computer, laying down lines of code, debugging and developing your personal projects.\n\nGood advice for any engineer: commit to your craft, but remember to maintain work-life balance. The rest of it is just a distraction."], [48, "my attitude is and has always been; man or woman if you're competent I'll respect you."], [23, "Excepted some retarded \"outreach\" type of shit, but this is actually very reasonable.\n\nAnd while your skills will indeed speak louder than your gender. Let's be honest, if skill is comparatible then other things start to become a factor. While no one will hire a shitty man over an excellent woman. If the skills are comparable in _most_ places the man will get hired, however in others they do the opposite as some kind of counter-balance and that exists as well. So while skills do speak louder, it's sadly still a factor. Amongst many, many, many things. People act like gender and race are only disadvantaging factors but I like how everyone in white collar work speaks with some prestige-accent. It's works against you a lot if you have a \"lower class accent\", no matter how smart you are, people will assume you are simpleton and uneducated until proven otherwise if you have certain accents."], [21, "Expected feminist bragging, did not find it. Nice!"], [21, "why are all girls recently writing about this Ruby developers... "], [7, "I'm jealous I'm not a woman in that I don't get to have that experience as a man. So, I judge them as \"less\" to make myself feel \"more\". So far, every woman programmer I've seen has been okay to good, but not great or amazing. If I ran into an amazing female programmer, I'd probably secretly feel angst towards her or jealousy and possibly try to undermine her. \n\nI'm trying to get rid of this shit by writing it out, I know it's bullshit, but it's what is bouncing around in my head. "], [3, "That's a pretty nice article."], [1, "Great attitude!"], [0, "> To every aspiring female developer out there\n\nI get a little saddened every time I see something like this. If you wish for equality, make equality. Say \"To EVERYBODY....\""], [0, "Of course the comments here are arguing against diversity and also claiming that obviously they only care about competence, somehow conflating that as meaning the industry only cares about that.  Keep it up reddit!"], [-1, "Is it just me or does it matter? I don't care if you're female etc. What I care about is the quality of your work. Why do you feel the need to embasis your gender and make it an issue here? It's not an issue unless you make it one"], [-3, ">  I live and breathe code.\n\nThank god I am not a programmer.\n\nIf I'd live and breathe code, I'd seriously wonder what would be wrong with my mind.\n\nCode is just a tool. It's like driving a car. Cutting some wood. If it is beautiful then it can be poetry.\n\nBut breathing? Living? Oh my god ..."], [-3, "I just want to raise a big red flag and spoil the truth : there is no equality in this world, every man is different in many aspects, including gender inequality. ALL the time when someone tries to talk about any kind of equality, its actually about doing the oposite thing - they want to become hunters from beeing hunted, not to be equal. Imagine what would happen if women were to be naturally blamed for every rape, no matter the situation. Also, this world is corrupted from the ground to the skies, and every bad thing is tied up together, so it makes little sense to just bring up one piece of puzzle out of millions. If you really want to fix anything, you have to burn this world to the ground and build a new one, nothing else will help you, ever."]], [[{"comment": "> and getting equal respect and consideration, just as any other person on the team\n\nThis isn't something that happens enough even among just men, but I agree with her point.\n\n-edit-\n\nThe site this is on...if you do [this](http://imgur.com/O3kWe6R) with your site, then you deserve to get fucked with a bronzed pineapple. Seriously, I can't be the only person who highlights while reading and has a blinding hatred of sites that make highlighting equivalent to an ad click through.\n\n-follow up-\n\nI was highlighting when reading and accidentally  hit the highlighting button that shows up when you have text highlighted. I mistook an actual feature for a rage inducing pop-up.", "id": "d13p2ue"}, {"comment": "I have that \"highlight while reading\" habit too. It's so annoying when they go full retard and change the default browser behaviour.", "id": "d13rkiz"}, {"comment": "I wonder why browsers allow it?", "id": "d13swep"}, {"comment": "Well I've stolen right click's normal ability when doing a full webpage webgl in order to have right click manipulate the webgl in the ways that I want. Just because things can be used maliciously doesn't mean it was intended for that purpose.\n\nNot sure how I'd use the highlight event though since I don't know how it's used. [But it sounds like some people do](https://www.reddit.com/r/programming/comments/4aulqi/being_a_female_developer/d13x331)", "id": "d13yjjz"}, {"comment": "A few years back we developed an application for seniors with bad eye-sight. The application was a modified chrome browser that wrote everything that was highlighted into a text file. Meanwhile a C# service was listening for changes to that text file and made Microsoft Anna read it when text was added.", "id": "d14cmpw"}, {"comment": "This reads like the xkcd spacebar heating thing", "id": "d14bt68"}, {"comment": "I don't know, I think it's more like a UX thing. For example, sites that hijack scrolling or immediatly show you a \"Susbcribe\" pop up, it's just bad UX, not necessarily the browser's fault :p", "id": "d13x8g6"}, {"comment": "I've seen ones that hijack scrolling just to make it scroll slower...", "id": "d13xswg"}, {"comment": "I really like that evil idea.", "id": "d159ban"}, {"comment": "Well, sometimes people want to highlight text to copy to the clipboard.", "id": "d13yzda"}, {"comment": "Allow what?  \nHow would you prevent it?", "id": "d13v8gz"}, {"comment": "> Allow what?\n\nHijacking the highlight functionality.\n\n> How would you prevent it?\n\nBy not implementing a way to treat the event as an actionable event, i.e. not provide info to the website when a user highlights something.", "id": "d13vjk8"}, {"comment": "So not provide info when you click, drag and release? Could break stuff, ie. Google maps panning..", "id": "d13x331"}, {"comment": "You should be able to do it on a site-by-site basis. Kinda like how you control when websites read your location or go fullscreen.", "id": "d145ig5"}, {"comment": "Or everything with drag and drop. Or every slider. \n\n", "id": "d141fvj"}, {"comment": "NoScript does a good job of blocking it.", "id": "d141rm2"}, {"comment": "The New York Times changes the size of text when you try to highlight with double clicking, so obnoxious", "id": "d1494ir"}, {"comment": "One of the things I hate the most is when they show a laggy tooltip over the selection with a bunch of share buttons.", "id": "d14af31"}, {"comment": "Guys and ladies... they only do this when you try to save a highlight with a popup button. See http://imgur.com/yn6MPOH", "id": "d14gch8"}, {"comment": "I highlight while reading and just tested it out again, I did not have that pop up. Either this doesn't happen on firefox, on linux, with ublock origin, or with noscript.", "id": "d13u6pc"}, {"comment": "It seems to only happens with double/triple click but not with click and drag", "id": "d13v85j"}, {"comment": "oh I see what you mean. I have never tried highlighting in that fashion before. Just good old fashion click and drag.", "id": "d13van3"}, {"comment": "It's great for precisely selecting a word or a paragraph which is what I want most of the time.", "id": "d13x88p"}, {"comment": "Yeah, I'm not seeing this regardless of what I try. I can highlight things just fine with and without adblock, on chrome and firefox.", "id": "d13yfud"}, {"comment": "Highlighting as in simply click-drag-selecting??", "id": "d13rhj7"}, {"comment": "Yeah, people highlight to focus thier attention on the bit they're reading. A lot of people do it, it's a habit formed when trying to process difficult concepts and it infects normal reading.", "id": "d140aj3"}, {"comment": "Yeah it's a common habit, at least on laptop/desktop.", "id": "d13ujmd"}, {"comment": "I didnt know that other people have that highlight-while-reading habit.\n\nMy family and friends get mad at me when I'm on the computer because of it :P", "id": "d13z4rg"}, {"comment": "The ones that makes me crazy are when they hijack the back button, or on mobile when they disable zoom.", "id": "d13v3kh"}, {"comment": "> The site this is on...if you do this  with your site, then you deserve to get fucked with a bronzed pineapple.\n\nMaybe a little annoying, but only because Medium lets you leave comments on arbitrary sentences/paragraphs (which you highlight), and it doesn't make sense to allow non-members to leave comments. They could probably come up with a better way of handling regular highlighting though.", "id": "d13w02e"}, {"comment": "then they should ask for it when user actually leaves the comment, not while selecting", "id": "d147ej9"}, {"comment": "That would be even more annoying. \"Hey, I just finished typing in 200 words. Time to save. Wait, I have to register. Shit, that was a waste of time.\"", "id": "d14glkn"}, {"comment": "Between selecting and typing there is a step, which opens the text entry to type. Here is good moment. Also, what's annoying in having to register if you are actually leaving the comment? Of course, it should be able to keep the comment text though registration.\n\nPS: that's pointless actually. Obviously they don't really care that much about case of leaving the comment, they just want \"active users\" figure to wave it to investors.", "id": "d15g67m"}, {"comment": "I have this same habit and I hate it when sites mess with it. There's a Firefox extension called right to click which helps on some sites, there is probably something equivalent for Chrome too.", "id": "d13uj2p"}, {"comment": "You can also disable javascript in your browser once the page has loaded. Most browsers have this option hidden behind a *Careful, developer dangerous stuff ahead* setting, but hopefully that's not a problem in this forum. Bind the option to a keyboard shortcut and you only need one keystroke to make the web what it always should have stayed as. If something needs js keystroke, click, keystroke again.\n\nI'm surprised the solution to anything is to bring in even more bloat through additional software.", "id": "d13xieg"}, {"comment": "Did they change it? With Chrome 49 on Win7 I only get [this](http://imgur.com/vJIJb6w).", "id": "d14ashx"}, {"comment": "Yeah, me too. I was confused what OP is talking about.", "id": "d14dkst"}, {"comment": "I posted an edit to my comment above.", "id": "d14ihw1"}, {"comment": "Well medium.com is awful but cant you just `C-a` to select all ?", "id": "d13xrw8"}, {"comment": "It's about highlighting the line you are currently reading so you don't lose your place in the sea of white.", "id": "d14dwiu"}, {"comment": "you can triple click to select whole paragraph", "id": "d14e2i6"}, {"comment": "[deleted]", "id": "d14am60"}, {"comment": "That's less cruel.", "id": "d14b5pt"}], [{"comment": "> after all, diversifying the tech workforce can only benefit the industry at large.\n\nThis is an argument I have never understood. Sure, we can all agree that discrimination is bad: not hiring someone because of their race or gender is a shitty thing to do. But I don't get why people go around acting as if diversity is an inherent good.\n\nLack of discrimination does not necessarily mean great diversity.", "id": "d143opy"}, {"comment": "When the people involved in a project have different life experiences, you are more likely to get different points of view and more ideas to choose from to include in the end product.", "id": "d1452od"}, {"comment": "Implicitly, this conflates racial/gender diversity with life experience diversity. \n", "id": "d1476lk"}, {"comment": "Isn't it true at least for genders? It's hard to deny that women and men have (usually) different life experiences. ", "id": "d14dncm"}, {"comment": "But they are, in this situation, both developers. They'll have a bunch of stuff in common ; technically minded, age, income levels, education.  It isn't real diversity that you'd get from a random sample of the population, or typical of your customers or end users. You're simply hiring a geek that uses a different bathroom.", "id": "d14eknp"}, {"comment": "> They'll have a bunch of stuff in common ; technically minded, age, income levels, education. \n\nYes, there are some commonalities (like you mentioned: technically minded, age, income levels, education), but there are also significant differences (do I really have to argue that women are different in some things from men?).\n\n> It isn't real diversity that you'd get from a random sample of the population, or typical of your customers or end users.\n\nWhat's a real diversity then? Do I need to hire uneducated criminal to have real diversity? No thanks. Still, if my goal is to have some diversity in the team, I'd like to have some women there instead of men-only team.\n\n> You're simply hiring a geek that uses a different bathroom.\n\nThat's just oversimplification ad absurdum. Also, notion that developers are geeks is mostly a myth. ", "id": "d14euyf"}, {"comment": "> do I really have to argue that women are different in some things from men\n\nThat depends, do you want to defend gender essentialism?\n\nUnless you're making a health or fitness or app, or something that directly relates to women's issues, you're not going to get a magic diversity insight hiring female developers.\n\nReally, this argument becomes absurd when you consider the actual blind spots when it comes to programmers and usability for the people who use their software. \n\nIf hiring people let us achieve these insights, we'd need to hire physically disabled developers, developers with an average or even below average intelligence, developers who are very old, developers who are very young, developers who don't speak English, developers who know almost nothing about how computers work, etc.\n\nIt is better to understand people's needs than to meet diversity quotas.", "id": "d14gnwm"}, {"comment": "> That depends, do you want to defend gender essentialism?\n\nNo, that's far too theoretical for my needs. In my experience, most women (and female developers) are somewhat different from most men (male developers). I think my experience is far from unique.\n\n> Unless you're making a health or fitness or app, or something that directly relates to women's issues, you're not going to get a magic diversity insight hiring female developers.\n\n> Really, this argument becomes absurd when you consider the actual blind spots when it comes to programmers and usability for the people who use their software. \n\nThat's far too narrow view focused only on the final product. You must count in the process of making the said product. Women can have different ideas how to work in a team, organize work, mediate conflicts etc. There could be much more which we simply don't see.\n\n> If hiring people let us achieve these insights, we'd need to hire physically disabled developers, developers with an average or even below average intelligence, developers who are very old, developers who are very young, developers who don't speak English, developers who know almost nothing about how computers work, etc.\n\nMost of these are extreme cases. Of course, diversity often has an associated cost - you can hire developer who doesn't speak English. It might bring some benefit, but the cost is probably much higher than the benefit. Hiring woman into the male-majority team has very small cost, benefit is potentially quite a bit larger. \n\nBTW, I think that women-men diversity is quite special because here it's not only about diversity itself but also about all the gender dynamics at play. I'm not really sold on e.g. racial diversity, race itself seems of little importance. Cultural diversity is more interesting, but there the costs are quite large and might easily offset the benefits.", "id": "d14hsoz"}, {"comment": "> Most of these are extreme cases.\n\nNo, these are common cases. Calling them extreme betrays your own biases. Heck, by definition, half of all people are below average intelligence. Don't assume they're not using your software.\n\nOf my examples, only physical disability has little bearing on their capacity for being successful developers. For the rest, we have no choice but to try to imagine what it is like to be our users.\n\nGender and race... both mean fuck all to software. Discrimination is a societal problem being scapegoated onto our field because we have money they don't think we deserve and the gender imbalance and reputation for poor social skills make us easy targets.", "id": "d14irea"}, {"comment": "> No, these are common cases.\n\n* 10 year old and 90 year old developers are not common (in companies). \n* Developer who doesn't speak english (if the team doesn't speak his language) is not common\n* Developer with below average intelligence is not common\n* Developer who knows knothing about computers is not common\n\n> For the rest, we have no choice but to try to imagine what it is like to be our users.\n\nYou probably didn't notice yet, but I'm not talking about any users. I'm talking about development process, team dynamics etc.\n\n> Discrimination is a societal problem being scapegoated onto our field because we have money they don't think we deserve\n\nI don't talk about any discrimination. I just think that having teams with some female developers is better than having male-only teams.", "id": "d14jvwo"}, {"comment": "> do I really have to argue that women are different in some things from men\n\nNot if you believe in true equality.", "id": "d14nnwz"}, {"comment": "So women and men are truly equal only if they are identical (no differences)? ", "id": "d14nw5b"}, {"comment": "It's just that you seem to be advocating for \"separate but equal\". Yet for very good reasons that argument hasn't worked in the past.", "id": "d14ooog"}, {"comment": "It's different (not separate) but equal. It's absurd to argue we're all the same. ", "id": "d14vsvz"}, {"comment": "There is also a lot they do not have in common, in Western culture anyway. I'll link [Sheryl Sandberg](http://leanin.org/tips/work/) again because she is more articulate than me ", "id": "d14g1z0"}, {"comment": "Yes, exactly. ", "id": "d147sls"}, {"comment": "/u/andsoareotherthings is saying they're not the same thing. And probably that the latter is more important.", "id": "d14by76"}, {"comment": "You are saying people aren't treated differently and experience things differently due to their gender and race. I disagree.", "id": "d14fyp5"}, {"comment": "Hmm? Where are you getting that?", "id": "d14hjo3"}, {"comment": "> ~~Yes, exactly.~~ Pretty Much, fuck you.\n\nFTFY\n", "id": "d14e0tp"}, {"comment": "Indeed, the most beneficial form of diversity is viewpoint diversity, and there is mounting evidence that self-described diversity proponents do more than anyone to prevent viewpoint diversity. For example, discrimination in social sciences.", "id": "d159wsr"}, {"comment": "People from different backgrounds, different genders, different race or ethnicity *do* have a different life experience from the majority of the tech community. They experience things that the majority doesn't.\n\nDiversity is inherently good for tech. Having people from diverse backgrounds making decisions on technical solutions means we get technical solutions that serve a more diverse user base. \n\nDevelopers make a lot of decisions about how to implement solutions, what features to prioritize, etc. When you've lived a different life experience, your experience leads you to implement solutions differently. \n\nThe example I think of is how Twitter's user base is disproportionately Black. Users have been asking for improved ways to block and mute people (for example, when you block somebody, they can still see other people quoting your tweets). Harassment is rampant and it's something experienced by women and minorities way more than by people like Twitter's developers. Very different life experiences there. And so we get the hated Moments tab and a Like heart replacing the Favorites star because Twitter is trying to be Facebook instead of finding mutually beneficial ways to monetize its huge impact and serve its user base.\n\nTech benefits from diverse solutions, whether at large companies or at startups. People from other backgrounds aren't stealing your jobs. Diversity creates more jobs because we'll be solving problems that haven't even been on the radar.\n\n---\n\nAlso (talking to everybody now), let go of the assumption that valuing diversity means lowering standards. Stop conflating the two. \n\nThis subreddit already encourages people going back to school, people who are self-taught and got great jobs after, people who have fallen into technical roles and learned the skills on the job.\n\nWe already disparage the obsession with Stanford and Berkeley and the Big 4 tech companies and unicorn startups. There are a lot of wonderful jobs to be done outside of the Bay Area and outside of the household name companies.\n\nSoftware will never run out of jobs. We're not limited by material resources the way other industries are. We're not isolated to a single geographic location the way most labor is. Software just needs time, funding, and skills. \n\nWhile the web dev/bootcamp bubble may or may not pop soon, there is still an ever-growing need for great developers in all industries. Software touches every aspect of modern life. There are jobs to be done. Valuing diversity won't saturate the field, trust me.", "id": "d14mu48"}, {"comment": "Being devil's advocate here - I always hear this response, but where's the objective evidence for it? Bell Labs for example was pretty much only white males (your posterboy Groupthink environment) and was probably the most important research center of its time. ", "id": "d146fob"}, {"comment": "I challenge your assertion that only white men made contributions at Bell Labs :)\n\n[Women working at Bell Labs in the 60s](http://www.theguardian.com/technology/gallery/2016/feb/13/future-women-the-bell-lab-computer-operators-of-the-1960s-in-pictures-women-in-computing)\n\n[Erna Schneider Hoover worked at Bell Labs for 32 years](https://en.wikipedia.org/wiki/Erna_Schneider_Hoover)\n> Hoover used her knowledge of symbolic logic and feedback theory to program the control mechanisms of a call center to use data about incoming calls to impose order on the whole system.[2] It used computer electronic methods to monitor the frequency of incoming  calls[10] at different times.[6] Her method gave priority to processes that were concerned with the input and output of the switch over processes that were less important such as record keeping and billing.[2][7] The computer, as a result, would adjust the call center's acceptance rate automatically, greatly reducing the overloading problem.[9] The system became known as stored program control.[6]\n> \n> Hoover's thinking about the invention happened while she was in a hospital recuperating after having given birth to her second daughter, according to several sources.\n\nThat is pretty badass.\n\n[Shirley Ann Jackson worked at Bell Labs](https://en.wikipedia.org/wiki/Shirley_Ann_Jackson)\n> At Bell Labs, Jackson researched the optical and electronic properties of two-dimensional and quasi-two dimensional systems. In her research, Jackson has made contributions to the knowledge of charged density waves in layered compounds, polaronic aspects of electrons in the surface of liquid helium films, and optical and electronic properties of semiconductor strained-layer superlattices. On these topics and others she has prepared or collaborated on over 100 scientific articles.\n\n[Google books link for other women who worked at Bell Labs in the 70's](https://books.google.com/books?id=cwVneUvbAWQC&pg=PR15&lpg=PR15&dq=Bell+Labs+women&source=bl&ots=g-pA4fYM0f&sig=wwMPvgO_HVhTD3xeL4RbOyWG-io&hl=en&sa=X&ved=0ahUKEwiM8-2lt8nLAhUDlx4KHUFVCx4Q6AEITTAL#v=onepage&q=Bell%20Labs%20women&f=false)\n\n[Diversity in schools study](http://www.npr.org/sections/ed/2015/10/19/446085513/the-evidence-that-white-children-benefit-from-integrated-schools)\n", "id": "d147nt0"}, {"comment": "What was the ratio of men to women at bell labs? Almost certainly not 50/50 in its prime. Would it have been even more productive if it was 50/50?", "id": "d148rgb"}, {"comment": "More innovative, maybe. Most of the articles I read last night said diverse teams were more innovative.", "id": "d14g4nm"}, {"comment": "Well, that would be incredible for one of the most innovative places in the world to become more innovative. ", "id": "d14stpw"}, {"comment": "Cool stuff. I'm for diversity by the way, but I think it's more important to understand the facts behind it than to state the canned responses I always hear. So thanks for posting that =). Besides, even if Bell Labs were 100% white males, that would just be one case study, and wouldn't prove anything. ", "id": "d14k4i0"}, {"comment": "If that's the case, why would you weight \"life experiences\" by population count? Let's say 90% of people in the world are life experience A, and 10% life experience B. Why would the best ratio be 90%/10% for a team, and not 50/50%? Why does life experience A count for more than a life experience B?\n\nIf this retarded logic really was the case, people would be rushing to hire Inuits, Native Americans, aborigines, dwarfs, blind people, etc. ", "id": "d148t9b"}, {"comment": "Blind people might have some important things to say about user interface design. ", "id": "d14bbe8"}, {"comment": "That doesn't imply that the percentage of people who are blind should be the percentage of the workforce that is blind.", "id": "d14cdzo"}, {"comment": "Absolutely. I don't see where what I said argues against that.", "id": "d14spcm"}, {"comment": "If we take that argument a little further, we will conclude we'd be better off including doctors, lawyers, prison guards, unskilled workers, people over 89, kids under 16, etc. in our teams.", "id": "d14b5iv"}, {"comment": "Even if we stick to strictly gender differences, the logic is problematic.\n\nIf gender is fluid and both male and female minds are fundamentally the same, then having more women on a team should have little to no effect (and to say men can't understand or have similar backgrounds is to deny men's experiences). If gender is tied to genetics, then not only must you deal with awkward questions about transgender individuals, but you must also deal the resulting idea that men may be more equipped or just more inclined to be happy programming.\n\nIn both cases, you will run afoul of the group of people who attempt to make this a tech issue.", "id": "d14qqgi"}, {"comment": "There's a limit to this though. If you wanted to get *maximum* diversity you would end up with a group of people who have no way to communicate (because they all speak different languages) and have very different cultural norms, political views, and working styles. That would probably be a disaster for any project.", "id": "d14i4dw"}, {"comment": "I don't entirely disagree, but this philosophy generally seems to be almost exclusively defined by superficial factors such as race and gender. Never mind that things like religion, economic class, or even location are never discussed and even outright illegal, but life experiences can vary wildly within those superficial traits we diversify on (ie. people of the same race or gender can have radically different life experiences) \n\nTo that end, I generally interpret this argument as simply a means to an end of diversity for diversity's sake. Also consider the reverse. If we found that homogeneous groups do better, are we seriously going to argue it's better to only hire one demographic? Doubtful.", "id": "d14q4ff"}, {"comment": "[deleted]", "id": "d146fil"}, {"comment": "blue collar work is icky and gross and actually involves WORK so you won't see any of these neon whales make a push at those fields.", "id": "d14auh4"}, {"comment": "> neon whales\n\nwhat the fuck, dude. ", "id": "d14ec58"}, {"comment": "> neon whales\n\n\nActually laughed out loud", "id": "d14k5vr"}, {"comment": "Hilarious, also sounds like a mega man boss. ", "id": "d14lh1u"}, {"comment": "Diversity is good because simple numbers: bigger skill pool.", "id": "d148wjv"}, {"comment": "Wouldn't having only high skill people increase the skill pool more?", "id": "d14ae68"}, {"comment": "That's what we're talking about though.  Diversifying means not eliminating skilled people because of their race or gender.  Gotebe was talking sheer numbers, not percentages.", "id": "d14b1mv"}, {"comment": "That's one view on it, from the perspective that there are lots of skilled people out there who aren't getting jobs due to discrimination. Unfortunately, if the problem is mostly further upstream, and people of other backgrounds simply haven't been trained in the relevant skills in the numbers required, then the only direct route to increased diversity is necessarily going to be to lower the skill threshold.\n\nAnalogy: here in the UK, 90% of nurses are female. Let's assume we wanted to hire more men instantly for more diversity. Unfortunately the system only recruits people who've done a nursing degree, which also has a roughly 9:1 ratio of women to men. If the graduates are of equal skill on average, and industry wants to shift that ratio at the point of hiring, then that means hiring men over equally qualified women. And if industry wants to enact a 50/50 hiring policy, that leaves 8/9ths of the qualified female graduates unemployed even though all the worst men got hired.", "id": "d14bjor"}, {"comment": "The author of the article is encouraging aspiring female developers to stick with computer science if they're passionate about it. And not to remove themselves from the skill pool because it feels like a \"boys' club\". The line Barrucadu quoted was specifically saying it is good that \"more and more women are entering the tech industry\" - nothing about discriminatory hiring practices. I don't agree that using discriminatory hiring practices is the only route to increased diversity. Students who are passionate about computer science should be encouraged not to leave the field because they feel like they don\u2019t fit in the stereotype. It\u2019s pretty simple, but that\u2019s really all this article is about.", "id": "d14cr9i"}, {"comment": "I'm not really responding to or criticising the article, just the idea that \"Diversifying means not eliminating skilled people because of their race or gender\". In the best case, that is true. However many people push for more than that, aiming for diversity as an intrinsic goal, and along several parts of the pipeline it's not possible to maximise that without lowering the average skill level. (And ironically often eliminating more-skilled people because of their race and gender, because that race or gender is perceived to be more privileged.)", "id": "d14dsvn"}, {"comment": "Nobody (so far) is proposing to eliminate skilled people because of their race or gender.\n\nThe question is what value there is in diversity in the *absence* of discrimination.", "id": "d14c09m"}, {"comment": "Taken literally, this argument definitely makes sense; diversity of opinion breeds diversity of viewpoints and diversity of solutions.\n\nHowever, people (feminists mostly) use this argument in a completely wrong way, purely for propaganda purposes. Obviously, being a woman doesn't mean you'll think differently than a man. You *might* (especially since we grow up with physically different bodies), but the differences might be minor and/or irrelevant. Actually, two men from different backgrounds (e.g. one from the US and one from Asia) might have much more diverse minds than a man and a woman from the same background.\n\nMost complaining about lack of \"diversity\" in tech is just selfish propaganda.", "id": "d14c5qv"}, {"comment": ">But I don't get why people go around acting as if diversity is an inherent good.\n\nIt's really easy to understand but I rarely see this pop up. The term is creative abrasion, having a diverse team is one way to maximise creation abrasion (ideas are productively challenged) and can help you arrive at a better solution, gender is one way of increasing diversity. There are write ups on how 3M, Nissan and Apple purposefully diversify their teams to maximise creative abrasion.\n\nDiversity in many ways need to be managed. Teams with low diversity tend to fraction (called faultlines) and form subgroups. I think this is the reason why you get the story of a team with one woman feeling isolated (I was thinking along the lines of Ellen Pao).", "id": "d14dkut"}, {"comment": "I think viewpoint diversity is important because monocultures can have blind spots. Race/gender diversity can act as an (imperfect) proxy for viewpoint diversity.", "id": "d147ins"}, {"comment": "Hmm... so choosing to hire a black person who went to stanford or a woman who went to stanford, over a white man who went to stanford is a good way to proxy for viewpoint diversity? Good to know!", "id": "d148ubk"}, {"comment": "Welcome to strawman central!", "id": "d14beoe"}, {"comment": "Great argument!", "id": "d14ssc6"}, {"comment": "How is having a person of a different gender or race going to help me solve a programming problem in a better way? If they are making a point about UX, then we aren't talking about programming -- we're talking about knowing what your target users want.", "id": "d14rc2h"}, {"comment": "This is probably an artifact of how I approach software design, but I find that the technical bits are really the easiest part of software development. Much harder, and also much riskier, is the part where you need to figure out your users' concerns, the \"story\" you're telling via UX, etc. This is just as true when you're doing web apps as when you're doing platforms/systems/tools.", "id": "d14s9vv"}, {"comment": "I very much agree that consulting a diverse group of people when making an application that targets a diverse group. That's far different than the idea of diversity though. I don't need to hire that person as a programmer to get their input. In fact, being a programmer generally means that you think in a way that's less likely to make you relate to the program in the same way as other people of your specific group.\n\nA second point is that diversity is relative. When I'm designing a website, I want a blind person to be able to navigate it as painlessly as possible. When another programmer is making a first-person shooter, a blind person's opinion is less important (though the opinion of someone with poor eyesight or colorblindness would still be quite important). If I'm making a systems application, then my target market is systems users. I don't see a Jewish female systems admin calling a command line program in a significantly different way from a hispanic male systems admin.\n\nIt's true that front-end devs tend to be a lot closer to UX than back-end devs, but in any company with more than 10-15 people, there should be dedicated UX designers who interact with a diverse group of users to give you feedback on what to implement. It's also worth noting that the recent stackoverflow survey indicated that this was the top area for women to work in.", "id": "d14tkcm"}, {"comment": "In the spirit of Extreme Programming, I think the PM/design team *must* be diverse in viewpoints/background. That may or may not be the same team that's in charge of implementing the product.", "id": "d14uswj"}, {"comment": "Different viewpoints lead to better decisions overall, not just in tech.  It's not really that hard of a concept.", "id": "d14hoyx"}, {"comment": "Different viewpoints do not correlate to better decisions. The viewpoint of a Scottish shepherd from the 1500s wouldn't matter one bit when I'm deciding how to operate on a bunch of data.\n\nWhat viewpoints will these diverse people bring to programming?\n\nI imagine that the answers will all involve UX. Getting UX feedback is important and informs what the product spec should be, but the product spec is not programming.\n\nThis leaves you with \"X is a ____, so X going to approach programming differently\". If you believe in these innate differences, then you immediately raise other questions that call into question diversity too (whether that blank is filled by woman, black, disabled, transgender, or whatever else).", "id": "d14r5ur"}, {"comment": "Because its nice to work with all kinds of people?", "id": "d14ml20"}, {"comment": "http://blogs.lawrence.edu/lawrencetoday/2010/03/610/", "id": "d14gdle"}, {"comment": "For example, http://www.mckinsey.com/business-functions/organization/our-insights/why-diversity-matters\n\n\"Companies with more diverse workforces perform better financially\"\n\n", "id": "d14a3m6"}, {"comment": "Correlation != Causation\n\nMore success could mean hiring more women, not the other way around, or another factor might play a part in both financial success and the hiring of women.", "id": "d14bzk4"}, {"comment": "Exactly, with a higher profit margin, companies could also be willing to carry more 'dead weight'. (I know this is a BS statement, but still...)", "id": "d16gqqa"}, {"comment": "I would put forward that having diversity generally means you are already a successful company. Small businesses tend to have relatively few people and those people already know each other (but are then definitionally less 'diverse'). It is only when you have succeeded enough to branch out that diversity becomes possible.\n\nI particularly take issue with \"diversity\" relying on stereotypes. How does hiring a black person make your company's collective experience \"more diverse\"? The only way you can make that statement is if you believe that a black person can't possibly have the same experiences as a white person -- that's somewhere between nationalism and outright racism.\n\nTo make the point without racism, you have to say \"find someone with a minimum overlap of shared experiences\", but that could just as easily mean pulling a homeless guy off the street as anything else.", "id": "d14rroa"}, {"comment": "Men, Women, Transgender, Genderfluid, Asian, African-American, African, Indonesian and Helicopters all deserve 50% representation each.", "id": "d14ctqy"}, {"comment": "Put it this way: if you, as a developer, are spending more time coding than actively recruiting a diverse team, then your project deserves to fail.", "id": "d14lduk"}, {"comment": "Really? Or did you type those two choices in the wrong order?", "id": "d14v6pf"}], [{"comment": ">your skills will speak louder than your gender\n\nthis", "id": "d13n23c"}], [{"comment": "> Overall, to become a female developer, you only have to do what any other smart dev would do. Spend weekends and late nights in front of your computer, laying down lines of code, debugging and developing your personal projects.\n\nGood advice for any engineer: commit to your craft, but remember to maintain work-life balance. The rest of it is just a distraction.", "id": "d144jbd"}, {"comment": "When I saw the snippet you had quoted, I expected a completely different comment than what you said. \n\nPerhaps I've been reading reddit too long, but these quotes are usually followed up with \"rah rah I want to clock out at 5pm and come home. Expecting me to code on my off hours just to keep relevant is a red flag\"... which ironically, is also a red flag... \n\nSo, kudos to you. ", "id": "d14go65"}, {"comment": "It would be great if everyone could have a job they love, and commit to it and love it. But some jobs are going to just be boring and awful but they still need doing. So take a moment out of your day to thank those guys and gals who just want to clock out and 5pm and come home, that get those jobs done.\n", "id": "d14hz0m"}, {"comment": "Software is a craft and it requires devotion -- if you're work is boring, then work on something else in the field. Working with people that aren't invested in advancing their field or in their field can be depressing, and you should expect the investment to be a prereq for a top level job. ", "id": "d14l0g1"}, {"comment": "I agree, we should all strive to do those things.\nBut there is always horrible grunt work that needs doing, and some people will have to fail to achieve these things and do that grunt work.  Hopefully the have fun hobbies outside of work.\n", "id": "d14lh3v"}, {"comment": "The key phrase is \"personal projects.\"  \n\nThough for some people, the problems to solve at their work are just as interesting, but for the majority of programmers I don't think that is the case and is why we get pissed when we're forced into 50+ hour work weeks.", "id": "d14gyec"}, {"comment": "I spend about a half hour at work writing the code to solve a problem, and then the rest of the time planning my vacation. But then, I'm a code wizard. ;)", "id": "d14ha6g"}], [{"comment": "my attitude is and has always been; man or woman if you're competent I'll respect you.", "id": "d13wuhq"}, {"comment": "> man or woman if you're competent \n\nThe problem is, most people perceive men as being more competent than women. That's the nature of bias. And the effect is stronger on those that think of themselves as objective, [apparently](http://www.socialjudgments.com/docs/Uhlmann%20and%20Cohen%202005.pdf).", "id": "d15esv9"}, {"comment": "It's not bias, it's a perfectly rational shortcut. Considering there are over 10 times more men than women in IT, it's perfectly accurate to assume a random man is more proficient with computers than a random woman, just like it's perfectly rational to expect a random woman to know more about shoes than a random man. ", "id": "d1757lm"}, {"comment": "When comparing a random woman with a random man, yes. When comparing a random woman with a random man, both in IT or applying to a related position, there is no rational reason to assume the former is less competent, but we do.", "id": "d17anm8"}, {"comment": "That's assuming we can afford to carefully weigh every information we have at every time, and we simply can't. ", "id": "d17cs0a"}, {"comment": "Agreed. But I think just being aware that you might be biased could help a bit.", "id": "d17dvki"}, {"comment": "[deleted]", "id": "d16izlr"}, {"comment": "I don't know what to do, either, it's a complicated subject.\n\nBut recongizing you (and me) probably have biases is a good first step. Note this cuts the other way as well. We are biased to think women are more compentent at typically female jobs.", "id": "d17arwf"}], [{"comment": "Excepted some retarded \"outreach\" type of shit, but this is actually very reasonable.\n\nAnd while your skills will indeed speak louder than your gender. Let's be honest, if skill is comparatible then other things start to become a factor. While no one will hire a shitty man over an excellent woman. If the skills are comparable in _most_ places the man will get hired, however in others they do the opposite as some kind of counter-balance and that exists as well. So while skills do speak louder, it's sadly still a factor. Amongst many, many, many things. People act like gender and race are only disadvantaging factors but I like how everyone in white collar work speaks with some prestige-accent. It's works against you a lot if you have a \"lower class accent\", no matter how smart you are, people will assume you are simpleton and uneducated until proven otherwise if you have certain accents.", "id": "d13rlvj"}, {"comment": ">  If the skills are comparable in most places the man will get hired\n\nSource?", "id": "d13sgad"}, {"comment": "http://www.pnas.org/content/109/41/16474\n\nSame credentials, but a male or female name makes a difference.\n\nInteresting detail by the way is that if a woman does the hiring statistically she is just as likely to discriminate against women. While women statistically are the casualty. Unlike what people tend to assume, men are not the perpetrator statistically.\n\nIn any case, the bias is not high, but still significant.\n\nEdit: On that note, I never got why blind interviews aren't a thing. It's a simple process, one person does the interviewing and verifies  the credentials. Then another isolated person gets a transcript and does not get to know anything that is not relevant like name, place of birth, gender, race, really anything that is not directly a credential and of course the transcript and then gets to decide whether the applicant is hired being shielded from that information.\n\nI also never got why in Jury trials the jury actually gets to _see_ the defendant, why would you let them sit there live as the attorneys ask the quaestions and not isolate them? Anything that is actually stricken _will_ be stricken, the Jury will not get to hear it because they later get to either read a transcript or a distorted recording which makes anyone completely unrecognizable, is there any reason the Jury needs to see the defendant sitting in the room who will no doubt conclude \"oh, scary face, probably guilty\" or conversely \"Oh, nice elder lady, can't have committed a murder\"", "id": "d13sk46"}, {"comment": "I'd love to see similar study for a line of work that is mostly female-dominated.\n\nIt seems to me like it could be bias caused by \"common knowledge\" that men are better at x and women are better at y", "id": "d13y2ck"}, {"comment": "Most likely same result for male nannies, yes.", "id": "d13y4y2"}, {"comment": "I expected the link to be easily dismissed, and I was already preparing potential rebuttals as I read it, but that actually sounds like a really good study. I tend to think of myself as being unbiased toward gender, but this is making me second guess myself...", "id": "d13sues"}, {"comment": "There are also studies that show very much the opposite. [National hiring experiments reveal 2:1 faculty preference for women on STEM tenure track](http://www.pnas.org/content/112/17/5360.abstract): http://www.pnas.org/content/112/17/5360.abstract\n\nSo blind interviews, as /u/Frat_Krats suggests, would actually be severely advantageous for men.", "id": "d13wk9t"}, {"comment": "Urgh, while this study has a slightly different methodology, it's close enough. This kind of stuff is why I'm honestly giving up on putting _any_ weight on _any_ soft \"\"\"science\"\"\" study ever.\n\nIt's ridiculous how you can have one study which shows one thing while another shows the opposite  the next day. It's garbage.", "id": "d13yh94"}, {"comment": "Yep :( It's even worse because you can't even solidly rely on a meta analysis of a group of studies because of the publication bias. Results that aren't considered interesting or fitting the existing evidence don't get published as often as those that do. This phenomenon even appeared in physics. Here's a couple of paragraphs by Feynman on the electron mass scandal: \n\n> We have learned a lot from experience about how to handle some of the ways we fool ourselves. One example: Millikan measured the charge on an electron by an experiment with falling oil drops, and got an answer which we now know not to be quite right. It's a little bit off because he had the incorrect value for the viscosity of air. It's interesting to look at the history of measurements of the charge of an electron, after Millikan. If you plot them as a function of time, you find that one is a little bit bigger than Millikan's, and the next one's a little bit bigger than that, and the next one's a little bit bigger than that, until finally they settle down to a number which is higher.\n>\n> Why didn't they discover the new number was higher right away? It's a thing that scientists are ashamed of\u2014this history\u2014because it's apparent that people did things like this: When they got a number that was too high above Millikan's, they thought something must be wrong\u2014and they would look for and find a reason why something might be wrong. When they got a number close to Millikan's value they didn't look so hard. And so they eliminated the numbers that were too far off, and did other things like that...\n\n-- https://en.wikipedia.org/wiki/Oil_drop_experiment#Millikan.27s_experiment_as_an_example_of_psychological_effects_in_scientific_methodology", "id": "d13zlmf"}, {"comment": "Yes, while physics is obviously rock solid when it's correct, and correct is correct and exact in physics, physics does not escape the situation that people don't want to publish things they don't like. However, a couple of things mitigate physics, most importantly that physical results are distinctly apolitical. People have no political interest in the mass of the electron.\n\nSoft science is often distinctly political with researchers definitely wanting a certain result and when it's not what they want, they might just not publish it. Also, the environment can easily be constructed in advance to support the desired conclusion. The thing with soft science is that it _heavily_ relies on extrapolation of the data. You can see it here already, in one study we have data:\n\n- In a specific US state, in a specific time of the year, in a specific this, in a specific that and a specific such and this when you put a female name on a specific application (were the female names randomized to begin with? Maybe they used female ghetto names to skew the result?) blablabla\n\nAnd all these \"specific\" things are then generalized as is so often the case in soft science. And by picking the specifics you can easily support the conclusion you want. That's how soft science works. Some controlled situation about how people elect class praesident in a specific US state with people of a specific age is extrapolated to say something about how people elect leaders in the general case. Some study observing a speed dating session in a specific time of the year in a specific US state is extrapolated about how human beings in general search for a mate.", "id": "d1401oc"}, {"comment": "Yeah. Grant seeking + narrow study + bad statistics + publication bias + journalistic misreading + wild generalization + political punditry + clickbait headline + ignorant readers = public opinion. It's like trying to read a book through ten layers of dirty glass, some of which have scribbles all over them. We need to improve the whole stack before we have any hope at finding the truth.", "id": "d14azi0"}, {"comment": "Well, my own philosophy in life is that people who think they aren't biased or corruptable are probably the most biased and corruptable that they don't notice.\n\nIt tends to fill me with more faith when there is a conflict of interest that someone just admits \"Yes, this is a conflict of interest that no doubt influences me\" then when they preach high that it supposedly bears _zero_ influence which is just unlikely.", "id": "d13t1ef"}, {"comment": "I used to admit that there are conflicts that probably influence me, but if you live in a highly political world (like say any management position) this is generally a really bad plan. You're basically admitting to bias, intentional or not, which regardless of intent exposes you to risk in terms of claims of discrimination made against you.\n\nIf you care about about your career I would advise to avoid any statement at all about any bias you may or may not have. Deny it only if required to do so, avoid the topic if at all possible.", "id": "d13ul53"}, {"comment": "> If you care about about your career I would advise to avoid any statement at all about any bias you may or may not have.\n\nIf you **only** care about about your career. <-- I think this is what you mean.\n\nIt seems you are in a position where you care about bias, but don't feel it is safe to mention that (everybody including) you can fall prey to it. As a suggestion, would it be possible to nonetheless restructure protocols to reduce the risk of bias? E.g. when you have to look at c.v.'s, ask that the name be removed before it is given to you. When asked for reasons, I find \"so no-one can accuses us of bias\" is often a good stand-in for \"because we are prone to bias\".", "id": "d14gwm0"}, {"comment": "You're talking about covering your ass in the same way I am. You're no more admitting to bias than I will. \"So no-one can accuse us of bias\" is not admitting you have any, it's basically a method of shifting blame of perception of bias to the other party. Certainly these are conversations we have amongst ourselves, and we do things like scrub resumes and code samples of all identifying information prior to starting a preliminary technical review.\n\nTo be frank though, yes I care about my career more than I care about letting anyone else know I am aware of my own biases.", "id": "d14hd46"}, {"comment": "I mainly want to make the point that although one may be afraid to speak one's agenda, one might still be able to act according to it; but it seems you are already doing that, in all matters except for speaking freely.\n\n>  You're no more admitting to bias than I will.\n\nI phrased my answer as though I were in your shoes, yes. I am personally in a rather different position, and more inclined to speak openly regardless of consequences, but I felt that advice might not directly transfer to your situation. We seem to have the same sort of values, but we live in rather different context.\n\n(I can still recommend airing ones opinion, though. Our thoughts are formed by the thoughts we hear; systems are a collection of rules and customs that are shaped by their constituents; and when constituents get a chance to make system-forming decisions, they do so according to their thoughts. It's a long game, but it works.)\n\n> \"So no-one can accuse us of bias\" is not admitting you have any, it's basically a method of shifting blame of perception of bias to the other party. Certainly these are conversations we have amongst ourselves, [...] though, yes I care about my career more than I care about letting anyone else know I am aware of my own biases.\n\nIf you started saying 'so we won't commit accidental bias' instead, that would give the conversation another small nudge in the right direction, and hopefully shape the way your company thinks of bias. Perhaps that's a change that you could afford to make?\n\nP.s. I am no good at radical revolution, as you can probably tell by how modest the actions are that I propose. Maybe I should read [something](https://en.wikipedia.org/wiki/Gene_Sharp) by [Gene Sharp](http://www.bbc.co.uk/news/world-middle-east-12522848)? Although he seems more concerned with non-violent revolution than with change from within.", "id": "d14ladg"}, {"comment": "Hey!\n\nYou are my boss, aren't you?\n\nYou incompetent bias-hiding tool!\n\n:-)", "id": "d148uh7"}, {"comment": "Get back to work!", "id": "d149i7m"}, {"comment": "Now go and reperform that study in the tech world, and you will get the exact opposite results. Lack of diversity has been crammed down our throats so much that tech companies are going out of their way to hire *any* woman who is remotely qualified.", "id": "d148pw2"}, {"comment": "The study was performed in the tech world...", "id": "d149b9o"}, {"comment": "Academia != the tech world.", "id": "d14cgdn"}, {"comment": "academic science is not the tech world.", "id": "d14r3o0"}, {"comment": "Re. blind processes (obviously just my opinions):\n\nIn the case of interviews, it would seem to stem from a couple things: \n\n1. We're terrible at creating interview processes which can reliably separate qualified individuals from unqualified individuals. \n2. We very much rely on our *feel* for the candidate during the interview when making hiring decisions.\n\nAnd, in fact, as Google found with their [Project Aristotle](http://www.nytimes.com/2016/02/28/magazine/what-google-learned-from-its-quest-to-build-the-perfect-team.html?_r=0) research, #2 might actually be the more important thing. Successful teams are, it would seem, almost entirely the result of interpersonal dynamics and not individual competencies. \n\nThe obvious result of that is a lot of hiring of people who are already like the team. In the case of our industry, that's frequently going to be nerdy white guys. As we see more diverse teams being formed from the start, we'll likely see more diverse hiring follow.\n\nAnd as for the court system, much of it probably comes down to the Sixth Amendment right to a public trial. While you're dead on that [attractive defendants get shorter sentences](http://onlinelibrary.wiley.com/doi/10.1002/bsl.939/epdf) its important that the defendant know he's actually being tried by a jury and that the jurors know they're actually trying the defendant. While likely small, there's a risk that justice could be completely subverted by providing jurors with doctored testimony, not actually *having* a jury, etc. \n", "id": "d14g5ut"}, {"comment": "> We very much rely on our feel for the candidate during the interview when making hiring decisions.\n\nThis is just basically the essence of \"discrimination\" though, this is very much discriminating on so many fronts. For some reason if you ever admit you didn't hire someone because he or she wasn't pretty or fat you land yourself in deep shit, but if you just say \"I didn't like him or her\" then you're fine which is the same thing. Discrimination based on a pretty face is unacceptable, but pretty voice and personality? That's all fine some-how.\n\n> And, in fact, as Google found with their Project Aristotle research, #2 might actually be the more important thing. Successful teams are, it would seem, almost entirely the result of interpersonal dynamics and not individual competencies.\nThe obvious result of that is a lot of hiring of people who are already like the team. In the case of our industry, that's frequently going to be nerdy white guys. As we see more diverse teams being formed from the start, we'll likely see more diverse hiring follow.\n\nYeh, well, I don't have much compassion for the awful \"plight\" of people who have to work with people they don't like, I had to work with people whom I don't like all my life, your job isn't for pleasure, man up and ignore it.\n\n> And as for the court system, much of it probably comes down to the Sixth Amendment right to a public trial. While you're dead on that attractive defendants get shorter sentences its important that the defendant know he's actually being tried by a jury and that the jurors know they're actually trying the defendant. While likely small, there's a risk that justice could be completely subverted by providing jurors with doctored testimony, not actually having a jury, etc.\n\nSo record the jury publicly in their deliberations after the fact to ensure that they get to see all the evidence and give the defendant the right to verify they saw everything. I never got why jury deliberations are hidden anyway, they should be public and noted and the jury making certain arguments should be grounds for appeal.", "id": "d14lujk"}, {"comment": "> This is just basically the essence of \"discrimination\" though, this is very much discriminating on so many fronts.\n\nI totally agree. We're hard-wired to do it, though, and fighting that nature is hard, if not impossible. I'm not defending the practice, just answering your question.\n\n>Yeh, well, I don't have much compassion for the awful \"plight\" of people who have to work with people they don't like, I had to work with people whom I don't like all my life, your job isn't for pleasure, man up and ignore it.\n\nIs that all you took away from that? If so, you're missing the forest for the trees. \n\nTeams that get along produce better products, do better work, and on the whole are more effective than just being the sum of their parts. It's in the best interests of the company, the employees, and their customers that the team be cohesive.", "id": "d14mrj5"}, {"comment": "> I totally agree. We're hard-wired to do it, though, and fighting that nature is hard, if not impossible. I'm not defending the practice, just answering your question.\n\nAh, but the good part is that with my proposed system we don't have to fight our nature because we are shielded from that info to begin with.\n\n> Teams that get along produce better products, do better work, and on the whole are more effective than just being the sum of their parts. It's in the best interests of the company, the employees, and their customers that the team be cohesive.\n\nMaybe so, but you can justify any form of discrimination with that. Maybe this also applies to a team of all white people but try using that argument to hire only white people.\n\nThe thing about anti discrimination laws is that they are not to protect the company, far from it, they are to protect the potential employees.", "id": "d14mxnz"}, {"comment": "What about [this study](https://www.washingtonpost.com/news/morning-mix/wp/2015/04/14/study-finds-surprisingly-that-women-are-favored-for-jobs-in-stem/) though", "id": "d14grlo"}, {"comment": "Personal anecdote, worth nothing, but i've been personnally told by a manager I got a job because he didn't want any female in the team. Some were more skilled than me, at least on the resume. I actually owe a job to mysogyny ...", "id": "d14d1g2"}], [{"comment": "Expected feminist bragging, did not find it. Nice!", "id": "d13mhmd"}, {"comment": "I did...\n\n> More and more women are entering the tech industry.\n\nAre they? I mean, the point might actually be correct, AFAIK more women are entering the tech *industry*, but mainly in non-engineering/technology-related positions.\n\n> And this is necessary; after all, diversifying the tech workforce can only benefit the industry at large.\n\nThis is true why exactly? More to the point, my issue with this argument is that diversity of *opinion* is good, not diversity of *sex organs*. The latter doesn't imply the former.", "id": "d14c9r5"}, {"comment": "[deleted]", "id": "d14e869"}, {"comment": "They don't, but my bet would be that the life experiences of a man and a woman from the same background (e.g. both from the US) is much more similar that those of two men, one from the US and the other from Asia.\n\nFunny enough, SJWs keep ignoring the latter diversity and spouting propaganda that there is a \"lack\" of \"diversity\" in tech.", "id": "d14epk8"}, {"comment": "Hello, I am a woman telling you that I do not have the same life experiences as men with similar interests an backgrounds as me. I am telling you through my own experiences that your assertion is false. Does this change your mind at all? Are you going to demand proof from me and dismiss me when it does not meet some standard of yours?\n\nHow about you just take my word for it.", "id": "d14h931"}, {"comment": "> I do not have the same life experiences as men with similar interests an backgrounds as me\n\nI never said as much.", "id": "d14jecw"}, {"comment": "Just out of interest, what makes you think that?", "id": "d14nc3y"}], [{"comment": "why are all girls recently writing about this Ruby developers... ", "id": "d13zb3x"}, {"comment": "I'm not sure why, but the Ruby community seems to be *very* feminist compared to other language communities.", "id": "d147k04"}, {"comment": "Maybe because it is web oriented, and that attracts more females than things which are systems oriented, which is still the realm of the nerds and neckbeards.", "id": "d148vw4"}, {"comment": "I know plenty of women who fucking love systems. Please explain why we would care so much about being seen as a neckbeard (unlikely) or a nerd (whatever, already an engineer) than a man would?", "id": "d14lmr4"}, {"comment": "Did I ever say there weren't women who loved systems? I just said that the distribution seems to be skewed towards front-end/user interactive development than systems development.", "id": "d14t838"}, {"comment": "Just makes women seem weak and slaves to social norms to suggest that they'd shy away from a fascinating topic because of some uncool stereotypes", "id": "d14u55y"}, {"comment": "When did I say that women stay away from systems because of neckbeards and nerds? I said it is *still the realm* of neckbeards and nerds, not that women stay away from it *because* of them. I feel like you're putting words into my mouth.", "id": "d14uzs7"}, {"comment": "Ok, I see what you were saying, describing the effect not the cause. Sorry for the emotions/confusion, systems are near and dear to my heart.", "id": "d14yunc"}, {"comment": "<3", "id": "d14z5tt"}, {"comment": "Ruby's had its share of unfortunate incidents tho: http://blog.hasmanythrough.com/2009/4/29/not-the-post", "id": "d14edy8"}, {"comment": "But (based) Matz rejected  CoC ", "id": "d14mo5x"}, {"comment": "I guess I won't pick up Ruby anytime soon.", "id": "d17rs1k"}, {"comment": "yup. it has spilled over into PHP as well, phil sturgeon being the biggest feminist cuck of them all.", "id": "d14dknt"}, {"comment": "designers I my guess. it's a stupid simple language so it's easy to learn ", "id": "d14bmkk"}, {"comment": ">stupid  \n\nYes.\n\n>simple?\n\nIf it was simple, it wouldn't be stupid. ", "id": "d14d3wh"}, {"comment": "good point... :)", "id": "d14dvz2"}, {"comment": "I've noticed that a lot of places (colleges, bootcamps, etc.) are teaching ruby and RoR. I would argue that given that there has been an uptick in the number of female participants in these events in recent years, we can correlate that most of the new female devs will have experienced that language/framework. Also, because the new female devs (say less than 3 years) are a bigger portion of the total female dev population than the new male devs wrt total male devs, it is more likely that a blog post by a female dev written recently was written by a new dev that has learned ruby than a recent blog post written by a male dev was written by a new dev that learned ruby.", "id": "d144ob1"}, {"comment": "I wonder if they know that it's not such a favorable framework for big apps... I read it's better now but the env setup still seems like a clusterfuck. I always wanted to try it out but I gave up while setting it up...", "id": "d14dwxy"}], [{"comment": "I'm jealous I'm not a woman in that I don't get to have that experience as a man. So, I judge them as \"less\" to make myself feel \"more\". So far, every woman programmer I've seen has been okay to good, but not great or amazing. If I ran into an amazing female programmer, I'd probably secretly feel angst towards her or jealousy and possibly try to undermine her. \n\nI'm trying to get rid of this shit by writing it out, I know it's bullshit, but it's what is bouncing around in my head. ", "id": "d1444u5"}, {"comment": "Do you also feel jealous of amazing male programmers? ", "id": "d149djx"}, {"comment": "Yes, and it's worse because then I feel I have no excuse. Then I really beat myself up with no recourse. I'm learning to let it go though. There's always someone \"better\", and comparing is the creation of suffering. I know this intellectually, but need it to be engrained in my being at a core level.\n", "id": "d14ro0a"}, {"comment": "Sometimes I find instead of [beating yourself up], it's better to channel the energy.\n\nFor example, when you find someone better than you, admit that they are skillful, then figure out how they achieved their skill. (Donald Knuth, for example, seeks out examples of great people and tries to understand how they did what they did). \n\nLet your respect for the person challenge you, and motivate you to improve your own skills. \n\n", "id": "d154p6k"}, {"comment": "That is indeed some baggage you've got there, good luck getting rid of that shit.\n\nKeep working on it. Examine this resentment; don't cuddle it; examine (deeply! your mind will want to flinch -- keep at it) where it comes from, practise letting it go. Go on a [Coke Talk](http://dearcoquette.com/best/) archive binge, woman's got her head on right and understands both systems and individuals. Here's one that's [indirectly relevant](http://dearcoquette.com/on-sleazebags-and-self-loathing/), but in general exposure to her methods of thinking will help.", "id": "d14gfps"}], [{"comment": "That's a pretty nice article.", "id": "d140dhb"}], [{"comment": "Great attitude!", "id": "d144pqb"}], [{"comment": "> To every aspiring female developer out there\n\nI get a little saddened every time I see something like this. If you wish for equality, make equality. Say \"To EVERYBODY....\"", "id": "d14dj2y"}], [{"comment": "Of course the comments here are arguing against diversity and also claiming that obviously they only care about competence, somehow conflating that as meaning the industry only cares about that.  Keep it up reddit!", "id": "d14hz44"}], [{"comment": "Is it just me or does it matter? I don't care if you're female etc. What I care about is the quality of your work. Why do you feel the need to embasis your gender and make it an issue here? It's not an issue unless you make it one", "id": "d14f4vu"}], [{"comment": ">  I live and breathe code.\n\nThank god I am not a programmer.\n\nIf I'd live and breathe code, I'd seriously wonder what would be wrong with my mind.\n\nCode is just a tool. It's like driving a car. Cutting some wood. If it is beautiful then it can be poetry.\n\nBut breathing? Living? Oh my god ...", "id": "d14q97p"}], [{"comment": "I just want to raise a big red flag and spoil the truth : there is no equality in this world, every man is different in many aspects, including gender inequality. ALL the time when someone tries to talk about any kind of equality, its actually about doing the oposite thing - they want to become hunters from beeing hunted, not to be equal. Imagine what would happen if women were to be naturally blamed for every rape, no matter the situation. Also, this world is corrupted from the ground to the skies, and every bad thing is tied up together, so it makes little sense to just bring up one piece of puzzle out of millions. If you really want to fix anything, you have to burn this world to the ground and build a new one, nothing else will help you, ever.", "id": "d14bsfr"}]]], "4816lo": ["A succesful Git branching model considered harmful", "2016-02-28 12:59:44", 3, "https://barro.github.io/2016/02/a-succesful-git-branching-model-considered-harmful/", [[27, "Considered Harmful Titles Considered Harmful."], [13, "tl;dr: trunk based development in Git.\n\n[I concur that git-flow is problematic](https://www.reddit.com/r/git/comments/44bgag/i_am_reading_about_gitflow_and_i_do_not/czpvmuf) but this is advice is terrible. The article keeps appealing to `git bisect` but that handles (simple) branching just fine, and the key to avoiding Christmas trees and spaghetti lies in *rebasing* rather than *not-merging*."], [5, "In a perfect world, whoever commits to master will never break the build, by pulling immediately prior to committing and testing it. \n\nBut that assumes a lot of things about race conditions between two developers, how long it takes to actually test something, the complete invisibility of feature branches to someone looking through the project history, etc. I am not sure that I agree with the quality implications of not having someone perform the merges from a central perspective. Am I wrong?"], [3, "I have never found that git flow branching model to be necessary in any large projects I've worked on including government regulated ones with concurrent supported releases.\n\nIt's just unnecessarily overcomplicated.\n\nEDIT: Should also mention that unless you know you're going to be doing work on a maint branch you can always just leave the release as a tag and branch off the tag later if you actually need it. \n\nI've seen quite a number of projects with these branches for maint which never have any work done on them..."], [2, "The original article makes it seem as if people didn't know about branches before git existed, which can't be more false. Two workplaces I was in did it before gut existed, in two other SC systems. Release branches, feature branches, bug fix branches, the lot. It is as if universities discovered source control only when git was brought to the world, and suddenly hundreds of students started blogging about it.\n\nOne thing that both articles disregard are forward commits from master (or develop). You do not want your feature branch to be woefully out of date. You want any conflicts discovered and dealt with **early**. Doing this also largely does away with the \"integration hell\" (except if development really happens if massive feature branches who all only come together before a release; but nothing can save he who does that :-))."], [1, "nvie's original git-flow workflow was great because it got people really thinking about specifying their workflows formally and accurately, which I didn't see any sign of before.\n\nHowever I do think the master branch is a bit silly. What happens if you have multiple active releases, for example? The clear solution is to simply remove master, then s/develop/master/. Then tag your releases on your release branches followed by merging them into develop."], [1, "If merging with Git were actually really difficult, then the author might have a leg to stand on, but everything everything he complains about can be solved by fetching and merging often.  I've worked on long-lived branches many times.  It's not a problem.  Every work day, the first thing I do is pull and merge the latest changes from upstream.  This means that when it comes time to merge my feature branch, I have at most 1 day worth of code to merge with."], [0, "I like this. However, I presume that the implicit caveat to \"develop on master\" is that master should always compile*. Shared remote branches should be used for WIP changes that would break this, but nevertheless need to be shared.\n\n*and to some extent, work"], [0, "Very long living branches with big changes are impossible simply because the produce a lot of merge conflicts. So more realistic use of the feature branches are short and/or contain only limited changes. After this limitation I cannot say that merging produces any noticeable integration issues. In most cases if anything is broken it is discovered already during compilation.\n\nPS: I assume that you CI also checks the branches which prepared for the merge. Even the better would be to make automated check _after_ merge, and push the merge to the `master` only after the build is completed, but so far I don't know about systems which do so"], [-2, "Is it already 1st april?"]], [[{"comment": "Considered Harmful Titles Considered Harmful.", "id": "d0gsisf"}, {"comment": "[\"Considered Harmful\" Essays Considered Harmful](http://meyerweb.com/eric/comment/chech.html)", "id": "d0gtsgn"}, {"comment": "https://en.wikipedia.org/wiki/Considered_harmful", "id": "d0gt3t8"}], [{"comment": "tl;dr: trunk based development in Git.\n\n[I concur that git-flow is problematic](https://www.reddit.com/r/git/comments/44bgag/i_am_reading_about_gitflow_and_i_do_not/czpvmuf) but this is advice is terrible. The article keeps appealing to `git bisect` but that handles (simple) branching just fine, and the key to avoiding Christmas trees and spaghetti lies in *rebasing* rather than *not-merging*.", "id": "d0grihj"}, {"comment": "What do blondes and spaghetti have in common? They both wiggle when you eat them.", "id": "d0grjkw"}], [{"comment": "In a perfect world, whoever commits to master will never break the build, by pulling immediately prior to committing and testing it. \n\nBut that assumes a lot of things about race conditions between two developers, how long it takes to actually test something, the complete invisibility of feature branches to someone looking through the project history, etc. I am not sure that I agree with the quality implications of not having someone perform the merges from a central perspective. Am I wrong?", "id": "d0gt5g4"}], [{"comment": "I have never found that git flow branching model to be necessary in any large projects I've worked on including government regulated ones with concurrent supported releases.\n\nIt's just unnecessarily overcomplicated.\n\nEDIT: Should also mention that unless you know you're going to be doing work on a maint branch you can always just leave the release as a tag and branch off the tag later if you actually need it. \n\nI've seen quite a number of projects with these branches for maint which never have any work done on them...", "id": "d0gt6sp"}, {"comment": "> It's just unnecessarily overcomplicated.\n\nI used to think so as well until I finally just got it. It's not really all that complicated and provides for a lot of control on what actually gets pushed and released to master.", "id": "d0gz8li"}, {"comment": "Maybe over-engineered rather than over complicated. \n\nYou can control what gets into master very easily with pull requests/patches, you dont need the git flow setup to help you control that.\n\nBranch for features, rebase from master as needed, review, merge (or rebase if that's your preference). Tag releases as you go, there's no need for a development branch to accomplish any of that.", "id": "d0hk4xc"}, {"comment": "Same here, after working with git and mercurial for a long time my guess is that the git flow idea comes from the centralised version control mindset while trying to attach the things DVC systems make quick and easy. Might be completely wrong about that, not sure how you would come to git branching setup if you hadn't had exposure to existing centralized setups.\n\nJust need to take a step back and ask what would happen if I didn't have \"this part\"... that pretty much applies to engineering as a whole.\n\nEdit: Some more reading for those who are curious\n\nhttps://news.ycombinator.com/item?id=9744059 - discussion of similar article almost a year ago.\n\nhttp://scottchacon.com/2011/08/31/github-flow.html\n\nhttps://about.gitlab.com/2014/09/29/gitlab-flow/\n\nhttp://endoflineblog.com/follow-up-to-gitflow-considered-harmful - answers more questions than the original article", "id": "d0hkpjx"}], [{"comment": "The original article makes it seem as if people didn't know about branches before git existed, which can't be more false. Two workplaces I was in did it before gut existed, in two other SC systems. Release branches, feature branches, bug fix branches, the lot. It is as if universities discovered source control only when git was brought to the world, and suddenly hundreds of students started blogging about it.\n\nOne thing that both articles disregard are forward commits from master (or develop). You do not want your feature branch to be woefully out of date. You want any conflicts discovered and dealt with **early**. Doing this also largely does away with the \"integration hell\" (except if development really happens if massive feature branches who all only come together before a release; but nothing can save he who does that :-)).", "id": "d0gvht1"}], [{"comment": "nvie's original git-flow workflow was great because it got people really thinking about specifying their workflows formally and accurately, which I didn't see any sign of before.\n\nHowever I do think the master branch is a bit silly. What happens if you have multiple active releases, for example? The clear solution is to simply remove master, then s/develop/master/. Then tag your releases on your release branches followed by merging them into develop.", "id": "d0gtwmu"}], [{"comment": "If merging with Git were actually really difficult, then the author might have a leg to stand on, but everything everything he complains about can be solved by fetching and merging often.  I've worked on long-lived branches many times.  It's not a problem.  Every work day, the first thing I do is pull and merge the latest changes from upstream.  This means that when it comes time to merge my feature branch, I have at most 1 day worth of code to merge with.", "id": "d0iknj6"}], [{"comment": "I like this. However, I presume that the implicit caveat to \"develop on master\" is that master should always compile*. Shared remote branches should be used for WIP changes that would break this, but nevertheless need to be shared.\n\n*and to some extent, work", "id": "d0grgjt"}], [{"comment": "Very long living branches with big changes are impossible simply because the produce a lot of merge conflicts. So more realistic use of the feature branches are short and/or contain only limited changes. After this limitation I cannot say that merging produces any noticeable integration issues. In most cases if anything is broken it is discovered already during compilation.\n\nPS: I assume that you CI also checks the branches which prepared for the merge. Even the better would be to make automated check _after_ merge, and push the merge to the `master` only after the build is completed, but so far I don't know about systems which do so", "id": "d0h797v"}], [{"comment": "Is it already 1st april?", "id": "d0gtq9c"}]]], "4i97ya": ["Beating Uber with a PostgreSQL prototype", "2016-05-07 12:05:28", 46, "http://www.cybertec.at/2016/05/beating-uber-with-a-postgresql-prototype/", [[125, "Maybe I'm dumb, but that blog post was clear as mud to me. \n\nI didn't see how the indices were created, I didn't understand the logic behind the magic numbers used to create the equivalency to the Uber DB, I didn't understand the logic behind how the particular shape/point coordinates (more magic numbers, to me) are equivalent to what Uber is doing, and finally I missed actually seeing the \"promising\" results on the blog page in terms of screenshots of query output time measurements etc."], [67, "Maybe they could have used some of that prototyping ability [to make their website faster](http://i.imgur.com/kOfi9la.png)."], [64, "What did I just read? Some guy took a subset of a massive amount of data and tells people smugly that he's beaten Uber?\n\nThe use case is limited whereas Uber's clearly isn't.\n\nIt's like me creating a basic OS implementation and telling people I've just beaten Apple and Microsoft at their own game."], [21, "> even developing the business logic is faster with PostgreSQL\n\nRight, because that's where you want your business logic, in the database. I'm sure you won't regret that when you try to scale."], [12, "The linked Medium article is way better than OP's link. It describes all the voodoo magic that PostGIS is doing to improve the efficiency of point-in-polygon queries. The author glosses over the indexes they created, but those are the most important part of doing any  large scale GIS queries. \n\nLink: https://medium.com/@buckhx/unwinding-uber-s-most-efficient-service-406413c5871d#.vdsg0fhoi"], [11, "I don't know it the author is reading this, but there is a typo in his about section: \"www.postgresq-support.de\".\n\nFurthermore on postgresql-support.de the footer links \"Kontakt\", \"Impressum\" and \"Blog\" seem to be pointing to a staging system. The non-accessible imprint may even have legal implications."], [2, "This is a weird post. First off he says that Uber fucked up by only getting < 5 ms 95% of the time, and the posts some SQL snippets and then claims their version is 40 times faster...but doesn't provide a benchmark or any kind of fair comparison."], [2, "> The results are very promising. Our version is around 40 times faster than the Uber one.\n\nPretty sure Uber's systems are running more then 1 query at a time, and likely has other checks and balances, and also includes the time from Go -> DB -> Go and not just the DB call."], [2, "As one comment on the post points out, Uber's cars move, a lot. Can you regenerate your indexes to keep up with that?"], [2, "This is so far off. "], [-1, "Dumb"], [-4, "Please add node.js label"]], [[{"comment": "Maybe I'm dumb, but that blog post was clear as mud to me. \n\nI didn't see how the indices were created, I didn't understand the logic behind the magic numbers used to create the equivalency to the Uber DB, I didn't understand the logic behind how the particular shape/point coordinates (more magic numbers, to me) are equivalent to what Uber is doing, and finally I missed actually seeing the \"promising\" results on the blog page in terms of screenshots of query output time measurements etc.", "id": "d2w76kl"}, {"comment": "Not dumb at all. It's nothing more than \"LOL - I can do this tiny little limited operation faster than Silicon Valley all-star with little to no context or abstract thinking about the problem set. Aren't we so smart?\"", "id": "d2w7f6n"}, {"comment": "Yeah, that's how it sounded to me. I'm sure most developers can make a simple sample app that deals with the data the guy posted and get the quoted '&lt;95% 5ms' response time while running on your laptop. That's in no way comparable to running a huge worldwide operation like Uber. ", "id": "d2w7z95"}, {"comment": "I dunno, I have a proprietary CRM running on a single VPS instance that makes half a dozen database calls with most page loads, and still posts response times of 70ms. That other post that was bragging about \"look how fast my site is\" is using a ton of optimizations that resulted in his simple blog post being *slower* than my entirely *un*-optimized system, with zero server OR browser caching.\n\nAnd my database architecture is far slower than it should be, by virtue of me not being a DBA.\n\nI said it there and got downvoted for it, but I'll say it again here: site complexity is *not* the major factor in page response times. It's network latency. We tried one host, the *exact* same code with the *exact* same local database structure was taking 1.5s or more to respond. Current host is 70ms.\n\nBlame the code all you want. You're most likely wrong. Host quality has *infinitely* more to do with response times than code quality.", "id": "d2w901o"}, {"comment": "That other blog post was loaded within 200ms for me. Completely, with all assets. Subsequent loads were 30ms, and 60ms until render.", "id": "d2w9wpw"}, {"comment": "Hit ctrl+f5 - you're probably getting a browser caching effect", "id": "d2wj8p8"}, {"comment": "No, you know how I know these numbers? Network panel of chrome. \n\nAnd you know what option I always have enabled there, and had enabled there? \n\n[Disable cache](http://i.imgur.com/sRmQhsR.png)\n\nThat is also the way I distinguished between the first and subsequent loads. \n\nI know how to measure page speed for the most part.", "id": "d2wlro4"}, {"comment": "Good network latency is a prerequisite for a fast-loading site just as snow efficiently implemented site is. In fact, the time it takes to load a page is the sum of the networking time (which depends on latency and bandwidth) and processing time (which depends on the speed of the server and the efficiency of the implementation) - and obviously the performance of the unit rendering the page. ", "id": "d2wgbi2"}, {"comment": "No you aren't dumb, but the post was for insiders, written in a typical German style. He doesn't care about your objections, because his message is, that he doesn't need special code and is faster. The example is so fast done, everyone at Uber can check the results in a short time. Why should he invest more time?\n\n", "id": "d2w8zyw"}, {"comment": "> written in a typical German style\n\nNo idea what you have against Germans, but.. what?", "id": "d2wekp9"}, {"comment": "Your idea I have something against Germans is funny. Tbh. sometimes I prefer the German academic style because it's extreme compressed while anglophone academic texts are lengthy and pedantic. The latter is better when you are have no idea about a field, while German texts are better in the case you want to build an abstract for yourself. ", "id": "d2wf7sn"}, {"comment": "> German academic style \n\nIs that an actual documented thing, or are you being racist? In my experience I've always perceived germans to be both effective and pedantic.\n\nEDIT: Just downvote me then, typical french acting. /s", "id": "d2xpef6"}, {"comment": ">Why should he invest more time?\n\nBecause his \"quick and dirty\" solution didn't solve the problem at all. He ran some code on his laptop and claimed that the latency was better, without having any insight into the problem space.\n\nDid he also load test his solution given uber's scale, which is probably doing thousands upon thousands reads and writes per second? Can Postgres be tuned to handle that kind of database trashing?\n\nIt remains to be seen, but given the laziness of the author, I'm willing to bet that Uber's engineers have nothing to worry about.", "id": "d2wgq86"}, {"comment": "1) If the problem has a cost of  O(n^m) with m>1 I would agree. But nobody had mentioned it and I don't know. \n\n2) The problem isn't about writing data, because a users position is tested against a waste amount of data. \n\n3) Yes Postgresql is capable of much including indexes on geographical and nosql data. \n\nThe rants on the authors are weird because most of them don't recognize a blog is a just a blog and not an academic work and most of the rants here aren't better than the author. ", "id": "d2wh09f"}, {"comment": ">Can Postgres be tuned to handle that kind of database trashing?\n\nYes...", "id": "d2x60od"}, {"comment": "Postgres can easily scale out for reads. With 40 machines that they use it could handle far more requests than their solution.\n\nThe only problem that I can see is number of updates (the master server would have to be a bit powerful), but they did not talk about it in their article. It probably would be high but still much lower than their reads.", "id": "d2x6a3f"}, {"comment": "I'm also unclear if they just traded memory for execution time. Depending on pricing, that may be a terrible trade at Uber scale.", "id": "d2wnmv7"}, {"comment": "I do not see any reason to think so given that the data set is small enough to fit in memory and that there is no reason for ST_contains to allocate a lot of memory.", "id": "d2womxp"}, {"comment": "This step \"After applying some nice indexing\" just sounds incredibly vague to me.\n\nEdit: https://medium.com/@buckhx/unwinding-uber-s-most-efficient-service-406413c5871d#.lbj17sn3i\n\n*Much* better link that explains what's going on and goes into detail on each potential indexing approach. Clearly Uber did not have a great approach. I just wasn't able to parse the indexing difference between \"throw it into PostGIS and index\" and Uber's approach from the OP blogpost.", "id": "d2wpghu"}, {"comment": "Yup, the linked article is poor and with lots of hand waving, but given my knowledge of Postgres and indexing I think the author is correct. He just does not explain himself well enough.", "id": "d2wrubo"}, {"comment": "[deleted]", "id": "d2w9r79"}, {"comment": "10/10 rustled my jimmies ", "id": "d2wv87m"}], [{"comment": "Maybe they could have used some of that prototyping ability [to make their website faster](http://i.imgur.com/kOfi9la.png).", "id": "d2w7lxh"}, {"comment": "yep, they don't use any caching to generate the page. every time someone loads it it hits the server, makes calls to postgres (slow) and sends back the document.", "id": "d2wh90l"}, {"comment": "Oh God, I wonder how bad our college project would fare... ", "id": "d2wcbhf"}, {"comment": "Since you probably access it through your college's local network. It'd probably be very fast, regardless of the bloat.", "id": "d2wcfwt"}, {"comment": "Hahahahahahahah, oh man that's a funny one... \n\nOh wait, you're being serious.  No, first of all, they have the 80 and 8080 ports locked (if I'm not mistaken), and second, the connection here is horrible.", "id": "d2wcl9g"}, {"comment": "College project as in a project that you did for a course in college, or a project you did in college that has nothing to do with said college? If it's the former, and hosted on the college's servers while accessing it within the same network, then pretty fast. If it's the latter, then that depends on how much you're paying your ISP.", "id": "d2wd5ia"}, {"comment": "Erm, question: did I do something to enrage you or others you may know to keep my upvote count on the negative side?\n\nPretty much all I said is that the website we did for a college project ain't exactly optimized for slower Internet speeds, that's the first comment I made. Your answer to it was a nice assumption, to which I respond that we didn't run that website on a college server during the project defense (or revision, whatever you prefer), and that we ran it on one of the team's laptop. Regarding the 80 port, all I know is that websites don't work on the Wi-Fi network, which is shit, so that explains the laughter comment. I apologize if for some reason I have offended you or others, and if you have any other questions, please let me know and I will answer to the best of my ability. ", "id": "d2wqn97"}, {"comment": "> did I do something to enrage you or others you may know to keep my upvote count on the negative side?\n\nNaw, your post just sounded a little out of place and I guess that spooked a lot of people the same way spam does. \n\nFirst you mention some \"college project\". Context isn't enough to assume that you're talking about your website's latency. Then you talk about blocked port 80 and 8080 which shouldn't affect speed at all. Just run your server on another port range assigned to you. Oh and local network latency is very low so you'd have to be using decade-old hardware for it to be slower than the internet. If you're outside a carrier hotel, the internet is sloooow. ", "id": "d2wvhhw"}, {"comment": "No, not really. I definitely didn't do any down voting.", "id": "d2wxtty"}, {"comment": "First, and no, we don't host it on the college's servers, we actually had to defend it on a laptop which was both the DB server and the Web server. ", "id": "d2wdp8v"}, {"comment": "80 out is firewalled?  \ndo they provide you a proxy to use then ?", "id": "d2wd9nx"}, {"comment": "Colleges generally don't want people on their networks hosting web sites for a variety of reasons: using excess bandwidth, copyright infringement, etc.", "id": "d2wjbwo"}, {"comment": "of course 80 in is firewalled (if he even gets a public ip)  \nI thought he meant 80 out was firewalled", "id": "d2wkx9n"}, {"comment": "Yeah. Why don't they do Html server-side rendering in custom SQL stored procedures or alternatively C++?! Much faster and better than all slow stupid Java/PHP/JS Web frameworks combined </sarcasm>", "id": "d2w8dde"}, {"comment": "It's not a question of rendering speed - that particular page [makes 125 web requests](http://i.imgur.com/ZPe5nsI.png) on every page load. They should either concat their JS and CSS files to reduce the number of requests, or at least use HTTP2.", "id": "d2w8pap"}, {"comment": "It's a blogpost with no interactive parts that I can see. They won't need JS at all.", "id": "d2w9yr1"}, {"comment": "Navigation is no interaction? Sure, navigation works with plain html links as well, but single page sites have the advantage of reducing the size of subsequent requests (not saying this site is a single page site).", "id": "d2wa9mg"}, {"comment": "Navigation works just fine on that website and I'm running NoScript and yes I'm just commenting about this website.", "id": "d2wagck"}, {"comment": "Same here, I just commented on the assumption that a blogpost wouldn't need JS at all - that doesn't have to be true.", "id": "d2wco5p"}, {"comment": "Host quality also has a huge impact there, and don't even fucking pretend it doesn't, because I'm tired of being downvoted for pointing out the fact that network latency is a thing.\n\nI have a massive proprietary CRM that we've been working on finding the right host to migrate to. Our last attempt resulted in VPS hosting with website response times of around 1.5s.\n\nThe new VPS host has response times of 70ms.\n\nSame exact code, same exact local database, same infrastructure.\n\nThis day and age, code quality is peanuts compared to server response time. Shit host, shit response, plain and simple.\n\nDownvoters, please at least offer reasons why you downvote, because I know you're going to. You hate the concept that a massive CRM that makes half a dozen database calls *per page request* can have a faster response time than your static HTML page.\n\nIT'S THE HOST, BABY. ", "id": "d2w92lb"}, {"comment": "Network latency is one thing, but you're VPS-hosted which probably isn't going to do you any favours either. Why not take your *massive* solution and spend a little more money getting a server for it?\n\n> This day and age, code quality is peanuts compared to server response time. Shit host, shit response, plain and simple.\n\nI can offer plenty of examples where I've seen developers slow down applications by making ridiculously large dataset calls to databases and only filtering when it gets back, or not implementing any caching strategies.\n\n", "id": "d2wae55"}, {"comment": "You mean like an Amazon EC2 instance, which are also just VPS servers and power a large portion of the web? VPS solutions have come a long way, reducing the friction between the virtualization layer and the hardware itself. In my latest experiences of moving from dedicated hardware to VPS solutions (like AWS, DigitalOcean, and Linode) for some proprietary Rails and and NodeJS apps and two OwnCloud instances, there have been no differences in performance. In fact in some cases I am getting better performance and response times. Don't forget that network latency isn't the only issue. Response are also dependent on the software and languages being used. Node will provide faster response times than Ruby, just as Nginx will typically respond faster than Apache depending on your config. So it's not really fair to rip into someone for using VPS servers nowadays..\n\nAs for the code quality, I wholeheartedly agree. Same goes for server config. A puma quad core server with 16GB RAM  and a single worker using 16 threads will barely hit .2 CPU usage on one core, even though it's plowing through a large set of queries with some R processing and slowing down the system for other basic users. Whereas the same puma server with one worker per core and 16 min and 64 max threads will easily peg the cores around .9 when processing the same heavy queries and R processing from 10 different users simultaneously, and the system will still be responsive for the basic users.", "id": "d2wdjxh"}, {"comment": "I concede that, if you're using a tier 1 provider, network latency probably isn't going to be a problem for you.\n\nEdit: Also, not sure why you're being downvoted. What you said is perfectly reasonable.", "id": "d2wglpx"}, {"comment": "You're getting down voted because you're being idiotically simplistic. Performance is not an either/or question. ", "id": "d2wig7m"}], [{"comment": "What did I just read? Some guy took a subset of a massive amount of data and tells people smugly that he's beaten Uber?\n\nThe use case is limited whereas Uber's clearly isn't.\n\nIt's like me creating a basic OS implementation and telling people I've just beaten Apple and Microsoft at their own game.", "id": "d2w8efv"}, {"comment": "... more specifically an os that opens a text document in 5ms but has no other functions whatsoever...", "id": "d2w9vep"}], [{"comment": "> even developing the business logic is faster with PostgreSQL\n\nRight, because that's where you want your business logic, in the database. I'm sure you won't regret that when you try to scale.", "id": "d2wfsda"}, {"comment": "Sometimes yes, sometimes no.\n\nAs much as possible I put my \"business logic\" in tables. That requires more sophisticated SQL, but eliminates the need for code pushes when basic rules change.", "id": "d2x2aw7"}, {"comment": "I always hear these arguments about putting business logic in the database or not. Seems like database experts think it can be useful from time to time, while general programmers/engineers rage against it like it's the plague. What even constitutes \"business logic\"? To me a lowly NOT NULL constraint is some degree of business logic, and I can't understand why anyone would object to that...I guess if you're trying to code an entire complex application in MySQL stored procedures, then sure that's a terrible idea...", "id": "d2xgvpl"}, {"comment": "Back in the 90's we were taught to actually use the database as it was designed, which included a lot of stored procedures because, quite frankly, some code does belong in the database.\n\nThen people started taking it too far. They'd use it for all kinds of random things like FTP downloads, CSV parsing, and HTML generation. I've even seen stored procedures that just validate some parameters without ever touching the database.\n\nSo we swung too far in the other direction and started using ORMs. What was originally meant as a tool for quick and simple queries became the \"one true way\" and now we see massive amounts of data being needlessly shuffled between databases and applications.\n\n", "id": "d2xj86h"}, {"comment": "Yeah I pretty much agree that a happy medium is nice. I'm generally finding myself working at companies where they use a database (often MySQL) as a bit bucket and build these layers on top of it - sometimes a Java method will process data in a row by row fashion from a database in a way that is much more complex and hits the database harder... I often intervene with a view or function that solves the problem more neatly and quickly. Sometimes I'm met with resistance out of principle (\"no! business logic in db is bad!\"), sometimes not.  \n  \nMy last job was a short gig at an all Oracle shop where they did *everything* in the database to an absurd level - credit card processing for example. The company's main application was written in Oracle Forms, consisting of a tangled mess of triggers (each of ~1000 tables had multiple triggers) and packages. Unmaintainable.", "id": "d2xk74g"}, {"comment": "Stored procedures and triggers ftmfl.\n\nWe have lost so much time trying to migrate away from such a thing. Yay for vendor tie in as well.", "id": "d2wxxff"}, {"comment": "Brings back terrible memories of trying to update and debug PL/SQL.", "id": "d2wjr9s"}, {"comment": "Not all databases suck as much as oracle.", "id": "d2x29dd"}, {"comment": "With the proper tools there's nothing inherently bad about this. Most developers who seem to rail against PL/SQL seem unaware that there are tools for instrumenting your code, even stepping through it like any other debugger...And that there's a slew of database objects available to you other than stored procedures and triggers. (I definitely agree that triggers=yuck except in a few special circumstances...)", "id": "d2xgzbo"}], [{"comment": "The linked Medium article is way better than OP's link. It describes all the voodoo magic that PostGIS is doing to improve the efficiency of point-in-polygon queries. The author glosses over the indexes they created, but those are the most important part of doing any  large scale GIS queries. \n\nLink: https://medium.com/@buckhx/unwinding-uber-s-most-efficient-service-406413c5871d#.vdsg0fhoi", "id": "d2wdo5e"}, {"comment": "Very nice article. \n\nFrom my understanding, @buckhx's work and Uber's work could be compatible. One is focused solely on the geo-fencing problem while Uber was about switching from a nodejs architecture to a microservice  with various services for read/write ", "id": "d2wf93o"}], [{"comment": "I don't know it the author is reading this, but there is a typo in his about section: \"www.postgresq-support.de\".\n\nFurthermore on postgresql-support.de the footer links \"Kontakt\", \"Impressum\" and \"Blog\" seem to be pointing to a staging system. The non-accessible imprint may even have legal implications.", "id": "d2w7m3t"}, {"comment": "What's an imprint? How does an non-accessible imprint have legal implications?", "id": "d2wd31z"}, {"comment": "> The imprint obligation regulated by \u00a75 of the German Teleservices Act (TMG) \"General information obligation\" and the \u00a755 Rundfunkstaatsvertrag (RStV) \"Information obligations and information law\".\n\n> For reason of information alone, you should have an imprint on your website, so that your visitors know who is responsible for the website. And should there be any legal quarrels, a address for service should be available.\n\nhttp://www.own-free-website.com/howto/General-Questions--10/Do-I-need-an-imprint-on-my-website-68\n\nBasically, it's a legal disclaimer for a website, and is especially relevant for business-related sites.", "id": "d2we4g6"}, {"comment": "His company is Austrian though, but maybe they have an equivalent law.", "id": "d2wouvq"}, {"comment": "Yeah, they have something similar.", "id": "d2wpdmp"}, {"comment": "Heh, I wonder if anyone enforces laws like that. ", "id": "d2wvl97"}, {"comment": "Thank you.", "id": "d2wy18s"}, {"comment": "\n\n>The non-accessible imprint ~~may even have~~ has legal implications.\n\nThe only question is if someone is going to nag the owner of the site.\n", "id": "d2w9n40"}, {"comment": "In Germany and Austria, typically there is.", "id": "d2waaqv"}], [{"comment": "This is a weird post. First off he says that Uber fucked up by only getting < 5 ms 95% of the time, and the posts some SQL snippets and then claims their version is 40 times faster...but doesn't provide a benchmark or any kind of fair comparison.", "id": "d2wbxv8"}], [{"comment": "> The results are very promising. Our version is around 40 times faster than the Uber one.\n\nPretty sure Uber's systems are running more then 1 query at a time, and likely has other checks and balances, and also includes the time from Go -> DB -> Go and not just the DB call.", "id": "d2wi6m2"}], [{"comment": "As one comment on the post points out, Uber's cars move, a lot. Can you regenerate your indexes to keep up with that?", "id": "d2xat7c"}, {"comment": "That's not what this is for.  It's for finding out when a point is in a \"geofence\", where is geofence tends to be set up around a neighborhood, landmark, etc.  (I know the blog post was written poorly, but read the Uber document if you disagree.)", "id": "d2xihn5"}], [{"comment": "This is so far off. ", "id": "d2wbaj9"}], [{"comment": "Dumb", "id": "d2wmnjw"}], [{"comment": "Please add node.js label", "id": "d2w91jg"}]]], "53efqz": ["Tulip: A Language for Humans (Strange Loop talk)", "2016-09-19 02:07:08", 0, "https://www.youtube.com/watch?v=lvclTCDeIsY", [[12, "Tulip: A Language for Humans (unless you're a \"cis white male\")"], [10, "A gender politics-oriented language?"], [10, "Any TL;DW that actually constructively addresses the contents of the video?"], [10, "I don't understand. Why even bring in gender? What does it have to do with language design? "], [7, "Great-looking language. It's exactly the language I've wanted for some time (a functional, fast scripted language that's feature-rich without needing a massive build system). Clearly a lot of thought has gone into this to ensure a solid foundation while it's in the BDIC phase well before any kind of bureaucracy is established.\n\nShame about the aggressive stances on gender politics. I might think of contributing were it not for the fact that I'm a cis hetero male with literally everything to lose this early in my career. Openly touting that one's team is very much not blind to issues of sexuality and gender identity tells me there might be an overzealous, hostile atmosphere to avoid. Codes of conduct like Tulip's that demand a \"nice\" atmosphere seem like they trade open aggression on matters of opinion (as with Linux) for passive aggression. I'd rather not deal with that kind of posturing.\n\nI wish them the best, and I hope to make use of this language soon."], [6, "Well that's a shame. I don't even want to watch the video now after reading the TL;DWs here. Why in the world can't we have some peace on the issue. I for one don't care if it's a male, female or whatever, white, coloured or whatever human writing the code, but they are essentially burning everyone who is a white man at the stake no matter what their stance on this issue is. Instead of really tackling the issue of women being valued less in the software industry they are just reversing the issue by making men less valuable. Not a bit better if you ask me. These are not people who want to solve the problems for real, these are bitter people who need some kind of attention and think this is a good band wagon to hop on. Also equality has nothing to do with language design. This is one of most inappropriate places to try and start such a discussion. This project is doomed to fail with this arrogance by their maintainers. "], [3, "[Github repo](https://github.com/tulip-lang/tulip).\n\nDon't get your hopes up: no language samples in the main `README.md`.\n\nWhy do people keep doing that?\n"], [0, "This can die fast"]], [[{"comment": "Tulip: A Language for Humans (unless you're a \"cis white male\")", "id": "d7sgt66"}, {"comment": "Seems strange to make sexism a first-class concept in a programming language indeed.", "id": "d7sip0w"}], [{"comment": "A gender politics-oriented language?", "id": "d7sft7l"}, {"comment": "The language itself has no gender politics. They want to make a diverse team to design the language because I suppose there is some conception that popular language designers are almost exclusively white and male and that stifles input from would-be female or minority language designers, who may have some novel insight.\n\nI'm not sure if I buy this line of thinking but the talk is largely technical and the language itself has no gender oriented elements.", "id": "d7sszgu"}, {"comment": "Right. My comment was based on their github readme.\n\nI haven't watched the presentation in full, seems to have some neat ideas in the design.", "id": "d7svixw"}, {"comment": "> They want to make a diverse team to design the language\n\nThey don't want a diverse team, they want a femme team.  After all, they are unapologetically femme.", "id": "d7tak4g"}], [{"comment": "Any TL;DW that actually constructively addresses the contents of the video?", "id": "d7shxhy"}, {"comment": "Erlang-style dynamically-typed pure-ish functional programming. Lots of nice ideas (pervasive pattern matching, heap allocation tied to and hidden behind message queues leads to GC opitimzations,) aims to be fast (compiled/JITted to LLVM; currently faster than CPython 2.7, next target is faster than PyPy, ideally as fast as OCaml.) At least one wonky idea (dynamic scoping, but they justify it in the context of scripting ergonomics as a way to save on parameter passing.)\n\nThe gender politics is just a bit at the beginning which doesn't recur; if you can go past the fact that the authors are trying to justify carving a niche for themselves the talk is interesting and quirky. I recommend it.", "id": "d7skjf6"}, {"comment": "There's really not. Two minutes in:\n\n> I'm really sick of having languages where eventually you have some cis white men who are the people who started the language and establish the culture.\n\nMore\n\n> Tulip itself is unapologetically femme. If you are working on or in tulip, you should expect to be interacting with women who probably know more than you about tulip. ... The intention of doing ... any kind of programming is women's work. And if you don't like this you can use another language and that's fine.\n\n*nervous laugh from audience*\n", "id": "d7sj2l9"}, {"comment": "> I'm really sick of having languages where eventually you have some cis white men who are the people who started the language and establish the culture.\n\nShe's free to use Cobol.", "id": "d7svnr1"}, {"comment": "> cis white men who are the people who started the language and establish the culture.\n\nFFS...", "id": "d7stvag"}, {"comment": "The Youtube description maybe?  \n\n> There are a lot of competing ideas about what makes a language \u201cgood\u201d. This is because we as language designers still have no idea what we're doing. The design of Tulip is based on careful study of a wide variety of popular and esoteric programming languages over about 4 years. Its runtime takes cues from Erlang, and its syntax is slightly like ML, but with a few key innovations designed for repl ergonomics. Tulip is one of the new languages to come out of the language community Snek, emphasizing languages by minority designers and implementers.\n\nFrom skimming through the video at 2x and slowing down for the interesting bits, I'm really not a fan of the syntax, but their 'kill nil' ideas are really solid, and generally how I handle null in clojure & scala.  \n\nAs others have mentioned, there are some feminism mentions in the first couple minutes, but the rest of the talk is purely technical.  ", "id": "d7skjhf"}, {"comment": ">  emphasizing languages by minority designers and implementers\n\nWhy would it matter if the designer/implementer is in a minority?\n\nLeave politics out of tech.\n", "id": "d7sqv1l"}, {"comment": "Their belief is that there is a significantly large subset of people that have a desire to contribute to open source software that don't because they don't feel like they fit in.  By marketing this as \"femme tech\" they attempt to gain contributors from that group.  ", "id": "d7t1x90"}], [{"comment": "I don't understand. Why even bring in gender? What does it have to do with language design? ", "id": "d7sjotv"}, {"comment": "Because it smashes the patriarchy of course!", "id": "d7sr76g"}, {"comment": "Any time a long term project lasts long enough, a community arises around it. If this project picks up traction, they want to consciously inform the kind of community that it develops. I don't think that's such a crazy thing to want, and if they want it they may as well be upfront with it.", "id": "d7suxr1"}, {"comment": "Maybe it does? There *are* strong normative constraints at play in language design (being \"C-like\" or the deceptively neutral \"familiar-looking\" are deal-breakers; to give an example, the people at Facebook wrote an OCaml pre processor just to give the syntax curly braces and it was hailed as a godsend) and most language discussions can't seem to get past syntax bikeshedding (Perl6, OCaml, APL/J/K seem to be the perennial \"languages we love to hate.\") Maybe gender imposes such normative constraints, maybe it doesn't, but until someone tries to do the experiment of thinking of gender as a constraint and a generating force in PL design, we will never know.", "id": "d7sl4o8"}, {"comment": "It doesn't even need be that gender has any direct bearing on language design, and the authors don't claim that (at least, not in the very short spiel in the video). It's not necessarily that women will have different or better ideas than men. It's that some people with different or better ideas are women, but they aren't presently part of the community in the same way that men are.\n\nWhy they aren't part of the community is a big and complicated question, but it seems obvious to me that creating a community to directly engage women in language design is a very reasonable approach to changing things for the better.", "id": "d7smfcn"}, {"comment": "Good point, though I got the impression that Tulip being an avowedly \"femme language\" hinted at design implications. Of course I have nothing to base my impression on other than a vague intuition, so I admit I might be overstating the case.", "id": "d7sn26k"}, {"comment": "I think you might have got that impression from her saying, \"Tulip is unapologetically femme,\" but I think how she continues makes it clear she is referring to the community and marketing:\n\n>If you are working on or in Tulip, you should expect to interact with women who probably know more than you about Tulip. Our branding is very femme, our core team is all women, and the intention is that the act of doing distributed systems programming or embedded programming or any kind of programming with Tulip is women's work.\n\nI took this as saying that one of the project's goals is to appeal to and engage with women. But, yeah, I see why you got that impression, and I don't discount the possibility of what was meant.", "id": "d7snut4"}, {"comment": ">but they aren't presently part of the community in the same way that men are.\n\nBecause they choose to segregate themselves off like this.", "id": "d7so0nd"}, {"comment": "There is no history of women or other underrepresented groups creating sub-communities like this. Clearly, there is some other reason for their underrepresentation, and I would argue that, in fact, it's a very complex interaction of many different issues that cannot be reduced to blaming Tulip's authors (regardless of how we might feel about their effort). \n\nOne really big factor is that women simply don't go into and stay in CS (academically, as a hobby, or as a career) as much as men do. Some of that is systemic cultural bias (computers are still viewed as something more for boys) and bad hacker culture making women not try or those that do try feel unwelcome. Some of it is even women consciously avoiding the discipline due to their own doubts and biases. \n\nI think marketing to women is a smart attempt at overcoming some of these problems. Yes, it has downsides. But if we think that the problem is more that there are too few women participating (instead of too many segregating themselves), it's at least reasonable to consider whether this is a good strategy. ", "id": "d7sq6rf"}, {"comment": ">There is no history of women or other underrepresented groups creating sub-communities like this.\n\nThat's possibly the most incorrect thing I've read this month. \n\n>Clearly, there is some other reason for their underrepresentation, and I would argue that, in fact, it's a very complex interaction of many different issues that cannot be reduced to blaming Tulip's authors (regardless of how we might feel about their effort).\n\nThey're underrepresented because they aren't interested in it. Peoples' reasons for being uninterested in programming as a career is none of our business. \n\n>One really big factor is that women simply don't go into and stay in CS (academically, as a hobby, or as a career) as much as men do.\n\nAnd why would they? Why does that have anything to do with you?\n\n>Some of that is systemic cultural bias (computers are still viewed as something more for boys) and bad hacker culture making women not try or those that do try feel unwelcome. Some of it is even women consciously avoiding the discipline due to their own doubts and biases.\n\nAnd all of it is their own personal reasons that have nothing to do with any of our actions. Women don't avoid programming. Girls do. And girls avoid it because they aren't interested in it.\n\n>I think marketing to women is a smart attempt at overcoming some of these problems.\n\nWhat problems? None of those things are problems. Nobody is concerned about women not wanting to do mining. Why aren't women becoming miners? Why aren't women going into forestry? People only care about women not going into what they see as an easy, low-stress, low-danger, high-paying profession. \n\n>we think that the problem is more that there are too few women participating (instead of too many segregating themselves), it's at least reasonable to consider whether this is a good strategy.\n\nIf people want to go into this industry they can. It's by far the easiest of all professions to get into. Compared to law, academia, medicine, accounting, etc. programming is basically trivial.", "id": "d7sycsb"}, {"comment": ">That's possibly the most incorrect thing I've read this month.\n\nYou claimed that women presently aren't part of the language design community because they, \"choose to segregate themselves off like this.\" So if I'm so incorrect in saying that there is no history of this segregation, it should be a simple matter for you to point to examples that explain the long-standing fact that women aren't participating in these communities.\n\nI don't think you can. Women-centric groups that aren't focused in programming, like Women In Technology, are a phenomenon of the 2000s. The women-centric, programming-focused groups, like Girls Who Code, are just a few years old. Groups focused on attracting women to a very niche area of CS are novel. It's very much in evidence that these groups are a _response_ to the fact that women largely left technology in the 1980s and have yet to come back.\n\n>They're underrepresented because they aren't interested in it. Peoples' reasons for being uninterested in programming as a career is none of our business.\n\nThat's extraordinarily reductive. Unless you believe that women are genetically predisposed to be less interested in programming, the fact that they are less interested than men is due to external factors. People grow up in a culture which they both shape and are shaped by. We don't need to simply accept that our culture discourages women and minorities from entering the field.\n\n>Why does that have anything to do with you?\n\nIt's something I care about having been in this industry for 20 years. One big reason I care is entirely selfish. I do a lot of hiring, and I see a lot of shitty candidates. The fact is, no matter how inclusive we commit ourselves to being, the talent pool is still very shallow. Getting more people into the industry is important simply because the more people there are, the more qualified people there are.\n\n>People only care about women not going into what they see as an easy, low-stress, low-danger, high-paying profession.\n\nWell, I don't know about \"only\" (there's certainly initiatives to get women involved in forestry), but, uh, yeah, no shit. There are far more reasons for people to not enter difficult, stressful, dangerous, and unrewarding professions. It's a cop out to say women and minorities don't go into an easy, low-stress, safe, and high-paying profession because, \"they're not interested.\"", "id": "d7ta7ao"}, {"comment": "Our culture doesn't discourage anything. *That* is reductive. Blaming everything on culture is reductive. Saying that women aren't interested in computer science is not reductive. It's objective fact. They aren't. They aren't interested in maths either. \n\nYou can claim there's no genetics to it, but that's almost certainly untrue. Women are almost universally on average less interested in technology, computer science, programming, mathematics, gaming, reddit, IRC and the internet in general.\n\n>Well, I don't know about \"only\" (there's certainly initiatives to get women involved in forestry), but, uh, yeah, no shit. There are far more reasons for people to not enter difficult, stressful, dangerous, and unrewarding professions. It's a cop out to say women and minorities don't go into an easy, low-stress, safe, and high-paying profession because, \"they're not interested.\"\n\nYet nobody ever talks about getting men out of dangerous professions. Men are systematically discriminated against by our culture, according to you, by being 'encouraged' to go into extremely risky jobs. Women don't do that. Why should women get to avoid the high risk jobs but then also get to go into the easy high-paying jobs? That's not fair. ", "id": "d7tygnl"}, {"comment": "In the early 1980s, women made up nearly 40% of CS graduates, and it was actually trending up. But there was an inflection point in the mid-1980s. By the mid-90s, the percentage of women in CS had fallen to 25%. Today, they represent around 10% of graduates. Genetic factors cannot possibly explain this dramatic change over such a short time period.\n\nIn any case, it seems to me that we are at an impasse. I think we understand each other's positions at this point, but we disagree on _reality itself_. You believe that women aren't interested in CS for hardwired and unknowable/personal reasons; that systemic/cultural biases are not a substantial contributor; that women won't ever be interested in CS; and we should just accept that. I believe that women's interest in CS has diminished for a large number of reasons, some of which have been shown to be systemic and cultural biases against women; that this is a serious but solvable problem; and that (even if you're right) we should work to be more inclusive because an industry absent more than half the population is not as robust and healthy as it could be.\n\nI don't see a constructive place to go from here. We could simply repeat ourselves over and over, but I haven't found you persuasive, and you aren't finding me persuasive. Absent a better idea, I'll step out of the thread. Thanks for the discussion.", "id": "d7u2jd4"}, {"comment": "You are completely bonkers. We do not have testing standards for the effects of gender bias that properly control for other biases, and other cultural biases are clearly at greater play than the lens of gender.\n\nPlease fucking give up the witch hunt.", "id": "d7smbrm"}, {"comment": "I hunt no witch, I make no substantive argument regarding gender issues in PL design other that it seems interesting to me to experiment including them in the design process. If you feel persecuted that's something for you to work out, but in any case refrain from insulting me.", "id": "d7sn8ju"}, {"comment": "I think that exploring these new concepts is best done through satire. C+Equality does that pretty well.", "id": "d7so2tk"}, {"comment": "I wonder what the reaction would be if the satire were directed in the opposite direction. In any case I find it interesting to think on the possibilities of taking PL ergonomics outside the dismally dominant C+UNIX paradigm of the last 30 years. If personal identity is a motor for such explorations I welcome it, even if it's not the political stance I choose or endorse.", "id": "d7son3h"}, {"comment": "Personal identity should never be that motor--we have countless examples of why tying a concept like programming to a person's existence as an ego does not work.\n\nThis is not about politics, but about the philosophical concept of trying to attach yourself to something that has no latch-points for said personal baggage.  This is why their talk is so focused upon those points--because they cannot bake it directly into the language without it becoming harmful to the utility of the device.", "id": "d7t3ve5"}, {"comment": "That literally makes no sense whatsoever.", "id": "d7snzy4"}, {"comment": "> There are strong normative constraints at play in language design \n\n... examples?\n", "id": "d7sqwsf"}, {"comment": "From last year's Strangeloop, https://www.youtube.com/watch?v=uEFrE6cgVNY\n\nAndreas Stefik talks about research that has revealed that some keywords like `for` that are used in most programming languages are among the worst possible choices for a keyword that does what for does.  \n\nI don't think being femme really helps in that specific case, but it is an example of poor language design choices propagating to new languages purely because \"that's how it has always been\".", "id": "d7t26kc"}, {"comment": "> being \"C-like\" or the deceptively neutral \"familiar-looking\" are deal-breakers; to give an example, the people at Facebook wrote an OCaml pre processor just to give the syntax curly braces and it was hailed as a godsend\n\nExamples of appeal to tradition, familiarity or to a talent pool that is sought after and not to be \"alienated\" by \"weird syntax\" appear weekly on this sub.\n", "id": "d7srcx0"}, {"comment": "Perhaps those are normative because it works?", "id": "d7stwfw"}], [{"comment": "Great-looking language. It's exactly the language I've wanted for some time (a functional, fast scripted language that's feature-rich without needing a massive build system). Clearly a lot of thought has gone into this to ensure a solid foundation while it's in the BDIC phase well before any kind of bureaucracy is established.\n\nShame about the aggressive stances on gender politics. I might think of contributing were it not for the fact that I'm a cis hetero male with literally everything to lose this early in my career. Openly touting that one's team is very much not blind to issues of sexuality and gender identity tells me there might be an overzealous, hostile atmosphere to avoid. Codes of conduct like Tulip's that demand a \"nice\" atmosphere seem like they trade open aggression on matters of opinion (as with Linux) for passive aggression. I'd rather not deal with that kind of posturing.\n\nI wish them the best, and I hope to make use of this language soon.", "id": "d7su8r5"}], [{"comment": "Well that's a shame. I don't even want to watch the video now after reading the TL;DWs here. Why in the world can't we have some peace on the issue. I for one don't care if it's a male, female or whatever, white, coloured or whatever human writing the code, but they are essentially burning everyone who is a white man at the stake no matter what their stance on this issue is. Instead of really tackling the issue of women being valued less in the software industry they are just reversing the issue by making men less valuable. Not a bit better if you ask me. These are not people who want to solve the problems for real, these are bitter people who need some kind of attention and think this is a good band wagon to hop on. Also equality has nothing to do with language design. This is one of most inappropriate places to try and start such a discussion. This project is doomed to fail with this arrogance by their maintainers. ", "id": "d7sk68t"}, {"comment": "The point *actually* made was that the core dev team is all women, so if you're interested in using the language, you have to be okay with the existence of women who know more about it than you.\n\nIf you're not okay with that, I hope I never have to work with you.", "id": "d7souj2"}, {"comment": "This makes me think the designers of the language have a pretty heavy chip on their shoulders.\n\nI don't give a damn what sex you are as long as you give me interesting tech to play with.\n", "id": "d7sqybu"}, {"comment": "Stick around the D language forums for a couple months and you'll get a rough idea where that chip comes from.", "id": "d7t67d7"}, {"comment": "Are there people who are not ok with that?", "id": "d7styu1"}, {"comment": "In fairness, there probably are _some_. But there's vanishingly few of them among the typically highly-educated, nerdy, introspective, left-leaning personality that is so common among programmers, and the assertion that the few that actually do exist wield any sort of influence/power in our industry is utterly unsupported by empirical data.", "id": "d7syli0"}, {"comment": "From what I've seen in the D and Nim communities, I expect assholes in general. I have more experience in the D community, and there I expect overtly sexist assholes. Only about ten percent of the community, but that's more than enough to sour the experience. (I recall one long thread about how D needed more women in the community. It started off by stating that all women are natural community managers and marketers willing to work for free. Not quite in those words, but that was the thrust of the argument. Every now and then, Walter Bright needs to step in and tell people to stop a specific thread, but it's always three to five posts later than it should be.)\n\nI've got a tiny amount of experience with the Elm community, and it seemed more professional.\n\nSince the designers of Tulip are women, they have a lot more experience with these problems than I do, and they are no doubt basing that announcement on their own experiences.\n\nMoreover, advertising this policy will encourage women to participate in the Tulip community. If I were a woman and had experienced both the D and Nim communities, I would be hesitant to look at the community for a new language. If the core devs said up front that they're women and don't tolerate that kind of shit, I'd be much more likely to give it a chance.", "id": "d7t71ff"}, {"comment": "Do they live in the 50's?", "id": "d7ubgcy"}, {"comment": "I'm pretty sure most of them are normal people.", "id": "d7umk0s"}, {"comment": "> Are there people who are not ok with that?  \n\nIf someone had told me 5 years ago that a language was designed by all women, I'd be a little more interested in it then if I didn't know their gender.  \n\nIf someone told me that today, I'd be significantly less interested in it in the same way as if someone told me it was done by \"all Trump supporters\" or \"by a conservative only group\" \"only liberal feminazis\" etc etc after various negative experiences with identity politics people.  \n\nI'm not interested in being involved with a hate group that hates me.", "id": "d7y7vnk"}, {"comment": "Yes but those women hate cis white men. If you are a male, if you are white or if you are cis then your participation in this community is not wanted and when you go to ask for help or contribute in any way you are going to get a lot of abuse from these hateful people who hate you for what you are not what you have to give.", "id": "d7srbl6"}, {"comment": "Maybe you didn't reach the end of their presentation when they appeal for volunteers, especially C programmers, without mentioning sex, gender, race or any other identifying characteristic.", "id": "d7srl90"}, {"comment": ">Maybe you didn't reach the end of their presentation when they appeal for volunteers, especially C programmers, without mentioning sex, gender, race or any other identifying characteristic.\n\nThey already expressed their hatred of white cis men in the start of the presentation why do they need to state it again at the end?\n\nBesides surely there are thousands of trans colored women who can contribute, they don't need white cis men.\n\n", "id": "d7swo7i"}, {"comment": "And my point is that this should not matter at all. If they are women, that's completely fine by me. But how they worded it, they made pretty clear they just hate all white men because we are all assholes. That is just not true and that's what annoys me. ", "id": "d7swhw0"}], [{"comment": "[Github repo](https://github.com/tulip-lang/tulip).\n\nDon't get your hopes up: no language samples in the main `README.md`.\n\nWhy do people keep doing that?\n", "id": "d7sqt8q"}, {"comment": "It also seems no one is currently working on it? The last commit to ./src was over five months ago. :/", "id": "d7ssa2h"}, {"comment": "Probably hard to get people to take it serious because of the SJW sabotage ", "id": "d7tz189"}, {"comment": "On that note I hate Clojures web site. All I want are code examples, I couldn't care less about you \"design philosophy\" before I get to see some damn code.", "id": "d7su0jb"}, {"comment": "[They're on Gitlab now.](https://gitlab.com/tulip-lang/tulip)", "id": "d7tvl2k"}], [{"comment": "This can die fast", "id": "d7ss7f0"}]]], "5asomx": ["Visual Studio Code 1.7 Now Available", "2016-11-03 01:27:43", 6, "https://code.visualstudio.com/", [[4, "Man I love VS Code. I wrote an Express API last night and it was just so comfortable. As a normal VS user for .NET I feel right at home doing webdev. "], [4, "What a refreshing new world we live in. Atom + VS Code + the plethora of extensions are just great. They both run fast, offer great features and are just \"modern\" (love the search function for command execution) Really nice to see both competition AND interoperability as well (VSCode offers Atom and Sublime keymaps)."], [4, "And.. now it's unavailable again :\\\n\nApparently they were bringing down npmjs.org ?"], [3, "It's been reverted back to 1.6.1 due to overloading the service at npmjs.org.\n\nGood move until they figure out a solution."], [1, "The improvements for 1.7 are listed here:\n\nhttps://code.visualstudio.com/updates"]], [[{"comment": "Man I love VS Code. I wrote an Express API last night and it was just so comfortable. As a normal VS user for .NET I feel right at home doing webdev. ", "id": "d9j6tx7"}], [{"comment": "What a refreshing new world we live in. Atom + VS Code + the plethora of extensions are just great. They both run fast, offer great features and are just \"modern\" (love the search function for command execution) Really nice to see both competition AND interoperability as well (VSCode offers Atom and Sublime keymaps).", "id": "d9j3l7b"}, {"comment": "visual code destroys atom in my experience in terms of speed, especially for large files.", "id": "d9jclpr"}], [{"comment": "And.. now it's unavailable again :\\\n\nApparently they were bringing down npmjs.org ?", "id": "d9j9k9h"}, {"comment": "They should have proxied it like yarn", "id": "d9ja6wz"}], [{"comment": "It's been reverted back to 1.6.1 due to overloading the service at npmjs.org.\n\nGood move until they figure out a solution.", "id": "d9jfb0f"}], [{"comment": "The improvements for 1.7 are listed here:\n\nhttps://code.visualstudio.com/updates", "id": "d9iyxdx"}]]], "3w7q0k": ["\"The Drive To Develop\" - JetBrains introduces major rebranding", "2015-12-10 15:04:01", 13, "http://blog.jetbrains.com/blog/2015/12/10/the-drive-to-develop/", [[24, "Is this blog article relevant to programming?"], [21, "It's official, the 80s are back in style."], [10, ">Just because it has a computer in it doesn't make it programming.\n\n-\n\n>If there is no code in your link, it probably doesn't belong here."], [7, "Kind of reminds me of the [new Freeview logo...](http://www.underconsideration.com/brandnew/archives/freeview_logo_detail.jpg)"], [4, "The stuff JetBrains makes is amazing. The IDEs are literally the only reason I code for Android in a JVM language (Kotlin)."], [3, "Can someone explain to me what's going on? What was the initial brand of the company? "], [2, "It's good to see them developing more brand consistency. I enjoyed working with their software since the day they saved me from Eclipse."], [1, "> New subscription model  \n> Rebranding  \n\n\nJetBrains you are scaring US!"], [-15, "Yay, you're \"majorly rebranded.\"  I can't be bothered to click."]], [[{"comment": "Is this blog article relevant to programming?", "id": "cxu3lnb"}, {"comment": "It's not even an article. It's an announcement for rebranding. FFS", "id": "cxu6ejc"}, {"comment": "i can't even tell what the new brand is ... weren't they always called jetbrains ???", "id": "cxu8kz1"}, {"comment": "Yes. As far as I can see, they just changed the logo and the \"tagline\".\n\nBut I have no idea how either of those will help with\n\n> People know IntelliJ IDEA. People know ReSharper. People know TeamCity, but they don\u2019t necessarily know that these products are from the same company, nor do they know what other products JetBrains offers.", "id": "cxucqag"}, {"comment": "They used to do Java stuff.  Now they probably Cloud or something.", "id": "cxunfhm"}, {"comment": "Then I guess it's a good thing the OP declared as much in the text of the link, so that one can either read or ignore it, depending on one's interests.", "id": "cxu7o19"}], [{"comment": "It's official, the 80s are back in style.", "id": "cxu2bxb"}, {"comment": "They have applied the slick, dazzling, veneer of the 1980s. Mixed with the Microsoft Pipes screen saver.", "id": "cxu3xj0"}], [{"comment": ">Just because it has a computer in it doesn't make it programming.\n\n-\n\n>If there is no code in your link, it probably doesn't belong here.", "id": "cxu72k1"}, {"comment": "That's a terrible filter. News about notable technologies(for developers) or developers don't have code in them, but I would be upset if they weren't posted in /r/programming. ", "id": "cxuluco"}, {"comment": "So tell me, why is a company painting their window shutters in any way relevant to /r/programming?", "id": "cxunlls"}, {"comment": "I agree this is a fringe article for this sub. I was more calling out your original comment about \"if there's no code in your link\". ", "id": "cxuugwa"}], [{"comment": "Kind of reminds me of the [new Freeview logo...](http://www.underconsideration.com/brandnew/archives/freeview_logo_detail.jpg)", "id": "cxu36o8"}], [{"comment": "The stuff JetBrains makes is amazing. The IDEs are literally the only reason I code for Android in a JVM language (Kotlin).", "id": "cxu5i24"}], [{"comment": "Can someone explain to me what's going on? What was the initial brand of the company? ", "id": "cxu8z0q"}, {"comment": "They have a new logo and slogan. They didn't have those before. That's it as far as I can tell.", "id": "cxubo36"}, {"comment": "Additionally the logos for all of the projects are more cohesive. It's easy to tell they are sibling products.", "id": "cxucf4o"}, {"comment": "Not a big fan though... the new PyCharm logo colors and the black rectangle on top are jarringly \"in your face\". It's okay on their website, but doesn't fit any other icons in the taskbar or window switcher.", "id": "cxunicw"}, {"comment": "IT [wasn't so bad](https://web.archive.org/web/20151204111028/https://www.jetbrains.com/)...", "id": "cxulpmd"}], [{"comment": "It's good to see them developing more brand consistency. I enjoyed working with their software since the day they saved me from Eclipse.", "id": "cxu741y"}], [{"comment": "> New subscription model  \n> Rebranding  \n\n\nJetBrains you are scaring US!", "id": "cxuapum"}], [{"comment": "Yay, you're \"majorly rebranded.\"  I can't be bothered to click.", "id": "cxu2pv3"}]]], "55nyyb": ["I'm tired of repeating function in python, so I made simple function.", "2016-10-03 18:44:44", 0, "https://github.com/phillyai/py-repeat", [[11, "Is this satire or a shitpost? Does a trivial 5-liner deserve its own github repository?"], [9, "    for x in xrange(3):\n      whatever()\n\nLooks simple enough to me."], [5, "This looks like a homework assignment to me.\n\n    >>> def repeat(func, args):\n    ...     def do(times):\n    ...         for _ in range(times):\n    ...             func(*args)\n    ...     return do\n    ...\n    >>> repeat(print, ('Hello', end=', '))(10)\n      File \"<stdin>\", line 1\n        repeat(print, ('Hello', end=', '))(10)\n\n\nThis is not how keyword arguments work. Research \"kwargs\".\n"], [3, "FYI this is basically function composition, for some great reading on it, I'd just check out [this guide](https://drboolean.gitbooks.io/mostly-adequate-guide/content/) (yes it's in JS, fight me.)\n\nWhat you're doing can be read in chapter 5 :)\n\nHere's a brief port of it I did in Python a few months back \n\nhttps://github.com/joereynolds/programming-dump/blob/master/dickarounds/function-composition.py\n\nand the same in Scheme because...why not?\n\nhttps://github.com/joereynolds/programming-dump/blob/master/dickarounds/function-composition.scm"], [2, "Um, I don't think this is valid syntax:\n\n    repeat(print, ('Hello', end=', '))(10)"], [1, "I was going to make a comment showing the equivalent in a variety of languages, but I wasn't able to figure it out for most. In ruby, though: `$n.times { fn(args) }`\n\n\n"], [0, "Nobody can use this because you don't have a license. You should add one. \n\nhttps://help.github.com/articles/open-source-licensing/\n\nAlso:\n\n    [print(x) for_ in range(10)]\n\nbut you should probably use a generator instead."], [-1, "Why doesn't every language have automatic currying? It's useful, stays out of the way if you don't care about it, and lets you avoid writing weird little functions like this.\n\nSwift actually *removed* it from the language. What the heck Apple?"], [-2, "The def do ... return do enclosure is redundant -- unless you want to use the return value, which isn't part of your description."], [-3, "Poor guy - should have used Ruby."]], [[{"comment": "Is this satire or a shitpost? Does a trivial 5-liner deserve its own github repository?", "id": "d8c75kk"}, {"comment": "Is there really a need for the saltiness?\nThis guy could just be learning and you've potentially scared him off from showing his work.\n\nNice job.", "id": "d8c9lmm"}, {"comment": "Now now now what happened to npm ... how many lines did that thingy have that was removed...", "id": "d8c8gw1"}, {"comment": "[This one?](https://github.com/stevemao/left-pad/blob/master/index.js) It's a bit less trivial than this thing.", "id": "d8cshdw"}, {"comment": "    # Python 3\n    def leftpad(msg, length, padchar):\n        return \"{:{}>{}}\".format(msg, padchar, length)\n\n    >>> leftpad(\"foo\", \"@\", 12)\n    @@@@@@@@@foo\n\nNote that Python also has `str.rjust()` in the standard library, making what I wrote useless :-)\n\n    >>> \"foo\".rjust(7, '@')\n    '@@@@foo'\n", "id": "d8cz0ap"}], [{"comment": "    for x in xrange(3):\n      whatever()\n\nLooks simple enough to me.", "id": "d8c5x5x"}, {"comment": "I just wanted cleaner code.", "id": "d8c6jfd"}, {"comment": "It's Python, the way of the snake - lots of ssszszssz isn't made for pretty coils and scales!", "id": "d8c8gav"}, {"comment": "How often do you need to call the same function multiple times with the same arguments?", "id": "d8cz71l"}, {"comment": "[deleted]", "id": "d8c6tgi"}, {"comment": "That's not \"overloading the syntax\". It's just using first class functions.", "id": "d8c936g"}], [{"comment": "This looks like a homework assignment to me.\n\n    >>> def repeat(func, args):\n    ...     def do(times):\n    ...         for _ in range(times):\n    ...             func(*args)\n    ...     return do\n    ...\n    >>> repeat(print, ('Hello', end=', '))(10)\n      File \"<stdin>\", line 1\n        repeat(print, ('Hello', end=', '))(10)\n\n\nThis is not how keyword arguments work. Research \"kwargs\".\n", "id": "d8c9itg"}], [{"comment": "FYI this is basically function composition, for some great reading on it, I'd just check out [this guide](https://drboolean.gitbooks.io/mostly-adequate-guide/content/) (yes it's in JS, fight me.)\n\nWhat you're doing can be read in chapter 5 :)\n\nHere's a brief port of it I did in Python a few months back \n\nhttps://github.com/joereynolds/programming-dump/blob/master/dickarounds/function-composition.py\n\nand the same in Scheme because...why not?\n\nhttps://github.com/joereynolds/programming-dump/blob/master/dickarounds/function-composition.scm", "id": "d8c5oh3"}], [{"comment": "Um, I don't think this is valid syntax:\n\n    repeat(print, ('Hello', end=', '))(10)", "id": "d8chaga"}, {"comment": "Sure it is, as along as `repeat`'s return value is a callable (which it is). Reducing:\n\n```\nrepeat(print, (\"Hello\"))(10)\n```\n\nbecomes \n\n```\nanonymous_func(10)\n```", "id": "d8d3omt"}, {"comment": "This is perfectly valid syntax:\n\n    repeat(print, (\"Hello\"))(10)\n\nThis (notice the keyword arg) is not:\n\n    repeat(print, ('Hello', end=', '))(10)\n\nThe implementation would be more useful if written as:\n\n    def repeat(func, *args, **kwargs):\n        def do(times):\n            for _ in range(times):\n                func(*args, **kwargs)\n        return do\n\nAnd then this would work:\n\n    repeat(print, 'Hello', end=', ')(10)", "id": "d8drl6p"}], [{"comment": "I was going to make a comment showing the equivalent in a variety of languages, but I wasn't able to figure it out for most. In ruby, though: `$n.times { fn(args) }`\n\n\n", "id": "d8c7uy5"}, {"comment": "Well not quite since you gave a hardcoded number.\n\nFor equivalency you also need to do what he did and provide the argument to a function/method.", "id": "d8c8icd"}, {"comment": "If the idea is to pass around the repeater so you can call it $n number of times just by passing a number, sure. In ruby you'd need to define:\n\n```\ndef repeat(method, args)\n  return proc {|n| n.times { method.call(args) }}\nend\n```\n\nand call it like this:\n\n```\nrepeat(fn, args).call(3)\n```\n\nBut they're pretty much equivalent. \n\nIf you want to pass around just the method, you can also do:\n\n```\n$n.times(&method)\n```", "id": "d8c9b3s"}, {"comment": "You can call the `times` method on any number in Ruby since numbers are objects.  So, it's not \"hard-coded\". It also yields the iteration starting at 0.\n\n    > num = 5\n    > num.times do |n|\n    >   puts n\n    > end\n    0\n    1\n    2\n    3\n    4\n\nWithout a block it returns an iterator, so you can call map directly.\n\n    5.times.map { |n| n*n }\n    #=> [0, 1, 4, 9, 16]\n", "id": "d8cruoe"}], [{"comment": "Nobody can use this because you don't have a license. You should add one. \n\nhttps://help.github.com/articles/open-source-licensing/\n\nAlso:\n\n    [print(x) for_ in range(10)]\n\nbut you should probably use a generator instead.", "id": "d8cuqv7"}], [{"comment": "Why doesn't every language have automatic currying? It's useful, stays out of the way if you don't care about it, and lets you avoid writing weird little functions like this.\n\nSwift actually *removed* it from the language. What the heck Apple?", "id": "d8c6lz1"}, {"comment": "because you only want to curry in like 2% of situations, and the other 98% of the time, you'd rather have an early error about using the wrong # of arguments.", "id": "d8cdezg"}], [{"comment": "The def do ... return do enclosure is redundant -- unless you want to use the return value, which isn't part of your description.", "id": "d8c5sg1"}], [{"comment": "Poor guy - should have used Ruby.", "id": "d8c8fhr"}]]], "4erutb": ["Kite - Programming copilot", "2016-04-14 20:09:23", 0, "https://kite.com/", [[3, "Okay that's cool.... It's prolly not going to be open source, however maybe someone will make a OSS clone of this...."]], [[{"comment": "Okay that's cool.... It's prolly not going to be open source, however maybe someone will make a OSS clone of this....", "id": "d22vt0p"}, {"comment": "Exactly what I was thinking. Anyway there is more discussion in the other thread:  /r/programming/comments/4erqgq/kite_programming_copilot/", "id": "d22ztf7"}]]], "43ea53": ["Sublime Text is not dead", "2016-01-30 17:34:58", 0, "https://www.sublimetext.com/3dev", [[23, "[deleted]"], [19, "It might not be dead, but why would I pay $70 for any basic text editor? Why wouldn't I just use emacs or vim? I paid $90 for PyCharm and while it's subscription based now, I get tons of built in features, a fully configurable build system, debugger, type inspection, autocompletion, etc. for tons of different languages. The most that Sublime can really offer me out of the box is syntax highlighting and some decent key shortcuts. Don't get me wrong, I love using Sublime 2 for quick scripts, but any larger project is going to have me turning to tools where I can justify the price.\n\nThe other main issue is that there's no main release of Sublime 3. Why am I paying $70 for something that isn't finished? I don't even do that with video games."], [8, "Sublime's on life support. I'm a user since 2 was released and loved it, but the fact that I can't rely on updates tells me I should venture away from it, because otherwise there *will* be the day I update my OS and Sublime doesn't start and I'm without a properly configured editor."], [4, "It's a pretty light changelog for almost 7 months of development. A reasonable person could call that dead. Not unlike post mortem spasms."], [3, "As someone who bought a license (what feels like) years ago, this is disheartening.\n\nThough to be fair, I haven't had any real issues with it over that time. Kind of nice to not have an update every time you wake your computer, like everything else seems to do these days. I still would prefer some more dev attention for a product that they charge (a decent amount) for.\n"], [1, "Well it is dead for most people, JetBrains package is just too good to ignore or not work with "]], [[{"comment": "[deleted]", "id": "czhktd5"}, {"comment": "Plus it's open source and *free*. I understand that developers have to live and make money, but you can't compete with that kind of pricing model.", "id": "czhl027"}, {"comment": "Open source is good, but might be good to not emphasize the free, pay a software creator for the value their tools have added to your work/life.", "id": "czhm84h"}, {"comment": "I do pay for tools that help out with my work flow. But with most things, if I can get something that is comparable for a cheaper price, I'm probably going to go with the cheaper option unless the more expensive one has something I can't live without ", "id": "czhmm3b"}, {"comment": "Open source developers tend to make their money on services, not products.  Free products are a huge selling point, and advertising that helps increase adoption and recognition, which in turn helps increade demand for the authors' services.\n\nFocus on free.  It makes the authors more money.", "id": "czhr6nz"}, {"comment": ">Github's Sublime clone, Atom, may be a tad slower, but, wow, the pace of development is just staggering.\n\nYeah but why did they have to write it in Javascript. Eugh. There's a reason git was written in C. It's REALLY FUCKING FAST.\n\nI want a text editor written in Rust. ", "id": "czielvw"}, {"comment": "Atom's plugin ecosystem is amazing, compared to Sublime.", "id": "czhl6uw"}, {"comment": "Can you elaborate why? Sublime has lots of plugins as well.", "id": "czhp08c"}, {"comment": "While this may be a joke, it illustrates the variety and choice available in the ecosystem.\n\nhttps://atom.io/packages/activate-power-mode\n\nYou could just count code formatters as well, but that wouldn't be as interesting.", "id": "czhpfcz"}, {"comment": "It's not a tad slower, it's a *lot* slower. It's also slower than Visual Studio Code even though it has no reason to be as they're both Electron based. \n\nI understand why those two (Atom and VSCode) aren't comparing to a native app like Sublime, but really the performance of Atom is unacceptable. \n\nI understand it used to be a lot worse though, so I guess in six months to a year it might actually be usable. \n\n**edit**\n\nI made [a video](https://www.youtube.com/watch?v=fjR5X-4--kg) to demonstrate. \n\nWindows 7, Intel i5-4670K 3.4 GHz, 16 GB RAM, running off an SSD.\n\nSublime Text 3, build 3088.\n \nAtom version 1.4.1\n\nVisual Studio Code version 0.10.6", "id": "czii58w"}, {"comment": "The Atom build says failing right now :(. I like it and I like that people are willing to put their own time into this tool that is free and every bit as capable as something that someone is charging $70 for that has horrible development pace. ", "id": "czhp7pq"}, {"comment": "download a release version", "id": "czi0ezy"}, {"comment": "I did but a broken build...a main branch shouldn't have a broken build for any significant amount of time...", "id": "czi1wgs"}, {"comment": "use apt-get/homebrew/an installer. you should not be on cutting edge builds for a project like this", "id": "czi2wn3"}, {"comment": "And a build master branch shouldn't be broken. I don't know what you are getting at. ", "id": "czi3fvr"}, {"comment": "do you want to use a text editor or talk about principles of software design\n\nno one is disagreeing with you, I am offering you a solution", "id": "czi6g1f"}, {"comment": "I really don't know what the hell is so hard about this. I have it. I said I have it. I said it's installed. This is also /r/programming so it's kind of exactly on topic. ", "id": "czi6qkh"}, {"comment": "reread this thread and imagine it from the perspective of anyone that is not yourself", "id": "czi7rg9"}], [{"comment": "It might not be dead, but why would I pay $70 for any basic text editor? Why wouldn't I just use emacs or vim? I paid $90 for PyCharm and while it's subscription based now, I get tons of built in features, a fully configurable build system, debugger, type inspection, autocompletion, etc. for tons of different languages. The most that Sublime can really offer me out of the box is syntax highlighting and some decent key shortcuts. Don't get me wrong, I love using Sublime 2 for quick scripts, but any larger project is going to have me turning to tools where I can justify the price.\n\nThe other main issue is that there's no main release of Sublime 3. Why am I paying $70 for something that isn't finished? I don't even do that with video games.", "id": "czhkvha"}, {"comment": "Wait, you have to buy sublime? I've just been closing that message everytime it pops up.", "id": "czhlmo7"}, {"comment": "No you don't have to buy sublime 2, but you do need to have a license for 3. And at the same time I really really don't like an editor that has a pop up 4 times a day asking me to shell out 70 bucks. ", "id": "czhlppr"}, {"comment": "4 times a day? Man I'm lucky if I get 4 times a week. I'm on a Linux system and it's better than using gedit.", "id": "czhlryq"}, {"comment": "I use ST2 on Ubuntu and it appears to appear every 20 saves.", "id": "czhnwmr"}, {"comment": "Yeah, I spam ctrl+s a lot which is why I see it so often. ", "id": "czho18c"}, {"comment": "Same. Every few lines or I pause to think, ctrl+s.", "id": "czho29c"}, {"comment": "its also a really nice target if you want to learn how to crack something  :)", "id": "czi5b4i"}, {"comment": "$70 is nothing if it's a tool that makes you better at your job. If it makes you 0.1% more efficient it'll still pay for itself.", "id": "czhnc5t"}, {"comment": "Except for a few dollars more I can get a tool that offers significantly more functionality. If SublimeText was $20 I might pay it but fuck a bunch of $70 when I can either get a free tool that does everything it does or spend a little more and get something like RubyMine or PyCharm. ", "id": "czhp3qp"}, {"comment": "You could pay $70.\n\nOr you could pay $0 and use better text editors.", "id": "cziekav"}, {"comment": "Becoming 0.1% more efficient would make you save half a minute over an eight hour day. Let's say you charge 100 bucks an hour. Half a minute of your time would be worth about 83 cents. At a price of 70 bucks for Sublime Test you'd have to work about 84 days like this to break even.\n\nOr you'd lose 42 minutes if you charge 100 bucks an hour.\n\nIf you charge 100 bucks an hour you can probably write Sublime Text off anyway.\n\nI don't know why I just posted this.", "id": "czhpdcd"}, {"comment": "except sublime doesnt make you .1% more efficient. theres three clones with the same features that are free and for any language with a first class IDE you're basically guaranteed to be more efficient using that instead", "id": "czi0i3p"}, {"comment": "What clones? Every clone I tried was shit in some way.", "id": "czooooh"}, {"comment": "[deleted]", "id": "czooptu"}, {"comment": "Atom is also slow. I mean really slow.", "id": "czopypn"}, {"comment": "> pen retardedly huge files which you should never be doing anyways\n\nI sometimes have to open large log files, or SQL dumps or XML files provided to me by others.  Not sure why it's not a valid use case?", "id": "czp4dkt"}, {"comment": "[deleted]", "id": "czp4rk2"}, {"comment": "Both of which are the purview of a text editor, aren't they?  In the same way Photoshop or the GIMP can open a 500 byte GIF icon, or a 40mb RAW camera file.  Two different tasks, but both under the rubrik of an image editor.", "id": "czp4vhe"}, {"comment": "> payed\n\npaid", "id": "czhnypp"}, {"comment": "Thanks, I thought that looked wrong. I haven't had my coffee yet. ", "id": "czho0r0"}, {"comment": "I use both sublime and pycharm but for different things. Pycharm for my main projects and sublime for any quick fix, script, log file or project i edit infrequently (whatever the language). So for me they dont fill the same role.", "id": "czhresw"}, {"comment": "They definitely do fill different roles, I was just comparing the price point. One has an absolutely massive amount of things built in, and the other is just a really lightweight text editor that I can't really say is any better than atom in terms of functionality. Why are they even close to the same price? Even though one is a subscription, I fail to see how sublime packs $70 worth of benefits into their text editor.\n\nAlso if you do need quick scripts and still want Pycharms syntax highlighting and type inspection and debugger, look into scratch files. They really should be advertised better. ", "id": "czhrv0k"}, {"comment": "> One has an absolutely massive amount of things built in, and the other is just a really lightweight text editor that I can't really say is any better than atom in terms of functionality. Why are they even close to the same price\n\nI've tried on a few occasions to like any of JetBrains' editors, but I just can't. They feel clunky, slow and overly cluttered with UI - generally a bad UX experience. No matter how fast the computer. Just ick. I spent way too much time tuning the interface to try and get what I already got from TextMate or Sublime.\n\nI've also tried Atom a few times. There are a few little things that just make me dislike it. For example, scrolling isn't per-pixel, it does this jumpy \"line (or three) at a time\" scrolling. OS X has really smooth, responsive scrolling ... I know it seems like a minuscule complaint, but it really makes it easier to track the lines and continue reading even when scrolling. Then Atom basically was unresponsive whenever I opened large files. I have to open large log files occasionally and I don't want to fight the editor when I do.\n\nI was a bit grumpy paying my $70 for Sublime Text 2 back in the day, but I was coming from TextMate which was also commercial software (and similarly worth it). What I loved about Sublime at the time (look at me rhyme) was I could have the same \"light-weight\" text editor across all platforms, and that was/is worth supporting. \n\nI think a lot of people, similar to myself, gave up on TextMate \"2.0\" ever coming out (which was going stagnant much as Sublime perhaps is now) and moved to Sublime, which, at the time, was very actively developed (like how Atom looks today).\n\n$70 (or less for bulk licensing) ultimately isn't that much for professional developer, or company hiring developers. \n\nI've never encountered a bug in Sublime, I use it every day for I don't know how many years now. For my needs it is \"finished\".\n\nTLDR: I prefer Sublime because I value smooth, responsive editors with the perfect balance of keyboard/mouse usability. Also I bought Sublime long before Atom existed.\n", "id": "czi6qvx"}, {"comment": "Honestly all the things you mentioned are really easy in gVim. ", "id": "cziela3"}, {"comment": "Sure, but it is vim. I don't like vim. =)", "id": "czkdwd7"}, {"comment": "May I ask why? I've never seen a satisfactory answer. It's usually just \"I tried to close it once using Ctrl-C and it didn't work, I had to press :q!, so I deleted it from my computer.\" or equivalent.\n\n'I tried it for five minutes and it wasn't immediately intuitive' is also a pretty silly argument for vim being bad.", "id": "czkqu6e"}, {"comment": "You probably won't find my answer satisfying either =p\n\n**\nEdit: I never said vim is bad. Clearly it is a very capable editor, lots of my friends/co-workers are very productive in it. It just comes down to preferences about the little things. All the following complaints are \"1st world editor problems\". =)\n**\n\nI use vim whenever I'm shelled into somewhere, or occasionally for quick edits on config files on my local machine. A number of years ago I even challenged myself to live and work in vim. I lasted about a week. I've done the same with emacs.\n\nI don't like the command/dual mode editor concept. I find it fatigues my hands to be constantly doing the key strokes for commands. I never learned to type as a traditional touch typist and maybe that is a contributing factor. I can type fast, but it isn't learned via the traditional typing method where my hands are always on the home keys. I like using the mouse about 10-30% (I'm guessing) of the time to give my hands a break.\n\nAnother sour note with vim is how often I've encountered certain keys not working: backspace, arrow keys, etc. Granted this likely shouldn't be an issue running a native vim. But that is one of the first, dark places, my mind goes to when I think about vim. It spewing escape characters into my document! I realize this wouldn't/shouldn't using some variant of vim for my native OS.\n\nAlso, there are a few features which just feel better implemented (visually if nothing else) in editors that aren't restricted to ASCI/ANSI. For example the built in file browser along the left margin in editors like Sublime, Atom and TextMate are awesome and none of the hacked-on solutions in vim or emacs really match it, imo.\n\n\nCheers.", "id": "czl7n7z"}, {"comment": ">I don't like the command/dual mode editor concept. I find it fatigues my hands to be constantly doing the key strokes for commands.\n\nI much prefer it, which is just preference. I really hate chording keys. Escape-Meta-Alt-Control-Shift is not my favourite editor. I prefer lots of quick commands to a few complex ones. I suppose that's just a preference thing.\n\n>Another sour note with vim is how often I've encountered certain keys not working: backspace, arrow keys, etc. Granted this likely shouldn't be an issue running a native vim. But that is one of the first, dark places, my mind goes to when I think about vim. It spewing escape characters into my document! I realize this wouldn't/shouldn't using some variant of vim for my native OS.\n\nThat's a terminal/terminal emulator/shell issue, nothing to do with vim.\n\n>Also, there are a few features which just feel better implemented (visually if nothing else) in editors that aren't restricted to ASCI/ANSI. For example the built in file browser along the left margin in editors like Sublime, Atom and TextMate are awesome and none of the hacked-on solutions in vim or emacs really match it, imo.\n\nAh yeah well y'see if I ever have to use Sublime I immediately press Shift-F11 so I don't have to see all that chrome. And I never use Atom because it's incredibly slow.\n\nI would much rather type `;e include/server.hpp` than have to move my hand over to my mouse, move my mouse to the right one, etc. That's all just so slow. I notice that even people that use Sublime, for instance, nearly always use keystrokes to do this. They hit the command for opening a file then type the filename and hit enter. Not ctrl-O. \n\n", "id": "czlo5j1"}], [{"comment": "Sublime's on life support. I'm a user since 2 was released and loved it, but the fact that I can't rely on updates tells me I should venture away from it, because otherwise there *will* be the day I update my OS and Sublime doesn't start and I'm without a properly configured editor.", "id": "czhn1ak"}, {"comment": "You must be on OSX.\n", "id": "czhowy4"}, {"comment": "I don't see how that relates to my point. Also no.", "id": "czhzeai"}, {"comment": "Most people in tech are. None of those fancy social websites they build run on a Windows stack. (edit: And Mac OS is highly compatible with Linux, to the point where most of your *nix dev tools basically \"just work\" on Mac).", "id": "czhxf62"}, {"comment": "You're right, the sites run on Linux stacks. ", "id": "czhyw6z"}, {"comment": "You may not know this, but Mac OS is highly compatible with POSIX systems.", "id": "czhz08y"}, {"comment": "You may not know this, but approximately 0% of servers run on Macs. Certainly not those fancy social websites. ", "id": "czib7tq"}, {"comment": "Yet we're discussing GUI text editors, so I don't think the servers used to host Facebook are particularly relevant.", "id": "cziejzo"}, {"comment": "it becomes significantly easier to work if your dev and test environments match the production environment.", "id": "czikp44"}, {"comment": "I'm not sure if you are trolling or uneducated. If you wanted some reasonable level of compatibility with a Linux stack on your personal machine and didn't want to run a Linux desktop, this is where Mac OS fits in.\n\nI do a lot of Python. I work on Linux but Mac users tell me it just works. (I had a Mac once and I can confirm this is mostly true). I don't even know how to make my stuff compatible with Windows.", "id": "cziklmc"}, {"comment": "You may not know this, Darwin (The base of OS X) has literally never in its history been POSIX compatible. It's \"close\", at best.", "id": "czmdryj"}, {"comment": "I don't what information people are feeding you but mac os / unix / linux are all very compatible with each other. Sure, not everything works exactly the same, but I'd recommend actually trying them them out before continuing this discussion.", "id": "czmfxwm"}, {"comment": "Go ahead, write a script using grep -P or perhaps tar -xzf which you expect to work on all three of those systems. After that, attempt to run a binary compiled for FreeBSD on OS X. \n\nAre they similar enough for most practical purposes? Sure. \"Highly compatible\"? No.", "id": "czmv93u"}, {"comment": "I find it difficult to assume you're taking the question seriously when you're using a grep switch marked \"highly experimental\". I didn't even know -P (uppercase P) existed. Something like that isbn't even guaranteed to work consistently across different distros of the same OS.", "id": "czmw93c"}, {"comment": "Ah, you have not been nearly thorough enough.\n\ngrep -P is only highly experimental on *some* implementations of grep. That's because there's GNU grep and then there's BSD grep. GNU grep's -P flag is not experimental: https://www.gnu.org/savannah-checkouts/gnu/grep/manual/grep.html#grep-Programs and is available on the majority of linux systems.\n\nBSD grep's -P flag is generally nonexistent, though it is sometimes implemented.\n\nThese are considerable differences in a *single* utility. You fail to have remarked on binary compatibility, and let's not forget markable differences in how packages are handled. \n", "id": "czmx377"}], [{"comment": "It's a pretty light changelog for almost 7 months of development. A reasonable person could call that dead. Not unlike post mortem spasms.", "id": "czhnlk8"}], [{"comment": "As someone who bought a license (what feels like) years ago, this is disheartening.\n\nThough to be fair, I haven't had any real issues with it over that time. Kind of nice to not have an update every time you wake your computer, like everything else seems to do these days. I still would prefer some more dev attention for a product that they charge (a decent amount) for.\n", "id": "czid2ou"}], [{"comment": "Well it is dead for most people, JetBrains package is just too good to ignore or not work with ", "id": "czjj815"}]]], "5822zs": ["Node.js Examples - What Companies Use Node For in 2016", "2016-10-18 08:57:27", 0, "https://blog.risingstack.com/node-js-examples-what-companies-use-node-for/", [[9, "Besides aync IO (which can be done is any other sane language), what are the reasons for using nodejs nowadays? I have an impression that the main reason is that front-end devs don't want to learn other languages."], [6, "Did something happen to coffee script? I never really paid much attention to it but the article just seems mention as an asside that they are exited to ditch it and go back to plain JS?"], [2, "My problem with this is that the more popular Nodejs gets the more companies looking for frontend work also happen to explicitly ask for Nodejs just because is the same language, like if for some reason a frontend specialist would be also a backend expert just because the same language is used. They always put arguments like \"code reuse\" which doesn't ever happen at high level since the domains are vastly different. Is completely ridiculous. And no I don't want to work with Nodejs, I have enough problem working with Js on the client and only would barely tolerable if I use typescript or something better."], [1, "What does the OP mean when he refers to Groupon using Node on front-end applications, rather than backend?"]], [[{"comment": "Besides aync IO (which can be done is any other sane language), what are the reasons for using nodejs nowadays? I have an impression that the main reason is that front-end devs don't want to learn other languages.", "id": "d8wxach"}, {"comment": "It's so that people who don't know how to write server applications can write server applications.\n\nThis is rarely a good idea.", "id": "d8wxorl"}, {"comment": "Hmn?\n\nThey still don't know how to write server side applications.", "id": "d8x1xo2"}, {"comment": "lmao", "id": "d8x05pk"}, {"comment": "most teams choose node.js backend for increased fatigue. let them build stuff in node for a year. then you lift that restriction. everybody is flying.\n", "id": "d8x0p8k"}, {"comment": ">  front-end devs don't want to learn other languages.\n\nAs a full stack web dev for about 8 years now, done java, .net, php, node, python and ruby. I chose node for my newest project for these reasons:\n\n- One Page apps take a lot of the work from backend, sometimes even removing the need for one with some databases.\n- Front end build tools are written in node, when you have more code in gulp/webpack files than your express server why would you bother using something else?\n- Even for cases where the server needs to do some lifting, the benefits of having the same language everywhere kills most benefits you would get from using GO + JS or C# + JS or Haskel + JS or whatever.\n\nThat and in the end I know JS well, at a certain point you know a language so well that compared to languages you don't know, you have to put in so much work to reach the same level of code quality and performance it's hard to justify.", "id": "d8wyctp"}, {"comment": "The real problem for me is the absolute shit show that the Javascript ecosystem is at the moment. The amount of different tools in the chain is just ridiculous, I've never seen any other language that even comes close to this mess", "id": "d8x1r45"}, {"comment": "Why is that a problem? Just use the tools you want to.\n\nIt requires some self restraint and knowledge of what tools you actually need, but if you get over that hump it's nice having so many tools to work with sometimes.", "id": "d8y7v3q"}, {"comment": "At a bare minimum there is at least 5 different tools or trans-pliers you need yo know and understand to even get started with a lot of the open source projects lately, its been the same for contract jobs I have taken. Its ridiculous.\n\nOnce the market settles I'm sure the tool chain will level out as it matures but at the moment its beyond a joke and completely unnecessary ", "id": "d8yhi6v"}, {"comment": "Do you miss static typing though? Or are you using TypeScript or similar?", "id": "d8wzj9o"}, {"comment": "not him, but personally i use typescript and it's been a bliss ", "id": "d8x2qr6"}, {"comment": "I'm currently using Sanctuary JS for my typing needs https://github.com/sanctuary-js/sanctuary.", "id": "d8y7xay"}, {"comment": ">  the benefits of having the same language everywhere \n\nMind naming a single possible benefit of such an enormous stupidity?", "id": "d8wzyfb"}, {"comment": "Code reuse", "id": "d8x0c0y"}, {"comment": "Shitty reason. You're unlikely to need the same code on those too different sides. And if you do, you're doing it wrong.", "id": "d8x0ddq"}, {"comment": "Learn a utility library like Lodash, or fetch API for http requests, or just a form validation where you share the constants for the form keys over a single file, or server side rendering with React. Not all of them are reasonable in my opinion, but it sounds like you have a very closed mindset already.", "id": "d8x0l79"}, {"comment": "> Learn a utility library like Lodash\n\nIs low level, is almost impossible to share any highly level logic on both sides, which is 99% of it.", "id": "d8x20ha"}, {"comment": "I didn't mean logic, just not relearning different utility libraries for the same job twice. In my daily job, I use Guava with Java, and Lodash with JS, why not use a single one for most cases.", "id": "d8xf7lh"}, {"comment": "Their utility is marginal in the long run,  and they only deal with low-level details that have nothing to do with the domain.", "id": "d8xp2px"}, {"comment": "If you want domain specific example I'd suggest socket.io for web sockets, or server side React rendering.\n\nTo me the utility is very high if you work with small teams on multiple things at the same time and you don't want context switching between languages which is a huge distraction for me.", "id": "d8xset6"}, {"comment": "All the exceptionally shitty reasons. If some hipstor scum does it this way, it does not mean anyone should follow their shitty example.\n\nForm validation constraints and all that is a good case for a *higher level* DSL translating into whatever, not for this \"common labguage\" stupidity.", "id": "d8x0nq4"}, {"comment": "Maybe none of these ideas are shitty, but you're just a shitty person other devs complain about in other subreddits.\n\nI would much rather use JS than learning another DSL to export my constants around, thank you.", "id": "d8x0w56"}, {"comment": "This is exactly why incompetent idiots like you should never be allowed to program anything at all.", "id": "d8x11dn"}, {"comment": "I personally don't do that, but it's sure tempting to do. Whatever reason people choose to do so, I hope they don't have you as their coworker, you're a piece of shit.", "id": "d8x1agf"}, {"comment": "Many people think using the same language for FE and BE is stupid, but the potential is great. Many of the libraries originally built for frontend use like lodash, momentjs, and even jQuery (which can now be used for web crawling). Code reuse hardly happens between a front end and backend *codebase* but almost always happens for libraries.", "id": "d8x0mga"}, {"comment": "Why would you ever want the same libraries for so different kinds of code?", "id": "d8x0v4b"}, {"comment": "It's really not that different. Lodash is a general utility library that provides functions that work on objects, arrays, strings, etc. Momentjs is a datetime library used for converting date formats and locales. jQuery is used server side to crawl web pages. There are many more examples like this. The only code I would say is *only* applicable on the browser is DOM specific code. This goes the other way round as well... most of the packages on npm (a package manager originally made for node) can also be used on the browser.\nIf that's not code re-use, then I don't know what is.", "id": "d8x1dga"}, {"comment": ">  Lodash is a general utility library that provides functions that work on objects, arrays, strings, etc.\n\nI.e., a set of crutches. But *why* do you need those crutches in the first place?\n\n> If that's not code re-use, then I don't know what is.\n\nTo start with, the idea of code reuse is vastly overrated.\n\nAnd, code reuse only makes sense if your problem domains are similar. Yet, backend and frontend are so obviously different that there is very little opportunity for code reuse left.", "id": "d8x1frf"}, {"comment": "[deleted]", "id": "d8xbm3f"}, {"comment": "Yes, a good example of another pile of crutches.", "id": "d8xcaft"}, {"comment": "What's enormously stupid about that? What if you could run Rust or Haskell both on the server and the frontend? Still \"enormously stupid\"?", "id": "d8x0sp4"}, {"comment": "Of course. What kind of an idiot would ever want to use the same language for such a polar pair of problem domains?", "id": "d8x0zmn"}, {"comment": "So what's your ideal setup then? JavaScript on the frontend and some statically typed language on the backend? Are there really no good backend languages that would do well in a frontend environment (through web assembly I'm assuming)? I find that hard to believe.", "id": "d8x148p"}, {"comment": "> Are there really no good backend languages that would do well in a frontend environment \n\nI cannot think of a single thing that backend and frontend may even have in common (besides some really trivial bits like validation). So, yes, there is absolutely no reason to ever use not just the same, but *similar* languages on both ends.\n\nAnd I do not think JavaScript is that suitable for the frontend (or for anything at all), it just happens to be the only option available.", "id": "d8x1dxx"}, {"comment": "Fair enough, validation does usually end up being the main feature touted.", "id": "d8x1jxl"}, {"comment": "Can you think of a single language that is good for anything?", "id": "d8y854v"}, {"comment": "Yes, of course. Any particular small problem domain has a language most suitable for it.", "id": "d8ygj4d"}, {"comment": "Python", "id": "d8x1u6h"}, {"comment": "That is a very good reason, considering that code is written by developers", "id": "d8wxg7c"}, {"comment": "How often facilitating a stupidity and appealing to incompetence is a \"good reason\"?!?", "id": "d8wy7oz"}, {"comment": "How about you stop being so aggressive and stop insulting others having a casual conversation about programming? ", "id": "d8x0n6y"}, {"comment": "How about learning to read? Even if you're dyslexic, you can still pretend you're normal with few simple tricks.", "id": "d8x0uc8"}, {"comment": "Is that your best comeback? Adding another disability insult. Typical.", "id": "d8x0y77"}, {"comment": "It is a diagnosis, not an insult. You such a fucking moron that you failed to understand a single word of what I said.", "id": "d8x10kf"}, {"comment": "Shhhh...shhhhh.... it's ok u/combinatorylogic...it's ok.... shhhh...", "id": "d8x0s00"}, {"comment": "u trolling, right?\n\nI mean, you'd rather use PHP??", "id": "d8x1fgs"}, {"comment": "I'd take PHP over nodejs, but why are we limited to those two options? I'd rather use Python or Go on the back-end.", "id": "d8xlcom"}, {"comment": "Why the hell not?", "id": "d8x1vip"}, {"comment": "[deleted]", "id": "d8wytgh"}, {"comment": "Except arguably the JS type system is harder, given its nonsensical rules.", "id": "d8wzkza"}, {"comment": "I'd make a distinction; the JS type system is easier to _learn_ but harder to _use_. JS and a lot of other currently hip scripting languages have traded away everything that makes a language good (for experienced developers) in order to increase adoption. For example, the types in JavaScript which makes immediate sense to a beginner (\"1 duck\" + \"2 swallows\" == \"3 birds\"), but adds insanity for an experienced developer. `new Date(2016, 1, 31) == 2016-03-01T23:00:00.000Z` which any sane person would expect to fail, rather than give out the _wrong date_. Easy for beginners, because it will silently \"fix\" errors, but difficult for experienced developers because it will silently \"fix\" errors.", "id": "d8x1n3m"}, {"comment": "What's hard about learning that adding `4` to `{}` is an error, rather than `\"4[object Object]\"`?", "id": "d8x1226"}], [{"comment": "Did something happen to coffee script? I never really paid much attention to it but the article just seems mention as an asside that they are exited to ditch it and go back to plain JS?", "id": "d8wvw5t"}, {"comment": "it's probably \"so 2015\"", "id": "d8wwq12"}, {"comment": "ES5 and later with \"use strict\", \"class\" and \"=>\" and to lesser extend \"const\" and \"let\", make coffeescript less worth the tradeoff. Plus coffeescript's \"most global lexical scoping\" was never exactly handy...", "id": "d8wxgh0"}, {"comment": "The developer of CoffeeScript decided on purpose to not support features added in recent versions of JavaScript, such as `import` statements, in order to focus the language on targeting older browsers. This policy has doomed CoffeeScript: as JavaScript gets more features, CoffeeScript falls farther behind. This is not to say the developer made the wrong decision. Perhaps it was the only way to simplify the project enough that the developer would have enough time to keep maintaining it. \n\nI haven't heard of any third-party efforts to keep CoffeeScript modern. I think this is because some of the recent JavaScript features add functionality similar to that in CoffeeScript, such as class syntax and shorter anonymous function syntax.", "id": "d8xjs0v"}], [{"comment": "My problem with this is that the more popular Nodejs gets the more companies looking for frontend work also happen to explicitly ask for Nodejs just because is the same language, like if for some reason a frontend specialist would be also a backend expert just because the same language is used. They always put arguments like \"code reuse\" which doesn't ever happen at high level since the domains are vastly different. Is completely ridiculous. And no I don't want to work with Nodejs, I have enough problem working with Js on the client and only would barely tolerable if I use typescript or something better.", "id": "d8x1w1s"}], [{"comment": "What does the OP mean when he refers to Groupon using Node on front-end applications, rather than backend?", "id": "d8xy2f8"}]]], "55ed8g": ["So You Want to be a Functional Programmer (Part 5)", "2016-10-01 22:05:19", 0, "https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-5-c70adc9cf56a", [[18, "I'm starting to experience FP fatigue. It is not the be-all-end-all that HN and /r/programming is pedalling it to be. It is fantastic for some use-cases, but not all. I am longing to see a write-up of someone writing a non-trivial piece of software using the functional programming paradigm. Does anyone know of any such texts?"]], [[{"comment": "I'm starting to experience FP fatigue. It is not the be-all-end-all that HN and /r/programming is pedalling it to be. It is fantastic for some use-cases, but not all. I am longing to see a write-up of someone writing a non-trivial piece of software using the functional programming paradigm. Does anyone know of any such texts?", "id": "d89uh0t"}, {"comment": "I saw [this](http://www.aosabook.org/en/ghc.html) a while ago while deciding whether to try writing compilers in Haskell or OCaml. There's not much in there that talks about the downsides of FP though.", "id": "d89uxfj"}, {"comment": "Thanks for sharing. Compilers in general is well-suited for FP, as it is one of those problem domains that is very easily expressed in a declarative fashion.", "id": "d89vwps"}, {"comment": "Compilers in general are so simple that you don't even need a Turing-complete language to write them.\n", "id": "d8aqb6m"}, {"comment": "How did you arrive at this conclusion? During my compiler construction class at university there were few who succeeded in writing a robust/feature-complete language & compiler. I'd say that people like writing compilers (which is why there are so many of them), but saying it's easy is oversimplifying imho.", "id": "d8aqyct"}, {"comment": "I actually said \"simple\", meaning algorithmic complexity. But, thanks for reminding, I should have also mentioned that compilers are not just simple (they're nothing but a chain of trivial *rewrites* after all), they're also easy, among the easiest things out there.\n\nUnfortunately, most often this topic is taught so poorly that there is a false perseption that compilers are somehow an advanced and complicated topic. If this topic is taught the right way, it'd be hard to find anything of a practical value that'd be easier than compilers.", "id": "d8ar8e4"}, {"comment": "That's like saying \"Building a house is always easy because it's just a *rearrangement* of it's building materials\".\n\nAltough I agree with you that teaching quality can be subpar, I've seen the same not-understanding and vacant stares during harder programming subjects (which most of my peers agreed on were of sufficient teaching quality).", "id": "d8auar7"}, {"comment": "With compilers, this rearrangement of the building materials is really quite trivial - not a lot of possible variations, everything is too straightforward.", "id": "d8auq89"}, {"comment": "To me it sounds like you only have experience with writing compilers in Haskell. Have you tried other (procedural) languages? I can guarantee you they are much more interesting for writing compilers ;)", "id": "d8az57n"}, {"comment": "No, I do not write compilers in Haskell (and it is also far from being the most suitable language, still too verbose).\n\n> I can guarantee you they are much more interesting for writing compilers ;)\n\nMore *verbose*, but essentially the same simple thing. As long as you understand that all you do is rewriting some trees using some very simple rules, it does not really matter how you implement this concept on a low level.", "id": "d8az9mg"}, {"comment": "https://code.facebook.com/posts/745068642270222/fighting-spam-with-haskell/", "id": "d8a66xd"}, {"comment": "The primary problem domain that functional programming is not effective at yet is UI and game programming. There is ongoing research into this and what they have come up with is quite elegant. It is called FRP. Besides those, even for imperative tasks functional ideas such as monads etc are still useful for making code easier to reason about.\n\nApplications developed in a functional style are here. Rx, which is inspired by FRP, and other libraries are simplifying asynchronous programming using functional ideas.", "id": "d89ycpr"}, {"comment": "> Besides those, even for imperative tasks functional ideas such as monads etc are still useful for making code easier to reason about.\n\nI don't dispute this in the slightest. I'm very happy that monads have been introduced as a mainstay in the Java community. And FRP is enticing, to say the least. I'm just opposed to the general humbug about FP being a silver bullet. I heartily acknowledge the value that FP provides and wouldn't discard it out of sheer dogma. ", "id": "d8a2tz9"}, {"comment": "Elm's main aim is Web Development which is mainly GUI.", "id": "d89yxcg"}, {"comment": "> I am longing to see a write-up of someone writing a non-trivial piece of software using the functional programming paradigm\n\nHow about the backend of a streaming service: \n\nhttps://www.go90.com", "id": "d8a20bo"}, {"comment": "> How about the backend of a streaming service:\n> https://www.go90.com\n\nYou mean [server error as a service](http://imgur.com/a/2msNv)? :)", "id": "d8a2vg4"}, {"comment": "In my experience, the most flexible architectures use a mix of FP and imperative approaches.\n\nSpecialization (extending a class and overriding just a method) remains a very powerful advantage offered by OOP that you don't find in any other approach (and certainly not FP).", "id": "d89y35m"}, {"comment": "    {-# LANGUAGE GADTs #-}\n\n    data Thingie = Thingie\n        { welcome :: IO ()\n        , farewell :: IO () }\n\n    base = Thingie (print \"hello\") (print \"goodbye\")\n    spec = base { farewell = print \"ttfn\" }\n\n    greet :: Thingie -> IO ()\n    greet t = do\n        welcome t\n        farewell t\n\n    main :: IO ()\n    main = do\n        greet base\n        greet spec", "id": "d8a63q0"}, {"comment": "Do you notice you're doing the virtual dispatch manually by passing `base` or `spec` yourself? That's what I'm talking about.\n", "id": "d8a6w4q"}, {"comment": "Tell us, how's it different from:\n\n    interface Thingie {\n        void welcome();\n        void farewell();\n    }\n\n    class Base extends Thingie {\n        public void welcome() { System.out.println(\"hello\"); }\n        public void farewell() { System.out.println(\"goodbye\"); }\n    }\n\n    class Spec extends Base {\n        public void farewell() { System.out.println(\"ttfn\"); }\n    }\n\n    public abstract class Main {\n        // \"doing the virtual dispatch manually by passing base or spec yourself\"\n        private static void greet(Thingie t) {\n            t.welcome();\n            t.farewell();\n        }\n\n        public static void main(String[] args) {\n            Thingie base = new Base();\n            Thingie spec = new Spec();\n            greet(base);\n            greet(spec);\n        }\n    }", "id": "d8aavai"}, {"comment": "No, I'm really not doing that.\n\nI'm selecting an instance manually by using `base` or `spec` as an instance of type `Thingie`.  Exactly as you'd need to in OOP: writing some specialised class won't magically make that specialisation get used everywhere, you still have to instantiate it and inject it _somewhere_.\n\nVirtual dispatch is occurring inside `greet` where the appropriate function defined as part of `Thingie` is extracted from `t` and executed.  The definition of `spec` \"inherits\" the `welcome` attribute of `base`, so the dispatch invokes the same welcome action for both `base` and `spec`.", "id": "d8a7gw2"}]]], "4n3scz": ["Program your next server in Go", "2016-06-08 11:03:52", 0, "https://talks.golang.org/2016/applicative.slide", [[-2, "I know that's right! Whenever it comes to network-programming, I would not touch anything but Golang. :) I personally have written more than 5 full server applications in production in Go."]], [[{"comment": "I know that's right! Whenever it comes to network-programming, I would not touch anything but Golang. :) I personally have written more than 5 full server applications in production in Go.", "id": "d41tuwq"}]]], "4zsm6v": ["Itsy Bitsy Data Structures - Common data structures written in easy to read JavaScript", "2016-08-27 08:05:07", 2, "https://github.com/thejameskyle/itsy-bitsy-data-structures", [[8, "On a cursory glance, I don't entirely appreciate the tone. To take a small quote and dissect it, we aren't hanging out in the programming subreddit because we think a computer's memory layout \"is boring\". I think the exact opposite is true."], [5, "I agree with the other comments. Perhaps an interactable website with two panes, one being the text and one being the code would make this a hell of alot more useful and easier to understand/read "], [3, "It looks like something that should be done in a Jupyter Notebook kind of thing."], [2, "That is a LOT of text in comments. Should be in a markdown file."], [2, "Wow. I'm really impressed by the case that's gone into this. I love the ascii art. Especially hash table ha."], [2, "\"Glaze over dealing with hash collisions?\" Then that's not properly implementing a hash table!"]], [[{"comment": "On a cursory glance, I don't entirely appreciate the tone. To take a small quote and dissect it, we aren't hanging out in the programming subreddit because we think a computer's memory layout \"is boring\". I think the exact opposite is true.", "id": "d6ykhoj"}, {"comment": "I get the sentiment, but I see a lot of comments from people who express no interest in understanding how the computer works or anything about data structures and algorithms because \"the libraries will handle it\" or \"I can just Google it.\"", "id": "d6ysu6r"}, {"comment": "that's JavaScript's brand of torture: death by libraries", "id": "d6zbh4f"}, {"comment": "I guess I'm not fit to hang out in JS circles because I'd much rather use a couple monolithic libraries than a thousand \"microlibraries.\"", "id": "d6zgjpv"}, {"comment": "every language has its perversions. I use Ruby and grimace at its death-by-monkey-patching (now discouraged but still very much in use). Java had death-by-abstract-factory-factory. and so on. ", "id": "d6zpcf7"}], [{"comment": "I agree with the other comments. Perhaps an interactable website with two panes, one being the text and one being the code would make this a hell of alot more useful and easier to understand/read ", "id": "d6yi0bp"}, {"comment": "was thinking exactly the same thing!", "id": "d70wy86"}], [{"comment": "It looks like something that should be done in a Jupyter Notebook kind of thing.", "id": "d6ygzgp"}], [{"comment": "That is a LOT of text in comments. Should be in a markdown file.", "id": "d6ygi7j"}], [{"comment": "Wow. I'm really impressed by the case that's gone into this. I love the ascii art. Especially hash table ha.", "id": "d6yqgcz"}], [{"comment": "\"Glaze over dealing with hash collisions?\" Then that's not properly implementing a hash table!", "id": "d6zkeax"}]]], "4t5p8j": ["I made a sudoku solver. It solves the \"toughest\" sudoku in ~30 ms", "2016-07-16 22:07:44", 0, "https://github.com/lakshayg/sudoku", [[6, "There is no sudoku solver here, just a wrapper around a SAT library.\n\nThere wasn't anything to learn from looking at the source code as a result."], [6, "Here's the link to the hardest sudoku: http://www.telegraph.co.uk/news/science/science-news/9359579/Worlds-hardest-sudoku-can-you-crack-it.html"], [3, ">by formulating it as a boolean satisfiability problem\n\nHm could you add a writeup explaining how this is done?"], [3, "You should include the time it takes to create the SAT to the benchmark."], [1, "Can you explain a little bit more? There's some mathematical theory behind your solution that I don't know\n\nIs it faster than the recursive backtracking solution?\nIf so why?\n\nIt seems overly complicated for a sudoku solver, a lot of nested loops..."], [1, "Great! Can you make a puzzle generator as well, generating symmetric puzzles that don't involve any brute-force guesses?"], [-28, "[deleted]"]], [[{"comment": "There is no sudoku solver here, just a wrapper around a SAT library.\n\nThere wasn't anything to learn from looking at the source code as a result.", "id": "d5f4448"}, {"comment": "Thank you for saving me five min", "id": "d5nb45b"}], [{"comment": "Here's the link to the hardest sudoku: http://www.telegraph.co.uk/news/science/science-news/9359579/Worlds-hardest-sudoku-can-you-crack-it.html", "id": "d5erjbp"}], [{"comment": ">by formulating it as a boolean satisfiability problem\n\nHm could you add a writeup explaining how this is done?", "id": "d5exco3"}, {"comment": "Sure, I will add a writeup as soon as I can.", "id": "d5fat7l"}, {"comment": "Soduko can be reduced to the SAT problem. Without looking at the code, he probably implemented a polynomial reduction. Note however that SAT is NP-complete.", "id": "d5eyrsc"}], [{"comment": "You should include the time it takes to create the SAT to the benchmark.", "id": "d5eydsc"}], [{"comment": "Can you explain a little bit more? There's some mathematical theory behind your solution that I don't know\n\nIs it faster than the recursive backtracking solution?\nIf so why?\n\nIt seems overly complicated for a sudoku solver, a lot of nested loops...", "id": "d5ey6ob"}, {"comment": "It's just a SAT solver (minisat), he just convert the input in a sat problem :\nhe uses addclause to modelize each rule of the sudoku and just run minisat...\nMinisat is fast, but it's one of the best sat solver so it's normal ... Just look at sat solver for theorical explanation\n ", "id": "d5gps3f"}], [{"comment": "Great! Can you make a puzzle generator as well, generating symmetric puzzles that don't involve any brute-force guesses?", "id": "d5fl3mw"}], [{"comment": "[deleted]", "id": "d5ewqgc"}, {"comment": "The votes on posts sort things out mate, no need to be a dick", "id": "d5exw45"}]]], "42c8m6": ["I believe in the 10x engineer, but\u2026", "2016-01-23 22:18:51", 0, "http://erikbern.com/2016/01/08/i-believe-in-the-10x-engineer-but/", [[2, "Once again, being a 10X developer isn't necessarily a good thing. \n\n10X is just the spread between the fastest and slowest developer during studies that look at things like pair programming or TDD. It doesn't actually speak to the quality of their work, merely that they completed the exercise."], [1, "I think the 10x depends on circumstances, I think that when I wrote the Java to BREW converter there might have been a dozen people who could have done it as quickly, because I had a fairly unique set of experiences before hand. I had written an assembly to C converter before, and then at my previous job I wrote a Java byte code optimizer. But even so I think that although it would have taken another programmer much longer to develop the same software, it would have been possible for 2-3 programmers to do it in the same time. (6 months from start to a version where it would convert code, that compiled without intervention, it produced a windows dll file and an Arm binary that ran on the phone)."], [1, "I'm not sure I believe in the x10 developer, but I might believe in the opposite. Not sure if that's any different."], [0, "For what it's worth, I think this list is pretty much spot on except for the first one, and the one about no \"intra-team variance\"."], [0, "> Quoting Alexander Scott\n\nScott Alexander* :)"]], [[{"comment": "Once again, being a 10X developer isn't necessarily a good thing. \n\n10X is just the spread between the fastest and slowest developer during studies that look at things like pair programming or TDD. It doesn't actually speak to the quality of their work, merely that they completed the exercise.", "id": "cz992vp"}], [{"comment": "I think the 10x depends on circumstances, I think that when I wrote the Java to BREW converter there might have been a dozen people who could have done it as quickly, because I had a fairly unique set of experiences before hand. I had written an assembly to C converter before, and then at my previous job I wrote a Java byte code optimizer. But even so I think that although it would have taken another programmer much longer to develop the same software, it would have been possible for 2-3 programmers to do it in the same time. (6 months from start to a version where it would convert code, that compiled without intervention, it produced a windows dll file and an Arm binary that ran on the phone).", "id": "cz9mxzw"}], [{"comment": "I'm not sure I believe in the x10 developer, but I might believe in the opposite. Not sure if that's any different.", "id": "cz9utne"}, {"comment": "There are definitely net negative developers. Actually it's much easier to destroy value than the opposite. \n", "id": "cz9vt5u"}], [{"comment": "For what it's worth, I think this list is pretty much spot on except for the first one, and the one about no \"intra-team variance\".", "id": "cz96z30"}], [{"comment": "> Quoting Alexander Scott\n\nScott Alexander* :)", "id": "cz97y43"}]]], "43eyei": ["Obama wants $4B for more computer science education", "2016-01-30 20:25:01", 16, "http://www.computerworld.com/article/3027924/it-industry/obama-wants-4b-for-more-computer-science-education.html", [[24, "This doesn't seem to belong in /r/programming.  No code, and it's about some politician's desires."], [9, "This is the best tl;dr I could make, [original](http://www.computerworld.com/article/3027924/it-industry/obama-wants-4b-for-more-computer-science-education.html) reduced by 74%. (I'm a bot)\n*****\n> President Obama&#039;s budget proposal for the fiscal year that starts Oct. 1 will include $4 billion to provide states with money to develop computer science programs, along with $100 million in grants available directly to school districts to advance computer learning.\n\n> The funds will be used to encourage states and districts to not only create computer science programs, but also build programs that draw in students who are typically left out of that education right now.\n\n> The President&#039;s push for additional funding is part of an agenda to get Americans learning computer science so that they&#039;re better equipped to participate in an economy that is increasingly driven by computers.\n\n\n*****\n[**Extended Summary**](http://np.reddit.com/r/autotldr/comments/43f7kh/obama_wants_4b_for_more_computer_science_education/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ \"Version 1.6, ~31682 tl;drs so far.\") | [Theory](http://np.reddit.com/r/autotldr/comments/31bfht/theory_autotldr_concept/) | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr \"PMs and comment replies are read by the bot admin, constructive feedback is welcome.\") | *Top* *keywords*: **computer**^#1 **science**^#2 **program**^#3 **President**^#4 **support**^#5\n\n"], [7, "Because a $100 million (2.5% of $4B) direct outlay to schools will make a shitload of difference... /s\n\nWFT happens to the other $3.9B?  Oh, yeah, it goes to our *Always Careful With Taxpayer Money*^TM government bureaucracy and campaign contributors who already run or will create useless consultancies for the project.\n\nIOW: Another boondoggle to help create a false legacy for B.H.O.\n\n"], [0, "I'd want $4B of other people's money for my own projects to...\nWait, no, I don't."], [0, "Ah yes the myth that government can spend that 4B better than the taxpayers.  Which is why we are 20 trillion in debt.  But hey its what they teach everyone in schools."], [-3, "If you divide that by 300 million Americans that's 1.3 million dollars per person!"], [-3, "[deleted]"]], [[{"comment": "This doesn't seem to belong in /r/programming.  No code, and it's about some politician's desires.", "id": "czhu35a"}, {"comment": "This comment has been overwritten by an open source script to protect this user&apos;s privacy. \n\n   If you would like to do the same, add the browser extension [GreaseMonkey](https://addons.mozilla.org/en-us/firefox/addon/greasemonkey/) to Firefox and add [this open source script](https://greasyfork.org/en/scripts/10380-reddit-overwrite).   \n\n Then simply click on your username on Reddit, go to the comments tab, and hit the new OVERWRITE button at the top.", "id": "czi8i35"}, {"comment": "> some politician's", "id": "czhx5q3"}, {"comment": "> politicians desire's\n\nedit: wow, I guess it wasn't clear I was joking :)", "id": "czi0n7i"}], [{"comment": "This is the best tl;dr I could make, [original](http://www.computerworld.com/article/3027924/it-industry/obama-wants-4b-for-more-computer-science-education.html) reduced by 74%. (I'm a bot)\n*****\n> President Obama&#039;s budget proposal for the fiscal year that starts Oct. 1 will include $4 billion to provide states with money to develop computer science programs, along with $100 million in grants available directly to school districts to advance computer learning.\n\n> The funds will be used to encourage states and districts to not only create computer science programs, but also build programs that draw in students who are typically left out of that education right now.\n\n> The President&#039;s push for additional funding is part of an agenda to get Americans learning computer science so that they&#039;re better equipped to participate in an economy that is increasingly driven by computers.\n\n\n*****\n[**Extended Summary**](http://np.reddit.com/r/autotldr/comments/43f7kh/obama_wants_4b_for_more_computer_science_education/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ \"Version 1.6, ~31682 tl;drs so far.\") | [Theory](http://np.reddit.com/r/autotldr/comments/31bfht/theory_autotldr_concept/) | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr \"PMs and comment replies are read by the bot admin, constructive feedback is welcome.\") | *Top* *keywords*: **computer**^#1 **science**^#2 **program**^#3 **President**^#4 **support**^#5\n\n", "id": "czhr0ka"}], [{"comment": "Because a $100 million (2.5% of $4B) direct outlay to schools will make a shitload of difference... /s\n\nWFT happens to the other $3.9B?  Oh, yeah, it goes to our *Always Careful With Taxpayer Money*^TM government bureaucracy and campaign contributors who already run or will create useless consultancies for the project.\n\nIOW: Another boondoggle to help create a false legacy for B.H.O.\n\n", "id": "czhpofg"}, {"comment": "That $4B wouldn't be going to bureaucracy. You're right that the $100M directly to schools is minuscule, but then schools already have most of the hardware needed for such education. What isn't there, and what's not under the purview of individual schools, is curriculums, standardized testing, planning with post-secondary schools, educated teachers. All of which is what that $4B would be paying for.", "id": "czhtehc"}, {"comment": "But what schools really need is enough money to pay teachers salaries that don't fucking suck. Especially in the USA, where schools are largely funded with local taxes, poor districts get the short end of the stick. But even in wealthier areas, I make at least 3 times what my teacher friends do working in industry, possibly more. If I was purely optimizing my career for money, it might be even higher.\n\nWithout anything approaching good pay for public school teachers, dumping more tests on students is a waste of time.", "id": "czhvpdu"}, {"comment": "Actually what schools really need is a way to fire crappy teachers and hire good ones. Many teachers are vastly overpaid for their abilities, and many can't get work simply because of horrible hiring practices/unions.\n\nI don't think very many teachers get into teaching for the money, and most areas AFAIK have a way higher supply of teachers than demand for them. Most of the people I've heard of who give up on being teachers don't make the decision because of pay, it's because of the unlikelihood of actually being hired.", "id": "czi5b9c"}, {"comment": "> Actually what schools really need is a way to fire crappy teachers and hire good ones.  Many teachers are vastly overpaid for their abilities,\n\nThere aren't enough good ones, and for a very good reason. For many teachers, if they *had* abilities, they'd double their income out of school by going into industry. And get out of school with less debt, earlier. The upper bound on teaching salaries sits at about 10% to 30% of the cap for a good industry job in, eg, software.\n\nTeaching, as it stands, only attracts the idealistic self-sacrificers, and the incompetent. And as a society, we don't revere teachers enough to attract a large number of the idealists, which leaves an overabundance of the incompetents.\n\nBasically, teaching is a shitty career choice in terms of respect, workload, and money; That needs to be fixed before we can get good teachers.", "id": "czi5omy"}, {"comment": "Do you need teachers that are experts in their field? Not really, you just need someone with a good grasp of the content, which could simply be someone who just passed the course with a good grade. TAs in college are probably the best resource, there's no reason why the concept couldn't work in high school as well. Teachers definitely shouldn't need a bachelors degree + 2 years of specialized training. That doesn't make a teacher any better. Practice does (almost every teaching student will tell you they learn FAR more in their placements, and every school stresses their importance). If schools were willing to hire \"uneducated\" teachers you could easily have people spend a year or two as teachers before getting into their industry. They could even use the year or two as a way to make money to afford university. The only problem with that would be a matter of age difference and therefore discipline, but you could easily introduce baby sitterish adults to supervise.\n\n> we don't revere teachers enough to attract a large number of the idealists, which leaves an overabundance of the incompetents.\n\nActually there are many people I know that were interested in teaching, but went into industry simply because of the job market for teachers being what it is. They are very bright individuals. I had a very intelligent and very fantastic high school computer science teacher, who faced losing his job simply because a more senior teacher was interested in moving to the school (and he'd therefore shift down, and was at the bottom of the rung to be laid off when a school closed). You can't possibly measure which of these forces is the driving factor behind major imcomptence, and ultimately I think we both want the same thing. Better freedom for schools to pay someone based on skill (teaching skill that is, being an expert in comp sci doesn't mean you are good at teaching, and fantastic teachers don't have to know more than the course content). In order for schools to do that, they need to be able to fire the teachers that aren't very good, so they can dedicate salaries to the ones who are good.\n", "id": "czijnqt"}, {"comment": "On the contrary, there is a MASSIVE demand for *good and qualified* teachers. There are plenty of primary school teachers because girls all love children etc. But there aren't enough actually trained and qualified teachers that are great, because you can make 5x as much in the sciences without even really trying.\n\nIf teachers were well paid, they would actually be good, because good people would want to do it.", "id": "cziegqm"}, {"comment": "> If teachers were well paid, they would actually be good, because good people would want to do it.\n\nOnly if they managed to get a job, ie wait for older (potentially crappier) teachers to retire. Teachers simply aren't hired based on skill. \n\nalso \n\n> There are plenty of primary school teachers because girls all love children etc\n\nlet's try not to be sexist here. The point you were wanting to make is that people who love children think they can be teachers automatically and flood the primary school market.\n\nUltimately there's no reason why you need expert teachers in this day and age. Lesson materials are abundant and even someone who barely knows the content can teach it. Sites like khan academy are becoming the best way to learn anyways, what we need is the college concept of TAs (someone who just passed the course is the best resource for answering questions). Pay huge amounts for digital course content that is excellent in quality and replace teachers with monitors and TAs.", "id": "czijhoh"}, {"comment": ">Teachers simply aren't hired based on skill.\n\nYes they are.\n\n>Only if they managed to get a job\n\nEasy, there's a massive shortage of teachers.\n\n>let's try not to be sexist here.\n\nIt's not sexist, it's fact.\n\n>Ultimately there's no reason why you need expert teachers in this day and age.\n\nUnqualified teacher detected.\n\n>Sites like khan academy are becoming the best way to learn anyways\n\nLol no, they miss out on having someone to ask questions of.\n\n> what we need is the college concept of TAs (someone who just passed the course is the best resource for answering questions)\n\nEver heard of chinese whispers?\n\n", "id": "czitsp1"}, {"comment": "I know for a fact that there is not a shortage of teachers where I live (Canada) and as far as I understood it was pretty much the same in the states. Also unions dictate that seniority comes first, years spent in university comes second when it comes to pay. Very few places in North America use skill to determine salary or who to hire (or when they do it's only marginally considered).\n\n[Bill gates talks about this in one of his ted talks](\nhttp://www.ted.com/talks/bill_gates_unplugged/transcript?language=en). If wherever you are has a massive shortage of teachers and they hire on skill then please tell me where that is, because in Ontario you have teachers moving to essentially ghettos in the north to teach simply so that they have X years of experience.", "id": "cziuu1o"}, {"comment": "[deleted]", "id": "czhq8uz"}, {"comment": "I don't have a breakdown, but paragraph 2 in the story gives the $100M figure.", "id": "czhqvmh"}, {"comment": "> there are 98817 schools in the US\n\nI hate to be *that guy* but could you give a source for this? also do you mean just highschools? or highschools + middle schools + elementary schools? there are a lot of different ways to break this down", "id": "czhugam"}, {"comment": "[deleted]", "id": "czhxr7e"}, {"comment": "that's cool, Thanks!\n", "id": "cziavrj"}, {"comment": "That will go to states for allocation assuming they meet the requirements laid out in the full proposal no one has yet seen.", "id": "czht3ic"}, {"comment": "no bias in this comment", "id": "czhx6wo"}], [{"comment": "I'd want $4B of other people's money for my own projects to...\nWait, no, I don't.", "id": "czhyu33"}], [{"comment": "Ah yes the myth that government can spend that 4B better than the taxpayers.  Which is why we are 20 trillion in debt.  But hey its what they teach everyone in schools.", "id": "czi62xd"}, {"comment": ">Ah yes the myth that government can spend that 4B better than the taxpayers.\n\nIt can.\n\n>Which is why we are 20 trillion in debt.\n\nNo, lowering taxes and then going to war is why you are 20 trillion in debt.\n\n", "id": "czieipd"}, {"comment": "The things you believe are pure BS.  Go look up the figures, the entire DOD budget isn't 1 trillion, so you are saying we have been at war for 20 years?  \n\nIf govt spends so well, give me some examples it does better than the private sector.  I will get us started:\n1. Social security vs private investments - FAIL\n2. Public education vs private - LAFF\n3. Public housing vs private - A PATTERN HERE\n4. Public health care(VA) vs private healthcare - NOT EVEN CLOSE", "id": "czijnyk"}, {"comment": ">The things you believe are pure BS. Go look up the figures, the entire DOD budget isn't 1 trillion, so you are saying we have been at war for 20 years?\n\nI said LOWERING TAXES AND GOING TO WAR. Also have you never heard of interest, idiot?\n\npublic healthcare is better in every country with public healthcare.", "id": "czitqg8"}, {"comment": "Cry me a river that the government doesn't have enough. It spends 3.4 Trillion a year just at the federal level.  \n\nDebt is caused by spending.  If you get a high credit card bill do you complain your income was too low?  I guess you skipped math and economics in school.\n\nHealthcare is not better elsewhere.  They use US equipment and medicines and still have longer wait times than the US.", "id": "czjcphi"}, {"comment": ">Cry me a river that the government doesn't have enough. It spends 3.4 Trillion a year just at the federal level.\n\nLiterally my entire point is that it spends too much. Just on the wrong things.\n\n>Debt is caused by spending.\n\nIt's caused by spending more than you earn. Raise taxes, spend less on military. EZ.\n\n>Healthcare is not better elsewhere. They use US equipment and medicines and still have longer wait times than the US.\n\nHealthcare is better elsewhere. We use equipment and medicines from around the world. Where they are from is irrelevant. And wait times vary wildly between countries. The quality of healthcare in the US is absolutely abysmal from a price/performance standpoint. ", "id": "czjg3kq"}, {"comment": ">It's caused by spending more than you earn. Raise taxes, spend less on military. EZ.\n\nBeyond a certain point, economic activity slows and you earn less money.  The laffer curve is well established here and we aren't pre-apex on that curve.\n>Healthcare is better elsewhere.\n\nI guess that's why Canadians are coming to the us for care?  \n\nhttp://www.huffingtonpost.com/2010/02/02/danny-williams-canadian-o_n_446481.html\n\nAnd Canada is a _tiny_ country population wise (2nd largest by land mass).  Even comparing to the US (320 million) is ridiculous on its face, not that the US has free market care anyway....", "id": "czk7ash"}, {"comment": ">Beyond a certain point, economic activity slows and you earn less money. The laffer curve is well established here and we aren't pre-apex on that curve.\n\nYes, yes you are. You're WAAAAY pre-apex. The US has relatively low taxes.\n\n>I guess that's why Canadians are coming to the us for care?\n\nI can guarantee you that the vast, vast majority of Canadians get their healthcare in Canada. A few ultra-rich Canadians may come to the US for a few very very specialised treatments, but they aren't available to the average American either.\n\n>And Canada is a tiny country population wise (2nd largest by land mass). Even comparing to the US (320 million) is ridiculous on its face, not that the US has free market care anyway....\n\nThe size of the population is **completely and utterly irrelevant**. I don't know why Americans seem to insist on pointing out their population when being compared to other countries. Of course you've got a big population. No shit. We're talking about PROPORTIONAL statistics when comparing two countries. If anything, the US comes out on top in those comparisons, because it should benefit from economies of scale. Instead it comes out the worse, in healthcare.\n\nIn fact, the USA has the power to make healthcare much cheaper. The cost of medicine in the USA is huge because there are WAAAAY more individual buyers than sellers. If the US government contracted for medicine in bulk i.e. it formed a monopsony and was the sole (or nearly the sole) buyer of medicine in the US, it would heavily force down the cost of medicine and therefore the cost of healthcare in the USA.\n\nI find it amazing as well that people don't understand that the main reasons that US healthcare is so inefficient from a price/performance standpoint is that the cost has to go somewhere, and that place is in the pockets of the shareholders of health insurance companies i.e. the megarich.\n\nThe \"force everyone to buy insurance\" scheme is ridiculous. Nationalise your healthcare system, implement an accident compensation scheme to eliminate the massive inefficiency that is personal injury litigation (remembering that you would still be able to sue for PUNITIVE damages, just not for costs), implement a single buyer of healthcare products for the entire healthcare system, and you would absolutely blow the efficiency of any other country's healthcare system out of the water.\n\nAnd everyone knows Americans love blowing things out of the water.", "id": "czkqsxn"}, {"comment": "I love the stuff you just \"know\".   No facts required.\n\nIf you believe politicians can make your decisions better than you can, then you aren't that bright.  I will make my own health care decisions.\n\nIts funny you believe it would be more \"efficient\" with government control but cost has gone WAY UP the more government has gotten involved.  The same as it has with education.  This is fact, not my opinion.  Those \"higher costs\" fund all the medical advances the US develops.  And we fund somewhere north of 45% of new drugs.  All that with FIVE PERCENT of the world population.\n\nBut I am sure you can do it much better, huh?\n\nThe fact you think population matters not says volumes about your shallow thinking on the matter.  Does it even occur to you that the more people you are \"managing\" the more difficult to find policies which somewhat fit those needs?  Of course it doesn't.\n\nSo according to you a policy designed for a family of four works equally well for a single person, or a family of twelve, or 3 elderly siblings.\n\nStay in your bubble.  You seem quite happy there.", "id": "czlurm7"}, {"comment": "There are a diversity of people to manage healthcare outcomes for in a population of any country-sized size. \n\n>Its funny you believe it would be more \"efficient\" with government control but cost has gone WAY UP the more government has gotten involved. The same as it has with education. This is fact, not my opinion. Those \"higher costs\" fund all the medical advances the US develops. And we fund somewhere north of 45% of new drugs. All that with FIVE PERCENT of the world population.\n\nOf course it will cost more if you're covering sicker people, because those sicker people have high healthcare costs. The difference is now they're getting them while before they were just dying.\n\n>So according to you a policy designed for a family of four works equally well for a single person, or a family of twelve, or 3 elderly siblings.\n\nIdiot, I never said that. There is a diversity of people in any country. There isn't magically an impossible amount of diversity of people in the USA in 320 mil people, but not in the UK with 60 mil.", "id": "czlxu6c"}], [{"comment": "If you divide that by 300 million Americans that's 1.3 million dollars per person!", "id": "czi8g6v"}, {"comment": "[deleted]", "id": "czif15v"}, {"comment": "I believe that was [meant as a joke.](http://www.cnet.com/news/can-powerball-end-poverty-lottery-meme-fails-to-check-the-math/)", "id": "czihghj"}, {"comment": "Yeah, I was referencing the powerball wealth sharing meme: http://www.snopes.com/powerball-wealth-sharing-meme/", "id": "cziju6l"}], [{"comment": "[deleted]", "id": "czhzzgb"}, {"comment": "You're roughly correct. We shouldn't lower our standards to attempt to get more people. \n\nEducation is far too easy. You can understand 40% of the content of a course, get a grade of 50% because 10% of the course is basically a test of whether or not you turn up (sometimes LITERALLY just attendance marks) and still pass. It's fucking insane.\n\nIf you can't get a software engineering degree with the prerequisites they have, you aren't fit to be a software developer.", "id": "cziei29"}]]], "54ko71": ["IBM says: \u2018Swift is now ready for the enterprise\u2019", "2016-09-26 17:53:40", 1, "http://www.computerworld.com/article/3122994/apple-mac/ibm-says-swift-is-now-ready-for-the-enterprise.html", [[3, "Wouldn't the lack of Swift ABI compatibility make this not the case, though?"], [2, "Considering how slow enterprise development is, I'd say no.  Not while they introduce breaking changes on a yearly basis."]], [[{"comment": "Wouldn't the lack of Swift ABI compatibility make this not the case, though?", "id": "d82q08w"}], [{"comment": "Considering how slow enterprise development is, I'd say no.  Not while they introduce breaking changes on a yearly basis.", "id": "d839vrn"}]]], "43yyp8": ["Yahoo ex-employee sues, alleging manipulation of performance reviews and gender bias", "2016-02-03 11:31:51", 9, "http://www.latimes.com/business/technology/la-fi-tn-yahoo-lawsuit-20160202-story.html", [[23, "Much as this is an interesting article, what does it have to do with /r/programming? \n\nTo quote:\n\n> ... the editorial director in charge of Yahoo's autos, shopping, homes, travel and small-business sites.\n\nand\n\n>... while doing a Knight-Wallace fellowship at the University of Michigan for mid-career journalists\n\nJournalists are programmers now?"], [9, "I still think it's funny all the fuss about stopping employees (I don't think all) from working from home like that was the reason the company was doing so badly. It still hasn't improved now. If you absolutely have to see your employees on seats to trust them then you have a real problem with your management culture"], [3, "[deleted]"], [0, "Interested to see where this goes in a few months. On all sides of this lawsuit..."], [-2, ":-p"], [-43, "Yahoo's ceo is a woman? no wonder that company is doing so poorly"]], [[{"comment": "Much as this is an interesting article, what does it have to do with /r/programming? \n\nTo quote:\n\n> ... the editorial director in charge of Yahoo's autos, shopping, homes, travel and small-business sites.\n\nand\n\n>... while doing a Knight-Wallace fellowship at the University of Michigan for mid-career journalists\n\nJournalists are programmers now?", "id": "czm4wby"}, {"comment": "Mods seem to be asleep recently", "id": "czm5oqs"}], [{"comment": "I still think it's funny all the fuss about stopping employees (I don't think all) from working from home like that was the reason the company was doing so badly. It still hasn't improved now. If you absolutely have to see your employees on seats to trust them then you have a real problem with your management culture", "id": "czm4ffe"}], [{"comment": "[deleted]", "id": "czm3q2r"}, {"comment": "Man, I don't much like her or what she's done, but it sucks to shit on someone for having a weird laugh.", "id": "czm5wv5"}, {"comment": "Yeah totally agreed. A lot of people don't like Hillary Clinton for that reason too which always rubs me the wrong way", "id": "czm98yp"}, {"comment": "No that is because she laughs as a way to avoid answering hard questions by implying they aren't worth a serious response. Her laugh isn't weird even if it is usually forced.", "id": "czmaa7s"}, {"comment": "Did anybody else found that oddly humanizing? She might be one of the richest people in the world, so fashion shoots and run one of the larger internet based businesses, but she still gets nervous and laughs like a dork.", "id": "czm5wwe"}], [{"comment": "Interested to see where this goes in a few months. On all sides of this lawsuit...", "id": "czm4sjr"}], [{"comment": ":-p", "id": "czm8r41"}], [{"comment": "Yahoo's ceo is a woman? no wonder that company is doing so poorly", "id": "czm3vdd"}, {"comment": "[deleted]", "id": "czm57wv"}, {"comment": "Nah, you can fuck off to tumblr though. Sorry for not putting a trigger warning on my post", "id": "czm81sw"}, {"comment": "Oooh, you seem a bit sensitive. ", "id": "czm86le"}, {"comment": "In my experience the people who are quick to bitch about trigger warnings are at least as sensitive as the people calling for them. I'm convinced that half the reason TRP so violently hates on tumblrinas is that deep down they know they're staring at a funhouse mirror reflection of themselves.", "id": "czmd4nb"}, {"comment": "deep bruh. btw I don't go to that subreddit", "id": "cznm2pf"}, {"comment": "slow news, huh? only been like 3-4 years now ...", "id": "czm4h0y"}]]], "5aw2gj": ["5 Best Way To Write And Run JavaScript Online", "2016-11-03 14:59:46", 0, "http://www.discoversdk.com/blog/5-best-way-to-write-and-run-javascript-online", [[1, "Meh, pointless article. "]], [[{"comment": "Meh, pointless article. ", "id": "d9k87ol"}]]], "48fw1q": ["IOT Programming Essential Job Skills [Infographic]", "2016-03-01 14:51:06", 9, "http://cloudtweaks.com/2016/02/essential-job-skills-learning-to-code/", [[17, "Where did they get their average salaries from? Like everything else in this infographic, it seems highly misguided and entirely untrue."], [17, "How does this fit into IOT?"], [12, "[Higher Resolution Infographic](http://makeawebsitehub.com/wp-content/uploads/2016/01/what-code-should-I-learn-cheat-sheet-2016-01-FINAL-1.jpg)"], [10, "> Since almost all programming languages nowadays are themselves implemented in C, knowing C basically gives you a free ticket to knowing all programming languages.\n\n(I was going to add a snarky comment here, but words escape me)"], [8, "As I've often heard some of my American friends say, \"This is some bullcr*p\" - \n\"JS is high performance because it's client side\" ....\n....\n....\nsomeone get me a drink please."], [4, "Terrible mobile experience. The entire graphic is hidden under some blank box that appears to be meant to contain author information.\n\nhttp://imgur.com/X4qYPqB"], [4, "\"What is ... used for\" is really outdated. \n\n\"... was used to build..\" Is just missleading.\n\nJs is apparently not secure because it run on the client. The ehm.\n\nAnd so on.."], [3, "IoT is just a flat out dumb idea. Who is going to do the required sysadmin work to update and patch vulnerabilties in a toaster. And, do you want your toaster to be a vector for a state spying on your life?. But I wonder if some archivecture would make it doable. Like, I dunno, something like small VM's that run in the central server, and absolutely minimal code running in the toaster, other than support for a protocol to interface with this VM.  Everything sandboxed. Everything with a offline path so the toaster can run offline and is probably running offline but with some sort of wake-on-lan feature. IoT is stupid and a criminal danger, but maybe it can be made safe and non-stupid with some architecture that puts the real strengths to each industry to work.   Anything but hardware companies writing code (we have been there, we don't want to go there again). \n\n"], [2, "In case anyone's wondering (God knows I've spent 5 minutes scratching my head), IOT stands for Internet of Things.  "], [2, "Seriously GTFO. It's \"embedded systems\" none of this marketing bullshit. Source: I work in embedded systems."], [1, "I, for one, want to know where all of these $100,000+ salaried jobs are all of a sudden. You'd get half of that in Ireland."], [0, "R gets no love again"]], [[{"comment": "Where did they get their average salaries from? Like everything else in this infographic, it seems highly misguided and entirely untrue.", "id": "d0jatl3"}, {"comment": "There are lots of places where software engineers make 50k/year\n\nEspecially in Europe", "id": "d0jb2xm"}, {"comment": "And yet most of these prices are above 100k/yr, which is an insane average. Currently, CS jobs after graduation only average 80k. ", "id": "d0jb82k"}, {"comment": "> Currently, CS jobs after graduation only average 80k.\n\nI *wish* I could make $80,000 out the door from university and I'm living in one of the better-off countries in Europe.", "id": "d0jebt8"}, {"comment": "That is mostly for NA universities; There's tons of jobs for graduates here.", "id": "d0jfmv4"}, {"comment": "I'm 3 years out of Uni with a CS degree, very active portfolio, contribute to open source and live in NE U.S. Employed as software engineer and I am only making 46K/year including bonuses... I would do unforgivable acts for 80K/year", "id": "d0jje1p"}, {"comment": "Look into moving to SF, LA, Seattle, Austin, Atlanta, Chicago, or NYC.", "id": "d0jnnys"}, {"comment": "Judging by the list of cities, the survey must be US only.", "id": "d0jnbey"}, {"comment": "All the salaries were 100k +/- 2k with the outlier being PHP making 89k. yeah... 100k for a javascript developer, how? Oh and C programmers make a lot more than 100k especially with embedded programming. ", "id": "d0jbmss"}, {"comment": "Where do you live? I need to move...", "id": "d0jbo80"}, {"comment": "Most people don't even know you don't have to work in Silicon Valley or New York for these jobs. In fact you shouldn't because the expenses are higher and eat into your salary than working 50k in Ohio would. \n\nObviously work in the private sector not public, master a few mainstream languages you see in job postings and build your resume with experience in those languages. Then do your research on companies that are hiring. Don't go for startups because you'll work more than you need to and don't go big corporate because you won't be able to negotiate better salary unless it's a niche role that is hard to find. Definitely no government jobs. Certain job skills like C are rare versus PHP or most web languages. After that it's really negotiating your value to the company based on your unique experience and mastery of languages that are core to their services. Figure out an angle. Are you the guru in C/Java/Linux/.NET guy which the company is looking for, or the swiss army knife that is versatile and a good fit that plugs the needs of the company in multiple roles. Discuss the day to day activites/projects and define what your value would be in that project as well as how your experience relates. Don't sound too eager and act like the job is close to a perfect fit but that one thing is missing. Then negotiate using that \"one thing\" that irks you. Whoever is hiring sees dozens of candidates for a position and most are flunks, some are decent fits, but rarely do you find a solid fit and you let that solid fit swim away.\n\nJob interviews aren't about you showing you can code B-trees or linked lists or do your SQL syntaxes correctly. You should be doing that fine anyway unless you're fresh out of school. Job interviews are about negotiating desire and your worth to the company. Let them talk and explain their position/company/goals while you think about how you are the perfect fit but you just aren't sure. Act like a hot entitled woman that isn't sure if she should buy the Pradas or the w/e and they will jump at you.", "id": "d0jcj94"}, {"comment": "Yea but you have to live in Ohio. Nobody wants to live in Ohio.", "id": "d0keitt"}, {"comment": "Yep. I remember once on this sub, an infographic said Ruby developers made an average of 120K a year. I don't know what fairytale land that exists where learning simple web-based languages will make you 6 figures. The only people I know in software development are the ones who know C++ or COBOL.", "id": "d0jdstl"}, {"comment": "yeah imo web based languages net you less than desktop level languages and way less than embedded programming languages like C/ASM. It's simply game theory applied. Harder languages which less people learn are more scarce and worth more. the only exception is if you develop entire web platforms or services which requires multiple languages, but that's an exception to the rule and generally requires you're working for yourself. \n\nHearing Ruby or Python coders make 100k has to be a joke of some sort.", "id": "d0jfeqn"}, {"comment": "You're totally right, I have no idea why they make up those numbers. Is it so they can somehow feel better about their decisions? I don't think there's anything wrong with working in web-based languages, but like you said, simple scarcity means that the jobs known by the few will pay more than the jobs known by many.", "id": "d0jh239"}, {"comment": "The other laught I got was all the languages were 100K +/-2k with PHP being the low outlier for 89K and Objective C usually targetted at iOS apps being at 110k. Clearly someone writing from their Macbook. No one makes that much money writing apps. Apps are usually a supporting element of your system not your main product and so I have a hard time believing that a higher salary is because of Objective C programming. They should have went all the way and claimed Swift programmers make 300K plus a company car.", "id": "d0jh8to"}, {"comment": "On the other hand web programmers can often work remotely, embedded programmers rarely", "id": "d0jg1bb"}, {"comment": "true but web programmers take more shit from clients as far as requirement changes go while embedded programmers usually take requirements from within the company and don't usually interact directly with the client.", "id": "d0jh3z7"}, {"comment": "There's tons of remote contracting embedded work for companies where the software isn't the primary product. Think things like an appliance manufacturer or industrial equipment. ", "id": "d0kn5oh"}, {"comment": "Which ones?\n\nBut I always thought of those as 2nd class jobs far away from the state of art programming. ", "id": "d0kwtlu"}, {"comment": "Where did they get the upvotes from?  There's nothing in that post that would vaguely interest the average /r/programming subscriber.\n\nSomething's afoot.", "id": "d0jn50i"}, {"comment": "I have a sneaking suspicion that a large amount of r/programming is JS and Ruby devs who feel the need to upvote anything that agrees with their opinions; true or no.", "id": "d0jnjmt"}, {"comment": "\"C++ is an object oriented programming language\"! What the fuck, is it 1995 again?!", "id": "d0q6qln"}], [{"comment": "How does this fit into IOT?", "id": "d0j96qb"}, {"comment": "I know your question is rhetorical, but I'm going to answer it anyway.\n\nIt doesn't. It's just a meaningless and arguably incorrect programming language summary with random buzzwords like IOT added.\n\nI suspect it would benefit people who are a combination of (1) not very bright and (2) looking to learn their first language.\n\nIt would be quite bad if some company used it to decide which language to implement their IOT project in.", "id": "d0jaly4"}, {"comment": "As someone who is actually working in IoT, I scrolled up and down that page for a good 10 minutes trying to find the part about IoT.", "id": "d0jlbfx"}, {"comment": "Honestly, I'm not sure why you're getting downvoted since this has absolutely nothing to do with IoT", "id": "d0jaofo"}, {"comment": "I was wondering the exact same thing.", "id": "d0jarlf"}], [{"comment": "[Higher Resolution Infographic](http://makeawebsitehub.com/wp-content/uploads/2016/01/what-code-should-I-learn-cheat-sheet-2016-01-FINAL-1.jpg)", "id": "d0j9apm"}, {"comment": "Thank you!", "id": "d0j9hyc"}], [{"comment": "> Since almost all programming languages nowadays are themselves implemented in C, knowing C basically gives you a free ticket to knowing all programming languages.\n\n(I was going to add a snarky comment here, but words escape me)", "id": "d0jd4ub"}, {"comment": "Even if it was true (it's not) this is complete BS. The fact that a language is implemented is C is completely unrelated with how difficult the language is to learn for someone knowing C.", "id": "d0jgqs2"}, {"comment": "Except C, which is mostly implemented in C++. ", "id": "d0jq31u"}, {"comment": "You could give a list of words like: clang, gcc, Rust, GHC, OCaml, Java, etc.", "id": "d0jdpro"}, {"comment": "I think Free Pascal is implemented in Free Pascal", "id": "d0jf8l1"}, {"comment": "\"Just because you can engineer a NASCAR doesn't mean you can drive one\" ?", "id": "d0ju3zz"}], [{"comment": "As I've often heard some of my American friends say, \"This is some bullcr*p\" - \n\"JS is high performance because it's client side\" ....\n....\n....\nsomeone get me a drink please.", "id": "d0jaxzk"}, {"comment": "I don't want to crap on you because you're right about the article being utter crap.\n\nHowever, if you're considering things in the context of IOT, the server is probably some shitty micro-controller in a Smart Microwave Oven, that exposes a web server. In this case, assuming you don't give a shit about security (which seems to be the norm for IOT) then doing complex calculations client side in the phone's browser with JS actually makes a lot of sense. The phone has the more powerful CPU by far.", "id": "d0jbjmf"}, {"comment": "What kind of complex calculation is required for a lightbulb or a toaster oven?", "id": "d0jdswm"}, {"comment": "Current events? Or doesn't that [joke](http://m.imgur.com/ccy2fuY?r) work here?", "id": "d0jm1lf"}, {"comment": "It's IOT, so I can sing and have the lightbulb change hue according to the tone, right? Even if it didn't come that way from the factory, someone would write an app for it.", "id": "d0jel26"}, {"comment": "You have to compute the intensity of each LED of the strip.  \n  \n  It is not IoT if it doesn't have a LED strip.", "id": "d0jf0d9"}, {"comment": "I'm not arguing that it doesn't make more sense in that case- my point was rather that you're not saying that JS is faster than java/C/objC/C++ code, you're saying \"the phone is faster than the lightbulb\". If that was also the statement they'd made, rather than praising JS as being fast for this reason (without praising any of the other languages which can also run \"client side\"), then I might agree with it.", "id": "d0jicsp"}, {"comment": "Again, nothing you say is incorrect, but *in this context* I agree with definitions from the original article. \n\nFor *Internet* of Things,  then \"client\" means browser, and the browser runs JS. \n\nYou can run C/C++ and Java client side, but doing it in the browser? It's very hard. \n\nAnd why not use the browser? Every home generic coputing device will have one (even a console and possibly a newer TV) and it's the easiest way to expose an API to a home device.", "id": "d0jisjg"}], [{"comment": "Terrible mobile experience. The entire graphic is hidden under some blank box that appears to be meant to contain author information.\n\nhttp://imgur.com/X4qYPqB", "id": "d0ja57q"}], [{"comment": "\"What is ... used for\" is really outdated. \n\n\"... was used to build..\" Is just missleading.\n\nJs is apparently not secure because it run on the client. The ehm.\n\nAnd so on..", "id": "d0jbg0u"}, {"comment": "C#'s not cross-platform, donchaknow.", "id": "d0jd0j7"}, {"comment": "Well, Mono is a thing. But it's rarely used, so for the most part I suppose that's true.", "id": "d0keq20"}], [{"comment": "IoT is just a flat out dumb idea. Who is going to do the required sysadmin work to update and patch vulnerabilties in a toaster. And, do you want your toaster to be a vector for a state spying on your life?. But I wonder if some archivecture would make it doable. Like, I dunno, something like small VM's that run in the central server, and absolutely minimal code running in the toaster, other than support for a protocol to interface with this VM.  Everything sandboxed. Everything with a offline path so the toaster can run offline and is probably running offline but with some sort of wake-on-lan feature. IoT is stupid and a criminal danger, but maybe it can be made safe and non-stupid with some architecture that puts the real strengths to each industry to work.   Anything but hardware companies writing code (we have been there, we don't want to go there again). \n\n", "id": "d0je9dm"}], [{"comment": "In case anyone's wondering (God knows I've spent 5 minutes scratching my head), IOT stands for Internet of Things.  ", "id": "d0jemf8"}, {"comment": "Such an ugly acronym, IoT. And it sounds stupid anyway, just like World Wide Web or Information Superhighway. Hopefully we get a better name! ", "id": "d0jfcro"}], [{"comment": "Seriously GTFO. It's \"embedded systems\" none of this marketing bullshit. Source: I work in embedded systems.", "id": "d0jpq42"}], [{"comment": "I, for one, want to know where all of these $100,000+ salaried jobs are all of a sudden. You'd get half of that in Ireland.", "id": "d0je9vh"}, {"comment": "In the Bay area", "id": "d0jgq9l"}, {"comment": "*Starting* salary for a new graduate in a tech company in silicon valley area is 100+.\n\nUS <-> Ireland is not directly comparable though. Consider what are your healthcare costs in Ireland? You probably have a functioning free public healthcare system while the yanks pay $3,000 - $25,000 for a broken leg (lower end if it doesn't need surgery).", "id": "d0jhs9e"}, {"comment": "> Consider what are your healthcare costs in Ireland? You probably have a functioning free public healthcare system\n\nWhile we spend less than half of what the US does per capita every year on healthcare, we definitely don't have a free healthcare system - it is, to some extent, subsidised, but it's not like the NHS. The cost of living here was the [fifth-highest in the EU](http://www.independent.ie/business/irish/cost-of-living-in-ireland-fifth-highest-in-eu-30998821.html) as of early 2015. Our median salary are also almost $20,000 less than that in the United States.", "id": "d0jimqm"}, {"comment": "If you have a $100k programming job, you probably have pretty good health insurance as well. Not necessarily, but companies which are going to pay $100k for a programmer aren't that likely to skimp on benefits, since the people they are hiring have plenty of other options.", "id": "d0mygvx"}, {"comment": "Boston, New York City, San Fran / SV, Seattle, Austin.", "id": "d0keq4l"}], [{"comment": "R gets no love again", "id": "d0jnyim"}]]], "51wons": ["No more MVC for me, I will use MVA", "2016-09-09 14:17:43", 2, "http://modulit.se/blog/no-more-mvc-for-me-i-will-use-mva/", [[27, "Why do people override native scrolling and implement their own shitty version instead? It's unusable on a Mac trackpad and I just closed the tab in frustration."], [3, "This is very similar to Jimmy Bogard's use of the Mediator pattern:\n\nhttps://lostechies.com/jimmybogard/2014/09/09/tackling-cross-cutting-concerns-with-a-mediator-pipeline/\n"], [3, "I find that large (God) controllers are symptomatic of poor domain object modeling / design / organization, leaky business logic that isn't abstracted into services, not implementing the Single Responsibility Principle, etc.  "], [3, "good for you"], [1, "You should check out this framework, Verily, which implements basically what you are talking about: http://www.goverily.org -- In Verily it's called Method, Router, Response. "], [1, "MVP?  MVVM?  These are all old school...."], [-1, "Interesting idea, but I worry that in Java this would cause the number of classes to explode, shifting the problem from too many methods in a class to too many classes in a package.\n\nI figure I have it pretty-well figured out how to keep views from becoming a mess, but controllers are something I'm still working on. Maybe there's a universal law that when state changes, there is going to be a mess somewhere.\n\nEDIT: Really, people? I'm not attacking OP; I'm just expressing my reservations. And my second paragraph was supposed to be a separate thought, unrelated to the first half."], [-4, "That sounds like a good model. What are your thoughts on this?"]], [[{"comment": "Why do people override native scrolling and implement their own shitty version instead? It's unusable on a Mac trackpad and I just closed the tab in frustration.", "id": "d7fgx9i"}, {"comment": "Thank you for the feedback, smooth scrolling removed!", "id": "d7fio5i"}, {"comment": "Thanks. Sorry if I came across as a dick.", "id": "d7fk6dr"}, {"comment": "No worries!", "id": "d7fkemd"}, {"comment": "Upvoting this comment, your later comments, and the post solely for removing smooth scrolling.\n\nI've gone so far as to try and add AdBlock filters to block smooth scrolling scripts before; I dislike it so much.", "id": "d7fng4p"}, {"comment": "because its cool, if they didn't they would be rejected by the hipsters and there website would be shit and useless", "id": "d7fhvat"}, {"comment": "Hipsters are using Macs: your argument is invalid!", "id": "d7fi0uf"}, {"comment": "ah true... don't tell the OP this otherwise he might purchase some trousers that fit him and shave of his half baked beard ", "id": "d7fi31v"}], [{"comment": "This is very similar to Jimmy Bogard's use of the Mediator pattern:\n\nhttps://lostechies.com/jimmybogard/2014/09/09/tackling-cross-cutting-concerns-with-a-mediator-pipeline/\n", "id": "d7fgwfe"}, {"comment": "Yes, this is actually one thing that I wanted to achieve as well. My approach is basically achieving the same thing but using the features already built into the MVC frameworks.", "id": "d7fhb9r"}], [{"comment": "I find that large (God) controllers are symptomatic of poor domain object modeling / design / organization, leaky business logic that isn't abstracted into services, not implementing the Single Responsibility Principle, etc.  ", "id": "d7fzuqg"}], [{"comment": "good for you", "id": "d7fgnfv"}], [{"comment": "You should check out this framework, Verily, which implements basically what you are talking about: http://www.goverily.org -- In Verily it's called Method, Router, Response. ", "id": "d7fnvju"}], [{"comment": "MVP?  MVVM?  These are all old school....", "id": "d7ge51e"}], [{"comment": "Interesting idea, but I worry that in Java this would cause the number of classes to explode, shifting the problem from too many methods in a class to too many classes in a package.\n\nI figure I have it pretty-well figured out how to keep views from becoming a mess, but controllers are something I'm still working on. Maybe there's a universal law that when state changes, there is going to be a mess somewhere.\n\nEDIT: Really, people? I'm not attacking OP; I'm just expressing my reservations. And my second paragraph was supposed to be a separate thought, unrelated to the first half.", "id": "d7fnmun"}, {"comment": "Why does this bother you?", "id": "d7gez60"}, {"comment": "To clarify, the magnitude of my fear is that of slight annoyance, so my arguments may sound weak. If you're okay with OP's suggestion, then by all means follow it.\n\nIf I read this blog post correctly, OP is suggesting that every controller method should be in its own class. Now, in Java every file must have exactly one class (no more, no less), not counting inner classes. Now, OP's example is written in C#, which to my understanding imposes no such restriction. Given how the choice of programming language impacts architectural decisions, I feel the need to consider whether this advice is just as applicable in Java.\n\nLet's say that an existing code base has 15 controllers with an average of 10 methods each; splitting the methods up will yield 150 different source files. Assuming no other organization system already exists, all of these files will be in the same folder, making it difficult to navigate the project's directory tree. It won't remain like this for long, though; most people will immediately start sorting their methods these into sub-packages.\n\nI posit that the contents of many of these sub-packages will resemble the original, conglomerate classes.\n\nWhat do people gain from this? The elimination of God-objects, and a little more flexibility when re-organizing \"methods\" -- In my experience, IDEs can update `import` statements with little trouble, at least relative to moving methods between classes.\n\nOh, and you no longer have to worry what order your methods appear in a source file -- which I admit sounds pretty nice.\n\nWhat is the cost of this flexibility? From a performance perspective, the runtime now has to load and manage (and inject, in the case of Spring Framework) 150 objects instead of 10. Okay, so if you're building a web service, there will be a lot more objects than that being created with each request.\n\nBut blindly following OP's advice, a programmer may find oneself writing a bunch of short classes and dumping them across a package hierarchy. Then, each reference to a method requires its own import statement. If your REST API class (of which there will be one for each top-level URI if you're in Spring Framework) used to call 10 different methods on the same service-layer class, now you're calling a method on 10 different classes in mostly-the-same-package.\n\nAll of this is to say that splitting up every controller method into its own class may cause more bookkeeping than one wants to deal with. As I said before, your mileage may vary; you may decide that you value the benefits of OP's MVA over MVC, and I admit that there are benefits. On the other hand, if the idea of splitting your controller code into one method per class drives you batty, then that's sufficient reason to stick to MVC.", "id": "d7gh4f4"}, {"comment": "I write mostly C# and C++ with a bit of Python, none of which as you said have the one-class-per-file restriction, so I'd also be really frustrated with the explosion of source files.\n\nNow, I'm not a java guy, so I don't know how badly this messes with Java idioms, but what about treating the file-level class as a namespace?\n\nI've done this out of laziness for scratchpad java programs and assumed people thought it was bad form because of reasons mysterious to me. However, when I looked at the source for Clojure I saw it used this all over the place. Especially in [Compiler.java](https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/Compiler.java).", "id": "d7gokdz"}], [{"comment": "That sounds like a good model. What are your thoughts on this?", "id": "d7fitty"}]]], "42837c": ["Linus Torvalds on Not Acting 'Professional'", "2016-01-23 01:55:42", 33, "https://gist.github.com/bryanedds/09796865c0b54761b15c", [[56, "Why is this here? "], [49, "> I'm also not going to buy into the fake politeness,\n\nMost people call this \"social skills\"."], [33, "[deleted]"], [23, "It's depressing to see this stuff float up over and over again, and to see programmers make excuses.\n\nFor the record, I don't think Linus is some kind of maniac. He's probably a fairly nice guy who gets kind of into the heat of the moment. That's fine.\n\nBut I treat those moments as what they are: slip-ups in trying to not be a jerk to people, despite whatever circumstances (them not doing things to your standard, or disagreeing with you, or ...).\n\nThink about it; if you had a junior dev that generally did good work and was nice to people, but occasionally went sort of \"overboard\" on an email, how would you handle it? Pretend for a moment that lawsuits and corporate nonsense are not a concern. You'd probably say something like \"you're a good worker, but those emails are kind of over the top. You'd be a better worker if you didn't do that\". And if they were good guys, they would say \"yeah, you're right, I slip up like that sometimes, but I'll keep working on the frequency and the magnitude\". That's it. You wouldn't get a pile of nonsense about how \"that's just the way I am\". And you wouldn't get everyone else at the company saying that those emails were ok.\n\nThat's what really bothers me I guess. I'm not some social justice warrior that thinks that his emails are oh so appalling, I understand he's exaggerating and he doesn't literally wish that someone was aborted before birth (or whatever the quote was). It's just that he doesn't classify those emails as screw ups, he thinks they are totally cool. And there's a bunch of programmers that seem to agree, that those emails are totally cool.\n\nLinus can be an overall good person, and his outbursts can still be a thing that we classify as negative. We can even accept that they will happen occasionally, because we are all human and lose our tempers, while still wishing that it happened less often. So can we please do that, instead of pretending that these emails are perfectly ok?"], [16, "Did people here read the entire email? I think he makes a very good point. This excerpt makes him come off as an asshole but it doesn't if you take into consideration his entire email. \n\nThis post just sounds like a gossip magazine taking one line out of context from a celebrity just for sales. "], [10, "This is stupid as hell. I don't respect Linus for his interpersonal skills and I certainly wouldn't recommend anyone take this advice seriously in their professional lives.\n\nHe doesn't succeed because of his personality, he succeeds in spite of it."], [4, "I completely agree with this one. But I understand that he said that because he can."], [2, "What a shitty excuse for acting like a petulant child.\n\nSee I can talk like you too, Linus, and there's very little useful that comes from it."], [2, "Linus is a lot of fun.\n\nIf Poettering would only be as much fun ..."], [1, "He seems to not entertain the idea that some people are being genuinely polite in the workplace... I could understand how someone with that notion would rail against what they see as boundless conformity, but I fear his outburst says more about him than anything else."], [0, "What a dick Linus is.  And we still follow him. \nYou know he wrote Git as a joke while he was coked-up in Vegas one weekend?\n"], [0, "/r/linusrants if you like seeing Linus get mad on mailing lists."]], [[{"comment": "Why is this here? ", "id": "cz8iana"}, {"comment": "> Things I ask myself about every 2nd top thread in r/programming", "id": "cz8rdik"}, {"comment": "If you are referring to \"only code-containing submissions\" rule, it's dead for years. We /r/softwareDevelopment now.", "id": "cz8rwh4"}, {"comment": "That rule was never alive.", "id": "cz8z0k5"}, {"comment": "All communities deserve to get what they want, good and hard.\n\nIt is after all us that's doing this.", "id": "cz8wmup"}, {"comment": "Because everything that comes out of Linus' mouth is golden.\n\nWhen you've developed and managed a large piece of software, you have proven that you are a sort of ubermensch, and everything you say is insightful. Ordinary people such as you and I have faults, and these are sometimes revealed in what we say and do. If, for example, you were to say something that sounds obnoxious or egotistical, it would be evidence of a defect in your character. But if Linus says something like that, not only is it not actually objectionable, but it's always a reflection of the mindset which enables him to excel rather than the faults he hasn't overcome. So we need to contemplate his words carefully but uncritically, and pass them on to whoever is willing to listen so that they can profit by them as well, and so that we look a little bit more like Linus to them.", "id": "cz8szdg"}, {"comment": "Not true.\n\nIn this case, we have Linus articulating something very important and very profound that, given due reflection, many in the software development community can learn and grow from. Linus's name only makes it easier for this particular message to be exposed to a wide audience.\n\nI don't doubt for a second that if I could have formulated such an excellent distillation of wisdom, I would have done so myself! Only difference is that it would sit as a lone, ineffectual tweet on my twitter page, to be quickly forgotten.", "id": "cz8trlu"}, {"comment": "Maybe you should think about why you advocate one way of abuse over another. If you need to get f****ed in the ass, why prefer one way to the other? What difference does it make to you?", "id": "cz8uotq"}, {"comment": "Honesty is the lube that can make a corporate fucking bearable. ", "id": "cz8v2hz"}, {"comment": "I already knew you preferred that type of abuse. I was just asking _why_ do you prefer \"honest\" (straightforward) abuse.", "id": "cz8v867"}, {"comment": "I guess I have a bit more respect for someone is trying to screw me in a transparent fashion - it at least demonstrates some courage. More importantly, it's something I can prepare for, deal with, or even choose to walk away from before it happens. It puts me in a little more control over a bad situation.\n\nI can't have any respect for a coward who tries to do the same, but in a likely much more damaging and traumatic way - just so he might evade the consequences of it. I truly despise cowards who also abuse power.\n\nOf course, one would prefer to not be screwed either way. But we're talking about corporate America here, so...", "id": "cz8vgql"}, {"comment": "> and grow form.\n\nThat something being the undesirable behaviour of artificial unwarranted politness?\n\nMost programmers want to know how their code is crappy instead of discovering months or years later that they were basically polishing turds.", "id": "cz8urrk"}, {"comment": "Nobody anywhere is claiming that people should not have their code critiqued. Nobody. \n\nWe're saying you don't have to insult someone and rant like an asshole to do it. Why is that so fucking hard for you people to grasp?", "id": "cz9a9ee"}, {"comment": "People need to stop buying the idea that Linus is a nasty asshole. He's one of the nicer people you'll ever meet. \n\n4 rants out of 25,000 emails leading the LKML for TWENTY YEARS is hardly a definitive indicator of a person. \n\nFrankly this myth that Linus is a nasty person is laughable. \n\nOne of the first things Forbes and Businessweek reported about him was that he as actually a nice person, which surprised them because they kept meeting assholes like Stallman, Gates, and Jobs  who were all very abrasive and well known for it. ", "id": "cz9ls7m"}, {"comment": "> we have Linus articulating something very important and very profound that\n\nNo it isn't. ", "id": "cz91gk5"}, {"comment": "Man just imagine a community of 1000 linus' all with slightly differing views.", "id": "cz90rnx"}, {"comment": "Syria.\n", "id": "cz971mj"}], [{"comment": "> I'm also not going to buy into the fake politeness,\n\nMost people call this \"social skills\".", "id": "cz8fk5y"}, {"comment": "For a lot of people in Europe, when they move to the US, they find huge amounts of what seems to them to be \"fake politeness.\" That's what Linus is talking about.\n\nFor people that grew up in the US, it might seem like \"social skills\", because that's the society they are familiar with.\n\nSo both you and Linus are right, in a way. Both are reasonable perspectives.\n", "id": "cz8ir0l"}, {"comment": "This. All americans should take a few months to work in northern Europe and learn how to have a constructive professional disagreement. ", "id": "cz8p1ru"}, {"comment": "That's about as helpful as saying all Fins need to move to Brazil to learn what it is to share emotions. People grow up in a culture which shapes their own views, wants and things that work for them. Yet within each cultural mindset you'll find people that are productive or not. ", "id": "cz90i6p"}, {"comment": "I moved to america. I'm not sure what I'm trying to learn but I suspect it's some kind of agressiveness.", "id": "cz91ftz"}, {"comment": "This mindset does not work well for many US americans.\n\nI guess it depends on what part of Europe you would translate to - from New York to London it is possibly closer than say Los Angeles to Paris. Or Berlin ... :-)", "id": "cz8r91g"}, {"comment": ">US americans \n\nMiss South Carolina, what are you doing in /r/programming???", "id": "cz8u4d4"}, {"comment": "Are you aware, that there are other, non-US americans?", "id": "cz8wglf"}, {"comment": "As a Canadian, I have yet to meet any.", "id": "cz93uns"}, {"comment": "> This mindset does not work well for many US americans.\n\nRather they are not used to it. If they actually used communication to communicate for longer they might see benefits of it", "id": "cz8rvtw"}, {"comment": "What part of that is telling someone they should be retroactively aborted?", "id": "cz9abv6"}, {"comment": "The American English language is a beast built on syllogism, making nice of  nasty things like shitting yourself because you're incontinent and calling it \"an accident\". Finnish is a language where telling someone they're wrong involves telling them their mother should have worn a condom or better yet kept their trap shut, or even better, died long ago of maggots infesting their brain, and having lower bowel control problems is brought up pretty forthright.\n\nThe Nordic languages are fairly straight to the point. Failure in most classical Nordic cultures meant people died. \n\nA friend of mine encountered this recently when he saw his boss stand up at a meeting and swear loudly, declare \" fuck this, I need to go shit. Have a solution by the time I get back\" after the last 20 minutes were nitpicking over less vs sass. 15 minutes later, no solution was there so said boss took out a coin, flipped it and declared \"were using less. Coin says so,\" and walked out, swearing loudly in Finnish. \n\nSaid boss used to manage a nuclear tractor somewhere, if he's to be believed.", "id": "cz9bdtb"}, {"comment": "Not dealing with \"social skills\" and all the games that come with that is one of the reasons why a lot of people who gravitate towards tech gravitate towards tech in the first place. The same way you're telling those people to just \"deal with it and be normal\", those people can just say back to you \"no, you deal with it and fuck off\".", "id": "cz8fwks"}, {"comment": "Social skills are skills, and like technical skills or physical skills, they require practice and dedication. Just like every person should maintain some sort of exercise routine for their health, people should engage others and perform social exercises for the same reasons.\n\nNow, certainly, there are people who are non-neurotypical who aren't going to engage social skills in the same way, and even neurotypical individuals have blind spots (I suck at reading emotional cues and lack psychological mindedness). But like physical exercise, one should work within the boundaries of what their biology allows, and strive for constant improvement.", "id": "cz8gz7w"}, {"comment": "Unlike physical exercise, some people simply don't like dealing with other people and their life becomes better when they don't have to. Trying to force people and frame this like it's something that everyone has to do isn't helpful and isn't true. Not everyone wins from interacting with others, and not everyone wins from interacting with others in ways that are considered \"normal\".\n\nEveryone has different ways they prefer to act and trying to normalize everything so that everyone has a good experience is bad. I love people who jokingly insult me and who can take insults back. Should I not be allowed to behave like this with my friends because someone feels uncomfortable? No. If you feel uncomfortable you can just leave, especially if it's a public place, like an Internet forum.", "id": "cz8hkus"}, {"comment": "> Unlike physical exercise, some people simply don't like\n\nPhysical exercise sucks. While some people like it, most of us do it because we have to.\n\n> Everyone has different ways they prefer to act\n\nYes, but if someone decides, for example, that they don't want to participate in the social convention of wiping their ass, we rightfully point out that they're being shitty.", "id": "cz8hmo2"}, {"comment": ">Physical exercise sucks. While some people like it, most of us do it because we have to.\n\nYour analogy of physical exercise doesn't work. Some people feel better when they are alone and their quality of life improves when they are able to be mostly alone, even for long periods of time. My point is that socializing is not something people need to do to live a healthy life, unlike with physical exercise.\n\n>Yes, but if someone decides, for example, that they don't want to participate in the social convention of wiping their ass, we rightfully point out that they're being shitty.\n\nAnd if there's a group of people who think that not wiping their ass is fine, they'll keep not wiping their ass and being shitty to themselves. What does a normal person do in this situation? You just leave and let them do their own thing that you clearly don't understand. You don't hang around them and keep pointing out how shitty they are all the time.", "id": "cz8hshl"}, {"comment": "Even if you're introverted, you require social interaction. Being a hermit isn't normal. Also, that is totally different from the conversation. Social convention isn't about YOU, its about the people you interact with. You might not give a shit if you wipe your own ass, but you better not come near me with your shitty ass. That's an insult, you're saying that you're better than me.", "id": "cz8hz6z"}, {"comment": "In this situation Linus is the guy with the shitty ass, and everyone else are the people coming to him. So I don't know why you're talking about people coming to you with a shitty ass. Linus doesn't care about you and he clearly doesn't care about what you think of his shitty ass.", "id": "cz8i0ck"}, {"comment": "> Linus is the guy with the shitty ass,\n\nWhoa!!  4 rants out of 25,000 emails over twenty years is not someone who never wipes their ass. ", "id": "cz9m80m"}, {"comment": "Nobody living in any city is a \"hermit\".\n\nYou interact with other people ALL THE TIME.\n\nAnd nobody is unfriendly ALL THE TIME or never talks to anyone else.", "id": "cz8ranc"}, {"comment": "I wasn't implying living alone makes you a hermit, I was implying that hermits run away because they dislike other people, and that's not considered normal or okay. Social interaction is most definetly apart of being a healthy human being, and to interact socially you shouldn't be an ass.", "id": "cz8rbwb"}, {"comment": "And when someone acts like an ass from time to time, how about people not making it into something more than it usually is - a temporary lapse of patience and judgement. Just as not everyone has the same intellect, not everyone has the same temperament.\n\nThere's no need to apply negative labels when at the end of the day, we're all people with different perspectives trying to do our level best. Everyone gets frustrated because, frankly, businesses are demanding more and more from us and giving less and less in return.\n\nThere are actually many dynamics at play here, and we can't keep all turning against one another just because we have different personal needs.", "id": "cz8spz8"}, {"comment": "> Physical exercise sucks.\n\nTotally untrue. It depends on the kind of excercise.\n\nYou will see a huge difference between people doing acrobatics to bboying to professional gymnast to running a marathon to participating in MMA.\n\nAll those things are ultimately different and I am sure you can compare their motivational level statistically to find out which exercise is better/more fun and which one is less.\n\nSeveral of them will be addicted to exercise and a need to become better WITHOUT feeling that it drains them mentally.", "id": "cz8ra26"}, {"comment": "Yes, but to be clear, 4 rants out of 25,000 emails over twenty years of leading the LKML Is in NO WAY someone being \"shitty\". \n\nFrankly Linus has been pretty much a saint overall. Not a dick. 3 or 4 descents into having to tell people to wake the hell up over that time period is pretty reasonable considering what the membership there is. ", "id": "cz9m2q9"}, {"comment": "You implied that all people like physical exercise, which is false.", "id": "cz8qv4y"}, {"comment": "It's more like the *effects* of physical exercise are universally *good*.", "id": "cz8vpi8"}, {"comment": ">Should I not be allowed to behave like this with my friends because someone feels uncomfortable? No. If you feel uncomfortable you can just leave, especially if it's a public place, like an Internet forum.\n\nThe issue is how you behave when you are at work. ", "id": "cz8rmty"}, {"comment": "But why should all work places be the same? Why do we all have to follow a top-down imposed model that, according to Linus, causes more social problems than it solves?\n\nThat's the question I think people might be missing.", "id": "cz8s23d"}, {"comment": "Nobody said anything about a top down model (which, is what the Linux kernel uses). We're talking about not being an ass to people you're working with.", "id": "cz9ahea"}, {"comment": "The LKML Is NOT a Corporate environment.\n\nIts an  ALL volunteer project that has built the most successful tech product ever. ", "id": "cz9lzkv"}, {"comment": "Not only that, I've maintained for years that if these people with \"good social skills\" were as good at it as they thought, they'd get along just fine with the folks who have \"bad social skills\"\n\nWhen you strip all the bullshit away, what they really mean is \"people like me\".  It's always easier to get along with people like you, where the rubber hits the road is being able to understand, and get along with, people who are not like you.\n\nSoftware developers get along just fine with other software developers, gamers get along just fine with other gamers.  Just because those two groups don't get along with person X doesn't mean they lack social skills, it means they're not like person X and person X isn't as good at social skills as he'd like to think.", "id": "cz95uoi"}, {"comment": "You're missing the point. Being with other people is healthy, but doing things just because they are customary is stupid.", "id": "cz8t9iz"}, {"comment": "Not if it helps you achieve your goal/s.\n\nTake the extreme example.  You could earn $1 billion, but would have to do some customary things for one hour to do it.  Would it be \"stupid\" to do those customary things or not to do them?\n\nAlso, many customary things have become so for a reason, and many that go out of their way to avoid them are doing so because of a juvenile mindset.  \n\n- Slams door into old woman walking behind him \"I'm no slave to society!!!\"", "id": "cz8v5q5"}, {"comment": "Yes, but on the other hand you easily end up hurting people if you do what is considered polite instead of considering what course of action is best for everyone involved.", "id": "cz8ykdn"}, {"comment": "The vast majority of people don't \"practice social skills\". Just like playing a sloppy rendition of Smoke on the Water (with power chords) for five years isn't \"practicing guitars\", hanging out with your buds every night and making smalltalk with your coworkers and extended family isn't \"practicing social skills\".\n\nYou might be practicing your social skills if you are a member of Toastmasters, or are into *seduction*, or have read How to Influence People (or whatever it's called) and use it to get a leg up in your professional life or whatever. i.e., not most people. \n\nBut saying that most (reasonably social people) \"practice social skills\" is as conceited as a video gamer describing his hobby as honing his reflexes, strategic faculties and decision skills. *Most* people get by with some mixture of an osmosis of people's apparent expectations, coupled with their own insecurities and projections. Is the \"practice\" deliberate? No. Does the \"practice\" have any goals? No: people might **say** that they have goals like getting a significant other, but few people will actually put in the work of *practicing* a damn thing. Instead they will just go for some ready-made model of other people's expectation of them: \"play this part, and you will get favorable results\".\n\n\"Practicing social skills\" for most people means hanging out with their bud-buds every other night, and the occasional mingling with extended friends. That has about as much to do with *practicing* social skills as having played guitar for 15 years with your friends and still only knowing three chords (badly).", "id": "cz8vtlc"}, {"comment": "> The vast majority of people don't \"practice social skills\".\n\nNot in a structured fashion perhaps, but this is obviously false. All social interactions are practice.", "id": "cz8w2e6"}, {"comment": "No they are not. Just blindly (more or less) doing something is not practice. You will not automatically become better. You might even become worse, by adopting a *wrong* model of other people and their expectations. And just *doing* something doesn't entail actively seeking out more and more challenging scenarios; at best you will reach a flatline at some point where you have \"OK\" skills for what you want to achieve.\n\nJust like playing Smoke on the Water for 10 years won't make you into a guitar virtuoso. ", "id": "cz8w7hz"}, {"comment": "> at best you will reach a flatline at some point where you have \"OK\" skills for what you want to achieve.\n\nIsn't that where most people are at? There are the politicians, the actors, the socialites who have focused on the skills, but your average person has achieved a \"good enough\" mechanism that generally routes around conflict and gets them a reasonable chance of engaging meaningfully with other humans.", "id": "cz8wff0"}, {"comment": "Then what of all the talk about constantly practicing and honing ones social skills? Something which **most** people do **not** do. And arguably not in any capacity which could legitimately be called actual practice, even when they are not \"developed\" enough to have the social skills yet to reach that *flatline*.", "id": "cz91agx"}, {"comment": "I can say with complete truthfulness that I learned a lot from being blamed for the failure of a project I wasn't involved in. Yay learning! Why would anyone want to avoid it?\n\nMuch of what counts as \"social skills\" tends to boil down to dealing with the aspects of human beings that no one likes. How to deal with an angry screaming customer, how to deal with an abusive boss, how to get your coworker to turn the damn radio off, and so on.\n\nYou can get much better at all that stuff. People get amazing at dealing with angry customers. However, in terms of life quality, we'd all prefer to just tell those people to fuck off.", "id": "cz8syk7"}, {"comment": "I have shown a finger to your \"social skills\" for a some while.\n\nI have noticed I am happier and more respected than ever. I tell people almost directly what I think of them and accept what people say directly about me.\n\nI suppose your \"social skills\" are actually malfunctioning job society at work. You are only unable to tell others what you think about them, if you're a dog or their toy.", "id": "cz8k0do"}, {"comment": "Ironically if what you say is true, it is the actually the opposite of what you claim. Being able to tell people directly what you think of them while keeping their respect is a very much social skill.\n\nThere's a difference between being honest and being a dick about it. The former is a social skill, the latter is not \"chicanery\" or other things, it's just being a dick. Linus seems to confuse \"social skills\" with dishonesty and honesty with dickishness.", "id": "cz8vb36"}, {"comment": "There's an other reason to not be a dick. It is if you fear that other people think badly about you. Going the dick is sure way to be hated.\n\nBut why should you fear that? People hate so many things today. Some of them hate you even if you were politically correct. Why let your haters define who you are? Let haters hate.\n\nAnd being a bit of dick makes it easier for people to tell both the negatives and real positives.\n\nI could be wrong about this, but more often you're not a dick because of this reason, rather than respecting others. And it quickly falls apart from your other behavior because you represent your disrespect other ways. When the other guy notices that, the shit goes loose.\n\nWhen the other guy notices that, and goes with the same suite, the scenery is ready for some backstabbing.", "id": "cz8x31h"}, {"comment": "Spot on.\n\nSome call it 'social skills'... others call it 'chicanery'.\n\nIf it is the latter, as many believe, then there is no merit in wielding it - with it fitting only in the same 'skill' category as that of demagoguery.\n\nSuch a 'skill' is clearly, at least to me, on the dark side of the force.", "id": "cz9c13p"}, {"comment": "My toddler feels the same way about social skills.", "id": "cz8v4sm"}, {"comment": "People who harp on about \"social skills\" are invariably a buncha bullshitters who can't deal with their substandard work being rejected or criticized and insist on being \"included\" regardless of merit. \n\nProfessionalism?! The only real professionalism is to perform up to a professional standard. None of this \"social skills\" bullshit; that ain't professionalism, that's just a buncha bullshitters thinking they can bullshit their way through. ", "id": "cz8q6xu"}, {"comment": "> that is one of the reasons why a lot of people who gravitate towards tech gravitate towards tech in the first place\n\nWho do you personally know that develops professionally and never have to work with other people or show that they are at least somewhat socially normalized? Now compare that to the larger group of all professional developers; I'd wager that they're not the norm.\n\nTo be perfectly honest, it's not hard to surpass the competency threshold that most places typically requires. To be successful, whether in tech or anywhere else, you have to also hone your social skills in addition to being productive at your job.", "id": "cz8m4m0"}, {"comment": "Why is developing professionally a requirement here? In fact, the main rant is one against professionalism.\n\n>To be successful you have to also hone your social skills in addition to being productive at your job.\n\nThis is false, especially in tech.\n", "id": "cz8m987"}, {"comment": "Fine, developing for rent. Either way, however you cut it.\n\n\n>> To be successful you have to also hone your social skills in addition to being productive at your job.\n\n> This is false, especially in tech.\n\n\nOkay, let me put it in a different way. To have an above abysmal chance of becoming successful, you should also work on non-technical aspects of yourself. The bulk of these traits are included in the subset known as your personality and your social skills.\n", "id": "cz8mfq7"}, {"comment": "> To have an above abysmal chance of becoming successful\n\nBeing a CEO of amazon sounds quite successful to me.\n\nhttp://www.businessinsider.com/things-amazons-jeff-bezos-tells-employees-when-he-gets-angry-2013-10?IR=T", "id": "cz8w43y"}, {"comment": "Sounds like the guy understands the importance of social skill.", "id": "cz9pyto"}, {"comment": "That is not true either.\n\nYou can be socially incompetent but still make a fortune or be technically brilliant.\n\nOf course it would be better to be ALL OF THIS combined, but to state that the \"bulk of these traits\" is part of your \"social skills\", in particular when a lot of this is an \"accepted norm\" in one society but not in another (compare USA versus Japan here), simply is incorrect.", "id": "cz8rc0i"}, {"comment": "um, Japan has pretty rigorous social customs. Not sure why you would bring up Japan. ", "id": "cz8rjm2"}, {"comment": "I think it's because said culture is strikingly different from the two-faced, passive aggressive, politicized corporate culture we're talking about here.\n\nIn Japan, you can lose face very fast for that type of conduct.", "id": "cz8s3et"}, {"comment": "You can, I'm saying that it's unlikely that you will in the grand scheme of things. If anything, I'm also familiar with the culture in Japan, and if you don't play politics there, it's going to be even more difficult for you to succeed relative to the United States.\n\nGranted, I understand your point. I too prefer a meritocratic working culture. To a certain extent, I believe that my current working situation does award productivity and work ethic over pure politicking. Even then, how well other people want to work with me is a tenfolds better predictor of my future successes here than how much code that I can put out on my own.", "id": "cz9qde5"}, {"comment": "That's interesting, because across a couple of big tech companies I haven't met a single senior (or above) level dev who didn't at least have reasonable social skills. I know one guy who got held back from a promotion to that level because of his poor interactions with people.\n\nYou don't need to be buddies with everyone, outgoing, or really even  a nice person. But if you can't maintain a good working relationship with people then you aren't going anywhere. ", "id": "cz8rkc0"}, {"comment": "> Who do you personally know that develops professionally and never have to work with other people or show that they are at least somewhat socially normalized? \n\nYou are missing the point. That is not main part of the job, maybe 10% of it (in time spent).\n\n> To be successful, whether in tech or anywhere else, you have to also hone your social skills in addition to being productive at your job.\n\nNo, *to be promoted to management* you have to. To be a tech lead you have to have enough to be technical without being asshole about it and not be a source of conflicts. Yes you do need some but  that is by far not a main focus and what is usually called \"social skills\" in \"professional environment\" is \"lie and push people's buttons to get stuff you want\"\n", "id": "cz8ry9n"}, {"comment": "That's BS.  I know plenty of otherwise gifted engineers who go no where because they are anti-social.  Two mediocre engineers can work on a project together and by using their communication skills, be an order of magnitude more productive than a team of two highly-skilled cube hermit counterparts.  For any project that is going to require more than 1 person and that is going to require any sort of initiative to seek out information (as opposed to waiting around to be told exactly what to do) social skills are extremely important.", "id": "cz8vh0r"}, {"comment": "This is strictly a problem of simplistic management style - and not at all of one of engineer personalities.\n\nFor too long, managers have applied a one-size-fits-all methodology (EG - agile), eliminating with extreme prejudice any developer that doesn't fit that mold.\n\nAs Erik Meijer put it, working in Agile is like being a teenager working at McDonalds - there are so many processes and suffocating constraints that few expert cooks (or in our case, engineers) can reach a reasonable fraction of their potential.\n\nDespite what Linus's destractors say, we're not dealing with assholes here - we're dealing with people whose talent and capability have outgrown their manager's million-monkeys methodology.\n\nI have proposed an organizational style that will make my 2 gifted developers crush the output of your 2 code monkeys, and it's surprisingly simple - \n\nhttps://medium.com/@bryanedds/sharing-is-the-root-of-all-contention-f1ba6b9b82fc\n\nhttps://top.fse.guru/the-civilized-alternative-to-agile-tribalism-4c60d01428c0\n\nhttps://medium.com/@bryanedds/an-unexpected-inquisition-c4776bdedbb8\n\nIt's time management stop blaming the failures of their one-size-fits-all approach on the disparate personalities and expertise of engineers. If they can't understand how to structure development processes to capture the synergies unique to the team, then they either need to make an about face - or find something else to do.", "id": "cz8w32d"}, {"comment": "This approach still requires collaboration.  \n\n> This approach minimizes engineering contention by allowing engineers to collaborate mostly only at the boundaries of their code\u2019s contracts rather than inside implementation details.\n\nAny non-trivial project is going to require collaboration.  So my team of socially gifted engineers is still going to crush your technically gifted cube hermits for the vast majority of projects.\n\nAnd in the long term, their interaction allows for continued growth that eventually develops them into technically gifted engineers who can doubly crush your team with their ever improving combination of soft and hard skills.\n\nAnd in trying to develop a software development management style that minimizes social interaction and collaboration, it would seem more appropriate to use the \"code monkey\" term for your own team...\n\nCan you imagine trying to use a system like this for safety critical development?\n\n----\nLet's allow our electrical / mechanical / structural / software / etc. engineers to design this safety critical system in as much isolation as possible.  Instead of allowing brainstorming sessions and other forms of collaboration to reach an optimal design, we'll depend on individual heroics.  That guy that sits in the corner cube over there and refuses to leave, even for free food, would be a great choice for independently performing the system hazard analysis and deriving the resulting safety requirements...\n\nSuggested nobody ever...\n\nThe most successful teams I've seen include socially gifted, passionate, and nice engineers who can vehemently disagree in a respectful way, and are socially mature enough to move on to the next thing without taking it personal if the team decides to go in a direction that they don't agree with (after a thorough and fair debate).  \n\nThe team of isolationist engineers working with minimal collaboration and crushing complex projects is just something I've never seen work.  Not to say that it can't, but from my experience, I would imagine it would need to be led by an extremely gifted manager (who was willing to carry a huge work load).  \n\nOn the other hand, I've seen socially gifted teams of good engineers succeed even in the face of mediocre to poor upper management.", "id": "cz90fr8"}, {"comment": "It's a strawman to argue these people can't work with others.  The person who kicked all of this off is Linus Torvalds and he leads the largest OSS project in the world and interacts with people on a daily basis to get it done.\n\nMaybe you should stop attacking a strawman.", "id": "cz96e2i"}, {"comment": "Should be called social choices. People like Linus are perfectly capable of politeness or professionalism. They just don't value them.", "id": "cz8p2ho"}, {"comment": "Nah, they simply have them in a different place on their list of priorities.\n\nIf only people could stop being so black and white...", "id": "cz8s5bw"}, {"comment": "I agree - that is a much better way of viewing it.", "id": "cz8tiy0"}, {"comment": "> If only people could stop being so black and white...\n\nI have been wondering about that. Where does False Dicthomy get drilled into people and at what age?", "id": "cz8uuub"}, {"comment": "The point is that using 'social skills' simply leads to people acting out their intentions in even uglier ways, such as passive aggression, manipulation, back-stabbing, and social coercion.\n\nAll that for what? So some lilly flower can have their feelings spared for a fleeting moment?", "id": "cz8fvt9"}, {"comment": "That point has no basis in reality. And your choice of language betrays your true desire to just be an ass to people rather than some desire for being \"genuine\"", "id": "cz8hgve"}, {"comment": "> such as passive aggression, manipulation, back-stabbing, and social coercion.\n\nThese are things assholes do. And if you don't think Torvalds' approach to social interactions is not a form of social coercion wherein he uses his position of social power to control others' behavior, I've got a bridge to sell you.\n\nHumans are social animals. You can't escape this reality. You put three humans in a room, and you're going to have politics. You're going to have social dominance games. ", "id": "cz8h1ev"}, {"comment": "Sure you can escape reality..\n\nOn the other hand, you can put 3 introverts in a room, and everyone will pick a corner. And it will be quiet", "id": "cz8ncru"}, {"comment": "And they will get shit _done_!", "id": "cz8rac8"}, {"comment": "What kind of company do you work for where a large amount of people act like this all the time? I can see a handefull of people acting like this, but the way you speak about it, it makes it seem like everybody but you is evil. It sounds like you are using a strawman argument dude. ", "id": "cz8sgtu"}, {"comment": "I think this is a false dichotomy, though.  Like if you don't just shit all over people via email, you'll do it through backstabbing and office politics.  I don't agree that that's true, I think you can do neither.\n\nI do agree that some social norms, like dress codes and such, do nothing to promote healthy collaboration or discourage politicking.  But ranting and raving isn't the answer, either.  There are other ways to vent your frustration so that you don't have to mix it with getting your point across.", "id": "cz90n6d"}, {"comment": "You can do neither, but I've never found a team culture that didn't end up in one gulley or the other. And if I have to pick a poison, I'll pick the one with the word 'poison' written on it rather than 'magic corporate elixer'.", "id": "cz9cpd5"}, {"comment": "The dark side of this is manipulation. ", "id": "cz8g1mw"}, {"comment": "No more manipulation than acting like an ass to people.", "id": "cz8heoc"}, {"comment": "When I think of 'manipulation' I think covert rather than overt action.\n\nMaybe you have a different connotation?", "id": "cz8stbc"}, {"comment": "Covert or overt does not matter. ", "id": "cz9a052"}, {"comment": "Manipulation is inevitable. Even Torvalds' demeanor is an act of manipulation.", "id": "cz8gva1"}, {"comment": "I disagree - manipulation implies underhanded action, whereas Linus is being quite overt - even to the point of transparency. It's really the lack of transparency that pisses people off.\n\nIf I had to choose an evil, I'd choose the overt one, for at least it doesn't get all back-stabby when comes time for me to push back for technical reasons.", "id": "cz8sur6"}, {"comment": "> manipulation implies underhanded action\n\nNo, it doesn't. Manipulation implies directing people to do the things you want them to.", "id": "cz8w2qh"}, {"comment": "I believe that's more commonly known as 'instruction' or 'delegation' as opposed to 'manipulation'.", "id": "cz8w55c"}, {"comment": "To-may-to, to-mah-to. If you get someone to behave the way you wanted, you've manipulated them. The strategy you employed may be underhanded or overt, but it's still manipulation.", "id": "cz8w7fo"}, {"comment": "Meat is murder, wages are slavery, blah blah etc etc\n\nThat's not what we're talking about you manipulative shit.", "id": "cz93o2r"}, {"comment": "Social skills is communicating in a clear often straightforward way mixed with empathy. His emails are pretty clear and he doesn't call people bags of shit. He might call your code shit and not to send him anything if you continue to write code like that but for the most part his messages are thoughtful and coherent.\n\nI can have social skills and say your code makes me so depressed monkeys would see my agony. Social skills doesn't mean I can't/won't give out an insult", "id": "cz8rrji"}, {"comment": "Maybe someone should write up \"Social Skills Considered Harmful\"..", "id": "cz90byk"}, {"comment": "Thank you, this is the perfect title for my next medium post!", "id": "cz9cra1"}, {"comment": "Uhm ... nope.\n\nBesides, are you stating that Linus is not social? 3 kids and married? Leading a huge project? Creating git? Hmmmmm. Nah.", "id": "cz8r8d5"}, {"comment": "He's ignorant. We can't defend him when he's wrong, just saying that he's a Linux creator. People watch him and look up to him. I don't want all my colleagues to be as rude as Linus Torvards, even if they are good at what they do.", "id": "cz8rxv0"}], [{"comment": "[deleted]", "id": "cz8ckh2"}, {"comment": "> In some projects, you have guys like Linus who suggests you should be shot before reproducing,\n\nExcept that's not Linus.   As noted in the early days, by actual journalists at places like Forbes and Business-week, Linus is a very nice person and in fact much nicer than the average geek. \n\nBecause he has to police the Linux Kernel mailing list, once or twice a year he might be impolite in public.  But keep in mind, Linus has posted more than 25,000 emails to that list over the years. \n\nLinus is not a raving lunatic just because a few people on the internet got upset. \n\n\nShow me the numbers of his \"bad behavior\".  Its not real. \n\nLinus being a nasty person is a myth created on the internet by people seeking attention.\n\nIts a total distortion of reality. ", "id": "cz8fyds"}, {"comment": "People also discount just how very emotionally depleting hard core programming can be over time. When you code as hard and deal with as much complexity as Linus, you lose a lot of patience that everyone else takes for granted. Ego depletion (https://en.wikipedia.org/wiki/Ego_depletion) is a very pernicious thing, especially for programmers.\n\nAnd then you have the media and the politically-motivated who always attack engineers who hold any power and blow everything out of proportion - when they really should just try to give a little understanding.", "id": "cz8g54v"}, {"comment": "Linus is not doing hard core programming for a while already though.\n\nHard core quality control and management, yes :-)", "id": "cz8qrx9"}, {"comment": "Heh, either way, that shit catches up to you - and often in a sneaky way that you don't realize until shit starts flying out of your mouth.\n\nI don't know why people are denying these essential human experiences... Maybe they think by taking the faux-moral high-ground, they can keep a blind eye to their own ugly, passive aggressive conduct...", "id": "cz8rbsi"}, {"comment": "Its PC-SJW-extortion. It's become very common for SJW types to claim injury or offense where none really exists as a way of trying to control other people. \n\nBy claiming  Linus is a \"dick\" (false, 4 rants out of 25,000 emails over 20 years does not make someone a dick, it makes them a saint. ) They claim the right to change his behavior.  \n\n\nWell as soon as Google, most of the internet servers and most of the cell phones on the planet are using their OS, they will have the credibility to make that argument. \n\nUntil then, they should just go do their own thing.  And shut their festering Gobs.  :-D ", "id": "cz9j8a8"}, {"comment": "[deleted]", "id": "cz8td83"}, {"comment": " 4 rants out of 25,000 emails over 20 years does not make someone a dick, it makes them a saint.\n \nAnd your failure to understand this makes you a dick. \n\n", "id": "cz9jaf7"}, {"comment": "So, two moments out of TWENTY FIVE THOUSAND EMAILS OVER TWENTY FUCKING YEARS OF HERDING THE MOST STUBBORN PEOPLE IN THE WORLD? \n\nAnd you're going to classify him as an asshole? \n\nYou are the pinnacle of bias confirmation. \n\nCome back when you have done an actual analysis of his emails to the linux kernel list and can provide a reasonable analysis of his politeness level compared to the general population. ", "id": "cz93kiq"}, {"comment": "[deleted]", "id": "cz8zqk4"}, {"comment": "She's a \"justice warrior\" and \"feminazi\" because she said that berating and insulting others was not an appropriate way to behave in public?", "id": "cz9b15u"}, {"comment": "[deleted]", "id": "cz9baz5"}, {"comment": "I see nothing there that is a problem, or that is outside of what one would consider basic human decency. ", "id": "cz9bj2u"}, {"comment": "[deleted]", "id": "cz9bs6o"}, {"comment": "No, she isn't. Stop being paranoid", "id": "cz9bxnb"}, {"comment": "[deleted]", "id": "cz9c1jq"}, {"comment": "Jesus, go read the article, put the actual words in your head! ", "id": "cz9jhos"}, {"comment": " 4 rants out of 25,000 emails over 20 years does not make someone a dick, it makes them a saint. \n\nAnd your failure to understand this makes you a dick. ", "id": "cz9j9wm"}, {"comment": "You're delusional if you think it was only 4. And how do you explain the behavior that Sarah Sharp was describing when she left? Does that sound like anything but a hostile environment?", "id": "cz9lqem"}, {"comment": "> Both projects are successful. Courtesy and \"acting professional\" or not doesn't matter. The difference is merely that Linus looks like a successful raving lunatic (with some collateral damage along the way) and Matz looks like a successful normal guy.\n\nI'm not sure about that. It's very possible that different communities work best with different styles.\n\nFor example, Linux has huge corporate contributors with massive conflicts of interest. It also has a lot of contributors from smaller hardware companies that \"just want to get in the tree\". All together, that's a lot of potential for disagreements and wasting of time.\n\nRuby on the other hand has a very, very different community of users and contributors. It's not just much smaller - it's also very different in nature.\n\nIt's very possible Linus's approach works well for his environment, and Matz's for his. ", "id": "cz8io59"}, {"comment": "Very true.\n\nBut there also is a different philosophy.\n\nYou can think in pink ponicorns while you write ruby code.\n\nFor the linux kernel, with other projects depending on it, it is much much harder to have pink ponicorns (or the old whycats by _why and the poignant guide, for instance).\n\nI use Linux since +10 years (and the other ecosystem) and I use ruby since almost as long.\n\nBoth projects are great. I am more productive with both, too.\n\nBut ... as far as my love is concerned, it's definitely closer to ruby than to Linux even though the linux kernel is arguably more important. But ruby is where the real fun is at. (It is also much harder to compare because you often won't notice the kernel in everyday work; I use disparate applications, such as fluxbox as my main DE, kde konsole for all terminals most of the time, for scripting and automation I use predominantly ruby, browsing firefox and so forth... I would not want to lose ruby here but I also don't want to lose kde konsole either nor fluxbox. Fluxbox versus KDE, that is interesting because I don't like the whole KDE environment, I am less productive in it, but individual KDE applications are really really awesome. KDE Konsole is by far my favourite, yakuake is also great, I'd wish they would integrate quadkonsole, I'd just love to be able to have some kde konsole tabs be split up individually just like midnight commander. I do also use some gnome applications such as evince, and eye of gnome is also ok. It's quite strange to combine different programs but if you think about it, most people on windows do that too, by using different programs altogether)", "id": "cz8rj3s"}, {"comment": "> His rants are getting old.\n\nThis rant _is_ old. It was, actually, uttered during an email discourse that made his rants kind of famous. A whole bunch of people who have never contributed in any meaningful way to Linux development suddenly formed an opinion on both Linux and Linus Torvalds after that.\n\nIt all started, btw, by a hilariously misguided attempt by one contributor to promote and impose on others their personal view of what constitutes politeness.", "id": "cz8o4d7"}, {"comment": "Yeah that is typical. People who don't do any real contribution complain a lot.\n\nI give credit to Poettering and the systemd people here. They created something that a lot of other people use. While I don't agree with Poettering in regards to the criticism he did to Linus or on the fake-white-washing in favour of Red Hat's overdominance in the linux ecosystem and systemd, at the least he did create something that some other people use, so that at least makes his criticism more \"acceptable\" than those who did not contribute at all but just critisize linus.", "id": "cz8rk8t"}, {"comment": "> A whole bunch of people who have never contributed in any meaningful way to Linux development suddenly formed an opinion on both Linux and Linus Torvalds after that.\n\nThey're just being \"honest\". \n\nYou know, dispensing with the \"corporate bullshit\" and \"hypocrisy\" and calling it for what it is.\n\nThat's what we wanted, right?\n", "id": "cz976tr"}, {"comment": "Someone much wiser than me once said:\n\n> Opinions are like assholes. Everybody has got one.", "id": "cz98gw8"}, {"comment": "Including him. :P\n", "id": "cz998wt"}, {"comment": "It's a matter of personality. This is who he is, he's okay with that, and whether or not you're willing to put up with it is entirely up to you. About midway, he writes:\n\n> See what I'm saying? People are different. I'm not polite, and I get\nupset easily but generally don't hold a grudge - I have these\nexplosive emails. And that works well for some people. And it probably\ndoesn't work well with you.\n\nThe way I see this, is that Linus is a person who tends to overreact. As he say himself, he gets upset easily and he can say some nasty stuff when he's upset. But if you improve your work to a level he finds acceptable, he won't let that earlier disappointment cloud his judgment. \n\nHe's not interested in changing himself to make himself a nicer person to work with. He has accepted who he is, and if you can't, you shouldn't work with him. \n\nSure, a nicer atmosphere would motivate more people to contribute to Linux, but that doesn't fit him. Besides, if he had to bottle up all the anger, plus sift through an even larger body of code that makes him angry, he'd be dead in a month.", "id": "cz8gctl"}, {"comment": "Yeah but I actually find Linus polite so I have no idea why people keep on complaining about him.", "id": "cz8rg8j"}, {"comment": "They have to ceaselessly promote their 'narrative', it seems.", "id": "cz8s67q"}, {"comment": "His point is that being 'nice' has the unintended effect of making people act out in uglier, more dishonest ways than just being a bit abrasive now and again.\n\nIf that is true, then being 'nice' is in fact very destructive because it destroys the most basic value of human relationships - trust.", "id": "cz8gs0w"}, {"comment": "It's not as black-and-white, being supportive does not destroy trust by default. \n\nMany of us programmers spend some of our (usually free) time contributing to open source projects. If we don't feel at ease in a particular community, we're unlikely to contribute to it. There are probably many programmers who could make wonderful contributions to the Linux kernel, but who don't take the time because they don't like Linus's personality. \n\nDoes his personality impede the development of Linux? I honestly don't know. I'm sure it saves a lot of time reviewing bad contributions, at the cost of excluding good contributions from programmers who don't want to deal with \"Angry Linus.\"", "id": "cz8h5d0"}, {"comment": "four rants out of 25,000 emails for the past 20 years ???  \n\nNo, Linus is one of the nicer people you will ever meet and is is much nicer that your average Software geek. (we tend to be stubborn, somewhat egoist being convinced that were smart, and we always thing our idea is the right way to do it. )\n\nYou will find very few people who actually have a real problem with Linus.", "id": "cz9jngy"}, {"comment": "[deleted]", "id": "cz8kj8v"}, {"comment": "Yup, 2013 old.", "id": "cz8ec1h"}, {"comment": "> His rants are getting old.\n\nI wasn't aware that opinions had a lifespan.", "id": "cz8hku0"}, {"comment": "> In other projects, you have guys like Ruby-Matz, who is so nice\n> that the entire community decided to be nice as well.\n\nTotal crap. I wonder why you come up with this shit either - besides, it was not matz who coined the \"matz is nice and so are we\" either. How does this even translate anyway? Just because matz is nice, does not mean that others are necessarily \"nice\" or \"cool\" people. Matz is cool. Tenderlove is cool. Many other contributors are cool too. DHH is opinionated - I have no particular strong opinion against him, but being so opinionated is annoying to me. I never had that feeling with matz in the slightest. And Linus? Yeah, Linus is very opinionated too but I never found this to be a problem. In fact - all those rants about Linus just show that people are unable to come up with technical arguments that are sound, so they have to focus on straw man \"arguments\". And when their points are shattered by technically accurate statements, they are helpless, don't know what to do and so resort to mud slinging drama. \n\nMatz is awesome and so is Linus.\n\nHowever, Matz is not always 100% nice - when you make silly proposals and keep on insisting that these should happen, you can find that Matz is in total disagreement and he will state so too. Because ultimately, ruby is his language and if you want a better language, go develop it.\n\nAlso remember, matz contributed to competition like crystal too with a hefty donation, so think about the implication of that. He welcomes competition of ideas.\n\nI guess we can all agree that matz rules, even if you are not always in agreement (I am not always either, static strings still scare me for the ruby 3.x era).", "id": "cz8rfpv"}, {"comment": "Reply that was deleted? \n\n>[\u2013]moisays \n\n>>How does this even translate anyway?\n\n>By applying common sense. You should try it sometimes. \n\nPretty strange coming from a person who thinks Linus isn't nice. \n\n\n\n", "id": "cz9jqk6"}], [{"comment": "It's depressing to see this stuff float up over and over again, and to see programmers make excuses.\n\nFor the record, I don't think Linus is some kind of maniac. He's probably a fairly nice guy who gets kind of into the heat of the moment. That's fine.\n\nBut I treat those moments as what they are: slip-ups in trying to not be a jerk to people, despite whatever circumstances (them not doing things to your standard, or disagreeing with you, or ...).\n\nThink about it; if you had a junior dev that generally did good work and was nice to people, but occasionally went sort of \"overboard\" on an email, how would you handle it? Pretend for a moment that lawsuits and corporate nonsense are not a concern. You'd probably say something like \"you're a good worker, but those emails are kind of over the top. You'd be a better worker if you didn't do that\". And if they were good guys, they would say \"yeah, you're right, I slip up like that sometimes, but I'll keep working on the frequency and the magnitude\". That's it. You wouldn't get a pile of nonsense about how \"that's just the way I am\". And you wouldn't get everyone else at the company saying that those emails were ok.\n\nThat's what really bothers me I guess. I'm not some social justice warrior that thinks that his emails are oh so appalling, I understand he's exaggerating and he doesn't literally wish that someone was aborted before birth (or whatever the quote was). It's just that he doesn't classify those emails as screw ups, he thinks they are totally cool. And there's a bunch of programmers that seem to agree, that those emails are totally cool.\n\nLinus can be an overall good person, and his outbursts can still be a thing that we classify as negative. We can even accept that they will happen occasionally, because we are all human and lose our tempers, while still wishing that it happened less often. So can we please do that, instead of pretending that these emails are perfectly ok?", "id": "cz8iqfa"}, {"comment": "I disagree with you. If you look at most (or all?) of his 'slip-ups' he has reasoning and they're pretty good. It isn't simply 'go eat a dick' and never that offensive. He calls your code shit he doesn't call you shit.\n\n", "id": "cz8rq7j"}, {"comment": "Here's the quote that I mentioned:\n\n> Of course, I'd also suggest that whoever was the genius who thought it was a good idea to read things ONE F*CKING BYTE AT A TIME with system calls for each byte should be retroactively aborted. Who the f*ck does idiotic things like that? How did they noty die as babies, considering that they were likely too stupid to find a tit to suck on?\n\nIt's clearly talking about the person not the code. And it's also worse than \"go eat a dick\", to be frank; it's pretty offensive. As for having reasoning:\n\n> trying to not be a jerk to people, despite whatever circumstances\n\nIt doesn't really matter how bad the code was, there's still no reason to handle it this way. Anyhow, thanks as stepping up and serving as an example of apologist (when apparently you don't even know what he's written that people have gotten worked up about).", "id": "cz9bwlk"}, {"comment": "> It doesn't really matter how bad the code was\n\nYes it does. Its a software project, but it's not just a software project its the kernel. Do you understand why the code was wrong.", "id": "cz9l97e"}, {"comment": "Welcome to the tradition hyperbole of Geek online tech lists. \n\nNow, how does 3 or 4 of those out of 25,000 emails over TWENTY FUCKING YEARS of riding herd on an all volunteer, group of the most stubborn, egoist engineers to ever exist  matter at all? \n\nIt doesn't. \n\nFrankly Linus has been a saint virtually all of the time.   Any other human would have cracked and gone ballistic hundreds of times by now. ", "id": "cz9ksoa"}, {"comment": "Hahahahahahah omg that's hilarious. Uhhhh IDK what to say about that. I have to agree with how stupid it is to read a byte at a time. I guess I'll say bosses (maybe not a manager but a CTO or CEO) will say shit like that so... its life? I wonder if I would say something like that. Maybe I would bc if someone had no idea what they were doing and didn't have it peer reviewed before coming to me I might let some words fly. I'd probably give a warning at first tho. But if it was an anonymous patch and it was shit like that I'd probably say something like that", "id": "cz9ghxj"}, {"comment": "There's a certain type of person that expects all others to be perfect angels who restrain their emotions like monks. The people who freak out over the spectacle of Linus Torvalds being ANGRY! SOMETIMES! are probably the same ones who think police officers should take 3 bullets to the chest before drawing their weapon.\n\nAnd they're all hypocrites once you look at their post history.\n\nThe only reason anyone gives a crap is because we've turned every mundane interaction involving \"notable people\" into a media spectacle. The Phil Fish effect.", "id": "cz945xj"}, {"comment": "The biggest problem isn't even that Linus feels his childish rants are ok, it's that a lot of people look up to him and assume that this is what's expected.", "id": "cz8qjo6"}, {"comment": "The reason people see this is ok, is that they are similar to Linus and used to abusive behavior. It may be emotional shallowness or just that they don't get social cues themselves. Also, they may have parents that are / were abusive and authoritarian. Ordinary people tolerate him because he might be essential for getting their pay check. We all know people like these, but you can still be polite with them (even though they are unable to themselves). I had this conversation with my brother recently, he was driving my car:\n\n- Hmm, this car has automatic shift that's geared towards economy, so engine braking is really slow, especially here in downtown. People are getting anxious behind you.\n- Yeah, but it's better for the car, saves the brakes and the engine.\n- Look, maybe you don't understand but I'm kind of tired of driving at the snail's pace so just use the brake pedal. It's my car so I'm paying for the parts.\n\nAnd he still didn't kind of get it :D. I didn't even go to the point where considering other people when driving is kind of a cool thing, since he doesn't really get that. He likes rules, and it's not illegal to drive like a grandmother.\n\nIt is sort of sad, and yes, these people have limited \"social intelligence\", and they're lucky if they have some special skill that allows them to function well in the society. If not, they're called \"idiots\", and they're pretty much f****d.", "id": "cz8sx6l"}, {"comment": "This is the biggest load of horseshit I've ever seen.\n\nTaking your own anecdote; it's a bit like Linus driving 15 miles under the speed limit while you're behind him saying \"hey, it might be more professional of you to drive the exact speed limit\" while he's saying \"fuck you, this is how I drive. Get over it.\"\n\nSo at this point, instead of behaving like an adult and realizing that he's entirely entitled to drive well under the speed limit -- and instead of simply passing him on the left and forgetting about it -- you're purposefully staying directly behind him and criticizing his driving because it's \"affecting\" you in some way.\n\nThe guy has every right to drive at whatever-the-fuck speed he wants with his own project. And you have every right to be offended by how slow he's driving. But you always have the option to exit stage left -- and just because you're offended that doesn't mean _something happens_ because of it. \n\n[This is pretty relevant.](https://youtu.be/fHMoDt3nSHs?t=203)", "id": "cz8vuek"}, {"comment": "That wasn't the point. The point was the inability to take social cues and respect others and make their lives a bit easier with your behavior. I mean, good manners don't cost nothing, right.\n\nEdit: And as for being offended. Nah, he's just driving like a granny, I wasn't offended by that. It's just a friendly advise to maybe use the brake pedal instead of waiting for a queue to form behind him so we don't look like a bunch of elderly driving a way overpowered car :D.", "id": "cz8xx0h"}, {"comment": "No it wasn't. Using profanities in communication has nothing to do with respect. Where is it written that because I use \"fuck\" in an email that means I have no respect for you?", "id": "cz90c1r"}, {"comment": "1 day old account - Likely Sock Puppet. ", "id": "cz9knuj"}, {"comment": "Way to go. Is your life completely about reddit? Any real people in your life?", "id": "cz9usj8"}, {"comment": "Hmm, thought I heard something there for a moment, but it was only the wind. ", "id": "czagut6"}, {"comment": "There's absolutely nothing wrong with saying \"I'm an asshole. If you choose to work with me, that's what you have to deal with.\" There's also nothing wrong with saying \"This is a professional environment, you should act better.\"\n\nBut as Americans, it's perfectly fine if he tells you to suck a dick, too. His rights don't end where your feelings begin, and he's not a bad person for keeping your emotions and feelings out of his project. It's also not unprofessional for him to do so.\n\nPeriod.", "id": "cz8vrnq"}, {"comment": "He's not American.", "id": "cz9e8pt"}, {"comment": "He's lived in Oregon for like 10 years. Of course he's American... Just because you weren't _born_ here doesn't mean you're not _from_ here.", "id": "cz9f4nj"}, {"comment": "I didn't realize that. Either way I don't think nationality is that important in determining reasonable expectations for someone in an online community.", "id": "cz9finf"}, {"comment": "FYI, Buddy, Linus acts MUCH NICER than most people in online tech communities. :-D ", "id": "cz9ij7v"}, {"comment": "Neither do I. I was more relating it to \"it's a free country\" or \"it's an open web.\"", "id": "cz9fnhv"}, {"comment": "He acquired US citizenship a few years ago and lives here since 1997. ", "id": "czatk7e"}, {"comment": "Linus is very aware of the human factor. Much more so than you are.\n\n And he demonstrates that continuously. Please provide some real numbers about how many times he was inappropriately impolite/offensive versus the over 25,000 emails he has posted to that list. \n\n#Twenty Five Thousand to five?   You would have done much worse. \n\nHis rants ARE OK.  Because he almost never does them and when he does do them, he has good reason to and they accomplish what he needs done. \n\nGet a fucking grip on reality.  If you were doing what he has been doing, you would have had total meltdowns and ragequit the whole thing. \n", "id": "cz93ccw"}, {"comment": "This actually concerns me quite some bit. One of the things I like about Linus is his honesty. If people look up to him,  thy should read his emails and study the context. He normally only goes ballistic at people that should have known better. \n\nIf people see this as normal behavior,  they should check twice. It's not and I guess Linus knows that he gets away with it because he got the credit. ", "id": "czathw3"}, {"comment": "It's people choosing sides, depending on their experiences and perspective.\n\nSome people would prefer to be coddled and manipulated, while others prefer brutal honesty and self-determination.\n\nAs far as I can tell, the engineering community is split down the middle.\n\nLet a thousand flowers bloom, I suppose.", "id": "cz8rdx4"}, {"comment": "No, its not split down the middle. if it was, the Linux kernel would have been forked by some minor faction some time ago.  \n\nThe Linux community is substantively aligned with Linus.   Loud whiners on the Internet get much more visibility than their actual numbers should represent.  But that's a good thing because it means dissent will be well heard. And then, if the dissent has any actual validity, it will get supported. \n\nThis dissent has no credibility. ", "id": "cz9ibga"}, {"comment": "> As far as I can tell, the engineering community is split down the middle.\n\nAre you basing that on personal experiences or hearing people on internet. Because vocal people on internet are not exactly a best thing to go at.\n\nIt is way too easy to see something out of context, dont bother to research and go \"yea, what he/she said\"\n", "id": "cz8t5k7"}, {"comment": "I'm afraid I only have anecdotal evidence on the matter.", "id": "cz8tc0s"}, {"comment": "Why is it that everyone advocating abusive communication claims that the only alternative is coddling?   It's not a choice between one or the the other -  it is possible to be honest and direct without resorting to ad-hominem attacks.  ", "id": "cz92vj5"}, {"comment": ">  without resorting to ad-hominem attacks. \n\nLOL.  Since when is 3 or four rants out of 25,000 emails \"Advocating abusive communications\"??? \n\nCan you even count?   Have you even looked at the LKML archive? \n\n#\\#1 First and foremost the idea that Linus is constantly abusive is a FUCKING MYTH!!!!!!\n\n\n# SHOW ME THE CONSTANT STREAM OF ABUSE HE HAS PUMPED OUT INTO THE LKML FOR THE PAST TWENTY YEARS OR SHUT THE FUCK UP!!! \n\nThe archive are public. You can download every single email he has ever sent to it and find every instance where he was \"abusive\". \n\nGo ahead, I'll wait. ", "id": "cz9igyn"}, {"comment": "I can count to one.  That is the only number that counts.", "id": "cz9o7f2"}, {"comment": "> Think about it; if you had a junior dev that generally did good work and was nice to people, but occasionally went sort of \"overboard\" on an email, how would you handle it? Pretend for a moment that lawsuits and corporate nonsense are not a concern. You'd probably say something like \"you're a good worker, but those emails are kind of over the top. You'd be a better worker if you didn't do that\". And if they were good guys, they would say \"yeah, you're right, I slip up like that sometimes, but I'll keep working on the frequency and the magnitude\". \n\nNot only is this not how real life works -- it's also not even close to how Linus is relating the situation.\n\nHe's saying, it's totally fine for that junior dev to go overboard sometimes, and it's totally fine for people to not be okay with that. It's a professional working relationship. You don't __have__ to like people on a personal level to work with them. It may help some times, but the only thing you should be concerned about with that junior dev is if he __gets shit done__.", "id": "cz8vq6w"}], [{"comment": "Did people here read the entire email? I think he makes a very good point. This excerpt makes him come off as an asshole but it doesn't if you take into consideration his entire email. \n\nThis post just sounds like a gossip magazine taking one line out of context from a celebrity just for sales. ", "id": "cz8lzhz"}, {"comment": "Context matters, that's for sure.", "id": "cz8mofu"}, {"comment": "> This post just sounds like a gossip magazine taking one line out of context from a celebrity just for sales. \n\nAnd welcome to /r/Linux. Enjoy your stay.", "id": "cz8relz"}, {"comment": "Except the last paragraph. Everything except the last paragraph was OK.", "id": "cz9d84b"}], [{"comment": "This is stupid as hell. I don't respect Linus for his interpersonal skills and I certainly wouldn't recommend anyone take this advice seriously in their professional lives.\n\nHe doesn't succeed because of his personality, he succeeds in spite of it.", "id": "cz8gnao"}, {"comment": "He maintains and works as a street police for a fucking kernel that is used by millions and that gets contributions from thousands of people. It's larger management task than you find in any of software companies today.\n\nThat is a good evidence of interpersonal skills.\n\nhttps://en.wikipedia.org/wiki/Delusion", "id": "cz8kfoc"}, {"comment": "Why? I see no problem with his personality at all, so I don't understand why you write \"succeeds in spite of it\".", "id": "cz8rkl3"}, {"comment": "You bought the fucking myth. \n\nfour rants out of 25,000 emails to the LKML over TWENY YEARS, is not an indication that Linus is a Dick. Its an Indication that he's a Saint. \n\nStart thinking critically an dstop believing everything you hear. ", "id": "cz9jsm3"}], [{"comment": "I completely agree with this one. But I understand that he said that because he can.", "id": "cz8fb2f"}, {"comment": "He's a straight shooter with upper management written all over him.", "id": "cz8isi7"}, {"comment": "though I hear he's been having a problem with his TPS reports...", "id": "cz8lu3a"}], [{"comment": "What a shitty excuse for acting like a petulant child.\n\nSee I can talk like you too, Linus, and there's very little useful that comes from it.", "id": "cz8g9p4"}, {"comment": "> You bought the fucking myth.\n> \n> \n> \nFour rants out of 25,000 emails to the LKML over TWENY YEARS, is not  indication that Linus is a Dick. Its an Indication that he's a Saint.\n \n \n \nStart thinking critically and stop believing everything you hear. \n\n", "id": "cz9jvtb"}], [{"comment": "Linus is a lot of fun.\n\nIf Poettering would only be as much fun ...", "id": "cz8r80a"}], [{"comment": "He seems to not entertain the idea that some people are being genuinely polite in the workplace... I could understand how someone with that notion would rail against what they see as boundless conformity, but I fear his outburst says more about him than anything else.", "id": "cz90vwn"}, {"comment": "Actually he does. And he demonstrates that continuously. Please provide some real number about how many times he was inappropriately impolite/offensive versus the over 25,000 emails he has posted to that list. ", "id": "cz9358e"}], [{"comment": "What a dick Linus is.  And we still follow him. \nYou know he wrote Git as a joke while he was coked-up in Vegas one weekend?\n", "id": "cz90bhl"}, {"comment": "I appreciate your satire.   I think it went over the head of most people.   Oh, and it was Crack, not coke.  ", "id": "cz9imc9"}], [{"comment": "/r/linusrants if you like seeing Linus get mad on mailing lists.", "id": "cz98egb"}]]], "4orgi1": ["Welcome to Framework Hell", "2016-06-19 06:14:06", 2, "https://medium.com/@garywiz/welcome-to-framework-hell-aa54a9b5d4fd#.smbf6zxi6", [[25, "> I am an expert programmer.\n\nSo you're definitely not an expert programmer..."], [20, "Just so you know, there are probably many people like myself who read the first sentence and stopped reading this."], [3, "Very good points.\n\nThe claim that programmers are tribal, hence framework islands, is too specific. **People** are tribal. Business is conducted in tribal ways. It takes guts/foresight to admit/see other ways of doing it.\n\nI particularly love the observation that frameworks are supposed to relieve us from low-lever grunt, but going in takes us into their rabbit holes, whatever they are. Overall, it is better than doing it all by yourself, but much less than what some framework-assembling \"architect\" might think."], [3, "I somewhat agree with his conclusion that we need more engineering discipline in information technology... but as far as computer science goes - that's a terrible idea...  the reason why the field continue to make large advancements (or rediscoveries) in software is maily due to it's fluid nature and low barrier to entry. Yes it's unfortunate that we have a bunch of reinvented wheels... what's the real cost? Failed Enterprise IT projects? That's mostly due to bad money being thrown after good... and vendors rebranding open source software as high priced Enterprise Products... and the cost of project managers... there are way more problems to solve in modern software development outside of the glut of frameworks. Engineering practices won't solve that."], [2, "I don't think it's necessarily fruitful to compare software development with something like electrical engineering in the manner that this article does. In software development, there is a virtually limitless number of ways to build almost anything and have it perform decently, and the risks of trying new things are low. In electrical engineering, on the other hand, or in something like bridge-building... correct me if I'm wrong, experts in those fields, but it seems to me that the number of known ways to build anything so that it is safe, effective, and affordable is usually pretty small. And because when you are building hardware, testing is much more expensive and the consequences of failure more likely to be dangerous, trying new things is much more risky than it is in software development.\n\nPart of the reason why software development is in the state that it's in is precisely because it's so easy to try new ways of doing things. Of course there are going to be thousands and thousands of different options. This leads to some negative consequences, yes, but it is also a good thing."], [1, "I never understood the obsession with how many different frameworks there are. Yeah, most of them are probably junk. I just ignore most of them."], [1, "> But no. If you know Sympfony, Django will be a complete mystery. Program using Node.js? You\u2019ll have to start from scratch if you want to learn Twisted. You\u2019re an expert in jQuery? Get ready to relearn everything if you switch to Dojo. Even if you\u2019re an expert, you\u2019ll end up gasping at how perversely arcane the configuration, structure, and deployment can be for different frameworks.\n\nIt is baffling to me that hiring managers and developers alike adopt this point of view.  Assuming decent documentation, it isn't much trouble for a good programmer who knows a few design patterns to pick up a new framework, and be productive later that day."], [1, "The responses to this article strike me as so strange.  The point of the article makes sense to me, perhaps because I'm also a dinosaur (started writing code in the 1970s).  The modern development landscape is a mess - there are hundreds of thousands of new approaches to solving the same old problems, and young developers seem to think that those solutions are better, by default, than solutions which have worked perfectly in the past, simply because they're newer.  The need to keep up with new platforms doesn't mean that progress is being made.  Millions of developers are wasting billions of man hours trying to re-invent wheels, often \"solving\" simple UI \"problems\" in new ways, to create glorified CRUD apps.  It would be great if newer challenges could be tackled instead.  Most of that real work is being done using platforms, languages, methodologies which are decades old."], [-1, "[Sort of relevant xkcd](https://xkcd.com/927/)"]], [[{"comment": "> I am an expert programmer.\n\nSo you're definitely not an expert programmer...", "id": "d4f18nl"}, {"comment": "Why not?", "id": "d4f8rf7"}, {"comment": "Corollary to Dunning-Kruger: Experts generally don't self-identify as experts because they are overwhelmingly aware of how much they don't know.", "id": "d4f98p7"}, {"comment": "the curve rises back up when you come to actual expert, so it can be misleading", "id": "d4favvi"}, {"comment": "Really... it all comes down to context.  Were this article written for a laymen, then claiming to be an expert at \"programming\" is fine... however, this article is written for programmers.  Claiming to be an expert is silly in this case.  Really, you are an expert in *all of programming*?", "id": "d4gruwt"}, {"comment": "Fair enough, I suppose it is like that. But I still think the authors point stands, expert or not. Just for the record.", "id": "d4fguv6"}], [{"comment": "Just so you know, there are probably many people like myself who read the first sentence and stopped reading this.", "id": "d4eyx8m"}, {"comment": "I am subscribed to at least 15 subreddits, and have upvoted well over 1 hundred comments myself. I'm not bragging, but merely indicating that upvoting is not new to me.", "id": "d4ez53j"}, {"comment": "I changed it to \"very experienced\" so people aren't put off.  Whether I'm an expert wasn't really the issue.   My point was that I've seen a lot of code in the 38 years I've been doing this professionally, and worked on a lot.  I'm not a noob to code, frameworks, libraries, and have seen tons and toons.  Sometimes people see articles where people are \"overwhelmed by choices\" and shrug it off because, of course, any new programmer can be easily overwhelmed.  But, that's not me. ", "id": "d4f5snf"}, {"comment": "Is your experience relevant to the article? Your points either stand on their own or they don't. Your observations are either relatable or they are not. I'm not going to just take your word for it because you are an experienced programmer. There are lots of very experienced programmers.\n\nPersonally, I find the article fairly myopic and authoritarian. At no point do you address the experiences and motivations of the developers behind the frameworks. You just assert that there is no good reason to have so many. This is not remotely convincing. Any developer who has experienced tangible benefits switching between frameworks is going to dismiss this immediately. There are *reasons* people create new frameworks when there are existing alternatives and you address absolutely none of them.", "id": "d4f70cg"}, {"comment": "As a follow up I would like to mention that the author insist that programmers require certifications to work professionally but this won't prevent the creation or use of OSS frameworks.", "id": "d4f8dc4"}, {"comment": "He does suggest:\n\n>... no programmer should be able to build a framework unless they have an advanced certification in systems architecture.\n\nWhich I assume is intended to cover OSS frameworks. How would it be enforced? No one knows. Who would design this course? Again, no one knows. Would this even increase the quality of widely used frameworks? Probably the opposite.", "id": "d4f8w9n"}, {"comment": "Show, don't tell.\n\nIf you're as experienced as you say, then let the weight of your arguments speak for themselves.\n\nCiting your experience to start the discussion might be reassuring to you; but it makes *me* very uncomfortable because frankly, on the internet, I don't trust self-cited authorities.", "id": "d4gffdl"}, {"comment": "Fair enough. I don't think it was meant to be condescending if that's what you mean. ", "id": "d4ez5xj"}, {"comment": "It's not condescending, it's bragging. I know you say that's not what it's meant to be, but that is what it is.", "id": "d4f2xpx"}, {"comment": "[deleted]", "id": "d4f397p"}, {"comment": "Thanks for that.  I did exactly what you're suggesting.  I wasn't really wanting to blow my own horn, just set the stage so people knew I wasn't coming at this from a newbie perspective.", "id": "d4f5typ"}, {"comment": "Actually - you are coming at this from a newbie perspective. If you're \"not much of a web guy\" and your past web experience is some Django and PHP then you don't get to position yourself as an authority on web frameworks.", "id": "d4f7byr"}, {"comment": "I'm not going to jump all over you, but there are a lot of \"I\" sentences. I know you're writing about your experience, but that makes me think back to high school (or earlier!) English class, and that there's a way around \"I\" that I can't find in Google right now. :)", "id": "d4fi8ic"}, {"comment": "I was put off by the \"I'm fluent in 15 programming languages\". I just don't buy it. It's just bragging to say \"I'm really good please listen to me\". \n\nYou can write some simple code in 15 languages? Yes, I guess. Are you actually fluent (as in being able to develop complex programs and know some of the intricacies and specific details to those languages)? I highly doubt it.\n\nBut I enjoyed the rest of the post and agree with some of the points.", "id": "d4f7lwa"}], [{"comment": "Very good points.\n\nThe claim that programmers are tribal, hence framework islands, is too specific. **People** are tribal. Business is conducted in tribal ways. It takes guts/foresight to admit/see other ways of doing it.\n\nI particularly love the observation that frameworks are supposed to relieve us from low-lever grunt, but going in takes us into their rabbit holes, whatever they are. Overall, it is better than doing it all by yourself, but much less than what some framework-assembling \"architect\" might think.", "id": "d4f48o9"}, {"comment": "The claim that the software world is tribalistic is not to claim that it is somehow exceptional in that regard, but to affirm that it is not excepti0nal", "id": "d4f7egx"}], [{"comment": "I somewhat agree with his conclusion that we need more engineering discipline in information technology... but as far as computer science goes - that's a terrible idea...  the reason why the field continue to make large advancements (or rediscoveries) in software is maily due to it's fluid nature and low barrier to entry. Yes it's unfortunate that we have a bunch of reinvented wheels... what's the real cost? Failed Enterprise IT projects? That's mostly due to bad money being thrown after good... and vendors rebranding open source software as high priced Enterprise Products... and the cost of project managers... there are way more problems to solve in modern software development outside of the glut of frameworks. Engineering practices won't solve that.", "id": "d4f1b58"}], [{"comment": "I don't think it's necessarily fruitful to compare software development with something like electrical engineering in the manner that this article does. In software development, there is a virtually limitless number of ways to build almost anything and have it perform decently, and the risks of trying new things are low. In electrical engineering, on the other hand, or in something like bridge-building... correct me if I'm wrong, experts in those fields, but it seems to me that the number of known ways to build anything so that it is safe, effective, and affordable is usually pretty small. And because when you are building hardware, testing is much more expensive and the consequences of failure more likely to be dangerous, trying new things is much more risky than it is in software development.\n\nPart of the reason why software development is in the state that it's in is precisely because it's so easy to try new ways of doing things. Of course there are going to be thousands and thousands of different options. This leads to some negative consequences, yes, but it is also a good thing.", "id": "d4f5wqw"}], [{"comment": "I never understood the obsession with how many different frameworks there are. Yeah, most of them are probably junk. I just ignore most of them.", "id": "d4faxtb"}], [{"comment": "> But no. If you know Sympfony, Django will be a complete mystery. Program using Node.js? You\u2019ll have to start from scratch if you want to learn Twisted. You\u2019re an expert in jQuery? Get ready to relearn everything if you switch to Dojo. Even if you\u2019re an expert, you\u2019ll end up gasping at how perversely arcane the configuration, structure, and deployment can be for different frameworks.\n\nIt is baffling to me that hiring managers and developers alike adopt this point of view.  Assuming decent documentation, it isn't much trouble for a good programmer who knows a few design patterns to pick up a new framework, and be productive later that day.", "id": "d4ffo8q"}], [{"comment": "The responses to this article strike me as so strange.  The point of the article makes sense to me, perhaps because I'm also a dinosaur (started writing code in the 1970s).  The modern development landscape is a mess - there are hundreds of thousands of new approaches to solving the same old problems, and young developers seem to think that those solutions are better, by default, than solutions which have worked perfectly in the past, simply because they're newer.  The need to keep up with new platforms doesn't mean that progress is being made.  Millions of developers are wasting billions of man hours trying to re-invent wheels, often \"solving\" simple UI \"problems\" in new ways, to create glorified CRUD apps.  It would be great if newer challenges could be tackled instead.  Most of that real work is being done using platforms, languages, methodologies which are decades old.", "id": "d4g05lf"}], [{"comment": "[Sort of relevant xkcd](https://xkcd.com/927/)", "id": "d4f1e2i"}, {"comment": "Lemme guess... the standards one?", "id": "d4f42bj"}]]], "4u5zgq": ["10 things I hate about Git", "2016-07-23 04:58:23", 7, "https://stevebennett.me/2012/02/24/10-things-i-hate-about-git/", [[33, "I don't agree with a number of his points.\n\n> As a point of reference, consider Subversion: you have files, a working directory, a repository, versions, branches, and tags. That\u2019s pretty much everything you need to know. \n\nDon't forget properties, which are only occasionally but quite important.\n\n> Power for the maintainer, at the expense of the contributor\n\nThat depends on what you're comparing it to. For example, if you want to hold up Subversion as your example, IMO the distributed nature of Git makes it *way* better for Sue Random Contributor. Because if you don't have commit rights to a Subversion project, how the hell are you going to do any work on it more complicated than a couple dozen lines? You either have to put some other tool on top (e.g. git-svn or svk) or make your own repo for your work, and go through highly-obnoxious vendor-branch handling.\n\n> Several ways a committer can irrevocably destroy the contents of a repository:\n\nHere's a great way to destroy a Subversion repository: `rm -rf /path/to/myrepo`.\n\nAt least with Git:\n\n* Other people can have clones of the *whole repo* instead of just the head; in practice, I suspect this makes it harder to lose a Git repo\n* None of those mistakes are irrecoverable until GC runs\n* You (usually?) need to specify `-f` to break someone's repo; e.g. my understanding is `git rebase -i <some commit that has already been pushed and worked from>` / `git push` will refuse to update\n\nWhile we're on the topic of irrecoverably destroying information.... `svn up` is the most destructive version control command I know of.\n\n> Git history is a bunch of lies\n\n*Every* VCS history is a bunch of lies. When you forget to put a `;` at the end of a line, do you commit it with the missing `;` because \"that's what actually happened?\" If you introduce a bug and have to go hunting it down, do you commit the buggy version?\n\nOf course not! (At least in general.) Because those changes aren't small, self-contained, logical changes. Just like a merge commit isn't a small, self-contained, logical change. So why should you make merge commits?\n\n(That said, I do kind of wish there was a way to tell Git (in a good way) to keep around the original changes so they can be referred back to if need be.)\n\n> Surely the correct solution is a better log output that can filter out these unwanted merges.\n\nBecause logs are the only thing that matters, and it's impossible for a merge commit to introduce a bug that's basically impossible to track down.\n\n> The point of working on an open source project is to make some changes, then share them with the world. In Subversion, this looks like:\n\n> * Make some changes\n* svn commit\n\n> If your changes involve creating new files, there\u2019s a tricky extra step:\n>* Make some changes\n* svn add\n* svn commit\n\nUnless it turns into \"if you wind up having two changes in your sandbox at once, then spend an hour teasing apart your different changes\" vs \"use `git add --patch`\". (Actually, this is a common enough occurrence I wrote a script that does a mediocre emulation of that for Subversion...)\n\n> the following is basically the bare minimum\n\n>* Make some changes\n* git add [not to be confused with svn add]\n* git commit\n* git push\n* Your changes are still only halfway there. Now login to Github, find your commit, and issue a \u201cpull request\u201d so that someone downstream can merge it.\n\nOK, *sooo* many objections here.\n\nFirst, that's not the bare minimum; `git commit -a` as a replacement of `git add`/`git commit` is closer.\n\nSecond of all, if you're going to count \"issue a pull request so that someone downstream can merge it\", then you also need to count \"`svn diff` and send it off to a mailing list\" for the Subversion case. And at that point, you may well be able to drop the `git push` step, because maybe you don't have another repo. And if you're gonna then say \"but the maintainer will ask you to do such-and-such...\" well, what do you think will happen with your email patch?"], [10, "1 thing I hate about Git:\n\n1. It's not Mercurial."], [8, "First this is from 2012. Its just a really lazy and invalid rant.\n\nGit is complex. But it is solving complex problems in an efficient and graceful manner. End of discussion. The documentation is excellent, the learning curve is a little steep but navigable for anyone with half a brain. Now write/post something worth talking about."], [5, "What I hate about Git is how much time I spend doing boring version control stuff instead of programming. It would probably be the same with other VCS but I don't remember wasting so much time back when I used Subversion."], [3, "For me, the most retarded thing about Subversion is that branches are the same as sub-directories. "], [2, "These points are all valid.  People getting used to them doesn't make them not true.\n\nI'd add a more significant one, though.  The model for committing a subset of changes is broken.  When you add stuff to the \"index\" (horrible terminology, btw), to stage for a commit, you're then committing a state of the repository which has never been instantiated.  If you haven't instantiated it, you haven't tested it, and you shouldn't be committing it.\n\nAdding stuff to be committed should construct a state of the code as it will appear in the commit, so it can be examined and tested *before* committing.\n"], [1, "It sounds like you've given this a lot of thought. Anytime any of my programmers complains about something I challenge them to design something better. What would your ultimate distributed version control system look like? What would the user experience be? It's easy to criticize, but useless if you don't create something better."], [1, "> They describe the commands from the perspective of a computer scientist, not a user. \n\nGit is a tool primarily aimed at computer programmers, not the archetypal Aunt Tillie. I don't see a problem here."], [0, "Point #7 got me the other day. Lost a few hours work in a rebase gone bad. Sure, the bad rebase my fault but that's no reason a prior checkin should have been effectively delete. \n\nI hate git and prefer Mercurial."], [-4, ">  What a pity that it\u2019s so hard to learn, has such an unpleasant command line interface, and treats its users with such utter contempt.\n\nWhat?!\n\n> The command line syntax is completely arbitrary and inconsistent.\n\nbs\n\n> The man pages are one almighty \u201cfuck you\u201d.\n\nmore bs\n\nI don't even want to finish reading this piece of crap."], [-6, "Old but classic and still relevant article. "]], [[{"comment": "I don't agree with a number of his points.\n\n> As a point of reference, consider Subversion: you have files, a working directory, a repository, versions, branches, and tags. That\u2019s pretty much everything you need to know. \n\nDon't forget properties, which are only occasionally but quite important.\n\n> Power for the maintainer, at the expense of the contributor\n\nThat depends on what you're comparing it to. For example, if you want to hold up Subversion as your example, IMO the distributed nature of Git makes it *way* better for Sue Random Contributor. Because if you don't have commit rights to a Subversion project, how the hell are you going to do any work on it more complicated than a couple dozen lines? You either have to put some other tool on top (e.g. git-svn or svk) or make your own repo for your work, and go through highly-obnoxious vendor-branch handling.\n\n> Several ways a committer can irrevocably destroy the contents of a repository:\n\nHere's a great way to destroy a Subversion repository: `rm -rf /path/to/myrepo`.\n\nAt least with Git:\n\n* Other people can have clones of the *whole repo* instead of just the head; in practice, I suspect this makes it harder to lose a Git repo\n* None of those mistakes are irrecoverable until GC runs\n* You (usually?) need to specify `-f` to break someone's repo; e.g. my understanding is `git rebase -i <some commit that has already been pushed and worked from>` / `git push` will refuse to update\n\nWhile we're on the topic of irrecoverably destroying information.... `svn up` is the most destructive version control command I know of.\n\n> Git history is a bunch of lies\n\n*Every* VCS history is a bunch of lies. When you forget to put a `;` at the end of a line, do you commit it with the missing `;` because \"that's what actually happened?\" If you introduce a bug and have to go hunting it down, do you commit the buggy version?\n\nOf course not! (At least in general.) Because those changes aren't small, self-contained, logical changes. Just like a merge commit isn't a small, self-contained, logical change. So why should you make merge commits?\n\n(That said, I do kind of wish there was a way to tell Git (in a good way) to keep around the original changes so they can be referred back to if need be.)\n\n> Surely the correct solution is a better log output that can filter out these unwanted merges.\n\nBecause logs are the only thing that matters, and it's impossible for a merge commit to introduce a bug that's basically impossible to track down.\n\n> The point of working on an open source project is to make some changes, then share them with the world. In Subversion, this looks like:\n\n> * Make some changes\n* svn commit\n\n> If your changes involve creating new files, there\u2019s a tricky extra step:\n>* Make some changes\n* svn add\n* svn commit\n\nUnless it turns into \"if you wind up having two changes in your sandbox at once, then spend an hour teasing apart your different changes\" vs \"use `git add --patch`\". (Actually, this is a common enough occurrence I wrote a script that does a mediocre emulation of that for Subversion...)\n\n> the following is basically the bare minimum\n\n>* Make some changes\n* git add [not to be confused with svn add]\n* git commit\n* git push\n* Your changes are still only halfway there. Now login to Github, find your commit, and issue a \u201cpull request\u201d so that someone downstream can merge it.\n\nOK, *sooo* many objections here.\n\nFirst, that's not the bare minimum; `git commit -a` as a replacement of `git add`/`git commit` is closer.\n\nSecond of all, if you're going to count \"issue a pull request so that someone downstream can merge it\", then you also need to count \"`svn diff` and send it off to a mailing list\" for the Subversion case. And at that point, you may well be able to drop the `git push` step, because maybe you don't have another repo. And if you're gonna then say \"but the maintainer will ask you to do such-and-such...\" well, what do you think will happen with your email patch?", "id": "d5n81ru"}, {"comment": "Agreed. It bugs me, the whole discussion of merge vs. rebase commits.  The answer isn't one or the other.  The answer is, do what makes the most sense, on a case by case basis.  Should you merge every little change you make, adding semicolons? of course not.  Should you rebase a giant change you made from a previous version even though other people have changed 10 other things in the meantime?  Probably not.\n\nThe fact is, if you're using version control, and even have to ask yourself this question, it is because you are working with other people.  So the right question to ask yourself is not, should i rebase or should i merge, it should be \"will my team and I understand this while reading the history, a month from now?\"\n\nEdit: just an extension of this thought.. if you are telling yourself that rebase is \"lying\", I would suggest rethinking that.  First, no it's not.  You're just editing something you already edited.  If nobody else has seen it yet, you are just continuing your own edits.  If they *have*, then you shouldn't rebase because it'll fuck them up.  (Although feel free to talk to them about it and get an understanding that it'll clarify the history for later -- if everyone knows and agrees, no harm done.)  Second, it makes the history clearer to understand, in most cases.  When it doesn't, well.. don't do it.  I don't see how that's a hard decision to make.  It's about as hard as deciding how much whitespace to put before a section of code.  If you're programming, you are constantly making these kind of decisions about the aesthetics of code, so to me at least deciding how the history should look is no different.", "id": "d5n8yhu"}, {"comment": "Yes, I stopped reading at the \"git push -f destroys my repository\". It's called force for a reason. If you don't like it, disable it in your git hooks.", "id": "d5nffhw"}, {"comment": "You don't even need hooks. There are config options for that:\n\n    receive.denyNonFastForwards\n    receive.denyDeletes    ", "id": "d5nj5nh"}], [{"comment": "1 thing I hate about Git:\n\n1. It's not Mercurial.", "id": "d5n909d"}, {"comment": "Mercurial must have the same complexity behind the scenes, but manages to provide a much simpler interface somehow.", "id": "d5ptqrm"}], [{"comment": "First this is from 2012. Its just a really lazy and invalid rant.\n\nGit is complex. But it is solving complex problems in an efficient and graceful manner. End of discussion. The documentation is excellent, the learning curve is a little steep but navigable for anyone with half a brain. Now write/post something worth talking about.", "id": "d5n9gyp"}, {"comment": "> The documentation is excellent\n\nThe documentation is so excellent [there's a parody on it that generates random man pages](https://git-man-page-generator.lokaltog.net/).\n\n    git-rebase \u2013 Forward-port local commits to the updated upstream head\n\ngit documentation seems to be written for people that already understand it. ", "id": "d5ngipw"}, {"comment": "> git documentation seems to be written for people that already understand it. \n\nYeah actually, that's right, it *is* designed to help people who understand it. Helps you find the option you need quickly. \n\n\"man gittutorial\" is the documentation for people who are unfamiliar with git. ", "id": "d5nqrgr"}, {"comment": "Sounds typical of the git(hub)-monoculture and its unfortunate consequences.\nIf not too late, do yourself a favor and try to unlearn some of your hard-coded git habits, invest some time reading about mercurial and the others.\nThere are proofs out there that solving the complex problem of decentralized version control doesn't involve all the pain-points highlighted in the article (and might reveal some areas where git is lagging behind, like safe/collaborative history rewriting).", "id": "d5nd7ht"}, {"comment": "> First this is from 2012\n\nWhat's changed since then?\n\n> Its just a really lazy and invalid rant.\n\nHow so?\n\n> Git is complex. But it is solving complex problems in an efficient and graceful manner.\n\nThe author addresses this. He believes it's unnecessarily complex for the problems that it's solving.\n\n> End of discussion.\n\nOkay. Bye.\n\n> Now write/post something worth talking about.\n\nYou can leave now. We'll continue to discuss this without your scintillating wit.", "id": "d5n9jkc"}, {"comment": "You're an idiot who adds nothing to a conversation after posting some stupid article from somebody who clearly knows little about Git.\n\nThis was written 4 years ago. A lot has changed. I'm not going to hold your hand... You can figure it out yourself.\n\nBye", "id": "d5naob8"}, {"comment": "Added to RES ignore list.", "id": "d5narhr"}], [{"comment": "What I hate about Git is how much time I spend doing boring version control stuff instead of programming. It would probably be the same with other VCS but I don't remember wasting so much time back when I used Subversion.", "id": "d5nnq2g"}, {"comment": ">What I hate about Git is how much time I spend doing boring version control stuff instead of programming\n\nThen don't do it as much. I don't know what you're spending your time on, but unless you're managing the build machine, git should be saving you time and making things easier.\n\nMaybe there's something in your workflow that can be improved. ", "id": "d5nqnwj"}], [{"comment": "For me, the most retarded thing about Subversion is that branches are the same as sub-directories. ", "id": "d5nkclr"}], [{"comment": "These points are all valid.  People getting used to them doesn't make them not true.\n\nI'd add a more significant one, though.  The model for committing a subset of changes is broken.  When you add stuff to the \"index\" (horrible terminology, btw), to stage for a commit, you're then committing a state of the repository which has never been instantiated.  If you haven't instantiated it, you haven't tested it, and you shouldn't be committing it.\n\nAdding stuff to be committed should construct a state of the code as it will appear in the commit, so it can be examined and tested *before* committing.\n", "id": "d5nxtik"}, {"comment": "Uhm, why shouldn't you commit it? You probably shouldn't push it to master that way (though even then it might be fine for trivial/documentation fixes or when you have multiple programs inside a single repo) but committing it to some local branch is totally fine. You can always untangle it later.\n\nAlso, you can use of the index to snapshot your in-progress work and affect diff output to your liking.", "id": "d5ojazf"}], [{"comment": "It sounds like you've given this a lot of thought. Anytime any of my programmers complains about something I challenge them to design something better. What would your ultimate distributed version control system look like? What would the user experience be? It's easy to criticize, but useless if you don't create something better.", "id": "d5n6hd7"}, {"comment": "This one looked interesting to me but it never went anywhere\n\nhttps://www.fossil-scm.org/index.html/doc/trunk/www/index.wiki\n", "id": "d5n8063"}, {"comment": "Bearing in mind I've never used fossil...\n\nI don't like the position it takes on what, in Git, you'd rebase for. Here's what it has to say:\n\n> Fossil, in contrast, puts more emphasis on recording exactly what happened, including all of the messy errors, dead-ends, experimental branches, and so forth. One might argue that this makes the history of a Fossil project \"messy\". But another point of view is that this makes the history \"accurate\". In actual practice, the superior reporting tools available in Fossil mean that the added \"mess\" is not a factor.\n\nFirst, I *very very very* much doubt the last sentence. I have no idea how a lot of the stuff that *I* rebase for could possibly be made cleaner by tools.\n\nSecond, as I argued in another post, Fossil already isn't recording what happened. It doesn't record your typos, it doesn't record your mistakes, it doesn't record anything you don't commit. What you commit is already a lie, and not what actually happened.\n\nThird, what actually happened is, for almost all purposes, irrelevant. What matters is how *useful* the history is. How easy is it to figure out why something was added or changed? When a bug was introduced? None of those things usually mean needing to know what *actually* happened in the fossil sense. It's only if, e.g., an error is introduced during a rebase, or the meaning of a commit changes during a rebase, where the actual history becomes important.\n\nAnd from what I can tell, it's much much easier to emulate Fossil-style immutable history in Git (though I do wish it were easier) than to emulate rebased history in Fossil.\n\nNow, maybe I have a poor impression of what Fossil does. At the same time, I can't go and spend a month evaluating every version control system someone comes up with, and in terms of convincing me that Fossil is worth experimenting with... it's utterly failed. To me, the powerful commit editing features (both pre-commit, with the index and `--patch`/`--interactive` and stash, and post-commit with rebase) is *the* killer feature of Git. Take that away and you've got a big battle to win my interest.", "id": "d5n9wnm"}, {"comment": "You can do most of the normal git non-mangling git workflow, you just do it backwards. Instead of picking out stuff to commit, you stash and interactive patch the commits out from the stash.\n\nReally, after looking into it for a while, it's mostly a mindset difference between the two. Sort of like bringing up rival games in another's community with praise.", "id": "d5nbviu"}, {"comment": "Wow. I just downloaded that to use with a side project I'm starting. It's actually pleasant to use, and it has only one binary, and it comes with a web server ui built in. Cool.", "id": "d5nctd6"}, {"comment": "Written by the author of sqlite. Looks good, has its own bug tracking system, and has some git compatibility.\n\nWhen  you say \"never went anyway\" you mean \"never got a big mindshare\"? \n\nWell, the author got one huge hit. Fossil also relies on sqlite, and sqlite development is managed by fossil.", "id": "d5n87ig"}, {"comment": ">When you say \"never went anyway\" you mean \"never got a big mindshare\"?\n\nYes.\n\n> Fossil also relies on sqlite, and sqlite development is managed by fossil.\n\nAll the more surprising it's not in wider use.", "id": "d5n8nel"}, {"comment": "And reading further, fossil is one small (2MB) binary.\n\nComparison of [git and fossil](https://www.fossil-scm.org/index.html/doc/trunk/www/fossil-v-git.wiki)", "id": "d5n9cov"}, {"comment": "Actually it does not look like he gave it much thought at all. It looks like someone's bad attempt at making git look bad so he can justify not using it to himself.", "id": "d5ngsve"}, {"comment": "> Anytime any of my programmers complains about something I challenge them to design something better\n\n'tis a fallacious argument", "id": "d5ns2ln"}, {"comment": "I agree. You see this kind of argument a lot in discussions about food or art. \"If you think it's terrible, why don't you do something better.\" The argument doesn't have legs, because\n\n1. It's predicated on the notion that one's ability to judge something is only as valid as their ability to create it. I can't build a car, but I know the traits of a bad one.\n\n2. It effectively states that anyone who doesn't have the time to work on something can't critique anything like it. I don't have the time to learn to build a car or the time to learn to build a car or the tools to build a car, but I still can critique a car.\n\n3. It's most often a deflection.\n\n4. It denigrates the value of pure criticism, which must always come before progress.", "id": "d5ny1f7"}, {"comment": "> It's predicated on the notion that one's ability to judge something is only as valid as their ability to create it. I can't build a car, but I know the traits of a bad one.\n\nI'm just saying it's easy to only criticize, not that the criticism is invalid. Likewise when you criticize a car you can provide a constructive alternative without knowing how to actually create one. Design and implement are two different things. If you said the seats were poorly shaped you could describe a seat design that changes shape to match your body without knowing how such a thing would be created.\n\n> It effectively states that anyone who doesn't have the time to work on something can't critique anything like it. I don't have the time to learn to build a car or the time to learn to build a car or the tools to build a car, but I still can critique a car.\n\nIf you have time to criticize something you have time to come up with some ideas for improvements. You don't have to actually make those improvements, or even know how to make them. But criticism without a single suggestion for improvement is easy and lazy and we see it EVERYWHERE.\n\n> It's most often a deflection.\n\nHow so?\n\n> It denigrates the value of pure criticism, which must always come before progress.\n\nI agree that it denigrates the value of pure criticism. I would disagree that pure criticism must come before progress. Actually I think if there's pure criticism without new ideas then it's more likely nobody will do anything about the problems.\n", "id": "d5o4ha4"}, {"comment": "> If you have time to criticize something you have time to come up with some ideas for improvements. \n\nno, these are two entirely different thought processes. (Mostly) everybody agrees that pollution is bad, but nobody has come up with a \"solution\" (if a solution even exists)", "id": "d5om32j"}, {"comment": "* Start a social media campaign to encourage your city council to change zoning laws to encourage mixed-use construction so that home and work are closer together for more people.\n* Create a social game that rewards people for walking, bicycling, and taking public transportation. Level up and be the envy of all your friends!\n* Ask someone who has the same commute as you if they'd like to carpool one day per week.\n\nSee  how easy that is? I'm talking about \"ideas for improvements\" and you're talking about \"solutions\". All I'm saying is that the author of this article doesn't even make an attempt to suggest a single improvement or better way, and that irritates me.", "id": "d5otktg"}, {"comment": "He actually does make suggestions if you pay attention to his criticisms.\n\n> The command line syntax is completely arbitrary and inconsistent. Some \u201cshortcuts\u201d are graced with top level commands: \u201cgit pull\u201d is exactly equivalent to \u201cgit fetch\u201d followed by \u201cgit merge\u201d. But the shortcut for \u201cgit branch\u201d combined with \u201cgit checkout\u201d? \u201cgit checkout -b\u201d. Specifying filenames completely changes the semantics of some commands (\u201cgit commit\u201d ignores local, unstaged changes in foo.txt; \u201cgit commit foo.txt\u201d doesn\u2019t). The various options of \u201cgit reset\u201d do completely different things.\n\nSounds like he wants them to make the command line syntax more consistent.\n\n> The man pages are one almighty \u201cfuck you\u201d. They describe the commands from the perspective of a computer scientist, not a user. Case in point:\n\n> git-push \u2013 Update remote refs along with associated objects\n\n> Here\u2019s a description for humans: git-push \u2013 Upload changes from your local repository into a remote repository\n\nSeems like he's making a pretty clear suggestion here.\n\nYou can only believe that a critic isn't making suggestions, if you ignore what they are complaining about. He clearly thinks that there should be more abstraction to protect users from git internals, that better logging to ignore unwanted merges is preferable to constant rebasing to create a false narrative, that simple tasks should be easier to do with less commands, etc.", "id": "d5p0m3s"}, {"comment": "You'll have to ask the author. I just posted this.", "id": "d5n6o6k"}, {"comment": "Ah, okay. These kind of articles bother me because all they do is criticize without offering a better way. It's easy to break something down, and rather lazy IMHO. Just a few suggestions for improvement would go a long way. The world is overflowing with critics and not enough creators.", "id": "d5n6zfo"}, {"comment": "I used Darcs for a few projects in school. I like the interface, and it's embracing being distributed by not forcing all changes into an arbitrary time line.\n\nI have not used it for any larger projects, and it was almost ten years ago now that I used it, so I can't say if it would be better than git which we use at work. I think it's \"theory of patches\" is not a very performant solution, compared to the straight timeline of other version control systems, but conceptually it felt nice to use.", "id": "d5ng68m"}], [{"comment": "> They describe the commands from the perspective of a computer scientist, not a user. \n\nGit is a tool primarily aimed at computer programmers, not the archetypal Aunt Tillie. I don't see a problem here.", "id": "d5ojnrd"}, {"comment": "Good luck getting people to contribute documentation if your project requires git submissions.", "id": "d5ojxvj"}], [{"comment": "Point #7 got me the other day. Lost a few hours work in a rebase gone bad. Sure, the bad rebase my fault but that's no reason a prior checkin should have been effectively delete. \n\nI hate git and prefer Mercurial.", "id": "d5najv7"}, {"comment": "Git reflog lets you undo a bad rebase. Mercurial also has a reflog if you screw up your hg histedits.\n\nI use both git and hg daily (work uses hg for most things), so I'm pretty familiar with both. In practice, there's not much difference, beyond git being faster, and mercurial having better hooks  go make it suck less with hundreds of thousands of files.\n\nEDIT: Also, looking at the examples -- mercurial also has similar; I've needed to edit repo state and force push things using hg in the past because of broken repositories and conversion tools, and hg *absolutely* has the ability to clobber things the same way as git.", "id": "d5ncb5z"}, {"comment": "I have had plenty of things go wrong in Mercurial (mostly bad merges) but I've never ever lost a commit. I'm not saying you're wrong or that it can't be done, but I've been using Mercurial for 6 years and it never happened. It happened after using git for about 6 months. ", "id": "d5oc4f5"}, {"comment": "I lost a commit the first time I tried to histedit to fix up a sequence of commits in order to make Arcanist happy -- so, about 2 or 3 weeks into using mercurial on a daily basis.\n\nIt wasn't the tool's fault. In fact, the UIs for these operations are almost identical.", "id": "d5ow61y"}], [{"comment": ">  What a pity that it\u2019s so hard to learn, has such an unpleasant command line interface, and treats its users with such utter contempt.\n\nWhat?!\n\n> The command line syntax is completely arbitrary and inconsistent.\n\nbs\n\n> The man pages are one almighty \u201cfuck you\u201d.\n\nmore bs\n\nI don't even want to finish reading this piece of crap.", "id": "d5ngou8"}], [{"comment": "Old but classic and still relevant article. ", "id": "d5n6jsr"}]]], "53zqh5": ["I made this flowchart to help beginners pick which programming language to learn first. It's pretty simple. Am I missing anything major?", "2016-09-22 20:16:05", 0, "https://www.lucidchart.com/blog/2016/09/22/which-programming-language-should-i-learn-first/", [[13, "Quote: \"Deciding which programming language to learn first is a big decision\"\n\nNo, it's not. All modern languages can be used to learn programming basics, which is the point, not to get married to a language before learning the basics. \n\nOnce past the basics, which language to use becomes more important, but at that point, the student doesn't need to have his hand held."], [10, "If this is for real, I disagree with the notion that all these languages are well suited for teaching foundational principles, implying that these principles should be learned before moving on to programming games, making websites, etc. The people that build SDKs and web frameworks like React likely are really good programmers, not just good web developers. \n\nI am merely a mortal, and thus don't have all the answers, but I think Python is one of the better languages to start with because it's simple, well documented, and widely used for many purposes. Also, it is extremely easy to install and start working with. "], [4, "Javascript isn't sexy. It's both ugly and frustrating. Instead of recommending it that way, I'd present it as for both server side and client side development.\n\nBut I'll still never use it on my server."], [3, "I see nothing for languages like Fortran/Matlab/R/Julia that are mainly used for numerical/statistical applications.\n\nThere are a few other things that strike me as strange. For instance, a beginner to programming languages doesn't know what a compiler is, so why would they choose the path to C."], [3, "Processing should be on the flowchart"], [2, "You're missing the whole functional world. I'd argue ML-family languages are a better way to learn to program, and lead to higher-paying jobs."], [3, "Want to make something safe?  Ada"], [2, "Ultimately all you did was put stereotypes or biases into a flow chart.  Congratulations on perpetuating these, that's exactly what a beginner needs to be considering."], [2, "Your view of programming language strengths and quirks seem to be heavily biased and the flow chart reeks of hipster arguments. "], [1, "Scrap it all. Learning your first language? Learn Logo."], [1, "I'd disagree with some of these choices.  If you're new to programming, you shouldn't be thinking about a particular project for it yet.  Some of these decisions are also hardly geared to new developers.  A new developer shouldn't be writing graphically intensive apps.  If they could do that, they wouldn't need your flowchart.  I'll also note C++ isn't particularly more appropriate for graphics on Android than Java."], [1, "I reckon we should all agree this is not to be taken too seriously. That said, it's a nice work and fun to read. IMHO there should be a path from \"get a job\" to C++ if nothing else according to the Tiobe ranking, and also plain C should be mentioned somewhere possibly in relation to \"get a job\" in the embedded or IoT industry."], [1, "If they're a newbie, they're likely not going to know answers to questions like \"Which engine do you want to use\" for learning game programming. Among many other flaws, as others point out."]], [[{"comment": "Quote: \"Deciding which programming language to learn first is a big decision\"\n\nNo, it's not. All modern languages can be used to learn programming basics, which is the point, not to get married to a language before learning the basics. \n\nOnce past the basics, which language to use becomes more important, but at that point, the student doesn't need to have his hand held.", "id": "d7xn40s"}], [{"comment": "If this is for real, I disagree with the notion that all these languages are well suited for teaching foundational principles, implying that these principles should be learned before moving on to programming games, making websites, etc. The people that build SDKs and web frameworks like React likely are really good programmers, not just good web developers. \n\nI am merely a mortal, and thus don't have all the answers, but I think Python is one of the better languages to start with because it's simple, well documented, and widely used for many purposes. Also, it is extremely easy to install and start working with. ", "id": "d7xmn6b"}, {"comment": "there are reasons MIT starts the kids on python nowadays", "id": "d7xnapd"}], [{"comment": "Javascript isn't sexy. It's both ugly and frustrating. Instead of recommending it that way, I'd present it as for both server side and client side development.\n\nBut I'll still never use it on my server.", "id": "d7xq16f"}], [{"comment": "I see nothing for languages like Fortran/Matlab/R/Julia that are mainly used for numerical/statistical applications.\n\nThere are a few other things that strike me as strange. For instance, a beginner to programming languages doesn't know what a compiler is, so why would they choose the path to C.", "id": "d7xmy8p"}, {"comment": ">I see nothing for languages like Fortran/Matlab/R/Julia that are mainly used for numerical/statistical applications.\n\nBecause you need to study math for a few years to even think about learning a language to use it for statistical or numerical computations.", "id": "d7xnoba"}, {"comment": "At age 17 or so, I first used Mathematica. I believe it was my first programming experience. I think I used Matlab at around 18. \n\nOf course, I first started studying math at age 5, so I guess I did get a few years of math studies in before learning those.", "id": "d7xr6wm"}], [{"comment": "Processing should be on the flowchart", "id": "d7xoy5b"}], [{"comment": "You're missing the whole functional world. I'd argue ML-family languages are a better way to learn to program, and lead to higher-paying jobs.", "id": "d7xmp9o"}, {"comment": "Seriously, no. Nobody uses functional languages. The few jobs that exist are highly paid, because nobody cba to learn it because it's so completely foreign, dense and abstract.\nWhy does everything always have to be hipstery and exciting and out of the ordinary? Just learn Java or Python like everybody else. You will find all the resources and libraries that you could ever need, with good documentation and good tooling and you can easily transfer your skills to any other widely used language.", "id": "d7xwatj"}, {"comment": "JavaScript is widely used and a functional language.\nThe reality is the oop is weird, functional programming is not the weird style.\n\nBut yea Haskell is weird tho yea.", "id": "d7xxh5y"}, {"comment": "JS is not really a functional language. You can write it in a functional style and functions are first class citizens, but it's still an imperative OOP language (albeit a bit out of the ordinary because it's prototyping instead of classes) and is mainly used as such. Variables are mutable, loops are favored over recursion, almost everything is an object etc.\n\nI just don't think starting out with FP over imperative does a beginner any good. Maybe if you want to do certain maths-heavy stuff only, it makes sense, but for general purpose, stick to imperative OOP", "id": "d7ymf9c"}, {"comment": "I don't think functional really means what you're implying.  Theres no reason to consider functional languages to have to do those things. \n\nFunctional programming is a style that stresses functional composition -- aka passing functions in as parameters --and is usually done to attempt to reduce side effects.\n\nGiving a strict definition for functional which basically just lines of with Haskell is pointless.  You can definitely definitely write functional style code in JavaScript. \n\nThe only.real require.ent of a functional language is function pointers /references. \n\nI say to a beginner just start writing code.  I think showing them some functional styles makes sense as the next step as opposed to the crazy oop hacks that people tend to write.", "id": "d7ys0ql"}], [{"comment": "Want to make something safe?  Ada", "id": "d7xn30c"}, {"comment": "Yeah, beginners usually think about programming airplanes when they first learn to program.", "id": "d7xnp51"}, {"comment": "It does help instill good habits that carry over too", "id": "d7xnsqq"}, {"comment": "Not really.  If the language takes care of things like arrays and pointers and what not for you then you're not used to programming them.", "id": "d7xqpom"}, {"comment": "I was thinking more the typing system", "id": "d7xsiva"}], [{"comment": "Ultimately all you did was put stereotypes or biases into a flow chart.  Congratulations on perpetuating these, that's exactly what a beginner needs to be considering.", "id": "d7yduqy"}], [{"comment": "Your view of programming language strengths and quirks seem to be heavily biased and the flow chart reeks of hipster arguments. ", "id": "d7yn3rn"}], [{"comment": "Scrap it all. Learning your first language? Learn Logo.", "id": "d7xrpyz"}], [{"comment": "I'd disagree with some of these choices.  If you're new to programming, you shouldn't be thinking about a particular project for it yet.  Some of these decisions are also hardly geared to new developers.  A new developer shouldn't be writing graphically intensive apps.  If they could do that, they wouldn't need your flowchart.  I'll also note C++ isn't particularly more appropriate for graphics on Android than Java.", "id": "d7y0voo"}, {"comment": "I think most programmers learn to program by writing something that they want to write. ", "id": "d7y7y0l"}], [{"comment": "I reckon we should all agree this is not to be taken too seriously. That said, it's a nice work and fun to read. IMHO there should be a path from \"get a job\" to C++ if nothing else according to the Tiobe ranking, and also plain C should be mentioned somewhere possibly in relation to \"get a job\" in the embedded or IoT industry.", "id": "d7y1i6y"}], [{"comment": "If they're a newbie, they're likely not going to know answers to questions like \"Which engine do you want to use\" for learning game programming. Among many other flaws, as others point out.", "id": "d7ys7g1"}]]], "55nbx8": ["Lesser known Git commands", "2016-10-03 16:06:31", 0, "https://hackernoon.com/lesser-known-git-commands-151a1918a60#.e8lhzs19h", [[4, "> Happy aliasing!\n\nTell that to your compiler."], [3, ">Made up Git commands"], [2, "I was about to call OP out for the [repost](https://www.reddit.com/r/programming/comments/552mfb/lesser_known_git_commands/) but decided to check their post history instead.... 460+ submissions in 10 days, 975 in the past month. Something tells me OP won't care."], [1, "Alias logo as `log --oneline`"]], [[{"comment": "> Happy aliasing!\n\nTell that to your compiler.", "id": "d8c2dhi"}], [{"comment": ">Made up Git commands", "id": "d8c5azy"}], [{"comment": "I was about to call OP out for the [repost](https://www.reddit.com/r/programming/comments/552mfb/lesser_known_git_commands/) but decided to check their post history instead.... 460+ submissions in 10 days, 975 in the past month. Something tells me OP won't care.", "id": "d8c7a1l"}, {"comment": "That's 46 a day, 2.875 an hour (assuming 16 waking hours), so about one submission every 20 minutes.\n\nThat seems pretty close to the submission limit, so I think OP may be a bot. \ud83e\udd16", "id": "d8c7lj3"}, {"comment": "I'd thought about that possibility as well but was thrown off when I saw they were a member for 10 years. I forgot all about the sites where you can buy/sell reputable Reddit accounts to spam with.  \n  \nEdit: You can also see more detailed statistics on [SnoopSnoo](http://snoopsnoo.com/u/speckz). Reddit limits the data they use to the last 1000 submissions/comments so keep that in mind. ", "id": "d8c8d69"}, {"comment": "Yeah, experiencing d\u00e9j\u00e0 vu. I read this last Friday or Thursday, one of those.", "id": "d8c7px0"}], [{"comment": "Alias logo as `log --oneline`", "id": "d8caw8r"}]]], "452y1u": ["How can JavaScript be stopped from spreading like a cancer?", "2016-02-10 17:29:50", 0, "https://medium.com/@richardeng/an-open-letter-to-ecma-cb60ee917da9", [[15, "The worst part of working with js today isn't really the language (although, it's not that great either), but the ecosystem and the extreme ADHD of the npm community. Running an npm install on a modern, reasonably sized frontend project and watching the shitstorm of dependencies unfold is frightening. People seem to write a function for stripping whitespace from a string, create an npm package from it, then  build a website with a .io domain to show it off. The end result is your project uses three packages which pulls in three different packages for stripping whitespace, which in turn pulls in three different packages for traversing a string, and down the rabbit hole we go.. And I'm only slightly exaggerating. \n\nA prominent example of this is when react came out and eeeveryone set out to wrap it in some kind of framework. It was obviously in need of one; but people couldn't pick one and stick with it to save their lives (are we still on redux?).\n\nThere are obviously a ton of smart and (over-) productive people working with JavaScript and all the horrors of modern frontend frameworks, but it's getting messier by the minute.."], [13, "Why not introducing just a new script type? Then you can remove stuff without worring to break the internet.\n\n<script type=\"text/ecmascript2016\"></script>"], [6, "The same way we stopped PHP, Java, and C++ spreading like cancer: roll over and die, because they will not go away."], [4, "I guess he never got the memo about WASM."], [3, "Bashing JavaScript on reddit? The collective psychosis isn't ready for the truth yet"], [2, ">I have programmed in many languages, but I have never\u200a\u2014\u200aEVER!\u200a\u2014\u200ahad to specify anything like a strict mode.\n\n*cough* Perl *cough*"], [2, "JS already is a compiler target for multiple languages (including ES6, amusingly). Why doesn't the author simply use it as such?\n\nThe best way to stop bad JS (or any language) is to have educated devs. It's a perfectly capable language. (I've programmed professionally in assembly-on-up, so I have perspective.)"], [1, "If you\u2019re not running a static code analyzer, a transpiler or a lightweight solution like TypeScript, you\u2019re maintaining an old project, or your team is not with it. Plus, most type conversions you fear don\u2019t actually account for a lot of defects in the wild. 98% of uncaught implicit conversions are found to be harmless: http://mp.binaervarianz.de/ecoop2015.pdf"], [1, "Noone's gonna talk about the balls? I mean... come on!"], [1, "Semantics are so hard for developers to adjust to.  JavaScript semantics are something you either learn to live with or you start trying to figure out how to kill JavaScript or prevent its spread. Hint: You can't stop it.   Once you learn and adjust to the semantics, and learn to write idiomatic JavaScript (Hint: Read Doug Crockford, and consider carefully what he thinks, but don't clone his brain-state, think for youself.) it's not as bad as you thought."], [0, "[deleted]"], [-1, "JavaScript is many things, but broke ain't one of them. Especially now, with the significant improvements that the ECMA standards have brought about. The language is now mature, has some pretty neat features, and like any language there are pros/cons to using it.\n\nI don't see it as fundamentally worse than the many languages I've worked with over time (FORTRAN, C, C++, Python, Perl, Ruby, JavaScript, Java, R.) Certainly not an \"abomination\" as compared to the other popular languages.\n\nHonestly, this article seems like it was written by someone with very little programming experience, but who has a high opinion/certainty of their programming knowledge."]], [[{"comment": "The worst part of working with js today isn't really the language (although, it's not that great either), but the ecosystem and the extreme ADHD of the npm community. Running an npm install on a modern, reasonably sized frontend project and watching the shitstorm of dependencies unfold is frightening. People seem to write a function for stripping whitespace from a string, create an npm package from it, then  build a website with a .io domain to show it off. The end result is your project uses three packages which pulls in three different packages for stripping whitespace, which in turn pulls in three different packages for traversing a string, and down the rabbit hole we go.. And I'm only slightly exaggerating. \n\nA prominent example of this is when react came out and eeeveryone set out to wrap it in some kind of framework. It was obviously in need of one; but people couldn't pick one and stick with it to save their lives (are we still on redux?).\n\nThere are obviously a ton of smart and (over-) productive people working with JavaScript and all the horrors of modern frontend frameworks, but it's getting messier by the minute..", "id": "czv0eoy"}, {"comment": "Fast forward a few years when programmers start using NPM without knowing anything beyond npm install, only that it 'works'.  If *anything* goes wrong they're buggered.", "id": "czvi9t1"}, {"comment": "The future is now. Yesterday a friend of mine couldn't clone a repo because the folder hierarchy created by npm was too deep for his filesystem (he's on windows)", "id": "d02zgf7"}, {"comment": "> (are we still on redux?)\n\nWhat's the current state of redux? ", "id": "czvtaxs"}], [{"comment": "Why not introducing just a new script type? Then you can remove stuff without worring to break the internet.\n\n<script type=\"text/ecmascript2016\"></script>", "id": "czv1cdc"}], [{"comment": "The same way we stopped PHP, Java, and C++ spreading like cancer: roll over and die, because they will not go away.", "id": "czuu5bf"}, {"comment": "PHP should probably go away though...\n\nJS has come a long way from its humble origin and is far from a toy language at this point. Its event driven, asynchronous nature makes JS (Node) particularly suitable for IoTs. In fact Intel and other chip makers have been doubling down on Node. So not only is JS not going away, it is expanding into ever more new territories. ", "id": "czv1q2s"}, {"comment": "You'll hear no argument from me. I like js. The first language to popularize functional style into the majority of programmer mindshare, and it's the only language (STILL!) that is truly write once, run anywhere. There are caveats, there always are, but it has succeeded where its namesake has not.", "id": "czv2j4k"}, {"comment": "Oh absolutely. I love how higher order functions come so naturally in JS so that many people start writing FP into their code (filter, map, reduce with anonymous functions) without even realizing it, unlike python where you have to declare with lambda .", "id": "czv3hsh"}, {"comment": "I saw an example of a single-page app written in this style, with plenty of function composition, fold, map, rcurry, filter(with the identity function as base case), etc... And it was mind-boggling slow.\nIt was rewritten to lots of inline switches and for loops over arrays, and runtime - especially including GC time - went down 100x.\nMoral of the story: don't write FP style unless you have a language with the right semantics that allow the compiler to optimize the code. Haskell can do it, JS can't.", "id": "czvb7oa"}, {"comment": "In Python you tend to do higher-order functions as decorators - the entire reason decorators exist is to syntactic-sugar down on the extreme common pattern of higher-order functions that was being used.\n\nI've never seen lambdas in use in the large Python codebase I work on because most Python programmers prefer to create their callable objects using the standard `def foo():` syntax.\n\n    def reduce_add_and_divide(things):\n        def foo(x, y):\n            return (x + y) / 2\n        return reduce(foo, things)\n\nYou generally don't use map, you'd just use\n\n    [f(x) for x in y]", "id": "czv50tn"}, {"comment": "Interesting. I assume they prefer not to use lambdas in large code bases to make the code more readable to others who may work on it later? ", "id": "czv5mii"}, {"comment": "More just: why? I've never understood the JS convention of always defining your functions inline, and outside of maybe some trivial examples like `lambda x: x**2` for which the reasons are obvious in context I'd much rather see a named function made and used like in my example code above. \n\nIt's generally easier to read to me, but also I think it's more self-documenting if you're forced to describe what the callback/function-being-passed-as-an-argument does by naming it. ", "id": "czv6m6q"}, {"comment": "JS use anonymous functions for closure and private variables. I guess in python you would use decorators for closure instead and python doesn't really like private variables.", "id": "czv7gx0"}, {"comment": "You don't need to make anonymous functions for closures or private variables, though, that's what I'm saying: I find it easier to work with and read code that names any function even when, theoretically, you could get away with using syntax to not do so.", "id": "czv7ql2"}], [{"comment": "I guess he never got the memo about WASM.", "id": "czus3fr"}], [{"comment": "Bashing JavaScript on reddit? The collective psychosis isn't ready for the truth yet", "id": "czushsa"}], [{"comment": ">I have programmed in many languages, but I have never\u200a\u2014\u200aEVER!\u200a\u2014\u200ahad to specify anything like a strict mode.\n\n*cough* Perl *cough*", "id": "czuremg"}, {"comment": "Also, for C, C++ a similar notion is achieved through compiler flags (eg. -pedantic).", "id": "czus2qp"}, {"comment": "While this is technically true, the main reason for using these compiler flags is to achieve some level of portability across multiple platforms. As the C/C++ code I've written never had to be portable, I've never had to use these flags. Certainly, these flags were not necessary in order to avoid problematic language features.", "id": "czv6wu5"}], [{"comment": "JS already is a compiler target for multiple languages (including ES6, amusingly). Why doesn't the author simply use it as such?\n\nThe best way to stop bad JS (or any language) is to have educated devs. It's a perfectly capable language. (I've programmed professionally in assembly-on-up, so I have perspective.)", "id": "czw95fe"}, {"comment": "?????\nYou don't seem to have read the article. I clearly stated that there are many transpiled alternatives. I even told you I use Amber Smalltalk, my favourite transpiled alternative.\n\nYes, ideally, we should educate all JS developers to use the language correctly. Far too many of them abuse the language terribly. [Eric Elliott](https://medium.com/javascript-scene/javascript-training-sucks-284b53666245) says, \"99 out of 100 JavaScript developers I interview lack the skills required to hit the ground running on a scalable production JavaScript application.\" Almost nobody really understands JavaScript!\n\n**Re-education is a necessity.** However, this is a very daunting goal. How would you go about accomplishing this? How would you, for example, compel all JS devs to read Douglas Crockford's book? There are tons and tons of online JS courses and tutorials. I don't expect all of them, *or even most of them*, to teach JS correctly. How would you fix that and prevent the spread of misinformation?", "id": "czwg0nl"}, {"comment": "\"Why don't you use it as such and not worry about it?\" is what I was getting at, obliquely.\n\nAs far as I'm concerned, if one can't code in JS, one is not a JS dev. \"99 out of 100 JS devs lack required skills\" means he only talked to one developer and 99 impostors.\n\nEvery single professional developer I personally know has no problem writing solid code in JS. I've hired people with zero language-specific knowledge to great effect. These are people who have worked in the computing industry for decades in scores of languages. Some of them have worked on massive JS projects. Maybe a couple of them have read Crockford's book (I haven't), but their JS skill comes from their underlying dev skill, not from anything JS-specific.\n\n(Or, put another way, a crap JS pretend-dev is going to be crap at Amber Smalltalk, too.)\n\nHow did the professional devs get to the point in the craft that they are able to quickly wield JS, or any other language, with ease and skill? That's where we need to be going.\n\nAll the issues you bring up for the problems with JS courses and tutorials exist for all languages. You cannot stop the spread of misinformation, so the battle must, therefore, be fought elsewhere.\n\nUnfortunately, we're just sucking more and more at education in this country. I do have a supreme plan for an overhaul of the education system that would actually address this, but the probability of overhauling the education system in this country is, as Kryten would say, 0\u00b2.", "id": "d06hqat"}, {"comment": "> \"99 out of 100 JS devs lack required skills\" means he only talked to one developer and 99 impostors.\n\nImposters??? That's quite the proclamation. I think Elliott's point is that many, many JS programmers are simply not very good. They may lack proper programming background, or *they may have trouble navigating through the confusion of bad features and inconsistent semantics*. It's disingenuous to call them imposters.\n\nUnquestionably, there are developers who can write solid JS code. Especially those with extensive programming backgrounds who can exercise the necessary self-discipline to avoid \"the bad parts\" of JS. I count myself among these people, *if I cared to use JS seriously*. But why should I? I'm perfectly happy to use a transpiled language such as [Amber](https://medium.com/smalltalk-talk/a-gentle-introduction-to-amber-8c532631e9ab) or [GopherJS](http://www.gopherjs.org/) or [Transcrypt](http://www.transcrypt.org/).\n\nIt's great that you've come across good JS devs. However, all the evidence I've seen suggest that most JS devs are abusing the language. And that's why I'm evangelizing *against* it; it's my civic duty. **Otherwise, you are absolutely correct: Why don't I just use a transpiled language and be done with it?**", "id": "d06q8tq"}, {"comment": "This is just me, but IMHO one must surpass a certain skill level to call oneself a JS dev. And people who are having trouble writing sensible JS code are not yet there.\n\nI might be too close to the issue to see it, but from my perspective, JS simply is not that different than other multitude of languages I've used professionally. It's not especially more dangerous, safer, harder, easier, or whatever... for a dev!", "id": "d0b2ytg"}], [{"comment": "If you\u2019re not running a static code analyzer, a transpiler or a lightweight solution like TypeScript, you\u2019re maintaining an old project, or your team is not with it. Plus, most type conversions you fear don\u2019t actually account for a lot of defects in the wild. 98% of uncaught implicit conversions are found to be harmless: http://mp.binaervarianz.de/ecoop2015.pdf", "id": "czvehwc"}, {"comment": "Let\u2019s assume that your cited study is correct. JavaScript\u2019s freewheeling coercions are mostly safe. This still doesn\u2019t change the fact that JavaScript\u2019s bizarre semantics in this regard makes the language, and the resulting code, more difficult to reason. You can\u2019t entirely trust your understanding of what\u2019s going on in the code unless you completely immerse yourself in the language spec and know every nook and cranny of the language to the minutest detail. That\u2019s a whole shitload of effort for a language that purports to be easy to learn and easy to use.", "id": "czvlbo3"}, {"comment": "| You can\u2019t entirely trust your understanding of what\u2019s going on in the code unless you completely immerse yourself in the language spec and know every nook and cranny of the language to the minutest detail.\n\nI've coded in C#, Java, JS, Python, C++... that seems to be true of any of them, and is arguably the definition of being proficient in the language in question. The most basic JS features have parity with any other OOP language, sure there's maybe 3-5 big gotchas and things to watch for, but once you get past those, yes it is pretty damned easy. I've seen interns out of college with degrees in english figure out JS and make meaningful contributions within days. If you don't do weird shit like assign variables to self-invoking functions and declare const inside loops and shit, you're fine. I've not had a need for most of the newer features... that is to say, I've never sat around reading the js spec and yet can turn out 20k, 40k, and 60k SLOC applications with little question as to what is going on in the code. \n\n\n", "id": "czwfdyc"}, {"comment": "> but once you get past those, yes it is pretty damned easy.\n\nReally? JS evangelist Eric Elliott says, \"almost everybody knows a little JavaScript, but almost nobody really understands JavaScript.\" He has interviewed many JS devs and 99% of them get a failing grade. This may explain why there is soooo much crappy JS code out in the wild. You find it in commonly used libs. You find it in production code. This code was written by people who got passed the 3-5 gotchas.\n\nI've coded in the same languages as you have, but frankly I've never had to look at the language spec for any of those languages. (I've only used JS sparingly in conjunction with jQuery and Amber.) Being able to reason and understand my C# or Java or Python or C++ code was never a problem. JS is another matter altogether.", "id": "czwgwa9"}, {"comment": "meh. the same argument was made about C when writing assembly was the norm.  You don't understand assembly, so you're not a real programmer. Assembly was too high level for the punchcard programmer. this is crap. Who cares if there's bad code out there? There's a ton of shitty c++ and Java libraries out there too. JS gets a lot of flack because that's where all the newer devs are going, of course they're not going to fully comprehend prototypical inheritance... fuck if I REALLY know how it works. But if I can unit test and validate and use something like TS to lend a helping hand, who cares if some ass-butt writes some bad sorting algo.  As long as you can develop SOLID, who cares about the minutiae? I'd rather higher a newbie to JS who had good fundamentals and the ability to read other peoples code than somebody who claims they can reason perfectly about their code and that somehow it is superior because the static checkers are built into the base tool. ", "id": "czx2892"}, {"comment": "My full retort here: http://www.foreverscape.com/art/2016/byte-me-javascript-fatigue/", "id": "czx3sfz"}], [{"comment": "Noone's gonna talk about the balls? I mean... come on!", "id": "czvtcfl"}, {"comment": "It's a clever piece of satire. The testicles draw attention to the humour. Did anyone notice the reference to lipstick on a pig at the beginning that ties together with the pig's balls at the end? Neat!", "id": "czvylbf"}], [{"comment": "Semantics are so hard for developers to adjust to.  JavaScript semantics are something you either learn to live with or you start trying to figure out how to kill JavaScript or prevent its spread. Hint: You can't stop it.   Once you learn and adjust to the semantics, and learn to write idiomatic JavaScript (Hint: Read Doug Crockford, and consider carefully what he thinks, but don't clone his brain-state, think for youself.) it's not as bad as you thought.", "id": "czw0und"}, {"comment": "Read my response to beej71. There are gazillions of JS programmers, and almost none of them really understand JS. Can you get all of them to read Crockford's book? There are a lot of online courses presented by said gazillions of JS programmers. What can you do about them? Yes, it actually *is* as bad as I thought.", "id": "czwgbln"}], [{"comment": "[deleted]", "id": "czuram7"}, {"comment": "Thats just a workaround. A technically unnecessary indirection with potential performance loss and another baklava abstraction layer. JavaScript is not lowlevel enough to make it a good compilation target like Assembly. For example multithreading or the browser VM doesn't use type information from TypeScript to optimize accordingly. Even if a company uses another language, they still need to know the JavaScript pitfalls, atleast in their output and why that output was transpiled that way.", "id": "czusan4"}, {"comment": "Transpiled languages are not ideal, that's true. But since we can't replace JS, I don't see an ideal alternative. At least, we can *largely* avoid programming directly in JS. I use Amber Smalltalk, for example, and 99 per cent of the time is spent in Smalltalk. I just have to pinch my nose when I dip into JS the other one per cent of the time. I'm sure Dart and ClojureScript developers will tell you similar stories.", "id": "czv7g8h"}, {"comment": "I'm waiting for WASM. But can't get my hopes up too high just yet.", "id": "czva3z9"}], [{"comment": "JavaScript is many things, but broke ain't one of them. Especially now, with the significant improvements that the ECMA standards have brought about. The language is now mature, has some pretty neat features, and like any language there are pros/cons to using it.\n\nI don't see it as fundamentally worse than the many languages I've worked with over time (FORTRAN, C, C++, Python, Perl, Ruby, JavaScript, Java, R.) Certainly not an \"abomination\" as compared to the other popular languages.\n\nHonestly, this article seems like it was written by someone with very little programming experience, but who has a high opinion/certainty of their programming knowledge.", "id": "czusm1s"}, {"comment": "Maybe not broken but so full of idiosyncrasies and pitfalls that you'll have to keep in mind all the time even if you superficially restrict yourself to a subset of the language. It constantly carries with it a kind of undeterminism that many people don't like. Sure those exist in other languages aswell like manually freeing memory in C++ (now discouraged) or multithreading complexity, but those are conceptual problems and not on language design level.\nAnother issue is that [TMTOWTDI](https://en.wikipedia.org/wiki/There's_more_than_one_way_to_do_it) is very prevalent in JS. (In contrast to the more sane [Zen 13](https://en.wikipedia.org/wiki/Zen_of_Python) approach) There are numbers of ways to create an object or do polymorphism etc., some additional coming with ES6. With glueing together libraries and frameworks being the way to code in JS, you'd need to be familiar with them all.", "id": "czutfw7"}, {"comment": "this seems to be a natural effect of any language being popular over a stretch of time\n\njava, javascript, php, and c++ are all among hte most hated languages on the internet\n\ni dont think this is a coincidence. popularity of a language inhibits growth of features, which inevitably leads to mistakes in language design. python began to get popular and immediately got hit in the face with a schism in its community. history again and again seems to show that standing still isn't an option if you want a language to actually be used, and not standing still eventually leads to warts.", "id": "czv2e76"}, {"comment": "C# seems to be an exception to your hypothesis. Although it's connected with the \"stigma\" of Microsoft.", "id": "czv2kq5"}, {"comment": "C# got a lot right because it took advantage of lessons learned with Java. ", "id": "czv5rth"}, {"comment": "It's a beautiful language.  I have to say it's the best blend of readability, learnability, and productivity I've seen.  It does contain some traps, but fewer than just about anything else I've read.  Combined with an excellent IDE that encourages users to write good exception handling code (break on unhandled exception for the win!) and the results is that the Pit of Success is enlarged, and the Pits of Failure are greatly reduced in size. A beautiful piece of language, framework, and tool engineering.  If I have one criticism it's that the surface area of the language, the IDE, and the frameworks can be dizzying.  But that's what you get when you build a huge useful ecosystem. The same criticism applies to Java which is also a huge and incredibly useful ecosystem (Language, JVM Runtime, IDEs, component packages, tooling).", "id": "czw0y0i"}, {"comment": "i dont feel like c# ever experienced the explosion effect any of those 4 languages did though. it is indeed popular, but think about the origins of these 4 come from: the beginning of the 'boom' in desktop/webspace", "id": "czv30p8"}, {"comment": "Might be so. No-one just seems to talk about it, yet it remains one of the most widely used languages in the enterprise/corporate world. I guess it's just not very exciting or controversial. It hasn't done any big mistakes, and nothing revolutionary, except perhaps LINQ.", "id": "czv36ic"}, {"comment": "a 'pure' tag for methods would go a long way for that language. sadly the userbase seemingly doesn't understand the value in such a thing yet", "id": "czv3l1t"}, {"comment": "Can you explain what pure would be?\n\nhttps://msdn.microsoft.com/en-us/library/system.diagnostics.contracts.pureattribute.aspx\n\n?", "id": "czv4vkk"}, {"comment": "JavaScript was badly designed from the start though. Also inevitably mistakes in language design didnt apply to C++ (shared and unique pointers etc.) or Java (Java 8 lambda / streams) for instance.", "id": "czv2nd7"}, {"comment": "i don't think something be the pillar of something as big as the internet and be as deeply flawed as you say\n\ni learned and use javascript recently. i truly dont run into any terrible issues nor am I worried. the worst aspect of javascript I run into in my day to day is dealing with runtime errors... issues that exist on all dynamic languages\n\njs introduces new stuff that's good too. its easy to point out random good things released. but it only takes one bad thing implemented for people to cite it as a Horrible Language Ruining Thing. or too many different ways to do something before the language is Too Bloated", "id": "czv3gnh"}, {"comment": "Something doesn't need to be good to be popular, JavaScript for instance was pretty much shunned and ridiculed before jQuery, V8 and AJAX appeared. Coupled with being the only browser supported language, it's inevitable. No way around it. People start to learn it first and foremost (or after PHP) without the knowledge of better designed languages. They are defending it with all their guts. Any seasoned developer will tell you that the language itselfe has so many minefields - more so than most others - but that they can make it work somehow. Forced to use it. For now... JavaScript has seen countless attacks from every angle: GWT, CoffeeScript, TypeScript, Dart, Scala.js to name a few. There definitly is a market for a JS alternative.", "id": "czv4d33"}, {"comment": "it has to be good enough to not collapse under itself though. the web did not die-- despite relying upon javascript to function\n\npeople have not given up on javascript, can you say the same for companies that say... drop ruby entirely for a more performant language? it's easy to pick on javascript because javascript is still here. were it not javascript, it would be something else. it's the first language in a category of applications that did not exist before it. sure, javascript could be replaced by a better language. but backwards compatibility is a thing, and javascript will always have that to worry about, so the comparison isn't exactly meaningful\n\nscott meyers has a talk precisely about this topic with c++. he gave it at a dconf. the take home is that design decisions happen for a reason. every single feature in every language you use had someone weigh some costs and benefits and commit to an implementation decision. js aint all that bad, and has done quite a bit given the pressure it's been under over the years", "id": "czv4lja"}, {"comment": "You mean a company like Twitter?", "id": "czv4tul"}, {"comment": "im sure soundcloud wishes they could too", "id": "czv516e"}, {"comment": "Yes, backwards compatibility is absolutely a thing, which is why I'm satisfied to leave it as a transpiler target for other *better* languages. No one is suggesting that we get rid of JS, but there's no need to *directly* program in it, either.\n\nHowever, what's the excuse for using JS in other application domains, such as the server side, such as the mobile space, such as the Internet of Things, etc., where backwards compatibility is not an issue?", "id": "czv6bns"}, {"comment": "It was the ONLY choice in the browser. Therefore it doesn't matter how deeply flawed it was. If the pit of success was one hair wide, and the pit of failure was a mile wide, but it was the ONLY pit of success around, it would win.\n", "id": "czw11ro"}]]], "4f2w2c": ["Canadian PM schools reporter on quantum computing", "2016-04-16 21:43:49", 0, "https://www.youtube.com/watch?v=Eak_ogYMprk", [[7, "Not programming.\n\nIt is nice to see a leader who's enthuthiastic about this stuff, though.\n"]], [[{"comment": "Not programming.\n\nIt is nice to see a leader who's enthuthiastic about this stuff, though.\n", "id": "d25pai6"}]]], "4id9tx": ["TypeScript, web and the illusive type-safety-advantage", "2016-05-08 08:32:39", 6, "https://www.jayway.com/2016/05/06/typescript-web-and-the-illusive-type-safety-advantage/", [[35, "I'm not sure I agree with this conclusion. The module is built in typescript, but then you use standard javascript to get values from the document. You won't get type warnings if you stop using typescript for half your code."], [29, "> Rather than trying to avoid properly learning JavaScript, I think anybody doing front end web should embrace it and learn to love it. Yes, really!\n\nBy that same token, I would encourage the author to embrace static typing, and learn to love it.  He clearly does not understand the role of static typing and its limits.  Static typing logic extend to compile time checks, and only over the code actually inspected by the compiler.  He seems to want to treat static typing as a run time check, so that he can catch cases where his add method is passed numbers in an arbitrary onclick eval.  If he's getting confused why that doesn't work, he doesn't understand how typescript works.\n\nThe author has two better options in this case:\n\n1. use typescript to attach click handlers rather than using html attributes (preferred)\n2. add run time checks for value types passed into method bodies (which slows things down, but may be the only option if inline javascript in html is to be used).\n\n[edit : numbered points]\n\n\n\n"], [11, "I don't see how any typescript user can be surprised by this behavior. Every tutorial or course on TypeScript I've seen starts with a demo on how the types disappear in the compiled JS."], [10, "This is not really an issue with Typescript or JavaScript but a lack of understanding of HTML inputs. The type property simple restricts the type of the input not the output. The output is always a string, the type property just makes sure that string is of type X, in this case a number."], [8, "Use TypeScript to document your assumptions on what data/types you expect. Use tests to verify the runtime behaviour.\n\nAny type documentation is better than none; it helps signify the developer's intentions."], [4, "> Also, since the TypeScript compiler prevents us from passing strings into the function, we can\u2019t even unit test the function with string input to make sure the type conversion works like it should.\n\nYes you can. Just add casts: add(<any> \"1\", <any> \"2\"). "], [4, "Illusive or Elusive?"], [2, "I completely agree with the sentiment that devs need to understand the underlying language and how it works.\n\nThe problem for me in this situation is that the unit tests are being run against the ts files, not the generated javascript. The unit tests aren't testing the actual code that *runs*, they are testing the code that *generates* the code that runs\n\nTest against the output and you can run edge tests and this becomes a non issue"], [2, "One thing is TypeScript compiling to JavaScript which is 95% solid and sound (although the rest 5% are gaping holes), the whole other thing is what you do with the perfectly valid compiled JavaScript. If you stick it into a dishwasher it will get wet, if you put it under a hydraulic press you gonna get it smooshed, but hey why would you do that? Didnt you know that doing it is unsafe? No one does it because makes little sense. Similary you take perfectly valid JavaScript code compiled from TypeScript and stick it to something that doesn't give a shit about that validness and stuff just because when the validness was checked it was not there. So mind me asking you, what do you expect?"], [2, "Honestly, arguing that you can get logic errors in type safe code is like arguing that seat belts are not worth using in cars because things can come through the window and kill you that way. \n\nIt's true, but still completely missing the point of the benefits it does give. Don't let the perfect be the enemy of the good.\n\nAnd in this case more type checking would prevent the error anyway."], [1, "This is a good case for the strong mode proposal. Uses typescript style declarations and will throw a TypeError when a call doesn't follow them. Also adds other changes like getting rid of \"arguments\", double equals, and \"var\".\n\nhttps://developers.google.com/v8/experiments#frequently-asked-questions"], [0, "[deleted]"], [0, "> The problem I have with TypeScript in web projects is that I often get the feeling, it was chosen because the developers prefer to avoid having to understand JavaScript and want to code the web-frontend in a language they are comfortable with.\n\nWhich is perfectly fine and sensible. I'd rather not deal with a language that is designed in 10 days and that fact is felt even now, when I have a good alternative at hand."]], [[{"comment": "I'm not sure I agree with this conclusion. The module is built in typescript, but then you use standard javascript to get values from the document. You won't get type warnings if you stop using typescript for half your code.", "id": "d2x60x5"}, {"comment": "That was my first thought as well. He's calling\n\n    add(document.getElementById(\"arg1\").value)\n\nand is then surpised that it's passed as string.\n\nIf getValue() was also written in TypeScript and defined as returning a number then the compiler would catch the error because it knows that input.value is a string.", "id": "d2x9omm"}, {"comment": "So you're saying that if you use TS directly to get the values from the text fields, it will automatically convert them to numbers before doing anything else with them?\n\nIf so, then really yeah, it's just a problem of not using TS all the way.  Though it makes sense that if you use TS, you'll probably interface with JS modules in some regard and that any communication between the two will have to be assessed for type validity.", "id": "d2x7xl2"}, {"comment": "It won't automatically convert them, it'll give you a compile error because you're trying to pass a string off as a number.\n\nSince TS just compiles to JS, I'm confused as to why people would expect it'd catch any runtime type errors or alter behaviour in third party code written in other languages? \n\n", "id": "d2x8fyl"}, {"comment": "You probably wouldn't want it to automatically convert them anyways considering numbers can have a wide variety of formats. This is a good case for the strong mode proposal which uses TypeScript style type declarations to throw a TypeError when invalid parameter values are passed.\n\nhttps://developers.google.com/v8/experiments", "id": "d2xdrrh"}], [{"comment": "> Rather than trying to avoid properly learning JavaScript, I think anybody doing front end web should embrace it and learn to love it. Yes, really!\n\nBy that same token, I would encourage the author to embrace static typing, and learn to love it.  He clearly does not understand the role of static typing and its limits.  Static typing logic extend to compile time checks, and only over the code actually inspected by the compiler.  He seems to want to treat static typing as a run time check, so that he can catch cases where his add method is passed numbers in an arbitrary onclick eval.  If he's getting confused why that doesn't work, he doesn't understand how typescript works.\n\nThe author has two better options in this case:\n\n1. use typescript to attach click handlers rather than using html attributes (preferred)\n2. add run time checks for value types passed into method bodies (which slows things down, but may be the only option if inline javascript in html is to be used).\n\n[edit : numbered points]\n\n\n\n", "id": "d2x9asf"}, {"comment": "It should be noted that using Dart instead of TypeScript would not produce these kinds of issues, so that's another option. The dart2js compiler automatically handles types correctly. The article argues that TS is an inadequate shield from the vagaries of JS, but sadly fails to point out that Dart *does* protect you from that stuff.", "id": "d2xescv"}, {"comment": "Haxe can as well, although not as a first class language feature.  It's not a good idea to offer run time type checks as a production solution to javascript interfaces.  It may be nice to have during debugging (or testing, as in the use case of the Haxe equivalent), but it's a tremendous slowdown for the runtime to validate types, both in terms of executing the logic necessary, and in generating and saving the additional rtti info necessary for the checks.\n\nTo take advantage of static typing in this case, the author should really find a type safe way of binding his method logic to dom events.  He's pretty close from what I can see, he just needs to take that final step to expose all of the logic to the compiler internals.  He'll be much happier when both he and the compiler are on the same page with their entire app.\n", "id": "d2xsn6x"}, {"comment": "Yeah, with Dart, you only get runtime type checking when you run in \"checked mode\", a special mode of Dartium (a build of Chromium that includes the Dart virtual machine). All that overhead is eliminated for production builds.", "id": "d2y2atn"}], [{"comment": "I don't see how any typescript user can be surprised by this behavior. Every tutorial or course on TypeScript I've seen starts with a demo on how the types disappear in the compiled JS.", "id": "d2xb2h1"}], [{"comment": "This is not really an issue with Typescript or JavaScript but a lack of understanding of HTML inputs. The type property simple restricts the type of the input not the output. The output is always a string, the type property just makes sure that string is of type X, in this case a number.", "id": "d2x59a5"}, {"comment": "The type property doesn't have to verify that either, it's just a suggestion for which soft keyboard to display for mobile and what type of picker is recommended. Browser support is all over the place when it comes to UI and validation.", "id": "d2x6j67"}], [{"comment": "Use TypeScript to document your assumptions on what data/types you expect. Use tests to verify the runtime behaviour.\n\nAny type documentation is better than none; it helps signify the developer's intentions.", "id": "d2x9g0b"}], [{"comment": "> Also, since the TypeScript compiler prevents us from passing strings into the function, we can\u2019t even unit test the function with string input to make sure the type conversion works like it should.\n\nYes you can. Just add casts: add(<any> \"1\", <any> \"2\"). ", "id": "d2xd51y"}, {"comment": "Yes this is an important point. The article is based on the fact it can't be tested, but it can, so it makes the entire argument irrelevant.  \n\nAlternatively you can write your unit tests in Javascript as mocking is  easier in a type-less language.\n\nEven if this was a problem with TS, the type system catches far more type problems in your own code at compile time to still be worth using over JS. I can only assume this guy has never written a large application with a team of developers.", "id": "d2xu4jm"}], [{"comment": "Illusive or Elusive?", "id": "d2x4buk"}, {"comment": "If you read the article it seems that illusive is what the author meant.", "id": "d2x4n0k"}, {"comment": "Isn't illusory the correct word?", "id": "d2x8gfk"}, {"comment": "illusory: based on illusion; not real\n\nillusive: deceptive; illusory\n\nBoth are acceptable, although \"illusory\" would probably be more clear.", "id": "d2x8z2i"}, {"comment": "`more clear` should be `clearer`", "id": "d2xtqsi"}, {"comment": "Hmm, I read the article, and *elusive* seems more idiomatic, even if in a literal sense *illusive* is appropriate too.\n\nAs in: he's suggesting that people use TypeScript because they're scared of JS's dynamically typed nature, and are using TypeScript to attain (static) type-safety.  And that type-safety eludes them.\n\nSure, you could say the type-safety provided by TypeScript is an illusion, which is almost equivalent, but using *illusive* like that isn't idiomatic AFAIK.", "id": "d2xbc5e"}, {"comment": "I read it more as the type-safety advantage itself is an illusion. \n\nYes, using illusive like that isn't idiomatic, but it's closer to what he means than elusive. At least, in my opinion. :)", "id": "d2xmcqa"}], [{"comment": "I completely agree with the sentiment that devs need to understand the underlying language and how it works.\n\nThe problem for me in this situation is that the unit tests are being run against the ts files, not the generated javascript. The unit tests aren't testing the actual code that *runs*, they are testing the code that *generates* the code that runs\n\nTest against the output and you can run edge tests and this becomes a non issue", "id": "d2x8wnd"}, {"comment": "The tests are run against the JS, they are just compiled against the TS.", "id": "d2xu64e"}, {"comment": "Ah, ok, but there is still a similar issue. Compiling the tests against TS isn't simulating how they'd run in the wild as it prohibits testing edge cases\n\nUsing TS to test actively stops you using inputs that are valid once the code has been compiled down to javascript", "id": "d2yizd1"}, {"comment": "> it prohibits testing edge cases\n\nIt doesn't. You can either;\n\n\n1. write your tests in JS\n2. write your tests in TS with casting when testing incompatible types\n\nBoth cases don't prevent you from writing your production code in TS.", "id": "d2z0h45"}], [{"comment": "One thing is TypeScript compiling to JavaScript which is 95% solid and sound (although the rest 5% are gaping holes), the whole other thing is what you do with the perfectly valid compiled JavaScript. If you stick it into a dishwasher it will get wet, if you put it under a hydraulic press you gonna get it smooshed, but hey why would you do that? Didnt you know that doing it is unsafe? No one does it because makes little sense. Similary you take perfectly valid JavaScript code compiled from TypeScript and stick it to something that doesn't give a shit about that validness and stuff just because when the validness was checked it was not there. So mind me asking you, what do you expect?", "id": "d2xo36h"}], [{"comment": "Honestly, arguing that you can get logic errors in type safe code is like arguing that seat belts are not worth using in cars because things can come through the window and kill you that way. \n\nIt's true, but still completely missing the point of the benefits it does give. Don't let the perfect be the enemy of the good.\n\nAnd in this case more type checking would prevent the error anyway.", "id": "d2yhayo"}], [{"comment": "This is a good case for the strong mode proposal. Uses typescript style declarations and will throw a TypeError when a call doesn't follow them. Also adds other changes like getting rid of \"arguments\", double equals, and \"var\".\n\nhttps://developers.google.com/v8/experiments#frequently-asked-questions", "id": "d2xdcab"}], [{"comment": "[deleted]", "id": "d2xcc70"}, {"comment": "A type check is a universal check. A test is an existential check. The former tend to be weaker, the latter, at least in my experience, tend to become more cumbersome and less useful as a system grows.", "id": "d2xfa1d"}, {"comment": "You are in sore need of new experiences then, in a language where the type system is actually useful.", "id": "d2xgz64"}, {"comment": "It's a general fact of mathematical proofs that universal proofs are harder than existential ones, the simple reason being that if a property holds universally, there exists a configuration for which the property holds.", "id": "d2xhrwp"}, {"comment": "That is true, but you're still operating on the false premise that type systems are only capable of universal proofs.", "id": "d2xi6vu"}, {"comment": "Care to cite appropriate literature? Happy to be falsified.", "id": "d2xx20v"}, {"comment": "I was unable to find any literature on the subject with that specific framing, instead I can give you a (hopefully) straightforward example using Scala(I use scala because that's what I use in my day job, but I can also produce the same example in haskell).\nLet's say given the following Record:\n\n    case class Book(author: String, title: String, id: Int, price: Double)\n\nNow let's say we want to define a function that accepts record with a price expressed only in USD. Currently as given, our record type has the price as a poorly typed `Double`. We don't know if the price valid(at the very least bounded above 0), if it is in USD and perhaps if not is in a currency that is expressible in terms of USD(our existential constraint). Let's call this function `purchase` and let us define a few extra datatypes to represent these constraints.\n\n     //A few currencies\n    class USD(val dollars: Double)\n    class Yen(val yen: Int)\n    class Ruble(val rubles: Double)\n\n    //Give an alias for Conversions to USD\n    type ToDollar[T] = T => USD\n\nNow lets take a look a a possible signature of purchase:\n\n    def purchase[C : ToDollar, R](record: R)(price: R => C)\n\nThe above constraint in Scala is called a context bound. It would read, given a type `C` there must exist a `ToDollar[C]`. We also accept a Record type `R`, and a function to retrieve the price from our record, which is of dubious value at the moment(why not have purchase just accept `C` instead of taking `R` and `R => C`?), but this allows our record to be polymorphic without having to involve more complicated constraints that will distract from our currency constraint.\n\n   If we define a function to convert Rubles to USD and mark that function as `implicit`(which will make the function evidence of the `ToDollar` constraint) like so:\n\n    implicit val ruble2USD = (ruble: Ruble) => USD(ruble.rubles * 0.8) //Hardcode some bogus exchange rate for now.\n\n\nWe then call purchase with a with Ruble, passing the identity function to the second parameter list.\n\n    purchase(Ruble(1.0))(identity)\n\nIf we did the same thing with Yen, we'd fail compilation:\n\n    purchase(Yen(1000))(identity)\n\n    Error:(17, 25) not enough arguments for method purchase: (implicit evidence$1: ToDollar[Yen])USD.\n    Unspecified value parameter evidence$1.\n    purchase(new Yen(1000))(identity)\n                       ^\nWe now have a function that allows currencies given an existential proof. To better demonstrate, let's make Book Polymorphic over it's currency.\n\n    case class Book[C](author: String, title: String, id: Int, price: C)\n\nand define two different types of books:\n\n    val CandP = Book(\"\u0424\u0451\u0434\u043e\u0440 \u041c\u0438\u0445\u0430\u0301\u0439\u043b\u043e\u0432\u0438\u0447 \u0414\u043e\u0441\u0442\u043e\u0435\u0301\u0432\u0441\u043a\u0438\u0439\", \"\u041f\u0440\u0435\u0441\u0442\u0443\u043f\u043b\u00e9\u043d\u0438\u0435 \u0438 \u043d\u0430\u043a\u0430\u0437\u00e1\u043d\u0438\u0435\", 1, Ruble(1.0))\n    val genji = Book(\"\u7d2b \u5f0f\u90e8\",\"\u6e90\u6c0f\u7269\u8a9e\", 2, Yen(1000))\n\nWe are able to purchase `CandP`:\n\n    purchase(CandP)(_.price)\n\nbut `genji` is rejected by the type system:\n \n    purchase(genji)(_.price)\n\n    Error:(24, 17) not enough arguments for method purchase: (implicit evidence$1: ToDollar[Yen])USD.\n    Unspecified value parameter evidence$1.\n    purchase(genji)(_.price)\n               ^\n\nI have a complete working example of this program [here](http://scastie.org/17101). You can clone the snippet and comment out the usages of Yen to see the compilation errors yourself. In a complete program we may also need to handle the possibility of failure(ie, if we had old book values with just `Double`s, a conversion to `USD` may not be valid), or work with polymorphic lists of `Book`s or non-`Book` records.", "id": "d3090zr"}, {"comment": "&exist; x.\n\n&forall; x -> true;\n\n-> true.\n\nQED.", "id": "d33d3ki"}, {"comment": "Let me re-iterate:\n\n* a (successful) test implies the program works for a particular input.\n* a (successful) type check implies the program might work (up to granularity of the type system and, hence, things \"going wrong under the hood\") for all possible inputs.", "id": "d33dava"}, {"comment": "the amount of tests that i write for haskell is far less than other languages.. many other languages use tests as a supplement for the language itself...seems backward direction", "id": "d2xd4d8"}], [{"comment": "> The problem I have with TypeScript in web projects is that I often get the feeling, it was chosen because the developers prefer to avoid having to understand JavaScript and want to code the web-frontend in a language they are comfortable with.\n\nWhich is perfectly fine and sensible. I'd rather not deal with a language that is designed in 10 days and that fact is felt even now, when I have a good alternative at hand.", "id": "d2xjde6"}]]], "56yyue": ["Bye Bye, Bullets: The Stack Overflow Developer Story is the New Technical Resume", "2016-10-11 20:45:42", 0, "http://blog.stackoverflow.com/2016/10/bye-bye-bullets-the-stack-overflow-developer-story-is-the-new-technical-resume/", [[20, "This is terrible, yet another profile, yet another place to maintain presence online, it's ridiculous"], [10, "I tried to create my developer story but it was closed as duplicate by a mod /s"], [9, "Wow, i never knew my resume could be outdone by such genius.  Thank god for you, stack overflow product people!\n\n/s"], [9, "I clicked the rickroll. Off-putting :-(\n\nI really only ask questions on SO. Stupid question I reserve for a non-de-plume account of course, and haven't build a reputation for either.\n\nI'm active on Github which feels like a decent showcase place for projects/demos - but I need to do a spring clean there to make it consumable for people that would want to approach me for jobs.\n\nLinkedin is where my who-I-am, where-I-worked (stretching back to '89). I'm in exec management now, so my coding is mostly my hobby time. The \"Developer Story\" aspect to the SO launch, doesn't feel inclusive to/of me.\n\nWhat I really want is a Linkedin not owned by Linkedin, the data for which is held in a public Github repo (data about me - my repo, you have yours too) that uses PKI to make sure that only people I'm connected to see everything, and otherwise a site that provides the visibility of excerpts/subsets progressively depending on your linked-ness to me.  Not, I think, a job for blockchains, but would be using some of the same principles. It'd need a client app, or at least a set of CLI tools (queue seed projects)."], [6, "This seems rather full of hubris."], [6, "No thanks"], [4, "Yeah, yeah I get it... no, thanks, though.\n\nI simply *will not* be arsed. I do not wish e.g. to be harassed by recruiters when I am not looking for a job, and that doesn't happen all that often, maybe once in 5 years. And when I did, I did not see that recruiters and businesses failed to find me. Heck, google found me, but bar some google groups posts, I had no \"online presence\" whatsoever. (disclaimer: I failed miserably; on the upside, I just took a new position, so it would have been quite embarrassing had I passed, and I wasn't too interested in moving either).\n\ntl;dr: bleh, I am too old for this shit :-).\n\nBesides\n\n\n"], [3, "Weak."], [3, "So Stackoverflow announces that they are the best?  This is called advertising, not a post."], [2, "Tell this to every single job I've ever applied for."], [2, "Seems like the \"Save to PDF\" feature puts your very first display name as the header, i.e. I've changed my display name twice, yet it shows my very first display name on the PDF."], [2, "no"], [-2, "I give that to a future employer and I'll never hear from them again! \n\nLeave it to the liberals in the programming community to come up with a very bad idea. I swear for every one great idea the programming community has there's at least a hundred really shitty ideas and about five of those shitty ideas will be adopted and widely used. (example: javascript)"]], [[{"comment": "This is terrible, yet another profile, yet another place to maintain presence online, it's ridiculous", "id": "d8njcin"}, {"comment": "It's the first careers profile linked to a big website that I know of though.\n\nLinkedin is not built for recruiting, and isn't good at it. This is built for recruiting, and builds on an existing job board system.", "id": "d8nksgk"}, {"comment": "A good recruiting site needs to at least have the fig-leaf of not being a recruiting site - that way one doesn't get grief when your boss sees you on it. ", "id": "d8nq7aj"}], [{"comment": "I tried to create my developer story but it was closed as duplicate by a mod /s", "id": "d8nxv4g"}, {"comment": "This story has been closed as \"personal\" by *50 powermod names here*", "id": "d8qwha5"}], [{"comment": "Wow, i never knew my resume could be outdone by such genius.  Thank god for you, stack overflow product people!\n\n/s", "id": "d8nkxp2"}], [{"comment": "I clicked the rickroll. Off-putting :-(\n\nI really only ask questions on SO. Stupid question I reserve for a non-de-plume account of course, and haven't build a reputation for either.\n\nI'm active on Github which feels like a decent showcase place for projects/demos - but I need to do a spring clean there to make it consumable for people that would want to approach me for jobs.\n\nLinkedin is where my who-I-am, where-I-worked (stretching back to '89). I'm in exec management now, so my coding is mostly my hobby time. The \"Developer Story\" aspect to the SO launch, doesn't feel inclusive to/of me.\n\nWhat I really want is a Linkedin not owned by Linkedin, the data for which is held in a public Github repo (data about me - my repo, you have yours too) that uses PKI to make sure that only people I'm connected to see everything, and otherwise a site that provides the visibility of excerpts/subsets progressively depending on your linked-ness to me.  Not, I think, a job for blockchains, but would be using some of the same principles. It'd need a client app, or at least a set of CLI tools (queue seed projects).", "id": "d8nlqx1"}], [{"comment": "This seems rather full of hubris.", "id": "d8njv23"}], [{"comment": "No thanks", "id": "d8nkwij"}], [{"comment": "Yeah, yeah I get it... no, thanks, though.\n\nI simply *will not* be arsed. I do not wish e.g. to be harassed by recruiters when I am not looking for a job, and that doesn't happen all that often, maybe once in 5 years. And when I did, I did not see that recruiters and businesses failed to find me. Heck, google found me, but bar some google groups posts, I had no \"online presence\" whatsoever. (disclaimer: I failed miserably; on the upside, I just took a new position, so it would have been quite embarrassing had I passed, and I wasn't too interested in moving either).\n\ntl;dr: bleh, I am too old for this shit :-).\n\nBesides\n\n\n", "id": "d8nkrdm"}], [{"comment": "Weak.", "id": "d8o04sk"}], [{"comment": "So Stackoverflow announces that they are the best?  This is called advertising, not a post.", "id": "d8o9elq"}], [{"comment": "Tell this to every single job I've ever applied for.", "id": "d8nll60"}], [{"comment": "Seems like the \"Save to PDF\" feature puts your very first display name as the header, i.e. I've changed my display name twice, yet it shows my very first display name on the PDF.", "id": "d8nnosu"}], [{"comment": "no", "id": "d8oj9g5"}], [{"comment": "I give that to a future employer and I'll never hear from them again! \n\nLeave it to the liberals in the programming community to come up with a very bad idea. I swear for every one great idea the programming community has there's at least a hundred really shitty ideas and about five of those shitty ideas will be adopted and widely used. (example: javascript)", "id": "d8obpy9"}]]], "54b2s8": ["So You Want to be a Functional Programmer (Part 4)", "2016-09-24 21:22:48", 0, "https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-4-18fbe3ea9e49", [[2, "Interesting use of JavaScript, arguably one of the worst choices for functional programming. f\n\nEdit: For the sake of clarity, I'm really just trying to say, JS is very difficult to enforce immutability, purity and referential transparency. The lack of a type system also makes most implementations of monads relatively useless (Promise is the only good one that's monad-ish), especially with the advent of generator-based control flow.\n\nIf anything, these medium articles should show some functional C++ or other languages that are established (and respected) and show how they're all adopting functional concepts while leaving the category theory behind (and thank God for that)."], [-1, "Loosely-examined shower-thought: The more-extreme zones of Functional Programming are just OOP in heavy makeup: The trick is that your usual business-customers have all been replaced by mathematician-customers, and most of your ~~objects~~ ~~effort~~ *stuff* is spent modeling and encapsulating *those* concepts and operations instead."], [0, "Somebody needs to ban medium.com and its shills. This is disgusting spam."]], [[{"comment": "Interesting use of JavaScript, arguably one of the worst choices for functional programming. f\n\nEdit: For the sake of clarity, I'm really just trying to say, JS is very difficult to enforce immutability, purity and referential transparency. The lack of a type system also makes most implementations of monads relatively useless (Promise is the only good one that's monad-ish), especially with the advent of generator-based control flow.\n\nIf anything, these medium articles should show some functional C++ or other languages that are established (and respected) and show how they're all adopting functional concepts while leaving the category theory behind (and thank God for that).", "id": "d81ddl1"}], [{"comment": "Loosely-examined shower-thought: The more-extreme zones of Functional Programming are just OOP in heavy makeup: The trick is that your usual business-customers have all been replaced by mathematician-customers, and most of your ~~objects~~ ~~effort~~ *stuff* is spent modeling and encapsulating *those* concepts and operations instead.", "id": "d80dmof"}, {"comment": "You're not far off; in category theory (the basis of pure, statically typed languages), the core concepts are 'objects' and 'arrows' (roughly functions) between them.", "id": "d811sg1"}, {"comment": "given the amount of boilerplate OOP languages tend to have I'd be tempted to say its the reverse, OOP languages are the ones covered in slap ;)", "id": "d82gida"}], [{"comment": "Somebody needs to ban medium.com and its shills. This is disgusting spam.", "id": "d81apo9"}]]], "519jpw": ["Why You Should Hire Computer Science Majors", "2016-09-05 18:05:43", 0, "http://brennan.io/2015/08/30/why-you-should-hire-cs-majors/", [[1, "> But the vast majority of code a developer writes runs on an operating system, and if they don\u2019t understand the basics of how it works and what it does, they\u2019re writing code on a rotten foundation. You expect that an engineer building a bridge understands the properties of the ground they\u2019re building on, and the materials they\u2019re using. For programmers, the operating system is that ground and material.\n\nYes of course I'd expect an engineer to know how the ground reacts, and the properties of the materials you're using. But I would not expect them to know how to manufacture those materials.\n\nUniversity doesn't teach you the properties and merits of wood vs concrete vs steel for building bridges. It teaches you how to make bricks. Using the bricks to make a bridge is left as an excercise to the reader, and never mind the fact that bricks aren't really used to build bridges anymore[1].\n\nLearning how to make bricks doesn't really help you to build bridges out of steel, just the same as learning how to build a toy operating system doesn't really help you to build applications on modern operating systems. \n\n[1] I of course don't make bridges so this might not be true :P"], [0, "Javascript developers are downvoting this :p"]], [[{"comment": "> But the vast majority of code a developer writes runs on an operating system, and if they don\u2019t understand the basics of how it works and what it does, they\u2019re writing code on a rotten foundation. You expect that an engineer building a bridge understands the properties of the ground they\u2019re building on, and the materials they\u2019re using. For programmers, the operating system is that ground and material.\n\nYes of course I'd expect an engineer to know how the ground reacts, and the properties of the materials you're using. But I would not expect them to know how to manufacture those materials.\n\nUniversity doesn't teach you the properties and merits of wood vs concrete vs steel for building bridges. It teaches you how to make bricks. Using the bricks to make a bridge is left as an excercise to the reader, and never mind the fact that bricks aren't really used to build bridges anymore[1].\n\nLearning how to make bricks doesn't really help you to build bridges out of steel, just the same as learning how to build a toy operating system doesn't really help you to build applications on modern operating systems. \n\n[1] I of course don't make bridges so this might not be true :P", "id": "d7brfee"}], [{"comment": "Javascript developers are downvoting this :p", "id": "d7akaac"}, {"comment": "I didn't get further than it being a year-old rebuttal opinion piece to a forgotten article out of a non-tech publication.", "id": "d7cgm7j"}, {"comment": "Anyone who isn't desperately trying to justify their wasted nearly half a million dollars is downvoting this (half a million figure includes the opportunity cost vs 4 years of working at a typical software salary).\n\nEducation is valuable, but we need to realize that time is a limited resource. By going to university you are sacrificing time for something else (which is why you can't just tack math courses onto a computer science degree with the proof that people who took math are better software developers, you have to compare it with taking additional comp sci courses)", "id": "d7brt8e"}, {"comment": "My tuition fees were ~14\u20ac per year.", "id": "d7bspaq"}, {"comment": "yeah that's a fraction of the real cost though. The real cost is the loss of 4 years of salary.", "id": "d7c7g4o"}, {"comment": "But my salary with no experience and no degree would have been shit anyway.", "id": "d7cho0u"}, {"comment": "Firstly that's not true. Maybe it wouldn't have been the standard $100K, but it would have been higher than most people get paid.\n\nSecondly the pay would go up over those 4 years (if you're good) to the point where it's higher than it would be straight out of university. So to accurately compare you have to consider those 4 years as being tacked onto the total years you work, in which case you count them as the highest salary you'll achieve. (Put another way, not going to uni means 4 more years working before you retire).\n\nIf you don't want to go extreme then consider the 2 year programs in colleges. I have yet to see any real difference in pay between those and the 4 year students. In fact most of our best hires come from college, not from university. That's 2 extra years of salary, and the salary will be identical coming out of it anyways (and after those 2 years of working will go up more than at uni anyways).", "id": "d7cp1dq"}, {"comment": "I'm european, as you might understand from the use of \"\u20ac\" as currency symbol.\n\nWe don't have college/university thing that you're talking about.", "id": "d7cq2qg"}, {"comment": "You don't have the 2 year vs 4 year program? Where the 2 year program is focused more on real world, applied learning, and the 4 year program is theoretical academic learning?", "id": "d7cq4m1"}, {"comment": "Nope. We have 3 years for everyone (bachelor degree), and if you want you can do an extra 2 years for master degree.\n\nBachelors degree in CS are somewhat more applied, but you'll still do lots of math. Masters, it depends on what you specialize, but they won't be teaching you javascript or go.", "id": "d7cs69i"}, {"comment": "You don't have diploma programs?\n\nEDIT: It looks like you do: http://www.academiccourses.com/Diploma/Europe/", "id": "d7ctg0l"}]]], "3w6jxb": ["Go vs Node vs Rust vs Swift", "2015-12-10 08:21:55", 0, "https://grigio.org/go-vs-node-vs-rust-vs-swift/", [[24, "> Here the fastest is Swift, then Rust. It is a bit weird because they both compile in LLVM.\n\nEasy, just because they use the same backend it doesn't mean:\n\n- they use the same version\n\n- they are compiled with the same set of flags\n\n- they are using the same set of compiler passes\n\n- the bitcode given from the frontend to the backend is the same\n\n\nThis is why one should never make the error of conflating languages with implementations."], [22, "Is there any reason to compare those four languages? I was under the impression they all have entirely different goals."], [22, "> So I decided to do a couple of simple benchmarks\n\nBenchmarking is hard, simple benchmarks are almost certainly wrong."], [11, "TIL - Node is a language."], [9, "Go and Swift use machine integers, whereas Rust uses `i64` on `fib` and `i32` on `bench1`. Use `isize` in Rust or `Int64` in others instead for fairness. Unfortunately there's no easy way to be as nice to Javascript, but that's its own damned fault.\n\nAlso, for parallelism in Rust just use threads. Rust's threads aren't scary like other language's threads, which is the whole point."], [9, "I never really understand these sorts of tests because in the real world when you have to deliver solutions 9/10 you will have to factor in DB access/operations and possibly network latency.\n\nI've been coding for 27 years and never had a paying customer say 'O write me an app to compute the fibonacci sequence will you...' :)\n"], [6, "[deleted]"], [7, "One of those is not like the others."], [3, "> Modern user-friendly typed languages\n\nSeeing that it includes JavaScript, whats your definition of \"typed language\". You mean languages with a type system?\n\n\n> mature, possible code sharing with frontend, it's JavaScript, functional features\n\nDefinition of \"mature\" too.\n\n\n> I didn't compare these languages to dynamic languages like ruby or python because there are already a lot of comparisons with them.\n\nThen why compare it with JavaScript?"], [2, "I see you are using gnome-system-monitor to visualize CPU performance. Why not use CPU Graph which uses less system resources and allows you to rewind the timeline, ultimately making your visualization more accurate?\n\nhttp://www.getlazarus.org/apps/cpugraph/\n\n\n\n"], [2, "Just as an FYI, not a debunking of the write up:\n\n> Golang: to enable all the cores, you have to put in your code runtime.GOMAXPROCS(num of cores you want to use)\n\nThis isn't true, you can set the environmental variable `GOMAXPROCS` for this - if anyone is looking for a nicer way to accomplish that :)"], [2, "see also: https://www.reddit.com/r/linux/comments/3w2r74/go_vs_node_vs_rust_vs_swift_on_ubuntu_linux_1510/"], [-7, "It's a mashup of _all_ the useless fashion statement programming languages! Anything to avoid actually programming, #yolo!\n"]], [[{"comment": "> Here the fastest is Swift, then Rust. It is a bit weird because they both compile in LLVM.\n\nEasy, just because they use the same backend it doesn't mean:\n\n- they use the same version\n\n- they are compiled with the same set of flags\n\n- they are using the same set of compiler passes\n\n- the bitcode given from the frontend to the backend is the same\n\n\nThis is why one should never make the error of conflating languages with implementations.", "id": "cxtvr2w"}], [{"comment": "Is there any reason to compare those four languages? I was under the impression they all have entirely different goals.", "id": "cxtx5ce"}, {"comment": "Ability to get click-throughs? It's pretty buzz-word compliant isn't it .-)", "id": "cxtxryu"}, {"comment": "Because 3 are:\n\n- user-friendly modern typed languages\n- the syntax is very similar (at least for basic scenarios)\n- to see if the performance benefits are worth or not", "id": "cxty22j"}, {"comment": "Node.js is obviously doesn't meet these criteria. I mean javascript been so long for now and syntax of it IMHO not so similar to others(yes they look like Algol family languages, but still). \n\nAnd Go, Rust, Swift they are compiled, but Node.js isn't. What's the point to compare it with those 3? ", "id": "cxtyac9"}, {"comment": "Node.js is just as compiled as the rest, it's just JIT complied rather than AOT. Performance should be comparable.", "id": "cxtyh1t"}, {"comment": "Downvoters, _under the circumstances of this benchmark_, this is a true statement. Small functions doing integer arithmetic is \"easy mode\" for a JIT. Any JIT that can't get native-level performance out of a Fib implementation needs to go back to the drawing board, as it has failed at its most basic job.", "id": "cxu4313"}, {"comment": "Yeah, thank you for obvious, everything must be compiled down to machine code to work. But everybody understood what I've meant and difference between jit/compiled, you don't have to mention that. :) And believe me that is the factor for languages for not comparing them if they are compiled/JIT/interpreted. Performance is comparable even between Python and C++. ", "id": "cxu94e4"}, {"comment": "> Performance is comparable even between Python and C++.\n\nYou wouldn't expect Python and C++ to achieve similar performance on this kind of benchmark. You *would*, however, expect a good JIT to do so. In this case, the difference between JIT and AOT can easily be negligible.", "id": "cxubd4d"}, {"comment": "You answered all by yourself: \"good JIT\". :) Also you forget that javascript is dynamic language.", "id": "cxvc372"}, {"comment": "v8 is considered pretty good. And dynamic languages can be compiled to efficient code, especially for simple benchmarks like these.", "id": "cxvckx1"}, {"comment": "I believe you are fanboy, that's sad.  ", "id": "cxvn4zz"}, {"comment": "Then you are an ignorant fool.", "id": "cxvnsw6"}, {"comment": "I wrote 3. NodeJS is there because it is the fastest non-typed language and V8 is the most used JavaScript implementation.\nPS:I'm the author of the post", "id": "cxtycxn"}, {"comment": "Lua is generally faster than JavaScript with LuaJIT, I believe. ", "id": "cxu148e"}, {"comment": "[deleted]", "id": "cxu1fjf"}, {"comment": "You sure? LuaJIT normally aces nanobenchmarks. See, for example, the benchmarks on [Julia's homepage](http://julialang.org/).", "id": "cxu1obt"}, {"comment": "Incorrect.", "id": "cxu28a9"}, {"comment": "> typed languages\n\nSo [TypeScript](http://www.typescriptlang.org/) ?", "id": "cxvgm01"}, {"comment": "or Flow.. The point is that both compile in non typed js, because currently javascript doesn't support types natively.", "id": "cxvsui6"}, {"comment": "The point is to check the types, before run time.", "id": "cxvy3ut"}], [{"comment": "> So I decided to do a couple of simple benchmarks\n\nBenchmarking is hard, simple benchmarks are almost certainly wrong.", "id": "cxtx85t"}], [{"comment": "TIL - Node is a language.", "id": "cxtydiu"}, {"comment": "When benchmarking you actually want to compare implementations of languages. That's also why there's \"golang\" and \"gccgo\".", "id": "cxtyqn0"}], [{"comment": "Go and Swift use machine integers, whereas Rust uses `i64` on `fib` and `i32` on `bench1`. Use `isize` in Rust or `Int64` in others instead for fairness. Unfortunately there's no easy way to be as nice to Javascript, but that's its own damned fault.\n\nAlso, for parallelism in Rust just use threads. Rust's threads aren't scary like other language's threads, which is the whole point.", "id": "cxu009s"}], [{"comment": "I never really understand these sorts of tests because in the real world when you have to deliver solutions 9/10 you will have to factor in DB access/operations and possibly network latency.\n\nI've been coding for 27 years and never had a paying customer say 'O write me an app to compute the fibonacci sequence will you...' :)\n", "id": "cxty5cv"}, {"comment": "It's true but it doesn't make all else equal.  Browsers have to go out to the network a lot but we still write them in C++ instead of Ruby.", "id": "cxu2a1m"}, {"comment": "Probably because they have CPU intensive tasks as well as pretty low latency requirements for rendering.", "id": "cxu4fhj"}, {"comment": "In the real world we also would use iterative fib(n) implementation, like\n\n    a = 1\n    b = 1\n    for i in [2..n] {\n       c = b\n       b = a + b\n       a = c\n    }\n    return b", "id": "czcvisq"}], [{"comment": "[deleted]", "id": "cxtzlij"}, {"comment": "The point wasn't to recreate another one \"Benchmark game\" http://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=swift&lang2=rust", "id": "cxu1u9a"}, {"comment": "fib? [Seems like 2004](http://web.archive.org/web/20040623030236/http://shootout.alioth.debian.org/bench/fibo/).", "id": "cxuj5kq"}], [{"comment": "One of those is not like the others.", "id": "cxu1erd"}], [{"comment": "> Modern user-friendly typed languages\n\nSeeing that it includes JavaScript, whats your definition of \"typed language\". You mean languages with a type system?\n\n\n> mature, possible code sharing with frontend, it's JavaScript, functional features\n\nDefinition of \"mature\" too.\n\n\n> I didn't compare these languages to dynamic languages like ruby or python because there are already a lot of comparisons with them.\n\nThen why compare it with JavaScript?", "id": "cxu31ua"}], [{"comment": "I see you are using gnome-system-monitor to visualize CPU performance. Why not use CPU Graph which uses less system resources and allows you to rewind the timeline, ultimately making your visualization more accurate?\n\nhttp://www.getlazarus.org/apps/cpugraph/\n\n\n\n", "id": "cxtvndy"}, {"comment": "just clarify, I am not the author", "id": "cxtwizm"}], [{"comment": "Just as an FYI, not a debunking of the write up:\n\n> Golang: to enable all the cores, you have to put in your code runtime.GOMAXPROCS(num of cores you want to use)\n\nThis isn't true, you can set the environmental variable `GOMAXPROCS` for this - if anyone is looking for a nicer way to accomplish that :)", "id": "cxtw296"}, {"comment": "Also, I believe since Go 1.5 GOMAXPROCS is set to the number of CPUs available by default (previously it was set to 1 by default).", "id": "cxtweqo"}, {"comment": "I wonder what that does to you in a Docker container.", "id": "cxtx4ww"}, {"comment": "Nothing different. Applications running inside a docker container are just namespaced processes. GOMAXPROCS sets OS threads anyway rather than actual processes iirc. \n\nYou can run multiple processes in a container. The only \"special\" thing about the ENTRYPOINT process is that Docker will tear down the container when it exits. ", "id": "cxtxf16"}, {"comment": "Well, say you have 8 containers, each pinned to a core, on an 8 core machine. You thought you were getting 8 processes...", "id": "cxuylv9"}], [{"comment": "see also: https://www.reddit.com/r/linux/comments/3w2r74/go_vs_node_vs_rust_vs_swift_on_ubuntu_linux_1510/", "id": "cxtxwbw"}], [{"comment": "It's a mashup of _all_ the useless fashion statement programming languages! Anything to avoid actually programming, #yolo!\n", "id": "cxtwmn1"}, {"comment": "", "id": "cxtx82k"}, {"comment": "wait, they forgot haskell!", "id": "cxtxyfx"}, {"comment": "All of those are very much real-world programming languages, all seeing serious and professional use. They all stand a good chance of growing into large-scale use in the coming years.\n\nCalling them \"useless fashion statement programming languages\" is basically just ignorant.", "id": "cxtyiia"}, {"comment": "\"Large-scale use\" and \"useless fashion statement\" do not contradict.\n\nProgramming is a field that prides itself on ignorance, and it's usually the most ignorance-enabling tools that quickly achieve \"large-scale use\". (They also quickly fade, so all we have to do is wait 15 years or so until these \"serious and professional\" languages fade away.)\n\n\n", "id": "cxtykkz"}, {"comment": "You really haven't actually looked into what they offer, have you?", "id": "cxtymun"}, {"comment": "Use and useless do contradict.", "id": "cxtzaed"}, {"comment": "> Anything to avoid actually programming\n\nSo someone who uses one of these languages isn't *actually programming*?", "id": "cxu4ne6"}, {"comment": "Yes. Most programmers aren't actually programming. Oversight and planning in the software business is appalling, especially inside the large corporations.\n", "id": "cxuaems"}, {"comment": "And what does that have to do with Go, Swift, Rust, and JS? You're just ranting at this point because other people use and enjoy languages that you don't use and enjoy.", "id": "cxurrq6"}, {"comment": "Programming languages aren't meant to be 'enjoyed', dumbass. That was my whole point.\n\nWould you trust a carpenter that picks his tools because he 'enjoys' using them to build your house?\n", "id": "cxv4238"}, {"comment": "Hahahaha, oh man, you're a terrible troll.\n\n> use and enjoy\n\nIt's possible for someone to use a tool, be productive with it, and enjoy it simultaneously. I *would* trust a carpenter that enjoys using his tools, because he probably has a good reason for doing so.\n\nSo let's go back to my original question: \"someone who uses one of these languages isn't actually programming?\"\n\nThe engineers working on Servo at Mozilla aren't actually programming because they're using Rust? Google engineers aren't actually programming because they're using Go?\n\nYou must have a rough life every day when you approach things with that attitude.", "id": "cxv7buc"}, {"comment": "> It's possible for someone to use a tool, be productive with it, and enjoy it simultaneously. \n\nYou're right. Theoretically. Now scroll back through the comments on this page and try to find even one comment mentioning productivity.\n\nP.S. 'Productivity' is a red herring anyways. To go back to the construction analogy: I don't give two shits if the construction workers building my house are 'productive' or not. What I really want is a house built to spec.", "id": "cxv9n3w"}, {"comment": "Well okay, sorry that some people like discussing programming languages in a *programming* subreddit.\n\nI don't know what you want, but have fun being angry at the world for not behaving exactly how you want it to :)", "id": "cxvw3il"}]]], "4lfxus": ["Blocklist of all Facebook domains", "2016-05-28 18:07:58", 0, "https://github.com/jmdugan/blocklists/blob/master/corporations/facebook/all", [[15, "This isn't going to pan out the way you want. Many browsers will simply sidestep the system resolver libs if they don't get a reasonable answer.\n\nAlso, don't use 0.0.0.0. That's an actual valid IP address which actually has a meaning. Instead, use 127.0.0.1 or an address from the 169.254 range so the requesting host will either get a connection refused or a destination unreachable response.\n\nFinally, this has NOTHING to do with programming. Wrong sub entirely."], [6, "This isn't even nearly complete. Just for shits and giggles, I loaded up Facebook, chose a random domain I saw it load content from, and it wasn't on the list.\n\nscontent-mxp1-1.xx.fbcdn.net -- not found.\n\nAs others have said this list would be useless even if complete."], [3, "There's got to be a better way to do this than enumerate every single FQDN. Can't you run some sort of local DNS responder that matches a prefix (well, suffix I suppose) of a domain name in a request and decides to either blackhole it or pass it along to your \"real\" DNS server?"]], [[{"comment": "This isn't going to pan out the way you want. Many browsers will simply sidestep the system resolver libs if they don't get a reasonable answer.\n\nAlso, don't use 0.0.0.0. That's an actual valid IP address which actually has a meaning. Instead, use 127.0.0.1 or an address from the 169.254 range so the requesting host will either get a connection refused or a destination unreachable response.\n\nFinally, this has NOTHING to do with programming. Wrong sub entirely.", "id": "d3n2mxm"}, {"comment": "> Many browsers will simply sidestep the system resolver libs if they don't get a reasonable answer.\n\nProof?", "id": "d3ng283"}, {"comment": "Using `127.0.0.1` will be not-fun if you are running a local webserver ...", "id": "d3n4h2w"}, {"comment": "You'd get a 404 most likely. So, still getting the desired effect.", "id": "d3n5rg9"}, {"comment": "SSL certificate mismatch more likely.", "id": "d3n6c8c"}, {"comment": "Well, presuming you're running an SSL enabled server on your local host. Either way, modifying hosts file is one of the worst ways imaginable to accomplish this.", "id": "d3n6kxe"}, {"comment": "I'll bite: what is the best way of preventing a machine from doing any communication with Facebook or any Facebook-owned service? I do mean **any** communication: if Mark Zuckerburg is aware of the existence of the machine in question, the solution is not adequate.", "id": "d3pu71j"}, {"comment": "A far superior solution to attempting to poison DNS would be to have your border firewall block all traffic to and from Facebook's CIDR ranges. There are lots of ways to find those ranging from combing through RIR records to determining related announcements in BGP tables. Ultimately, I'd do both.\n\nI think you will find there is no 100% method at all, ever, except completely disconnecting from the internet or by having your own router and only allowing trusted BGP announcements to populate your tables and having a default drop rule.\n\nSince this is a programming sub, I think we're far off topic.", "id": "d3pwbr4"}], [{"comment": "This isn't even nearly complete. Just for shits and giggles, I loaded up Facebook, chose a random domain I saw it load content from, and it wasn't on the list.\n\nscontent-mxp1-1.xx.fbcdn.net -- not found.\n\nAs others have said this list would be useless even if complete.", "id": "d3n3e6p"}], [{"comment": "There's got to be a better way to do this than enumerate every single FQDN. Can't you run some sort of local DNS responder that matches a prefix (well, suffix I suppose) of a domain name in a request and decides to either blackhole it or pass it along to your \"real\" DNS server?", "id": "d3n1ru2"}, {"comment": "DNS RPZ", "id": "d3n2gi3"}]]], "4jasfh": ["Onyx - pragmatic, get-shit-done, beautiful, fast & stable programming", "2016-05-14 13:30:52", 1, "https://github.com/ozra/onyx-lang#onyx---pragmatic-get-shit-done-beautiful-fast--stable-programming", [[9, "> Inheritance (single! - no deadly diamond of death dilemma)\n\nhttp://blog.cleancoder.com/uncle-bob/2015/01/08/InterfaceConsideredHarmful.html\n\n> Hmmm. I wonder why? Have other compiler writers solved this problem?\n>> Well, C++ allows you to create diamonds.\n\n> Yes, and I think Eiffel does to.\n>> And, gosh, I think Ruby figured out a way to do it.\n\n> Yes, and so did CLOS and -- well, let's just say that the deadly diamond of death is a problem that was solved decades ago and it isn't deadly, and does not lead to death."], [3, "[deleted]"], [3, "\"near C/C++ speeds\". \"garbage collection\". Either one of those is wrong or you are doing something very novel and damn impressive. Considering you didn't mention your revolutionary new GC design, I am guessing you don't actually have near C/C++ speeds on most real programs."], [2, "I hate when people say that a language is understandable when what they really mean is that they understand it. For all this promises, I fail to see how it delievers. Is there any basis for aaying that it runs at \"near C/C++ speeds\"?"], [1, "Python is already pragmatic , beautiful and stable. Just make it fast for us please ;)"]], [[{"comment": "> Inheritance (single! - no deadly diamond of death dilemma)\n\nhttp://blog.cleancoder.com/uncle-bob/2015/01/08/InterfaceConsideredHarmful.html\n\n> Hmmm. I wonder why? Have other compiler writers solved this problem?\n>> Well, C++ allows you to create diamonds.\n\n> Yes, and I think Eiffel does to.\n>> And, gosh, I think Ruby figured out a way to do it.\n\n> Yes, and so did CLOS and -- well, let's just say that the deadly diamond of death is a problem that was solved decades ago and it isn't deadly, and does not lead to death.", "id": "d353o29"}, {"comment": "I am pleased and surprised to find another MI apologist in the wild.\n\nMI shouldn't be avoided just because C++ did it wrong. Besides, with MI you get mixins for free without having to introduce another language construct.", "id": "d354tlo"}, {"comment": "MI works perfectly fine in C++.", "id": "d355stu"}, {"comment": "C++ mixins, as in \"template<class T>class Mixin : public T { ... }\", are only \"free\" if the time you waste waiting for the C++ compiler is worth nothing.", "id": "d358mt9"}, {"comment": "Is your argument that because C++ implementations compile something slowly, that it's univerally a bad thing in programming languages?\n\nC++ compiles a lot of things slowly.", "id": "d35pl23"}], [{"comment": "[deleted]", "id": "d356y5w"}, {"comment": "Crystal doesn't run on Windows because the Windows API is not posix, and the exception handling is completely different. Compiling to C instead of LLVM wouldn't make a difference. It's just a matter of time until we support Windows, not the backend choice. ", "id": "d357fct"}, {"comment": "[deleted]", "id": "d3573kn"}, {"comment": "It's not dynamically typed ", "id": "d357g9h"}], [{"comment": "\"near C/C++ speeds\". \"garbage collection\". Either one of those is wrong or you are doing something very novel and damn impressive. Considering you didn't mention your revolutionary new GC design, I am guessing you don't actually have near C/C++ speeds on most real programs.", "id": "d35usjv"}], [{"comment": "I hate when people say that a language is understandable when what they really mean is that they understand it. For all this promises, I fail to see how it delievers. Is there any basis for aaying that it runs at \"near C/C++ speeds\"?", "id": "d355kpd"}], [{"comment": "Python is already pragmatic , beautiful and stable. Just make it fast for us please ;)", "id": "d356zot"}]]], "43bxd0": ["The Top 10 Things Wrong with JavaScript", "2016-01-30 04:12:20", 3, "https://medium.com/@richardeng/the-top-10-things-wrong-with-javascript-58f440d6b3d8", [[18, "I agree with the points, but this horse is a protein paste at this point."], [5, "JavaScript is not that bad if you avoid working on edge cases and keep your code organized. The opinionated view of programmers that follow fashion instead of reason is the thing that causes most harm."], [4, "`#1`, `#2`, `#3`, `#5` and `#6` make sense. Not the other ones.\n\nParticularly #4: that's not JS fault's, and to be honest, in the last couple of years the coding style has improved a lot. Specially in the backend. There are a lot of smart guys working with JS."], [3, "I've seen lots of JavaScript bashing, but I've never seen this before:\n\n    $ node\n    > xs = [\"10\", \"10\", \"10\"];\n    xs = [\"10\", \"10\", \"10\"];\n    [ '10', '10', '10' ]\n    > xs.map(parseInt)\n    [ 10, NaN, 2 ]\n\nWhat the heck is actually happening here?\n\nedit: Ah. `parseInt` can take two parameters, and `map` provides three.\n\nSo you get:\n\n    var xs = [\"10\", \"10\", \"10\"];\n    var result = [];\n    for (var i = 0; i < 3; i++)\n        result.push(parseInt(xs[i], i, xs));\n\nwhere `parseInt` simply ignores the third argument."], [2, "JavaScript seems like it was made to be a small, simple language. It has exploded considerably though, and some libraries add 20,000+ LOC to the project"], [3, "Mostly the same old js stuff we've seen on this sub a dozen times already. Nothing new. The last paragraph is kind of absurd though.\n\n> However, [JSLint] has major limitations. It\u2019s also highly opinionated. \n\nJSLint kinda had this problem. The JSHint fork does a better job on some of the more \"judgement call\" stuff. If JSHint gave you an error it's much more likely that you done goofed\n\n> Moreover, it\u2019s difficult to incorporate into your workflow\n\nHahahah **what**? You can integrate JSHint with vim so it'll open up errors in a quickfix view. I'm sure Emacs has a similar integration. Atom will pull linting errors straight into the editor. And shit, if you're just some hardcore haxxor using Notepad you can leave JSHint running as watch task and it'll spit out your fuckups in a terminal window. I guess if you're constantly tabbing out and running the jshint command by hand that'd be annoying... but after a couple times of doing that how could you *not* google a way to integrate it with your editor of choice? Ah right... you had to run to medium and publish another recycled article.\n\n>  JavaScript apologists frequently tout using JSLint as a universal solution to JavaScript\u2019s problems. ...*snip*... which is why many JavaScript developers do not use it.\n\nNo... it's not \"apologists\" touting JSHint/Lint as a way to get around javascript's shortcomings. It's touted by developers who have found a way to mitigate some of javascript's inherent awfulness. It's a tool that helps keep you from doing stupid shit. And what the hell is \"many javascript developers do not use it\"? I haven't seen a frontend codebase *without* a linter (or compiler in the case of typescript) in **years**. I'm sure those codebases are out there... and I'm sure they're an extra special brand of awful.\n\n> And finally, JSLint\u2019s output results are subject to interpretation and you need to decide what to do about them; \n\nOh no! My tool gave me an error and now I have to **think** about what to do about it? The cognitive burden of doing a strong type check!  For fucks sake... if you're going to spend 10 bullet points bemoaning javascript being a tricky language, to turn around piss and moan about one of the better tools for helping ease that burden is just stupid.\n"], [3, "Many mistake their familiarity with Javascript with it being a good language.\n\nThen I talk about Python.\n\nHaving said that - if you want to code for the browser, Javascript is the only game in town."], [1, "The worst thing wrong with JS is that your application, I mean, your web browser, doesn't crash. Your JS code is free to stomp on data, engage in good quantities of fuckery, and generally get itself into all sorts of trouble that can be avoided by using better languages. JS itself would be so much better off if the browser would just crash, because then people might be forced to write reliable code... except that the constant crashes would necessarily expose most JS 'applications' for what they truly are."], [1, "what's the objection to the type of NaN being the same as the type for 0.1. I think that's the point of IEEE NaN--so that every floating point operation can be closed over the floats."], [2, "Mr. Richard Eng,\n\nInstead of bitching how awful Javascript is you might as well start learn it, because you're obvious clueless and/or ill-intentioned. Nobody is forcing you to use JS, so go write code and make $illions using your perfect language ... "], [1, "any criticism of javascript should start and stop at inconsistent semantics, you don't need a second point, it's already failed at the most important thing."], [-1, "This article is just stupid clickbait. \"People have written lots of bad code.\" Right, that's a problem with the language."], [-1, "Just to nitpick since this comes up often:\n\n    [] + [] \u2192 \"\"\n\nThis is reasonable as far as I am concerned.\n\nThe + is exclusively for addition and string concatenation. Just because the language does something different than other languages doesn't make it wrong (no one complains about this in Lua). For joins, there's the concat() method."], [-1, "such a wimpy kid, did't your mommy tell you you gotta man up one day?"]], [[{"comment": "I agree with the points, but this horse is a protein paste at this point.", "id": "czh536e"}, {"comment": "Some of the younger ones don't know yet. JS is the first language they learn and they don't understand what the problems are as it's the only thing they know.", "id": "czh5qj3"}], [{"comment": "JavaScript is not that bad if you avoid working on edge cases and keep your code organized. The opinionated view of programmers that follow fashion instead of reason is the thing that causes most harm.", "id": "czh77hw"}, {"comment": "Come on. There is a book telling you which of the handful of language features are considered good and which to avoid. In most other languages the things to avoid are either deprecated libraries, undefined behavior, or are universal to that languages paradigm.\n\nA newbie can easily get into a big mess unless they are taught a whole list of the **Proper Ways to Do Things in Javascript\u2122**.", "id": "czhf8an"}, {"comment": "Apparently, a lot of JavaScript developers are not reading the book you refer to. They are still writing terrible JS code. Perhaps it is a question of poor education or lack of proper instruction, as you intimate. Nevertheless, JavaScript makes it very easy for people to write bad code, a phenomenon you don't find in other languages such as Java, Python, C#, Ruby, etc. Yes, bad code is written in every language, but not to the same extent.", "id": "czi37hv"}, {"comment": "But it still isn't very good. And I've got better things to do thenfighting with the language to get things done and keep them maintanable, so I'm switching to dart on frontend and definitely not letting js into the backend.", "id": "czhf9st"}], [{"comment": "`#1`, `#2`, `#3`, `#5` and `#6` make sense. Not the other ones.\n\nParticularly #4: that's not JS fault's, and to be honest, in the last couple of years the coding style has improved a lot. Specially in the backend. There are a lot of smart guys working with JS.", "id": "czhewut"}, {"comment": "Give me a fucking break (not you, the author).\n\n>3) Automatic semicolon insertion. This can cause subtle bugs and unexpected behaviour. Why does this \u201cfeature\u201d even exist??? It\u2019s super weird and unnecessary. Get rid of it, ECMA, please!\n\nES6, strict mode.\n\n>5) JavaScript is highly dependent on global variables. Implied global variables are especially problematic (\u201cuse strict\u201d to avoid). Global variables seriously complicate your programs.\n\nSo 20 years ago someone made a mistake by allowing global variables. You don't have to use them. Also, it's not \"highly dependent\" on global variables as strict mode proves, just like the author says.\n\n>6) JavaScript code can fail silently due to syntactical slip-ups. It has happened to me several times, and tracking down the reason can be most exasperating.\n\nHow about learning the syntax and using a good IDE and linter? FYI, those things exist.\n\n>7) Prototype objects do not scale well to large applications;\n\nWhat?\n\n>it\u2019s a rather primitive\n\nWhat?\n\n>and sloppy way to do object-oriented programming\n\nWhat?\n\n>Further, there are multiple ways to handle object inheritance, making it difficult to decide which way to go.\n\nWhat?\n\n>JavaScript is the only popular OOP language that uses prototype objects.\n\nSo?\n\n>The preference for class-based OOP is clear, such that ES6 and TypeScript employ classes.\n\nThat's because \"programmers\" (notice the quotes, please) like you are using it wrong and then they claim it's the language's fault. How about not using classes in a class-less language?\n\n>And because the use of prototype objects is so poorly understood by most JavaScript developers, they abuse the language and write horrible code as a result.\n\nThat's because \"programmers\" (notice the quotes, please) like you are using it wrong and then they claim it's the language's fault.\n\n>8) Asynchronous programming in JavaScript is very messy. Callback hell is a frequent complaint. (Promises mitigate this to some extent, but are not a perfect solution.)\n\nThere is no perfect solution.\n\n>10) The main draw of JavaScript is actually in frameworks like Node.js and AngularJS.\n\nHoly fuck! Dear author, please use Lisp or Clojure.\n\netc. etc. etc. There are some good points (eg, integer types), but 90% of this article is bullshit.\n\n**tl;dr** Omg, I don't understand JavaScript, therefore it sucks.", "id": "czhj43m"}, {"comment": "As surely as the sun rises in the East, there will be many JavaScript developers who do not use strict mode. Strict mode is recommended, but it's not enforced. The fault of JavaScript lies in the fact that there isn't a single, standard language \"mode\" that everyone is required to code in. JavaScript's sloppiness encourages poor coding in a way that you don't see in other languages. Yes, bad code is written by bad programmers in every language, but not to the extent that JavaScript suffers from. In my 30+ years in IT, I've programmed in FORTRAN, C, C++, C#, Objective-C, Java, Python, Smalltalk, and Go, and I have very seldom heard this criticism leveled at these languages. Do a Google search to find how often JavaScript is lambasted for the vast body of badly written code that exists in popular libraries, frameworks and code bases. Then do the same Google search for other languages. Do your homework and you shall see what I mean.\n\nPerhaps I don't fully understand JavaScript. Nevertheless, it should not be this hard to write good code, or at least respectable code. In no other language am I tripped up so easily, and you can blame the documentation or the lack of proper instruction, but JavaScript's sloppy design surely has to assume some of the responsibility. The point is, it does take special care to use JavaScript properly, and the question is, *why bother?* Because JS is conveniently available in all web browsers? This is a valid reason?\n\nThere are better languages that do not have these problems.", "id": "czi1c2u"}, {"comment": ">JavaScript's sloppiness encourages poor coding in a way that you don't see in other languages.\n\nI fully agree with this. My point was that it wasn't necessary to split this single issue (regardless of how big it is) in a list of \"top 10 ways I could shoot myself in the foot\" and then blame all those items separately on the language.\n\n>I have very seldom heard this criticism leveled at these languages\n\nThat's probably because you're spending a lot of time in professional circles that don't waste time making fun of them. I mean... C? Seriously? The lack of garbage collection lead to probably 99% of the security vulnerabilities that caused tons of issues for lots of people (money lost, identities stolen, etc). You wanna bash a language by how the programmers use it? Okay, let's do this! Let's talk about \"real programmers\", the ones that code critical systems and let's see how many decades it took to stabilize them and remove buffer overflows from the Linux kernel and from drivers and the tens of thousands of programs that have been exploited because of the ~~programmers' stupidity~~ language.\n\nI mean... bro... get real... https://stackoverflow.com/questions/14273252/why-can-i-cast-int-and-bool-to-void-but-not-float At least JavaScript doesn't let you do shit like this: `void* u = (void*)(((unsigned short*)(&x))[0] | (((unsigned int)((unsigned short*)(&x))[1]) << 16));`\n\nAbstractJavaSingletonInstanceFactory? Seriously? You don't see a problem with the extreme levels of abstraction ~~done by Java progammers~~ in Java? It takes for-fucking-ever to build anything decent using Java. You need a fucking *class* and a *method* to do anything. A programmer needs an insane amount of knowledge to *understand* something as simple as Hello World.\n\nPython? Which one? v2 or v3? Because they're pretty much the same but not really. I mean the syntax is very similar and it's almost like v2 code should run in v3 without issues. Except it's not the case. I could go on and talk about libraries and cross-platform issues, but I won't, because I stopped learning Python as soon as I ran into that shit.\n\n>it should not be this hard to write good code, or at least respectable code\n\nIt's not hard at all. The problem is that lots of people who entered the software job market started by duct taping together some HTML and CSS with JavaScript and called it a day and employers who didn't know better put those monstrosities in production. JS happened to come at a time and in a place where there was a surge in the need for software developers, so everyone who had a keyboard started using it.\n\nThe most recent problem in JS is that a bunch of programmers manage to duct tape libraries together and create some really cool things and then they begin to teach others how to do things, but they don't really know what they're doing and they keep spreading bad practices, and the newbies take their advice to heart. If someone does some pretty cool 3D visualizations they obviously understand the intricacies of prototype inheritance, right? /s And those are the same programmers who pushed for JS to emulate class inheritance... I mean HO-LY SHIT! In 5-10 years people are going to laugh at JS (ES6+) for that. Mark my words!\n\n####Oh, hey, talk about sloppy coding, **CHROME JUST CRASHED** because my Internet went down. Look at all I wrote above. I would have lost all that if I didn't have Lazarus installed. Chrome crashed with no warnings, no complaints, no nothing... It just disappeared as if I pressed Alt+F4 while I didn't have my hands on the keyboard.\n\nYou wanna talk about a really shitty programming language? Pick on PHP. Just take a look at /r/lolphp to see real WTFs in a programming language.\n\n=\n\nThere are things that are inherently very bad in JavaScript. Let's see the first few that pop up in my mind:\n\n- automatic semicolon\n\n- lack of real types\n\n- interaction with the DOM (if we're talking JS and not ES)\n\n- automatic globals\n\n- `var` scope\n\n- difficult inline function calls (the need for hacks like `!function(){..}()` or `(function(){..})()`)\n\n- hanging expressions (like in C, you can just say `5;` and it's a perfectly valid statement, something you can't do in **Pascal**)\n\n- `eval()` exists\n\nAnd I'm too lazy to think of more. A lot of these are shared with other languages, but for some reason you don't hear \"professional\" programmers complain about them. Here's some Python bullshit:\n\n    def foo():\n        def bar():\n            print x\n        bar()\n        x=2\n        bar()\n    \n    foo()\n\nWhat does the above code do? (don't cheat, answer without running it) What if you add a line `x=1` before the `def foo()`? What if you move that line between the `def`s? What if you accidentally indent the first call to `bar()`? IMHO programming languages that use white space as part of their syntax (like Python and Ruby) are the worst offenders when it comes to sloppiness. The \"you don't have to think about writing the beginning and end of blocks\" is one of the biggest bullshits in the history of programming languages. You miss *one space* and you're fucked. I find it tiresome to read Python code because my eyes hurt when I start focusing on the fucking *indentation*. Oh, here's another thought, what if you say `x=5` inside `bar()`? *This* (variable scoping) is what I believe to be a serious problem in programming languages like Python or JS.\n\nYes, there are reasons to shit on JS just like there are reasons to shit on C, C++, Python and probably all other programming languages out there but I believe that PHP is the only widely used programming language that deserves its bad reputation.\n\nPS: The fact that the author of the article talks about the AngularJS and Node.js frameworks [sic] like that shows that they don't know enough about JS for their opinion to be given any public attention. I mean FFS, they don't even know the difference between a framework and an environment. If you want to have a serious conversation about the bad parts in JavaScript, I'm definitely open to it, there are things - like those I listed above - that are inherently bad about the language, but at least form your opinion after you talk about JS with someone who actually knows and understands JS. I see the mistakes beginners do, I see the mistakes beginner self-proclaimed \"professionals\" do, I remember the mistakes I did, and I know which were caused solely by stupidity and which were partly (or mostly) caused because of the language.\n\nPPS: ^(I know this comment is sloppy writing - since we're talking about sloppy - but it's 3 AM where I live and I'm so tired that I can't even write proper English. You wanna bash JS? Just give me the go-ahead and I'll do it for you and then I'll let you be the judge so you can decide for yourself whether the issues are big enough to point the finger at JS! At least you won't just take the opinions of someone who doesn't know what a framework is for granted.)\n", "id": "czi486o"}, {"comment": "Re: your PS...\n\nOf course, I know the difference between a framework and an environment. I wasn't using the word \"framework\" in the exact sense you're thinking of. This is a literary article I wrote and I exercised a small amount of literary licence. Nevertheless, Node.js' own website says in their About page:\n\n> As an asynchronous event driven **framework**, Node.js is designed to build scalable network applications. In the following \"hello world\" example, many connections can be handled concurrently. Upon each connection the callback is fired, but if there is no work to be done Node is sleeping.\n\nSo, you see? There's no need to be anal about my use of vocabulary.", "id": "czi50u1"}, {"comment": "I see your point, but that's just terrible of them! It does provide a framework, but it's an environment regardless of what they call it.\n\nUnrelated: Am I correct in assuming you've seen the \"wat\" video?", "id": "czi5909"}, {"comment": "Indeed, I have. Here's another *very entertaining* video I highly recommend: https://www.youtube.com/watch?v=D5xh0ZIEUOE", "id": "czi5d26"}], [{"comment": "I've seen lots of JavaScript bashing, but I've never seen this before:\n\n    $ node\n    > xs = [\"10\", \"10\", \"10\"];\n    xs = [\"10\", \"10\", \"10\"];\n    [ '10', '10', '10' ]\n    > xs.map(parseInt)\n    [ 10, NaN, 2 ]\n\nWhat the heck is actually happening here?\n\nedit: Ah. `parseInt` can take two parameters, and `map` provides three.\n\nSo you get:\n\n    var xs = [\"10\", \"10\", \"10\"];\n    var result = [];\n    for (var i = 0; i < 3; i++)\n        result.push(parseInt(xs[i], i, xs));\n\nwhere `parseInt` simply ignores the third argument.", "id": "czhdzgr"}, {"comment": "Man thanks! I was wondering what was happening there.\n\nMaybe the proper way is wrapping `parseInt` in a function?\n\n    > xs = [\"10\", \"10\", \"10\"];\n    [ '10', '10', '10' ]\n    > xs.map(function (i) { return parseInt(i); });\n    [ 10, 10, 10 ]\n\nWhich is an anti-intuitive `map` behavior to me.", "id": "czhexhb"}, {"comment": "Yeah, I guess it's more of an unfortunate way that function arguments work in JavaScript than anything, ie free-for-all.\n\nThis is just one more screw-up-waiting-to-happen to be aware of when using JavaScript, there are plenty of them. Still quite fond of the language however.\n\nOne of my favourites being:\n\n    function fn() {\n        return \n            { one: \"one\" };\n    }\n\n    fn() === undefined;", "id": "czhhjuz"}, {"comment": "Really? Why?!", "id": "czhiatx"}, {"comment": "Semicolon insertion. The \"return\" on its own line becomes *return;* and the next line is a effect-less object declaration. Jslint catches this, of course. ", "id": "czhldm6"}, {"comment": "Ooh I didn't even see that! Thank you for the explanation!", "id": "czhpkyo"}, {"comment": "Well the correct way would be to use Number or parseFloat. The author clearly dont know how JavaScript works, hence the ranty blogpost.\n\n    xs = [\"10\", \"10\", \"10\"];\n    xs.map(Number); // -> [ 10, 10, 10 ]\n    xs.map(parseFloat); // -> [ 10, 10, 10 ]", "id": "czhl4jd"}, {"comment": "Yes he clearly didn't memorize all the ways in which js is broken. Map and parseint in nearly every other language dont set such traps.", "id": "czhr9h0"}, {"comment": "Well, its right there in the function docs. The Array.map callback gets three args: current, index and the array. And parseInt takes two params: the string and its radix. So the author is basically doing this:\n\n    parseInt(\"10\", 0); // -> 10\n    parseInt(\"10\", 1); // -> NaN\n    parseInt(\"10\", 2); // -> 2\n\nSo either write a helper function:\n\n    const toNum = (parse) => parseInt(parse, 10)\n    xs.map(toNum) // -> [ 10, 10, 10 ]\n\nOr then learn the correct way.\n", "id": "czhwfyx"}, {"comment": "Thanks for explaining it, that totally would have tripped me up (if I ever remembered to actually use map).", "id": "czi5vgs"}, {"comment": "No problem. Actually i find map (and the other array methods added in es5) very usefull, and i use it almost daily. I would recommend you try it out the next time you find yourself writing a for loop. I havent used a oldschool for loop in years, its all map, filter and reduce. It translates well between diffrent languages and makes your code more clean and functional.", "id": "czicps6"}, {"comment": "> xs.map(parseInt)\n\nTry\n\n    xs.map(Number)\n", "id": "czhqvbh"}], [{"comment": "JavaScript seems like it was made to be a small, simple language. It has exploded considerably though, and some libraries add 20,000+ LOC to the project", "id": "czh603m"}, {"comment": "*cough node.js *cough", "id": "czh6e4o"}, {"comment": "\"Well fellas, we code with a shit language on the front end - why not code with the same shit language on the backend?!\"\n\n", "id": "czhg03w"}, {"comment": "\"Small, simple languages\" have no problem with growing. Poorly designed ones do.", "id": "czhfaaa"}], [{"comment": "Mostly the same old js stuff we've seen on this sub a dozen times already. Nothing new. The last paragraph is kind of absurd though.\n\n> However, [JSLint] has major limitations. It\u2019s also highly opinionated. \n\nJSLint kinda had this problem. The JSHint fork does a better job on some of the more \"judgement call\" stuff. If JSHint gave you an error it's much more likely that you done goofed\n\n> Moreover, it\u2019s difficult to incorporate into your workflow\n\nHahahah **what**? You can integrate JSHint with vim so it'll open up errors in a quickfix view. I'm sure Emacs has a similar integration. Atom will pull linting errors straight into the editor. And shit, if you're just some hardcore haxxor using Notepad you can leave JSHint running as watch task and it'll spit out your fuckups in a terminal window. I guess if you're constantly tabbing out and running the jshint command by hand that'd be annoying... but after a couple times of doing that how could you *not* google a way to integrate it with your editor of choice? Ah right... you had to run to medium and publish another recycled article.\n\n>  JavaScript apologists frequently tout using JSLint as a universal solution to JavaScript\u2019s problems. ...*snip*... which is why many JavaScript developers do not use it.\n\nNo... it's not \"apologists\" touting JSHint/Lint as a way to get around javascript's shortcomings. It's touted by developers who have found a way to mitigate some of javascript's inherent awfulness. It's a tool that helps keep you from doing stupid shit. And what the hell is \"many javascript developers do not use it\"? I haven't seen a frontend codebase *without* a linter (or compiler in the case of typescript) in **years**. I'm sure those codebases are out there... and I'm sure they're an extra special brand of awful.\n\n> And finally, JSLint\u2019s output results are subject to interpretation and you need to decide what to do about them; \n\nOh no! My tool gave me an error and now I have to **think** about what to do about it? The cognitive burden of doing a strong type check!  For fucks sake... if you're going to spend 10 bullet points bemoaning javascript being a tricky language, to turn around piss and moan about one of the better tools for helping ease that burden is just stupid.\n", "id": "czh9z4n"}, {"comment": "JSLint/JSHint do help ease the burden. They don't solve all the problems, especially JavaScript's awful, inconsistent semantics. **These tools mitigate, but do not eliminate, all of JS's problems.**\n\nBut ultimately, the question has to be asked: *Why bother with JavaScript at all?* Just because it's conveniently available in all web browsers? There are many *better* alternatives that transpile to JS. I ended my article asking, \"Is it too much to ask for a programming language that doesn\u2019t have such horrendous problems that I need a tool to help me avoid them?\" Think upon this question seriously.", "id": "czi2uvn"}], [{"comment": "Many mistake their familiarity with Javascript with it being a good language.\n\nThen I talk about Python.\n\nHaving said that - if you want to code for the browser, Javascript is the only game in town.", "id": "czhfzt9"}, {"comment": "See dart. It removes all js insanity. And there are many other languages that compile to js.", "id": "czhrcpn"}, {"comment": "I will check it out", "id": "czhyqg3"}], [{"comment": "The worst thing wrong with JS is that your application, I mean, your web browser, doesn't crash. Your JS code is free to stomp on data, engage in good quantities of fuckery, and generally get itself into all sorts of trouble that can be avoided by using better languages. JS itself would be so much better off if the browser would just crash, because then people might be forced to write reliable code... except that the constant crashes would necessarily expose most JS 'applications' for what they truly are.", "id": "czh6oxy"}, {"comment": "what the fuck are you talking about? it does crash (try throw together with try/catch) window.onerror is the last line of defense ", "id": "czhgvxg"}, {"comment": "I can't agree more.", "id": "czhfcpb"}], [{"comment": "what's the objection to the type of NaN being the same as the type for 0.1. I think that's the point of IEEE NaN--so that every floating point operation can be closed over the floats.", "id": "czh98mk"}, {"comment": "`NaN` *has to be* a number; that's kind-of the whole point. It's a number in terms of its intrinsic type, but it's the distinguished value for malformed bit patterns. It's all in the IEEE spec.", "id": "czh9yui"}, {"comment": "It's just a bit of stupid word-play that got used in one of a hundred \"JavaScript sucks\" presentations, and people keep recycling it. NaN stands for \"Not a Number\", and then when you ask JavaScript what its type is, you get \"Number\", even though it's Not a Number. Hilarious!", "id": "czhljlq"}, {"comment": "but... like every language that uses IEEE floats wil--never mind.", "id": "czm7z30"}], [{"comment": "Mr. Richard Eng,\n\nInstead of bitching how awful Javascript is you might as well start learn it, because you're obvious clueless and/or ill-intentioned. Nobody is forcing you to use JS, so go write code and make $illions using your perfect language ... ", "id": "czhf8rn"}], [{"comment": "any criticism of javascript should start and stop at inconsistent semantics, you don't need a second point, it's already failed at the most important thing.", "id": "czhrted"}, {"comment": "Thank you!!! My sentiments exactly.", "id": "czhyawc"}], [{"comment": "This article is just stupid clickbait. \"People have written lots of bad code.\" Right, that's a problem with the language.", "id": "czh9xvb"}], [{"comment": "Just to nitpick since this comes up often:\n\n    [] + [] \u2192 \"\"\n\nThis is reasonable as far as I am concerned.\n\nThe + is exclusively for addition and string concatenation. Just because the language does something different than other languages doesn't make it wrong (no one complains about this in Lua). For joins, there's the concat() method.", "id": "czhbr1c"}, {"comment": "I don't like it because there's no reason for its existence. Even without getting into why weak typing sucks, what's the benefit? In what situation will I, as a developer, would want [] + [] to equal an empty string? I would much rather it throw an error, because 99% of the time that's not what I want to happen. ", "id": "czhdgim"}, {"comment": "> would much rather it throw an error, because 99% of the time that's not what I want to happen.\n\nIs it really? Probably 100% of the time if I add an empty list to an empty list I'd want to get an empty list back. \u2205 \u222a \u2205 = \u2205. Holds up mathematically if we say [a] + [x] == [a, x] is correct, and holds up given how often I've wanted to collect some things from n different places and getting a total of 0 elements was entirely possible.", "id": "czhmxmv"}, {"comment": "Hindsight is 20/20. JS was quickly developed to basically just do form validation and dynamically write out web pages, which is mostly about dealing with numbers and strings. As such the coercion and operator rules were very basic and its focus was on its initial intended domain, not other things that seem like common sense in other domains.", "id": "czhpt60"}, {"comment": "> JS was quickly developed to basically just do form validation and dynamically write out web pages... As such the coercion and operator rules were very basic and its focus was on its initial intended domain, not other things that seem like common sense in other domains.\n\n**Exactly!!!** We now understand the historical reasons for JavaScript's sloppy design. By and large, the problems with its design will not be eliminated by ECMA's strict mode and ECMA slapping on new features, unless you can enforce strict mode and require everyone to code to the new \"standard.\" And what about the vast code base that currently exists in the wild (in libraries and frameworks) that do not conform to the standard? People still have to use them, *interface* with them, *reason* about their logic, and sometimes **debug** them! (Unfortunately, this is our reality if we want to benefit from JS's ecosystem.)", "id": "czi2ft7"}, {"comment": "Indeed, the existing code is the real reason that we need to keep JS around for a good long time. Otherwise, we're finally poised to move to WebAssembly, which should slowly move us out of this deadzone. It will take a while, and we'll need compile-to-JS to fill in the gaps until WA grows enough to handle managed-memory languages, but at least the browser vendors are all finally on the same page. Frankly it's surprising that JS has held together as long as it has.", "id": "czi3fxr"}, {"comment": "It doesn't make sense at all. Even if you'd shoehorn \"+\" to be an append operation on arrays (e.g. [].append([])) it would result in an empty array. Empty string is just WTF!?", "id": "czhiekj"}, {"comment": "It should be quite obvious what's going on if you use your brain: you're getting a string back, so clearly it tried to stringify both arguments and concatenate them. What else would an empty array be as a string, but the empty string?\n\nTL;DR, in a language with type-coercion, you need to learn its type coercion rules. Otherwise you're only showing your ignorance and unwillingness to learn your tools, whether they're crap or not.", "id": "czhp4hb"}, {"comment": "An array should be an array and not a string unless I tell it to be a string. Period.", "id": "czhvgne"}, {"comment": "I'm glad we agree, but JS's type coercion does not. Yet there is no mystery behind what it does, once you take a few seconds to learn how JS works, or even just infer backwards from the results. It \"makes sense\", just not the sense we would prefer.", "id": "czhwf8i"}, {"comment": "The \"sense we would prefer\" is the sense we have come to develop and internalize from years of using other, more sensible languages. You're quite right, JavaScript is the odd man out, but why is this? Why should this be so?\n\nWhat justification is there for having a language that doesn't work the same way as Java, C#, Python, C, etc.?\n\nWhen you look at JS's language specs in detail, you may come to understand the historical reasons for why it is the way it is. However, this does not excuse the language's awful semantics and quirky syntax. Knowing how it's supposed to work is not a rationale for using such an objectionable language. Especially when better alternatives are available to you.", "id": "czi1xui"}, {"comment": ">What justification is there for having a language that doesn't work the same way as Java, C#, Python, C, etc.?\n\nBack when it was created, it was supposed to be a simple form validation language. And it had to work on the web of its time, on the web devices of its time, and keep the barrier to use as low as possible. If they knew what it would be today, I doubt they would have gone the route they did. If Microsoft had not ignored the web and their own browser for so long, then JS might have also evolved a bit more quickly. It's a giant mess born of a giant mess.", "id": "czi3311"}, {"comment": "**Exactly!!!** You're practically writing my response for me!\n\nDespite the historical reasons, the fact remains that JavaScript is an awful language with terrible semantics and poorly conceived syntax. The entire point of my article is rooted in one question: *Why bother with JavaScript at all?* Especially when better alternatives are available. Because JS is conveniently available in web browsers? This is a good reason?", "id": "czi3s0r"}, {"comment": ">Because JS is conveniently available in web browsers?\n\nPrecisely. Sometimes you just don't have a big enough project to justify over-complicating things by using a compiled-to-JS language (this is soon to be an even murkier decision with ES6 just around the corner).\n\nThat and you have administrative factors to consider. Will it be easier to find a good JS coder to maintain your project, or a good coder in your niche language of choice? Can you even find 5 skilled TypeScript devs in your area for a large project, or will you have to re-train them so they know how to write good TypeScript anyhow?\n\nThere's a lot to think about once you stop simply focusing on how bad the language seems.", "id": "czi5mtx"}, {"comment": "In any application domain other than front-end web development, there are better languages with plenty of good coders to choose from. In the back-end server side, there are great languages like Java, Python, C#, Ruby, Scala and Go; **no need to use JS and Node at all**. In the mobile space, you have Java, Objective-C, Swift and, in the near future, probably Go. In the gaming space, you can choose from C++, C, C# or Lua, or even the mobile programming languages. JS brings very little to the table.\n\nIn front-end development, you can find plenty of coders who know the other mainstream languages I listed. It's a very small hurdle to switch to the transpiled versions. \"Administratively\" speaking, retraining to use TypeScript or Dart or Go has to be better than using a brain-dead language like JS. It makes better economic sense to *invest* in your company's future, rather than taking the \"easy\" way out with JS.", "id": "czioevl"}], [{"comment": "such a wimpy kid, did't your mommy tell you you gotta man up one day?", "id": "czhgwuv"}]]], "4vjb36": ["Fembot: A naive AI I wrote for a simple card game", "2016-08-01 02:08:39", 1, "https://rbryan.github.io/posts/fembot-a-naive-ai-for-the-game-of-femto.html", [[19, "Oh god, the name."], [4, "Write a post on how the thing actually works, give me diagrams, ELI5, all that. All I got out of this is \"someone made an AI that plays a game\". All I know about its working is \"it simulates lots and picks the best option\". I wanna know how you structure all that data, i want to know about run time, I want to know about the failed steps along the way and how you fixed the failures.\n\nI learned nothing from this. :("], [1, "I'd almost think because of the (seemingly) simple mechanics of the game, it could be mathematically solved. "]], [[{"comment": "Oh god, the name.", "id": "d5z76lk"}, {"comment": "Be honest, is it that bad?", "id": "d5z9j5s"}, {"comment": "\"Fembot\"? Yes, that bad. I was thinking \"oh god he's scraped instagram to make a teenage girl chatbot\". ^(please nobody actually do this)", "id": "d5za06v"}, {"comment": "I know what my next project will be! I think it would be a lot better if I included the name of the game in the title of the post to give the terrible name some context.", "id": "d5zadjq"}, {"comment": "Probably would help, yeah. Or call it \"Femto Roboto\" or something.", "id": "d5zbjaw"}, {"comment": "Ooohh, that's a good one. Not one word though.", "id": "d5zjnmw"}, {"comment": "FemtoRoboto?", "id": "d5zkdrw"}, {"comment": "Actually thought it was a feminist bot of some sort... Got triggered!", "id": "d5zbl6x"}], [{"comment": "Write a post on how the thing actually works, give me diagrams, ELI5, all that. All I got out of this is \"someone made an AI that plays a game\". All I know about its working is \"it simulates lots and picks the best option\". I wanna know how you structure all that data, i want to know about run time, I want to know about the failed steps along the way and how you fixed the failures.\n\nI learned nothing from this. :(", "id": "d5za2zg"}, {"comment": "Nothing to learn from exhaustive search, except how long it takes.", "id": "d5zb4jj"}, {"comment": "The post pretty well explained everything. There's not really that much to it. The two lines on how it works state everything about how it works. It looks at every possible outcome and chooses the branch with the most wins.", "id": "d5zad5p"}, {"comment": "I know that's \"pretty much everything\" to an AI geek, but I haven't really done any AI. I feel like looking at this, playing with it, and replicating it could be a really good stepping stone into learning it, but I really don't know what it's actually doing, mechanically speaking. ", "id": "d5zbkq7"}, {"comment": "I think you're expecting it to be waaay more complicated than it is. I have a big backlog of projects I'm writing up and for some of the more recent ones I'll have more in depth explanations, because they're more complicated and there's more to explain.", "id": "d5zjkz3"}], [{"comment": "I'd almost think because of the (seemingly) simple mechanics of the game, it could be mathematically solved. ", "id": "d5zcct1"}, {"comment": "I think, for something like this, properly implemented Minimax would be equivalent. I just never took the time to do that. I didn't make it because I wanted to do things the best way. I made it so I'd have something that could play well enough to beat me most of the time.", "id": "d5zjlw9"}, {"comment": "Which is perfectly fine. I thought through how I'd step through solving it and caching results through a simple tree. It just occurred that there may possibly be a \"perfect\" solution for each occurrence in the game. Though I suppose that such a solution may not be possible until the player has learned the identity of each card (unless steps are taken each time to randomize). Perhaps I do not understand the game well enough. ", "id": "d607z2y"}, {"comment": "I think properly implementing Minimax would be equivalent to that perfect solution. I think the perfect solution you're thinking of would also be equivalent to working out all the game theory that I don't really know enough about.", "id": "d6092v9"}]]], "4iguqx": ["What should you learn to get a [better] coding job", "2016-05-09 03:10:13", 44, "https://medium.com/swizec-s-nightowls/what-should-you-learn-to-get-a-better-coding-job-6453ef083597", [[94, "What a worthless article. The jackass even inserted HIS OWN twitter quote in the middle."], [72, "- Go beyond Javascript.\n- Avoid yet another CRUD job.\n- Stop integrating various shitty APIs.\n- Troll on Reddit more.\n- Learn nothing.\n- Get old.\n- Die.\n\n"], [24, "Design patterns. And how and when to fucking use them. Don't litter your code with 60000 interfaces because you think you understand the repository pattern. "], [17, "Engineering is an actual degree, not just what you want to call yourself out of convenience. "], [14, "I recently created a program that formats the data from the HN \"Who Is Hiring\" thread this article references. It is really interesting to see what languages, frameworks and databases are mentioned the most. The tech stack companies are using is all over the board.\n\nYou can see this data and the counts broken down into graphs from http://www.gosmartsolutions.com/hn/\n\nGoes to show that you really do have to continually be in learning mode to stay current in this field."], [8, "In my humble experience, getting a better job meant being opinionated and experienced. It's probably hard to have one without the other.\n\nFirst, I sucked as an entry-level coder. I had to go through hell (aka the Big Island of Hawaii) to learn how to make money coding. I had to learn what it takes to make clients happy, what it takes to get fast, noticeable results, how to maximize income, and how to minimize costs. A big part of this was choosing and becoming an expert with my tools of choice, even if it wasn't fashionable.\n\nIf you love COBOL, use COBOL and become an expert. I just left Novell (now Micro Focus Intl.), and there is a TON of COBOL to be done yet in the world.\n\nI now work at a company I love doing work I love with people that rock. I program in a language that people didn't even know about nine years ago, but I knew I loved it at first sight.\n\n"], [5, "I don't agree with the advice in this article. While salary data shows that the \"Engineer\" title does pay more, that's the beginning and the end of the terminology distinction. Programmers/Developers/Engineers all have the same job function: increase the business value of information technology.\n\nUnless you are in the business of selling technology, your organization likely uses technology as a selling point for their process or client experience rather than thinking of their technology as their product."], [5, "Is COBOL really on its way out?"], [3, "He lost me at the point he made out there was some sort of distinction between engineers, programmers and developers."], [2, "> don't call yourself a programmer\n\nHis blog is literally \"about [...] being the best programmer you can be\"."], [1, "Common sense advice that sadly still eludes the majority of people in the field.\n\n"], [1, "First of all, don't look for a \"coding\" job. There are some low paying programming jobs where you really are only turning pseudocode into code. That's a coding job. \n\nIn good programming/software engineering jobs, coding is only one of the many tasks you have to perform."], [-16, "Why the obsession with getting jobs?  Is that what most people worry about instead of things like, making a mark on the world, helping others, providing quality service and improving life.  I have found that any person who consumes themselves with titles, jobs and salaries tend to be leaches that often perform poorly due to misaligned motivations, or short-sightedness.  Let's all agree to align ourselves with things greater than money, and greater than ourselves.\n\nEDIT: Thanks everyone. You are all the reason the world is the way it is.  You have no one to blame except yourself."]], [[{"comment": "What a worthless article. The jackass even inserted HIS OWN twitter quote in the middle.", "id": "d2y98wr"}], [{"comment": "- Go beyond Javascript.\n- Avoid yet another CRUD job.\n- Stop integrating various shitty APIs.\n- Troll on Reddit more.\n- Learn nothing.\n- Get old.\n- Die.\n\n", "id": "d2y2zjn"}, {"comment": "I think we can shorten the list a bit.\n\n* Program.\n* Die.", "id": "d2y8wbd"}, {"comment": "You're hired!", "id": "d2yaxvd"}, {"comment": "My second internship was a CRUD job.  How is this not a solved problem already?  Why does it take 4 developers to maintain a system that just lets people enter stuff into a database?  Is having no soul a prerequisite for the job or does it leak out over time?", "id": "d2yb6wk"}, {"comment": "I worked 5 years at CRUD place (only the work was cruddy \ud83d\ude09. The company was actually pretty good, but our business model and customers were horrible)\n\nLet me spin this as a story from my experience to why CRUD takes so much labor.\n\nIn your city right now, in 2016, there exists at least 50 companies who still manage all of their internal bureaucracy with paper forms. \n\nNow, about 2005 or so, a bunch of these companies realized that computers weren't a fad, and in fact, could help them do more than just email and spreadsheets. \n\nSo they started digitizing their processes, probably with Access. A bunch of the long time employees are going to get really bent out of shape at this point in time, because their little sphere of influence (seeing that forms are properly filled out) was going to be automated.\n\nFast forward 11 years (damn, I'm getting old). This Access db has been corrupted so many times, nobody really knows what was going on from a data point of view for the last 11 years. New Hot Shot (NHS) is hired at Legacy Company to help them get up to speed. NHS hires your agency to help them fix their shit with _real_ applications.\n\nNow, you and your peers get along fine with NHS, but you rarely talk to them. They're too busy doing Business. Instead, you'll talk to Long Time Employee (LTE). LTE hates you, and hates everything you do. LTE knows that you're there to take their job from them, so they are going to do everything possible to sabotage the process. Additionally, even when you can get LTE to cooperate, they don't understand that there's no \"File to sync on the intranet\" anymore, and everything is real time, and half of the data they need input is redundant.\n\nProject goes over deadline. NHS is pissed, your boss is pissed. LTE is actually happy, but pretends to be pissed. Project gets extended with a little money exchanged. \n\nA typical project that should take 6 months will take over 2 years (coincidentally around the time that LTE is going to retire). \n\nThe app finally launches, but oh boy, is it a mess. Nobody internal or external at the client can figure it out. They're already talking a phase 2 to make it make sense.\n\nLTE retires. Sharp New Employee (SNE) starts. They look at how LTE handled the bureaucracy. It's completely wrong!!! On top of bug fixes, you'll need to rewrite EVERYTHING. \n\nNHS has moved on to an exciting new position, and you're stuck dealing with The Old Boss (TOB). TOB has no idea how any of this works, as they've spend 60 years in Widget Production. You'd think them handing everything off to SNE to handle it would be great, but it's even worse, because TOB has a nephew who can do all of this \"for half price\". \n\nSo now you have to fight for this crappy business. \n\nIn the meantime this power turnover battle has been waging, all of your engineers have been putting out constant fires with the original app because it was so bad. Unfortunately, that's not what they're suppose to be working on, because for your agency to really be making money, you need to be working on as many projects simultaneously as possible.\n\nYES, there are MORE horrible customers and more horrible apps just like the first one (in my case, we had over 120 that could break at any point in time).\n\nNow you may argue \"Once all of the techno-fossils are out of the work force, this is going to be way easier\"\n\nI want to think this too, but I really suspect that it's a cyclical process.\n\nCRUD can be stupid quick and simple regardless of the tech assuming\n\n1. The customer is educated on how network based applications work\n1. The customer knows what they want \n1. The customer can explain to you how they want it\n\nIf those last two sound like they rarely happen, then we're on the same page here.", "id": "d2yj85q"}, {"comment": "This made me want to cry as it describes my current job situation.  \n\nOnly change Access for disparate Excel files and the LTE isn't planning on retiring and has the ability to get me fired if I upset her by changing too much.", "id": "d2zu8yn"}, {"comment": ">Only change Access for disparate Excel files\n\nHah, yeah did lots of those too.\n\nYou sound like you have it rougher. This place knew at that the LTE was usually extremely subversive and wouldn't hold it against you. On the other hand, we had to walk on eggshells around them and couldn't just call them out on their BS. I stayed way too long at that place.", "id": "d2zzg2b"}, {"comment": "It is solved over and over again. When the solution reaches a mature enough state, a shiny new technology enters the stage and everyone starts over again. Cobol, Perl, RoR, NodeJS,  NoSQL, etc.", "id": "d2yih4g"}, {"comment": "It is largely. CRUD is stupidly easy in frameworks like Rails, you can even just about automate it with scripts.", "id": "d2yeeo9"}, {"comment": "> How is this not a solved problem already?\n\nA ton of old codebases doing it terribly with bosses that won't let you rewrite it but still want someone to maintain it.", "id": "d2ymd2v"}, {"comment": "It is all done for the sake of charity. Just imaging how many mediocre people will lose their jobs if CRUD gets automated properly.", "id": "d2ydovj"}], [{"comment": "Design patterns. And how and when to fucking use them. Don't litter your code with 60000 interfaces because you think you understand the repository pattern. ", "id": "d2y3dbr"}, {"comment": "Interfaces are god!", "id": "d2y982j"}, {"comment": "Repo pattern is the Bain of so much bad code IMHO", "id": "d2y8qws"}, {"comment": "Design patterns are mostly related to a useless and destructive religion. They got very little to do with any engineering.", "id": "d2ydnfy"}, {"comment": "I feel like you only read the first two words of my comment lol", "id": "d2yh77t"}, {"comment": "My point is that nobody should fucking learn any fucking \"design patterns\"", "id": "d2yhnc8"}, {"comment": "You must suck at your \"fucking\" job then or just love the job security you have from having to write code over and over.", "id": "d2yhrup"}, {"comment": "Ah, another deranged fucking OOP fanboy. Shit like you have infested the industry and is totally responsible for all the mess we have to deal with.", "id": "d2yia6j"}, {"comment": "\"Shit like me\" worked for America's space program directly on the STS missions. You sound just like one of those angry 80 year old AS/400 developers we phased out. Go write something pretty in Natural, Cobol, (procedural) PHP, or whatever it is you work with. I'll setup an Adabas instance for you.", "id": "d2yizru"}, {"comment": "OOP scumlickers like you destroyed this industry. I'd be so delighted to see all you suckers automated out into an unemployment! You're stupid and incompetent. Only a total moron can think that OOP is a usable methodology. Only a fucking brain-dead code monkey can think that a presense of a \"design pattern\" is anything but a sign of using a totally wrong level of abstraction.", "id": "d2ymssz"}, {"comment": "> a design pattern is a wrong level of abstraction.\n\nI'm not sure this makes any sense.  Are you advocating for not abstracting while creating software?  Surely whichever methodology you go with, you'll be working with multiple levels of abstraction.", "id": "d2ynh47"}, {"comment": ">  Are you advocating for not abstracting while creating software? \n\nWhat? I'm talking of exactly the opposite. If you keep seeing a recurring pattern, it means that you're on a too low level of abstraction. In an adequate abstraction level you won't see any redundancy. No matter how many layers you've got, if each layer is designed properly there won't be any redundancy on any of them.", "id": "d2yoavu"}, {"comment": "[deleted]", "id": "d2yrg1d"}, {"comment": "I'm annoyed *just enough* to be digging into another ingenious piece of a shitty opensource OOP code. Don't need any higher levels of anger for this.", "id": "d2yrwph"}, {"comment": "are you for real? you have to be trolling...", "id": "d2yvg2m"}, {"comment": "Another fanboy?!? This sub is infested...", "id": "d2yvjhn"}], [{"comment": "Engineering is an actual degree, not just what you want to call yourself out of convenience. ", "id": "d2y7v6b"}, {"comment": "It's also a job; doing it is arguably justification enough for calling oneself an engineer.", "id": "d2ybjdq"}, {"comment": "Fry, listen to me. Just because you say you're a robot doesn't make you a robot. Look at me, I call myself a doctor, but that doesn't make me a doctor. These fancy clothes do!", "id": "d2yc3as"}, {"comment": "It is an actual *responsibility*. Go on, call yourself an engineer but be ready to go to jail if you screw up.", "id": "d2ydd8h"}, {"comment": "That escalated quickly.", "id": "d2yg08k"}, {"comment": "This is exactly why the sane countries are defining the word \"engineer\" legally.", "id": "d2yhmb9"}, {"comment": "[deleted]", "id": "d2yn6p1"}, {"comment": "Of course, shit like Murica is hellbound on getting as lax a legislation as possible on literally everythibg, so that capitalists will be able to suck their profits with little to no responsibility. Fuck Murica.", "id": "d2yncsg"}, {"comment": "[deleted]", "id": "d2yo1vk"}, {"comment": ">  is \"insane\" because of a lack of MORE regulation\n\nExactly. You stupid Muricans cannot get it, so I won't waste my time explaining. The rest of the world know what kind of shit you are, especially after the most recent TTIP leaks.", "id": "d2yo86v"}, {"comment": "Engineers do not go to jail if they \"screw up\".  They go to jail for professional misconduct, which is intentional.", "id": "d2yqnov"}, {"comment": "> Engineers do not go to jail if they \"screw up\".\n\nEngineer who breaks the rules while building, say, a bridge, would go to jail, no matter, was it intentional or just down to an incompetence.", "id": "d2yr2mt"}, {"comment": "First, violating laws or codes is not merely \"screwing up\".  That is gross negligence at best.\n\nSecond, whether or not the engineer in authority goes to jail over such an issue most certainly does depend on whether it was gross negligence (unintentional) or willful misconduct (intentional).  It also depends on the severity of the infraction.  The bar for criminal charges in a case of gross negligence is much higher than in a case of willful misconduct.", "id": "d2ytmtg"}, {"comment": "> violating laws or codes is not merely \"screwing up\"\n\nDepending on a culture. A British \"a tad worrying\" is roughly an equivalent of an American \"panic!!!\", for example.\n\nAnyway, engineering is a profession where there are certain safeguards in place. Programming is, unfortunately, different, there is no way to punish a coder for even the worst possible screw-ups.", "id": "d2ytsnr"}, {"comment": "Depends on what country you happen to call home.", "id": "d2y98yi"}, {"comment": "Well, except for software engineering. Which is something you want to call yourself out of convenience.", "id": "d2ydj53"}, {"comment": "The difference between Computer Science and Software Engineering is semantics (or at my university, it's 4 papers).", "id": "d2yefeg"}, {"comment": "[deleted]", "id": "d2yrq0s"}, {"comment": "I'm fairly sure at my university if you only do 3 out of 4 years for a BEng(hons) in SE, you can graduate with a BSc in CS.", "id": "d2zkm9s"}], [{"comment": "I recently created a program that formats the data from the HN \"Who Is Hiring\" thread this article references. It is really interesting to see what languages, frameworks and databases are mentioned the most. The tech stack companies are using is all over the board.\n\nYou can see this data and the counts broken down into graphs from http://www.gosmartsolutions.com/hn/\n\nGoes to show that you really do have to continually be in learning mode to stay current in this field.", "id": "d2y9za6"}, {"comment": "It still shows Java as being the dominant language.", "id": "d2yeg36"}, {"comment": "[deleted]", "id": "d2z0e8e"}, {"comment": "I'm sorry, but that is hilarious.", "id": "d2z3d6f"}, {"comment": "Keep in mind that HN \"companies\" are a far cry from representative of anything you could consider the \"industry\" of prgrammers.  If it were, you'd still have at least a mention of COBOL on there, and Perl would still have significant placement in the tech stacks used.\n\nThis data is interesting, but we should keep it in the appropriate perspective of what it is, which is a tiny data point of one demographic in the bucket of all programming done.  Hell, there's an entire market that's not as tiny as you'd think for ColdFusion devs.  Props to anyone that even knows what that is.", "id": "d2z09bi"}, {"comment": "Totally agree with you. It is interesting data and kind of shows how far off the HN jobs (or maybe Bay Area) is from everywhere else.", "id": "d2z0nkf"}], [{"comment": "In my humble experience, getting a better job meant being opinionated and experienced. It's probably hard to have one without the other.\n\nFirst, I sucked as an entry-level coder. I had to go through hell (aka the Big Island of Hawaii) to learn how to make money coding. I had to learn what it takes to make clients happy, what it takes to get fast, noticeable results, how to maximize income, and how to minimize costs. A big part of this was choosing and becoming an expert with my tools of choice, even if it wasn't fashionable.\n\nIf you love COBOL, use COBOL and become an expert. I just left Novell (now Micro Focus Intl.), and there is a TON of COBOL to be done yet in the world.\n\nI now work at a company I love doing work I love with people that rock. I program in a language that people didn't even know about nine years ago, but I knew I loved it at first sight.\n\n", "id": "d2y7vfh"}], [{"comment": "I don't agree with the advice in this article. While salary data shows that the \"Engineer\" title does pay more, that's the beginning and the end of the terminology distinction. Programmers/Developers/Engineers all have the same job function: increase the business value of information technology.\n\nUnless you are in the business of selling technology, your organization likely uses technology as a selling point for their process or client experience rather than thinking of their technology as their product.", "id": "d2xze7m"}, {"comment": "> Programmers/Developers/Engineers all have the same job function: increase the business value of information technology.\n\nThis is so vague, it applies to everyone, even the sales people.\n\nIt's also useless because you don't know *what* is the value in the business sense. You can only provide your contribution in the form of engineering.\n\nIt is entirely possible that your company's business strategy will fail and it will have nothing to do with whether you did your job properly or not.", "id": "d2y7s70"}], [{"comment": "Is COBOL really on its way out?", "id": "d2y63f5"}, {"comment": "No its not, and there is a serious brain drain problem in the banking and insurance industries.  The old cobol/rpg programmers have 10ish years left before they retire.  You are going to start seeing some very nice salaries for cobol jobs in a few years.", "id": "d2y87pz"}, {"comment": "Do these organizations understand what it takes to do proper maintenance/improvements or are you considered a (bitchy) cost center?", "id": "d2yefcv"}, {"comment": "I've been considering learning COBOL for this reason. ", "id": "d2ydbmw"}, {"comment": "What about VB6?", "id": "d2yepp0"}, {"comment": "Yeah this is already the situation in my country where COBOL programmers are making big bucks, probably the most out of all programmers because they are in such a shortage.", "id": "d2yul81"}, {"comment": "Absolutely not. The worldwide COBOL codebase only grows, it's just not in the spotlight.\n\nIt might not be fun to develop in, its applications may lie only in boring subjects, but it's still the backbone of the entire financial industry (as well as some other large industries).\n\nIf you know COBOL you can get a job practically anywhere. This will become more true as time goes by, and more OG mainframe programmers retire. There is a shortage of skilled ones, you can use this as leverage.", "id": "d2yi1gr"}, {"comment": "The average COBOL programmer is 55 years old.\n\nhttp://blog.hackerrank.com/the-inevitable-return-of-cobol/", "id": "d2yidhx"}], [{"comment": "He lost me at the point he made out there was some sort of distinction between engineers, programmers and developers.", "id": "d2yio8i"}], [{"comment": "> don't call yourself a programmer\n\nHis blog is literally \"about [...] being the best programmer you can be\".", "id": "d2yde8e"}], [{"comment": "Common sense advice that sadly still eludes the majority of people in the field.\n\n", "id": "d2y7qkd"}, {"comment": "What eluded me was the difference between engineer and developer. I think I've been spoiled by working for too long in not very serious companies, but in all my years of experience rarely I found the software specified at detail, let alone some analysis of edge cases at all, that always ended up on the developer's responsibility.\n\nIs this less common than I think? Cause I've worked on very varied jobs and I never once landed one where I could follow an spec without thinking. And I was never called an engineer. :P", "id": "d2yhlrt"}], [{"comment": "First of all, don't look for a \"coding\" job. There are some low paying programming jobs where you really are only turning pseudocode into code. That's a coding job. \n\nIn good programming/software engineering jobs, coding is only one of the many tasks you have to perform.", "id": "d2yi3yv"}], [{"comment": "Why the obsession with getting jobs?  Is that what most people worry about instead of things like, making a mark on the world, helping others, providing quality service and improving life.  I have found that any person who consumes themselves with titles, jobs and salaries tend to be leaches that often perform poorly due to misaligned motivations, or short-sightedness.  Let's all agree to align ourselves with things greater than money, and greater than ourselves.\n\nEDIT: Thanks everyone. You are all the reason the world is the way it is.  You have no one to blame except yourself.", "id": "d2y6wa4"}, {"comment": "Sounds good. The moment my bills all agree to stop aligning themselves with being paid.", "id": "d2y7nuv"}, {"comment": "Job = ability to support yourself and family. Everything else is a nice-to-have :)", "id": "d2y7lzw"}, {"comment": ">Why the obsession with getting jobs?  \n\nCause we like to eat and have shelter.\n\n>Let's all agree to align ourselves with things greater than money, and greater than ourselves\n\nOk. Are you paying our bills while we do that?", "id": "d2yal50"}, {"comment": "But don't you have those things?  Once your basic needs are satisfied, you have to look at the big picture.  It's the only way you will MAKE jobs for yourself.  That covers pretty much every person in the USA.", "id": "d2ynf9u"}, {"comment": "I have those things because I work a job for money.", "id": "d2ywxnr"}, {"comment": "My comment was that your basic needs are satisfied, regardless. You have much more than those thing because you work a job... Now if only your job was good (for society and you)....  My comment was that doing good things for society and society will do good things for you. You are apparently completely misunderstanding that fundamental concept that society functions.", "id": "d2yyh4w"}, {"comment": "My basic needs are met BECAUSE I work a job for money.\n\nAnd I live in the US. Sorry, but society isn't gonna do shit.", "id": "d2zjnbt"}, {"comment": "Okay but wouldn't you like to do those things from under a warm, safe roof that you can pay for with money that you yourself earned? I'm not saying I disagree with you I just want to suggest to not throw jobs completely out the window because of your philosophical views on how the world works", "id": "d2y9t15"}, {"comment": "Yes, and title of this post is about getting a \"better\" job, so the presumption is that is already the case.", "id": "d2yyr7m"}, {"comment": "Whether or not we like it, the world is capitalist, and we have to work with the system we're in. Unfortunately in this system you either work as a wage slave, or you die. That's just the situation we're in, and while we can fight against it, we do all need money to survive.", "id": "d2yebrb"}, {"comment": ">making a mark on the world, helping others, providing quality service and improving life\n\nThese things can be seen to be the same as money. Since you can't do everything by yourself, you do some of these things for others and others do some of these things for you.\n\nMoney is nothing but a representation of these things.", "id": "d2yergk"}, {"comment": "Yes, exactly. And when you don't have (enough) money, the rational thing to do is to do good things for the world that then translates into more money.  The money isn't even a defining factor or important. The good things for society are. That was my point.", "id": "d2yyuqr"}, {"comment": "[deleted]", "id": "d2yrsv0"}, {"comment": "That is incredibly sad.", "id": "d2yypwg"}, {"comment": "[deleted]", "id": "d2yysk1"}, {"comment": "You contradict yourself sir. Learn the difference between a suggestion and \"pushing\" - unless you feel that a comment on Reddit has coercive power.\n\nSlavery is always sad.", "id": "d2yyyiw"}, {"comment": "kill yourself", "id": "d2ylu0y"}]]], "4sv6j6": ["Build a Pokemon Go clone using GraphQL, AWS Lambda, location services, iOS push notifications, and event-based triggers", "2016-07-14 23:39:25", 1, "https://scaphold.io/#/blog/pokemon-go-graphql-with-aws-lambda", [], []], "3zlxhv": ["Oracle sinks its claws into Android", "2016-01-05 23:11:40", 0, "http://andreasgal.com/2016/01/05/oracle-sinks-its-claws-into-android/", [[14, "The article is a bit hyperbolic. When you adopt a GPL2 software you are not required to support every part of the original code (like Swing). You are required to keep the license and release any modifications you make under the same license. Nobody stops you to fork the original code (as long as you keep the license) or to use only parts of the original code and update only these parts.\n\nI doubt we will see Google supporting Swing on Android.\n\nIn the long run this could, in theory, be a good move for Android developers, they will finally have access to latest Java versions. Short term I expect performance problems and new bugs for old applications."], [13, "> Swing will now sit on every Android phone, using up resources.\n\nIt's mystifying to read this kind of nonsense from the former CTO of Mozilla.\n"], [11, "Clickbait title. The article itself is entirely hypothetical."], [4, "If Google is using OpenJDK for future android versions this only means that they don't want to implement all the newer java features by themselves. It's kind of sad if you learn java 8 just to find out you just can't use the simple apis and language features for android development. If they use openjdk this problem will simply be gone.\n\n> Java includes its own user interface (UI) library Swing, for example. Google has of course its own Android UI framework. Swing will now sit on every Android phone, using up resources. Its unlikely that Oracle will try to force Google to actually use Swing, but Google has to make sure it works and is present and apps can use it.\n\nopenjdk is gpl; google can copy the whole codebase and remove everything they don't want. They probably can't call it \"OpenJDK\", or whatever Oracle has a trademark on but they can still ship it with Android. Google has to make these changes available somehow and that's the cool stuff about GPL. If some company makes use of OpenJDK and adds some nice improvements everyone will benefit from it. Oracle has absolutely no control here. You really got that wrong, I believe.\n\n> Oracle has actually already a history of up-selling OpenJDK. They are offering certain components of the Java VM only for royalty payments.\n\nwhich is totally fine. Oracle does the same with MySQL as well. It's not \"cool\" by any means but hey, they want to make money somehow :)."], [4, "A) It's not regular GPL, it's GPL with a classpath exception.  This is essentially a looser licence than even LGPL.  Also, the proprietary changes didn't tend to be in this part of the codebase, even when it was Apache licensed.  Changing the functionality of pretty much anything in here would cause you to fail cert.\n\nB) They removed Swing (and a lot of other stuff) after their initial import of everything, citing it as \"unused code\".  https://android.googlesource.com/platform/libcore.git/+/42cdd0bf7251074df8bf6dfa7f5d62a01c0a1ef6"], [4, "I didn't read very thoroughly, but I don't see the reason why they should support the whole openjdk with the standard java libraries e.g the swing. I say it won't happen."], [3, "why does the author refer to OpenJDK as \"Oracle's own\"?? you can fork it any time you like, you just can't take on rights not  expressed by the GPLv2. \n\nGoogle could simply import OpenJDK once and never move the code forward. they aren't under any obligation to track future changes in OpenJDK. \n\ni do agree with the author that Google made a number of blunders along the way with Android, and many of these were guided by a desire to allow downstream partners like Samsung make changes that didn't have to be made available in source form. they're doubling down on these mistakes by continuing to deal with Java...GPL or not, they have to contend with Oracle mucking with things. Google already heavily influences two decent BSD-licensed language stacks (Go, Dart) that they could have targeted as future developments platforms and completely broken free of the weirdo licensing situation they are in now.\n\nthe real winner is Apple. with Swift, they have a modern development stack that programmers like using and is completely unencumbered"], [3, "Pretty sensationalistic title, but hey, you have to get people clicking.\n\nGoogle is not a Java licensee so they have no obligations to implement any of the OpenJDK they imported (besides, the AWT and Swing classes were deleted in a subsequent commit a few hours later).\n\nAlso, Oracle has been trying to sink its claws in Android for a while now, it's pretty much the only reason why they acquired Sun."], [2, "The post is a bunch of fear mongering and gets basic facts wrong. GPL was perfectly fine for Linux which is at the core of Android so having GPL+CPE (an even lighter version) won't make ANY difference.\n\nWe all benefit as Java is unified and Android developers finally get new Java versions.\n\nOracle doesn't get \"much\" out of it besides what it actually gets in the trial/settlement and potential \"respect\". Since google uses the GPL version of Java they don't pay a license fee and they get an automatic patent grant if they pass the TCK which is great for everyone (more portable code!). Notice that Linux vendors use OpenJDK from source and don't pay Oracle a cent.\n\nWe covered this in a far more factual way here: https://www.codenameone.com/blog/analysis-google-moving-to-openjdk-what-that-really-means.html"], [1, "It's a shame they don't keep swing, I kind of like it more than android's UI."], [1, "Here's a good rebuttal article by Bradley Kuhn: http://ebb.org/bkuhn/blog/2016/01/05/jdk-in-android.html"], [-4, "> GPL2, a viral open source license with strong protections\n\nSo the author takes issue with GPL. I, for one, love it."]], [[{"comment": "The article is a bit hyperbolic. When you adopt a GPL2 software you are not required to support every part of the original code (like Swing). You are required to keep the license and release any modifications you make under the same license. Nobody stops you to fork the original code (as long as you keep the license) or to use only parts of the original code and update only these parts.\n\nI doubt we will see Google supporting Swing on Android.\n\nIn the long run this could, in theory, be a good move for Android developers, they will finally have access to latest Java versions. Short term I expect performance problems and new bugs for old applications.", "id": "cyn6xw4"}, {"comment": "On top of that the next version of Java allows for modularization. So by the time Google does ship an android based on Java it will be kosher to exclude swing. ", "id": "cyna4z4"}, {"comment": "There's a response to this article and continuation here: https://www.codenameone.com/blog/debating-brendan-eich-over-android-openjdk-move.html", "id": "cynzr7t"}], [{"comment": "> Swing will now sit on every Android phone, using up resources.\n\nIt's mystifying to read this kind of nonsense from the former CTO of Mozilla.\n", "id": "cyncqhk"}, {"comment": "My guess is that for Google to comply it has to provide the whole API, that means supporting swing, even if it won't be used. so \"resources\" may refer to only hard drive space?", "id": "cynhgsq"}, {"comment": "No, it really doesn't. If you read the [GPL v2](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html) license, you will see Google doesn't have any responsibilities to provide the whole api. \n\nThe author seems to be basing this more off of the Google vs. Oracle api lawsuit, but that still doesn't make any sense.\n\n>Whether Oracle will be able to leverage its lawsuit to control Java on Android remains to be seen.\n\nI really don't think the ruling says that Oracle \"owns\" what java looks like. All it says is that someone may not copy the API, as that would break Oracle's copyright. Furthermore, Oracle _must_ allow for Google to make modifications under the terms of the GPL v2 or else they would be breaching the terms of the contract.\n\n(I am not a lawyer, so don't take this as legal advice, it is my opinion on reading the GPL v2, and the _Oracle v. Google_ [circuit court ruling](http://www.cafc.uscourts.gov/sites/default/files/opinions-orders/13-1021.Opinion.5-7-2014.1.PDF), and a few laws about copyright).\n\nThis is all really complex, so I could understand why a really smart person could make mistakes. Heck I could be wrong. ;D\n\nEDIT: Oracle v Google is lawsuit not debate.", "id": "cyniq2o"}, {"comment": "Please read the GPL 2 text before guessing. As long as you provide your modifications under GPL 2 you are free to change (remove/add) the code in any way you wish. Your work will be considered derived work.", "id": "cyo0mhr"}], [{"comment": "Clickbait title. The article itself is entirely hypothetical.", "id": "cyn64oe"}], [{"comment": "If Google is using OpenJDK for future android versions this only means that they don't want to implement all the newer java features by themselves. It's kind of sad if you learn java 8 just to find out you just can't use the simple apis and language features for android development. If they use openjdk this problem will simply be gone.\n\n> Java includes its own user interface (UI) library Swing, for example. Google has of course its own Android UI framework. Swing will now sit on every Android phone, using up resources. Its unlikely that Oracle will try to force Google to actually use Swing, but Google has to make sure it works and is present and apps can use it.\n\nopenjdk is gpl; google can copy the whole codebase and remove everything they don't want. They probably can't call it \"OpenJDK\", or whatever Oracle has a trademark on but they can still ship it with Android. Google has to make these changes available somehow and that's the cool stuff about GPL. If some company makes use of OpenJDK and adds some nice improvements everyone will benefit from it. Oracle has absolutely no control here. You really got that wrong, I believe.\n\n> Oracle has actually already a history of up-selling OpenJDK. They are offering certain components of the Java VM only for royalty payments.\n\nwhich is totally fine. Oracle does the same with MySQL as well. It's not \"cool\" by any means but hey, they want to make money somehow :).", "id": "cyn98r7"}], [{"comment": "A) It's not regular GPL, it's GPL with a classpath exception.  This is essentially a looser licence than even LGPL.  Also, the proprietary changes didn't tend to be in this part of the codebase, even when it was Apache licensed.  Changing the functionality of pretty much anything in here would cause you to fail cert.\n\nB) They removed Swing (and a lot of other stuff) after their initial import of everything, citing it as \"unused code\".  https://android.googlesource.com/platform/libcore.git/+/42cdd0bf7251074df8bf6dfa7f5d62a01c0a1ef6", "id": "cynb12x"}], [{"comment": "I didn't read very thoroughly, but I don't see the reason why they should support the whole openjdk with the standard java libraries e.g the swing. I say it won't happen.", "id": "cyn67bt"}], [{"comment": "why does the author refer to OpenJDK as \"Oracle's own\"?? you can fork it any time you like, you just can't take on rights not  expressed by the GPLv2. \n\nGoogle could simply import OpenJDK once and never move the code forward. they aren't under any obligation to track future changes in OpenJDK. \n\ni do agree with the author that Google made a number of blunders along the way with Android, and many of these were guided by a desire to allow downstream partners like Samsung make changes that didn't have to be made available in source form. they're doubling down on these mistakes by continuing to deal with Java...GPL or not, they have to contend with Oracle mucking with things. Google already heavily influences two decent BSD-licensed language stacks (Go, Dart) that they could have targeted as future developments platforms and completely broken free of the weirdo licensing situation they are in now.\n\nthe real winner is Apple. with Swift, they have a modern development stack that programmers like using and is completely unencumbered", "id": "cyn91bt"}], [{"comment": "Pretty sensationalistic title, but hey, you have to get people clicking.\n\nGoogle is not a Java licensee so they have no obligations to implement any of the OpenJDK they imported (besides, the AWT and Swing classes were deleted in a subsequent commit a few hours later).\n\nAlso, Oracle has been trying to sink its claws in Android for a while now, it's pretty much the only reason why they acquired Sun.", "id": "cynbdag"}], [{"comment": "The post is a bunch of fear mongering and gets basic facts wrong. GPL was perfectly fine for Linux which is at the core of Android so having GPL+CPE (an even lighter version) won't make ANY difference.\n\nWe all benefit as Java is unified and Android developers finally get new Java versions.\n\nOracle doesn't get \"much\" out of it besides what it actually gets in the trial/settlement and potential \"respect\". Since google uses the GPL version of Java they don't pay a license fee and they get an automatic patent grant if they pass the TCK which is great for everyone (more portable code!). Notice that Linux vendors use OpenJDK from source and don't pay Oracle a cent.\n\nWe covered this in a far more factual way here: https://www.codenameone.com/blog/analysis-google-moving-to-openjdk-what-that-really-means.html", "id": "cynq5q4"}], [{"comment": "It's a shame they don't keep swing, I kind of like it more than android's UI.", "id": "cynflul"}], [{"comment": "Here's a good rebuttal article by Bradley Kuhn: http://ebb.org/bkuhn/blog/2016/01/05/jdk-in-android.html", "id": "cyoc5xr"}], [{"comment": "> GPL2, a viral open source license with strong protections\n\nSo the author takes issue with GPL. I, for one, love it.", "id": "cyn7fcn"}, {"comment": "Despite the blog author saying many things that are wrong in my opinion the line you're quoting is correct no matter how you look at it. Being viral is one of the core concepts of the gpl and it was specifically created to be that way. In fact if you look at the updates made between the gpl versions you'll see that keeping it viral was a big reason there too.", "id": "cync1os"}]]], "3xc63d": ["What\u2019s new in ASP.NET 5 RC 1", "2015-12-18 15:24:09", 0, "http://www.talkingdotnet.com/whats-new-in-asp-net-5-rc-1/", [[2, "There's a lot of stuff missing. And given that RC1 is long time available already and that RC2 is on the way this post comes very late."]], [[{"comment": "There's a lot of stuff missing. And given that RC1 is long time available already and that RC2 is on the way this post comes very late.", "id": "cy3blbd"}]]], "4umofv": ["Programmers can come from everywhere - even astrophysics", "2016-07-26 07:46:21", 1, "http://blog.hackerrank.com/could-this-astrophysicist-land-a-developer-job/", [[26, "Yeah even those astrophysicist dummies can learn to program! "], [10, "I appreciate the article, but am somewhat confused...\n\nI am a physics PhD student that spends ~8 hours a day programming (including weekends). I'll be the first to admit that my code is not as pretty as it could be, but I take time to learn everything I can about the languages I use. In fact, I love physics because it hits the sweet spot for me when it comes to programming: low-level, HPC work. I never have to worry about GUI's, user friendliness, or the chaos of web development, and it's awesome!\n\nThat said, industry tackles different problems than academia. I get that, but it seems odd to me to put someone who has years of demonstrable programming experience in another field in the same box as someone who just learned python yesterday."], [4, "I do agree that everybody might have the potential to be a programmer. I see it in the companies where I worked, half of them had a non programming background (history, biology, educator all at university levels) which they mostly didn't finish or couldn't find a job for what they learnt for. But you can see that they did have interest in computing already as a hobby mostly, but they never thought of making it their job. And because there's so much more work and money to make in the IT programming it was quite simple for them to enter that field.\n\nWhat I did see that the one who had an educator background and jumped blindly into programming that - with all respect - her code was not so nice to say it friendly. She had never learnt about design patterns, never heard about making proper variable naming, massive methods with 1000's lines of code, 20 arguments per method et cetera and nobody told her in the company that she was writing piles of bad code. She was delivering fast and as everybody knows, your boss/company doesn't care how you do it (mostly); they have to make money fast. I know her code is bad because when I joined the company I had/have to maintain it and it is still a hell to maintain, although it is a dying project (for several reasons).\n\nWhile on the other hand the colleague with a biology background at another company I worked for writes perfectly clean and documented code and you don't have to tell him how he should program. He wants to write nice and clean code and reads a lot of best practices online.\n\nThese are just some personal examples and actually theoretically I think in every company I was in I was the only one with the proper theoretical background in programming (did my bachelor in IT/software design/programming/etc). And in practice my experience is that other colleagues can be as good or bad with without any background in IT. Quite often I hear stories from colleagues that worked for other companies that they had terrible colleagues writing really bad code. These 'bad programmers' were just in it for the money and because there is/was no real requirements in a lot of companies doing IT (\"You can do Java and Javascript and Angular and some fancy tools? You're accepted\") like in most other professions which are more a sort of 'protected'. Try to apply for a physiotherapist job without proper certificates or try applying for a carpenter job without any educational background in it.\n\nThat's a bit the strange thing with IT and programming: everybody can just sit in front of his computer and do online courses in programming and learn by trail and error and can achieve very good skills. I actually think that's more and more the future; people educate themselves more and more online in a lot of professions by reading and watching YouTube videos and try them at home. \n\nBecause there is so much work for programmers I don't worry yet, but if there were a very limited amount of programming jobs and you see that people from everywhere with no IT background enter your field and write horrible code it would feel like stealing jobs and coming away while making a mess of it. It would be the same like everybody becoming a carpenter without proper education and theory/experience and making thing which fall apart after a few years and you with the proper background/education/theory knowing that if you would've built it it would be stable and solid."], [3, "A very significant proportion of the first generations of programmers came from physics. Simply because this is where computers were used mostly (besides finance/accounting). Just look at how much of the important stuff came from CERN (web included)."], [2, "yes but what about *from psychology*?"], [2, "Programmer with a degree in Literae Humaniores (Latin, Greek, history, philosophy, all that jazz) here... I dreamed of having skills as relevant as those of an astrophysicist."], [2, "The post completely misses the point of which people do and don't get hired for which types of job. It's not uncommon at all to find people in the industry who switched from for example chemistry or physics to software development. I worked at a small company for 10 years that had 2 chemists, 1 physicist and 1 astrophysics graduate working as software developers. \n\nThe problem is that having done 8 years of  physics research, even doing programming most of the day, is not really much relevant experience. And many of these people do expect to be paid more than a recent CS grad simply because they feel their 8 years of experience is relevant. I mean, it's programming right? \n\nJust because you're \"doing programming\" doesn't mean you actually grow as a software engineer. Something many developers run into when they want to switch after working for the same company for 10 years and then finding out they've hardly learning anything new. "], [2, "> How did you do on the HackerRank challenges?\n\nIt was interesting up until that point, then it just became a low effort advertisement for HackerRank. Although I'm kind of impressed at how many times they managed to get the word HackerRank into such a short amount of lines."], [1, "At first I thought the title said Astrology.."]], [[{"comment": "Yeah even those astrophysicist dummies can learn to program! ", "id": "d5r13z1"}, {"comment": "Those wacky guys with nothing but a background in math, computation, and supercomputing!", "id": "d5r1ao4"}, {"comment": "I think you guys missed the point of the article by JUST reading the title alone. It might not be the best title here.\n\nBut I think the point is that most recruiters wouldn't call him because his background feels too academic and far removed even though programmers know it's not too far off.", "id": "d5r2nyt"}, {"comment": "The thing is it completely contradicts my, and many of the people I know's, experiences. Maybe it's just the part of the world that I live in, but I had no shortage of job offers after coming out of university with a Physics degree (it wasn't even an exceptional classification). And I'm certainly not a unique case, many people I know from maths and science backgrounds have had the same experience.", "id": "d5raa9e"}, {"comment": "The better question is - do they want to?\n\nI know a doctor of astrophysics making 70k at a bank in germany (because math).", "id": "d5rbh21"}, {"comment": "Is that supposed to be high? \n\nSoftware developers seem to earn much more, especially those with a PhD.", "id": "d5t41hb"}, {"comment": "Yes, it is high in germany, afaik you keep more of your income here compared to the US but you don't get the 150k you may get in the SF area.\n\nJava developer with 10 years experience = ~65k (Absolventa numbers).\n\nFor others see http://www.handelsblatt.com/unternehmen/beruf-und-buero/buero-special/gehaltsuebersicht-fuer-2014-tabelle-it-berufe/8934336-5.html\n\n", "id": "d5t4kv9"}, {"comment": "Ok so 70,000 euros are about 77000 USD in the US. \n\nI don't know to me, that just seems really low for someone who has that much experience. Our tax is significantly lower than tax in Germany as well. \n\nWhat is the average rent in the areas where people can get 70k in Germany? Also, what is the average cost for lunch around those areas? ", "id": "d5t614k"}, {"comment": "Well, the 70k brutto are 40k\u20ac net for a single worker without kids + unmarried.\n\nHealth insurance, social insurance, pension plan etc is alreay paid then.\n\nHire & fire leads to higher incomes in general and fees for schools, university etc are much more expensive afaik in the US (in germany 290\u20ac per semester = 580\u20ac university fees per year).\n\nAlso you don't need a car because of a good public transport system, go by train/bus/bike or just by foot, I walk 20 minutes to my job at the moment and if my bike gets repaired it would be 10 minutes.\n\nRent is per square meter, here is a map of germany from 2015 - https://mietercoach.files.wordpress.com/2015/04/deutschlandmap-mietspiegelv4.jpg.\n\nIf you don't live in Munich, Stuttgart or Hamburg I would say 6-7\u20ac per square meter cold, add 3\u20ac for heating and stuff and you are up to ~10\u20ac per sq\u00b2.\n\nLunch depends on the city but I would say 7-10\u20ac for lunch + drink if you want to dine somewhere (most places have lunchtime cards with lower prices), a D\u00f6ner or similar would be 3\u20ac.", "id": "d5t8mxt"}, {"comment": "The logic behind this callback function should be obvious to even the most dim-witted individual... who holds an advanced degree in hyperbolic topology!\n\n\n\nP.s this is an ordinary square.\n\n\n\nEdit: looks like the down voters missed the Simpson's reference here. Has anyone seen the movie tron?", "id": "d5r68ah"}, {"comment": "ha I love that episode", "id": "d5rdl3j"}], [{"comment": "I appreciate the article, but am somewhat confused...\n\nI am a physics PhD student that spends ~8 hours a day programming (including weekends). I'll be the first to admit that my code is not as pretty as it could be, but I take time to learn everything I can about the languages I use. In fact, I love physics because it hits the sweet spot for me when it comes to programming: low-level, HPC work. I never have to worry about GUI's, user friendliness, or the chaos of web development, and it's awesome!\n\nThat said, industry tackles different problems than academia. I get that, but it seems odd to me to put someone who has years of demonstrable programming experience in another field in the same box as someone who just learned python yesterday.", "id": "d5r3k5p"}, {"comment": "What you said reminded me of a conversation I had with a friend of mine, who had seen a few programs a few aeronautical engineers in my college had written, he was saying while those guys were strong on math, they had a few tricky CS concepts that tripped them like how to do a proper map-reduce of the problem and other non-theory stuff like version control. \n\nWondering if this was a one off instance or is this common?\n\nEdit: Meant to say version control is a non-theoritical stuff as compared to map-reduce.", "id": "d5r49ro"}, {"comment": "I mean, this is highly dependent on the researcher. I would make a distinction here between a standard engineer and someone who works on HPC's, but that's a side point (I cannot speak for engineers). For the most part, researchers learn to code what they need on the job. This means that they know plenty of algorithms that CS students would not typically know. Of course, it goes both ways... CS students know plenty of algorithms that certain types of researchers would not know.\n\nThat said, most computational researchers (I know) are in the business of making as efficient code as possible. With code that is typically running for weeks on a cluster, any little optimization could mean days of runtime difference. \n\nAs far as version control is concerned, I could not imagine living without it and don't know many computational scientists who could. ", "id": "d5r4oop"}, {"comment": "Someone with your background probably wouldn't be \"in the same box as someone who just learned python yesterday.\"  At least at the big tech companies, you'd probably be treated about like a new CS grad in terms of getting an interview, and then the interview would determine whether you were hired, and at what level.", "id": "d5r55gs"}, {"comment": "Yeah - the best way is to put the skills to the test. If anyone has the motivation to learn industry-level skill, they'll be able to pass the coding interview. That's why companies have them.", "id": "d5r3o2v"}, {"comment": "In my personal experience (and from your post you don't seem to be one of these guys), physicist programmers write atrocious code from a quality standpoint. They have very little formal training in software engineering or architecture,  so things like naming, error handling, data structures, separation of concerns and general architecture of their code are way off.  Basically, they are coding-savages that leave a huge mess behind for anyone that has to maintain their code afterwards", "id": "d5r9p0s"}, {"comment": "Too true, absolute nightmare. Pure arrogance and lack of care with a, \"that'll do\" attitude produces awful code.", "id": "d5s37dl"}], [{"comment": "I do agree that everybody might have the potential to be a programmer. I see it in the companies where I worked, half of them had a non programming background (history, biology, educator all at university levels) which they mostly didn't finish or couldn't find a job for what they learnt for. But you can see that they did have interest in computing already as a hobby mostly, but they never thought of making it their job. And because there's so much more work and money to make in the IT programming it was quite simple for them to enter that field.\n\nWhat I did see that the one who had an educator background and jumped blindly into programming that - with all respect - her code was not so nice to say it friendly. She had never learnt about design patterns, never heard about making proper variable naming, massive methods with 1000's lines of code, 20 arguments per method et cetera and nobody told her in the company that she was writing piles of bad code. She was delivering fast and as everybody knows, your boss/company doesn't care how you do it (mostly); they have to make money fast. I know her code is bad because when I joined the company I had/have to maintain it and it is still a hell to maintain, although it is a dying project (for several reasons).\n\nWhile on the other hand the colleague with a biology background at another company I worked for writes perfectly clean and documented code and you don't have to tell him how he should program. He wants to write nice and clean code and reads a lot of best practices online.\n\nThese are just some personal examples and actually theoretically I think in every company I was in I was the only one with the proper theoretical background in programming (did my bachelor in IT/software design/programming/etc). And in practice my experience is that other colleagues can be as good or bad with without any background in IT. Quite often I hear stories from colleagues that worked for other companies that they had terrible colleagues writing really bad code. These 'bad programmers' were just in it for the money and because there is/was no real requirements in a lot of companies doing IT (\"You can do Java and Javascript and Angular and some fancy tools? You're accepted\") like in most other professions which are more a sort of 'protected'. Try to apply for a physiotherapist job without proper certificates or try applying for a carpenter job without any educational background in it.\n\nThat's a bit the strange thing with IT and programming: everybody can just sit in front of his computer and do online courses in programming and learn by trail and error and can achieve very good skills. I actually think that's more and more the future; people educate themselves more and more online in a lot of professions by reading and watching YouTube videos and try them at home. \n\nBecause there is so much work for programmers I don't worry yet, but if there were a very limited amount of programming jobs and you see that people from everywhere with no IT background enter your field and write horrible code it would feel like stealing jobs and coming away while making a mess of it. It would be the same like everybody becoming a carpenter without proper education and theory/experience and making thing which fall apart after a few years and you with the proper background/education/theory knowing that if you would've built it it would be stable and solid.", "id": "d5r6gdp"}], [{"comment": "A very significant proportion of the first generations of programmers came from physics. Simply because this is where computers were used mostly (besides finance/accounting). Just look at how much of the important stuff came from CERN (web included).", "id": "d5r8jfb"}], [{"comment": "yes but what about *from psychology*?", "id": "d5r624i"}, {"comment": "Nearby university has a dual CS Psychology masters program (that leads into a Psych PhD). I'm not entirely sure how it works.", "id": "d5r7atk"}, {"comment": "It's to train psychs specifically to deal with the massive amount of burned-out depressed computer programmers, obviously! :P (except psychology PhDs are not MDs)\n\n/s, but also not really /s", "id": "d5r9zsk"}, {"comment": "Sounds like an MSc in Social Engineering.", "id": "d5r946g"}, {"comment": "I thought it'd be AI/neuroscience, but it's supposedly just cognitive psychology using computational techniques.", "id": "d5r9cei"}, {"comment": "I study cognition and media science, 50% psychology, 50% CS.\n\nIn the end you have no real clue of both fields (like with most Bachelor things) and need a master to specialise in one field, but I like it so far.", "id": "d5rbknb"}], [{"comment": "Programmer with a degree in Literae Humaniores (Latin, Greek, history, philosophy, all that jazz) here... I dreamed of having skills as relevant as those of an astrophysicist.", "id": "d5r8xgs"}], [{"comment": "The post completely misses the point of which people do and don't get hired for which types of job. It's not uncommon at all to find people in the industry who switched from for example chemistry or physics to software development. I worked at a small company for 10 years that had 2 chemists, 1 physicist and 1 astrophysics graduate working as software developers. \n\nThe problem is that having done 8 years of  physics research, even doing programming most of the day, is not really much relevant experience. And many of these people do expect to be paid more than a recent CS grad simply because they feel their 8 years of experience is relevant. I mean, it's programming right? \n\nJust because you're \"doing programming\" doesn't mean you actually grow as a software engineer. Something many developers run into when they want to switch after working for the same company for 10 years and then finding out they've hardly learning anything new. ", "id": "d5r9f74"}], [{"comment": "> How did you do on the HackerRank challenges?\n\nIt was interesting up until that point, then it just became a low effort advertisement for HackerRank. Although I'm kind of impressed at how many times they managed to get the word HackerRank into such a short amount of lines.", "id": "d5ra589"}], [{"comment": "At first I thought the title said Astrology..", "id": "d5r2gv6"}]]], "4dgyqt": ["Microsoft needs Visual Studio proper to be on Mac and Linux", "2016-04-05 19:38:56", 0, "https://baltimoregun.club/microsoft-needs-visual-studio-proper-to-be-on-osx-and-linux-immediately-ee733cfb3069#.z1v8cb35a", [[6, "I think that in the next five years, Visual Studio will be on Mac and Linux as first-class citizens.\n\nObviously, that's a long time, but Microsoft seem quite open to the idea of competitors stepping up, which is where I think JetBrains will step up with [Project Rider](https://www.jetbrains.com/rider/).\n\nEither way, VS on Mac/Linux won't be a direct port, nor should it be. I think the interface will be native for both, with Microsoft looking for the underlying functionality to be separated out enough so that they can be reusable across all platforms."], [6, "I don't believe it's such a massive issue for a couple of reasons. First is that Xamarin Studio / MonoDevelop isn't that bad. I use Visual Studio by day and XS by night and is perfectly usable. XS isn't near Visual Studio n terms of quality yet but to call it a \"mess\" is unfair IMHO. It does what it's supposed to do.\n\nSecondly, there are very good options for using Visual Studio on the Mac at least, like Parallels with Cohesion mode (appears to be a regular Mac app) which also works extremely well.\n\nFor at least these reasons and probably others I don't know about, I'd be very surprised if Microsoft makes this a priority any time soon."], [3, "> The Electron-based editor is fast\n\npeople obviously never used QtCreator"], [2, "If MSFT doesn't 'do an Apple' and base Windows on an open-source OS having a proprietary DeskTop on top of that, they are lost.\n\nThey don't have man-hours available to do all the work and keep it current. By 'offloading' the underlying OS to the open-source guys, they get to have enough developers to keep the Windows Desktop current.\n\nWindows development is becoming a dead-end, the more the Windows environment is diverging away from the mainstream UNIX and UNIX-like OSs (Linux, OSX, BSD)"], [1, "If Microsoft releases the NT kernel and all of the Windows components as open source before the potential irrelevancy of Windows and NT if it ends up getting worse in that area for Microsoft, then I will believe that they are going all the way. Otherwise it may be too little and too late.\n"], [1, "Been telling them this for literally years now. Unfortunately, I have very little administrative authority there. :)"], [1, "This is what visual studio code is for. It's a ground up re-implementation of visual studio separating the IDE/Editor from the compiler. It can already do syntax highlighting and error checking for c++, C#, javascript, and a few others.\n\nhttp://stackoverflow.com/questions/30269449/how-do-i-set-up-vscode-to-compile-c-code\n\n"], [1, "It doesn't need to be a full-blown VisualStudio.  \nThe future of the .NET development should and will be more lightweight, and **convention driven**.  \nI think that is their purpose behind *VisualStudio Code*.\n\n**What I think Microsoft should do is to buy Jetbrains**, and revolutionize their development product offerings. Most people will hate the idea of Jetbrains being bought out by the evil Microsoft.  \n\nBut I think doing so can offer a lot to each other, and to the community as well.  "]], [[{"comment": "I think that in the next five years, Visual Studio will be on Mac and Linux as first-class citizens.\n\nObviously, that's a long time, but Microsoft seem quite open to the idea of competitors stepping up, which is where I think JetBrains will step up with [Project Rider](https://www.jetbrains.com/rider/).\n\nEither way, VS on Mac/Linux won't be a direct port, nor should it be. I think the interface will be native for both, with Microsoft looking for the underlying functionality to be separated out enough so that they can be reusable across all platforms.", "id": "d1qtill"}, {"comment": "I've actually been watching Rider's EAP quite closely, not least because I've been a pretty big JetBrains cheerleader for years.\n\nAs Visual Studio has adopted a lot of Resharper's features over the years between versions, I can sort of see how having Resharper's engine plug in to the Intellij core should have pretty extensive support for a lot of the .NET world.  In practice though, the (albeit very early) versions of Rider have highlighted to me just how far they still need to go with it (debugging was particularly patchy last I tried), but I'm hopeful nonetheless.", "id": "d1rw950"}], [{"comment": "I don't believe it's such a massive issue for a couple of reasons. First is that Xamarin Studio / MonoDevelop isn't that bad. I use Visual Studio by day and XS by night and is perfectly usable. XS isn't near Visual Studio n terms of quality yet but to call it a \"mess\" is unfair IMHO. It does what it's supposed to do.\n\nSecondly, there are very good options for using Visual Studio on the Mac at least, like Parallels with Cohesion mode (appears to be a regular Mac app) which also works extremely well.\n\nFor at least these reasons and probably others I don't know about, I'd be very surprised if Microsoft makes this a priority any time soon.", "id": "d1r1ay5"}, {"comment": "Am I being unfair to XS here? (legitimately?)\n\nIt's just that everytime I've tried to go back to it I'm reminded of how much it has (at least to my perception) stagnated.\n\nObviously now that Xamarin has been bought over and made freely available for most folks the expectation would be that the Visual Studio support is an even greater priority.\n\nI do wonder if this kind of re-enforces the point, though.  If XS were to languish (I'm not saying it will, I have no idea what MS's priorities are), then it would stand to reason that this could very well backfire on Microsoft.\n\nIf the goal is to bring iOS/Android developers into the .NET eco-system, the hurdles need to be as low as possible.\n\nPersonally speaking, I'm quite a fan of Parallels (although I'm not on OSX at the minute), but I can't imagine installing Studio, in Windows, in a VM, in Parallels is anyone's idea of fun if they didn't have that VM up-and-running already for other reasons (I suspect you and I are outliers ;-).)", "id": "d1rwftc"}], [{"comment": "> The Electron-based editor is fast\n\npeople obviously never used QtCreator", "id": "d1r2z2y"}, {"comment": "I think the reason is people only tend to use qtcreator for making qt apps instead of general c/c++ development. ", "id": "d1rc9uh"}], [{"comment": "If MSFT doesn't 'do an Apple' and base Windows on an open-source OS having a proprietary DeskTop on top of that, they are lost.\n\nThey don't have man-hours available to do all the work and keep it current. By 'offloading' the underlying OS to the open-source guys, they get to have enough developers to keep the Windows Desktop current.\n\nWindows development is becoming a dead-end, the more the Windows environment is diverging away from the mainstream UNIX and UNIX-like OSs (Linux, OSX, BSD)", "id": "d1rpxaq"}, {"comment": "This had not occurred to me before, and it makes a lot of sense.\n\nAside from the obvious technical challenges in achieving a move from NT to some flavor of Unix (is this why Bash-on-Windows was just announced?), I do wonder if the dichotomy of their business model now (free for consumers, paid for businesses) would make them see moving to a Unix core as a significant threat to their core business.\n\nWould it put them in direct competition with Red Hat in the enterprise space?  Would they see it that way even if it weren't really the case?\n\nOnce again I'm convinced that Satya Nadella has the least enviable job in tech right now.", "id": "d1rwmkh"}, {"comment": "I suggested that MSFT 'do an Apple' to a bunch of MSFT workers about 10 years back. They were too intoxicated on the MSFT Kool-Aid to even consider the idea. I wonder if they are still working there.\n\n> Would it put them in direct competition with Red Hat in the enterprise space?\n\nThey've always been in competition with Red Hat in the business areas. I would see Windows with a unix-like foundation as being much the same as OSX. Only the users and developers who actually need/want to get down under the hood into the unix workings would ever see that layer. All the rest of the Windows users would be quite satisfied with the familiar Windows GUI layer.", "id": "d1s23t9"}], [{"comment": "If Microsoft releases the NT kernel and all of the Windows components as open source before the potential irrelevancy of Windows and NT if it ends up getting worse in that area for Microsoft, then I will believe that they are going all the way. Otherwise it may be too little and too late.\n", "id": "d1qt0to"}, {"comment": "The NT kernel is a sidetrack away from the mainstream unix-style OSs. Even if open-sourced, it is too out-of-fashion to be usefully worked on.", "id": "d1rq0q1"}, {"comment": "Couldn't pretty much the same be said about BSD? Sure, it's a UNIX, but it really doesn't seem fashionable.", "id": "d1ry8gm"}, {"comment": "The mainstream OSs of today are the UNIX-style OSs. NT is too different from them to garner lots of developers, comparatively speaking. Anybody who is au-fait with Linux (say) could get up to speed very quickly if faced with BSD.", "id": "d1s1y17"}, {"comment": "Could? I guess. Would? I think that's the important question.", "id": "d1so6za"}, {"comment": "I'm not so sure. The BSDs tend to be lumped in with Linux overall, and they're sitting at reasonable levels (23, 53, 68, 80) in the top 100 distros. There have been several new version releases of the BSDs quite recently.\n\nBecause they're mainly used as servers, they are more 'invisible' than the user-level OSs.", "id": "d1srefy"}], [{"comment": "Been telling them this for literally years now. Unfortunately, I have very little administrative authority there. :)", "id": "d1r8dyn"}, {"comment": "Mark? GET BACK TO WORK.", "id": "d1rn2ub"}], [{"comment": "This is what visual studio code is for. It's a ground up re-implementation of visual studio separating the IDE/Editor from the compiler. It can already do syntax highlighting and error checking for c++, C#, javascript, and a few others.\n\nhttp://stackoverflow.com/questions/30269449/how-do-i-set-up-vscode-to-compile-c-code\n\n", "id": "d1s3ega"}], [{"comment": "It doesn't need to be a full-blown VisualStudio.  \nThe future of the .NET development should and will be more lightweight, and **convention driven**.  \nI think that is their purpose behind *VisualStudio Code*.\n\n**What I think Microsoft should do is to buy Jetbrains**, and revolutionize their development product offerings. Most people will hate the idea of Jetbrains being bought out by the evil Microsoft.  \n\nBut I think doing so can offer a lot to each other, and to the community as well.  ", "id": "d1ykyrg"}]]], "41dvex": ["C or C++ for my game engine?", "2016-01-17 18:08:02", 2, "http://crafn.kapsi.fi/new_engine.html", [[11, "80kloc taking 15 minute to build, multiple Gbytes of memory and a minute to link? I'd blame the programmer, or a specific choice of tools, rather than C++. Modern C++ compilers and linkers are fast. 80kloc shouldn't take more than a few 10s of seconds to compile & link overall."], [8, "> When using OOP, like the idiomatic C++ coder does\n\nThere's no need to jail oneself into using OOP with C++. In fact, there's very little OOP in idiomatic, modern C++ code.\n\nAlso, I'm not sure why DLLs are coming up so often in the article? What do you use them for and why?\n\nAlso, while the criticism towards std-containers is somewhat valid, I think most of the games can use the basic containers without many issues. Surely there are cases where you need to pay some extra attention to allocs/deallocs/copying, but are quite easy to optimize locally.\n"], [9, "> Safety-enforcing languages like Rust are going somewhat off already by definition, as they're focusing primarily on safety, which is not the focus for most game code.\n\nI don't develop games, so I'd like to ask: is correctness not a goal? How can you ensure that you game moves forwards smoothly if you cannot rely on the building blocks you use?"], [6, "> it's popular to resolve the C vs. C++ problem by saying that \"with C++ you only pay for what you use.\" That's false even in the limiting case, where the code is written using the common subset of C and C++, and just using a C++ compiler will make my future options worse, as we'll see.\n\nThat's how I resolve it. I'm pretty sure you can live-reload DLLs in C++ too, you can expose a C API (I called a C++ lib from LuaJIT's FFI this way), and if those pay-as-you-go C++ features bug you so much, you can write C++ in the style of idiomatic C.\n\nI really don't get why people force themselves to use C when C++ is mostly a superset of C."], [2, ">I can't really run the game in Valgrind to find memory errors, because it's unplayably slow, like several seconds per frame.\n\nSounds like OP needs to try AddressSanitizer et al."], [0, "I am writing a project in C that has over 85kloc in 91 source files. My full compile of every line to .exe takes 21 seconds and compiling a few sources plus link time is normally less than 1 second (the normal case). I am not happy with the compile times I currently get so I can't even imagine how you can write code with 10-20 second incremental and 5 minute total rebuild times.\n\nI agree with most of your article (about choosing C for now) BUT Jon Blow is creating a new language to create games with that you should take a look at."], [1, "Serious: Can't you just use a fast enough (sat) solver as the game engine?\n\nExcuse my ignorance, I never developed any cool game. Nothing except a toy voxel octree game."], [-1, "> I have to choose between writing duplicated code, writing a code generator, or tedious macro stuff for generic code.\n\nCode-generation all the way. Use an expressive language like python/lua/tcl/lisp/scheme to work on a higher layer than C.\n\nTwo-language programming (one GC scripting, the other C) beats the heck out of C++, in terms of best of both worlds: expressivity in higher layer, performance in lower layer.\n\nC++ has a dirty secret no one likes to talk about. Stroustrup himself was a two-language programmer. C++ was C with classes where the classes were built with unhygienic C macros. When he decided to show his work to \"average joe programmers\" of the world, he turned it into one language (it turned out he was not a very good language designer so the world has to live with it).\n\nIf you're working with C++ you are Stroustrup's average-joe customer.\n\nIf you're working with two-language programming you're Stroustrup himself (even better cz you're using a higher language way better than the C macro system)!"]], [[{"comment": "80kloc taking 15 minute to build, multiple Gbytes of memory and a minute to link? I'd blame the programmer, or a specific choice of tools, rather than C++. Modern C++ compilers and linkers are fast. 80kloc shouldn't take more than a few 10s of seconds to compile & link overall.", "id": "cz1ngn4"}, {"comment": "Most likely circular dependencies in headers.", "id": "cz1znsd"}], [{"comment": "> When using OOP, like the idiomatic C++ coder does\n\nThere's no need to jail oneself into using OOP with C++. In fact, there's very little OOP in idiomatic, modern C++ code.\n\nAlso, I'm not sure why DLLs are coming up so often in the article? What do you use them for and why?\n\nAlso, while the criticism towards std-containers is somewhat valid, I think most of the games can use the basic containers without many issues. Surely there are cases where you need to pay some extra attention to allocs/deallocs/copying, but are quite easy to optimize locally.\n", "id": "cz1k1uj"}, {"comment": "> Also, I'm not sure why DLLs are coming up so often in the article? What do you use them for and why?\n\nThe author uses dlls to do some advanced form of hot code reloading. The idea is that you can modify parts of the code without actually restarting the game by keeping most of the game code in a dll that is reloaded when changed.", "id": "cz1k54k"}, {"comment": "Does he not know to write a backend and then implement gameplay logic in an embedded script interpreter?", "id": "cz1zytz"}, {"comment": "he covers scripting languages in the first part of the article...", "id": "cz219ad"}, {"comment": "Different use case. There he's talking about prototyping in a dynamic language then implementing the prototype in C.\n\nI was referring to embedding an interpreter to handle gameplay logic  and NOT removing it (which is the usual way to solve this problem in a commercial game: they almost all run scripts on top of C++).", "id": "cz23g19"}], [{"comment": "> Safety-enforcing languages like Rust are going somewhat off already by definition, as they're focusing primarily on safety, which is not the focus for most game code.\n\nI don't develop games, so I'd like to ask: is correctness not a goal? How can you ensure that you game moves forwards smoothly if you cannot rely on the building blocks you use?", "id": "cz1lxxh"}, {"comment": "> is correctness not a goal?\n\nNO. Creating a working game is the goal. Whatever methods get us there is what we use. Time scale is also critical to keep in mind. Something that makes it longer to get a working product out gets multiplied by 2-5 years of development. This is why most game programmers aren't thrilled with rust. It adds too much friction toward getting things done.\n\nAlso, I've been a programmer long enough to remember when \"formal correctness\" demanded everything be strictly OOP with hierarchical class inheritance. It seems what is \"correct\" changes every decade or so.", "id": "cz1sdcy"}, {"comment": "> Also, I've been a programmer long enough to remember when \"formal correctness\" demanded everything be strictly OOP with hierarchical class inheritance. It seems what is \"correct\" changes every decade or so.\n\nThat kind of \"formal correctness\" is about programmer discipline. And it sucks. A language providing an expressive typesystem which helps you to *encode* intent rather than creating intent through side-effects is a different matter, and something of interest to other long-time programmers and game-devs.\n", "id": "cz20suv"}, {"comment": "> I don't develop games, so I'd like to ask: is correctness not a goal? How can you ensure that you game moves forwards smoothly if you cannot rely on the building blocks you use?\n\nThe pros care _a lot_ about correctness. See [this QuakeCon 2013 keynote](https://www.youtube.com/watch?v=1PhArSujR_A) from John Carmack and [Tim Sweeney's 2006 POPL presentation](http://lambda-the-ultimate.org/node/1277). Tim worked with colleagues at Intel Labs to define a new language, [Lambda Aleph](http://www.leafpetersen.com/leaf/publications/dtp2013/lambda-aleph-overview.pdf), but I don't know of any available code. However, if you narrow the description of it to \"not-lazy dependently-typed Haskell,\" it rather strongly resembles [Idris](http://www.idris-lang.org/).\n\nHaving been in the game industry myself, the moment someone says \"they're focusing primarily on safety, which is not the focus for most game code,\" I check out, because the author is fundamentally unserious about tournament play, cheaters, prizes... i.e. the entirety of the economy around a successful title.", "id": "cz1nyan"}, {"comment": "For single developers there are many more profitable options that don't revolve around multiplayer at all. Like, really, tournament play for a guy making a game on his own by himself? You should consider context when reading things and not bashing people because you can't understand where they're coming from.", "id": "cz20g1l"}, {"comment": "OK. What's a context in which _correctness_ doesn't matter?\n\nI fully expect an answer along the lines of \"correctness is one value to be weighed against others, such as time-to-market.\" That's fine, as far as it goes. But it falls squarely within the ambit of [/u/matthieum](https://www.reddit.com/user/matthieum)'s [question](https://www.reddit.com/r/programming/comments/41dvex/c_or_c_for_my_game_engine/cz1lxxh). In 2016, using C or C++ for _anything_, including a game engine, needs justification, because \"they're the only languages offering adequate performance, especially with respect to memory management, so the trade-offs are inescapable\" is false, and has been for several years.\n\nAs for specifics that may or may not be relevant today, e.g. networked tournament play, they're a tiny subset of motivations to be concerned about correctness, and ignoring correctness in the short term can very easily limit your options in the longer term. It can even immediately impact your revenue, e.g. when you publish your little indie title on Steam for what would otherwise be a reasonable price, but it crashes enough that you get a few bad reviews, and once you lose a chunk of your audience, getting them back is nigh-impossible, and suddenly your ticket out of your dead-end desk job isn't paying your rent. Obviously, substitute whatever goal you might actually have had here, unless it's literally just to develop a game engine for your own education, in which case correctness problems can certainly be... educational.\n\nSo my problem isn't that I'm not taking context into account. On the contrary; I'm taking a _larger_ context into account. If there's one thing I would caution all programmers against\u2014but especially programmers undertaking something this ambitious\u2014it's shortsightedness, and choosing C or C++ in January of 2016 is all but guaranteed to be shortsighted.", "id": "cz21oy8"}, {"comment": "I agree with your main point about C/C++ and disagree with the author on this too. And I agree with you that correctness matters. But I disagree with you on how much it matters taking the scope of his project in consideration. \n\nIn regards to matthieum's question, in my opinion, for an indie game of around 100k lines which is what the author is looking at, not being able to rely on the building blocks you have is something that won't happen that often. Engine code tends to stabilize pretty heavily after a while and part of gameplay code goes through a similar process but at a slower rate and at less predictable places. After most of this happens though you've run your game so many times that it's very unlikely you've missed something crucial that causes lots of crashes you (and most people who played the game before you released) previously just happened to miss. And this is especially true considering that the scope of a little indie game is... little, and so manual ad-hoc testing performs a lot better than it would if your scope or code base was a lot bigger.\n\nIn my opinion when you're working with a smaller code base it's the one time you have to be more relaxed about correctness in favor of development speed and not making use of this trade-off properly is a huge mistake that IMO far outweighs the cons of lowered correctness (like possibly higher bug rates). Plus, one important thing to keep in mind is what the author mentioned regarding his mental state while developing a game:\n\n>This leads to the point: maintaining interest, motivation, is the primary focus for me, because when I lose interest, my productivity drops to zero, maybe for months. Anything which merely deviates my productivity is secondary. Therefore, when I compare the languages I mostly focus on issues which make me frustrated, or incur mental overhead. Some people are not so easily frustrated. Good for them.\n\nLike the author, I feel like the most important thing about working on a project alone is that motivation has to remain high or you just won't get it done. So this plays a huge part into the choices people make, and especially the choices the author made in regards to what he decided to use. So even if I disagree with his use of C I can understand where he's coming from from a motivation perspective, which is something that shouldn't be downplayed at all and that I think is probably more important than your language of choice even. But this is a bit off-topic in relation to our discussion I guess...", "id": "cz2347y"}, {"comment": "> But this is a bit off-topic in relation to our discussion I guess...\n\nMaybe, but a thoughtful reminder of crucial points nevertheless. I did indeed project my own excitement at the prospect of learning a new language and/or feeling less concerned about bugs onto the author without warrant. Thanks for the well-stated follow-up!", "id": "cz2431h"}, {"comment": "Correctness/safety is definitely a goal, but rejected more readily compared to other areas of software engineering if the way it is achieved implies a potential performance penalty.", "id": "cz2ilda"}], [{"comment": "> it's popular to resolve the C vs. C++ problem by saying that \"with C++ you only pay for what you use.\" That's false even in the limiting case, where the code is written using the common subset of C and C++, and just using a C++ compiler will make my future options worse, as we'll see.\n\nThat's how I resolve it. I'm pretty sure you can live-reload DLLs in C++ too, you can expose a C API (I called a C++ lib from LuaJIT's FFI this way), and if those pay-as-you-go C++ features bug you so much, you can write C++ in the style of idiomatic C.\n\nI really don't get why people force themselves to use C when C++ is mostly a superset of C.", "id": "cz1jt92"}, {"comment": "> I really don't get why people force themselves to use C when C++ is mostly a superset of C.\n\nI was a C++ user for a decade who switched to pure C, so I can answer that..\n\n1. Compile times. If you include any STL file at all then you've probably bloated your compile time to 5x of a similar C file.\n\n2. There are a few features which really are C-only (struct initialization syntax), and writing `export \"C\"` for DLLs is a minor annoyance.\n\n3. But here's the significant reason. In the Python philosophy, one of the goals is \"there should be only one way to do it\". C follows this philosophy pretty well, and C++ blatantly does not. When you have more than one way to do the same thing, you expend brainpower deciding which one to use, and then it's pretty common that you want to change your mind later in the project.\n\nSo even if you are writing \"C with classes\", you still have to decide when to say, use member functions vs free functions, and then you still might get the urge to change it later. And all of that effort is pretty much wasted brainpower, you're not solving any real problems when you spend time on that. Fewer language options means the initial implementation is more straightforward and less likely to need a refactor later.", "id": "cz1khs9"}, {"comment": ">\"there should be only one way to do it\". C follows this philosophy pretty well, and C++ blatantly does not.\n\nIn c++ in the multiple ways to do things I thought there were generally trade offs between the different ways to do things.\n\nIn something like python I can understand that execution speed isn't generally a priority of a scripting language so multiple choices hardly matter.\n\nC is so low level that there really arn't choices, where C++ is higher level and the features could be made in C it's just that C++ has them as a choice.\n\nFeel free to tell me if I'm wrong because I very well may be.", "id": "cz1sllv"}], [{"comment": ">I can't really run the game in Valgrind to find memory errors, because it's unplayably slow, like several seconds per frame.\n\nSounds like OP needs to try AddressSanitizer et al.", "id": "cz1q25k"}], [{"comment": "I am writing a project in C that has over 85kloc in 91 source files. My full compile of every line to .exe takes 21 seconds and compiling a few sources plus link time is normally less than 1 second (the normal case). I am not happy with the compile times I currently get so I can't even imagine how you can write code with 10-20 second incremental and 5 minute total rebuild times.\n\nI agree with most of your article (about choosing C for now) BUT Jon Blow is creating a new language to create games with that you should take a look at.", "id": "cz1lucf"}], [{"comment": "Serious: Can't you just use a fast enough (sat) solver as the game engine?\n\nExcuse my ignorance, I never developed any cool game. Nothing except a toy voxel octree game.", "id": "cz28h3p"}], [{"comment": "> I have to choose between writing duplicated code, writing a code generator, or tedious macro stuff for generic code.\n\nCode-generation all the way. Use an expressive language like python/lua/tcl/lisp/scheme to work on a higher layer than C.\n\nTwo-language programming (one GC scripting, the other C) beats the heck out of C++, in terms of best of both worlds: expressivity in higher layer, performance in lower layer.\n\nC++ has a dirty secret no one likes to talk about. Stroustrup himself was a two-language programmer. C++ was C with classes where the classes were built with unhygienic C macros. When he decided to show his work to \"average joe programmers\" of the world, he turned it into one language (it turned out he was not a very good language designer so the world has to live with it).\n\nIf you're working with C++ you are Stroustrup's average-joe customer.\n\nIf you're working with two-language programming you're Stroustrup himself (even better cz you're using a higher language way better than the C macro system)!", "id": "cz2cs68"}]]], "57h33q": ["Arguing against Open-Source (Shen programming language goes Closed-Source)", "2016-10-14 20:00:56", 0, "http://www.marktarver.com/open.html", [[33, "This author man, he seems so douchey.\n\n\n>Now I will warn you that in the next paragraphs open source is going to be shredded\n\n>Also I hope that people are not going to try to save this discredited ideology from being led to the scaffold. Take heart, I am in fact only executing a corpse in what I am going to say in the next messages.\n\njesus christ. "], [29, "His goal is to make money. He decided it's easier for him to do without leaving his code open-source. Good for him.\n\nI'll tell you though, I will never choose a closed-source programming language. There are too many high-quality open-source options, there is no need to put your project at the mercy and whims of a closed-source owner. "], [22, "Weirdly entitled opinion and proclamations of 90% of programmers never understanding the majestic beauty of whatever he's created. Whenever someone thinks that way I like to remind myself\n\n> \u201cRight. I don\u2019t believe in the idea that there are a few peculiar people capable of understanding math, and the rest of the world is normal. Math is a human discovery, and it\u2019s no more complicated than humans can understand. I had a calculus book once that said, \u2018What one fool can do, another can.\u2019 What we\u2019ve been able to work out about nature may look abstract and threatening to someone who hasn\u2019t studied it, but it was fools who did it, and in the next generation, all the fools will understand it. There\u2019s a tendency to pomposity in all this, to make it deep and profound.\u201d\n\u2013 Richard Feynman, Omni 1979\n\nSo maybe, just maybe, the author's creation isn't as great as he might like to think it is. Maybe it's not a power tool. Maybe it doesn't provide an order of magnitude advantage. Maybe it's just another regular tool invented by a regular fool."], [11, "What people don't seem to understand is that open-source isn't just for the creator's advantage, but for the user. If your source inaccessible and unchangeable from my perspective, using it is to my disadvantage as a user.\n\nIMHO, the most important things to have open-source are operating systems and drivers. The fact that many drivers are closed source makes them become incompatible and makes it impossible for users of that hardware to control the setting that hardware is used, and to fix problems themselves.\n\nFor example, when AMD acquired ATI, my perfectly good radeon had practically nonexistant direct-rendering support in Linux. My perfectly good hardware was worthless until the open-source radeon drivers were usable, at which point my card was inherently worthless compared to cheap available, cards.\n\n**TL;DR** Just because you don't get an immediate advantage from open-source doesn't mean that advantage does not exist. Open-source helps users, and it's to your advantage to help your users; however indirect it may seem."], [8, "[deleted]"], [7, "This author extremely irks me, especially the quote \n> In that time the OS initiative has accomplished bugger all\n\nFrom reading his piece, it seems like he thought that open sourcing the operating system would be free labor, whereas he can let open source contributors build things for him. Open source is not about expediting development time, it's not about letting other people do the work for you. It's about transparency, and letting others contribute where they see fit, *if* they see fit. His expectations of other people going in and doing the work were extremely unrealistic and against open source principles."], [8, "TL;DR\n\n1. You're all fucking idiots and if you weren't fucking idiots you'd be using Shen.\n2. Reddit == OS community == all fucking idiots == don't listen == has to be closed source == author has the power.\n\nCall me crazy but I don't go to Reddit for OSS news or community nor do I make software OS so I can have \"mindshare\" and be popular by doing whatever Reddit says.  This guy is basically mad at Reddit and blaming OS."], [7, "This Mark Tarver is kind of a fuckwad, isn't he?\n\n> There is a certain character you see in the West; the sort of girl who paints her nails, works at KFC and dreams of being selected for X-Factor because she sang karaoke at her friend's hen night.\n\nThere's nothing wrong with any of that.\n\n> We laugh at this because we know that for her the chances of getting mindshare and being the next Beyonce are slight.\n\nWhat kind of asshole laughs at someone for having a dream?\n\nHer chances of matching Beyonc\u00e9 are slight, but if she works at it, she has a chance at a more modest amount of success.\n\n> Everyone can dream; but when the girl goes on to neglect her education and development because she's stuck on this dream, then something has gone very wrong in her head.\n\nIn other words, if a person pursues a dream that Mark Tarver thinks they should be pursuing, something's very wrong. And that something is Mark Tarver for thinking it's his business to dictate other people's dreams.\n\n> The aspirations of the OS fanatic hooked on mindshare are often no more realistic than the neurotic checkout girl at KFC.\n\nThe person in the analogy has a dream. Depending on what she's doing, she might be ambitious, or she might be overly optimistic, but Mark Tarver has done nothing to show that she is suffering from a mental disorder involving distress but not hallucinations or delusions.\n\nFurthermore, Mark Tarver has done nothing to demonstrate that the analogy, if it even worked, applied to this case.\n\nThe wider point that this bizarre and inane analogy is intended to support is that mindshare doesn't automatically yield success. More people interested in or using your project might not accomplish other goals you have that don't relate to interest levels or usage. Which makes sense, but popularity is a goal for most open source projects with more than one contributor (and many with only one).\n\nAlso, more work can be done with more contributors, and more popularity tends to mean more contributors. It's a specific type of popularity, though, one where people think of your project, view the source as accessible, and see the project's features. OpenSSL doesn't have that. It's a utility.\n\n> ...the zeitgeist of the movement does not especially reward originality.\n\nYour project isn't about originality. It's about fulfilling a need. Originality is valuable only insofar as it provides a better way to fulfill a need, or a way to fulfill an unserved need.\n\n> OS may not empower your project and indeed with a 98% failure rate is unlikely to do so.\n\nYou could say that of closed source personal projects too.\n\n> But actually if you look at the most productive phase from 2011-2012, the 'mindshare' consisted of a handful of people.\n\nThe project had few people because it was early. Progress felt fast because it was early. He instead believes that progress was fast because the project had few people.\n\nWhen you're at the start of a project, everything you do is a big feature, and you naturally concentrate on large features that are easier to implement. When the project is more mature, you've plucked the low-hanging fruit. Also, once the project has something to support -- existing code, existing users, existing data --  it's harder to add breaking changes. That doesn't happen in the first couple weeks. For a programming language, it might not happen in the first two years.\n\nBut hey, maybe Mark Tarver has trouble being productive when other people are asking for features or criticizing him. Though the answer there isn't going closed source; to address that problem, he should stop dealing with his community. At least directly. Maybe he could get someone else to do community management instead.\n\n> If you've worked in an OS environment, you'll quickly discover that only about 2% of your users will financially support your work.\n\nAh, here it comes out. The metric of success that Mark Tarver is using is financial.\n\nIf that's what you're going for, you want investors. You want a business model. And Mark Tarver can't imagine that anyone would have a commercial business related to an open source project.\n\nMark Tarver is creating a programming language. These days, people want their programming languages to be open source. They don't pay for compilers most of the time. I don't think he's going to see much more success with a closed source compiler than with an open source one."], [7, "> Shen simply sticks out as contrary to that trend - it is original and hard to understand. \n\nHard to understand. Huh, wonder why your project failed then"], [5, "So basically this article has absolutely nothing to do with open source, it instead has to do with \"mindshare\". Basically the author argues that success is not popularity and your product doesn't people to like it to succeed.\n\nThere is perhaps a smidgen of truth to that, but that doesn't seem to be the case here with Shen, where it's just a few developers who've made a useless product that nobody else wants. The developers have deluded themselves into thinking they must be geniuses and the entire world filled with morons for not wanting it."], [4, "\nSo lets get this right. You create an OS to run Shen you make it open source and say open source doesn't work because nobody \"did it for you\"?\n\nOnly there is some really obvious reasons why this would fail.\n\n1. Almost nobody uses shen. I had never heard of it. Its not even listed on wikipedia @ https://en.wikipedia.org/wiki/List_of_programming_languages\n\n2. The last thing we need is another OS without any driver support.\n\n\n"], [3, "I find it interesting that it runs on top of SBCL and Tcl/tk instead of Allegro and MFC. I wonder why that is."], [2, "Reddit speaks back!  As somebody might have said 'It's intelligence, Jim, but not as we know it'. \nWe have:  \n\n1.  Speculations about Shen based on total ignorance of the language. \n2.  Speculations on the author's motivation expectation based on total ignorance of the author.\n3.  Feeble and unwitty attempts to insult someone.\n4   Some half-sensible remarks.\n\n'So maybe, just maybe, the author's creation isn't as great as he might like to think it is'\n\nThis is just speculation.  In the absence of hard technical information; it is just a report on the \nconsciousness of the speaker.  Maybe Clinton won the 2016 election.  If I don't tune in I won't know the answer.  \n\n\"But hey, maybe Mark Tarver has trouble being productive when other people are asking for features or criticizing him.\" \n\nYep; another 'maybe' statement.  \n\n'I get the impression that he just expected random people to make great contributions out of nowhere for free.'\n\nAnother report on speaker psychology - 'I get the impression ...' \n\nBut nope; not at all.  Sponsors bought the right to make Shen BSD.  I was paid and delivered. I think other people expected me to work for free thereafter.  I personally never expected much from OS because I'd read the background and knew the weaknesses.  It performed even worse than expected, but I was neither bitter\nnor surprised.   Had it worked I'd have been pleased and surprised.\n\n\"Closing the language doomed the project.\"\n\nUnfortunately for this analysis; the closed source version is leaving the OS version far behind.  \n\n\"That's how Red Hat's business model was then formed, to give away products for free and make money on support.\"\n\nEven Perens said in 2007 this model really didn't work that well.  Get up to speed on your reading. Look at 'The Problems of Open Source' for why this often does not fly.\n\n\"So basically this article has absolutely nothing to do with open source, it instead has to do with \"mindshare\".\"\n\nReally, what does one say? Just go back to sleep.\n\n\"<Long irrelevant rambling defence of poor KFC check out girl omitted> ... which makes sense, but popularity is a goal for \nmost open source projects with more than one contributor.\" \n\nYes; again, as already stated in the article.  And the point is?  \n\n\"\"OS may not empower your project and indeed with a 98% failure rate is unlikely to do so.\" \"You could say that of closed source personal projects too.\"\"\n\nSorry; but the failure rate for new ventures is high, but definitely 98% wouldn't be it.  Maybe 50% or so. Otherwise people would never start a company or open a shop if the odds of success were 50:1.\n\n\"Ah, here it comes out.  The metric of success that Mark Tarver is using is financial.\"\nAnnounced with an air of discovering a guilty secret.  Strange; yes it is.  A lot of people do work that way.  Shocking isn't it?\n\nAnd there you have the collected wisdom of Reddit which could fit in a very small box. One positive remark.\n\n\"His goal is to make money. He decided it's easier for him to do without leaving his code open-source. Good for him.\"\nThankyou sir or whoever you are.  An open minded attitude not reflected anywhere else in this thread.\n\nNo more time for this nonsense; I won't revisit this page.  Have fun with yourselves."]], [[{"comment": "This author man, he seems so douchey.\n\n\n>Now I will warn you that in the next paragraphs open source is going to be shredded\n\n>Also I hope that people are not going to try to save this discredited ideology from being led to the scaffold. Take heart, I am in fact only executing a corpse in what I am going to say in the next messages.\n\njesus christ. ", "id": "d8rx0fd"}, {"comment": "Indeed, he's even more douchey in the rest of the article. \n\nBut I found interesting because it shows an opinion different than the usual \"Open-Source is the best model\"", "id": "d8rx6hj"}, {"comment": "Yeah I ended up reading the whole thing too. I feel like Open Source was bad for the project because it was set up to fail. It doesn't seem like the author had any interest in managing a community or spreading the philosophy of his project. I get the impression that he just expected random people to make great contributions out of nowhere for free. \n\nAlso, his slights at reddit seem really uninformed.", "id": "d8ryzh4"}, {"comment": ">  I get the impression that he just expected random people to make great contributions out of nowhere for free.\n\nIn my view, this is really one major benefit with open source, especially with regard to programming languages: the core is more-or-less easy to do, but then you have to implement libraries in order to actually make it useful, maybe even more than once if you want your thing to be multi-platform. In my experience, just implementing BSD sockets binding for Windows and Linux is already a PITA.\n\ntbh, I only read a few sentences from the article, but this process of gathering a team of talented people won't take just 6 months; 6 years is more realistic. Especially in an already fragmented community like the general Lisp+Scheme community in which you have dozens over dozens of implementations and dialects.", "id": "d8s1pdq"}, {"comment": "He also seems to have a history of bashing on open source. Douchebaggery at its finest.", "id": "d8s4sai"}, {"comment": "There are some pretty obvious criticisms of the standby arguments for OSS, in the sense that many of the theoretical advantages they cite are rather contingent in practice. C.f. \"many eyes...\" vs. the reality of OpenSSL, and so on.\n\nBut I really don't get what this guy's point is. He opens up his extremely niche language project, nothing much happens - because *why would it?* - and then he declares it a failure of open source because that's the point he wanted to make from the beginning anyway.\n\nedit: [is this in fact the official repository for the open version of Shen](https://github.com/Shen-Language/shen-sources)? I am just shocked that people aren't lining up to contribute to this very well-known project.", "id": "d8sb58v"}, {"comment": "And weirdly he's got that whole analogy that seems to be aimed at the very idea that people would be lining up to contribute?\n\n> We laugh at this because we know that for her the chances of getting mindshare and being the next Beyonce are slight. \n\nIs he trying to say that he actually allowed himself to buy into this notion that he would get mindshare, and was let down? Because okay fair enough though it seems like he barely *tried* in the first place. Or is he just, like, setting his own project up as a strawman?", "id": "d8sbw03"}, {"comment": "> edit: is this in fact the official repository for the open version of Shen? I am just shocked that people aren't lining up to contribute to this very well-known project.\n\nlol, I consider myself to be pretty well versed in esoteric and experimental programming languages, and I'd never heard of Shen...", "id": "d8z7b4z"}, {"comment": "Not to mention he named his programming language 'God' lol \n\nhttps://en.wiktionary.org/wiki/\u795e#Definitions", "id": "d8rzdj5"}, {"comment": "I agree. What was the point of his weird little sexist vignette? I get that he's trying to make a dig of some kind at people who think Open Source projects are a good idea, but it's a pretty crap way to do it.\n\n>There is a certain character you see in the West; the sort of girl who paints her nails, works at KFC and dreams of being selected for X-Factor because she sang karaoke at her friend's hen night. We laugh at this because we know that for her the chances of getting mindshare and being the next Beyonce are slight. Everyone can dream; but when the girl goes on to neglect her education and development because she's stuck on this dream, then something has gone very wrong in her head. The aspirations of the OS fanatic hooked on mindshare are often no more realistic than the neurotic checkout girl at KFC.", "id": "d8s4bgg"}, {"comment": "I think it's ironic because the analogy just as equally applies to starting a for-profit company around a niche, closed-source language. The number of people in the world who are interested in using this kind of language is maybe 1000. The number of those people who are willing to pay for it is maybe 5%. Closing the language doomed the project.", "id": "d8s82ng"}, {"comment": "[deleted]", "id": "d8s5vo2"}, {"comment": "*If they don't get lost you just punch them hard until the problem of their existence has been solved.*\n\n\nI'll be honest, people like you are ones I try to avoid interacting with lol ", "id": "d8sa4qw"}], [{"comment": "His goal is to make money. He decided it's easier for him to do without leaving his code open-source. Good for him.\n\nI'll tell you though, I will never choose a closed-source programming language. There are too many high-quality open-source options, there is no need to put your project at the mercy and whims of a closed-source owner. ", "id": "d8rysg8"}], [{"comment": "Weirdly entitled opinion and proclamations of 90% of programmers never understanding the majestic beauty of whatever he's created. Whenever someone thinks that way I like to remind myself\n\n> \u201cRight. I don\u2019t believe in the idea that there are a few peculiar people capable of understanding math, and the rest of the world is normal. Math is a human discovery, and it\u2019s no more complicated than humans can understand. I had a calculus book once that said, \u2018What one fool can do, another can.\u2019 What we\u2019ve been able to work out about nature may look abstract and threatening to someone who hasn\u2019t studied it, but it was fools who did it, and in the next generation, all the fools will understand it. There\u2019s a tendency to pomposity in all this, to make it deep and profound.\u201d\n\u2013 Richard Feynman, Omni 1979\n\nSo maybe, just maybe, the author's creation isn't as great as he might like to think it is. Maybe it's not a power tool. Maybe it doesn't provide an order of magnitude advantage. Maybe it's just another regular tool invented by a regular fool.", "id": "d8s381x"}, {"comment": "> So maybe, just maybe, the author's creation isn't as great as he might like to think it is. Maybe it's not a power tool. Maybe it doesn't provide an order of magnitude advantage. Maybe it's just another regular tool invented by a regular fool.\n\nyep, and they are finding all the reasons to blame open source for that", "id": "d8s44o5"}], [{"comment": "What people don't seem to understand is that open-source isn't just for the creator's advantage, but for the user. If your source inaccessible and unchangeable from my perspective, using it is to my disadvantage as a user.\n\nIMHO, the most important things to have open-source are operating systems and drivers. The fact that many drivers are closed source makes them become incompatible and makes it impossible for users of that hardware to control the setting that hardware is used, and to fix problems themselves.\n\nFor example, when AMD acquired ATI, my perfectly good radeon had practically nonexistant direct-rendering support in Linux. My perfectly good hardware was worthless until the open-source radeon drivers were usable, at which point my card was inherently worthless compared to cheap available, cards.\n\n**TL;DR** Just because you don't get an immediate advantage from open-source doesn't mean that advantage does not exist. Open-source helps users, and it's to your advantage to help your users; however indirect it may seem.", "id": "d8s2n2m"}], [{"comment": "[deleted]", "id": "d8ryxqj"}, {"comment": "It also doesn't apply to Shen. They are going to start their first commerical product in shen next year. As far as it looks nobody has made anything that has made money in Shen (except maybe shen itself?)", "id": "d8s8jde"}], [{"comment": "This author extremely irks me, especially the quote \n> In that time the OS initiative has accomplished bugger all\n\nFrom reading his piece, it seems like he thought that open sourcing the operating system would be free labor, whereas he can let open source contributors build things for him. Open source is not about expediting development time, it's not about letting other people do the work for you. It's about transparency, and letting others contribute where they see fit, *if* they see fit. His expectations of other people going in and doing the work were extremely unrealistic and against open source principles.", "id": "d8s6mdr"}, {"comment": "I listened to a talk by Bob Young (Red Hat co-founder), and he explained the benefits of open source very well.\n\nThe biggest benefit in his eyes were that customers were now truly interested in the companies success. People didn't see it as this corporation who sold them stuff, they instead saw it as this group of people who built things for them. That perspective switch changes everything (people are more willing to accept understandable flaws, shifting deadlines etc).\n\nHe told a story where he met with an IBM guy who told him that a few years back in his career he realized that IBM did not sell products. Their products sucked and everyone hated them (at that time). But the customers dealt with them because IBM had an office in every major city and had much better support. On that day he started carrying around stuff like spare routers and usb drives and just random stuff to try to help the customer in literally any way. Oracle is that way currently, people who use oracle are only doing it for the support they provide (although I've heard that kinda sucks lately and oracle just all around sucks nowadays). That's how Red Hat's business model was then formed, to give away products for free and make money on support.", "id": "d8s8v7j"}, {"comment": "*he realized that IBM did not sell products. Their products sucked and everyone hated them (at that time). But the customers dealt with them because IBM had an office in every major city and had much better support. On that day he started carrying around stuff like spare routers and usb drives and just random stuff to try to help the customer in literally any way.*\n\nThat's actually really fascinating, and impressed at the response of that IBMer. ", "id": "d8sa8w1"}], [{"comment": "TL;DR\n\n1. You're all fucking idiots and if you weren't fucking idiots you'd be using Shen.\n2. Reddit == OS community == all fucking idiots == don't listen == has to be closed source == author has the power.\n\nCall me crazy but I don't go to Reddit for OSS news or community nor do I make software OS so I can have \"mindshare\" and be popular by doing whatever Reddit says.  This guy is basically mad at Reddit and blaming OS.", "id": "d8sc0be"}], [{"comment": "This Mark Tarver is kind of a fuckwad, isn't he?\n\n> There is a certain character you see in the West; the sort of girl who paints her nails, works at KFC and dreams of being selected for X-Factor because she sang karaoke at her friend's hen night.\n\nThere's nothing wrong with any of that.\n\n> We laugh at this because we know that for her the chances of getting mindshare and being the next Beyonce are slight.\n\nWhat kind of asshole laughs at someone for having a dream?\n\nHer chances of matching Beyonc\u00e9 are slight, but if she works at it, she has a chance at a more modest amount of success.\n\n> Everyone can dream; but when the girl goes on to neglect her education and development because she's stuck on this dream, then something has gone very wrong in her head.\n\nIn other words, if a person pursues a dream that Mark Tarver thinks they should be pursuing, something's very wrong. And that something is Mark Tarver for thinking it's his business to dictate other people's dreams.\n\n> The aspirations of the OS fanatic hooked on mindshare are often no more realistic than the neurotic checkout girl at KFC.\n\nThe person in the analogy has a dream. Depending on what she's doing, she might be ambitious, or she might be overly optimistic, but Mark Tarver has done nothing to show that she is suffering from a mental disorder involving distress but not hallucinations or delusions.\n\nFurthermore, Mark Tarver has done nothing to demonstrate that the analogy, if it even worked, applied to this case.\n\nThe wider point that this bizarre and inane analogy is intended to support is that mindshare doesn't automatically yield success. More people interested in or using your project might not accomplish other goals you have that don't relate to interest levels or usage. Which makes sense, but popularity is a goal for most open source projects with more than one contributor (and many with only one).\n\nAlso, more work can be done with more contributors, and more popularity tends to mean more contributors. It's a specific type of popularity, though, one where people think of your project, view the source as accessible, and see the project's features. OpenSSL doesn't have that. It's a utility.\n\n> ...the zeitgeist of the movement does not especially reward originality.\n\nYour project isn't about originality. It's about fulfilling a need. Originality is valuable only insofar as it provides a better way to fulfill a need, or a way to fulfill an unserved need.\n\n> OS may not empower your project and indeed with a 98% failure rate is unlikely to do so.\n\nYou could say that of closed source personal projects too.\n\n> But actually if you look at the most productive phase from 2011-2012, the 'mindshare' consisted of a handful of people.\n\nThe project had few people because it was early. Progress felt fast because it was early. He instead believes that progress was fast because the project had few people.\n\nWhen you're at the start of a project, everything you do is a big feature, and you naturally concentrate on large features that are easier to implement. When the project is more mature, you've plucked the low-hanging fruit. Also, once the project has something to support -- existing code, existing users, existing data --  it's harder to add breaking changes. That doesn't happen in the first couple weeks. For a programming language, it might not happen in the first two years.\n\nBut hey, maybe Mark Tarver has trouble being productive when other people are asking for features or criticizing him. Though the answer there isn't going closed source; to address that problem, he should stop dealing with his community. At least directly. Maybe he could get someone else to do community management instead.\n\n> If you've worked in an OS environment, you'll quickly discover that only about 2% of your users will financially support your work.\n\nAh, here it comes out. The metric of success that Mark Tarver is using is financial.\n\nIf that's what you're going for, you want investors. You want a business model. And Mark Tarver can't imagine that anyone would have a commercial business related to an open source project.\n\nMark Tarver is creating a programming language. These days, people want their programming languages to be open source. They don't pay for compilers most of the time. I don't think he's going to see much more success with a closed source compiler than with an open source one.", "id": "d8shw4g"}], [{"comment": "> Shen simply sticks out as contrary to that trend - it is original and hard to understand. \n\nHard to understand. Huh, wonder why your project failed then", "id": "d8s56nb"}, {"comment": "\nDamm right. I just had a look at some docs (which actually took time to time). I looked at\n\nhttp://www.shenlanguage.org/learn-shen/io.html\n\nFirst problem. The example seems crappy. Its basically doing print. Only it seems to randomly swap arguments and the way the docs are written are basically non existent.", "id": "d8t80g6"}], [{"comment": "So basically this article has absolutely nothing to do with open source, it instead has to do with \"mindshare\". Basically the author argues that success is not popularity and your product doesn't people to like it to succeed.\n\nThere is perhaps a smidgen of truth to that, but that doesn't seem to be the case here with Shen, where it's just a few developers who've made a useless product that nobody else wants. The developers have deluded themselves into thinking they must be geniuses and the entire world filled with morons for not wanting it.", "id": "d8s88af"}, {"comment": "Well, unless you're closed source, and then popularity isn't the goal.\n\nThe goal is to sell it to as many people as possi... wait a minute this sounds a lot like a word I know...", "id": "d8sc1tp"}, {"comment": "I mean with closed source you do have the opportunity to sell to less people for more money, but you still need to sell to people. And the $50/month they are charging is both really expensive and too little to make money off of the small amount of devs they want to have. (You'd need at least 100 customers a month to keep a single full time dev on)", "id": "d8sy52g"}], [{"comment": "\nSo lets get this right. You create an OS to run Shen you make it open source and say open source doesn't work because nobody \"did it for you\"?\n\nOnly there is some really obvious reasons why this would fail.\n\n1. Almost nobody uses shen. I had never heard of it. Its not even listed on wikipedia @ https://en.wikipedia.org/wiki/List_of_programming_languages\n\n2. The last thing we need is another OS without any driver support.\n\n\n", "id": "d8t8gi1"}], [{"comment": "I find it interesting that it runs on top of SBCL and Tcl/tk instead of Allegro and MFC. I wonder why that is.", "id": "d8setz9"}], [{"comment": "Reddit speaks back!  As somebody might have said 'It's intelligence, Jim, but not as we know it'. \nWe have:  \n\n1.  Speculations about Shen based on total ignorance of the language. \n2.  Speculations on the author's motivation expectation based on total ignorance of the author.\n3.  Feeble and unwitty attempts to insult someone.\n4   Some half-sensible remarks.\n\n'So maybe, just maybe, the author's creation isn't as great as he might like to think it is'\n\nThis is just speculation.  In the absence of hard technical information; it is just a report on the \nconsciousness of the speaker.  Maybe Clinton won the 2016 election.  If I don't tune in I won't know the answer.  \n\n\"But hey, maybe Mark Tarver has trouble being productive when other people are asking for features or criticizing him.\" \n\nYep; another 'maybe' statement.  \n\n'I get the impression that he just expected random people to make great contributions out of nowhere for free.'\n\nAnother report on speaker psychology - 'I get the impression ...' \n\nBut nope; not at all.  Sponsors bought the right to make Shen BSD.  I was paid and delivered. I think other people expected me to work for free thereafter.  I personally never expected much from OS because I'd read the background and knew the weaknesses.  It performed even worse than expected, but I was neither bitter\nnor surprised.   Had it worked I'd have been pleased and surprised.\n\n\"Closing the language doomed the project.\"\n\nUnfortunately for this analysis; the closed source version is leaving the OS version far behind.  \n\n\"That's how Red Hat's business model was then formed, to give away products for free and make money on support.\"\n\nEven Perens said in 2007 this model really didn't work that well.  Get up to speed on your reading. Look at 'The Problems of Open Source' for why this often does not fly.\n\n\"So basically this article has absolutely nothing to do with open source, it instead has to do with \"mindshare\".\"\n\nReally, what does one say? Just go back to sleep.\n\n\"<Long irrelevant rambling defence of poor KFC check out girl omitted> ... which makes sense, but popularity is a goal for \nmost open source projects with more than one contributor.\" \n\nYes; again, as already stated in the article.  And the point is?  \n\n\"\"OS may not empower your project and indeed with a 98% failure rate is unlikely to do so.\" \"You could say that of closed source personal projects too.\"\"\n\nSorry; but the failure rate for new ventures is high, but definitely 98% wouldn't be it.  Maybe 50% or so. Otherwise people would never start a company or open a shop if the odds of success were 50:1.\n\n\"Ah, here it comes out.  The metric of success that Mark Tarver is using is financial.\"\nAnnounced with an air of discovering a guilty secret.  Strange; yes it is.  A lot of people do work that way.  Shocking isn't it?\n\nAnd there you have the collected wisdom of Reddit which could fit in a very small box. One positive remark.\n\n\"His goal is to make money. He decided it's easier for him to do without leaving his code open-source. Good for him.\"\nThankyou sir or whoever you are.  An open minded attitude not reflected anywhere else in this thread.\n\nNo more time for this nonsense; I won't revisit this page.  Have fun with yourselves.", "id": "d9voa2e"}]]], "47e8sd": ["Microsoft to acquire Xamarin & empower more developers to build apps on any device", "2016-02-24 22:05:58", 0, "http://blogs.microsoft.com/blog/2016/02/24/do-not-delete-224/", [], []], "50tquk": ["Adding a billion numbers in Rust", "2016-09-02 19:21:46", 0, "http://pramode.in/2016/08/25/rust-add-billion-numbers/", [[31, "This just in: compilers unroll loops and fold constants.\n\nAlso, I have no idea what the author means by comparing the run time of Rust and Python. _Of course_ the Python version will be many orders of magnitude slower -- it actually _performs_ the requested computation! It would've been much more interesting if they compared it with other compiled languages."], [6, "PyPy:\n\n> time pypy -c 'reduce(lambda x,y: x+y, xrange(1000000000))'\n\n> 1.58s user 0.02s system 99% cpu 1.604 total"], [3, "I would be impressed with an optimizer that substitutes the loop with Gau\u00df' sum formula: `result = n * (n + 1) / 2`"], [1, "Now try adding bigger numbers. In Rust you'll get an overflow or panic, in Python it will just work (automatic big int promotion). I made a similar analysis comparing Crystal to Ruby, and why such comparisons are unfair: https://crystal-lang.org/2016/07/15/fibonacci-benchmark.html"], [1, "Hah sweet I made a relevant C++ program recently.\n\n[Adding 4 billion numbers in C++](https://gist.github.com/MINIMAN10000/3b5f109fa2a1cb744063b30d5b337c81)\n\nOf course I made sure the compiler couldn't just optimize away the only point of creating it, adding 4 billion numbers at run time.\n\nCore 2 Duo E8400 4 Ghz\n\nIf I modify it for 1 billion\n\n>Loops 61035 * individualsize 16384 / IPS 4000000000\n\n>Elapsed Timed: 0.15625\n\n>Additions per clock cycle: 1.6\n\n>Array Output: 999997440\n\n>Array Length: 16384\n\nEdit: Changed to 1 billion\n"], [-5, "Everyone fails this math contest question. \n\nthe sum of 1 ... n can be thought of as many pairs that sum to n: \n\n0+n\n1+n-1\n2+n-2\n...\nand so on until\nn/2 + n-n/2 and\n+ n/2 if n is odd.\n\nagain, that's n/2 * (n+1) or just (n+1(if odd))/2. We've just derived the area of a triangle. Enjoy it."]], [[{"comment": "This just in: compilers unroll loops and fold constants.\n\nAlso, I have no idea what the author means by comparing the run time of Rust and Python. _Of course_ the Python version will be many orders of magnitude slower -- it actually _performs_ the requested computation! It would've been much more interesting if they compared it with other compiled languages.", "id": "d76uuoa"}, {"comment": "> This just in: compilers unroll loops and fold constants.\n\nThe interesting part here is that as in Python the \"loop\" in Rust is a fold on a high-level lazy iterator object, not a C-style fixed-size loop. So before it can even get to the loop to unroll (or in this case constant-compile) the compiler gets rid of multiple levels of abstraction. It doesn't just match \"hey fixed-size loop with a statically computable operation\".", "id": "d76vjkz"}, {"comment": "So exactly the same as it would be in C++, the compilers for which also optimise in the same way.", "id": "d77fbz8"}, {"comment": "C++ will optimize lazy iterator use into unrolled loops and constant folding? Do you have a reference or example for that?", "id": "d77itp7"}, {"comment": "    #include <cstdint>\n    #include <numeric>\n    #include <boost/iterator/counting_iterator.hpp>\n\n    uint64_t f() {\n        return std::accumulate(boost::counting_iterator<uint64_t>(0),\n                               boost::counting_iterator<uint64_t>(1'000'000'000),\n                               static_cast<uint64_t>(0));\n    }\n\nBoth `g++ -O2` or `clang++ -O2` compiles `f` to:\n\n    0000000000000000 <_Z1fv>:\n       0:\t48 b8 00 9b e4 b5 59 \tmovabs $0x6f05b59b5e49b00,%rax\n       7:\t5b f0 06 \n       a:\tc3                   \tretq   \n\nSo, yep.", "id": "d77pjm3"}, {"comment": "Trivial proof that it would:\n\nThe Rust compiler contains essentially 0 optimizations, relying entirely on llvm to rip its abstractions to shreds. The only potential advantage Rust has is that it can probably provide more aggressive aliasing information (but actually it's limited here because of bugs in llvm).", "id": "d77pv6g"}, {"comment": "https://godbolt.org/g/mwFtTL\n\n(Note the lines `movl    $55, %esi` and `movl    $15, %esi`, each of which replace computing `sum(1..10)` and `sum(1..5)` respectively).\n\nNot just iterating over stuff like a compile-time vector, but also iterating over runtime data that is really clearly just a very simple loop. It even works on totally user-defined stuff like that `generator` class.\n\nIt's fun to look at the code generated by replacing `-O2` with `-O1` in the command line in the top right. People often think enabling optimisations always bloats code. Not at all!", "id": "d77yn4k"}, {"comment": "That's pretty cool. Looking at it now I'm not sure why I doubted that was a thing. Thanks for the demo!", "id": "d781f4l"}, {"comment": "You can see some optimizations in the iterator implementations. The article uses a `fold()` over a `Range` object, which implements `Iterator`. [This](https://doc.rust-lang.org/src/core/up/src/libcore/iter/range.rs.html#496-519) is the `next()` method for `Range`. Notice the inline and the mem swap. The `fold()` [method](https://doc.rust-lang.org/src/core/up/src/libcore/iter/iterator.rs.html#1313-1321) is also inlined for all iterators.\n\nI'm not sure how significant those things are, but it may make it easier for the compiler. Also LLVM is pretty damn smart.", "id": "d77f8jo"}, {"comment": "The mem::swap isn't an optimization; it's semantically necessary because the Range code is generic over types which may not be copyable. The natural code:\n\n    let old = self.start;\n    self.start += 1;\n    return old;\n\nisn't correct when `let old = self.start` moves out of self (the second line would be working on uninitialized memory). Ideally this would work:\n\n    let old = self.start;\n    self.start = old + 1;\n    return old;\n\nBut it can't because `old + 1` might panic and unwind (since `+` here has a user-provided implementation). If it did, `self` would be left with uninitialized memory and the caller wouldn't know it. This could be used to e.g. use-after-free.\n\nThe inline annotation is honestly mostly just cargo-culting in the standard library. In some places it's necessary to ensure code is available for inlining in applications, but for generic code (like this), it's doing very little.", "id": "d77pr3b"}, {"comment": "Yeah I was really disappointed after he pointed out \"Oh it compiles away adding 4 billion times\" and then didn't create a second test that actually did the adding at runtime.", "id": "d76yu7d"}], [{"comment": "PyPy:\n\n> time pypy -c 'reduce(lambda x,y: x+y, xrange(1000000000))'\n\n> 1.58s user 0.02s system 99% cpu 1.604 total", "id": "d76yruq"}, {"comment": "Think the examples should actually be using functions in the stdlib, not random lambdas:\n\n    $ time pypy -c 'sum(xrange(1000000000))'\n    pypy -c 'sum(xrange(1000000000))'  0.88s user 0.03s system 99% cpu 0.914 total\n\nAlso python3 is quicker than python2 at this:\n\n     $ time python3 -c 'sum(range(1000000000))'\n     python3 -c 'sum(range(1000000000))'  21.74s user 0.03s system 99% cpu 21.804 total\n\n", "id": "d77blce"}, {"comment": "Which function it uses is actually pretty uninteresting, because the runtime is actually uninteresting here, it's just an artefact used to show off the Zero-Cost abstraction principle.\n\nThe real conclusion of the article is that C++ or Rust will let you use higher level abstractions without a runtime penalty.", "id": "d77iomm"}], [{"comment": "I would be impressed with an optimizer that substitutes the loop with Gau\u00df' sum formula: `result = n * (n + 1) / 2`", "id": "d77bmzo"}, {"comment": "Possible (compilers are, after all, pattern-matching engines) but improbable; it's much more reasonable to think that the compiler just brute-forced it...\n\n... which brings the point that showing off the compilation-time would probably have put Rust behind ;)", "id": "d77iyfl"}], [{"comment": "Now try adding bigger numbers. In Rust you'll get an overflow or panic, in Python it will just work (automatic big int promotion). I made a similar analysis comparing Crystal to Ruby, and why such comparisons are unfair: https://crystal-lang.org/2016/07/15/fibonacci-benchmark.html", "id": "d76y6oy"}, {"comment": "> In Rust you'll get an overflow or panic, in Python it will just work\n\nAnd that is exactly what you want in a systems programming language. You absolutely want to avoid \"magic\". Rust is crystal clear in what is happening and try to be as sound and unambiguous as possible. Try to leave no room for interpretation \u2013 as such Rust is pretty verbose. Rust is pretty strict about its types and this is one of its selling point. \"Will just work\" is a \"no goal\" in Rust. \n\nThere are two types of programming philosophies to distinguish here: Fail-Safe and Fail-Fast. Rust tends to be in the Fail-Fast direction whereas python is more in the Fail-Safe department. \n\nhttp://enterprisecraftsmanship.com/2015/09/15/fail-fast-principle/\n\nI tend more in the way of Fail-Fast whereas such things as \"automatic big int promotion\" could be considered as a contract violation.  ", "id": "d77189d"}, {"comment": "As someone who spent a lot of time working on Rust's APIs, \"just work\" was absolutely a goal. A common phrase you'll hear uttered in our community is \"if it compiles, it works\", and we in turn put a lot of work into trying to get things to \"just compile\". BigNums are *absolutely* following that philosophy.\n\nUnfortunately BigNums have a significant runtime cost, and it's *really* hard to get people off C/C++ if performance regressions are involved. We all tried that for two decades. Remember when *Java* was supposed to be a credible replacement for them?\n\nNumerics are a massive source of unfortunate compromises in Rust. I wouldn't ever point to it as \"wow we really knocked it out of the park, so perfect\". We made hard compromises to satisfy our competing concerns. The current state of hardware and optimizers is that fixed sized integers with wrapping overflow play really well. Swift has opted to push for trapping at all times, and I'm really interested to see if that puts enough pressure on hardware and optimizers (which the devs of Swift have massive sway over) to make this palatable for systems cases.\n\nJohn Regehr literally just posted a great article on this: http://blog.regehr.org/archives/1401", "id": "d77bvcj"}, {"comment": "That was not what i intended to say. \"Just work\" \u2013 at least for me \u2013 has the inherent meaning of \"i don't care whats happening\". If you overflow an u8 you expect it to panic in debug mode and overflow in release mode (if you don't use std::num::Wrapping). What you don't expect is it to \"just work\" and promote themself into something BigNums .. that's what i was trying to say. I can  hear you saying you can do that if you want to. And that's the hole point ... one can opt in into this, and rust is verbose in this regards giving you the opportunity to exactly indicate what you intend to do. In that regard i don't see Rust as a \"just work\" type language \u2013 because the compiler is in a very greedy mode and want you to exactly explain what you intend to do. ", "id": "d77cn5s"}, {"comment": "I don't think people expect Rust's behaviour -- empirically everyone is constantly confused by it and gets it wrong. Even people who work with it every day!\n\nBut yeah sure, u8 shouldn't promote itself. However, we could have rallied the language completely around a default Int type that is a BigInt and makes your code Just Work. I think that would have aligned perfectly well with Rust's goals if the performance impact weren't there. The author explicitly picked u64, but I don't think it was because they were like \"yeah I want a Z-2^64 \". They picked it because it could represent their result.", "id": "d77cv1m"}, {"comment": "> They picked it because it could represent their result.\n\nTo be fair, most everyday quantity is representable by a `i64` or `u64`. I've been programming non-numeric-heavy programs for 10 years and while I've seen plenty of integers outside the 32 bits range (notably DB-generated IDs), I've yet to have to use one which does not fit in 64 bits.\n\nI was slightly disappointed when Rust picked i31 as a default for this reason (greater risk of overflow), but I was certainly not disappointed by the choice of NOT using BigInts. As far as I am concerned, the usage of BigInt is niche enough that most programmers should only ever need them when toying with maths (Fibonacci, Factorial, etc...) and not in their daily occupations.", "id": "d77iwyl"}, {"comment": "To be fair, basically no real (e.g. production) code hits the default -- almost all code very quickly gets a different type from inference (most common case: usize for indexing).\n\nThe default is basically to make unit tests and code examples less tedious, in which case overflow isn't very interesting.", "id": "d77npzu"}, {"comment": "I see your point. I would guess it's also heavenly dependent of ones background. I see javascript programmers heavily struggling with this concept and i would agree on that part. But i also know people \u2013 and i would consider myself to this group \u2013 that are very happy about the current state of rust integer types and would be very confused and unhappy about such a default BigInt behavior ... or would really hard try to avoid it as the u8 u32 etc. types would still exist.    ", "id": "d77d89t"}, {"comment": "You probably mean Z/2^(64)Z, btw, if you're wanting to refer to the ring of integers modulo 2^(64).\n\nThere's no performance impact in defaulting to arbitrary-precision integers. There's a performance impact in choosing to use that default. That doesn't mean that the language is slower, it means that naive code might be slightly slower. If you want to compare performance you should compare performance for equivalent features, not for just naive code written without understanding of language semantics or language idioms. So you have to compare to std::Wrapping or w/e it's called anyway.", "id": "d77fhcq"}, {"comment": "I wouldn't characterise numbers that behave like actual mathematical numbers as \"magic\". The reason for fixed bit width numbers is speed. Their behaviour is less clean, not more clean. It's not Fail-Fast, but \"Fail and be fast\", whereas Python's numbers are \"Don't fail and be slow\".", "id": "d77a597"}, {"comment": "\"magic\" in this case probably refers to side effects such as memory being allocated when you were not expecting it.\n\nAlso, if you're concerned with \"actual mathematical numbers\", you'll need a lot more than big integers.", "id": "d77d1ly"}, {"comment": "What else do you need?", "id": "d77szb6"}, {"comment": "https://en.wikipedia.org/wiki/Rational_data_type (ok, just two bignums and some additional work)\n\nhttps://en.wikipedia.org/wiki/Symbolic_computation (hard pass)", "id": "d77wkyo"}, {"comment": "Need more than that, how do you represent irrationals?", "id": "d78dy4a"}, {"comment": "The [SymPy introduction](http://docs.sympy.org/dev/tutorial/intro.html) explains that a bit. \n\ntl;dr, irrationals are stored and manipulated as 'symbols' and only [evaluated to an approximate number](http://docs.sympy.org/dev/tutorial/basic_operations.html#evalf) on request", "id": "d78n64s"}, {"comment": "Ok, but that's for different types of numbers. Integers are fine mathematical numbers; they just don't support division, but fixed width integers don't either.", "id": "d77wtgd"}, {"comment": "> I wouldn't characterise numbers that behave like actual mathematical numbers as \"magic\".\n\nThat's an opinion i can accept, but i would not agree. In computer science Integer arithmetic is defined as \"residue class ring\" (don't know the exact therm its \"Restklassenring\" in german) as such it behaves like defined. Every common microprocessor is build as \"residue class ring\" in regards to Integer arithmetics\n\n> The reason for fixed bit width numbers is speed.\n\nI don't know what you mean by that. At first it is way simpler to construct microprocessor Integer arithmetic in the fashion of \"residue class ring\". There is academic research to use non fixed size \"registers\" but its not very common. but as you said in the second place one can simulate wider \"residue class ring\"s and that would be slower ... that's what big int is.\n\n> Their behaviour is less clean, not more clean. It's not Fail-Fast, but \"Fail and be fast\", whereas Python's numbers are \"Don't fail and be slow\".\n\nMy only point in this regards was, that this could be unexpected behavior cuz of the dynamic typing one could violate contracts at this place without knowing it, type checking cannot prevent this at compile time, whereas the python program would be happily calculate to wrong (big int) number. \n", "id": "d77c4ey"}, {"comment": ">That's an opinion i can accept, but i would not agree. In computer science Integer arithmetic is defined as \"residue class ring\" (don't know the exact therm its \"Restklassenring\" in german) as such it behaves like defined. Every common microprocessor is build as \"residue class ring\" in regards to Integer arithmetics\n\nResidue class ring is indeed a widely used term for it in English, although the more common term these days is probably quotient ring.\n\nAnd yes, 32-bit integer arithmetic is indeed modular arithmetic modulo 2^(32). That doesn't mean it's sensible. And nobody is 'simulating wider \"residue class ring\"s'. Big integers don't use modular arithmetic. They just use integer arithmetic.", "id": "d77ffku"}, {"comment": "This isn't really a Fail-Fast vs. Fail-\"Safe\" issue. Python generally throws exceptions when things are wrong too.\n\nThe source of the issue is probably just that performance is more important in Rust, so automatic bigint promotion isn't acceptable, either due to overhead or slower performance of bigints (that you wouldn't want to acquire unintentionally).", "id": "d777xvd"}, {"comment": "I understand. I'm just saying that comparing adding a bunch of numbers will always be slower in Python/Ruby or other languages where this kind of automatic conversion happens. I like Rust and I think the work they are doing is fantastic, but I'm always hesitant about number-crunching benchmarks where basically using any compiled language will win.", "id": "d77e013"}], [{"comment": "Hah sweet I made a relevant C++ program recently.\n\n[Adding 4 billion numbers in C++](https://gist.github.com/MINIMAN10000/3b5f109fa2a1cb744063b30d5b337c81)\n\nOf course I made sure the compiler couldn't just optimize away the only point of creating it, adding 4 billion numbers at run time.\n\nCore 2 Duo E8400 4 Ghz\n\nIf I modify it for 1 billion\n\n>Loops 61035 * individualsize 16384 / IPS 4000000000\n\n>Elapsed Timed: 0.15625\n\n>Additions per clock cycle: 1.6\n\n>Array Output: 999997440\n\n>Array Length: 16384\n\nEdit: Changed to 1 billion\n", "id": "d76yn8o"}], [{"comment": "Everyone fails this math contest question. \n\nthe sum of 1 ... n can be thought of as many pairs that sum to n: \n\n0+n\n1+n-1\n2+n-2\n...\nand so on until\nn/2 + n-n/2 and\n+ n/2 if n is odd.\n\nagain, that's n/2 * (n+1) or just (n+1(if odd))/2. We've just derived the area of a triangle. Enjoy it.", "id": "d77buwp"}, {"comment": "What kind of math competition are you in that that's even a question? ", "id": "d783mgm"}, {"comment": "Grade 7, I won $40 even for second place in the city. Named after Gauss: https://nzmaths.co.nz/gauss-trick-staff-seminar", "id": "d79rhox"}, {"comment": "Dude, I know the trick you're referring to, I'm just surprised that it was in a Math competition. At my school it's taught in standard Algebra 1 or Geometry, first week they talk about sums", "id": "d7a0p97"}, {"comment": "... you didn't look at the link. Gauss, Carl Friedrich Gauss, is said to have come up with this trick as a kid. This problem wasn't in the math contest: it was the theme of the math contest.\n\nWho really cares though, everyone else is iterating through all billion integers like autistic robots", "id": "d7bzavt"}]]], "4ht6e4": ["The software engineer\u2019s guide to asserting dominance in the workplace", "2016-05-04 09:51:42", 10, "https://hackernoon.com/the-software-engineer-s-guide-to-asserting-office-dominance-ddea7b598df7", [[20, "Oh look, it's this post again"], [11, ">\"If your new team doesn\u2019t use git, announce your resignation immediately and walk out\""], [4, "Not sure if funny story or if author has camera behind me."], [2, "> Cherry MX Green or Blue switches\n\nWeak. Get an original Model M. Also doubles as a bludgeoning device if your authority is challenged."]], [[{"comment": "Oh look, it's this post again", "id": "d2s6sd7"}, {"comment": "I've never seen it.", "id": "d2schfl"}, {"comment": "In general I'm not critical of reposts, but this gets exponentially less funny every time it is reposted.  Best to repost it to r/programmerhumor. ", "id": "d2snn84"}, {"comment": "Pay attention", "id": "d2sfu6b"}, {"comment": "Is this step 1 of asserting r/programming comment thread dominance? ", "id": "d2snrxt"}, {"comment": "Oh look, it's this post... about this post again", "id": "d2slpup"}], [{"comment": ">\"If your new team doesn\u2019t use git, announce your resignation immediately and walk out\"", "id": "d2s6o7a"}], [{"comment": "Not sure if funny story or if author has camera behind me.", "id": "d2s660o"}], [{"comment": "> Cherry MX Green or Blue switches\n\nWeak. Get an original Model M. Also doubles as a bludgeoning device if your authority is challenged.", "id": "d2s6x4o"}, {"comment": "Every real hacker knows Cherry is overrated crap.\n\nOnly [the best](http://www.amazon.com/Topre-Type-Heaven-104-key-Keyboard/dp/B00DGJALYW) is used by the *best*.", "id": "d2sbqq0"}, {"comment": "Sure that's fine, IF YOU WANT THE CHEAP VERSION. [Here's the real thing](http://www.amazon.com/dp/B00MV84Y2Y).\n\nSomething something [HHKB](http://www.amazon.com/dp/B000EXZ0VC)\n\nWait, what's all this about \"Korean customs?\"", "id": "d2sgt36"}, {"comment": "[Noobs](http://cdn.shopify.com/s/files/1/0185/6812/products/newpic11_1024x1024.jpg?v=1385561034)", "id": "d2soq2o"}, {"comment": "Except those use the exact same keys (Topre).  You're paying a $100 premium for black keys and you don't even get a keypad.", "id": "d2t2lb1"}, {"comment": "\n**Topre Type Heaven 104-key Keyboard** \n\n||||\n--:|:--|:--\nCurrent|$154.83|Amazon (New)\nHigh|$187.46|Amazon (New)\nLow|$144.91|Amazon (New)\n|Average|$154.83|30 Day\n\n[Price History Chart](http://i.imgur.com/XYmanMa.png) | [FAQ](http://www.reddit.com/r/PriceZombie/wiki/index) \n", "id": "d2sbqua"}]]], "4erg19": ["Come and Go", "2016-04-14 18:43:40", 0, "https://neurobashing.com/2016/04/14/come-and-go/", [[9, "> **Moreover, HN-driven development often results in big blind spots with the platforms you have.** A great example is Python. A lot of people went from Python 2.x to Go, citing bugs, performance problems, or a need for greater concurrency, without ever testing out the asyncio stuff in Python, or checking to see if their pet bugs were fixed. Go was a shiny new toy with the intellectual thrill of learning a new thing; porting to Python 3 was just hard, possibly boring work. Who needs *that* shit?\n\n> **Yes, I think Go is a bad language that ignores decades of programming language research to solve a specific problem Google has. Google\u2019s massive rep as tech innovator makes everyone think it\u2019s good: after all, Google uses it!**\n\nThe author manages to have an opinion of Go that is very common on HN. So what of *HN-driven development*?\n\nThere are plenty of hop-on-bandwagon sentiments on HN, but it's never a monolithic consensus on any up-and-coming technology."], [3, "> But the point of this rant is to not criticize Go, it\u2019s to illustrate that \u201cGo is going to solve all our problems!\u201d is a bunch of bullshit, because the most likely scenario is in 2-3 years the newest, hippest platform (an out-of-left-field Perl resurgence? Elm? INTERCAL?) will suddenly become the solution to all our problems.\n\nWho could have imagined this? Very Insightful!"], [3, "I think before criticizing an entire industry you should probably graduate and enter that industry to find out what exactly you are talking about. [ref](https://github.com/neurobashing/homework)"], [1, "Just say you are writing a generic rant on the top so people don't wind up getting tricked in to reading that shit.\n"], [1, "Go was in development at the same time node.js was created. The author clearly didn't do any research for his piece. If i had to guess I'd say he's probably a PHP programmer."], [0, "Rails is still quite popular, GitHub uses Rails, a bunch of CLI apps use Ruby. Node is also popular. Just use the right tool for the right job, who cares if it's trendy or not. If Go is better for the job than Node, so be it. "], [-4, "He fears that Go will replace Python. Which I hope it fucking will."]], [[{"comment": "> **Moreover, HN-driven development often results in big blind spots with the platforms you have.** A great example is Python. A lot of people went from Python 2.x to Go, citing bugs, performance problems, or a need for greater concurrency, without ever testing out the asyncio stuff in Python, or checking to see if their pet bugs were fixed. Go was a shiny new toy with the intellectual thrill of learning a new thing; porting to Python 3 was just hard, possibly boring work. Who needs *that* shit?\n\n> **Yes, I think Go is a bad language that ignores decades of programming language research to solve a specific problem Google has. Google\u2019s massive rep as tech innovator makes everyone think it\u2019s good: after all, Google uses it!**\n\nThe author manages to have an opinion of Go that is very common on HN. So what of *HN-driven development*?\n\nThere are plenty of hop-on-bandwagon sentiments on HN, but it's never a monolithic consensus on any up-and-coming technology.", "id": "d22mu6m"}, {"comment": "> The author manages to have an opinion of Go that is very common on HN.\n\nRight now it is, sure. There was a while over there where the Go circlejerk was truly out of hand.", "id": "d22nkcn"}, {"comment": "Then it seems that the author is about 5 years too late to the counter-jerk.", "id": "d230vso"}, {"comment": "Well, Go is a stagnated lenguaje that for Google is finished because it Works for their needs, because the goal of Go is to please Google, no one else.", "id": "d22ug35"}, {"comment": "[deleted]", "id": "d23oidw"}, {"comment": "Go 2 is an idea that will never been realized? Mostly collection of issues that break Go 1 compatibility promise and so a binned.", "id": "d23qfqj"}], [{"comment": "> But the point of this rant is to not criticize Go, it\u2019s to illustrate that \u201cGo is going to solve all our problems!\u201d is a bunch of bullshit, because the most likely scenario is in 2-3 years the newest, hippest platform (an out-of-left-field Perl resurgence? Elm? INTERCAL?) will suddenly become the solution to all our problems.\n\nWho could have imagined this? Very Insightful!", "id": "d22oo11"}, {"comment": "Hype drives our industry so much that we're almost a fashion industry.\n\nSome people are aware of it  need to pick their battles, some people are aware of it and cynically use & benefit from it, and the majority don't really understand it at all.   \n\nWhether it's functional programming, type safety, big data, data science, TDD, MongoDB, Hadoop, Scala, etc - the failure to see that the benefits are usually oversold, and that the solution will fail to be a silver bullet - is so common it's the rule rather than the exception.", "id": "d22voxn"}, {"comment": "Maybe we just don't know what we are doing. So we use poor proxies for what is good, like how new something is.", "id": "d230xi0"}], [{"comment": "I think before criticizing an entire industry you should probably graduate and enter that industry to find out what exactly you are talking about. [ref](https://github.com/neurobashing/homework)", "id": "d237j10"}], [{"comment": "Just say you are writing a generic rant on the top so people don't wind up getting tricked in to reading that shit.\n", "id": "d233rea"}], [{"comment": "Go was in development at the same time node.js was created. The author clearly didn't do any research for his piece. If i had to guess I'd say he's probably a PHP programmer.", "id": "d23609b"}], [{"comment": "Rails is still quite popular, GitHub uses Rails, a bunch of CLI apps use Ruby. Node is also popular. Just use the right tool for the right job, who cares if it's trendy or not. If Go is better for the job than Node, so be it. ", "id": "d22pau7"}, {"comment": "The article doesn't even have any data! He picked a *single example* of one company or person switching platforms as proof that they're losing popularity!\n\n[If you actually look at the trends](https://www.google.ca/trends/explore#q=%2Fm%2F0505cl%2C%20%2Fm%2F0bbxf89%2C%20%2Fm%2F09gbxjr&cmpt=q&tz=Etc%2FGMT%2B4) (warning: site seems to be broken for Firefox) you can see that Rails peaked in 2007 and has been on the decline since then (sitting at about mid 2005 numbers), and Go peaked in late 2013 - mid 2014 and has been in decline (sitting at late 2011 numbers), but Node is more popular than ever and growing even more quickly now. So pretending like the three are the exact same is just wrong.\n\nAnd not to mention, sometimes the right tool for the job is the one that everyone else is using, *because* everyone else is using it. When a language has a large community, there's a wealth of information, tools, libraries, and other resources available that wouldn't otherwise be there. If everyone you know is suddenly using a new tool and talking about how great it is, at some point shouldn't you at least give it a try? What's so bad about that?\n\n\"Kids these days! They just use whatever tools their friends are using! Back in my day we all wrote our own languages!\"", "id": "d22wpv8"}, {"comment": "Node is on hike due to one simple reason: it has no competitors. IMHO that is all. ", "id": "d2397k7"}, {"comment": "Node is primarily used to write website back ends. There are hundreds of frameworks for dozens of other languages that compete for this exact role. It's one of the most competitive areas of programming, so I don't know what you are talking about.\n\nBut if I were to speculate as to why Node is on top, I think it's some combination of the following:\n\n - JavaScript was already ubiquitous, well known, and (in some circles) fairly popular, so many people didn't have to learn a new language to start with Node which made it an easy sell.\n - It has a \"killer framework\" (Express) and a \"killer stack\" (MEAN) so it was easy to market to beginners.\n - Node itself is quite robust, and the APIs it provides are very nice, so once you get comfortable with it you need a good reason to give it up (e.g. higher performance).\n - Network effects suck people in and keep them from leaving. When all your favourite tools and libraries are for Node, you don't want to go through the pain of switching platforms.", "id": "d23aphz"}, {"comment": "* I think that now most Node stuff are developers tools, not web apps. So whole Brunch/Grunt/Gulp/Babel/Browserify/WebPack crap, not apps per se.\n* The most frightening thing in MEAN stack is that M part. If you want to be serious and you use Mongo, then you aren't serious.\n* JS is far away from anything what I could name \"nice\".\n* The only thing that I can agree with. But to be honest, I wouldn't like to work with someone that would not want to (from time to time) get out his/her comfort zone and try something new.", "id": "d23cy75"}, {"comment": "> I think that now most Node stuff are developers tools, not web apps. So whole Brunch/Grunt/Gulp/Babel/Browserify/WebPack crap, not apps per se.\n\nYou can write tools in any language, though. I've used tools written in Python and Ruby without even realizing it.\n\nNode tools do tend to expose a library interface so they can be called within JS code for more advanced stuff, but there's nothing stopping you from hooking them up with some shell scripts (unless certain features are restricted to the library interface).\n\n> The most frightening thing in MEAN stack is that M part. If you want to be serious and you use Mongo, then you aren't serious.\n\nAgreed, I prefer PostgreSQL. Not a fan of Angular either, and Koa is what Express should have been all along. It's unfortunate that much of the beginner materials seem to be oriented around MEAN stacks.\n\n> JS is far away from anything what I could name \"nice\".\n\nI would have agreed with you a year ago, but after getting used to it and developing a taste for good JS, it's now my favorite language. You just have to give it a fair shot (and avoid half its \"features\").\n\n> But to be honest, I wouldn't like to work with someone that would not want to (from time to time) get out his/her comfort zone and try something new.\n\nDon't work with the author of the article then, he seems to think that people trying new stuff they find on Hacker News is a problem.\n\nI agree, it's good to try new things. I used to think Node and JavaScript were complete garbage, so I'm glad I gave them a chance.", "id": "d23l80u"}], [{"comment": "He fears that Go will replace Python. Which I hope it fucking will.", "id": "d22ofy7"}]]], "4qrvya": ["Hackers can steal passwords and encryption keys by listening to your PC", "2016-07-01 18:04:05", 0, "http://www.msn.com/en-us/news/technology/hackers-can-steal-passwords-and-encryption-keys-by-listening-to-your-pc/ar-AAhQVC8?li=AA4Zoy&ocid=spartanntp", [[7, "> Fansmitter \"can regulate the internal fans' speed in order to control the acoustic waveform emitted from a computer,\" the researchers wrote. A nearby smartphone microphone, placed up to eight meters away, can then pick up the binary data being audibly transmitted.\n\n\n**tl;dr:** computer already has to be compromised and running attacker controlled software.  Neat, but not likely to be used in the real world."], [4, "I remember several years ago - before wifi - reading a breathless article much like this one that described how hackers could steal your network data by recording the flashes of your NIC traffic indicator LED.\n\nIf you've read Cryptonomicon, you know about [Van Eck](https://en.wikipedia.org/wiki/Van_Eck_phreaking) phreaking which [has been around](https://hardware.slashdot.org/story/07/04/20/2048258/laptops-and-flat-panels-now-vulnerable-to-van-eck-methods).\n\ntl;dr nothing is new."], [1, "> using the noise created by cooling systems and the CPU\n\nWhat do they mean \"noise created by the cpu\"?\n\nIs this the electronic hum it would make when powered, or do they mean the cpu fan (if one is fitted)?"]], [[{"comment": "> Fansmitter \"can regulate the internal fans' speed in order to control the acoustic waveform emitted from a computer,\" the researchers wrote. A nearby smartphone microphone, placed up to eight meters away, can then pick up the binary data being audibly transmitted.\n\n\n**tl;dr:** computer already has to be compromised and running attacker controlled software.  Neat, but not likely to be used in the real world.", "id": "d4vd6v6"}, {"comment": "It only needs to be compromised once, though, rather than accessed directly repeatedly to pull key entry logs. It's not entirely worthless in practical terms, it's just very niche.", "id": "d4ve7o6"}, {"comment": "True, but it does still require a persistent presence to extract the data.  A sound recording device is more discrete than human interaction to extract logs, but if you've already got custom software running on the target as well as some form of persistent presence, you've pretty much already won.", "id": "d4vfr0o"}, {"comment": "The article is very pointless scaremongery click bait though, maybe I skimmed too much but it implies hackers can steal all your information by just listening to your fans, there's little mention of your machine having to be compromised already.", "id": "d4wfokx"}, {"comment": "Yeah the article was a bit sensationalist on this specific threat, but [they can steal your information by just listening to your keystrokes,](http://www.berkeley.edu/news/media/releases/2005/09/14_key.shtml) and having a standard home pc compromised isn't out of the question. The fear of this specific threat may be blown out of proportion, but the general threat exists if someone targets you for some reason. \n\nSo the fearmongery nature isn't that unreasonable, either, in my view. If you don't know enough to know the PC needs to be compromised first for the exploit to work by reading the article critically, you probably don't know enough to keep your information secure from a determined hacker if you keep that information on your personal computer.", "id": "d4wftqk"}], [{"comment": "I remember several years ago - before wifi - reading a breathless article much like this one that described how hackers could steal your network data by recording the flashes of your NIC traffic indicator LED.\n\nIf you've read Cryptonomicon, you know about [Van Eck](https://en.wikipedia.org/wiki/Van_Eck_phreaking) phreaking which [has been around](https://hardware.slashdot.org/story/07/04/20/2048258/laptops-and-flat-panels-now-vulnerable-to-van-eck-methods).\n\ntl;dr nothing is new.", "id": "d4vbzty"}], [{"comment": "> using the noise created by cooling systems and the CPU\n\nWhat do they mean \"noise created by the cpu\"?\n\nIs this the electronic hum it would make when powered, or do they mean the cpu fan (if one is fitted)?", "id": "d4vw3ny"}, {"comment": "CPUs by themselves don't make any noise when running - not even a hum.\n\nIf your CPU is making a noise...it's probably cooking itself pretty drastically.", "id": "d4vyitk"}, {"comment": "They should do - there's 90W of current flowing though it. I assume you mean it won't be audible to humans?\n\nI suspect the whining is from the capacitors or power transformers adjacent to the cpu socket. There's a whole bunch of them. [Looks a bit like this.](http://www.gigabyte.com/fileupload/product/2/4965/10223_big.png). I don;t know what the square blocks are. The round ones seem to be capacitors.\n\nit's definitely not from the PSU. That has a much lower pitch sound.", "id": "d4w0nk7"}, {"comment": "Most if the current in a cpu could be considered DC with small ripples up in the GHz range.  Even if the ripples were in the audible range, you wouldn't here them as current in a wire won't induce pressure changes in the air.  The PSUs switching circuitry will generate lower frequency ripples though and those can produce mechanical changes in capacitors that may be audible (usually as a high pitched whine and it's usually a sign the component is going to fail).", "id": "d4w2z54"}, {"comment": "There's not just a high pitched \"failure warning\" power supply whine though: there's a lower buzzing one from the power as well. Pretty much all gadgets large enough to be impractical to run on batteries (including SSD laptops with the fans off) makes it.", "id": "d4w3f6m"}, {"comment": "Then it's just capacitors in the power circuitry.  A CPU won't make noise, trust me.  I used to design electronics for a living.", "id": "d4w5hxl"}]]], "4wnghb": ["Javascript continent and the callback pyramids of hell", "2016-08-08 03:59:14", 0, "http://boxbase.org/entries/2016/aug/8/javascript-pyramids/", [[18, "What?"], [19, "This article has bad grammar, mixed metaphors, lacks substance, and is generally filled with non-sequiters like \n\n> Promises originated as recorded sentences of OOP evangelists.\n\n... but hey, it says bad things about Javascript, so I guess it's going to get upvoted.\n\n---\n\nEDIT: When I made this comment, the post was something like 80% upvoted with 20-30 points, now it's 48% upvoted, so I guess cooler heads have prevailed in the hours since I made this comment."], [17, "The code examples in this article are atrocious. XxxxXXxxxxXxxxx();"], [8, "I agree that threads are better than callback pyramids at expressing most control flow, and it's sad that Javascript doesn't provide them. Serial code that executes from top to bottom is an amazing and underrated abstraction."], [5, "> Async and await spreads by programmer's ignorance, cross-pollinating other languages that didn't have any problems to start with.\n\nIt would have been nice if the author had provided an example of such a language. "], [4, "This would be a great article, if it was written 10 years ago."], [2, "haha -- where can I read that ORLY book? :-)"], [2, "I simply love the image cover... it's perfect."], [2, "I liked that pouchdb article more, to be honest."], [1, "I kinda wish we had gotten something like scala's delimited coroutines (shift and reset). I know mechanically async and await are roughly the same, but the intended use cases are very different.\n\n"]], [[{"comment": "What?", "id": "d68ep7g"}], [{"comment": "This article has bad grammar, mixed metaphors, lacks substance, and is generally filled with non-sequiters like \n\n> Promises originated as recorded sentences of OOP evangelists.\n\n... but hey, it says bad things about Javascript, so I guess it's going to get upvoted.\n\n---\n\nEDIT: When I made this comment, the post was something like 80% upvoted with 20-30 points, now it's 48% upvoted, so I guess cooler heads have prevailed in the hours since I made this comment.", "id": "d68p9m9"}, {"comment": "Seems to be up and downvoted in equal amounts. Maybe it gets below at some point. I dunno.\n\nThis style is difficult to me. I am amazed it succeeded enough to be controversial, and that some people understood what was my point.\n\nI am sure that people do not just upvote it because it says bad things about Javascript. I think it's how pictures match the context and the neatly drawn book in the end.\n\nThanks for pointing out about the grammar, mixed methaphors, lack of substance and non-sequiters. I'll see what I can do for that in the future.", "id": "d68urlu"}, {"comment": "If you had a point, I sure missed it.  As far as I can tell, it was just \"I don't like JS\nor any of the ways of handing async logic in it\"; you refer to every pattern for handling asynchronous logic as a \"parasite\", and never actually suggest an alternative.\n\nAnd, your claims range from substance-less insults (calling patterns \"parasites\", saying that programmers only use them out of ignorance, etc), to wildly inaccurate claims.\n\nTo demonstrate that last bit, let me just quote through a few paragraphs, and point out the factual inaccuracies as I go:\n\n---\n\n> **Promises**\n\n> Promises originated as recorded sentences of OOP evangelists. \n\nNo, actually promises actually originated from functional programming; see the [wikipedia article](https://en.wikipedia.org/wiki/Futures_and_promises) on the topic.  \n\n> They were eventually rewritten into a complete language of their own that nearly resembles a whole interpreted language of its own.\n\nNo, Promises aren't a language.  They're an abstract programming concept, which are implemented in many different ways by many different languages (see Java's [Futures](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html) for a different implementation of the same abstract concept).\n\nIn JS specifically, Promises generally follow the [A+ Promise specification](https://promisesaplus.com/), which is a specific API for the abstract concept of a Promise, but is still not a language.  \n\n> Internally they contain an interpreter to represent sequential control flow, and inject more promises into promises to represent code that can do calls that wait for subsequent results. \n\nNo, Promise libraries don't contain an interpreter (certainly not any library I've ever heard of); all Promise libraries really do, at their core, is take various handler functions as input, and then call the right functions with the right values based on the state of the asynchronous operation.\n\n> The interpreter-likeness makes the promises heavyweight, forming very interesting optimization problems to where they are used.\n\nOnce again, nope.  As mentioned, there's no \"interpreter-likeness\" going on, and more than that Promise libraries aren't necessary heavyweight.  The library [bluebird](http://bluebirdjs.com/docs/why-bluebird.html) for example is about as close to a zero-cost abstraction as is possible: there's very very little performance overhead to using it.  (And in most cases, the performance of the Promise library is a negligible factor in the performance of the async operation itself)\n\n---\n\nYou go on to call \"async and await\" a \"true language\", which is obviously not the case.  And I don't understand your criticism there, either.  Yes, JS `async/await` is largely just syntactic sugar around Promises.  Are you inherently opposed to syntactic sugar?\n\nThe irony is that one of the major points of `async` and `await` is to eliminate the \"pyramids of doom\" pattern, and they're successful at that: they entirely flatten out asynchronous logic so that it reads like synchronous logic.  But, then, by this point in your article you aren't really talking about pyramids of doom (or \"continents of JS\", for that matter), you're just insulting JS.", "id": "d692zpx"}, {"comment": "Now I'd maybe? have better things to do, but this confusion is better to be cleared out. I see that this whole thing annoyed you enough to bar you from enjoying the jokes, or thinking about the subject, enjoying it.\n\n> No, actually promises actually originated from functional programming; see the wikipedia article on the topic.\n\nYeah. That's an error. I'm sorry that I attributed a stupid concept to wrong stupid people.\n\n> No, Promises aren't a language. They're an abstract programming concept, which are implemented in many different ways by many different languages.\n\nLanguage without a meaning, semantics, is meaningless.\n\nWhere do you think semantics end when defining a language? There's a revised report on semantics of Scheme for example. Do you think that semantics end up to this paper?\n\nWell in case of Scheme you can introduce new semantics with macros. Now, why would just macros introduce new semantics? Semantics is the study of meaning in a language. Doesn't every new function introduce new meaning for some words?\n\nIf you take promises apart, yeah then they aren't a language. But if you put them into javascript and implement them in some way. They become a language, and you will use it like a language. You will treat it like a language construct. `async` and `await` go further and concretize this into new language elements. So.. You are wrong here.\n\nIn the implementation, a new language needs a new interpreter. The functions that implement the behavior of these new words form together an interpreter for this new language. This new interpreter implements new control flow constructs on top of the old. This has to be done in Javascript because the old ones cannot wait.\n\nYou see the pattern of \"pyramids of doom\" disappear when you use `async` and `await`, yes. Though it is reasonable to expect that [it is not \"eliminated\"](http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/).\n\nNow this is not meant as an insult to JS. I feel that I insult people here more than languages. And it seems that people seem to be triggered as well.\n\nIt could be that I am wrong. But you would first have to prove that for me to believe it. I don't know if I am right or wrong, but it's optional for you to keep going on this discussion.\n\nEdit: To be sure, I'll look into this and see if I got something wrong here. Because.. I think I pretty much failed with this blog post. I'll see what I can learn.", "id": "d694u67"}], [{"comment": "The code examples in this article are atrocious. XxxxXXxxxxXxxxx();", "id": "d68j328"}], [{"comment": "I agree that threads are better than callback pyramids at expressing most control flow, and it's sad that Javascript doesn't provide them. Serial code that executes from top to bottom is an amazing and underrated abstraction.", "id": "d68eq4c"}, {"comment": "Using a real call stack is great. However, preemptive multitasking has its warts -- mutable shared state makes it harder to reason about things and easier to get into deadlocks.\n\nCooperative threading is a pleasant middle ground. Unfortunately, the most hip current implementation (Go's) leaves something to be desired. I like [D's implementation](http://dlang.org/phobos/core_thread.html#.Fiber) -- you have a yield method as expected, unlike Quasar; can get a reference to the current fiber; can subclass `Fiber` to add local data or create your own scheduler... The cost is that every fiber has to allocate at least one page of memory, which isn't great for embedded systems.\n\nFor javascript, it would be nicer even to have hermetically sealed cooperative multitasking like in Go. Undesirable for what I'm using fibers for, but still handy.", "id": "d68fs8a"}, {"comment": "Erlang's actor like model is also very nice. its one of my favorites, just wish Go would have been implemented the same way.", "id": "d68gtnl"}, {"comment": "I've heard some great things about Erlang's actor model.", "id": "d68ljjh"}, {"comment": "ok", "id": "d68ohvp"}, {"comment": "Go is not purely cooperatively threaded.  It's pretty easy to get into deadlocks and other situations actually. ", "id": "d68m8q5"}, {"comment": "It's cooperatively multithreaded if you use GOMAXPROCS=1.\n\nDeadlocks are possible with purely cooperative multithreading. The difference is that cooperative multithreading is deterministic, which makes it somewhat easier to reason about.", "id": "d68pnlg"}, {"comment": "While I agree..  When I speak of cooperative multithreading, I am generally speaking of things that require the programmer to think about yielding the current fiber, or a library they are using does that on their behalf.\n\nIn the case of go, there are many language features which can cause a fibers to be rescheduled. (e.g. sending over a channel)", "id": "d7fug03"}, {"comment": "Maximally unshared state coupled with threading sounds like it would be close to ideal, as it gives you obvious control flow but simultaneously prevents having to deal with possibility of state being mutated from multiple control flows. I hate to say it, but JavaScript's web workers are exactly that.", "id": "d68rqrg"}, {"comment": "What's wrong with Go's implementation?", "id": "d68j7rm"}, {"comment": "The one thing that's specifically bad about it is that it uses an environment variable to determine whether it will schedule ~~fibers~~ goroutines across multiple threads. If you're not careful, an end user will set GOMAXPROCS and break your program. Fortunately, you can call a runtime method to override that, but your app is fragile by default.\n\n(The other bad thing is how the Go team had to rename them instead of using one of the standard terms. They have a habit of that -- goroutine, type assertion, panic/defer/recover...)\n\nThe thing that I can't tolerate is how you are entirely sealed off from ~~green threads~~ goroutines. You can't get a reference to a goroutine, for instance. No goroutine-local storage. No way to check whether a specific goroutine is still running. No way to provide your own scheduler.\n\nMy specific use case is using userspace threads to simplify scripting for an actor-based simulation. (A [MUD](https://en.wikipedia.org/wiki/MUD).) I want to be able to run through all scripts that need to run once per tick -- about 4Hz. I want to be able to plug in my own event queue so that a script won't be scheduled until the appropriate tick. I want to ensure that there won't be any drift so some scripts are scheduled too soon and some too late.\n\nBeyond that, there are some conveniences I can get from a richer interface to the ~~coroutine~~ goroutine system. Fiber-local variables save a lot of headaches, for instance. I can more naturally detect whether a particular actor's got a running script (and it should always have a running script, so if it's not running, I need to log the error and start an appropriate script).\n\nThere are other reasons I don't want to use Go, but they're rather off topic.", "id": "d68kl6h"}, {"comment": "I think it just doesn't match your use case and/or mindset. I used to be a C++ programmer and it took time to get used to writing \"dumber\" code but I'm much happier now.\n\n> The one thing that's specifically bad about it is that it uses an environment variable to determine whether it will schedule fibers goroutines across multiple threads. If you're not careful, an end user will set GOMAXPROCS and break your program. Fortunately, you can call a runtime method to override that, but your app is fragile by default.\n\nI'd contest that the ability to change GOMAXPROCS is a good thing. If the program breaks by changing concurrency parameters, the program is already broken by design. It's a good thing that the program will always use available resources provided by the platform, which is the point of having multiple CPU cores.\n\n> The thing that I can't tolerate is how you are entirely sealed off from green threads goroutines. You can't get a reference to a goroutine, for instance. No goroutine-local storage. No way to check whether a specific goroutine is still running. No way to provide your own scheduler.\n\nI used to miss these low-level customisations, until I stopped using goroutines as threads. Any time I run into a limitation of the language like this, I stop and remember that maybe I should be doing something much simpler which in 95% cases turns out to be true.\n\nIn fact, I was told by Go people that limiting access to goroutine internals and limiting implicit context is very much by design. I can best appreciate it when I read code that I did not write, as the lack of magic and implicit context makes it much easier to follow.", "id": "d6938kw"}, {"comment": "> If the program breaks by changing concurrency parameters, the program is already broken by design.\n\nYou may as well say, look, I have this C++ program that was working, but then I linked in libpthread and put this calculation into a separate thread, and now it segfaults, so the program was already broken by design.\n\nExcept instead of editing the source code, Go lets you do this with an environment variable. At least with PHP, you have to edit a global configuration file.\n\nIt's not quite that bad because you can be paranoid and set GOMAXPROCS in code. It's still less than ideal.\n\n> I used to miss these low-level customisations, until I stopped using goroutines as threads.\n\nThis isn't a customization for the hell of it. I am writing a stateful, long-running service in which concurrency is something I need to explicitly model and work with, where the service restarting would be disruptive (even if it were instantaneous). Go is designed with stateless services that use concurrency as a tool to improve resource utilization, services that can trivially be restarted. (That is why, for instance, it's recommended that you only use defer recover to log error messages, while some common operations like type assertions and map indexing can panic.)\n\nEven if I found Go pleasant to work with, it would be a poor match for my use case. Goroutines are a part of that mismatch.", "id": "d69dja2"}, {"comment": "> You may as well say, look, I have this C++ program that was working, but then I linked in libpthread and put this calculation into a separate thread, and now it segfaults, so the program was already broken by design.\n\nI think a better comparison would be porting a C program from x86 to another architecture and it breaks when you rely on undefined behaviour/specific integer size/endianness.", "id": "d69v98k"}], [{"comment": "> Async and await spreads by programmer's ignorance, cross-pollinating other languages that didn't have any problems to start with.\n\nIt would have been nice if the author had provided an example of such a language. ", "id": "d68p9h9"}, {"comment": "Await is available in C# and Python besides being pushed hard in JavaScript... it's not a long list.  From what I read though, C# await can be problematic if nested where JavaScript's implementation relies on Promises and acts a bit saner.  I know nothing about Python's implementation.", "id": "d68qrya"}, {"comment": "No, the author seems to be saying that there are languages that are already fine without async/await, but it's showing up in those languages anyway. The other async I/O approaches in C# aren't nearly as nice as async/await, so I'm not sure that this is an example the author had in mind. ", "id": "d68xwy5"}, {"comment": "It may very well be the example he had in mind, since in the Windows API, there are usually synchronous APIs available to do the same things as the asynchronous API. For example, you would never use `await` in conjunction with `WSARecv` because you can write your code to use the synchronous BSD Sockets API instead of forcing the asynchronous API to act like it's synchronous.\n", "id": "d6hs73g"}, {"comment": "Yeah. Details are fun. I can only hope I can manage to provide more of them at an another time.\n\nIn case you feel like you need an example of language that was 'cross pollinated' by async and await. You don't need to go look further than where Python3 is. So unfortunate.", "id": "d68uscw"}, {"comment": "How did Python handle async I/O before Python3? The only thing I'm aware of is Twisted, and it had the same problem that you're talking about.", "id": "d68ybao"}, {"comment": "Python had threading, even with GIL-locks it is okay if you have just one or two tasks that should run at same time.\n\nThen man called Armin Rigo also came up with these things called greenlets when he made stackless python. He eventually migrated these structures to python. They modify the stack to let you suspend an execution to continue in another and are slightly scary in the same way as ordinary threading is. Though they are slightly less because they run in co-operative fashion much like how javascript callbacks and events run.\n\nGreenlets would let you implement a javascript-like eventloop that lets you treat both callbacks and suspended functions with the same mechanism. If Javascript had greenlets-enabled eventloop, this would mean that setTimeout(1000) could actually suspend the currently running execution, put it into sleep queue as if it was a callback, pass control for other events in the meanwhile and then trigger the execution when a second has passed. Still the setTimeout could also function just with plain callbacks like before.\n\nSome people did that in python. They worked neat. I implemented some of those in my language. I really like how it came out.\n\nThe problem here is that it can break existing software that is used in combination with this new feature. The feature introduces kind of new cases you have to understand and take care of:\n\n* If you suspend an execution that holds a resource that must be explicitly freed, there will be trouble if you just suddenly lose the object. If the event source ceases to exist, it must schedule throwbacks into the listening greenlets to have them release the limited resources they may hold.\n* If you have atomicity requirements that must be fullfilled. For example, you're reading some structure and must read the whole record in whole before it changes. You must be certain that under subcalls the current greenlet is not suspended and control is not returned to eventloop, or then you must be certain that the structure is not changed by other greenlets that may execute in middle. This is a similar requirement as if you were working with real concurrency in same setting.\n* Another situation is dual of that, with the difference that you're writing some state down and no changes should occur while you are writing.\n\nObviously old code doesn't take these things into account. So there is a fear that python standard libraries would randomly break if greenlet-like programming became more prevalent there. We fear for a boogieman and leave an another in while we do so.\n\nAnd that's what I wanted to cleverly point out.", "id": "d68z9nw"}], [{"comment": "This would be a great article, if it was written 10 years ago.", "id": "d68rj8g"}, {"comment": "If it was written 10 years ago it wouldn't have been written by me.\n\nI would have been unable to predict this.", "id": "d68udvb"}], [{"comment": "haha -- where can I read that ORLY book? :-)", "id": "d68jn7i"}, {"comment": "Who knows if I write it some day. But I have to consider the thickness of that volume. The key question is could someone keep variation of writing and sustain the fun of code animals in that book, for over 500 pages? And could it be me?", "id": "d68uig3"}], [{"comment": "I simply love the image cover... it's perfect.", "id": "d68qy4p"}], [{"comment": "I liked that pouchdb article more, to be honest.", "id": "d68s896"}, {"comment": "I put those links in so that it's not a total disappointment for anyone who, expecting for fun reading, would read it. I like the pouchdb article too. It's very well written.", "id": "d68ujvg"}], [{"comment": "I kinda wish we had gotten something like scala's delimited coroutines (shift and reset). I know mechanically async and await are roughly the same, but the intended use cases are very different.\n\n", "id": "d68hrvl"}]]], "4p2gad": ["Visualising the .NET Garbage Collector", "2016-06-21 06:46:02", 0, "http://dotnetkicks.com/r/152432?url=http://mattwarren.org/2016/06/20/Visualising-the-dotNET-Garbage-Collector/", [[14, "Repost of https://www.reddit.com/r/programming/comments/4p176p/visualising_the_net_garbage_collector/  \nJust using a shitty redirection with this link."]], [[{"comment": "Repost of https://www.reddit.com/r/programming/comments/4p176p/visualising_the_net_garbage_collector/  \nJust using a shitty redirection with this link.", "id": "d4hn0wn"}, {"comment": "Repost of https://news.ycombinator.com/item?id=11941874", "id": "d4hqsq9"}, {"comment": "you don't get out much, do you? ", "id": "d4ho6qs"}, {"comment": "It's both on the first 25 entries of the /r/programming/new page.", "id": "d4hpix9"}]]], "5442ll": ["We\u2019re going back to a tech world run by hackers", "2016-09-23 14:33:40", 2, "http://chrismm.com/blog/what-full-stack-really-means-to-the-job-market/", [[22, "Back when the internet didn't have bloated webpages that kills your bandwith. I miss those times. "], [17, "\"I have met many programmers that don\u2019t like to code in their spare time, and that has reliably revealed them to be sub-par developers.\"\n\nIn bold even? That is so untrue. I have met dev who do code in their spare time, but they still suck. I have met other devs who have family/spouse/activities they do when they aren't working, but are still some of the best devs out there. This isn't a 1 rule fits most."], [14, "Still as bad as an article as [the last time you posted basically the same thing](https://www.reddit.com/r/programming/comments/4tr42n/what_full_stack_really_means_to_the_job_market/)"], [14, ">We\u2019re going back to a tech world run by hackers\n\nNobody cares about hipster web developers. Good riddance."]], [[{"comment": "Back when the internet didn't have bloated webpages that kills your bandwith. I miss those times. ", "id": "d7yvwh6"}], [{"comment": "\"I have met many programmers that don\u2019t like to code in their spare time, and that has reliably revealed them to be sub-par developers.\"\n\nIn bold even? That is so untrue. I have met dev who do code in their spare time, but they still suck. I have met other devs who have family/spouse/activities they do when they aren't working, but are still some of the best devs out there. This isn't a 1 rule fits most.", "id": "d7z6r4f"}, {"comment": "I do like to code in my spare time, but all my creativity and brainpower has usually been expended in my job. Perhaps I should make a bold statement\n\n**Programmers who like to code in their spare time are reliably revealed to be slacking at work**\n\nI have about the same amount of evidence.", "id": "d7zgw7e"}, {"comment": "Anecdotal at best. Everyone can say they know someone who is awesome and it's relative to their own capability.  It's so subjective that an intense study would be the only way to know for sure if the best programmers are the ones that devote the most time to their craft. IMO, it's like sports. You could have a programmer that is like Lebron James on the Cavs and is just the ultimate coder on his team where the others are mediocre or decent at best. You could have a very well rounded team of solid devs and relative to one another they would be fairly similar, etc. ", "id": "d7zam37"}], [{"comment": "Still as bad as an article as [the last time you posted basically the same thing](https://www.reddit.com/r/programming/comments/4tr42n/what_full_stack_really_means_to_the_job_market/)", "id": "d7yz13w"}], [{"comment": ">We\u2019re going back to a tech world run by hackers\n\nNobody cares about hipster web developers. Good riddance.", "id": "d7z0oxt"}]]], "4of7fn": ["Want to learn to make a Game just like Rust with C#? Well come check out this series! (\"Let's Make Rust!\")", "2016-06-16 23:36:51", 2, "https://www.youtube.com/watch?v=-q_daB1aN8w", [[2, "This is probably more suited for /r/gamedev or /r/unity3d"]], [[{"comment": "This is probably more suited for /r/gamedev or /r/unity3d", "id": "d4caauo"}, {"comment": "There seems to be programming involved and it is at least cool and original unlike a lot of posts on /r/programming ", "id": "d4cgp42"}, {"comment": "At this point I'll take anything that's not a medium blog post with 80% meme images.", "id": "d4ctlgn"}, {"comment": "Oh man you are preaching to the converted haha. Too much low quality content going around that gets copy pasta'd between here and y combinator ", "id": "d4cx68f"}, {"comment": "There's a similar tutorial where a guy makes Quake from scratch:\n\nhttps://www.youtube.com/watch?v=JpD-T28PU-4\n\nExcept they're not using Unity, they're doing all the coding by hand.", "id": "d4cp4qn"}, {"comment": "Also very cool. Thanks for sharing!", "id": "d4criq0"}]]], "4fd5l1": ["5 Mistakes That Are Ruining Your Chances of Hiring a Great Senior Software Engineer", "2016-04-18 22:04:23", 0, "https://medium.com/@ayasin/5-mistakes-that-are-ruining-your-chances-of-hiring-a-great-senior-software-engineer-4a505471bfc2#.b9wwz122z", [[13, "[deleted]"], [1, "HackerRank is not a bad tool, it just has nothing to do with helping you hire a great software engineer. It's an easy way to filter out bad candidates with a minimum of effort. I can't see any reason not to have a straightforward 1 or 2 hour HackerRank; it's eliminating only people who are very poor programmers or who have very poor attitudes, with zero effort on your side.\n\nEach time someone had a decent resume but did terribly on an easy HackerRank, some developer at that company just saved an hour. There's basically no downside, and that's why it's so widely used."], [1, "Sure this kind of blog posts massages the ego of an underpaid and unappreciated superstar that keeps asking himself why is nobody hunting for his head.\n\nBut if we want to talk about hiring problems the unpleasant truth runs a bit deeper I am afraid. The companies lie about positions as much as candidates lie about their abilities and experience. It's not gonna be a bleeding edge swarm of highly scalable micro-services. It's gonna be a horrible dung of legacy Ruby code and some badly normalized MyISAM database. Buy hey, come on, you're not a ninja superstar either.\n\nAnd the markets are quite efficient in pairing shitty developers with horrible working places. Sure as a company you can follow the 5 steps, fake it a bit, but it is to proper team building what pick-up is to romance.\n"]], [[{"comment": "[deleted]", "id": "d27u3xw"}, {"comment": "> It seems each \"solution\" to each of your mistakes require spending much more time and money than typical hiring practices, or raising the risk involved with taking on a new hire.\n\nThere isn't a cheap, easy way to hire top talent.", "id": "d27ze36"}, {"comment": "[deleted]", "id": "d2813da"}, {"comment": "> 1) How can you be so quick to draw that conclusion?\n\nBecause I've been trying to find one for years.\n\n> 2) This isn't an excuse to spend endless amounts of money on hiring. \n\nNo one's suggesting it is. I've spent the last two weeks solely on recruiting efforts. I'll go months at a time without even thinking about it.\n\nHere's the thing: the money we invest by spending Lead Engineer time is more than made up for when we get a great hire out of it, *and*, though this is harder to measure, it's also made up when we avoid a not-so-great hire.\n\n> 3) Throwing money at a problem doesn't guarantee a solution\n\nInvoking strawmen doesn't invalidate an otherwise sound point of view, either.\n\n> 4) You're simply restating the classic PM Triangle\n\n\"Hey, this thing that's been proven to be true? You're using it in your argument, so your argument is invalid!\"", "id": "d283b4l"}, {"comment": "[deleted]", "id": "d289zsx"}, {"comment": "> In effect, it's as if you're saying \"we don't know what we're doing but its working\".\n\nHow did you get that impression? We have a very focused strategy. Our funnel is job fairs, social media, and headhunters. One guy filters out the obvious garbage from that pile, then the resumes go to our lead engineers, who select the candidates that get a phone screen. The phone screen determines who gets an in-person interview. Each in-person interview takes two lead engineers about two hours.\n\nWe've used this process to hire four very good people in the past six months or so, and we've avoided hiring any duds. This is fucking fantastic.\n\nHow much are we spending on it? Probably a month's worth of lead engineer time, total, and it's only that much because we're in the middle of a hiring binge.", "id": "d28abrr"}, {"comment": "> It seems each \"solution\" to each of your mistakes require spending much more time and money than typical hiring practices\n\nYes, my entire point is that what you get out of recruiting is what you put in.  You can't expect to spend less money and less time AND find talented people except by accident.  \n\n> Have you thought about how any of these practices would scale?\n\nIt's much much cheaper than a bad hire.  \n\n> Just like skilled engineers, skilled tech recruiters don't grow on trees\n\nI agree that great recruiters don't grow on trees, there are probably fewer great recruiters than there are great engineers.  That statement wasn't designed to imply otherwise, merely to point out that recruiters that have no understanding of tech aren't going to do a good job.\n\n> one shouldn't express derision just before asking for a favor\n\nCalling someone \"not Google\", it's not derision it's truth (unless you actually are Google).  Google gets inundated with great talent, it's reasonable (and accurate) to believe that 99% of companies do not.  The only \"favor\" I'm asking is a recommend if you like the post, if someone hits me up for a project, one can reasonably assume that they're not trying to do me a favor but rather to enter into a mutually beneficial relationship.", "id": "d27uq2l"}], [{"comment": "HackerRank is not a bad tool, it just has nothing to do with helping you hire a great software engineer. It's an easy way to filter out bad candidates with a minimum of effort. I can't see any reason not to have a straightforward 1 or 2 hour HackerRank; it's eliminating only people who are very poor programmers or who have very poor attitudes, with zero effort on your side.\n\nEach time someone had a decent resume but did terribly on an easy HackerRank, some developer at that company just saved an hour. There's basically no downside, and that's why it's so widely used.", "id": "d283wct"}, {"comment": "It actually is pretty terrible, and the problems have nothing to do with how easy it is for managers to set up.  \n\nFor starters, you shouldn't use trivia and quizzes to hire (https://signalvnoise.com/posts/3071). Secondly, it tests nothing of value as a senior engineer.  I can't find the link right now but there was some article online about someone giving the test to their existing team.  The worst performers routinely did the best, the best did the worst.  Best case, codility and hackerrank test how long you've been out of school (the lower your score, the longer you've been doing real work), worst case, they test how well you can google the answer and paste it into the box.", "id": "d286z0j"}, {"comment": "> For starters, you shouldn't use trivia and quizzes to hire\n\nHackerRank offers quizzes and tests too, but its main feature is making a candidate write code that has to pass a suite of unit tests. Have you ever used HackerRank?\n\n> Secondly, it tests nothing of value as a senior engineer.\n\nIt tests whether or not someone can write very simple code. If you can't write code that passes FizzBuzz, I simply don't care what you claim to have done in the past, or even what code you show me that you claim to have written.\n\n> some article online about someone giving the test to their existing team. The worst performers routinely did the best, the best did the worst.\n\nPerhaps talking about Peter Norvig's talk where he said that at Google, winning programming competitions correlated negatively with performance reviews. In any case, going from that fact to the idea that programming competitions are not useful for selection is a statistical fallacy.\n\nIt's like saying: \"within the NBA, height is negatively correlated with points, therefore height is inversely correlated with being a good basketball player\". People hired by google have already gone through a selection process that valued coding tests; it probably over-values it simply because it's easier to test. As a result, you get negative correlation. This does not mean that in the general population (i.e. including people rejected by Google), that programming tests correlate negatively with programming skill.\n\nBtw, to make things concrete, consider a problem like this: https://www.hackerrank.com/challenges/sherlock-and-array. This problem is basic reading comprehension, plus extremely basic things like comparison and accumulation. A decent high school CS student can get this in ten minutes. If you can't do this in an hour in a language of your choice, it's not worth sometime's time to talk to you for an hour. And yes, many people will not be able to get a perfect score on a question like this in an hour.", "id": "d28ag4u"}], [{"comment": "Sure this kind of blog posts massages the ego of an underpaid and unappreciated superstar that keeps asking himself why is nobody hunting for his head.\n\nBut if we want to talk about hiring problems the unpleasant truth runs a bit deeper I am afraid. The companies lie about positions as much as candidates lie about their abilities and experience. It's not gonna be a bleeding edge swarm of highly scalable micro-services. It's gonna be a horrible dung of legacy Ruby code and some badly normalized MyISAM database. Buy hey, come on, you're not a ninja superstar either.\n\nAnd the markets are quite efficient in pairing shitty developers with horrible working places. Sure as a company you can follow the 5 steps, fake it a bit, but it is to proper team building what pick-up is to romance.\n", "id": "d28s3gi"}]]], "4ru9a2": ["Good coding instincts will eventually kick you in the teeth", "2016-07-08 15:41:54", 1, "https://medium.freecodecamp.com/good-coding-instincts-will-eventually-kick-you-in-the-teeth-2b3766897f3f#.2toumm96d", [[33, "So tired of these banner images that must be scrolled past to get to content. It seems like they are on every Medium post these days. I'm running a 1920x1080 and have to scroll *more* than a single page to get to the content on this one."], [11, "> Remove components from the solution until it starts working again, then put the components back one-by-one in order to find the broken piece. This feels tedious and scary, but it is one of the most effective, disciplined ways to find the cause of a bug in your code.\n\nGood advice, for certain problems.\n\n> Make sure you have a backup before you start though, in case you accidentally end up with Humpty Dumpty code (code that you can\u2019t put back together again). By the way, if you find yourself in a situation where you don\u2019t know how to reassemble the code back to how it was, this is an indication of a potentially bigger problem: you don\u2019t understand the codebase you\u2019re working with.\n\nI'm sorry, what? That's indicative of an easily solvable problem: You're not using source control."], [10, "Git bisect is also a useful tool. If your version control tool supports it or something like it.  It can be easier to go back to when something worked for sure and follow the chsin backwards. It may turn out to be a dependency upgrade for example that created a bug. "], [6, "I have never really recognized any kind of instinct in play with coding.\n\nAlso the post narrows out a lot. In title it's \"coding\", in middle of text it's \"debugging\".. When you read it through, you find out it's actually just about discovery of bugs and hardly about fixing them.\n\nThere are lot of dynamic, mental, hard-to-replicate activity going on when you're doing programming. But they are far away from being instinctual. Every single thing is learned, often during programming."], [6, "From  \"[The Curse of the Gifted](http://www.vanadac.com/~dajhorn/novelties/ESR%20-%20Curse%20Of%20The%20Gifted.html)\" by Eric S. Raymond:\n\n> \u201cWhen you were in college, did you ever meet bright kids who graduated top of their class in high-school and then floundered freshman year in college because they had never learned how to study?  It's a common trap.  A friend of mine calls it \"the curse of the gifted\" -- a tendency to lean on your native ability too much, because you've always been rewarded for doing that and self-discipline would take actual work.\n\n> (...)\n\n> we've seen the curse of the gifted* before.  Some of us were those kids in college.  We learned the hard way that the bill always comes due -- the scale of the problems always increases to a point where your native talent alone doesn't cut it any more.  The smarter you are, the longer it takes to hit that crunch point -- and the harder the adjustment when you finally do.\n\n> (...)\n\n> there will come a time when your raw talent is not enough.  What happens then will depend on how much discipline (...) you developed *before* you needed it, back when your talent was sufficient to let you get away without.\u201d\n\n----\n\nFrom [a comment by Edward Kmett](http://www.johndcook.com/blog/2014/06/12/every-exercise-in-the-book/comment-page-1/#comment-295396) in a blog post by John D. Cook:\n\n> The mathematician] Lorn Olsen used to say he\u2019d rather hire a bunch of \u201cdumb mathematicians\u201d to work on a problem rather than one really smart person who could solve problems in their head. Why? Because the smart person never had to learn how to attack problems that were too big to fit in their head, where the folks with lower mental capacity had to make it through that math degree by learning how to rip off little pieces and make progress as they could."], [2, "I think it's a good article. But when you boil it down, the techniques presented are very intuitive to me. At the end, I thought, \"That's usually how I do it, \" so I guess my intuition is either at this level, or I have discipline already?"], [1, "I can recommend the book \"Debug it!\", it covers much much more, naturally, than the blog post do.\nhttps://pragprog.com/book/pbdp/debug-it"]], [[{"comment": "So tired of these banner images that must be scrolled past to get to content. It seems like they are on every Medium post these days. I'm running a 1920x1080 and have to scroll *more* than a single page to get to the content on this one.", "id": "d546045"}, {"comment": "I agree. Thanks for the heads-up, I won't click on it.", "id": "d54e5tl"}, {"comment": "It also has annoying gifs where normal articles would have images.", "id": "d54t9ox"}, {"comment": "I made a tool called gundog which will just give you the text of a website\n\nhttp://gundog-smalluniverse.rhcloud.com/?gundog_url=https%3A%2F%2Fmedium.freecodecamp.com%2Fgood-coding-instincts-will-eventually-kick-you-in-the-teeth-2b3766897f3f%23.2toumm96d", "id": "d55h1d5"}, {"comment": "You should try posting in /r/firstworldproblems. ", "id": "d54g065"}, {"comment": "[deleted]", "id": "d54p9mp"}, {"comment": "Whoa, guys, you completely missed the point. I was only suggesting that /u/nwoolls should post to that subreddit to reap that sweet, sweet karma. Isn't that what we're here for? ", "id": "d558wd4"}], [{"comment": "> Remove components from the solution until it starts working again, then put the components back one-by-one in order to find the broken piece. This feels tedious and scary, but it is one of the most effective, disciplined ways to find the cause of a bug in your code.\n\nGood advice, for certain problems.\n\n> Make sure you have a backup before you start though, in case you accidentally end up with Humpty Dumpty code (code that you can\u2019t put back together again). By the way, if you find yourself in a situation where you don\u2019t know how to reassemble the code back to how it was, this is an indication of a potentially bigger problem: you don\u2019t understand the codebase you\u2019re working with.\n\nI'm sorry, what? That's indicative of an easily solvable problem: You're not using source control.", "id": "d54ejwb"}, {"comment": "> By the way, if you find yourself in a situation where you don\u2019t know how to reassemble the code back to how it was, this is an indication of a potentially bigger problem: you don\u2019t understand the codebase you\u2019re working with.\n\nI think the author means manually putting the code back to a working. Of course you can just revert the code back to the last working commit, but it proves you have basic understanding of the codebase if you can retrace your steps. ", "id": "d54y9cv"}, {"comment": "But the backups would have nothing to do with that.", "id": "d55rzx4"}], [{"comment": "Git bisect is also a useful tool. If your version control tool supports it or something like it.  It can be easier to go back to when something worked for sure and follow the chsin backwards. It may turn out to be a dependency upgrade for example that created a bug. ", "id": "d545vd4"}, {"comment": "*especially* if you have good tests, then you can bisect automatically", "id": "d546i2l"}, {"comment": "Mercurial has bisect as well, it does really help.", "id": "d54abzf"}], [{"comment": "I have never really recognized any kind of instinct in play with coding.\n\nAlso the post narrows out a lot. In title it's \"coding\", in middle of text it's \"debugging\".. When you read it through, you find out it's actually just about discovery of bugs and hardly about fixing them.\n\nThere are lot of dynamic, mental, hard-to-replicate activity going on when you're doing programming. But they are far away from being instinctual. Every single thing is learned, often during programming.", "id": "d54d3lw"}, {"comment": "I think they're using a less formal definition of \"instinct\". Maybe \"habit\" would be a better replacement. But everything they listed is a habit I've formed over the years, so I don't know.", "id": "d54t78r"}], [{"comment": "From  \"[The Curse of the Gifted](http://www.vanadac.com/~dajhorn/novelties/ESR%20-%20Curse%20Of%20The%20Gifted.html)\" by Eric S. Raymond:\n\n> \u201cWhen you were in college, did you ever meet bright kids who graduated top of their class in high-school and then floundered freshman year in college because they had never learned how to study?  It's a common trap.  A friend of mine calls it \"the curse of the gifted\" -- a tendency to lean on your native ability too much, because you've always been rewarded for doing that and self-discipline would take actual work.\n\n> (...)\n\n> we've seen the curse of the gifted* before.  Some of us were those kids in college.  We learned the hard way that the bill always comes due -- the scale of the problems always increases to a point where your native talent alone doesn't cut it any more.  The smarter you are, the longer it takes to hit that crunch point -- and the harder the adjustment when you finally do.\n\n> (...)\n\n> there will come a time when your raw talent is not enough.  What happens then will depend on how much discipline (...) you developed *before* you needed it, back when your talent was sufficient to let you get away without.\u201d\n\n----\n\nFrom [a comment by Edward Kmett](http://www.johndcook.com/blog/2014/06/12/every-exercise-in-the-book/comment-page-1/#comment-295396) in a blog post by John D. Cook:\n\n> The mathematician] Lorn Olsen used to say he\u2019d rather hire a bunch of \u201cdumb mathematicians\u201d to work on a problem rather than one really smart person who could solve problems in their head. Why? Because the smart person never had to learn how to attack problems that were too big to fit in their head, where the folks with lower mental capacity had to make it through that math degree by learning how to rip off little pieces and make progress as they could.", "id": "d54g8v0"}], [{"comment": "I think it's a good article. But when you boil it down, the techniques presented are very intuitive to me. At the end, I thought, \"That's usually how I do it, \" so I guess my intuition is either at this level, or I have discipline already?", "id": "d54e4y5"}, {"comment": "That's what I was thinking. What kind of instincts is the author talking about that kick you in the teeth?", "id": "d55s20v"}], [{"comment": "I can recommend the book \"Debug it!\", it covers much much more, naturally, than the blog post do.\nhttps://pragprog.com/book/pbdp/debug-it", "id": "d5m3adx"}]]], "3x2g4k": ["How to Make Python Run as Fast as Julia", "2015-12-16 14:20:05", 1, "https://www.ibm.com/developerworks/community/blogs/jfp/entry/Python_Meets_Julia_Micro_Performance", [[8, "Doesn't timeit module ignore Python's garbage collection? It renders such benchmarks a tad inaccurate. "], [6, "This is a great article, thanks for posting.\n\nUltimately though I'm left wondering why python is slow in the first place.  Of course by using extra technologies, and by heavily optimizing your code, with detailed knowledge of what's going under the covers, you can get drastic performance increases.  I'd expect this is the same for every language under the sun.\n\nThe more basic question is why python is so much slower to need this in the first place.\n\n[Various sources](http://www.cdotson.com/2014/08/nodejs-vs-python-vs-pypy-a-simple-performance-comparison/) indicate that a key reason why python is slower is that by default it doesn't use a JIT.   Node.js for example does, and unsurprisingly the performance there is much better.   \n\nSo python has an option for JIT, which is Pypy, and this article suggests an alternative (Numba) as a JIT for a subset of python.\n\nJITs seem fairly clearly good ideas (to me).  Why aren't they defaulted into Python?  Why do we have to bolt them on or otherwise optimize our code?"], [2, "This was posted two days ago.\n\nhttps://www.reddit.com/r/programming/comments/3wsffp/python_matches_julia_performance/"], [1, "I updated the post with Julia running times on the same machine as the one used for Python"]], [[{"comment": "Doesn't timeit module ignore Python's garbage collection? It renders such benchmarks a tad inaccurate. ", "id": "cy11asf"}, {"comment": "That's a good point, thank you.  I didn't know that Julia timeit included gc.  I'll rerun my timing with gc enabled, and will update the post if need be.", "id": "cy23wcb"}], [{"comment": "This is a great article, thanks for posting.\n\nUltimately though I'm left wondering why python is slow in the first place.  Of course by using extra technologies, and by heavily optimizing your code, with detailed knowledge of what's going under the covers, you can get drastic performance increases.  I'd expect this is the same for every language under the sun.\n\nThe more basic question is why python is so much slower to need this in the first place.\n\n[Various sources](http://www.cdotson.com/2014/08/nodejs-vs-python-vs-pypy-a-simple-performance-comparison/) indicate that a key reason why python is slower is that by default it doesn't use a JIT.   Node.js for example does, and unsurprisingly the performance there is much better.   \n\nSo python has an option for JIT, which is Pypy, and this article suggests an alternative (Numba) as a JIT for a subset of python.\n\nJITs seem fairly clearly good ideas (to me).  Why aren't they defaulted into Python?  Why do we have to bolt them on or otherwise optimize our code?", "id": "cy0ynpr"}, {"comment": "As far as I remember Guido wanted to keep CPython implementation relatively simple, since it's default implementation. ", "id": "cy0zn2k"}, {"comment": "In retrospect, after reading http://lucumr.pocoo.org/2014/8/16/the-python-i-would-like-to-see/ I think it might just be an excuse for poor interpreter design.", "id": "cy153gy"}, {"comment": "JITs are not obviously a better idea. They are slower to start up and make the semantics of interacting with C code harder. Not having a JIT is an explicit and valid tradeoff to make in a language implementation. ", "id": "cy15jwz"}, {"comment": "Is rapid startup time really a concern that python is optimizing for?\n\nPerhaps it does make the semantics of interacting with C code harder, but that's not something that everybody does, and even if it is harder, it's still possible and python has been around for a long, long, long time in tech terms.  Nowadays, people probably wouldn't run java without a JIT.  \n\nHaven't these problems really been worked out?", "id": "cy16pp1"}, {"comment": "Anyone who writes CLI tools cares about startup time. Python is a great language for CLI tools and scripts -- by sheer number certainly the most used language for them. \n\nSame reason Java is not a popular language for CLI tools and scripts, and the folks that do write serious CLI tools in Java usually resort to persistent background daemons. ", "id": "cy172dz"}, {"comment": "> Is rapid startup time really a concern that python is optimizing for?\n\nYes. Think about it: If you write a simple interpreter for your language, it's clear you sacrifice performance to reap the potential benefits of an interpreter: To have a great API for the host language to embed or for fast startup times. Unfortunately, Python isn't really convincing at one of these.\n\n> Haven't these problems really been worked out?\n\nLooking at LuaJIT or V8, they have been for simpler languages and their simpler-than-JVM compilers. Maybe they trade that for a longer warmup phases or less optimizations.\n\nAlso, I suspect V8 and LuaJIT typically have less standard libraries to begin with. Who knows if it's feasable for Python, probably only the PyPy team.\n\nAnother problem is that you can't inject code into memory everywhere.", "id": "cy1bcm0"}, {"comment": "I like the phrase Just Too Late to describe JITs. Because if it was \"just in time\", then the optimized code would be ready to run the moment that the computation was started, rather than being compiled later.", "id": "cy18url"}, {"comment": "[deleted]", "id": "cy1ckmt"}, {"comment": "Not with a JIT directly, I guess, but they're usually paired with complicated GC systems, and those require a lot more work to interact with C.", "id": "cy1cv7u"}], [{"comment": "This was posted two days ago.\n\nhttps://www.reddit.com/r/programming/comments/3wsffp/python_matches_julia_performance/", "id": "cy11yto"}], [{"comment": "I updated the post with Julia running times on the same machine as the one used for Python", "id": "cy27spk"}]]], "4sadz0": ["Fancy vanillaJS (no libraries) button radio alternative to hamburger menu. More appealing for your UIs!", "2016-07-11 15:11:06", 5, "https://bguzmanrio.github.io/vanilla-fancy-selector/", [[35, "That's pretty terrible usability wise. Slow to show, slow to use and doesn't work with keyboard."], [9, "I always found it funny that hamburger menus were called that - because they are an example of [mystery meat navigation](https://en.wikipedia.org/wiki/Mystery_meat_navigation)."], [9, "Whoever designed this has never seen a {windows/linux/emacs/vim} power user or even a good game interface.\nOk I know the objectives aren't the same, but still... \n\nThose top warcraft players could do 20 moves during the animation time..."], [3, "Such lag. Boot it off the map."], [3, "Right now, it's too slow. Slow in the sense the animation time is way too long, and slow in the sense that the frame-rate is too low (especially on mobile - it takes a nose dive on my Nexus 6p). \n\nEDIT: \n\nJust had a quick look at your source - this isn't a good way to animate anything:\n\n    for (let i = 0; i < this.nItemsAround; i++) {\n        setTimeout(function () {\n            selector.incrementalFunction(selector.list, baseAngle, theoreticalRadius, selector.button.offsetWidth, i);\n            selector.toggleSpinningAfter(i);\n        }, 500 + (i * Selector.STEP));\n    }\n\n\nInstead, call your step function from [window.requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame) and let the browser manage the redraw interval. "], [1, "The icons don't rotate around their centre in Firefox for Android"], [1, "Doesn't fail gracefully at all if you have JS disabled."]], [[{"comment": "That's pretty terrible usability wise. Slow to show, slow to use and doesn't work with keyboard.", "id": "d57s6ms"}, {"comment": "[deleted]", "id": "d57scgv"}, {"comment": "The icons are intended to be used as an example of what could it be used for. And also, the library is thought to be used in mobile UI (which do not usually neither show text nor work with keyboard)", "id": "d57sima"}, {"comment": "[deleted]", "id": "d57smg1"}, {"comment": "It should work wit any kind of HTML elements, but the person who uses it must adapt the styles I provide to make it look beautiful. The part which I worked harder in, was the dynamic arrangement algorithm for the surrounding elements.", "id": "d57wirs"}], [{"comment": "I always found it funny that hamburger menus were called that - because they are an example of [mystery meat navigation](https://en.wikipedia.org/wiki/Mystery_meat_navigation).", "id": "d57rnsr"}, {"comment": "The hamburger menu isn't a mystery meat navigation example though.", "id": "d581y1w"}, {"comment": "[deleted]", "id": "d586axp"}, {"comment": "It's a fairly standard icon which doesn't link anywhere - it pops up a menu instead - so the hamburger menu itself does not fit the definition of mystery meat navigation.\n\nThat's like saying the \"+\" sign used to expand tree views in user interfaces is mystery meat navigation.", "id": "d586j8j"}], [{"comment": "Whoever designed this has never seen a {windows/linux/emacs/vim} power user or even a good game interface.\nOk I know the objectives aren't the same, but still... \n\nThose top warcraft players could do 20 moves during the animation time...", "id": "d57ytiz"}, {"comment": "The meaning of this widget is not create a super fast UI for expert user, but an soft and smooth experience for clean UI", "id": "d58donm"}], [{"comment": "Such lag. Boot it off the map.", "id": "d57x7rn"}], [{"comment": "Right now, it's too slow. Slow in the sense the animation time is way too long, and slow in the sense that the frame-rate is too low (especially on mobile - it takes a nose dive on my Nexus 6p). \n\nEDIT: \n\nJust had a quick look at your source - this isn't a good way to animate anything:\n\n    for (let i = 0; i < this.nItemsAround; i++) {\n        setTimeout(function () {\n            selector.incrementalFunction(selector.list, baseAngle, theoreticalRadius, selector.button.offsetWidth, i);\n            selector.toggleSpinningAfter(i);\n        }, 500 + (i * Selector.STEP));\n    }\n\n\nInstead, call your step function from [window.requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame) and let the browser manage the redraw interval. ", "id": "d580u92"}, {"comment": "The animation is made through CSS, that timeout is only to move each of the menu items asynchronously\n", "id": "d58eyru"}, {"comment": "Wow. That's terrible, so if one of the frames takes too long to render it will screw up the entire animation?", "id": "d585d63"}, {"comment": "How does requestAnimationFrame compare to CSS animations? Previously I've always assumed that CSS animations would be better optimised. ", "id": "d585np7"}], [{"comment": "The icons don't rotate around their centre in Firefox for Android", "id": "d57vce1"}, {"comment": "Thanks, I'll check it out. \n\nPS: Issues would be welcome!", "id": "d57vy7q"}, {"comment": "Just tried it and it does work for me.\n\nThis is actaully an interesting widget. I would drop the rotation animation in application, but I am trying to think of a useful context for this. I am sure there is something out there. Personally I see a jquery plugin being useful and in your interest to provide as well.", "id": "d57wxm1"}], [{"comment": "Doesn't fail gracefully at all if you have JS disabled.", "id": "d57x18u"}]]], "4dlnrx": ["Bitcoin is the money, Waves is the platform", "2016-04-06 17:10:51", 1, "https://blog.wavesplatform.com/we-re-starting-a-new-cryptocurrency-and-we-don-t-want-it-to-be-used-as-currency-1de1bec402c0#.pe2420kmn", [[9, "> We\u2019ll be doing our bit to help Bitcoin become the first INTERnational currency (as opposed to NATIONAL currencies)\n\nUm, the Euro? That is an international currency."], [7, "So many words and I still don't know what it's for. "], [-3, "The blockchain has to be one of the most overengineered and inefficient ways to store information....I can't understand why people insist on developing yet more crapware on top of it."]], [[{"comment": "> We\u2019ll be doing our bit to help Bitcoin become the first INTERnational currency (as opposed to NATIONAL currencies)\n\nUm, the Euro? That is an international currency.", "id": "d1s389m"}], [{"comment": "So many words and I still don't know what it's for. ", "id": "d1s2bc8"}, {"comment": "It doesn't matter. I am a venture capitalist and I see a company use the word \"blockchain\" and I suddenly want to fork over a million dollars to them.", "id": "d1s4ht3"}, {"comment": "I'm not sure they know what it's for. It sounds like they want to establish another blockchain which will be used for non-money-transfer purposes, but they feel that they ALSO need it to handle money transfer. So they will allow transactions involving USD and CNY and EUR... and also Bitcoins? So I guess there will be some bitcoin transactions in the main BC chain... and other, independent transactions in this chain? So the main BC chain might say that one wallet has certain funds, but this alternate chain would disagree? And presumably, it wouldn't directly handle USD transactions. Surely, you'd need to give your USD to a trusted party in exchange for some sort of digital token, which you can then use in transactions in this new blockchain. So... how is that different from something like Bitcoin?", "id": "d1s2nur"}, {"comment": "Sounds like they think Bitcoin is cool and are trying to do something with it. But are like *\"we should be able to do x, and y, and z too\"*. Ends up being very muddled and confused.", "id": "d1s2wb6"}, {"comment": "I think they read [Steve Yegge's rant on platforms](https://gist.github.com/chitchcock/1281611) and thought \"if we call our thing a platform people will give us more money.\"", "id": "d1s9tjb"}, {"comment": "They don't even describe a platform. It's more like they got stoned and then tried to describe some neat ideas.", "id": "d1saloq"}, {"comment": "Honestly, if I could get stoned and describe some neat ideas AND get someone to give me money for it, I probably would.", "id": "d1sanfu"}], [{"comment": "The blockchain has to be one of the most overengineered and inefficient ways to store information....I can't understand why people insist on developing yet more crapware on top of it.", "id": "d1s2e28"}, {"comment": "Why is it inefficient to store info?  Should they be using memcache servers on everyone's machines?", "id": "d1scj2k"}]]], "4lghw5": ["Remaking Duck Hunt in Java [Part 1]", "2016-05-28 20:38:46", 3, "https://www.youtube.com/attribution_link?a=OCPOSze6i7c&u=%2Fwatch%3Fv%3DyhAQcDVTxTQ%26feature%3Dshare", [[3, "Looks like a cool series /u/KrisitownGaming. I started with Java and would love to see more examples of if its graphical capabilities. \n\nFor anyone who hasn't checked out the video yet, he's going to do more games using languages (and frameworks) other than Java.\n\nCan you post this on /r/java, /u/KrisitownGamin?\n\n"]], [[{"comment": "Looks like a cool series /u/KrisitownGaming. I started with Java and would love to see more examples of if its graphical capabilities. \n\nFor anyone who hasn't checked out the video yet, he's going to do more games using languages (and frameworks) other than Java.\n\nCan you post this on /r/java, /u/KrisitownGamin?\n\n", "id": "d3n99co"}, {"comment": "Hi, first off I want to thank you for the comment, I was started to get worried that it was horrible since all of the dislikes. I will post in on /r/java tomorrow when I get the second part out, as I don't want to be too spammy. I think that I should start getting into the gui part in a couple of days. Tomorrow I finish the model and start with the game loop so maybe after 2-3 more days you can expect the graphical part :)", "id": "d3n9xsb"}, {"comment": "Thank you for the learning opportunity, /u/krisitowngaming.\n\nJava is very unpopular in /r/programming but, why not post anyway?^* You have other languages coming, too. \n\nI think that generally, Redditors don't have a problem with tutorials. They are however, looked down upon when they are obviously blog spam for traffic and, personal promotion. As long as you keep it fresh and engaging, with a not **too** serious professionalism, Redditors will want more. \n\n^* I found some other [subreddits](http://www.google.ca/search?q=game+development+reddit&ie=utf-8&oe=utf-8&gws_rd=cr&ei=GhFKV9-vOs_WyALY4YzIDA) you may want to post to. There's also /r/learnprogramming.\n\n", "id": "d3ne4s8"}, {"comment": "Good one and \u0431\u0440\u0430\u0432\u043e! But you better post it to /r/gamedev. It will be more appreciated there.", "id": "d3o77pl"}, {"comment": "Thanks! And \u043a\u0430\u043a \u0440\u0430\u0437\u0431\u0440\u0430?", "id": "d3o8fd1"}, {"comment": "Github link in Youtube.", "id": "d3o9o6y"}, {"comment": "Aaaaah, of course/\u0440\u0430\u0437\u0431\u0438\u0440\u0430 \u0441\u0435 :D", "id": "d3obo7r"}]]], "4vwjov": ["You don\u2019t need to build a narrative", "2016-08-03 07:32:42", 5, "https://medium.com/@rtotheohan/you-dont-need-to-build-a-narrative-7dffe39969df#.ql6lultrt", [[22, "Good writing but seriously in the wrong place don't you think?"], [3, "> From the point of Bill, it looked like he was a promoted as a result of his efforts at work (fundamental attribution error).\n\nThe FAE is about how we attribute peoples motivations for their own actions. Basically \"I do what I do because of the situation I'm stuck in, but you do what you do because you're a bad person\" - we assume our own actions have external motivations, but others have internal motivations, and although it's technically not always about blame, in practice it pretty much is. Oddly enough in severe depression, the FAE flips to \"I do what I do because I'm a bad person, but you do what you do because of the situation you're in\".\n\nAt least on the surface, the managers motivations were external either way - motivated either by Bills efforts, or by the wider situation that Bill was unaware of. Bills assumption that he had more influence over events than he actually had is a different cognitive bias. Whoever you're focussing on, the FAE doesn't seem relevant.\n\n> What I mean is that Bill couldn\u2019t have predicted his promotion at that point in time, but when he looked at it in retrospect, everything sort of fit together.\n\nI think this is basically a quote, probably of Steven Pinker, but people are exceptionally good at spotting patterns - so good that we see them even where no pattern exists.\n\n> If only we could filter out these statements from our discourse. They denote a sequence of events as cause and effect and end up rewiring people\u2019s understanding of world.\n\nActually no, they literally do not denote causality at all. \"And then\" denotes a conjuction (both occurred) and a time sequence (the second happened after the first). The only reason that seems to imply causality is because of the cognitive error OP is describing in the first place. This mis-attribution happens often enough that those words are no doubt a reflexive trigger, but if you could erase the words \"and\" and \"then\" from the English language it wouldn't make any significant difference. People would still misinterpret correlation as causation. We would simply find other ways to communicate the correlation and time sequence, and learn new reflexive trigger words.\n\nActually, blaming the words \"and then\" is an *example* of the same basic error that OP is complaining about - blaming an apparent pattern that, even if the correlation exists, really isn't causal in any substantial way.\n\nThe same for blaming the human tendency to construct narratives - that certainly involves simplifications and errors, but of course people form ideas about why things happen, and of course these explanations are normally crude approximations because our knowledge is very limited. That's irrespective whether our understanding of the world is in the form of a narrative or not.\n\nAs soon as we go beyond listing direct observations (and actually, even *when* listing apparently simple direct observations) we make mistakes, draw false inferences etc. That's not even uniquely human. If you have a philosophical bent, or even if you once watched the Matrix, you should be aware that even the existence of the world you seem to observe is a potentially false inference.\n\nPerfect knowledge and understanding is not a practical goal. You have to do the best you can with what you've got. If you don't make potentially-wrong inferences, you end up not having a working model of the world around you and being unable to function well in it - irrespective of whether that world is real or not.\n"], [2, "And in the rare case that you *do* need a narrative, there's a [tool for that](https://github.com/BenWiederhake/narrate) (shameless plug)"], [1, "The best examples of these are people who hit the startup jackpot through largely luck (of course you do have to take the startup plunge in the first place), and then write books about how to be successful and be a leader at 23 years old.\n\n\n\n"], [1, "Appears to rip off mark Cubans comments about  the Mavs-heat final"], [1, "This has nothing to do with programming."]], [[{"comment": "Good writing but seriously in the wrong place don't you think?", "id": "d6253dw"}], [{"comment": "> From the point of Bill, it looked like he was a promoted as a result of his efforts at work (fundamental attribution error).\n\nThe FAE is about how we attribute peoples motivations for their own actions. Basically \"I do what I do because of the situation I'm stuck in, but you do what you do because you're a bad person\" - we assume our own actions have external motivations, but others have internal motivations, and although it's technically not always about blame, in practice it pretty much is. Oddly enough in severe depression, the FAE flips to \"I do what I do because I'm a bad person, but you do what you do because of the situation you're in\".\n\nAt least on the surface, the managers motivations were external either way - motivated either by Bills efforts, or by the wider situation that Bill was unaware of. Bills assumption that he had more influence over events than he actually had is a different cognitive bias. Whoever you're focussing on, the FAE doesn't seem relevant.\n\n> What I mean is that Bill couldn\u2019t have predicted his promotion at that point in time, but when he looked at it in retrospect, everything sort of fit together.\n\nI think this is basically a quote, probably of Steven Pinker, but people are exceptionally good at spotting patterns - so good that we see them even where no pattern exists.\n\n> If only we could filter out these statements from our discourse. They denote a sequence of events as cause and effect and end up rewiring people\u2019s understanding of world.\n\nActually no, they literally do not denote causality at all. \"And then\" denotes a conjuction (both occurred) and a time sequence (the second happened after the first). The only reason that seems to imply causality is because of the cognitive error OP is describing in the first place. This mis-attribution happens often enough that those words are no doubt a reflexive trigger, but if you could erase the words \"and\" and \"then\" from the English language it wouldn't make any significant difference. People would still misinterpret correlation as causation. We would simply find other ways to communicate the correlation and time sequence, and learn new reflexive trigger words.\n\nActually, blaming the words \"and then\" is an *example* of the same basic error that OP is complaining about - blaming an apparent pattern that, even if the correlation exists, really isn't causal in any substantial way.\n\nThe same for blaming the human tendency to construct narratives - that certainly involves simplifications and errors, but of course people form ideas about why things happen, and of course these explanations are normally crude approximations because our knowledge is very limited. That's irrespective whether our understanding of the world is in the form of a narrative or not.\n\nAs soon as we go beyond listing direct observations (and actually, even *when* listing apparently simple direct observations) we make mistakes, draw false inferences etc. That's not even uniquely human. If you have a philosophical bent, or even if you once watched the Matrix, you should be aware that even the existence of the world you seem to observe is a potentially false inference.\n\nPerfect knowledge and understanding is not a practical goal. You have to do the best you can with what you've got. If you don't make potentially-wrong inferences, you end up not having a working model of the world around you and being unable to function well in it - irrespective of whether that world is real or not.\n", "id": "d626nq4"}], [{"comment": "And in the rare case that you *do* need a narrative, there's a [tool for that](https://github.com/BenWiederhake/narrate) (shameless plug)", "id": "d629ys4"}, {"comment": "I like that :)  I'm gonna jsfiddle it if you don't mind.", "id": "d62mwtf"}, {"comment": "Hell yeah :)\nCan you post a link to it if it's done?", "id": "d63792v"}, {"comment": "ok, I'm gonna have to take some hashing liberties though :)\n\nthe denominator in:\n\n    hash_multiplier = responses_total_weight * 1.0 / \\\n                  int('f' * hash_method().digest_size * 2, 16)\n\n\nevaluates to 1461501637330902918203684832716283019655932542975 !!!", "id": "d63c2xf"}, {"comment": "turns out floats are the same in js and python so I kept that range.\n\nhere's the link to  the implementation\n\nhttps://jsfiddle.net/1o501mu4/1/", "id": "d63iezk"}, {"comment": "Umm\nYeah, that's because I hash the input, and interpret as a hexadecimal number, and then rescale onto the range [0,1].  `hash_multiplier` is just the constant dividend in that calculation.\nFeel free to use a different hashing scheme, or (sigh) even `rand()` if you must.", "id": "d63nuoz"}, {"comment": "lol, I had already sorted it with sha1 :)  take a look\n\nhttps://jsfiddle.net/1o501mu4/1/\n\nedit: I didn't notice the linefeed vs \"?\" delimiter but you get the idea.  The responses should be the same otherwise.\n\nI was concerned that you were taking advantage of unlimited integer sizes in python, but the floats are the same from python to js, so it was no problem.", "id": "d63t546"}, {"comment": "Hmm, doesn't work in Firefox 45.2.0 ESR, the console says `srcElement is undefined`.  Setting a breakpoint in the true-branch of `chkinput()` shows me that indeed, there is no `srcElement` member/field/element/whateverkidscallitthesedays in `event`.\n\nBut it's awesome that you stayed close to the original style of it :D", "id": "d64n542"}, {"comment": "ok, I made an update for FF (note, you can modify and hit update for a new fiddle url too)\n\nhttps://jsfiddle.net/1o501mu4/2/\n\nInstead of getting fancy with the event method, I just used the textarea reference I already had.", "id": "d658uw8"}, {"comment": "Last fun fact before I disappear:  Both versions answer appropriately to the question `Is this identical to the Python/SHA version?`, i.e., the Python/SHA version answers `Yes.`, whereas the javascript version answers `No.` (and complains that the question is not a question).", "id": "d67uoco"}, {"comment": "I couldn't actually run your program, it was missing something called \"blessings\", so there was some guesswork, but whatev.  \n\nYou probably cut and pasted, there is an issue there with no keypressing going on.  It returns the same string if you type it in.\n\n    User:\n    Is this identical to the Python/SHA version?\n\n    God:\n    Yes.\n\nUser:\n\n\n", "id": "d67va4g"}], [{"comment": "The best examples of these are people who hit the startup jackpot through largely luck (of course you do have to take the startup plunge in the first place), and then write books about how to be successful and be a leader at 23 years old.\n\n\n\n", "id": "d62fncq"}], [{"comment": "Appears to rip off mark Cubans comments about  the Mavs-heat final", "id": "d62y2gp"}], [{"comment": "This has nothing to do with programming.", "id": "d68vpfs"}]]], "4927p3": ["Reza Rahman: Why I Left Oracle", "2016-03-05 15:18:46", 2, "http://blog.rahmannet.net/2016/03/why-i-left-oracle.html", [[35, "There's nothing of substance here. Vague mention of Cameron being \"made to leave,\" vague mention of possible issues of all facets of Java, vague mention of issues the Java enterprise community is \"coalescing\" around. Non-specific \"skepticism.\" Some undescribed threat to \"global IT itself.\"\n\nIf you have concrete issues with Oracle or how they're handling Java, EE or otherwise, and you want to help the community you feel is threatened, *be specific.* Or be silent. All this does is spread FUD. I felt like I was in a spy movie reading this, where Spectre is secretly undermining Java with the intent to destroy computing as we know it and thus take over the world."], [24, "[deleted]"], [6, "The real question is why left so late"], [5, "An evangelist...  \nWhat a loss for Oracle! \\s"], [3, "> This is the portfolio that has helped make us all successful for the past two decades.\n\nIs it really? Java EE is a very niche thing."], [2, "It seems me an outcome of Oracle focussing on core Java and cutting JavaEE monstrosity that Sun created. All those design pattern laden enterprise architect astronauts suddenly seems less in demand. I may not be biggest fan of Oracle but I think in case of evangelist types leaving Oracle is good thing. \n\nThere seems to be tremendous activity in OpenJDK projects which means Oracle is finally concentrating on core technology and leaving those JavaEE folks to find something else."], [0, "Leaving a company and then calling its employees \"corporate drones\" is not just silly, it shows a lack of class and professionalism. There's nothing ever to be gained by burning bridges this way.\n\n"], [0, "Why I don't care about your career choices...."], [-6, "Everybody is moving on from the Java ecosystem.  Now that dotnet is officially crossplatform it's over for the JVM.  "]], [[{"comment": "There's nothing of substance here. Vague mention of Cameron being \"made to leave,\" vague mention of possible issues of all facets of Java, vague mention of issues the Java enterprise community is \"coalescing\" around. Non-specific \"skepticism.\" Some undescribed threat to \"global IT itself.\"\n\nIf you have concrete issues with Oracle or how they're handling Java, EE or otherwise, and you want to help the community you feel is threatened, *be specific.* Or be silent. All this does is spread FUD. I felt like I was in a spy movie reading this, where Spectre is secretly undermining Java with the intent to destroy computing as we know it and thus take over the world.", "id": "d0oh9rg"}, {"comment": ">Vague mention of Cameron being \"made to leave,\"\n\nPerhaps that was related to this:\n\nhttps://mail-archives.apache.org/mod_mbox/www-jcp-open/201510.mbox/%3C9CAB30A4-957B-4919-89CD-78137968D1B6@gmail.com%3E\n\nI did know Cameron as an important driving force behind Java and Java EE. And his tweets indicated that he didn't left by himself. See the fortune article:\n\n* http://fortune.com/2015/09/07/oracle-cuts-java-execs\n\nIf this blog is the first you read about the situation, yes, it may be seen as vague. If you have followed the stories around this lately then all I can say it that it doesn't bode well at all for Java.", "id": "d0ollbw"}, {"comment": "> If this blog is the first you read about the situation, yes, it may be seen as vague.\n\nWell to be fair not everyone's following (and investing the energy on) the drama around Java EE and this is why this post IS vague, lacks substance and is being downvoted to oblivion.\n\nSomebody should write an article or post on the subject that can give the context and the details to have decent discussion on the subject on proggit.", "id": "d0osru1"}, {"comment": "\n> Somebody should write an article or post on the subject that can give the context and the details to have decent discussion on the subject on proggit.\n\nSomeone should yeah, could you be that person?", "id": "d0ou4ar"}, {"comment": "I can't basically because I don't know shit about what's happening. That's my point: most people here (including me) don't understand the situation and that's why this kind of articles will be downvoted to hell.", "id": "d0ov6jv"}, {"comment": "While it's nice to have a little context, I still don't see what this post by Rahman adds to it. \n\nIf you're interesting in raising awareness for why Cameron left, perhaps those links would have been better to submit? Rahman didn't add any details about that situation, either as facts with verification or as opinions or theories. You could read the Fortune article alone, or read Fortune + Rahman, and get exactly the same amount of information either way.\n\nAnd Cameron leaving is the single concrete point he references, with everything else being \"the community\" and \"global IT.\" No specific company, person or organization. No specific threat or malfeasance, nothing to suggest Oracle is actually doing anything unethical or illegal or even not in the best interests of the Java ecosystem. No evidence is presented, no theories put forward, no personal opinions rendered. He doesn't even say what he's skeptical about other than \"Oracle\" which is uselessly vague. That blog post adds literally nothing to the ongoing story of Oracle and Java.\n\nAnd yeah, he's probably under an NDA and may not be able to provide any specifics. Fine. But *why write the article at all* if there is no informative value?\n\nThe only thing the post does is create uncertainty about Oracle's intentions with Java, and there is no evidence provided to support that. Publishing the article seems irresponsible to me on those grounds, and not worth talking about here in my opinion.", "id": "d0p0la6"}, {"comment": "Slight correction: Cameron didn't leave, he was explicitly fired. He says so himself in the email linked above.\n", "id": "d0pbzht"}, {"comment": "> That blog post adds literally nothing to the ongoing story of Oracle and Java.\n\n\nIt does, since before the articles mentioned unnamed former Oracle employees. And people brushed them off as being FUD spread by Pivotal (the Spring company, Java EE's major competitor).\n\nBut now we have for the first time I belief an actual name of an actual Oracle employee, and also not just any employee. He may not be as direct about it as we all wish, but IMHO it gives much credibility to the previous reports.\n\n>The only thing the post does is create uncertainty about Oracle's intentions with Java, and there is no evidence provided to support that.\n\nNo evidence you say? :X\n\nIf you're interested in the topic, look at the various Java EE mailing lists, and look in the repositories for the implementation code. \n\nThese were posted a couple of times before, but there we go again:\n\n* https://github.com/spericas/ozark/graphs/contributors\n* https://github.com/javaserverfaces/mojarra/graphs/contributors?from=2015-03-02&to=2016-03-12&type=c\n* https://twitter.com/jms_spec/status/689762921988132864\n* https://jcp.org/aboutJava/communityprocess/ec-public/materials/2015-12-15/December-2015-Public-Minutes.html\n\nAnd then look at the GlassFish 5 (Java EE 8 RI) builds, an automated zombie process with not a single Java EE 8 commit yet, and frankly almost none commits at all (see changes file for every build):\n\n* http://download.oracle.com/glassfish/5.0/nightly/index.html\n\nThe story is the same for no matter what Java EE list or repo you look at, with the exception of CDI which is lead by Red Hat.", "id": "d0pjsff"}, {"comment": "Oracle has basically never been a good steward of anything and are notorious as sociopaths where sociopathy is the norm, there is absolutely no reason to ever give them the benefit of the doubt on anything.", "id": "d0ov0ew"}, {"comment": "tl;dr: there's more money to be made if I do consulting.", "id": "d0oimlw"}, {"comment": ">there's more money to be made if I do consulting.\n\nI've been following the scene and the rumours of lately, but from all that I've heard that's very unlikely to be the case.\n\nPerhaps he's still under some NDA and still can't disclose exactly what's going on, but you don't even have to have insider info as a lot is out in the open. Shortly after JavaOne each and every Java EE specification either completely stopped or severely slowed down.\n\nI monitor all the spec activity normally on a daily basis and have breakfast while I read through all new developments, commits etc (hey, we all have our hobbies). Before I regularly didn't have enough time to read through all of it, and then suddenly there was hardly something to read at all.\n\nThe little news that still comes in is 99% from volunteers who help out. Almost nothing comes from Oracle staff.\n\nThen there are these articles:\n\n* http://www.infoworld.com/article/2980686/java/sources-oracle-releases-java-evangelists.html\n* http://www.infoworld.com/article/2987529/java/insider-oracle-lost-interest-in-java.html\n* https://jaxenter.com/oracle-and-javas-planned-obsolescence-121144.html\n\nAnd now there's the top evangelist leaving. There's without a shadow of doubt more going on than just some FUD.\n\n", "id": "d0olger"}, {"comment": "There are around 30 companies mentioned in expert groups and executive comitte, aren't they interested too? Ibm? RedHat? AFAIK current JEE is basically all done by RedHat- it's old j2ee + seam3 and Hibernate. Apache is the only foundation that did alternative implementations of JEE JSRs, and they left Java executive commitee. There were not much changes in JEE7 too", "id": "d0paz7b"}, {"comment": "Wow, that's a bit uninformed. Sorry ;)\n\nRed Hat leads the CDI and BeanValidation specs. Despite what everyone thinks, Hibernate is not the RI implementation, that's EclipseLink. JPA (which is implemented by Hibernate, EclipseLink and OpenJPA) is lead by Oracle.\n\nIBM leads the Batch spec, but this one is not updated for Java EE 8, so at the moment IBM isn't actively working in any spec.\n\nOracle leads all other specs.\n\n>Apache is the only foundation that did alternative implementations of JEE JSRs\n\nNo, they were not the only one. Implementations of at least one Java EE spec were done recently by Red Hat, Oracle, Apache, IBM, TMax, Caucho and OW2.\n\nSome of them may be lesser known, but they are real certified implementations. E.g. OW2 has its own EJB implementation called EasyBeans: http://www.easybeans.org/\n\nCaucho has its own CDI implementation called CanDI.\n\nTmax has its own implementation of the Java EE concurrency spec.\n\nFor a somewhat older list see this overview: \n\n* http://arjan-tijms.omnifaces.org/2014/05/implementation-components-used-by.html\n\n\n> [Apache] left Java executive commitee. \n\nWhich is unfortunate indeed, but did not stop their member projects implementing Java EE specs or even contributing to the spec discussions (being an EG member). See what OWB, TomEE and MyFaces are doing for example.\n\n>There were not much changes in JEE7 too\n\nReally? \n\n* http://blog.eisele.net/2015/12/a-refresher-top-10-java-ee-7-backend.html\n* http://blog.eisele.net/2016/01/a-refresher-top-5-java-ee-7-frontend.html\n* https://javaee7.zeef.com/arjan.tijms\n\nQuite a lot of changes if you ask me.\n\nI do agree that of those 30-something companies mentioned shamefully few of them actually contribute by taking up any portion of the implementation tasks.\n", "id": "d0pk36q"}, {"comment": "> Some undescribed threat to \"global IT itself.\"\n\nEveryone knows that global threat\n\nIt the precedent case of copyright on APIs", "id": "d0phaya"}, {"comment": "What \"community\" do you think you represent?", "id": "d0ovmnu"}, {"comment": "What's your position at Oracle?", "id": "d0ou3kh"}], [{"comment": "[deleted]", "id": "d0ogbxg"}, {"comment": "You just reminded me of [one of my favorite rants ever](https://youtu.be/-zRN7XLCRhc?t=33m). The target being, of course, Oracle.", "id": "d0ope6o"}, {"comment": "\"do not fall into the trap of anthropomorphizing Larry Ellision.\"", "id": "d0pam25"}, {"comment": "\"The lawn mower doesn't care!\"", "id": "d0ph0q5"}, {"comment": "I was about 90% sure it was that rant and then you confirmed it.\n", "id": "d0pguaq"}, {"comment": "Also extremely successful.", "id": "d0ogmci"}, {"comment": "https://www.youtube.com/watch?v=Q1qVJ8bTwuw", "id": "d0olg74"}, {"comment": "Very funny ;) But do remember the JVM is an important target for Clojure to run on. Without that one, it's back to the CLR and JavaScript. Not as nice for sure, right?", "id": "d0olont"}, {"comment": "Java and the JVM are great, but I'd love to know if any executive at Oracle gives a rat's ass about it other than an avenue to sue Google. \n\nCompared to the rest of Oracle's business, I'd think an exec sees it more like a distraction than a core investment for them. Oracle's top concern right now is that PaaS offerings like Workday are eating Oracle's core businesses -- software sales and support are down **20%** and **7%** YoY, respectively.\n\nSo I guess the question is, even with the JVM being great and improving, do people working on it feel like the higher ups are investing in it and they have a future? My guess, given all of these departures, is no.\n\nAnd with that, I just double re-installed CoreCLR, Node and Typescript.", "id": "d0om0d7"}, {"comment": ">My guess, given all of these departures, is no.\n\nI agree. Oracle's engineers deeply care. Higher ups probably not at all.\n\nBut what's really the cost of Java's upkeep? 10 million a year? 100 million? Subtracted by the revenue stream they DO get from Java, isn't the remainder just good PR?\n\nI know many people hated, absolutely downright hated everything Oracle. Oracle can simply not get inside those engineering driven companies. But with Java they were for a while looking to do great, and that hatred softened up a little.\n\nDo they *really* want to throw all that goodwill away? Will they not further slide away by this move?\n", "id": "d0onfce"}, {"comment": "Oracle has never cared much for goodwill. They tend to operate in terms of tangible revenue. Oracle has pretty much stated that they see other companies benefiting from Java as lost revenue. They'd much rather lock their customers into their own proprietary stack. Just look at what happened to all the other open source projects they inherited from Sun, why would Java be any different.", "id": "d0opbjq"}, {"comment": "That's a good question. Will be terrible when that happens. But Oracle has many customers who *do* care about Java and I predict those won't be happy...", "id": "d0ouii3"}, {"comment": "It's hard to say what will actually happen, but it does appear that is the strategy that Oracle is pursuing. I'm certainly not going to argue that it's a sane strategy, but I also don't think Oracle is a sane company. :)", "id": "d0owtj0"}, {"comment": "Oracle is not an engineering driven company and they don't sell things to engineers, they are a sales driven company that sells things to people who don't think anyone ever got fired for going with Oracle.", "id": "d0ov69a"}, {"comment": "With engineering becoming so much more important (think Devops, think docker and all that), how is this Oracle strategy of selling things those non-engineering folks ever going to last?\n\nStartups are engineering driven, almost by definition. And yes, startups ARE using Java EE, since it's way cooler than those indoctrinated with \"JavaScript frameworks of the week\" think. You can start with free and easy TomEE or WildFly. These companies can then later scale up to Oracle products like WebLogic if needed. \n\nBut of Oracle cuts of this migration path, don't they just hurt themselves eventually?", "id": "d0ozbix"}, {"comment": "> startups ARE using Java EE, since it's way cooler than ...\n\nI never thought people would seriously talk about Java being cool again, but it's true.", "id": "d0qvcy4"}, {"comment": "The JVM is a very nice platform. However, it's future looks a lot murkier with Oracle at the helm. Oracle has shown time and again that the company is not capable of playing nice with others. Oracle is hostile towards open source, and they see other companies as direct competition to them.\n\nGiven Oracle history, it wouldn't surprise me to see them forking off Java and the JVM into a proprietary solution where they stop contributing back to OpenJDK altogether. At that point the question becomes whether OpenJDK can be sustained as a cutting edge platform without a large corporation backing it.\n\nMeanwhile, Microsoft has been far more open source friendly with how it's been handling the CLR. Personally, I'm really glad that there is a viable alternative to the JVM. While I hope that the JVM will continue to growing and evolving, I don't think Oracle is the right company to have the stewardship of an open source platform.  ", "id": "d0oot7m"}, {"comment": "Oracle at the helm had been a red flag since day one, but initially it looked like the proved as all wrong. \n\nBut now, I'm not so sure anymore. I agree with your analysis, it's oracle-like to do just that. But who on earth is going to use that proprietary solution? ", "id": "d0oumws"}, {"comment": "That's the real question I think. So far, every time Oracle tried to this with an open source project, it backfired spectacularly. Open Office, Hudson, and MySQL, all ended up being forked with key developers leaving Oracle.\n\nI expect something similar will happens with Java as well, should Oracle continue down this path. However, other companies would have to step in to support serious development of the platform.\n\nIt's not clear how Oracle would react to that. For example, what happens if OpenJDK starts diverging from Oracle JDK. Will Oracle start litigation as they did with Dalvik at that point.\n\nSince latest ruling in Oracle vs Google was in favor of the idea that API is subject to copyright, this gives Oracle the power to sue anybody implementing the API if they so choose.", "id": "d0ox2p1"}, {"comment": "It almost can't be anything else that any attempt from Oracle to close Java and offer a proprietary version will backfire, again.\n\nI'd seriously rather move to PHP before ever using something like that (and I've turned down some amazing offers in the past just because those companies used PHP).\n\nThe Google lawsuit was and is spectacularly complicated, but one thing I think I got from it is that the totally from scratch implementation using a different license was the main issue. Forking and then modifying the OpenJDK code *should* be okay, the license (gpl) already grants you that.\n\nThe only thing whoever would fork the code cannot do in the future is change the license. That one perpetually has to stay GPL and only Oracle could change it in their version. This is likely for the better.\n\nWhat's not clear to me is if Oracle is already working on a closed feature set of Java EE. All those engineers that vanished from the scene. Are they working on their own branch of JSF 2.3 and Servlet 4.0 internally? Or like some of the articles about this topic suggest, did they all got relocated/retasked to work on \"cloud\", whatever that means.", "id": "d0oz01w"}, {"comment": "I think part of it is using the Java trademark as well. What could potentially happen is that the OpenJDK could be rebranded under a different name. At that point Oracle would have absolutely no claims regarding it. I also agree that the the JDK license is good for the platform.\n\nAs you point out, the big question is whether Oracle is going to continue advance the Java platform in the open.\n\nShould Oracle decide to either start creating a closed platform, or abandon it altogether, who would pick it up from there and move it forward.", "id": "d0p8jb8"}, {"comment": "Yes, the name is trademarked and needs to change as well.\n\nThe big question is what Oracle is doing at the moment. As far as I know all the Java (EE) engineers have not been made redundant. That would have been much bigger news.\n\nBut are they working on a closed Java EE, or on something else like an ill fated AngularJS-1 clone, or a Spring Boot clone etc?\n\nGoogle would be a potential candidate to pick up Java SE, but who would pick up EE? IBM and Red Hat have invested a lot in it with Liberty and JBoss, but the both of them could just as well decide to take the gamble and continue on their own.", "id": "d0pmwzy"}, {"comment": "The JVM is too large an effort to be maintained by only one company.", "id": "d0oujoc"}, {"comment": "That's pretty much what's happening right now. Most of the decisions are made by a single company, and Oracle makes all the major decisions regarding the direction of the platform. I'm not sure why you think the JVM is too large for that. Microsoft has been doing the same thing with CLR for years.", "id": "d0ox426"}, {"comment": "Oracle and others employee people all over the world in various positions to make the JVM what it is today.\n\nThe CLR is a toy project by comparison. Because no one had much interest (let alone opportunity) to contribute to it, given Microsoft's licencing.\n\nThings may change. But those changes will take a decade to manifest, if they ever do. ", "id": "d0ozzvb"}, {"comment": "I think it's a bit disingenuous to call CLR a toy a toy project compared to the JVM. Now that it's been released under the MIT license, there's no reason why it shouldn't be a viable open source platform going forward.", "id": "d0p8d9g"}, {"comment": "The conditions are there for the CLR now, and there's indeed no reason why it should not be a viable project going forward.\n\nBut I also agree with the two faced commit, and that's that it takes a lot of time for a culture around such contributions and collaboration to form, and it will simply take a long time for external non-microsoft engineers to get fully up to speed with all the intricate internals of the code.\n\nFor Java/JVM/Java EE that culture and knowledge base is in place **now**, but it looks like Oracle is doing all it can to destroy it.\n\nFor C#/CLR/.NET that culture and knowledge base is not really there at all, but it looks like Microsoft is doing all it can to create it.\n\nSuch strange opposite strategies going on :O \n\nAnd the question is, how much can we trust Microsoft in the long run? They have been pretty evil in the past. Now they're trying to be the Good Guys, but will they stay being that once they become more popular again?\n", "id": "d0pkb7q"}, {"comment": "That's well and good for them(and bad for the world) but anyone relying on them doing right by Java who can't figure out how their interests are aligned with Oracle's bottom line is a fool, because Oracle surely doesn't give a fuck about Java as technology, community or ecosystem in and of themselves.", "id": "d0ov48b"}, {"comment": "[deleted]", "id": "d0on2db"}, {"comment": "> Who fucking cares??\n\nOracle shareholders and Oracle executives. Comparing with genocide does not make sense since every for-profit company has only one goal both according to law and morally - to maximize shareholder profit.", "id": "d0opa1d"}, {"comment": "How many of the shareholders and executives are Java users?  If they are not I don't see how it's relevant to the question of Oracle's impact on Java.", "id": "d0ov856"}, {"comment": "[deleted]", "id": "d0oq5mw"}, {"comment": "Sure but do I care if Oracle plays good with community and free software? Do I care if Oracle sues Google? No, I don't. At least not more than I care about shareholders.", "id": "d0os5s1"}, {"comment": "[deleted]", "id": "d0ot8jv"}, {"comment": "True but the article does not tell us this thing happens at Oracle at all. Neither do people I know who have worked for Oracle.", "id": "d0ou3vh"}, {"comment": "This need a movie.", "id": "d0oy9kk"}, {"comment": "I think the critics will probably \"puke every 50 seconds\".", "id": "d0p0anm"}, {"comment": "I don't think he is that ugly :)", "id": "d0p0sov"}], [{"comment": "The real question is why left so late", "id": "d0ohnnr"}], [{"comment": "An evangelist...  \nWhat a loss for Oracle! \\s", "id": "d0olmlf"}], [{"comment": "> This is the portfolio that has helped make us all successful for the past two decades.\n\nIs it really? Java EE is a very niche thing.", "id": "d0oml75"}, {"comment": "It's not. Java is one of the biggest language eco systems out there, even without Android.\n\nMost of Java code runs server side.\n\nMost server side Java code uses Java EE in one way or the other.\n\nBy simple deduction you can easily see that Java EE is absolutely not niche thing. Many systems use Java EE, perhaps without even knowing it. Be it via Tomcat, JBoss, JSP, Servlets, JPA (perhaps known as Hibernate) even Spring, Spring Boot, etc etc.", "id": "d0ona6w"}, {"comment": "*Java is one of the biggest language eco systems out there,*\n\nIn fact, it might be the biggest language ecosystem. ", "id": "d0ot8kf"}, {"comment": "No, I think that title belongs to C", "id": "d0phcqz"}, {"comment": "They are probably close whichever of those is the absolutely biggest one.", "id": "d0phv0n"}, {"comment": "That's also a possibility. Measuring these things is hard. ", "id": "d0puuqf"}, {"comment": "> Java is one of the biggest language eco systems out there\n\nYes\n\n> Most server side Java code uses Java EE in one way or the other.\n\nI wouldn't be so sure.\n\n> Many systems use Java EE, perhaps without even knowing it. Be it via Tomcat, JBoss, JSP, Servlets, JPA (perhaps known as Hibernate) even Spring, Spring Boot, etc etc.\n\nJava *EE* is just the very particular set of APIs around beans and bean-containers.\n\nServlets, Hibernate, etc. otoh are just loosely tied in and freely exist on their own. Many of them even have simpler/lighter-weight non-spec-compliant alternatives provided by the same implementations.\n\nJava EE dying will not affect them.", "id": "d0oucct"}, {"comment": "> Java EE dying will not affect them.\n\nI don't think so. Without the Servlet spec to bind them, Tomcat, Jetty, Undertow & friends will all go their own way over time. In just a few generations I probably won't be able to run my bare Servlet on either of them. I'd have to write Tomcat code, Jetty code, etc.\n\nIn other words, the huge server side Java ecosystem with all its competitors and different vendors will shatter and all become separate small islands with nothing to bind them but the Java language itself. And don't forget, even the Java language itself is in danger.\n\nAnd it's not just the products itself. It also concerns the mobility of developers. As a dev, I can learn Java EE APIs and can be directly productive in many shops that build server side Java applications. Whether they use Resin, TomEE, Tomcat, JBoss, GlassFish, WebLogic, Liberty, WebSphere, JEUS... it doesn't matter.\n\nNow suppose that all of these would individual stacks, individual frameworks.\n\nAren't we back to the late 90-ties then, where you had the framework of the week thing that now plaques Javascript so much?\n\nAnd even if I would stick to a single stack. Say JBoss, never care about any other stack from any other vendor. We all know that vendors can't their leave APIs alone. They change things for the sake of changing, and we the users have to keep porting our code to the newest version.\n\nThe Java EE APIs for the longest times have been a shield protecting us against the whims of vendors. My Servlet 1.2 app to this very day runs unchanged on the latest version of Java EE. Try that with an application that uses JBoss 2 or 3 APIs directly. It won't work.", "id": "d0phtb6"}, {"comment": "> Most of Java code runs server side.\n\nInvisible unicorns are the most numerous animal on Earth, and most of them choose to remain uncounted.", "id": "d0pewii"}], [{"comment": "It seems me an outcome of Oracle focussing on core Java and cutting JavaEE monstrosity that Sun created. All those design pattern laden enterprise architect astronauts suddenly seems less in demand. I may not be biggest fan of Oracle but I think in case of evangelist types leaving Oracle is good thing. \n\nThere seems to be tremendous activity in OpenJDK projects which means Oracle is finally concentrating on core technology and leaving those JavaEE folks to find something else.", "id": "d0p0f3c"}, {"comment": "> All those design pattern laden enterprise architect astronauts \n\nYou're probably remembering J2EE 1.4. The current version, Java EE 7, is not the home of such people.\n\nAlso, if the rumours are to be believed, it doesn't end with Java EE. Java EE is just the beginning. There's activity in OpenJDK for sure, so it doesn't seem to be in trouble for now, but there have been resources moved already.\n\n    First they came for Java EE\n    and I did not speak out\n    because I was not a Java EE user.\n    They they came for ...\n\n\n", "id": "d0phmu4"}], [{"comment": "Leaving a company and then calling its employees \"corporate drones\" is not just silly, it shows a lack of class and professionalism. There's nothing ever to be gained by burning bridges this way.\n\n", "id": "d0p0bmh"}, {"comment": "\n> Many people seem to have an impression of Oracle as a company full of corporate drones. This is far from the truth. I wasn't, Cameron wasn't and we are very far from being alone. This entry would not be complete without a respectful salute to these courageous folks. They will need our continued total support no matter what and they do what few others would dare or care to (now including myself). I wish the corporate drones and their masters lots of luck - they are going to need it more than ever.\n\nIt's clear from the full quote that it's tongue in cheek and that he's not actually insulting them.", "id": "d0p9xip"}], [{"comment": "Why I don't care about your career choices....", "id": "d0pwhrs"}], [{"comment": "Everybody is moving on from the Java ecosystem.  Now that dotnet is officially crossplatform it's over for the JVM.  ", "id": "d0ou54l"}, {"comment": "Right. So does the CLR do cross platform GUIs as of yet?", "id": "d0owbs2"}, {"comment": "It \"does cross platfrom GUIs\" just like C++ does: through not de facto GUI frameworks/libraries.", "id": "d0ozyhr"}, {"comment": "C++ doesn't do GUIs at all. ", "id": "d0p042b"}, {"comment": "I think tha's his point.", "id": "d0p14pn"}, {"comment": "Does Java? Does Swing count? Does SWT count?  Realistically, ,everybody is moving to React Native or something like Electron.    The desktop is still owned by Microsoft, so ....", "id": "d0oxq6y"}, {"comment": "> Does Swing count?\n\nYes\n\n> Realistically, ,everybody is moving to React Native or something like Electron. The desktop is still owned by Microsoft, so ....\n\nYes. Meanwhile Swing is there, documented and ready for use.", "id": "d0ozudg"}, {"comment": "Swing is as  releveant as gtk+", "id": "d0pl9gs"}, {"comment": "> everybody is moving to React Native or something like Electron\n\nsurely my next calc.exe will be at least 40MiB in filesize, feel like a sluggish fuck and can be hijacked with some stupid xss crap. Perhaps \"everybody\" is thinking this is a good idea but I'm not. Go away with this and leave me alone :).", "id": "d0px378"}, {"comment": "Can you name literally any company or project that publicly mentioned intending to move from Java to C#? Is anyone even running .NET in production outside of Windows yet, when barely months have gone since the release?", "id": "d0p8rj6"}]]], "45qvwm": ["Scala, Erlang and Go compared on 1,111,111 threads", "2016-02-14 17:28:20", 57, "https://github.com/atemerev/skynet", [[81, "These are not equivalent concurrent primitives.  So this is an Apples to Oranges test.\n\nIf you want equivalent, convert the akka/scala code to use Quasar (fibers).  Fibers are more equivalent to .Net's  \"tasks\".\n"], [46, "If anybody is wondering about the extreme good performance of the .NET implementation (like me): It's because it doesn't use threads/actors at all. It only creates completed Task objects through recursive function calls and collects the results. A fairer comparison would probably use Task.Run or sth similar for creating the actors - which is not that fast. However you can also get if fast by implementing a own TaskScheduler/SynchronizationContext. The Hopac library in F# should also yield very good results here."], [28, "[deleted]"], [22, "Here it is in my little scripting language [Wren](http://wren.io):\n\n    class Skynet {\n      static makeFiber(num, size, div) {\n        return Fiber.new {\n          if (size == 1) {\n            Fiber.yield(num)\n          } else {\n            var fibers = []\n            for (i in 0...div) {\n              var subNum = num + i * (size / div)\n              fibers.add(makeFiber(subNum, size / div, div))\n            }\n\n            var sum = 0\n            for (task in fibers) {\n              sum = sum + task.call()\n            }\n            Fiber.yield(sum)\n          }\n        }\n      }\n    }\n\n    var start = System.clock\n    var result = Skynet.makeFiber(0, 1000000, 10).call()\n    var end = System.clock\n    System.print(\"Result: %(result) in %(end - start) s\")\n\nOn my Macbook Pro, it runs:\n\n    Result: 499999500000 in 1.475756 s\n\nNot too bad for a bytecode interpreter that's a little over 3k semicolons of C code.\n\nLike others said, some of the languages are doing different things so the comparison is kind of apples to oranges. Wren uses lightweight cooperative fibers. By default, they work like coroutines as in Lua: you invoke them directly and they don't go through a scheduler.\n\nWhen doing asynchronous IO, you can explicitly hand a fiber to the scheduler. It will then run any fibers that aren't blocked on IO and handle switching between them.\n\nHere, since there is no IO, it just calls the fibers directly."], [23, "tl;dr Oranges are better than apples."], [14, "World's worst benchmark since it doesn't test what it purports too. Net using tasks which are futures vs akka/Erlang which spawn actual actors and all the infrastructure that entails.\n\nTry this with a true actor library for net or use futures in Scala."], [11, "This sub needs a rule that shitty benchmarks aren't allowed."], [10, "I wonder if Erlang would be more competitive with Go on a non-mathematical task. Erlang only uses arbitrary-sized integers and has poor math performance."], [10, "Just as a reference; a relatively straight forward port to C++ with only a single thread doing the work takes roughly 8ms on my i7. So it's pretty cool so see what amount of overheads are involved in the various languages and MT strategies used in their tests."], [5, "Don't forget GHC Haskell!"], [3, "Ye olde [thread-ring](http://benchmarksgame.alioth.debian.org/u64q/performance.php?test=threadring) was less about startup ;-)"], [2, "This doesn't even stand next to a correct example... who even updoves this? Of course .NET fanboys. .NET example does completely different thing than all the others. Apples to Oranges."], [1, "Interesting synthetic benchmark, but not representative of real-world use."], [1, "How on earth was node that fast?"], [1, "I wrote a version using Coro in Perl (so zero parallelism, just overheads) and it runs in ~19 seconds. Took less than 2 minutes to rewrite that without Coro and it completes in ~2 seconds. Both cases on an older HP Microserver"], [1, "Aren't you just measuring the performance of the underlying operating systems thread creation system?  "], [1, "I do not think you're running the Haskell in parallel.  I think you need more options on the command line to run it over multiple cores.\n\nI think a ring simulation would be a better demo too, though this is pretty clever. "], [1, "many (maybe all) off these implementations fail to enforce the \"create a million threads\". instead, they create a few and then start processing them, at which point the code just becomes a simple loop\n\nall this benchmark is really testing is at which point this effect kicks in. the benchmark needs to be changed to require the thread creation completes prior to the start of processing\n\n"], [-4, "why does everyone call everything SKYNET these days, I assure you those will be the first things skynet destroys !!!!1"], [-18, "And Node.js wins here again. Javascript is awesome!"]], [[{"comment": "These are not equivalent concurrent primitives.  So this is an Apples to Oranges test.\n\nIf you want equivalent, convert the akka/scala code to use Quasar (fibers).  Fibers are more equivalent to .Net's  \"tasks\".\n", "id": "czzknp7"}, {"comment": "Akka under the hood uses fibres which may be run on mtiple threads.", "id": "czztk4c"}, {"comment": "Is that a new addition?  When I first reviewed Akka some time ago I think it was threads only. Fibers make much sense however.\n\nAkka's Actors are still a much higher level API than .Net Task or JS Promise.  Something on the JVM which utilizes fibers and a Future style API would be more equivalent.  perhaps we can get /u/pron98 to implement something ?\n\nFinally, anything on the JVM is going to be quite slow unless and until the JIT system gets involved.  Generally JVM benchmarks do a warmup run to ensure that the code has been JIT'd (both levels ) before taking actual data.  As shown in the bench mark it seems that we're incurring the cost of not only the initial interpreted execution but also, possibly, the cost of the JIT operation itself.\n\nHeck even the bluebird/JS benchmark does this warmup operation to involve any JS JIT operations.", "id": "d00888w"}, {"comment": "Hi. Yes fibers are what you want, but I seriously doubt Quasar fibers could be anywhere near competitive in this benchmark in their current state, even though in a real world system they'll perform just as well. The reason is that this benchmark measures overhead only. When you measure just overhead, you can make negligible differences arbitrarily large. If, say, Go's stack maintenance overhead is 2ns and Quasar's is 200ns, Quasar will be (at least) 100x worse in this benchmark (maybe worse, because there are other overheads that are measured here). However, in practice this difference may become effectively zero, because the scheduling operation is only carried out a few thousand times per-second-per core.\n\nThere is absolutely no benefit in benchmarking overhead unless you show that that overhead can be a significant contributor to your program's performance. As the overhead for kernel threads is *really* big (20us for a task switch, sometimes much more, and a lot of RAM), that can make a difference in practice, but differences between 2ns and 200ns scheduling have zero effect in a live system.\n\nIt's like measuring the performance difference between sqrt operations in different languages. Even if the difference is large, it's doubtful to have any impact on performance in practice. It's very easy to get runtimes with very specialized optimizations to beat \"general-purpose\" runtimes this way. But do we really care?", "id": "d00ijjb"}, {"comment": "for any particular implementation, i agree with you. but for the programming model to work / succeed, overhead really does matter - if things that \"should\" have zero cost don't, then the user needs a much more complicated model of the abstractions, and the actor model breaks down", "id": "d00o5en"}, {"comment": "Nothing here has zero costs. The question is simply what is the ratio of the overhead to the total program execution. I say that it is such a small ratio that unless the overhead is really huge (as it is for kernel threads), the arbitrarily large differences that this benchmark demonstrate make not an iota of difference in practice. At the point where parallelization starts yielding significant benefits, most of the implementations here would behave the same. The benchmark tests them well before that point (at a couple of integer arithmetic operation per task).", "id": "d00ohrj"}, {"comment": "> When I first reviewed Akka some time ago I think it was threads only. \n\nThat was my big problem with Akka's actors compared to Erlang's when I tried using it a year or so ago - you couldn't write a blocking actor because multiple actors had to share a thread, but a blocking actor would block the thread. Having to write your code constrained by an implementation detail is a bit of a leaky abstraction.", "id": "d00czra"}, {"comment": "Vert.x uses Quasar fibers. I would like to see that included as a comparison.", "id": "d00ihv9"}, {"comment": "I agree, that's why I did [this version](https://github.com/atemerev/skynet/pull/23) with cooperating multi threading. Unsurprisingly, it runs much faster than anything else, because it's basically a loop with some concurrency primitive in the middle.", "id": "czzv5eb"}, {"comment": "i added a [pull request for kilim](https://github.com/atemerev/skynet/pull/43), another fiber/actor library for java\n\nruns in approximately 3500ms on my ancient x60\n\nkilim actors are comparable to erlang actors (there's an erlang version that uses kilim to run on the jvm called erjang). as others have noted, this test isn't apples to apples - this example should be on the heavier end of the spectrum, ie a good percentage of the million actors should exist at the same time\n\nthe test should really be improved to make this a requirement\n\n", "id": "d00ryrn"}, {"comment": "i hacked in the requirement that all actors be created before processing starts, which increased runtime to maybe 5200ms. i'm not sure how much of this delta corresponds to the added messaging as opposed to the loss of premature optimization\n\n", "id": "d00tlpx"}], [{"comment": "If anybody is wondering about the extreme good performance of the .NET implementation (like me): It's because it doesn't use threads/actors at all. It only creates completed Task objects through recursive function calls and collects the results. A fairer comparison would probably use Task.Run or sth similar for creating the actors - which is not that fast. However you can also get if fast by implementing a own TaskScheduler/SynchronizationContext. The Hopac library in F# should also yield very good results here.", "id": "czzkc10"}, {"comment": "> A fairer comparison would probably use Task.Run\n\nIt does in the latest version, and the numbers are still very good:\n\nhttps://github.com/atemerev/skynet/commit/80e7f9ef782c90da93bd984922caaa26ac55ac67\n", "id": "czzlswh"}, {"comment": "And can be even much faster\n\nhttps://github.com/atemerev/skynet/pull/40", "id": "d00oc2v"}, {"comment": "So what's the difference between those two versions, the only obvious difference is the addition of an `.AsTask()` at the end of the faster one.  But just that is enough to make it run 100x faster!?", "id": "d00v856"}, {"comment": "The `ValueTask<T>` type is optimized for tasks that mostly complete sync - however it has a higher overhead when things complete Async which `Task<T>` is better for e.g. the `ValueTask` is converted to a `Task<T>` when it is not already completed on return.\n\nSo is an example if what you'd do if your async functions mostly completed by the end of their call - i.e. a code path optimised for the completed task route.\n\nAlso the .Net version on the readme.md page is currently run in debug mode.", "id": "d01jnlw"}, {"comment": "Indeed, if you don't use threads/channels at all you can do **much** faster in any language.  See, for example, this Haskell implementation using ordinary recursive parallelism to compute the same result which gives a 100x speedup:\n\nhttps://github.com/atemerev/skynet/issues/17", "id": "czzse8t"}, {"comment": "okay, but isn't this benchmark specifically intending to engage concurrency features?", "id": "czzwozu"}, {"comment": "Yes.  The linked solution would not qualify, but the point is that some of the other language solutions would not qualify either because they are not actually using threads and channels (or they are, but the implementations are not directly comparable).", "id": "czzx4i1"}, {"comment": "Or maybe concurrency is overrated :P", "id": "d009f9n"}, {"comment": "Thanks for this, I was very suspicious about that, especially when everyone on the HN thread is currently going on about how fast the .NET version is.", "id": "czzl2m7"}, {"comment": "> It only creates completed Task objects through recursive function calls and collects the results.\n\nIs this referring to a tail-recursive function?\n\nE.g. like using Accumulator variables in Erlang.", "id": "czzq5ha"}, {"comment": ".NET async/await are about as asynchronous as Node.js callbacks.", "id": "d0032do"}, {"comment": "Unlike node.js code, Tasks *can* run in parallel.", "id": "d00hs20"}, {"comment": "Apart from the fact that the code didn't use async/await: Not really.\n\nIn javascript land a promise continuation will always run in a new eventloop tick, independent of whether it was added with `Promise.then` or `await`ed. And also independent of whether the Promise was already fulfilled when the continuation gets attached or not.\n\nIn .NET continuations can also execute synchonously, depending on a lot of complex to member rules. Using `Task.ContinueWith` will favor scheduling the continuation on the given TaskScheduler (might be the ThreadPool) if not a special flag is set. However when you are awaiting an already completed Task then the continuation will be synchronously executed inside the current stack frame, which will boost the performance (no rescheduling needed), but make things a little less predictable. Interesting is also the situation when you complete Tasks via TaskCompletionSource. In most cases the await continuation is then executed in the context of the await caller, but under some circumstances (`SynchronizationContext` of awaiter vs. `SynchronizationContext` of completer), the await part might also be synchronously executed in `TaskCompletionSource.SetResult()`.\n\nSo yes - Tasks can behave like JS promises. But they can also behave otherwise under some conditions.", "id": "d00mfux"}], [{"comment": "[deleted]", "id": "czzm8gn"}, {"comment": "You sure your code is correct?", "id": "czzqplw"}, {"comment": "Let's see your implementation? Gevent/greenlet, threading, or multiprocessing?\n\nWhich interpreter are you using? Jython or pypy have far better threaded performance than cpython. ", "id": "czzs6ai"}], [{"comment": "Here it is in my little scripting language [Wren](http://wren.io):\n\n    class Skynet {\n      static makeFiber(num, size, div) {\n        return Fiber.new {\n          if (size == 1) {\n            Fiber.yield(num)\n          } else {\n            var fibers = []\n            for (i in 0...div) {\n              var subNum = num + i * (size / div)\n              fibers.add(makeFiber(subNum, size / div, div))\n            }\n\n            var sum = 0\n            for (task in fibers) {\n              sum = sum + task.call()\n            }\n            Fiber.yield(sum)\n          }\n        }\n      }\n    }\n\n    var start = System.clock\n    var result = Skynet.makeFiber(0, 1000000, 10).call()\n    var end = System.clock\n    System.print(\"Result: %(result) in %(end - start) s\")\n\nOn my Macbook Pro, it runs:\n\n    Result: 499999500000 in 1.475756 s\n\nNot too bad for a bytecode interpreter that's a little over 3k semicolons of C code.\n\nLike others said, some of the languages are doing different things so the comparison is kind of apples to oranges. Wren uses lightweight cooperative fibers. By default, they work like coroutines as in Lua: you invoke them directly and they don't go through a scheduler.\n\nWhen doing asynchronous IO, you can explicitly hand a fiber to the scheduler. It will then run any fibers that aren't blocked on IO and handle switching between them.\n\nHere, since there is no IO, it just calls the fibers directly.", "id": "czzpa46"}], [{"comment": "tl;dr Oranges are better than apples.", "id": "czzttaf"}], [{"comment": "World's worst benchmark since it doesn't test what it purports too. Net using tasks which are futures vs akka/Erlang which spawn actual actors and all the infrastructure that entails.\n\nTry this with a true actor library for net or use futures in Scala.", "id": "czztnw6"}], [{"comment": "This sub needs a rule that shitty benchmarks aren't allowed.", "id": "czzzplx"}, {"comment": "It's called the \"downvote\" button. I used it. ;)", "id": "d00d89f"}], [{"comment": "I wonder if Erlang would be more competitive with Go on a non-mathematical task. Erlang only uses arbitrary-sized integers and has poor math performance.", "id": "czzk34m"}, {"comment": "There's no mathematical task, it just does a few additions. The overhead is in spawning processes and message-passing.", "id": "czzmlnv"}, {"comment": "This is a pretty useless benchmark. Throw some heavy math in there and see how the results stack up. Next, do the same with I/O. Otherwise, there is no point other than to see how well underlying concurrency mechanisms themselves perform, which in most real-world cases is not an issue.", "id": "d001wkq"}, {"comment": "Math work, or anything that depends on raw CPU strength is something that will always be capped by number of CPU threads and not something that should be scaled with using lightweight/async threads.", "id": "d00365g"}, {"comment": "The benchmark does hardly anything. A few additions, spawning and a message pass. Unboxing doing math and boxing back variable length numbers is pretty expensive compare to just allocating a new process and adding a reference or passing a reference. The only other thing that could be slow is passing messages between processes on different CPUs. Setting process cpu affinities, decreasing gc rate and using a few kernel threads would probably make the erlang one run a lot of faster.", "id": "d0051nm"}, {"comment": "> A few additions, spawning and a message pass. Unboxing doing math and boxing back variable length numbers is pretty expensive compare to just allocating a new process and adding a reference or passing a reference.\n\nIt really isn't, that's completely nonsensical. `lists:sum(lists:seq(0, 999999))` runs essentially instantaneously (just try it in your shell) and it has to allocate a million-long list of integers before it can start summing stuff. Even in the most convoluted and least pythonic way (`functools.reduce(lambda acc, v: acc + v, list(range(1000000)), 0)`) *CPython* still only takes ~250ms to sum a million integers on my machine (40 when doing it \"correctly\": `sum(range(1000000))`)\n\n> decreasing gc rate\n\nThere is no GC in this bench what the hell are you talking about? Why would there be any GC when processes need under 30 words to do whatever they're doing here and they're started with a >200 words private heap?\n\n> would probably make the erlang one run a lot of faster.\n\nOf course it wouldn't.", "id": "d00gpbg"}, {"comment": "Just doing \" 3 * 3 + 3 div 3\" 1 million times in console takes 1 second on my machine. Erlang is stupid slow at math.\n\nThe GC is going to take turns with the other processes, even if there's hardly anything to GC.", "id": "d00vdla"}, {"comment": "> Just doing \" 3 * 3 + 3 div 3\" 1 million times in console takes 1 second on my machine. Erlang is stupid slow at math.\n\n1. which is a far cry from the runtime of the erlang program\n\n2. which is not really the operations performed here\n\n> The GC is going to take turns with the other processes, even if there's hardly anything to GC.\n\nNo it won't, there isn't \"hardly anything to GC\" there is literally nothing to GC, the GC doesn't trigger for no reason it triggers when manually invoked or when a process tries to allocate with a full heap, neither of which is going to happen when processes have barely 10% of their private heap in use.", "id": "d00wua2"}, {"comment": "Not only that, but I'm fairly certain it's not the same concurrency model anyway, isn't erlang's concurrency model more like using multiple processes and go's more like using multiple threads?", "id": "czzm4v3"}, {"comment": "Both of them have extremely lightweight processes that the scheduler maps to N OS threads. ", "id": "czzmfgj"}, {"comment": "> isn't erlang's concurrency model more like using multiple processes and go's more like using multiple threads?\n\nSemantically yes, Erlang uses shared-nothing concurrency (each erlang process has its own heap, and erlang structures are immutable) and Go uses shared-memory concurrency, though both use \"lightweight threads\", not OS-level facilities.", "id": "czzn64i"}, {"comment": "No, I think they're the same. Both of them create as many OS threads as you have CPU cores (~~well, Go defaults to 1 OS thread but you usually ask it for as many as you have cores~~ I was outdated, they changed this in v1.5), and then you spawn Erlang/Go 'lightweight processes' which the runtime schedules. \n\nBoth Erlang and Go lightweight-processes are much much cheaper and lighter than OS processes/threads, which is why you can spawn millions of them in a second or two.\n\nAFAIK the only real difference is that in Go, you create channels as a way to share data between the runtime-processes, while in Erlang (and Elixir) every runtime-process has its own channel built in so you just send data directly to the process that handles it.\n\nSomeone correct me if I'm wrong because I'm not an expert in these languages, I've only used them for hobby projects.", "id": "czzmh1b"}, {"comment": "> No, I think they're the same. Both of them create as many OS threads as you have CPU cores (well, Go defaults to 1 OS thread but you usually ask it for as many as you have cores)\n\n[That was changed in 1.5](https://golang.org/doc/go1.5):\n\n> By default, Go programs run with `GOMAXPROCS` set to the number of cores available; in prior releases it defaulted to 1.\n\n> AFAIK the only real difference is that in Go, you create channels as a way to share data between the runtime-processes, while in Erlang (and Elixir) every runtime-process has its own channel built in so you just send data directly to the process that handles it.\n\nFor this benchmark, the primary differences are probably:\n\n1. Erlang uses processes with individual independent heaps (with a default size is 233 words \u20141.8KB on a 64b system) as well as a bunch of other stuff (process dictionary, more features), so Erlang processes require ~2.5KB of upfront allocation (excluding structure initialisations). Go uses shared-memory concurrency so goroutines should have a smaller base footprint\n2. Erlang tends to box values more (work off the heap) and is mostly interpreted[0], Go does more work on the stack, which is faster\n\n[0] IIRC HiPE is not a tremendous compiler/jit, it's mostly good when doing lots of maths in the same process but it bails out to interpreting otherwise, which is probably why it's even slower than BEAM here", "id": "czzmpwe"}, {"comment": "> Erlang uses processes with individual independent heaps (with a default size is 233 words \u20141.8KB on a 64b system) as well as a bunch of other stuff (process dictionary, more features), so Erlang processes require ~2.5KB of upfront allocation (excluding structure initialisations). Go uses shared-memory concurrency so goroutines should have a smaller base footprint\n\nThis actually goes against my observations. We've recreated the experiment initially done by Erlang Solutions in which you'd spawn 4 chains of processes, the chains are 1000, 10000, 25000, 100000 processes long, 136000 processes in total. Each chain is passsing a token and once the token as gone full cycle you'd toggle a GPIO. The code is here: https://github.com/open-rnd/erl-hw and a Go counterpart is right here: https://github.com/open-rnd/golang-gpio-test\n\nThe measurements were done on some low end embedded boards, Raspberry Pi, BeagleBone Black, Olimex OlinuXino A20. The 136k Go (1.5) version took ~360-380MB (on the verge of being killed by OOM killer on RsPi and BBB), that gives a rough estimate of 2.7-2.8kB per goroutine. The Erlang (R18) could do up to 260000-280000 processes, still keeping a soft real-time scheduling fairness. Just to recap the original demo by Erlang Solutions used R15 or R14 and they could not go past the 160k limit IIRC.\n\nPerhaps the Go code was written poorly, I'm no expert at writing Go, more interested in its internals. But the difference is rather significant in favor of Erlang. Pity is that the language is just weird and the ecosystem around Erlang sucks bit time.\n", "id": "czzofvj"}, {"comment": "Have you seen the Elixir programming language?\n\nIt runs on the BEAM so has the same runtime as Erlang, but has a Rubyish syntax (remember: syntax != semantics - Elixir is not Ruby) and has a growing ecosystem.", "id": "d00d78w"}, {"comment": "> Rubyish\n\nFor a second there I read rubbish :) Just hoping that Elixir will accumulate enough hype to keep it rolling. From what I've heard, even the Phoenix framework is a direct Rails rip-off.", "id": "d00ful5"}, {"comment": "What you have heard is wrong.\n\nhttps://dockyard.com/blog/2015/11/18/phoenix-is-not-rails - By the founder of the project.", "id": "d00g51n"}, {"comment": "Thanks, nice read. They even mention observer!", "id": "d00sskm"}, {"comment": "Each goroutine starts with 2kb stack by default.", "id": "d007fpu"}, {"comment": "Yup, and it got changed between releases a couple of times already. It's 2kB since 1.4, before it was 8kB, and IIRC before that it was 4kB in 1.2.", "id": "d00fstd"}, {"comment": "> That was changed in 1.5\n\nOh, that's really cool. I'm outdated then, I'll edit my post.\n\nThanks for the points about the heaps, I wasn't aware of that, TIL.", "id": "czzmrsc"}, {"comment": "And node doesn't have any of those, it just runs all in single process. The test is a pretty poor comparision...", "id": "czzqtkq"}, {"comment": "At a glance, the big differences between the two involve:\n\n1) the standard libraries, Erlang's OTP is awesome for distributed systems. To be fair, Go could reach parity fairly quickly with this.\n\n2) Erlang's \"channels\" semantics. They allow for message passing across the network (identical to same machine), as well as specifying \"kill me when the remote disappears\" or \"tell me when they disappear\". These are a lot more difficult for Go to duplicate.\n\n3) Go gives much better control over channel implemontation than Erlang does, you can have single item channels, multi-item, typed, etc. Erlang message passing is all dynamic, and \"unlimited\" size.", "id": "d00dec1"}], [{"comment": "Just as a reference; a relatively straight forward port to C++ with only a single thread doing the work takes roughly 8ms on my i7. So it's pretty cool so see what amount of overheads are involved in the various languages and MT strategies used in their tests.", "id": "czzv3rt"}], [{"comment": "Don't forget GHC Haskell!", "id": "czzn63f"}], [{"comment": "Ye olde [thread-ring](http://benchmarksgame.alioth.debian.org/u64q/performance.php?test=threadring) was less about startup ;-)", "id": "czzssm1"}], [{"comment": "This doesn't even stand next to a correct example... who even updoves this? Of course .NET fanboys. .NET example does completely different thing than all the others. Apples to Oranges.", "id": "d00fe3m"}, {"comment": "The timings are completely out-of-date too.  There's dozens of pull requests waiting, and if those self-reported numbers are remotely accurate it's the usual suspects at the top: C#, Java and Haskell all sub 20ms; then all the hipster options people were getting excited about yesterday firmly in the embarrassing several hundred millisecond zone...", "id": "d00vfm7"}], [{"comment": "Interesting synthetic benchmark, but not representative of real-world use.", "id": "czzrl2t"}], [{"comment": "How on earth was node that fast?", "id": "czzsgx0"}, {"comment": "Because node isn't spawning actors this terrible benchmark is using futures (tasks) for .net and node and a full blown actor stack for Scala and Erlang. It's apples to oranges.", "id": "czztpn8"}, {"comment": "Because it's comparing spinning a single event loop vs. setting up a bunch of threads (either real or \"green\").", "id": "d00d969"}], [{"comment": "I wrote a version using Coro in Perl (so zero parallelism, just overheads) and it runs in ~19 seconds. Took less than 2 minutes to rewrite that without Coro and it completes in ~2 seconds. Both cases on an older HP Microserver", "id": "czzyxl4"}], [{"comment": "Aren't you just measuring the performance of the underlying operating systems thread creation system?  ", "id": "d003cgn"}, {"comment": "These are green threads not OS threads.", "id": "d004412"}], [{"comment": "I do not think you're running the Haskell in parallel.  I think you need more options on the command line to run it over multiple cores.\n\nI think a ring simulation would be a better demo too, though this is pretty clever. ", "id": "d00dd39"}, {"comment": "+RTS -N<number of threads>\nIIRC", "id": "d00di44"}, {"comment": "Or just `+RTS -N`, if you don't know how many cores you got.", "id": "d00v9v5"}], [{"comment": "many (maybe all) off these implementations fail to enforce the \"create a million threads\". instead, they create a few and then start processing them, at which point the code just becomes a simple loop\n\nall this benchmark is really testing is at which point this effect kicks in. the benchmark needs to be changed to require the thread creation completes prior to the start of processing\n\n", "id": "d00tyhj"}], [{"comment": "why does everyone call everything SKYNET these days, I assure you those will be the first things skynet destroys !!!!1", "id": "czzk383"}, {"comment": "Like Samaritan v/s the Machine in \"Person of Interest\"?", "id": "czzlgk3"}], [{"comment": "And Node.js wins here again. Javascript is awesome!", "id": "czzsm3k"}, {"comment": "Node.js only wins because it's measuring completely different things.", "id": "d00da3w"}, {"comment": "Node.js exposes the only best concurrency primitive. It's super fast. Beats all. Async out of the box. npm install shits. Win big. Macbook SSD. WHOA.", "id": "d00kpzd"}]]], "4vbyba": ["The mindset of a programmer", "2016-07-30 16:52:46", 5, "http://prognst.tumblr.com/post/148195526630/the-mindset-of-a-programmer", [[18, "> Programmers are adamant about how simple programming really is.\n\nThese people are wrong.\n\nThat's like saying \"playing music is simple\". Sure, there are songs and instruments that are on the simpler side to play. But \"playing music\" runs the full gamut.\n\nI think this \"programming is simple\" notion is probably said by people promoting the \"everybody can code\" movement. I'll quote Ratatouille:\n\n> In the past, I have made no secret of my disdain for Chef Gusteau's famous motto, \"Anyone can cook.\" But I realize, only now do I truly understand what he meant. Not everyone can become a great artist; but a great artist *can* come from *anywhere*."], [13, "That first sentence reeks of false authority.  I don't think that most programmers *are* adamant that programming is simple.\n\nAnd I sincerely doubt that people learning programming don't immediately understand that \"everything you type matters.\"   If anything they're *burdened* by that fact.  It's probably daunting to realize that you have to write a perfect sequence of characters to get the desired results."], [10, "I hope that anyone who teaches programming already knows this, because teaching the mindset of programming is teaching programming. "], [3, "\"Many even see code as a natural language, where the meaning of every statement is clear and intuitive.\"\n\nThis sentence tells me the author has not studied natural languages, nor done any natural language processing. Code is very much a formal language (as opposed to a natural one), which is why every statement is clear and unambiguous. Some languages like perl have syntaxes that try to blur this line, but it's still a formally defined language."], [2, "This is really poorly written. The post fails to define \"the mindset of a programmer\" before attempting to discuss the need for teaching it, and makes a lot of unsupported statements.\n\nIt reads like an essay a student would bullshit 30 minutes before the deadline."], [2, "Past a certain codebase size it's impossible to understand what every single line is doing. \n"], [1, "I overhauled the post based on your critique. I appreciate it!"], [0, "[deleted]"]], [[{"comment": "> Programmers are adamant about how simple programming really is.\n\nThese people are wrong.\n\nThat's like saying \"playing music is simple\". Sure, there are songs and instruments that are on the simpler side to play. But \"playing music\" runs the full gamut.\n\nI think this \"programming is simple\" notion is probably said by people promoting the \"everybody can code\" movement. I'll quote Ratatouille:\n\n> In the past, I have made no secret of my disdain for Chef Gusteau's famous motto, \"Anyone can cook.\" But I realize, only now do I truly understand what he meant. Not everyone can become a great artist; but a great artist *can* come from *anywhere*.", "id": "d5x4omd"}, {"comment": "I think the idea of \"everybody can code\" comes from the fact that programming is done with the most basic of logic (if/then/else). \n\nThe problem is that not everything is easy to reduce to this basic level of logic. Sure anyone could get to a point of \"if this variable is 5, output \"potato\", otherwise output \"tater\" but that's as much programming as baking an egg is cooking. ", "id": "d5x5b78"}, {"comment": "This is kind of the gist of the article. Experienced programmers can't often either realize or remember the difficulties newcomers have. Thus they can't really help newcomers in that situation.", "id": "d5x5q62"}, {"comment": "I want programming taught as early as possible to everyone, like basic math.\n\nTo me, after 35 years of coding, everything is as easy as \"if/then/else\", and the reason is that I have had so many opportunities to reduce problems to their simple forms, that it has become easy.\n\nGiving everyone the possibility of developing these types of skills is tremendously useful, whether they become a programming for their career, or ever do it for fun or personal utility.\n\nWhy does any child have to learn math?  They could get by without it these days, like people are cutting out cursive.  But math is an important skill for people to learn for mental development, and cursive is also important for dexterity development, and ability to write quickly and fluidly without a keyboard (different media provides different feedback as well).\n\nWhy does something need to be easy, in order to want everyone to learn it?  \n\nIt doesn't even matter if we grade them on it, it's important to try to teach people to code.", "id": "d5xsacy"}, {"comment": "> To me, after 35 years of coding, everything is as easy as \"if/then/else\"\n\nThat's great. You should write some software to accurately predict the weather, translate between colloquial usage of human languages and control the plasma in a fusion reactor. Your skills are of immense use to humanity.", "id": "d5y2ebh"}, {"comment": "Its like you dont know the difference between programming and domain knowledge.  As if somehow being able to code anything I understand also means i understand everything. \n\nWas there a reason for your bitterness?", "id": "d5y3rqs"}, {"comment": "I intended to convey wry humour. Sorry if it came over as bitter; that was not the intention.\n\nYou ~~acknowledge that part of the art of programming is to take problems and discover underlying simplicity within them~~ said *the reason is that I have had so many opportunities to reduce problems to their simple forms, that it has become easy*. I took that to mean that you consider this process of understanding and analysis to be part of programming. That is certainly my opinion and I apologise for misunderstanding you. \n\nIt's not always necessary to be as expert in a particular domain as its practitioners. It is often sufficient to understand the abstractions and models used within a domain and ask for clarification when required. As a programmer, you provide a dimension to the understanding that the full time domain experts don't have.\n\nI agree that writing programs to enact known solutions is reasonably simple.\n\n[Edit - Replaced my interpretation of what you said as I was presumptuous]", "id": "d5y4cod"}, {"comment": "Thanks for clarifying.  :)\n\nThere's still a misunderstanding due to parsing, which means I should have written it better.  This is the key:\n\n\"the reason is that I have had so many opportunities\"\n\nThat it has become easy for me is because I have done it so much, not circularly because it is already easy for me.  It's repetition, and access to repetition, having reasons to repeat, a desire to repeat, and enjoyment of repeating, that have caused me to gain the experiences needed to understand things, so that that they become understood, and thus are \"easy\".\n\nI'm not speaking about \"known solutions\" either, I can make up new solutions to problems on the fly, and repeatedly re-make them up in totally different ways, balancing each choice with the intended results (goal-meeting) that I wish to apply.\n\nWhat I mean is that if I dont understand something, I cant code for it.  For example, I am not an expert on weather systems, so I cant code up things to predict weather behavior.  \n\nI can certainly write all the code around that I think would be needed to provide the tooling to perform this work, but since I don't understand what needs to be done, I would need someone to explain the details of how a weather system should be predicted, and then I could code that up.\n\nSame with medical systems, I am not a medical researcher, surgeon or MD, so in any medical software I would need someone else to describe what the goals are, and then I could write that software.\n\nMany aspects of programming are never taught in any educational program that I have ever seen or heard about, so there is much more to programming than is currently being discussed.  More people having access to it will increase this knowledge, and benefit those people.\n\nThat's my real point.  Programming is good for your mind, it's creative, it allows the thinker to solve practical problems of a virtual nature, and with increasingly easy access to robotics and other physical interfaces, its going to allow regular people to solve physical problems accessibly soon too.\n\nProgramming is fundamental to technology, and we live in a technological culture.  It's like in a land of magic, where people can make fireballs in their hands, we don't want to teach all children how to do it, just because they might not become professional magicians.\n\nProgramming provides \"mobility\" to do things in a virtual space, and there is an increasing amount of virtual space.  Children that do not learn this type of mobility will be \"crippled\" in comparison to children that do learn it.", "id": "d5yun08"}, {"comment": "And that's great, in that a lot of programming problems can be reduced to simple if/else flows.\n\nBut sometimes, it's not at all clear what the conditional logic should look like. Take something like parsing, which essentially boils down to \"given that the next input token is X, what should I do?\" in a loop. It turns out to be a somewhat complicated question to answer, and that's why it's a concentration inside the broader field of computer science. The solutions aren't things that programmers are likely to arrive at intuitively. \n\nOr take something like multithreaded programming. It's very easy to make incorrect assumptions about what a certain chunk of code will do in a multithreaded environment (for example, is a 64 bit int read guaranteed to be atomic? Is a write in one thread guaranteed to be visible in another thread). Understanding the memory model of your environment is vital, especially since it's difficult to adequately test multithreaded code.\n\nOr look at distributed systems. When I go back to work tomorrow, I'm going to have to diagnose why a message is getting stalled in our message queue. It's getting put in the queue, but it's not getting consumed by anybody. Distributed programming brings with it a whole new set of problems. The solutions to these problems look different to the solutions that one would apply to a single-threaded program.\n\nAnd all the examples above assume that the \"correct\" program is something that we can objectively determine. What if \"correct\" is fuzzy? You might think that's silly; it should be clear what is \"correct\" in all cases. But domains like computer graphics and image processing have only rough ideas of correctness. In fact, any time you're processing potentially bad data from sensors, any notion of absolute correctness goes out the window. You really can only deal with probabilistic correctness. \n\nAnd consider too the softer things, like good API design and good documentation. These become essential skills, and have nothing to do with algorithmic decomposition. Good programmers need to be good technical communicators. They need to write code and documentation that speak for themselves, so that future maintainers can understand what the system does.\n\nFor that matter, consider software maintenance. Any system that's more than a toy will pass from hand to hand, and you will eventually find yourself reading somebody else's incomprehensible code. Breaking down and understanding that code is a wholly separate set of skills from the rest of programming, yet is a set of skills that are used almost every day.\n\nNow, you could maybe argue that these are all specialized offshoots of some core notion of programming. The essence of programming is still if/else control flow and data structures. But you can't talk about the essence of programming in a vacuum, because there are no practitioners of \"essential programming\". Everybody who is writing code is doing it to solve some problem. When deciding whether programming is \"easy\" or \"hard\", you have to consider programming as most practitioners deal with it. Everybody is building on stacks and stacks of technology, all of which might have bugs and corner cases. We build out own abstractions, some of which stand the test of time and some of which topple in spectacular fashion.\n\n---\n\nAnd none of what I wrote is meant to scare people away. I too think that it would be good to teach programming basics to many people, but not because I think most people should know how to program. I think programming forces students to think critically, which is a skill that will benefit people throughout their life (and is unfortunately a skill that many people never develop).\n\nBut we have to be careful how we phrase things. I would not say that \"programming is easy\". I would say that it's easy to get started with programming. I would encourage everybody to dabble with it. But I would not present programming as an easy profession. Sure, some days are easy, and it feels ludicrous that we get paid as much as we do. There are other days (or weeks or months) where we definitely earn our pay. \n\nTrying to portray the whole package as \"easy\" is, I think, misleading and disrespectul to people that might consider going into the field.", "id": "d5ycqmw"}, {"comment": "Did you think I meant that I only think about things in \"if/then/else\"?  Because, I of course think in all the ways you mentioned and many more.\n\nI am saying all of those things, everything I've encountered since starting programming, are now as easy as \"if/then/else\" because they have become normal tools to me, and I can balance them in the same way as I can balance on a skateboard.  If I want to go \"more left\", I \"lean left\", etc.\n\nAny new things that come up are similarly integrated, as I need them.\n\nI'm not sure why there is such a strong need for people to assume that other people are stupid online.\n\nNone of this is \"easy\", but if you aren't taught it, and especially aren't taught it young, then the path just isn't available.\n\nEasy is a silly concept.  Nothing is \"easy\" when you don't know how to do it.  Everything is \"easy\" when you do.", "id": "d5yu89w"}, {"comment": "Reminds me of when /u/djbootybutt was saying it would be easy to rap.\n\n>Everything he says is not that hard to say fast. He's using words that are easy to pronounce and flow together smoothly.\n\nQuoted so we know his literal words.\n\n[It turned out good.](https://www.reddit.com/r/videos/comments/4nkv8u/busta_rhymes_spits_his_verse_from_look_at_me_now/d45shlg?context=10000) So I'm inclined to say he was right.\n\nI like the Ratatouille quote though.", "id": "d5x5oe4"}, {"comment": ":D", "id": "d5x65w4"}, {"comment": "Playing music is simple enough to be performed by machines. It's difficult for humans, and there is  the complexy of interpretation, but for the most part, you're just following instructions. Even improvisation happens within parameters.", "id": "d5z7egf"}, {"comment": "Broken analogies. There is absolutely nothing in common between something as huge, arcane and skill-dependent as music and something as tiny programming, with a fundamental base no bigger than a Turing Machine or Rule 110.\n\nProgramming is really, really small and easy.", "id": "d5xckiw"}, {"comment": "Computers are just Turing machines, and music is just vibrating air. Painting is just brushwork and paint mixing. You can break any complex thing down to its most atomic pieces, point at those pieces, and say \"look, it's easy\". The complexity in music, in art, and in programming comes from how those pieces come together and interact with each other. Learning how to put the pieces together can take a lifetime.", "id": "d5xcxt3"}, {"comment": "There are far more rules in music than in programming. The sheer amount of information one have to operate with is incomparable. Programming is tiny, it's probably the smallest comprehensive and coherent piece of knowledge out there.\n\nAnd, if you're combining pieces in a way that complexity is increasing non-linearly, you're doing it wrong.", "id": "d5xd5oq"}, {"comment": "I find music incredibly easy and have been playing instruments most of my life. I find coding harder but I think some of it is the books. Too many are like:\nChapter One: Introduction\nChapter Two: Hello World\nChapter Three: Using Arrays and Variables to do a bubble sort algorithm. \nHAHAHAHA. \n....Some of the books are insane. Like Php and mySQL: from novice to professional. \n\nIt says novice in the title right? Most be ok for beginners? Ahhhh, no. It assumes you're already a programmer. No idea why novice is in the title. \n\n...and of course there's no brick and mortar bookstores anymore to look at the book before buying.  So a lot of them are an online crapshoot.\n\nAnyway you guys saying music is harder gives me hope because I find music very easy. So thanks for that.", "id": "d5xib0g"}, {"comment": "I find music incomprehensible, gave up long ago.\n\nAs for programming, if you only ever study one book, but do it thoroughly, without skipping steps, you'd pick up all the rest easily. Just study SICP, it is rather small.", "id": "d5xirra"}, {"comment": "Thanks I'd not heard of that book.\n\n....and if you decide to give music another go I still teach in my spare time.  :)", "id": "d5xlk6u"}, {"comment": "Writing a program, sure. Converting an idea to code, not so much.", "id": "d5xcu8b"}, {"comment": "> Converting an idea to code, not so much.\n\nIt is a mechanical process that does not require any thinking.\n\nEDIT: and downvoters, apparently, know *nothing* at all about engineering. Typical.", "id": "d5xd7c2"}, {"comment": "TIL my whole career is based on doing something my dog could do.\nNo, but I have to thank you for demonstrating the point of the article perfectly.", "id": "d5xdgg7"}, {"comment": "Point of the article is that once you get this engineering mindset, everything is easy. Problem is, many people build successful programming careers without ever achieving this mindset.", "id": "d5xhncx"}, {"comment": "he truly proved the point of the article didnt he", "id": "d5xi29i"}, {"comment": "Take an upvote, since I agree with you.", "id": "d5xmvc5"}], [{"comment": "That first sentence reeks of false authority.  I don't think that most programmers *are* adamant that programming is simple.\n\nAnd I sincerely doubt that people learning programming don't immediately understand that \"everything you type matters.\"   If anything they're *burdened* by that fact.  It's probably daunting to realize that you have to write a perfect sequence of characters to get the desired results.", "id": "d5xhqmc"}, {"comment": "I can see your point. But look around, you'll see a lot of this. Also, the point isn't much about writing a perfect sequence of characters. Most get that, for sure. It's about really needing to understand what it does.", "id": "d5xhwxs"}, {"comment": "> But look around, you'll see a lot of this.\n\nWhat?  I'm a programmer, I work with programmers, I'm constantly reading programmer's blogs and articles from programmers... and I don't see a lot of this...\n\n>It's about really needing to understand what it does.\n\n...so, the mindset of a programmer is to know what you're doing?  That's an empty generalization that could be applied to any learned discipline.", "id": "d5xhzi7"}], [{"comment": "I hope that anyone who teaches programming already knows this, because teaching the mindset of programming is teaching programming. ", "id": "d5x4jol"}, {"comment": "I wrote this, because many of the teachers I know, don't know this. They teach the language, not the mindset.", "id": "d5x4osk"}], [{"comment": "\"Many even see code as a natural language, where the meaning of every statement is clear and intuitive.\"\n\nThis sentence tells me the author has not studied natural languages, nor done any natural language processing. Code is very much a formal language (as opposed to a natural one), which is why every statement is clear and unambiguous. Some languages like perl have syntaxes that try to blur this line, but it's still a formally defined language.", "id": "d5xo3n7"}, {"comment": "I have. I referred to the fact that code can be read as easily as English or any given language you have enough expertise with, intuitively understanding the meaning without thinking about it.", "id": "d5xoahs"}, {"comment": "I see; I misunderstood your intended meaning then. Something a little clearer might be \"Many programmers even find they can read code as easily as they read a natural language (like English).\"", "id": "d5xqwc7"}, {"comment": "I did a major overhaul to the post, including that change, with my own wording, of course.", "id": "d5y4dk1"}], [{"comment": "This is really poorly written. The post fails to define \"the mindset of a programmer\" before attempting to discuss the need for teaching it, and makes a lot of unsupported statements.\n\nIt reads like an essay a student would bullshit 30 minutes before the deadline.", "id": "d5xnflk"}, {"comment": "Ah, darn. That was me trying to be artistic and failing at it.", "id": "d5xnrky"}], [{"comment": "Past a certain codebase size it's impossible to understand what every single line is doing. \n", "id": "d5xrz74"}, {"comment": "You should be *capable* of understanding what every single line is doing.  You don't have to know all of it at once.", "id": "d5y24rz"}], [{"comment": "I overhauled the post based on your critique. I appreciate it!", "id": "d5y4eir"}], [{"comment": "[deleted]", "id": "d5y73e1"}]]], "4yh5ts": ["Static Code Analyzer Reportedly Finds 10,000 Open Source Bugs", "2016-08-19 09:30:56", 2, "https://adtmag.com/articles/2016/08/18/open-source-bugs.aspx", [[16, "    if ((res->pw==0)||(res->pw==0)) continue;\n\n> Here, the logical OR operator (||) compares the same expression, **so the function will continue no matter what**, as it's basically saying something like the equivalent of \"if x = 10 OR if x = 10, continue.\"\n\nFunny, how the article is trying to point out a logic bug, makes a big logic error of it's own (in bold). It states the function will continue no matter what. But the function won't continue no matter what, it will only continue if X = 10."], [9, "The title is a really horrible clickbait and doesn't mesh with the actual article.\n\nFunnily enough, it is the actual title of the article on a site I've never heard about."], [3, "We like it a lot, PVS-Studio is actually really good, it seem to catch lots of real bugs in a very effective manner.. "], [3, "The article is written in a way to give the impression to a non programmer that Open Source Programs in particular contain lot of bugs.\nThe question of what counts as a bug is very complex and hard to understand and static analysing will always report false positives. Most of the reported 10000 bugs are probably false.\nRunning the same tests on proprietary code would probably give higher numbers as open source do not have the advantage of \"This code is shit, ship it anyway, nobody will know\"."], [1, "Coverity also scan and report on open-source projects.\n\nHow does the static analysis landscape look today?  Is there any clear leader?"], [0, "Coverity has been doing it for years https://scan.coverity.com/ and nobody cared. "], [-1, "I wouldn't call the example code a bug:\n\n    if ((res->pw==0)||(res->pw==0)) continue;\n\nThe compiler/optimizer will most likely remove the second comparison. \n\nHowever, if the second comparison is a typo and the programmer intended to write something else, then yes, it could be a bug."], [-18, "Nonsense!  Tripe!  Hogwash!\n\nEveryone knows OSS is bug freee!"]], [[{"comment": "    if ((res->pw==0)||(res->pw==0)) continue;\n\n> Here, the logical OR operator (||) compares the same expression, **so the function will continue no matter what**, as it's basically saying something like the equivalent of \"if x = 10 OR if x = 10, continue.\"\n\nFunny, how the article is trying to point out a logic bug, makes a big logic error of it's own (in bold). It states the function will continue no matter what. But the function won't continue no matter what, it will only continue if X = 10.", "id": "d6nxv16"}, {"comment": "I had to stop reading the article at this point and come here to see if it was the author or I was being incredibly stupid, and I was pretty sure it wasn't me. That error was so fundamental that it had me questioning myself: \"Surely no one could be making that big an error?\"", "id": "d6nztw4"}, {"comment": "I checked myself twice, I thought surely I'm making the mistake. Not seeing the comment in reddit also made me doubt myself. But I figured if I'm wrong, someone in reddit will certainly tell me.", "id": "d6nzxqs"}, {"comment": "Yah, didn't read anything past that glaring mistake either.  Author is obviously an idiot.", "id": "d6o1kci"}, {"comment": "Oh, I continued reading the article. I just had to pause.", "id": "d6o1u5g"}, {"comment": "Well, that's what happens when dumb journalists try to write about programming. The author has duly noted his mistake in the article and regrets the error. -- The Author", "id": "d6o20u0"}, {"comment": "Sorry for pointing it out :( I don't think you're dumb.", "id": "d6o69xv"}, {"comment": "Also if that is C++ code then == could be overloaded, and the expression might return a different value the second time it is called. This is why you must be extremely careful when overloading operators.", "id": "d6o1sy0"}, {"comment": "Oh God, why are you all criticizing that one particular example ((res->pw==0)||(res->pw==0)) and the way it is decribed in the article? :) There are hundreds of other [bugs like this](http://www.viva64.com/en/examples/V501/). I don't understand why this particular case is attracting you so much.", "id": "d6o3fjx"}, {"comment": "Note my comment says nothing about the code. In fact I could have left that part out, I was just quoting the article and commenting on the text. See the part in bold.\n\nMy comment has nothing to do with the left and right being the same, just the comment that said if the left and right are the same then the condition will always be true.", "id": "d6o64sd"}, {"comment": "Ok, I am understand. But so many comments about this exression. :)", "id": "d6o82uw"}], [{"comment": "The title is a really horrible clickbait and doesn't mesh with the actual article.\n\nFunnily enough, it is the actual title of the article on a site I've never heard about.", "id": "d6nvq76"}], [{"comment": "We like it a lot, PVS-Studio is actually really good, it seem to catch lots of real bugs in a very effective manner.. ", "id": "d6nrs0a"}], [{"comment": "The article is written in a way to give the impression to a non programmer that Open Source Programs in particular contain lot of bugs.\nThe question of what counts as a bug is very complex and hard to understand and static analysing will always report false positives. Most of the reported 10000 bugs are probably false.\nRunning the same tests on proprietary code would probably give higher numbers as open source do not have the advantage of \"This code is shit, ship it anyway, nobody will know\".", "id": "d6nxajs"}, {"comment": "Exactly. Proprietary, from my experience, is often much worse quality. Likely because there is the benefit of hidden code, combined with the people working on it less likely to give a crap about what they're working on. \n\nPeople working on open source are more aware of their quality being exposed and also likely more passionate about what they are working on because they are doing it for free. People think that paid work must somehow be better quality because you're paying for it, but people aren't motivated by money for quality output.", "id": "d6oxhmm"}, {"comment": "When writing the [first news](http://www.viva64.com/en/b/0421/), we didn't mean to say that there were lots of bugs. Just on the contrary, they are quite few in these famous projects. The point of that post was that even highly skilled programmers working on tough and well-known projects still make trivial mistakes every now and then and that's the reason why static analysis is helpful.", "id": "d6o3l8c"}], [{"comment": "Coverity also scan and report on open-source projects.\n\nHow does the static analysis landscape look today?  Is there any clear leader?", "id": "d6nw8ow"}, {"comment": "I'd like to point out that PVS-Studio analyzer finds lots of bugs in projects already scanned by Coverity. :)", "id": "d6o3rgo"}, {"comment": "Which is absolutely typical for every static analyzer on a market. Either Klocwork, QA, LDRA or Lint - they are not completely interchangeable. There wouldn't be any market otherwise.", "id": "d6rkt12"}], [{"comment": "Coverity has been doing it for years https://scan.coverity.com/ and nobody cared. ", "id": "d6rkr3e"}], [{"comment": "I wouldn't call the example code a bug:\n\n    if ((res->pw==0)||(res->pw==0)) continue;\n\nThe compiler/optimizer will most likely remove the second comparison. \n\nHowever, if the second comparison is a typo and the programmer intended to write something else, then yes, it could be a bug.", "id": "d6nqmm5"}, {"comment": "There is no case where anyone should write a code like that, so it is very reasonable to assume that they intended to write something else.", "id": "d6nr834"}, {"comment": "I've already seen stuff like that as a result of automatic code generation and/or automatic refactoring.\n\nThere is a high likelihood that this code contains an actual bug but I think there are tons of better examples.", "id": "d6nunpv"}, {"comment": "Aaah ok. I thought it was possibly one of those obscure cases of undefined behaviour in C, tried it, didn't find anything wrong and thought... hmm....\n\nBut sure, yes, it's probably a bug-in-the-programmers-head, not in the code itself.", "id": "d6ntw0y"}, {"comment": "This is perfectly valid code and could be intended but it is unlikely. Declare the variable as volatile and the code will test the value twice and not optimize it away. This could be important in real time applications.\n", "id": "d6nxykd"}, {"comment": "I came here to say exactly that.  Never is such a strong word.  I could see someone do that on some sort of wait state in a event loop and the volatile value has not been changed yet.  Check twice, then jump.  Similar to unrolling a for loop", "id": "d6o0l37"}, {"comment": "Yes, but the commonly accepted meaning of  \"bug\" is code that could lead to a system failure or inoperative feature. The example is bad practice but harmless, and is likely to be automatically eliminated by an optimizing compiler.\n\nEdit: Once again the \"Reddit Effect\" raises its ugly head. The \"Reddit Effect\" is a perverse effect springing from ignorance or malice or both, that reliably downvotes posts that suffer the inexcusable flaw of *being right*. In this case, I have objected that harmless code, code that cannot produce a program failure or anomaly, is *not a bug*.\n\nHere's the official definition of software bug:\n\n[Software bug](https://en.wikipedia.org/wiki/Software_bug) : \"A software bug is an error, flaw, failure or fault in a computer program or system *that causes it to produce an incorrect or unexpected result, or to behave in unintended ways*.\"\n\nThe posted example does not meet this definition -- *it cannot change the behavior of the program*, because it doesn't change the program's algorithm. Two black boxes containing two versions of the program, one with, and one without, the example, *cannot be distinguished from each other*. Therefore the example *is not a bug*.\n\nSo downvote away, you ignorant jackasses.\n", "id": "d6nrjpw"}, {"comment": "I disagree with your \"common accepted meaning\", as do others. A bug is an error in the code that could cause the program to exhibit unexpected behaviour, no matter how serious the ramifications are.\n\nThe example code was *likely* to contain a bug, because the written code does not make sense, hence the program is probably running a check on the wrong variable. Had it checked the right thing, the behaviour would possibly be different.", "id": "d6nscwa"}, {"comment": "> A bug is an error in the code that could cause the program to exhibit unexpected behaviour, no matter how serious the ramifications are.\n\nYes, and the posted example doesn't meet that definition -- it's inefficient, but it doesn't change the program's behavior. It's not a bug, it's an example of inefficient coding.\n\n> The example code was likely to contain a bug ...\n\nThat's far-fetched as an argument. It tries to argue that someone who would write a pointless line of code, would also write a harmful one.\n", "id": "d6nskf0"}, {"comment": "> if ((res->pw==0)||(res->pw==0))\n\nThis is a bug. Example of corrected [pi.c](http://ghostscript.com/~tor/gs-browse/gs/openjpeg/libopenjpeg/pi.c): \n\n     if ((res->pw==0)||(res->ph==0)) continue;\n", "id": "d6nsn3z"}, {"comment": "You can't fix stupid.", "id": "d6nunco"}, {"comment": ">> if ((res->pw==0)||(res->pw==0))\n\n> This is a bug.\n\nNo, it is not a bug, it is an inefficient bit of code that serves no purpose. An argument that an essential operation was omitted requires context, and the original example was provided without context.\n\nEDIT: Downvoters, GO FOR IT! Yes, you too can turn a self-evident truth into a lie by downvoting obviously true statements. It's called the \"Reddit Effect\" -- nothing is either true or false, everything is decided solely by whether an idea is *popular*. Donald Trump's campaign proves the power of this idea.\n\nAnother in this group of imbeciles has said here that, because no one agrees with me, therefore I must be wrong. That idea was a perfection of brainlessness, and only reinforces my perception of popular American reasoning ability.", "id": "d6nsq24"}, {"comment": "We all see your point. There is no bug in the posted code. But that code does not live in a vacuum, it's part of other code. And because of that it's not far fetched to say that the program does have a bug.\n\nThe code by itself is technically not wrong, but the program itself has a bug.\n\nDon't complain about down votes and then insult reddit for not agreeing with you. If you're getting down votes and you think you're right, then perhaps you just need to communicate your idea in a different way.", "id": "d6nxza6"}, {"comment": "> If you're getting down votes and you think you're right, then perhaps you just need to communicate your idea in a different way.\n\nRight is right, not semantics.", "id": "d6o3yj2"}, {"comment": "Aren't you the one arguing semantics?\n\nYou can be right all you want, but if you want others to recognize your greatness you need to learn to communicate it.", "id": "d6o66y8"}, {"comment": "I hope you agree that with context, it was indeed a bug by your own definition. If you stop for a moment and read what people have been saying, it's usually something like \"this is *likely* to be a bug\", it has potential to be a bug, etc.\n\nYou can never truly say that any line of code without context is buggy, even something like `int x = 20/0;`, because perhaps the intention is to generate a divide by zero exception.", "id": "d6nuwpc"}, {"comment": "> I hope you agree that with context, it was indeed a bug by your own definition.\n\nIt. Is. Not. A. Bug. The original topic was whether this harmless redundancy meets the definition of a software bug. It doesn't.", "id": "d6nuylv"}, {"comment": "Did you read only four words of what I wrote? \"... it was ... a bug...\"?\n\nI agree with you, there's no bug if you just read that redundant test out of context. But just saying that is a meaningless statement, because it is always true. You need context to determine if there is a bug or not.\n\nIn the actual program it was taken from, there was an actual bug. Hence, everyone who said there was probably a bug in that line was correct, because that's just an short, imprecise way of saying \"there's probably a bug in the program where that line of code was found\".", "id": "d6nw0e7"}, {"comment": "Relax.", "id": "d6nuy8k"}, {"comment": "So, if it is not a bug, why was the code changed? Did the maintainers also fall to the reddit effect, and decided to change the code because of popular opinion? Or, was such an expression indeed a code smell of a present bug?", "id": "d6nvcfv"}, {"comment": "> So, if it is not a bug, why was the code changed?\n\nWho cares? That doesn't address the topic, which is whether the example is a software bug.", "id": "d6nvdrt"}, {"comment": "So in other words, this is not a bug?\n\n    struct pos {\n        int x, y;\n    };\n    \n    pos a;\n    ...\n    if (a.x == 0 && a.x == 0) continue;\n\n\nbecause according to your arguments, it isn't, but here in the real world, it definitely is and the programmer wanted to check for point in the origin, not on the Y axis.\n\n---\n\nOr my favorite example\n\n    if (type != MessageTypeA || type != MessageTypeB) {\n        ...\n    }\n\nSure, theoretically it is just a dumb way to write `if (true)`, not a bug, but in reality it is definitely a bug.", "id": "d6nvjkw"}, {"comment": "The likelihood is that the above code should have been:\n\n    if ((res->pw==0) || (res->qw==0)) continue;\n\nAnd then it proceeds to process a record it was supposed to skip. That's quite easy to note there's something wrong if there's redundancy such as that.\n\nI just wonder how these systems would be able to detect a bug such as failure to decrement value on right parenthesis at the first token, here's an idea of how errorneous code would look like:\n\n    tok = get_token()\n    depth = 1\n    while tok != null and tok != \")\" and depth > 0\n        tok = get_token()\n        if tok == \")\"\n            depth -= 1\n        if tok == \"(\"\n            depth += 1", "id": "d6ns7at"}, {"comment": "Well, for catching errors like yours with static analysis you can try [bek](http://www.rise4fun.com/Bek).  I can't promise you that it is yet real-world useful, though. \n\nBut yeah, it seems that you can catch stuff like that.", "id": "d6nv2es"}, {"comment": "How does an omitted check not (potentially) lead to wrongful behaviour?", "id": "d6ntypf"}, {"comment": "Again, that is far-fetched -- it extrapolates a harmless redundant test to the unsupported assumption that the programmer actually meant something else.\n\nBut in any case, this example doesn't meet the definition of a bug, which was the original topic.", "id": "d6nue60"}, {"comment": "> it extrapolates a harmless redundant test to the unsupported assumption that the programmer actually meant something else.\n\nWell, a static code checker's job is to make assumptions like that. You then get to choose: Was that just a harmless oversight, or something else. That's what those tools are good for, and they have helped me find quite a few bugs that might have bitten me later.\n\n> doesn't meet the definition of a bug\n\nSure, technically you're correct. We all bow down before your superior wisdom, and now for crying out loud, let's get over it. Lets call it a potential bug. I don't care. What matters is that those analyzers can help poor lazy sloppy coders such as myself write better code. If you're above all that, more power to you.", "id": "d6nupsp"}, {"comment": "There is a reason why bugs are called bugs and not programming errors. \n\nLets try to keep the distinction while we can. Although, judging from this thread, it seems nearly impossible. ", "id": "d6o0ywa"}, {"comment": "> There is a reason why bugs are called bugs and not programming errors. \n\nWell yeah. It seems a bit like an academic distinction to me, but as I said, I'm happy with \"potential bug\" in the case mentioned. Or, if you like it better, \"potential not quite bug, but something nebulous that we just pulled out of our collective asses, as long as the damn thing helps me improve my code\".\n\n> Lets try to keep the distinction while we can.\n\nIf it matters so much to you, sure. I would challenge you to name an instance, though, where that specific distinction actually had a huge impact on your coding.\n", "id": "d6o36jf"}, {"comment": "> Lets call it a potential bug. I don't care.\n\n1. It's not a potential bug, it is not a bug at all.\n\n2. Clearly you do care.\n\n> If you're above all that, more power to you.\n\nI'm not above all that, I just know what a bug is. I've been programming for 40 years ([an old best-seller of mine](https://en.wikipedia.org/wiki/Apple_Writer)), if experience still counts for anything, and I'm [still active](https://play.google.com/store/apps/developer?id=Paul+Lutus&hl=en).", "id": "d6nux1h"}, {"comment": "kthxbye", "id": "d6nuzow"}, {"comment": "I think what he is saying is that, in context, this is a bug, because the second instance constitutes a missing test for some other business logic-related factor. Perhaps the correct second instance would have been \"...->pw==-1)...\". In which case, the program would crash in some cases. Not all bugs are semantic. The worst bugs aren't because they can't be so easily detected.", "id": "d6ns91y"}, {"comment": "> I think what he is saying is that, in context, this is a bug, because the second instance constitutes a missing test for some other business logic-related factor. \n\nThat's far-fetched logic. It tries to say that a pointless test was actually meant to be something else, something the program requires, and therefore a bug. But that's not self-evident -- the only self-evident fact is that there is a pointless test attached to one that serves a purpose. The code as written is harmless. Calling it a bug is a conjecture about what was *really* intended.", "id": "d6nsocn"}, {"comment": "Stop being so dense. The fact that is is \"harmless\" and doing nothing instead of doing what it should IS the bug.", "id": "d6nt17o"}, {"comment": "Stop trying to redefine software \"bug\" to include a harmless redundancy. Here is the term's definition:\n\n[Software bug](https://en.wikipedia.org/wiki/Software_bug) : \"A software bug is an error, flaw, failure or fault in a computer program or system that causes it to produce an incorrect or unexpected result, or to behave in unintended ways.\"\n\nBy this widely accepted definition, *the example is not a bug* -- it doesn't meet the definition. Learn to live with it.", "id": "d6ntiac"}, {"comment": "Anyone with even a small amount of common sense can infer that the snippet provided is not what was intended to be executed. You can't just take that one snippet and go \"IT RUNS, IT'S NOT A BUG!\".\n\nNobody would write redundant code like that on purpose. You can therefore infer that there is a mistake in one of the variables being checked and that it should be something else. That would change the execution flow of the program. That fits the description perfectly. It could cause an incorrect or unexpected result, or behave in an untended way by running the if branch instead of not running it.", "id": "d6ntsi4"}, {"comment": "> You can't just take that one snippet and go \"IT RUNS, IT'S NOT A BUG!\".\n\nYou locate where I said or implied this, and I will defend it. I won't hold my breath. It's not a bug because the term \"software bug\" is defined, and the example fails the definition.\n\n> Nobody would write redundant code like that on purpose.\n\nIt happens all the time, and the burden is therefore yours to disprove it. And it's an example of the \"No True Scotsman\" logical fallacy.", "id": "d6nui3o"}, {"comment": "I'm not bothering to waste my time further with this other than to state that obviously nobody here agrees with you, therefore you are wrong.", "id": "d6nujzk"}, {"comment": "I agree that the duplication itself is not a bug. But this case definitely indicates that there **is a bug**, namely the missing check of `res->qw==0`.", "id": "d6nugit"}, {"comment": "The posted example is not a bug. The idea that something else was intended is a conjecture, but one that by itself cannot elevate the posted example to the status of a bug.\n\nAs I write this, I realize I'm arguing with people who haven't the slightest, foggiest idea how to think logically. This example would be like arresting someone for murder, on the evidence that he beat up a fire hydrant, but using the \"reasoning\" that he really meant to kill someone and the fire hydrant only stood in as a symbol for his true intent.", "id": "d6nunxd"}, {"comment": ">but one that by itself cannot elevate the posted example to the status of a bug.\n\nSo you're saying that even if the intended result was something else, meaning that the **actual** result will \"produce an incorrect or unexpected result, or to behave in unintended ways.\", which according to the definition you gave most definitely constitutes a bug, you think it's still not a bug?\n\nIf that conjecture is true, then it most certainly **does** elevate the example to the status of bug.  And it seems pretty likely that that is the case: you're not going to write completely redundant code intentionally, so either the check should have been something else, or it's the result of fairly slapdash refactoring.\n\nBut you know what, we don't **have** to speculate here.  We can actually go and check whether it was a bug or not.  Let's do that and see who's right.  If you look at the [example](http://www.viva64.com/en/examples/V501/) it's taken from, you can see it's from mupdf, in the file pi.c, function pi_next_rpcl.  Go download [the source](http://mupdf.com/downloads/) for that and you can find that line and see what it's been corrected to.  Oh look:\n\n\t\t\t\t\tif ((res->pw==0)||(res->ph==0)) continue;\n\nIt really was a bug.  Everyone else was right and you were wrong, who'd have thought!\n\n>I realize I'm arguing with people who haven't the slightest, foggiest idea how to think logically\n\nI think if you really think about this, you'd realise the person who hasn't \"the slightest, foggiest idea how to think logically.\" is yourself here.  You'd be really rubbish at investigating murders if you think those are equivalent too.\n", "id": "d6nx7r2"}, {"comment": "It's a completely reasonable conjecture. Nobody would intentionally write the same test twice, so it is reasonable to speculate that this code is not doing as intended. Stop waving your silly wikipedia definition around like some sort of pedantic shield. ", "id": "d6ntv3t"}, {"comment": "It's ... not ... a ... bug. That was the original topic, to which I responded. All this leaves the original topic.\n\n> Stop waving your silly wikipedia definition around like some sort of pedantic shield.\n\nAh, I see, the postmodern argument, to wit: word definitions don't really mean what they say, therefore ideas can't be accurately conveyed, therefore everything is subjective opinion. How can you not see that that argument logically must first be applied to itself, thus demolishing it?", "id": "d6nuh1k"}, {"comment": "It...*might*...be...a...bug, which is why it is worth flagging. Hiding behind a wikipedia definition (which is certainly not the 'official' definition you elsewhere claimed it to be) does not change the fact that there is a high probability that this code does not do what the author intended, which would be a bug. ", "id": "d6nuz5e"}, {"comment": "> Hiding behind a wikipedia definition (which is certainly not the 'official' definition you elsewhere claimed it to be) ...\n\nSo professional consensus doesn't count for anything? For most words, what people think the word means rules the issue, with sometimes [hilarious results](http://www.merriam-webster.com/dictionary/literally), but for technical terms, there are accurate and inaccurate definitions. If the Wikipedia definition was wrong, someone would correct it. Are you planning to correct it?\n", "id": "d6nv6bd"}, {"comment": "No, I have better things to do than waste my time arguing with wikipedia editors.\n\nMore to the point, the code in question **does** meet the definition you gave anyway. If the second part of the condition is wrong, then this will cause the program to \"*behave in unintended ways*\", since the body of the if statement will execute under conditions that it wasn't intended to (in this particular case, skipping to the next iteration of a loop when it should have finished the current iteration).", "id": "d6nvf7k"}, {"comment": "That's actually extremely likely, and looking at the fix, I'd say it's also exactly what happened.", "id": "d6ntz9c"}, {"comment": "It's not pointless conjecture. It happens all the time. I see this kind of thing in code reviews often. These sort of code smells leads us to find a subtle bug.", "id": "d6o6h95"}, {"comment": "> Yes, but the commonly accepted meaning of \"bug\" is code that could lead to a system failure or inoperative feature. \n\nNo. A bug is simply a deviation between the specification and the implementation. E.g., the program's user expected the program to work differently, or the implementer intended to write it differently. In this case, it's very likely the latter \u2014\u00a0there's no apparent use case for ORing the same condition.", "id": "d6nzdk3"}, {"comment": "> No. A bug is simply a deviation between the specification and the implementation.\n\nHere's the Wikipedia definition of software bug:\n\n[Software bug](https://en.wikipedia.org/wiki/Software_bug) : \"A software bug is an error, flaw, failure or fault in a computer program or system that causes it to produce an incorrect or unexpected result, or to behave in unintended ways.\"\n\nThe posted example does not meet this definition -- it cannot change the behavior of the program, because it doesn't change the program's algorithm. Two black boxes containing two versions of the program, one with, and one without, the example, cannot be distinguished from each other. Therefore the example is not a bug.", "id": "d6o3wqs"}, {"comment": "There is no such thing as an \"official definition\" nor is Wikipedia some sort of authority over the meaning of words. \n\nThe word \"bug\" is used in a lot of different ways. Bugs can be related to functionality, in the way that if you were to write a simple unit test for a method, that it would fail. \n\nHowever, bugs can also be related to implementation details, where your unit test might succeed, but it might take too much memory or time or whatever. \n\nHaving in mind that bugs can be related to implementation details, bugs can also refer to issues in your code. Your code might do something that makes no sense, which likely points to a bug in functionality but not neccessarily. \n\nMy point is that saying \"their definition of 'bug' is incorrect\" is silly, as there is no such thing as an official definition. The word bug is used differently depending on context and it can definitely mean code issues in certain situations. ", "id": "d6oh2c3"}, {"comment": "> There is no such thing as an \"official definition\" nor is Wikipedia some sort of authority over the meaning of words.\n\nThe postmodern argument. Look it up if you need to. And have a nice day.", "id": "d6omdud"}, {"comment": "It's simply how language works, there is very little to argue. ", "id": "d6onmt7"}, {"comment": "You missed my point. The postmodern argument is not that people differ on the meaning of terms before reaching a consensus, it is that conveying truths isn't possible, that everything is empty opinion. And why did I mention it? Because you objected to a well-established definition without suggesting an alternative. That's postmodernism defined.", "id": "d6onzex"}, {"comment": "No, you were claiming the word has a narrow definition because Wikipedia said so. \n\nYou can reject it because you believe it is a postmodern argument, but in reality it just reveals a severe misunderstanding in language and communication. \n\nA \"bug\" can have slightly varying meanings depending on context (reinforced by the existence of the article), it does not just have one meaning and everyone who uses it differently is incorrect.", "id": "d6opzoy"}, {"comment": "> The posted example does not meet this definition\n\nWhile I find that definition obtuse, *yes it does* meet it: it is, indeed, a flaw that causes the program to behave in unintended ways. You can niggle all day long that \"oh, but the programmer wrote this code, so it was clearly intended!\", but, well, it clearly wasn't, because writing code like that doesn't make any sense.", "id": "d6ofvca"}, {"comment": "> ... a flaw that causes the program to behave in unintended ways.\n\nFalse, and clearly so. A valid test is conducted twice, and the tests are joined by a logical operator that assures that the single test result is produced, which makes the code functionally identical to the correct form. Had the test been conducted once, it would not be a bug. How then does it become a bug if conducted twice?\n\n> ... because writing code like that doesn't make any sense.\n\nYes, that's true, it certainly doesn't make sense. But it is not functionally distinct from the correct form -- it produces the same result, and if you were presented with two black boxes, one having the single test and the other having the pointless double test, *there is no external test that could distinguish them*.\n\nTherefore it is not a bug, unless you care to argue that of two functionally identical programs, one contains a bug and other other doesn't, even though they both produce the same results, and a bug is defined as something that causes a program to produce an incorrect or unexpected result, or to behave in unintended ways.\n\nThere are all kinds of programming modes and stylistic choices that produce code that is inefficient or confusing or unmaintainable, but not all those choices produce bugs. For example, if you met a programmer who always used a bubble sort and never used quicksort, maybe you would want to fire him for incompetence (in some cases rightly), but (on that basis) you could not accuse him of putting bugs in his programs. The reason? A bubble sort is inefficient and slow, but it's not a coding error, it's not a bug.", "id": "d6omxvg"}, {"comment": "> False, and clearly so. A valid test is conducted twice,\n\nWhich wasn't the intention.\n\n> Had the test been conducted once, it would not be a bug.\n\nYes it would, because the programmer clearly intended to test two different things. Not one thing twice, not one thing once. Two things.\n\n> But it is not functionally distinct from the correct form -- it produces the same result\n\nYes it is \u2014 eliminating one of the tests clearly doesn't lead to \"the correct form\" either.", "id": "d6p7sff"}, {"comment": "It is not a bug, it's evidence of sloppy programming, PERIOD. The program functions the same with, and without, the redundant test.", "id": "d6pnb7l"}, {"comment": "It's a potential bug; actually very likely to be a bug; (and, case in question, an actual bug).\n\nThat's EXACTLY what static code analysis is for: Inform the coder about potential bugs. The coder then has to decide if it's really a bug, and if it's not, somehow give a hint to the analyzer so it doesn't belch at the same line again.", "id": "d6nu0t7"}, {"comment": "Actually, the bug brought to light here is that the organization which produced that code does not implement code reviews effectively.\n\nThe change which resulted in that code should have triggered a review catching the duplication.", "id": "d6o0g4o"}, {"comment": "Conceivably, most compilers in major use would. If the left-hand side of an OR statement is true most would also short-circuit the evaluation as the second will not change the fact that the entire boolean statement is true. ", "id": "d6nxe58"}, {"comment": "Short circuit boolean evaluation is actually mandatory and not an option in C and C++.", "id": "d6nxs5t"}], [{"comment": "Nonsense!  Tripe!  Hogwash!\n\nEveryone knows OSS is bug freee!", "id": "d6nr2wp"}, {"comment": "Said no one ever. But this is the beauty of it, we can examine and maybe fix the bugs in the code, unlike proprietary code.", "id": "d6nsvv8"}, {"comment": "You will also not be DMCAed for even looking for bugs also.", "id": "d6nw8ti"}]]], "4tl15q": ["Become a 10x Programmer by Managing Your Time Better", "2016-07-19 17:09:21", 0, "http://nickjanetakis.com/blog/schedules-arent-a-constraint-on-life-they-let-you-live-it", [[9, "Nah mate I want to be an 11x programmer."], [3, "I found the post to be an interesting read. Up until the point that it asked me to sign up my e-mail for a subscription on how to actually manage time (namely what the post promised to do).\n\nI down voted because of the click bait title, failed promised, and a e-mail sign up. This is a bad and you should feel bad."], [1, "This 10x programmer thing, do people really believe in this garbage? "]], [[{"comment": "Nah mate I want to be an 11x programmer.", "id": "d5i3l1j"}, {"comment": "Let's kick it up a notch:\n\n\u00a1***TRIPLE 11X ROCKSTAR TEAM LEADER IO&trade;***!\n\nExcuse me while I vomit in my mouth a little.", "id": "d5i3yy4"}, {"comment": "I've got an agile scrotum er... scrum that's 11x'ed up my rusty container.", "id": "d5i4145"}, {"comment": "No worries. Just thought the article may have been interesting to you guys since it was trending on HN for a while yesterday.", "id": "d5i3vbo"}], [{"comment": "I found the post to be an interesting read. Up until the point that it asked me to sign up my e-mail for a subscription on how to actually manage time (namely what the post promised to do).\n\nI down voted because of the click bait title, failed promised, and a e-mail sign up. This is a bad and you should feel bad.", "id": "d5ics29"}, {"comment": "I initially posted it without the PDF but then I got over 30 people who e-mailed me \"how do I make a schedule?\", so I added it.\n\nYou even said you found it interesting, so you clearly got value out of it. You don't need me to tell you how to make a schedule, but for the people who want a detailed short guide on how I make my schedules can get something they can apply in minutes. If your goal is to become more productive, having solutions handed to you is a lot faster than manually researching things on your own.\n\nThe PDF addition is an efficiency boost for both readers and myself, not some ploy to spam you to death or harvest your e-mail so that I can profit by selling it to a Nigerian prince.", "id": "d5idb93"}], [{"comment": "This 10x programmer thing, do people really believe in this garbage? ", "id": "d5i866b"}, {"comment": "Have you worked in a professional software development environment?  It's real.  In fact, I'd assert that some people cause \"anti-work\".  Others just manage time poorly or make bad decisions about what's important to work on and what's not.  Still others (largely overlapping group) tend to be really bad at problem solving, not properly narrowing things down before trying to fit their half baked theory into the problem.\n\nThat's the sort of stuff that adds up quickly. It might even add up to more than 10x quite frankly.", "id": "d5i8p81"}, {"comment": "Agreed, the problem is misapplication of the label, not that such programmers don't exist.", "id": "d5ip2wx"}, {"comment": "The main problem with the 10X is that it doesn't take into account programmers that have a negative productivity. ", "id": "d5i8fom"}, {"comment": "The negative Xers usually think they are 10Xers, management often agrees.", "id": "d5j1bze"}, {"comment": "Yea, I've seen that too. Though if you count lines written instead of bug-free features completed, they're not wrong.", "id": "d5j2vf0"}, {"comment": "Like spending so much time customizing your development environment you loose out on actually using it?", "id": "d5i8j1w"}, {"comment": "This is article is mainly about how you can avoid being a -10x programmer by learning how to manage your time better.\n\nNot so much customizing your development environment, but doing non-programming things that distract you from getting work done.", "id": "d5i8mau"}, {"comment": "That's only 0X. -10X is building 12 abstraction layers glued together with at least 3 DI frameworks and enough reflection to scare away every vampire on the planet.", "id": "d5iam76"}, {"comment": "The 10x programmer isn't a thing. The 0.1x programmer is, and so is his brother, the -1x programmer.\n\nEither way, time management, with all its merits, is not the silver bullet, nor an important factor. It's probably highly personal, but for me at least, aggressive time management and forcing myself to think about certain thing exactly when I'm scheduled to do it seems to be the most powerful drain on motivation and productivity. My most productive moments and periods tend to pop up when I say \"fuck everything, I gonna crack this fucker right now\".", "id": "d5ijkz6"}, {"comment": "That's not how math works.", "id": "d5j36xm"}, {"comment": "Of course not; it's not math, it's psychology and maybe sociology.", "id": "d5kvwmm"}]]], "49b9y8": ["The stacks used by some of the world's best startups [Awesome information]", "2016-03-07 09:02:28", 0, "http://stackshare.io/stacks", [[8, "I think answering \"How\" or \"Why\" is a lot more valuable than \"What\" stack they use."], [6, "> [Awesome Information]\n\nYeah, no. More like guess the logo out of the 4 random ones we picked to display in this format because it looks ok-ish but conveys less information that just listing the fucking things. "], [2, "Just living for the day when professional tools stop being chosen based on fashion or endorsement...."], [1, "Nice find! Thanks"], [1, "PHP still #2 on the applications stack list."]], [[{"comment": "I think answering \"How\" or \"Why\" is a lot more valuable than \"What\" stack they use.", "id": "d0qitl4"}, {"comment": "Plenty of How and Why over here: http://stackshare.io/featured-posts", "id": "d0qk3rt"}, {"comment": "I think if you know what these technologies are you basically know how they are being used. It's true some more information could enlighten how exactly - but overall this is still helpful in answering \"How\" and \"What\" imo. \n\nExplaining \"Why\" would be a great addition!", "id": "d0qiw0p"}, {"comment": "The more things a company does--and the more they break stuff into services--the less you can guess from a \"what\" list.\n\nSometimes the answer is \"because we haven't rewritten it yet.\"\n\n", "id": "d0qjsqq"}], [{"comment": "> [Awesome Information]\n\nYeah, no. More like guess the logo out of the 4 random ones we picked to display in this format because it looks ok-ish but conveys less information that just listing the fucking things. ", "id": "d0qhyn0"}, {"comment": "If you click the company, it pulls up a different screen with all of the names.", "id": "d0qid57"}, {"comment": "Haha fair point. I guess I'm good with logos as this wasn't a big issue to me. \n\nEdit: if you click an individual stack it lists the names for each logo. ", "id": "d0qi0xy"}, {"comment": "Just needs some alt text so you can hover over and learn the symbols", "id": "d0qi6n9"}], [{"comment": "Just living for the day when professional tools stop being chosen based on fashion or endorsement....", "id": "d0qm28s"}], [{"comment": "Nice find! Thanks", "id": "d0qk2kt"}], [{"comment": "PHP still #2 on the applications stack list.", "id": "d0qmzv9"}]]], "4vsjt2": ["On Killing WIN32? [On the erosion of freedom]", "2016-08-02 17:57:48", 13, "http://timothylottes.blogspot.co.uk/2016/07/on-killing-win32.html", [[29, "I don't disagree with the article per se, but all these changes happen because software becomes safer to use and easier to program. The author talks about the distance between graphics API's and the graphics hardware, but there used to be a time when you had to write a different renderer for every graphics card. OpenGL and DirectX now allow us to write the code once and run it on any graphics card.\n\nThe same happens with the Win32 API becoming more modern; the modern functions make a bigger effort to be easier to use and harder to make mistakes. You no longer have the freedom to block the shutdown process because the user (who should always be the god of the computer) has requested the PC to shut down. And while you no longer have direct access to the hardware, you also can no longer literally destroy your computer using software.\n\nI've also long agreed that later generations forget lose insights of the past but in the other direction: we forget why we implemented the abstractions in the first place and just complain about them existing."], [13, "The author mistakes win32 for something non-shitty. If win32 is deprecated it will be because it's replaced by something slightly less horrifying. \n\nI say this as someone who spent 9 years professionally in win32 land. It was a hellscape, pure and simple. I was more productive in objc/cocoa within days than in win32 after years. "], [13, "> Each new generation lacks the larger perspective of the last, and starts ignorant of what had been lost. \n\n\"But not me of course\""], [9, "> One of the best examples of this phenomenon is how the new generation perceives old arcade games. Specifically as, games with incorrect color (CRT gamma around 2.5 being presented as sRGB without conversion), giant exactly square pixels (never happened on CRTs), with dropped frames (arcade had crystal clear no-jitter on v-sync animation), with high latency input due to emulation in a browser for example (arcade input was instant in contrast), with more latency due to swap-chains added in the program (arcade hardware generated images on scan-out), with added high latency displays (HDTVs and their +100 milliseconds, vs instant CRTs), and games with poor button and joystick quality (arcade controls are a completely different experience). Everything which made arcades awesome was lost in the emulation translation. \n\nThat's why arcade games were AWESOME.\n"], [7, "Kill it! nuke it from orbit!!!\n\nIt's one of the worst APIs ever."], [2, "This kind if stuff keeps coming up. The democratization of computing means the true hackers are a rarer species. So the dominant platforms are tuned for people who don't care. It's embarrassing how powerful contemporary machines are, yet crippled by abstraction layers and bloatware. \n\nHeck, even most languages and development platforms are designed more for [the devs who aren't passionate](https://www.reddit.com/r/programming/comments/4vqy94/is_there_any_room_for_the_notpassionate_developer/) than for the nerd corps."], [4, "Well times change and we change with them... We can't still pretend we are working with C64 (that the author loves :) ) in face of different complexities... And its not neccessarily bad either, just different..."], [3, "This is as much about eroding freedom, as introducing memory process separation or introducing multi-user capabilities in operating systems.\n\nYou don't have the freedom anymore that processes read and change the memory of other processes (except through special debugging apis), but in reality you don't have processes anymore that go mental and destroy all other processes. You can't change files of other users against their will anymore, but that's actually something you want.\n\nIn this case, it's actually about locking out random programs you found on some dubious website from having all the privileges of the user. It's there to protect users."], [2, "Really? Let's dismiss it quick: you have all the \"freedom\" you want exactly like on C64. How? You don't HAVE to use the OS. Write all the low level code by yourself. Make your app... Bootable. Each game engine \"takes away your freedom\"... To reinvent the wheel and make your own better engine? Come on! Each 8-bit awesome game used an engine, but most of them used their own one of a kind \"freedom limiting\" engines. The most advanced thing an old 8-bit game could do is to treat a bunch of pixels as one object. In our dystopian times we can take all detailed and textured 3D object... as one object. Well, at least using those evil, freedom limiting engines.\n\nBTW: you can manipulate pixels more or less directly using a bunch of different techniques. But it's almost always slower than letting the system do it for you. And it's good!\n\nComputers are evil! They do so many things auto. Chips are evil, you loose the freedom to design internal circuits by yourself. You don't control how everything is connected. \n\nWell, here comes inevitable \"dark future\": everything high level, hardware independent. Full virtualization. Code executed on virtual CPU, using virtual memory drawing 3D graphics using virtual graphics adapter displaing video on virtual screen."], [0, "This sounds like the ramblings of a madman."], [-3, "Freedom is being able to quickly write useful software using clean APIs and modern abstractions (and modern GUI, and modern multi-threading concepts).\n\nSystem functions which take 10 arguments, with 6 of them being NULL and the rest being the same common flags in all common cases, is not freedom - it's slavery.\n\nBeing very likely to accidentally shoot yourself in the foot and fuck up mouse or keyboard messages due to a mistake in message queue handling isn't freedom. It's enslavement.\n\nHaving to worry of every software download fucking up your documents and system settings, and critical system DLLs and settings, because every app has absolute permissions and absolute power, is not freedom. It's being held ransom.\n\n"]], [[{"comment": "I don't disagree with the article per se, but all these changes happen because software becomes safer to use and easier to program. The author talks about the distance between graphics API's and the graphics hardware, but there used to be a time when you had to write a different renderer for every graphics card. OpenGL and DirectX now allow us to write the code once and run it on any graphics card.\n\nThe same happens with the Win32 API becoming more modern; the modern functions make a bigger effort to be easier to use and harder to make mistakes. You no longer have the freedom to block the shutdown process because the user (who should always be the god of the computer) has requested the PC to shut down. And while you no longer have direct access to the hardware, you also can no longer literally destroy your computer using software.\n\nI've also long agreed that later generations forget lose insights of the past but in the other direction: we forget why we implemented the abstractions in the first place and just complain about them existing.", "id": "d619czb"}, {"comment": ">but all these changes happen because software becomes safer to use and easier to program.\n\nThat is what *should* happen, but often it does not happen, or does not happen enough to be worth the trade off. And there is no reason you have to get rid of the 'hard' way just because you introduce an indirect 'easy' way.\n", "id": "d61g2um"}], [{"comment": "The author mistakes win32 for something non-shitty. If win32 is deprecated it will be because it's replaced by something slightly less horrifying. \n\nI say this as someone who spent 9 years professionally in win32 land. It was a hellscape, pure and simple. I was more productive in objc/cocoa within days than in win32 after years. ", "id": "d612hul"}, {"comment": "The problem still stands though.  It's slowly being superseded by APIs with more restrictions and less power.  Newer APIs are getting nicer, cleaner, but also more locked down.  You can always build nicer APIs atop Win32, but you can't climb out of the sandbox if it gets replaced.", "id": "d616iy6"}, {"comment": "That's a separate from win32 problem though. Replacement of win32 does not necessarily have to be so regressive. It just shows you the true face of any corporation. It is never about your freedoms. It is always about their profits.\n\n", "id": "d617dz6"}, {"comment": "> It just shows you the true face of any corporation. It is never about your freedoms. It is always about their profits.\n\nWhat do you think the legal purpose of any for-profit corporation in a capitalistic economy is? That's non-sensical criticism.", "id": "d61bcp5"}, {"comment": "Often people get outraged when a corporation puts their profits in front of human lives or freedoms. As if it is something not to be expected.\n", "id": "d61bi05"}, {"comment": "You are free to not buy Windows and use Linux or BSD or whatever instead. Turning this into a human rights debate is overly dramatic. If people truly cared about unfettered access to their PC, it would be profitable and corporations would care. But we live in a world where people love iPhones.", "id": "d61c67r"}, {"comment": "Use FOSS if that matters to you. For everyone else, the security sandbox is a huge benefit.", "id": "d616n9u"}, {"comment": "You can't be a professional engineer. A security sandbox is not the same as removing APIs. Docker would be a good example of that.\n\n\nThe problem general computing has is uneducated users and social engineering. If the default email client did not download files or display HTML most problems would go away. That doesn't require a change to any APIs.", "id": "d62j280"}, {"comment": "> If win32 is deprecated it will be because it's replaced by something slightly less horrifying.\n\nTrue.  Microsoft tried to introduce better, more modern c++ API's with Windows 8.  The actual API's weren't horrible to read but they were like, \"These API's only work full screen, programs can only be deployed by our app store, and there are a ton of restrictions that don't benefit you.\"  And the world collectively gave no shits.  The replacement for Win32 was more horrifying than Win32 if you wanted to write any sort of traditional native GUI applications that had, you know, multiple windows.\n\nEventually Win32 will be replaced.  If Microsoft refuses to provide the less horrifying replacement, I am sure Apple and Google will gladly soak up the win32 refugees.  ", "id": "d619jc6"}, {"comment": "> The replacement for Win32 was more horrifying than Win32 if you wanted to write any sort of traditional native GUI applications that had, you know, multiple windows.\n\nFixed in Windows 10.", "id": "d61a9an"}, {"comment": "You are taking the article out of context. It is a response (not necessarily contradicting) to what Tim Sweeney wrote recently about Microsoft slowly killing Win32 in favor of the more restricted UWP. It doesn't talk about Win32's merits itself.", "id": "d616mzy"}, {"comment": "Maybe, but if the article disregards the merits of win32 it is also talking out of context and is thus at fault. ", "id": "d61e1gl"}, {"comment": "does anybody use win32 without a wrapper? the terrible nature of the api doesnt matter much if you are using SDL or something on top of it", "id": "d63t4uq"}, {"comment": "There's WAY too much API surface in win32 to use a wrapper. The construct works FOR the matrix. \n\nSo yea, some things you're fine with a wrapper but in those cases the wrapper can be updated to use the new APIs and this entire article is moot. ", "id": "d63vsmb"}], [{"comment": "> Each new generation lacks the larger perspective of the last, and starts ignorant of what had been lost. \n\n\"But not me of course\"", "id": "d610afw"}, {"comment": "The key word there is *starts*.  My kids take for granted that their console video games require an active internet connection. I just had to tell them that older consoles didn't work that way.\n\nThe same is true for all other things we start out by overlooking.  I'm 39, and I took for granted that all grocery stores have membership cards.  It wasn't until recently that I realized it's a kind of tracking, marketing, and advertising tool that wasn't around when my grandparents went grocery shopping.\n\netc... etc...  We can learn of the problems and address them.  We just start out ignorant of what was lost.", "id": "d611031"}], [{"comment": "> One of the best examples of this phenomenon is how the new generation perceives old arcade games. Specifically as, games with incorrect color (CRT gamma around 2.5 being presented as sRGB without conversion), giant exactly square pixels (never happened on CRTs), with dropped frames (arcade had crystal clear no-jitter on v-sync animation), with high latency input due to emulation in a browser for example (arcade input was instant in contrast), with more latency due to swap-chains added in the program (arcade hardware generated images on scan-out), with added high latency displays (HDTVs and their +100 milliseconds, vs instant CRTs), and games with poor button and joystick quality (arcade controls are a completely different experience). Everything which made arcades awesome was lost in the emulation translation. \n\nThat's why arcade games were AWESOME.\n", "id": "d613uhk"}], [{"comment": "Kill it! nuke it from orbit!!!\n\nIt's one of the worst APIs ever.", "id": "d613oy4"}, {"comment": "Also one of the first APIs ever - at least at this scale.", "id": "d6157j1"}, {"comment": "That doesn't justify its weirdness. At the time win32 was developed, there were other apis as well in other platforms with similar functionality but a much better design.", "id": "d6252ey"}, {"comment": "That's because it had to be backwards compatible to win16 which was pretty much designed and started with Windows 1.0 in the early 80s and was extended ever since. Back then, the winapi was fairly lean and well designed, and many of its quirks made perfect sense (remember e.g. that they implemented virtual memory and paging on the freaking 8088). A lot of additional weirdness was actually added during the 32bit transition, since they took very good care that as much 16 bit apps as possible would keep working on win95 and at the same time tried to make it easy to port code to 32 bit.\n\nI'm actually very impressed how far they could push it. For a very long time backwards compatibility was the top priority for keeping your customer base. There were many far superior platforms and operating systems over time, but we know how they mostly ended or are doing. Only now that everything moves to the cloud the OS gets more and more demoted to the browser display platform.", "id": "d62tqlk"}, {"comment": "I disagree, win16 was a bad api, and continuing to this day to build new functions based on its \"logic\" is terrible.\n\nAnd virtual memory was not available on 8088.\n", "id": "d62w4kv"}, {"comment": "> And virtual memory was not available on 8088.\n\nThat's why they had to implement it in software. You apparently don't know too much about the beginnings of win16: Windows on the 8088 had paging, virtual memory and cooperative multi tasking. Like said, in Windows 1.0 the winapi was as clean and elegant as it could be, regarding the huge limitations of the hardware it had to deal with, because of which you didn't exactly have the resources to build fancy abstraction layers either. And That pretty much set the foundations, since from then on it was an endless chain of backwards compatibility. By the time we arrived at win 3.11 and had protected and virtual mode, there was already a big load of legacy in the winapi to live with.\n\n> continuing to this day to build new functions based on its \"logic\" is terrible.\n\nThe continued success of Windows for the next 20 years after Windows entered the market showed that people didn't care. They didn't want to throw away all their expensive software they bought every time a new os release came around. That goes for private users as well as big corporations running dozens of expensive tools that make up convoluted processing chains.  \nThat's the one thing Microsoft figured out very early and got right. They have huge teams that are solely responsible for testing as much 3rd party software as possible on every new release of Windows, creating compatibility shims for misbehaving programs that only worked on the old version because they used undocumented features, relied on undefined behaviour or got away with invalid memory access because the memory layout just happened to forgive you that silly off by one error somewhere. Terrible maybe, but if it ensures you stay numbers  one and you make a shitton of money, it sounds like the right thing to to.", "id": "d62y81t"}, {"comment": "No, Win 1.0 did not have paging, virtual memory. Yes, it did have cooperative multitasking. 8088 did not provide any support for paging or virtual memory and neither it is possible to do it in software were the current app running is in control of the hardware.\n\nNo, the Win16 api was not as elegant as it could be, and the hardware limitations had nothing to do with how elegant it was or it wasn't.\n\nNo, there is no excuse to keep extending the win32 api when we finally got to 32-bit microprocessors. Microsoft could have provided an entirely new api, of high quality, and provide an emulation layer for older win32 applications.\n\nOther platforms like the Mac completely ditched the old apis while providing 100% compatibility with legacy software.\n\nMicrosoft could have made even more money if its apis where better.\n\n", "id": "d62zuar"}, {"comment": "Instead of making a fool out of yourself here you could have taken a quick look at the fucking Wikipedia article of Win 1.0 which states that\n\n> Applications were supposed to handle memory only through Windows' own memory management system, which implemented a software-based virtual memory scheme allowing for applications larger than available RAM.\n\nI have written software for Windows 2 using the virtual memory API, and remember from docs that it was already present in Windows 1.0.\n\n> Microsoft could have provided an entirely new api, of high quality, and provide an emulation layer for older win32 applications. [...] Microsoft could have made even more money if its apis where better.\n\nOr they could just not bother and still make all the money. I don't see how with a market share of 90% a better API would have made you more money. You have an interesting understanding of economics.\n\n> Other platforms like the Mac completely ditched the old apis while providing 100% compatibility with legacy software.\n\nThey were emulated and ran slower. It wasn't perfect so no 100%. But nobody cared since nobody used Macs anyways by the end of the 90s. So Apple had nothing to lose and they could take a shot at a new start. It worked for them.\n\nBut in order to not feed the troll I'm not going to address the rest and will end this conversation here. There is no point in conversing with someone who can't even look up simple facts and is unable to back their claims with any form of examples/references or anything the like.", "id": "d63qr06"}, {"comment": "> Instead of making a fool out of yourself here you could have taken a quick look at the fucking Wikipedia article of Win 1.0 which states that\n\nWhat Windows 1.0 supported was not virtual memory as we know it today, it was more like \"unload this memory block, load this memory block\" tricks, which was already present in DOS as memory swap.\n\nI wouldn't call that virtual memory.\n\n> Or they could just not bother and still make all the money. I don't see how with a market share of 90% a better API would have made you more money. You have an interesting understanding of economics.\n\nMicrosoft has 90% of desktop sales. It doesn't have the 90% of desktop software, or client-server software. It could have that as well, if its apis were better.\n\n> They were emulated and ran slower\n\nWho cares. They were quick enough to make the applications usable for the majority of cases.\n\n>  It wasn't perfect so no 100%.\n\nYeah, it was 99.999999999% perfect.\n\n> But nobody cared since nobody used Macs anyways by the end of the 90s. \n\nIf nobody cared, Apple wouldn't provide an emulation layer.\n\n> So Apple had nothing to lose\n\nThey did have big things to lose...namely all the art-related customers which used the Mac for graphics, Photoshop, printing etc.\n\n> But in order to not feed the troll I'm not going to address the rest and will end this conversation here. There is no point in conversing with someone who can't even look up simple facts and is unable to back their claims with any form of examples/references or anything the like.\n\nYou are the troll, since you're trying to defend Microsoft's bad APIs.\n", "id": "d63vef1"}, {"comment": "I don't understand why so many people hate win32, I actually find it gets work done fairly effectively.", "id": "d61glh6"}, {"comment": "Here is the most recent example: I was looking for an API that can monitor the filesystem for changes.\n\nLinux has the inotify interface, which is very nice, provides different event types, and works over remote filesystems.\n\nWin32 has the FindFirstChangeNotification, FindNextChangeNotification, ReadDirectoryChangesW, which have severe limitations, miss events under various circumstances, do not work on remote file systems (may  not work, as Microsoft says).\n\nAnd findfirst/findnext is the wrong analogy for filesystem events.\n", "id": "d624z17"}, {"comment": "I vaguely remember implementing something thread-pooly in a BSD using kqueue and on Windows using IO completion ports.\n\nThe Windows implementation ended up short, elegant and... well, better.\n\nBut yes, that experience stood out *because* it was unusual.", "id": "d62duaf"}, {"comment": "https://mollyrocket.com/casey/stream_0029.html", "id": "d63tayz"}], [{"comment": "This kind if stuff keeps coming up. The democratization of computing means the true hackers are a rarer species. So the dominant platforms are tuned for people who don't care. It's embarrassing how powerful contemporary machines are, yet crippled by abstraction layers and bloatware. \n\nHeck, even most languages and development platforms are designed more for [the devs who aren't passionate](https://www.reddit.com/r/programming/comments/4vqy94/is_there_any_room_for_the_notpassionate_developer/) than for the nerd corps.", "id": "d616j1i"}, {"comment": "> The democratization of computing means the true hackers are a rarer species.\n\nMore people having access is a bad thing now?", "id": "d61ou8d"}, {"comment": "Designing foundational APIs to be used by people who have no clue what they are doing is a bad thing, if they limit control/access in the process", "id": "d63td0c"}, {"comment": "Oh, don't get me wrong, there are benefits on that side. But the tech population is diluting, and the market responds, and pretty soon, you're the only one left with a lightsaber, wondering why they don't make things the way they used to.", "id": "d62fhw0"}], [{"comment": "Well times change and we change with them... We can't still pretend we are working with C64 (that the author loves :) ) in face of different complexities... And its not neccessarily bad either, just different...", "id": "d618lbg"}, {"comment": "If he wants to work like with C64 he is free to code his own APIs and maybe OS... ", "id": "d61h02r"}, {"comment": "He did. Poked AMD GCN from bare metal (which is not surprising considering that his day job was practically that but at NVIDIA, he is a guy behind FXAA/TXAA). Now seems like he went one step further and switched to FPGAs.", "id": "d628s5o"}], [{"comment": "This is as much about eroding freedom, as introducing memory process separation or introducing multi-user capabilities in operating systems.\n\nYou don't have the freedom anymore that processes read and change the memory of other processes (except through special debugging apis), but in reality you don't have processes anymore that go mental and destroy all other processes. You can't change files of other users against their will anymore, but that's actually something you want.\n\nIn this case, it's actually about locking out random programs you found on some dubious website from having all the privileges of the user. It's there to protect users.", "id": "d624gju"}], [{"comment": "Really? Let's dismiss it quick: you have all the \"freedom\" you want exactly like on C64. How? You don't HAVE to use the OS. Write all the low level code by yourself. Make your app... Bootable. Each game engine \"takes away your freedom\"... To reinvent the wheel and make your own better engine? Come on! Each 8-bit awesome game used an engine, but most of them used their own one of a kind \"freedom limiting\" engines. The most advanced thing an old 8-bit game could do is to treat a bunch of pixels as one object. In our dystopian times we can take all detailed and textured 3D object... as one object. Well, at least using those evil, freedom limiting engines.\n\nBTW: you can manipulate pixels more or less directly using a bunch of different techniques. But it's almost always slower than letting the system do it for you. And it's good!\n\nComputers are evil! They do so many things auto. Chips are evil, you loose the freedom to design internal circuits by yourself. You don't control how everything is connected. \n\nWell, here comes inevitable \"dark future\": everything high level, hardware independent. Full virtualization. Code executed on virtual CPU, using virtual memory drawing 3D graphics using virtual graphics adapter displaing video on virtual screen.", "id": "d63av9i"}, {"comment": "[deleted]", "id": "d63t8bm"}, {"comment": "Would it make any difference if they used Linux? Does Linux provide more freedom in low level access to hardware features? Is it easier to create games for Linux? I don't think so.", "id": "d63vmyz"}], [{"comment": "This sounds like the ramblings of a madman.", "id": "d613k85"}], [{"comment": "Freedom is being able to quickly write useful software using clean APIs and modern abstractions (and modern GUI, and modern multi-threading concepts).\n\nSystem functions which take 10 arguments, with 6 of them being NULL and the rest being the same common flags in all common cases, is not freedom - it's slavery.\n\nBeing very likely to accidentally shoot yourself in the foot and fuck up mouse or keyboard messages due to a mistake in message queue handling isn't freedom. It's enslavement.\n\nHaving to worry of every software download fucking up your documents and system settings, and critical system DLLs and settings, because every app has absolute permissions and absolute power, is not freedom. It's being held ransom.\n\n", "id": "d61jysq"}, {"comment": "Those system calls take more arguments than Unix system calls in order to specify, for example, a SECURITY_ATTRIBUTES structure for fine-grained access control, or whether an I/O operation should be overlapped (asynchronous) or not. Fun fact: *All* Unix I/O calls are synchronous.\n\nThe Windows kernel is quite a bit more sophisticated and powerful than Unix, and unfortunately that comes with added complexity.", "id": "d61x4pb"}, {"comment": "[POSIX AIO](http://man7.org/linux/man-pages/man7/aio.7.html) is a thing for quite some time.", "id": "d628u7l"}, {"comment": "On Linux, it's implemented as a library -- which works by making synchronous I/O calls in a separate process/thread.\n\nAsynchrony on Unix sucks because it wasn't built into the system from the ground up. By contrast, Windows inherited its model for I/O from VMS, which was better than the Unix model in the 1970s and is still better today. On Windows you can check an I/O buffer for data, and if no data is found, schedule the operation that would produce that data -- in one system call.", "id": "d62fvn2"}, {"comment": "nope, it is build on async io syscalls.\n\nhttps://www.fsl.cs.sunysb.edu/~vass/linux-aio.txt", "id": "d62fxwe"}, {"comment": "The POSIX AIO library is not built on those syscalls. It is built how I described.\n\nHardly anyone actually uses the Linux aio calls. Their continued inclusion in the kernel is controversial. I think Linus want to rip them out.\n\nAnyway, compared to the NT kernel APIs these calls are woefully inadequate. When Linux provides I/O completion ports and *comprehensive*, *non-racy* calls to schedule I/O and await the results, let me know. Until that time, [the most performant network I/O frameworks will be Windows-only](http://pyparallel.org).", "id": "d62kezk"}]]], "5dohm8": ["Google Cloud is 50% cheaper than AWS", "2016-11-18 22:59:55", 197, "https://thehftguy.wordpress.com/2016/11/18/google-cloud-is-50-cheaper-than-aws/", [[469, "...if you run numbers using Google Cloud's discount for full utilization but not Amazon's. I agree that managing reserved instances is a pain in the ass, and that they're far from ideal for many (most?) workloads ... but this is complete horseshit.\n\nIf you're going to put together a title like \"Google Cloud is 50% cheaper than AWS\" it can't have a subtext of \"because I don't like AWSs billing platform and decided to compare prices unfairly\"."], [103, "https://thehftguy.files.wordpress.com/2016/11/aws-vs-gce-pricing-summary.png\n\n> \"moving average\" of something that isn't even a series, let alone a time series\n\n[\\*head explodes\\*](https://media.giphy.com/media/oaPcDncoLfgjK/giphy.gif)"], [81, "I have used Google Cloud, AWS, and Azure all EXTENSIVELY in many different services and never found Google Cloud to be cheaper than AWS for most service.\n\nHaving said that, AWS offers by far the widest breadth of services but there are things that both Google Cloud and Azure offer that make them far more suited for certain applications.\n\nI think for cloud services, they are all close enough in price that the choice should be centered around what and what is not offered."], [57, "What did AWS do to this guy?"], [25, "Another article from the same guy for the record: \n\nhttps://thehftguy.wordpress.com/2016/06/15/gce-vs-aws-in-2016-why-you-should-never-use-amazon/\n"], [22, "The amount of extra labor put into the entire Google Cloud Platform more than offsets this. I'll never look back from switching to AWS."], [15, "...I don't believe this. If this was true, then why isn't Google Cloud seeing massive growth? Azure is making headway, but AWS continues to dominate.\n\nFor me AWS wins on:-\n\n* UI (see Azure \"dashboard\")\n\n* Documentation (see out of date Azure documentation)\n\nBoth of those are really important to me. Try using the Azure dashboard and see how quickly you lose hair. Or try reading about how you add authentication to your mBaaS.  Or try managing your account in the Azure dashboard, oh wait. No you can't. You have to go to the old \"classic\" portal for that."], [10, "I've been meeting with various cloud providers reps since 2007. I've been professionally involved with AWS, Azure and GC and also have used Openstack/Cloudify. I know for a fact that each major player has dedicated teams whose only job is competition analysis and, of course, it includes pricing. If you are with any major player and find that a competitor is offering a better price point for your needs, you just need to call and you will get what you want provided that you are comparing apples with apples. I simply cannot see AWS letting anyone, especially Google, undercut them so much."], [9, "Who pays anything close to sticker price for AWS?"], [6, "Honestly all the cloud pricing is pretty similar. The only outlier is Azure for Windows type pricing as well as SQL because they own the technology stack and don't have to pay licensing fees for it.\n\nMy real problem with AWS is that I wind up spending more man-hours managing VMs (because basically that's AWS' entire service other than Lambda which has a *lot* of limitations) than I'd like. Their PaaS services thus far are kind of well... not great. And of course there are no on-premises equivalents so it's a total vendor lockin play.\n\nAt least on Azure if I want to do containers I don't have to manage a farm; I can run Kubernetes as a service. If I want SQL I get a real multi-tenant service that I can give developers a database for $5 a month; I can't do that on AWS for that cheap, even with Aurora -- it's not a multitenant service.\n\nI think Google has a good future and as other indicated the pricing is dishonest in this article, but it's not the pricing that will pay them this benefit, it's the PaaS services that they excel at. You can use AWS for VMs and scaling, and a few other ancillary services -- it does that well. But you can use GCE or Azure for that too. You don't get as much in terms of machine choice as you do with AWS, but the reality is... do you need it?\n\nI think the future is moving away from the way AWS is building its services and more to the way GCE/Azure are building theirs. Nobody wants to spend the operational overhead and build devops practices just to manage environments... they just want a service that works and provides them the ability to do more work on their product in less time.\n\nAWS doesn't really do that as well as Azure/GCE do. It's just going to take some time for people to stop thinking AWS is really that great and investigate other options. And by the way -- if you are complaining about the console, you aren't using it right. Everything should be done programmatically and the console is just there as a helper.\n\n*Source: Ran cloud program for a Fortune 100 company covering multiple cloud providers"], [2, "The interface is awful on gCloud, though. I find its navigation highly non-intuitive. "], [2, "Lying sack of shit article. t2.small is $0.017/hr. That's $12.24/30 days, versus $20+ the article quotes for Amazon and $15/mo they quote for Google. You can see the best Amazon prices [here](https://aws.amazon.com/ec2/pricing/reserved-instances/pricing/)."], [1, "just find an IDC"], [1, "[deleted]"], [1, "I wonder where azure stacks up?\n\nI use azure for a few VM's but Microsoft gives us $6000 a year in free azure service's for 5 years for being a startup, in 2 more years we will have to start paying but its a pretty great deal right now."], [1, "As someone with experience in guiding tech startups i can tell that both are more or less equal in pricing. \nBut i find them both very very expensive for smaller companies. \nWithout a big funding package you should not go for either of them.\nThere are plenty of cloud services out there which are cheaper and provide enough reliability. \nI have seen an example where the monthly cost of a GC setup was around 10k versus $700 on a different cloud provider. No real concessions had to be made. Similar structure, similar performance. Reliability maybe not, but thats acceptable in many situations. "], [1, "Damn - my adblocker did not block that ad!"], [1, "Just use Azure."]], [[{"comment": "...if you run numbers using Google Cloud's discount for full utilization but not Amazon's. I agree that managing reserved instances is a pain in the ass, and that they're far from ideal for many (most?) workloads ... but this is complete horseshit.\n\nIf you're going to put together a title like \"Google Cloud is 50% cheaper than AWS\" it can't have a subtext of \"because I don't like AWSs billing platform and decided to compare prices unfairly\".", "id": "da64swn"}, {"comment": "> If you're going to put together a title like \"Google Cloud is 50% cheaper than AWS\" it can't have a subtext of \"because I don't like AWSs billing platform and decided to compare prices unfairly\".\n\nI would add \"also, Google discounts compute pricing to attract customers because they're woefully feature-deficient as a cloud platform.\"\n\nLiterally the only compelling reason to using GCE is if you _only_ need compute and you are, as /u/awj said, offended by Amazon's billing model.", "id": "da65wjw"}, {"comment": "Instances do spin up significantly faster with GCE, but yeah.\n\nOn the flipside, they have good APIs :)", "id": "da6ccjk"}, {"comment": "> On the flipside, [GCE] they have good APIs :)\n\nThough they have *terrible* documentation. ", "id": "da6q59r"}, {"comment": "Google really need to invest in improving this issue. So many google products are poorly documented. So much stale content too. ", "id": "da6uner"}, {"comment": "In my opinion, after extensive studying of both AWS and GCP APIs, I've got to say GCP are so much better documented. AWS has a ton of incorrect docs, usually too verbose, bad web layout and GCP also provides better examples.", "id": "da6x421"}, {"comment": "Amazon's billing model is abhorrent and unpredictable. I don't understand why they can't just provide a flat pricing like digital ocean does.", "id": "da6koqs"}, {"comment": "Probably want to nickle and dime customers, but that's probably just me being cynical.", "id": "da72dme"}, {"comment": "It's more like dollaring and hundreding but I get your meaning.", "id": "da7v9x9"}, {"comment": "I love DO so much because of the simple, flat pricing they have. Unfortunately I am tied to AWS for some projects because of stuff that DO is currently not offering (GPU for instance.)", "id": "da6vaxp"}, {"comment": "> Literally the only compelling reason to using GCE is if you only need compute and you are, as /u/awj said, offended by Amazon's billing model.\n\nThat's not the only compelling reason.  The most compelling reason is to avoid the disaster that is Amazon's management tools.  I mean, jesus christ look at this.  This is Amazon's control panel:\n\nhttp://imgur.com/a/xNXcX", "id": "da6cjyi"}, {"comment": "I don't think there's anything particularly wrong with the main page of the console except that it's tough for beginners to figure out what they need for common use-cases. [Which is exactly what they fixed in the new console UI](http://i.imgur.com/2BiHCsZ.png). Otherwise it serves its purpose pretty well as a big catalog of all the different services you can use.", "id": "da6e9cm"}, {"comment": "It's comparable to a toolbox conceptually. If you open a toolbox full of tools you're not familiar with, you'll get a similar feeling. Some tools will look like they do the same thing. Others you can't imagine a use case for. \n\nThe new console UI helps.", "id": "da6gt8c"}, {"comment": "Also, the control panel is for your fairly basic use-cases. They didn't even have a control panel at one point. They still don't have user interfaces for some of their more advanced services such as Spot Fleet.\n\nIf you're running a serious VM estate on AWS, you're using a tool like CloudFormation or Terraform or even rolling your own if you're like Netflix. ", "id": "da6g31t"}, {"comment": "Route 53 had no control panel for months after its release.\n\nI think you can do Spot Fleets through the control panel now, though.", "id": "da6gu24"}, {"comment": "What's the problem? After the first time you know which tools you want (EC2 and Elastic for me) and immediately click them and go to the specific page.", "id": "da6j7kb"}, {"comment": "Not any more.   They updated it.", "id": "da6n7dq"}, {"comment": "I took that screenshot *today*.", "id": "da6r5xe"}, {"comment": "Mine was updated at around 4pm EST. I couldn't find anything anymore. I want my wall of links back.", "id": "da6ravo"}, {"comment": "The AWS dashboard is *awesome* with [Cloud to Butt Plus](https://chrome.google.com/webstore/detail/cloud-to-butt-plus/apmlngnhgbnjpajelfkmabhkfapgnoai) installed.", "id": "da7061o"}, {"comment": "> Google Butt is 50% cheaper than AWS\n\n :]", "id": "da9l3jn"}, {"comment": "No one sane uses Amazon's control panel for real work (there is one exception, because they have a feature that ONLY exists in the control panel). I tell my guys time and again: \"stop using the control panel... nothing good will come of that\".", "id": "da6gx9j"}, {"comment": "> the disaster that is Amazon's management tools\n\nYou've clearly never had the displeasure of working with Microsoft Azure.", "id": "da7ivzt"}, {"comment": "Yeah their control panel does suck. I dabbled a little bit wit AWS for about a week and thought it was too complicated. For my next project I'm going to give DigitalOcean a try and see if it's any easier. (It looks like I may have to SSH in for a few things, but it still looks like it will be simpler than AWS)", "id": "da6n3bd"}, {"comment": "Lol. OK. Report back. \n\nIf you don't like to ssh in to a machine have fun with DO", "id": "da6q6bf"}, {"comment": "After I get my lamp stack all setup, I'm pretty sure I can just SFTP in with filezilla.", "id": "da6y2dr"}, {"comment": "I love using sftp to tail logs and restart services!", "id": "da72kst"}, {"comment": "Okay Dildo Swaggins, thanks for the advice.", "id": "da7d4cq"}, {"comment": "> I would add \"also, Google discounts compute pricing to attract customers because they're woefully feature-deficient as a cloud platform.\"\n\nWhat do you mean by that? They offer fewer services, yes, but when it comes to running servers, GCE is actually superior.\n\nFor example, GCE lets you to resize disks directly. On AWS the only option is to make a snapshot, make a new disk and attach a new disk.", "id": "da6tno2"}, {"comment": "So. IPv6 yet? Oh no, their entire networking platform does not have the ability to cope with any other protocol than IPv4 TCP or UDP. Not even ICMP.\n\nSo that's a good number of customers from smaller ISPs having to connect through Carrier Grade NAT, with all of Google's \"suspicious activity\" CAPCHA mess.", "id": "da6zdwt"}, {"comment": "BigQuery is really nice for many use cases and doesn't have a real alternative.", "id": "da751ia"}, {"comment": "[Here's](https://news.ycombinator.com/item?id=12994730) what the Author said about this on HN:\n\n> While I agree that Google's pricing model is superior, the author's position on reserved instances accounts for ~40% of the cost difference.\nAuthor here :D\nGotta take a stance to draw graphs, right? Comparing no reserved instance with the automatic discount is simple and realistic in my experience.\nI could make pricing graphs accounting for 25% of AWS reservations and 75% of automatic google discount. In my experience, that's the proportions we _may_ have in practise. It would still be the same conclusion. Google is massively cheaper.\nI could make TCO pricing graphs, accounting for the thing from the last paragraph, plus the human time (500$/day) required to understand, pick and manage reservations. I didn't do all the computations but so far it points towards a negative ROI (compared to not reserving), unless the infrastructure is big enough to have the economy of scale (hundreds thousands dollar per year). (Note: I really don't want to go against all the HN/reddit crowd who drank the reservations marketing koolaid, so purposefully avoid to talk about the TCO pricing model publicly ^^).\nThus, in all scenarios, google instances are massively cheaper. YMMV.\n\nGoogle offers a very compelling IaaS service to EC2. Just to name a few things, better disk, better reliability with live migration, global load balancer, global images, global snapshots, better networking, preemptlbie VMs > Spot instances, CUSTOM VMs, global networking out of the box, etc.\n\nAnd then there's services that AWS has no equal to - Bigtable, BigQuery, PubSub, Dataproc, Dataflow, GKE, CloudML, etc, etc. \n\nI think you owe it to yourself to at least take a look. Here's a good starting point:\nhttps://cloud.google.com/docs/compare/aws/", "id": "da780gk"}, {"comment": "Can you please elaborate on the \"woefully deficient\"?? There are many many Google services that AWS lacks today, and only a couple of spots IMHO where Google is lacking, largest one being managed postgres.", "id": "da78jiv"}, {"comment": "Not just Postgres but also MSSQL and Oracle.\n\nMost notably, they have no products competing with:\n\n* Elasticache\n* Directory Service\n* SES\n* Route 53 private zones\n\n... among the other odds and ends. Elasticache and Directory Service analogues aren't as big a deal but the lack of an email service or private DNS is baffling. SES integration with SNS, S3, and Lambda is insanely useful and I would have difficulty getting by without on Google Cloud. The lack of private zones for VPC should be a compelling reason for anyone to _avoid_ Google Cloud.", "id": "da7a07n"}, {"comment": "Thanks - I agree, I wish we had Elasticache, beyond a partner solution or a click-to-deploy solution. Stackdriver, Cloud Logging, and BigQuery help fill use case, but not 1:1. Same with ORCL/SQL Server.\n\nI'm not discounting the AWS ecosystem at all - they've done a great job delivering a compelling ecosystem. My argument is, Google has done this as well, albeit slightly differently. Things don't match 1:1, and are often for good reason (second-comer advantage for example).\n\nIf we flip the conversation, one can say \"lack of global images, lack of global vpc ([this](https://aws.amazon.com/answers/networking/transit-vpc/) doesn't count), prewarming ELBs, having to use network/storage/IO-optimized instances, lack of live migration and custom VMs, lack of a decent Cloud Logging system should be compelling reasons for folks to avoid AWS\". \n\nThis is slightly out of my expertise, but every Google project is in its own private network [by default](https://cloud.google.com/docs/compare/aws/networking). And, VPC came out of beta just recently so stuff is getting delivered on that front at a fast clip. Email is done through an industry-popular partner. Directory Service is compelling, and there are some Google Apps bits that help.", "id": "da7f0s2"}, {"comment": "What about the SEO aspect, do you know if Google somehow favors the stuff running in GCE? If that happens, it's a big reason to use it.", "id": "da6uy2c"}, {"comment": "If that happens it's a big chance for a antitrust case as well, since they would be misusing their competitive power.", "id": "da6vbev"}, {"comment": "Don't they use time-to-first-byte as part of their search ranking? They're going to have a few ms advantage, potentially being in the same data center.", "id": "da6x0tn"}, {"comment": "Interesting theory, I think that you are right on that one. Then at least a slow site on GCE will be beaten by a fast site on <insert random cloud provider here> ;)", "id": "da6yx9z"}, {"comment": "I can paint some sort of scenario:\n\n* 1 - Guy runs a website in GCE and has some small revenue running adsense.\n* 2 - Google slowly boosts its pagerank and brings a lot more of traffic.\n* 3 - The website increases userbase and adsense revenue, but he has to spend more with GCE.\n* 4 - ?\n* 5 - Google profits from everything.\n\nAgain, I don't know if they do that and I think they don't, but I can imagine the whole thing.", "id": "da71e1v"}, {"comment": "Google n1-standard-16 (16 core 60 gig ram)  vs m4.4xlarge (16core 64gig ram)\n\nGoogle with sustained discount + 375gig ssd: $490.93/mo\n\nAWS with 375gig ssd 1yr all up front reserved: $434/mo + Billing support\n\nAWS with 375gig ssd 1yr no up front reserved:  $512/mo + Billing support\n\nAWS with 375gig ssd on demand: $701/mo\n\nBut the AWS requires at least $100/mo to enable billing support and reserved instances. If you have a lot of servers that's not an issue. \n\nIn our organization we don't have the discipline to have everything inventoried and cataloged, so a majority are running as on-demand servers on AWS. Being messy, we'd benefit from google cloud.", "id": "da67gos"}, {"comment": "If you know you always have n number of a certain ec2 type running.. you can just reserve, it's not tied to a specific machine.", "id": "da69b89"}, {"comment": "Sure, or you'd benefit from not being messy. :P", "id": "da67kth"}, {"comment": "How2do tell everyone at corporate to clean their room?", "id": "da67m6b"}, {"comment": "Well, the easy simple start is to look up all on demand instances older than ten months and just go purchase reservations for them.\n\nBut, yeah, it's kind of hard to make your organization regard costs as important if they don't regard costs as important...", "id": "da67ol0"}, {"comment": "Good idea", "id": "da67qq3"}, {"comment": "If you really want to dig into it, see if you can get a list of all past on-demand instances and how long they were use for.\n\nUsing that, work out how long into an on-demand instance's life you have to wait before it is cheaper on average to just switch to a reserved instance.\n\nWorking out that value from historic usage should at least put you in the neighborhood of the lowest cost, at the very least it's a good time to ask the owner whether or not there is a planned shutdown date for the instance.\n", "id": "da6dacf"}, {"comment": "\"Guys, there was an issue with the AWS and some of the instances were stopped. Please give us a shout if this has affected your instances and we'll get them running pronto.\"", "id": "da6pcx0"}, {"comment": "[deleted]", "id": "da6pzpj"}, {"comment": "Make sure that people up the chain know you're doing it. I doubt that the high-ups would complain that you saved them ~30% in AWS bills because you have a shitty dev team.", "id": "da6q4lv"}, {"comment": "Make sure they know it was Amazon, not you, of course!\n\n(there is the technical small print that cloud instances can disappear at any moment without notice. Most people assume they will be there forever, and indeed, there are EC2 instances with uptime in years, but that's just... painfully, pitifully stupid. I eye any instance with uptime of more than a month as a maintenance ticket outstanding, any instance older than 3 months as an image rebuild ticket)", "id": "da6sncx"}, {"comment": "A remember reading a blog post by some startup that post all their data by using only RAM disks with no backup on one availability zone, when that zone died.\n\nThey actually thought that this was a valuable learning experience and that there was no way for them to have been aware of this in advance.\n\nIIRC they also thought that it was up to customers who couldn't get their orders (as they had no record of any orders past of present) to issue a charge back themselves and reorder, rather than make any effort to something about it.\n\nI'm always amazed at how clueless some devs can be at times.", "id": "da6zobm"}, {"comment": "Trusted Advisor would help.", "id": "da6prsq"}, {"comment": "Us too, the idea of reserved instances is imo defeating a fundamental principal of cloud computing, and that's elasticity. It should always be pay for what you use at a constant rate, then you can build software that scales predictably along with costs. DynamoDB is a great example, you have to reserve iops, so therefore you are already building a system you know cannot auto scale. ", "id": "da6d3rg"}, {"comment": "You can treat the non-discounted prices as this rate, and then any discounts for eg. reserved instances are just a bonus.", "id": "da6du4y"}, {"comment": "You can, but in that case you might as well move to Google :)", "id": "da6ph54"}, {"comment": "Google SSD is much faster than AWS GP SSD. To get comparable performance, you gotta use AWS provisioned IOPS, which cost an arm and a leg.", "id": "da6tu54"}, {"comment": "Here's a quick comparison of the price of SSD storage in the various cloud providers http://i.imgur.com/G7xYwHZ.png\n\nGoogle seems to be the most reasonable for the performance. Amazon can be cheaper but the IOPs get pretty low. All of them seem to be highway bloody ass rape compared to buying an SSD.", "id": "da7mwfd"}, {"comment": "I also doubt he's ever actually dealt with real infrastructure on both because AWS has a lot of practical solutions and support systems for stuff like user control, physical direct lines to aws, the ability to physically send or receive data from aws on storage appliances that encrypt and protect the data during transit, etc, based on their experience that google doesn't offer yet. AWS is 100% ready and heavily battle tested for the vast majority of needs.\nSounds like he just wanted to write an article about how great google is without weighing pros and cons.", "id": "da6dksa"}, {"comment": "To be fair. He's comparing monthly, not yearly prices, so if you need anything under a year, google is always going to be cheaper.", "id": "da6pedu"}, {"comment": "Which is nowhere in the title. Instead title comes off as sensationalist, possibly intentionally.", "id": "da6qz04"}, {"comment": "Granted.\n\nHowever, there are very few titles that are not intentionally sensationalist. Somehow it's perfectly fine to make your title sensationalist as long as either everyone agrees with your opinion, or you're clever enough to hide it well. \n\nNobody thinking of a title only thinks 'how can I make sure this represents the content of the article best?', without also thinking 'how can I make sure people read my shit'.\n\nI'm getting off track.", "id": "da6rfy3"}, {"comment": "Nobody, except serious scientific articles. But I got confused and though I was browsing /r/science where the only kind of articles allowed are non-opinionated articles. My mistake.", "id": "da6ske3"}, {"comment": "I also assume that they have not seen the 25% price cuts that AWS announced this past week...", "id": "da6kk0e"}, {"comment": "This is so true. ", "id": "da7748d"}], [{"comment": "https://thehftguy.files.wordpress.com/2016/11/aws-vs-gce-pricing-summary.png\n\n> \"moving average\" of something that isn't even a series, let alone a time series\n\n[\\*head explodes\\*](https://media.giphy.com/media/oaPcDncoLfgjK/giphy.gif)", "id": "da6d8ow"}, {"comment": "that moving average makes absolutely zero sense", "id": "da6kr0j"}, {"comment": "It's a wavy line, what more do you need?", "id": "da6lx89"}, {"comment": "i was looking for emotional affirmation of my frustrations with various services", "id": "da6okzi"}, {"comment": "Jesus. What.", "id": "da6jy3f"}, {"comment": "You're right, I'd much prefer to see this all in one pie chart", "id": "da6l17z"}, {"comment": "Just because excel has a button doesn't mean it goes on the graph.", "id": "da6qw5d"}, {"comment": "Moving average of what exactly? It starts higher than the Google value, but not enough to be an average of both. By the third column it's lower than any of the 6 bars shown? \n\nNot only is it a nonsensical thing to show, but it appears to have no relation with the data that there is.", "id": "da6mjf5"}, {"comment": "Might be a moving average of the Google prices? Not that that makes any sense either.", "id": "da6nrut"}, {"comment": "Even worse... it's not even \"correct\" as a moving average...\n\nLook how the \"average\" dips below the third and fourth bar, which are clearly the new minimum, so the average must be at or above it.", "id": "da6u7qt"}, {"comment": "It could be the average around a point rather than just to one side of it.", "id": "da6v099"}, {"comment": "Ah, good point.\n\n I usually work with physical systems, where it is hard to sample data from the future. :P", "id": "da7d904"}], [{"comment": "I have used Google Cloud, AWS, and Azure all EXTENSIVELY in many different services and never found Google Cloud to be cheaper than AWS for most service.\n\nHaving said that, AWS offers by far the widest breadth of services but there are things that both Google Cloud and Azure offer that make them far more suited for certain applications.\n\nI think for cloud services, they are all close enough in price that the choice should be centered around what and what is not offered.", "id": "da67vre"}, {"comment": "> Having said that, AWS offers by far the widest breadth of services\n\nExactly and how do you put a price tag on that?  ", "id": "da698w7"}, {"comment": "In my experience, it's easy.  Figure out how much extra dev time it costs you to deal with how poorly Amazon managed services scale then tack that into AWS pricing.  \ud83d\ude1d", "id": "da6hfqf"}, {"comment": "Hey, no argument there, some of those services are crummy.  Also, they suffer from the same problem that Google, Apple, Facebook, etc suffer from - they cannot embrace better services made by someone else.  Instead of just saying \"OK, GitHub owns cloud based source control\" and integrating like crazy with GitHub, they offer CodeCommit.\n\nNot saying CodeCommit isn't good but they could just partner with GitHub.  I don't know anyone who uses CodeCommit .", "id": "da6i6ee"}, {"comment": "You don't. You try to anticipate what your needs will be. It's entirely possible both services won't do everything you need, and so the real cost is figuring out what you need, then figuring out who to use to solve your problems will be much simpler after that. ", "id": "dab5dl8"}], [{"comment": "What did AWS do to this guy?", "id": "da6cyci"}, {"comment": "Not pay him to write ads for them.", "id": "da6ebq3"}, {"comment": "He tricked my adblocker! :(\n\n(Ok I am just kidding... I actually did not even read it, mostly because I don't care in the first place to see any ad but also because I don't think that this is in itself any good read at all other than waste of my time. Actually, reading and writing comments on reddit is a lot more fun than reading that blog entry!)", "id": "da9ay5b"}], [{"comment": "Another article from the same guy for the record: \n\nhttps://thehftguy.wordpress.com/2016/06/15/gce-vs-aws-in-2016-why-you-should-never-use-amazon/\n", "id": "da6c1q5"}, {"comment": "Jesus christ, I've never seen so much misinformation.  Has he never heard of the ever-so-slightly-legacy c3 and m3 instances, and the always popular r3 type, all of which have SSD instance stores?  His figures on bandwidth for instances are just flat out wrong -- I did actual benchmarks on C4 instances (2 cores) and they'll reliably put out 520 MBit a pop (at least within a region).  Most large instances will output [400-700 Mbps](http://stackoverflow.com/questions/18507405/ec2-instance-typess-exact-network-performance/35806587#35806587).\n\nDon't get me wrong, Amazon has definite flaws -- I tend to think of AWS as a basket of features poorly glued together into a product, with bad documentation and no real effort at user experience.  But darn it, there's a lot of really handy stuff in there once you know how to tie it all together, and they push burstability in a way that is extremely helpful for the common case (even without Lambda)... and I'll explain why.\n\n# AWS bursting\nFor example, a T2 instance with GP2 drive has burstable CPU, I/O, and (though it's never mentioned), network performance.  The credit-based model delivers predictable, trackable resource sharing.  For light use services, web apps, batch processing, and ESPECIALLY CI servers, they're amazing - and I think more flexible than the GCE equivalents, since you have 2 core options and high/low load versions.  Mixing some slightly overprovisioned t2.medium or t2.micro/GP2 instances in with a C4/M4 fleet (handling base load) also lets you seamlessly handle even fairly large traffic spikes without instance spin-up/spin-down hassles.  \n\nOne t2.medium instance fully charged up can increase its output on demand by a factor of 5 (0.2 cores baseline CPU  across 2 cores, bursting to 2 full cores) for up to 4+ hours.  Plus the way bursting works means that you're handling normal requests at sustained low load just as fast as if you had 2 full cores, but for half the price. \n\nJust like many AWS aspects though, if you don't understand the fine print, you can get screwed.  For example, you provision an important but low-load service on a pair of t2.micro instances behind an ELB for HA use, and forget about it.  Then one day you get calls because users are reporting major problems with your app availability, because demand has risen and you didn't bother to set up alarms or autoscaling.  The instances slowly depleted their pool of CPU credits and then couldn't keep up. ", "id": "da6p6ae"}, {"comment": "I remember this guy when his another article, Docker in Production: History of Failure, hit the front page. I had skimmed some of his articles at that time and my impression was he was either incompetent or it was a satire blog.", "id": "da70had"}], [{"comment": "The amount of extra labor put into the entire Google Cloud Platform more than offsets this. I'll never look back from switching to AWS.", "id": "da68lqp"}], [{"comment": "...I don't believe this. If this was true, then why isn't Google Cloud seeing massive growth? Azure is making headway, but AWS continues to dominate.\n\nFor me AWS wins on:-\n\n* UI (see Azure \"dashboard\")\n\n* Documentation (see out of date Azure documentation)\n\nBoth of those are really important to me. Try using the Azure dashboard and see how quickly you lose hair. Or try reading about how you add authentication to your mBaaS.  Or try managing your account in the Azure dashboard, oh wait. No you can't. You have to go to the old \"classic\" portal for that.", "id": "da68rbj"}, {"comment": "> I don't believe this. If this was true, then why isn't Google Cloud seeing massive growth? Azure is making headway, but AWS continues to dominate.\n\nI don't believe it either but your point isn't valid IMO.  A cheaper, better service isn't always guaranteed to beat out a competitor.  The world doesn't work that way.  Momentum, brand recognition, and many other factors come into play, not mention good old fashioned luck.", "id": "da69bff"}, {"comment": "Big business would save 50% any fucking day of the week on their cloud infrastructure.  They don't care about brand recognition, not that Google is lacking that...\n\nArticle is plain BS.", "id": "da6e879"}, {"comment": "I disagree, in the world of cloud computing, Google, Microsoft and everyone else are second fiddle to AWS.\n\nNot saying that that's good or bad, but Amazon owns \"the cloud\" right now.  They've owned it for a while.\n\nEDIT: that is what I mean by \"brand recognition\".", "id": "da6eicm"}, {"comment": "Not to mention, no \"big business\" that wants to stay that way migrates entirely to new infrastructure because it's the flavor of the week.", "id": "da6hjhz"}, {"comment": "Exactly, Amazon is the safe, trusted, conservative option to choose in Cloud Services.  Again, not saying it *should* be that way but that's the way it is, right now.", "id": "da6i87s"}, {"comment": "Amazon \"owns\" it because Amazon provide the best value and service for many. \n\nI've seen adverts for the '[Microsoft Cloud](https://www.youtube.com/watch?v=wmGQAGB-CyA)' on TV and online in the UK but none for AWS or Google Cloud.  Microsoft are really hitting at small businesses adopting Azure which could be a factor in its recent growth. ", "id": "da6fuub"}, {"comment": "I kinda disagree. I think choosing AWS is like the old \"no one was ever fired for buying IBM.\" AWS is the easy choice that doesn't have people ask questions. It gets a blanked pass. If you say that you should use GCE then people want to see the numbers. You say that it's cheaper, they want to see the proof. But you tell them AWS and you just get the thumbs up.", "id": "da6hij5"}, {"comment": "Good point, I'll agree with you there.  \n\nSpeaking of old computer taglines, I recently found this advert you might enjoy: https://www.youtube.com/watch?v=AGNGRU5g1aU.  It's got the new Microsoft logo...but it's straight out of 1995 ;)", "id": "da6hnpy"}, {"comment": "I'm leaning this way too -- though some of the extra services and options AWS has can be very helpful if they fit your needs.  That said, the quality is erratic and they're not always well thought-out. \n\nAWS has built something that sells well to management though, by having so many features checkboxes filled, even if the overall experience is of variable quality.", "id": "da6pd3a"}, {"comment": "> A cheaper, better service isn't always guaranteed to beat out a competitor. The world doesn't work that way.\n\nI disagree. **Prove** that a company will save 50% on cloud computing costs, then 90% of companies would move.\n\nThe only reason a move could not happen is if the company had not properly abstracted away the usage of that cloud computing platform.", "id": "da8fq9n"}, {"comment": "I too have noticed that azure has out of date documentation especially for its public APIs.  It's inexcusable, really.  It seems to be less of a problem for features that have been around a while, so this might just be a consequence of Microsoft not wanting to waste time writing documentation for a system that's still under constant flux, but I do wish they'd keep things more up to date. ", "id": "da6d3if"}, {"comment": "> It's inexcusable, really. \n\nIt is completely inexcusable. Another thing I really like about AWS is that their GitHub has a really cool team around. I've sent in a couple of PRs and they were accepted. I notified them about a small bug, and they had fixed it and published an updated library within 2 hours.\n\nMeanwhile the issue I reported for Azure is still open and somewhat ignored on GitHub for around two months now. It's not a great experience.", "id": "da8ftox"}, {"comment": " I like AWS and I like Google Cloud\n\n* EMR charges you for the instances AND the EMR services, google data proc just charges you for the instances\n* Google cloud charges at least 10 minutes and then by the milisecond. AWS rounds up to the nearest hour.\n* Google cloud has bigquery, if you use google analytics premium it can dump your logs. It works as a query-able data warehouse, enterprise can request unlimited queries at flat rate. Bigquery is not like redshift or another AWS equivalent.\n\nAWS has lots to love as well, but there's definitely a value offering on Google Cloud. The sad thing is that it's pretty hard to have the mental bandwidth at a company level to use both at once. Each has a learning curve to say the least.\n", "id": "da69qim"}, {"comment": "> EMR charges you for the instances AND the EMR services, google data proc just charges you for the instances\n> \n\nIs that new? I was using it last year and it was just the instances we were charged for.", "id": "da6dp9u"}, {"comment": "It's been like that since EMR launched", "id": "da6gsfq"}, {"comment": "Weird, the [pricing guide](https://aws.amazon.com/emr/pricing/) mentions nothings about an overhead fee - just paying for the instances. Base Hadoop and Spark should be free.", "id": "da6h5me"}, {"comment": "\"The Amazon EMR price is in addition to the Amazon EC2 price (the price for the underlying servers).\"\n\nThe prices listed there are inclusive of both the EMR costs and the underlying EC2 instances.", "id": "da6lxjq"}, {"comment": "Dataproc can be very compelling to EMR users:\n\n- Per-minute billing\n- Very fast bootup times (sub-90 sec, often in 30-45 seconds to cluster)\n- Custom VMs = set your own CPU/RAM\n- Preemptible VMs = 75% to 80% off\n- GCE<> GCS is very fast as well\n\nPoints 1 and 2 are especially important. When you have such high granularity of billing AND you get your cluster blazingly fast, you can rethink your workloads. \n\nInstead of \"standing up a cluster and filling it up with jobs and rounding up to the hour\", you simply start a cluster for every job, and discard it after every job - for ephemeral workloads. This is a very different model of thinking than EMR, and I think it's pretty compelling.", "id": "da78fxb"}, {"comment": "As someone who works on Azure, the feedback we get from customers is that they either really like the UI or hate it - the hate being focused on the horizontal scrolling. I think this will be addressed this year. It's usually one of the top concerns for customers.\n\nAnd yes, the Azure documentation is terrible. This is another top area of concern for customers. The Azure services are getting a lot better at it though, I think there has been a big overhaul the last couple months to improve all documentation. Definitely becoming a big area of focus moving forward.\n\nThe main problem I see for Azure going forward is competing with AWS on price. ", "id": "da6gsuh"}, {"comment": "I do not know exactly which part of Azure you work on. But here are my bug bears:-\n\n* Classic portal needs to be *properly* deprecated and *everything* needs to be migrated over to the new dashboard ASAP. It is not acceptable that some things are only available in the classic portal.\n\n* The UI is not functional. It is pretty, and lovely to look at it. But it does not do what is needed. I really do not care what it looks like, it needs to work and be functional. Forget the fancy styling, and smooth animations. Discovering new services is a horrible experience. I literally just want a simple list of what Azure offers. I don't want fancy shiny tiles. It detracts from what I need to do.\n\n* Documentation. Documentation. Documentation. I am currently using Azure for a personal project. Every service that I am using seems to have duplicate documentation. About six months apart. To actually get it working I have to take bits from both and try to make it work. Also, documentation discovery needs to be cleaned up. I have to use Google, because the main site just treats me like a noob.", "id": "da8g7zu"}, {"comment": "I work on the Azure Portal website - I like all your criticisms.\n\nThe deprecation of the classic portal has been pretty sloppy, the whole \"2 portals\" is terrible. But the good news is everything will be moved over and the classic portal will be properly deprecated really soon.\n\nThe UI is a designer's dream but an engineer's nightmare. It is the ultimate form vs function argument. It's definitely improved drastically over the last year and they are working on improvements every day. One great thing is that there are still tons of people working on improving this all the time so keep checking in on it and you will see it improve all the time. Sending in criticisms is also a great way to make progress - \"the squeaky wheels gets the grease.\"\n\nDocumentation has been hard because every service in Azure is basically it's own separate company. But I think there has been a huge push for every team to improve here asap, even for our own team. So hopefully this improves quickly. I've used Google as well and one thing I pointed out was how great the documentation and tutorials are - Azure definitely needs to learn this from Google.\n\nI'll see if I can forward your criticisms to the UI lead. Maybe they'll start listening to Reddit more.", "id": "da90byd"}, {"comment": "As somebody who uses both GCE and AWS extensively (around 500 instances across both as of right now) I can only say that the hell would have to freeze over before I'd even consider using Azure.\n\nOr anything that touches windows.\n\nReally. Stop trying to flog a dead horse into today. It's not going to work. And my first experience with Azure was a weekend hackaton sponsored by microsoft where the guy shelling out access credentials couldn't help himself but note that \"oh, our only datacenter is running at limit right now, if the instances go away something probably crashed again\".", "id": "da6ppdy"}, {"comment": "Never heard of a datacenter \"running at limit\" or why that would cause instances to just go away. I could see why a bad experience like that and not having a knowledgeable representative there to give any useful information or help with the problems would make you not want to use the product ever again.\n\nI don't know if this happened to you recently, but the product has changed drastically over the last year. The Azure support is also really responsive to problems noted by customers - even through twitter. \n\nIf you ever feel like trying it out again and experience any problems, definitely yell at Azure support on twitter or something and I guarantee that someone will be taking your criticism serious in order to improve the product or services.\n\n[Edit] Taking a guess about what the rep might've meant when he said the datacenter was \"running at limit\" - if they had everyone at the hackathon using the same azure subscription, there is a quota/limit for each subscription for the number of a specific products that can be created. This limit is typically really huge and usualy only a problem for big enterprise customers, but they usually just request a larger limit. If the reps putting on the hackathon weren't aware of this limit, maybe this could've been the problem.", "id": "da6rxom"}, {"comment": "It was quite a few years back when Azure was only just semi-public. The rep (it was quite senior guy, not a rep. Don't recall the name but it was VP level +) seemed to know what he is talking about. It was in London and the crowd were quite senior banking techs.\n\nWell, ether way. I'll trust you that Azure might have come leaps and bounds and is good and reliable and cost-effective and so on, but it still is a product from Redmond. Lessons learned from the past and all that. ;)", "id": "da6slsg"}, {"comment": "> ...I don't believe this. If this was true, then why isn't Google Cloud seeing massive growth?\n\nBecause both have made their pricing models as complex as they can. And people tend not to consider pricing as much -- there are cloud providers that cost 80% less than AWS for basic use cases.", "id": "da6ac45"}, {"comment": "its been a long time since i used AWS (1 year since i property gave it a good try) but I think the azure portal is fair easier to just get things up and running. \n\nits portal isn't great but i think the general layout is fairly easy. i feel like i have to go create 3 things from different menus in AWS which I would only know about by following tutorials. in  azure when you create a service if you need others (db, networking etc) it makes it fairly easy to do it within creating that first service.", "id": "da6b02d"}, {"comment": ">If this was true, then why isn't Google Cloud seeing massive growth\n\nAWS suits their business needs and transferring to Google Cloud isn't worth the time and effort? Also familiarity with AWS .", "id": "da6e3hg"}, {"comment": "50% bill cut. Dude, that's a pay rise for any head of IT pulling it. ", "id": "da6eijd"}, {"comment": "Yes but what of the manpower cost? My big expenditure is on staff.\n\nIt would save my company to move to Google sure, but the break-even point isn't even in this decade.\n\nAmazon would have to do something absolutely terrible for us to consider moving right now. And if I were starting a new company right now I'd probably still go with Amazon because it's what I know.", "id": "da6fygv"}, {"comment": "The businesses I know firsthand that have significant AWS bills (a few $1000 a month) typically expend ten times that amount in salary/contract work on their ops and dev/ops labor.\n\nPut another way, even a 50% saving on their hosting bill is going be roughly equivalent to a few days of one senior devops guy salary a month.\n\n", "id": "da6sw2v"}, {"comment": "Really?  The AWS UI is a selling point?  The thing is dreadful.  \n\nI agree the Azure interface is sadly even worse though (it feels like something built for an IT manager and not a user). \n\nGCE is definitely the winner here, with clear, high quality docs and an intuitive experience (less docs needed) -- definitely more usable than AWS in that regard, which has incredibly long, convoluted and confusing documentation and processes.\n\nAWS is winning because, well \"nobody got fired for choosing AWS\" (yet) and they have a really wide variety of services covering common uses.  Plus tons of integrations and tooling around them from third parties. ", "id": "da6pajj"}, {"comment": "> I agree the Azure interface is sadly even worse though (it feels like something built for an IT manager and not a user).\n\nI don't think so, I think they just went all in with the Windows 8 hub style and maybe a little of the old Xbox blades? ", "id": "da6pviw"}, {"comment": "> Really? The AWS UI is a selling point? The thing is dreadful.\n\nYes, for the simple reason that the Azure UI is atrocious. I used to think the AWS UI was horrible, but having experienced the Azure UI. I'll take the AWS UI any day.", "id": "da8fvp7"}, {"comment": "Heh, it's all relative I guess.  For my money, the general Azure ecosystem feels excessively overengineered / overcomplicated.  \n\nAWS has a bit of a feature bloat problem -- which I find more annoying than others because it limits discoverability, and requires context switching when an implementation crosses service boundaries due to each being a totally different animal.  But the core services (EC2, S3, ELB, VPC) are pretty straightforward to use on their own, especially via UI. \n\nThere's some line about the structure of software mimicking the organization, and it shows in cloud in a big way.", "id": "da8jacr"}], [{"comment": "I've been meeting with various cloud providers reps since 2007. I've been professionally involved with AWS, Azure and GC and also have used Openstack/Cloudify. I know for a fact that each major player has dedicated teams whose only job is competition analysis and, of course, it includes pricing. If you are with any major player and find that a competitor is offering a better price point for your needs, you just need to call and you will get what you want provided that you are comparing apples with apples. I simply cannot see AWS letting anyone, especially Google, undercut them so much.", "id": "da6n0ul"}, {"comment": "Call google? speak to an actual person? Is that possible? :)\n", "id": "da7g63w"}], [{"comment": "Who pays anything close to sticker price for AWS?", "id": "da6frxx"}], [{"comment": "Honestly all the cloud pricing is pretty similar. The only outlier is Azure for Windows type pricing as well as SQL because they own the technology stack and don't have to pay licensing fees for it.\n\nMy real problem with AWS is that I wind up spending more man-hours managing VMs (because basically that's AWS' entire service other than Lambda which has a *lot* of limitations) than I'd like. Their PaaS services thus far are kind of well... not great. And of course there are no on-premises equivalents so it's a total vendor lockin play.\n\nAt least on Azure if I want to do containers I don't have to manage a farm; I can run Kubernetes as a service. If I want SQL I get a real multi-tenant service that I can give developers a database for $5 a month; I can't do that on AWS for that cheap, even with Aurora -- it's not a multitenant service.\n\nI think Google has a good future and as other indicated the pricing is dishonest in this article, but it's not the pricing that will pay them this benefit, it's the PaaS services that they excel at. You can use AWS for VMs and scaling, and a few other ancillary services -- it does that well. But you can use GCE or Azure for that too. You don't get as much in terms of machine choice as you do with AWS, but the reality is... do you need it?\n\nI think the future is moving away from the way AWS is building its services and more to the way GCE/Azure are building theirs. Nobody wants to spend the operational overhead and build devops practices just to manage environments... they just want a service that works and provides them the ability to do more work on their product in less time.\n\nAWS doesn't really do that as well as Azure/GCE do. It's just going to take some time for people to stop thinking AWS is really that great and investigate other options. And by the way -- if you are complaining about the console, you aren't using it right. Everything should be done programmatically and the console is just there as a helper.\n\n*Source: Ran cloud program for a Fortune 100 company covering multiple cloud providers", "id": "da6k25q"}, {"comment": "Should add the other things AWS sucks at (without a lot of work on the developer/devops side) is allowing resource breakouts to specific customers or products. You can build a lot of tagging into your application to manage this, but the breakouts aren't pretty and then even destroying environments (because there is no container other than 'accounts') is really a pain in the ass. Cloudformation templates only cover the infra pieces, but as you start putting functions or big data then Cloudformation quickly becomes useless.\n\nAzure has this built in with resource groupings and RBAC, which is a nice plus. Not sure what GCE has since I've only used it as a credit card swipe to play with, but my guess it that it's pretty rudimentary.", "id": "da6k5jo"}], [{"comment": "The interface is awful on gCloud, though. I find its navigation highly non-intuitive. ", "id": "da6rsd0"}, {"comment": "I have found them the be other way around. You can group things into projects, access management seems easier to me, I can access all projects under my account. Everything moves much faster and smoother, things like creating, restarting and upgrading instances. Compute engines are thought so you have multiple users and different keys straight from the UI versus Ubuntu user on ec2. Cleaner interface versus the old master details style of aws. ", "id": "da6vte0"}], [{"comment": "Lying sack of shit article. t2.small is $0.017/hr. That's $12.24/30 days, versus $20+ the article quotes for Amazon and $15/mo they quote for Google. You can see the best Amazon prices [here](https://aws.amazon.com/ec2/pricing/reserved-instances/pricing/).", "id": "da6w3gj"}, {"comment": "Not quite...\n\n$0.017/hr is with a 1-year up-front RI (per the page you linked). It's actually $0.026 on-demand (and still, per-hour billing.. GCE is per-minute).\n\nThe article specifically talks about on-demand pricing for both, which is probably the best apples/apples comparison.\n\nI also think you gotta slow down on coffee a little :)", "id": "da7fwe6"}], [{"comment": "just find an IDC", "id": "da6ob75"}], [{"comment": "[deleted]", "id": "da6ssgg"}, {"comment": "> adverts\n\nI urge you to at least read the article. One of the sources he cites is specifically a [networking performance study](http://blog.zachbjornson.com/2015/12/29/cloud-storage-performance.html), where Google smokes Amazon, so your comment is at least 50% not accurate :)\n\n", "id": "da7g6au"}], [{"comment": "I wonder where azure stacks up?\n\nI use azure for a few VM's but Microsoft gives us $6000 a year in free azure service's for 5 years for being a startup, in 2 more years we will have to start paying but its a pretty great deal right now.", "id": "da6zdc2"}], [{"comment": "As someone with experience in guiding tech startups i can tell that both are more or less equal in pricing. \nBut i find them both very very expensive for smaller companies. \nWithout a big funding package you should not go for either of them.\nThere are plenty of cloud services out there which are cheaper and provide enough reliability. \nI have seen an example where the monthly cost of a GC setup was around 10k versus $700 on a different cloud provider. No real concessions had to be made. Similar structure, similar performance. Reliability maybe not, but thats acceptable in many situations. ", "id": "da7g3ug"}], [{"comment": "Damn - my adblocker did not block that ad!", "id": "da9aww2"}], [{"comment": "Just use Azure.", "id": "da6k4dg"}]]], "4daew9": ["Why I won't do your coding test", "2016-04-04 13:54:38", 94, "http://www.developingandstuff.com/2015/05/why-i-wont-do-your-coding-test.html", [[165, "omg working with this guy must be awful."], [127, "OP's \"numerous repositories on GitHub\" could be copy-pasted. Anyone in the universe can write a blog, that doesn't mean they know anything about practical coding. Many projects involve other developers, so linking to them isn't enough. A coding test shows what one single developer can do.\n\nThe proposed alternatives either involve the candidate coming in to the office, or the company ... paying the person to interview (ellipses to highlight the boldness of this suggestion). The point of the coding test would be to make sure an in-person isn't a total waste of time.\n\nI find the arrogance of this article to be disturbing. There are people who would die for a job as cushy and well-paying as a software developer, but OP thinks that jobs are an ego fulfillment apparently. Take the coding test or don't, but stop whining about it. \n\nEDIT: I have a mortgage, a wife, and 2 children. My company closed in March, 2 weeks before my second child's due date. I took coding tests until I got another job. It wasn't personally offensive. "], [113, "I agree that for senior programmers, they make little sense once the company has access to your information.   However, I find them useful as a gatekeeper.  \n\nIn the past, I would publish a job ad, and the majority of responses would be recruiters and people from India who wanted my company to sponsor a Visa.  (Even when publishing the ad only locally)\n\nIn desperation, the last ad I placed did not have a contact email.  In order to figure out who to contact, the ad contained a simple programming puzzle.  (Doable in 10-15 minutes).  Solving the puzzle gave the applicant our email address.  \n\nI got a couple of people who emailed me just to say they had fun doing the puzzle even though they didn't want the job.  The rest were qualified applicants.  \n"], [105, "For a company it makes more sense to annoy a competent person with coding tests than to waste time on a person who can't code.\n\nThe company probably doesn't look to hire only people who have github repos and have blogs. Should they adjust their hiring practices just for you?\n\nMaybe, but if they don't its understandable, right?"], [95, "> I have a day job, and several side projects: I won't spend a sizable chunk of my free time so they can tick some boxes about my coding skills.\n\nYou say this, but then suggest:\n\n> Bring the candidate to the office for a day, and work together.\n\nDoesn't it seem that if free time is a concern, that you would rather do a one-hour coding test than spend a whole day on an interview? Me, I'm not going to work for free for a whole day. I'm not going to fix one of their bugs for free either. If they're a for-profit company, then I fully expect to be paid for my work."], [66, "\"I don't have time to do your coding challenge\" but \"I do have a full day to visit your office and program with you\""], [37, "> I know how to code, and can show it. They can check my... [apps](http://www.coverr.me/) and sites out there.\n\nIt's a fucking application error on that link. Whoever hires this guy is making a big mistake."], [32, "Why I won't hire you"], [27, "Self contradictions abound...\n\n> Bring the candidate to the office for a day  \n\nI thought you said you \"have a day job\" no? are you going to waste a vacation day for every possible employer?\n\n> I've already expressed interest in their position\n\nThis seems unrelated to the point of doing something in an \"ordered and timely manner.\" which is something you have not yet demonstrated.\n\n> Assign the candidate a real feature/bugfix to implement\n\nThat's only possible if your product build environment is trivial to set up, which is never the case. Also, I probably don't want to send my whole code base to every candidate and spend a week teaching them what they need to know in order to do the most basic thing. \n"], [25, "Coding tests are simpler to manage from the company's side. You get , what you regard as, a standardised measure of the applicant.\n\nWhile I agree with yours, and many others', suggestions, it adds a lot of overhead to the companies recruitment process. And many are not that eager to make a lengthy process even longer. Where they ask you to do a coding test, it probably means that they have not head-hunted you and there are other applicants. So you may not be willing to do their tests but someone else will be. "], [18, "The reason this dreaded \"coding test\" exists is to save time. A company can hand out the test and step away from the candidate and if the candidate fails to complete _no valuable time was lost_; however, if a candidate is brought in, knows nothing about the language and fails to learn from large code bases all the time spent pairing with another senior engineer is _wasted_. \n\nI also like the concept of a coding test to weed out attitudes. If you do not have enough humility to do a code challenge then your attitude probably doesn't work well with the team. If you think your time is too valuable to take part in the interview process for my company then I'll find a candidate more interested. The quality of engineers on the team is higher when the company includes a coding portion of their interview. I've worked a company that looked at \"code samples\" and the quality of engineers was much lower. \n\nOn that last point, the engineer who felt that coding tests were offensive and evil things promoted code samples and pointed to his \"genius\" code sample of some date manipulation in some XML language. It came out later in unrelated conversations that was the result of a team effort but he uses it to show off \"his\" coding abilities. So frankly I don't care what you _might have_ done on your own, I want to see what you _can_ do on your own. \n\ntl;dr your suggestions end up becoming larger time wastes than a code challenge. And other alternative don't always give you the read you think your getting. "], [17, "> My main gripe with coding tests is that they ask me for an investment of my time and resources so that they can gather information about me, but I'm getting nothing back.\n\nExcept for the opportunity for a job."], [16, "Why I won't hire you: you're so fucking full of yourself."], [14, "Dude says it's a waste of his time to do an hour test then turns around to suggest a whole day at the office.. Lol.. No just no way am I going to bother my whole team with candidates that obviously can't code after 10 minutes.\n\nSorry dude but you have no idea how to recruit and select candidates. If you got off your pedestal for 5 minutes you'd realise that your attitude of mr special snowflake that thinks he's better than everyone else enough to not need to test is exactly what no one wants to hire for. The fact that you'll never apply is a feature, not a bug."], [13, "Uh, the fully working app, uh, isn't. \n\n> Application Error\n\n> An error occurred in the application and your page could not be served. Please try again in a few moments.\n\n> If you are the application owner, check your logs for details."], [11, "1. Some companies are great tech companies but have terrible HR from the previous century.  (Tests are pretty common even for folks becoming a bank teller).  HR needs some common way to gauge folks that somehow got past their ATS (Applicant Tracking System).\n\n2.  For every good developer I've hired, I've had to interview probably 30-40 bad ones.  Ones that couldn't past FizzBuzz but have been (verifiably) a \"Java Architect\" at major companies for the past 10 years.  Our industry has terribly bad imposter syndrome.  Where folks with degrees in Humanities are now software architects after taking a 6 week code camp.  There aren't too many industries where you can make 6 figures regardless of your education or experience.  If you invited every one of these on site for a day of coding, you'll end up wasting months of time just because they have blogs or GitHub profiles.\n\n3.  Maybe 1% of the developer community has blogs or do open source software.  Just because you don't have a blog or have a GitHub profile doesn't mean you're not a good coder.  Some of the best technical fellows at Google or Microsoft don't have blogs or GitHub profiles.\n\n4.  The author's blog doesn't even pull up and has an application runtime error.  No wonder that company sent that guy a coding test...\n\n"], [11, "[deleted]"], [8, "I've interviewed multiple devs with 5+ years of experience that were completely clueless on how to solve a problem unless you basically hand-held them through the algorithm.\n\nCoding, they could do fine.\n\nSo yeah, a toy problem is still relevant for senior programmers. I'm not looking for code monkeys."], [7, "I was asked to interview/test a kid like this a couple of years back for your basic LAMP-monkey slot. His \"portfolio\" was a pair of shitty HTML5 games... made in GameMaker. \n\nWhen the then-boss asked him to mock up something little and silly (I think it was a single-table address book), just to demonstrate something resembling \"passing familiarity,\" he got all huffy and proclaimed indignantly that he 'didn't work for free,' but he'd look forward to hearing back from us when we decided to get serious. \n\nHe wasn't even out the office door before I took his \"resume\" from the boss and round filed it. "], [8, "I would hate to work with this guy. He just reeks of that sole dev who goes off on his own and causes havoc.\n\nThe test serves a multitude of purposes:-\n\n* Can you actually code?\n\n* Show casing problem solving ability\n\n* How you approach the solution\n\n* Whether or not the person is used to pairing etc.\n\nWe hold our coding test in the same environment as the devs, with the same hubble and banter going on in the background. This also lets us know how the person copes with distractions.\n"], [6, "I don't actually mind take-home coding tests. Much better than whiteboard coding and logic puzzles IMO."], [6, "> I won't spend a sizable chunk of my free time so they can tick some boxes about my coding skills.\n\nSounds good.\n\n> Bring the candidate to the office for a day, and work together.\n>\n> Pair program with people from your team for an hour or two.\n>\n> Assign the candidate a real feature/bugfix to implement from home, remunerated accordingly.\n\nUh..."], [7, "He's revealed a fourth purpose: ability to cooperate. I.e. if asked to do a trivial task that will take you no time at all, will you just do the task or go write a blog post complaining about how it's beneath you instead?"], [5, "I will do your test. I enjoy doing tests."], [6, "i'll do your programming test....IF YOU DO MINE\n\nyou see, it is still a candidate's market out there...and i want to know if the people i am hooking up with are actually competent or just childhood friends with the one person who can code....\n\nif you have over five years of experience in this market, you have opportunities. you should spend as much time grilling the company as they spend grilling you. only new grads should be exposed to fully one-sided interviews"], [5, ">  I have a day job, and several side projects: I won't spend a sizable chunk of my free time so they can tick some boxes about my coding skills.\n\nAlternatives he gives:\n\n> Bring the candidate to the office for a day\n\n> Pair program with people from your team for an hour or two\n\n> Assign the candidate a real feature/bugfix to implement from home, remunerated accordingly.\n\nOoooookay. So instead of a take home coding assignment (which can easily be an hour tops) you'd have to spend a lot more time. It's not just that in general your time is precious; it's often a lot easier to find time somewhere to do a quick online test than it is to spend hours / a day working on 'real' stuff. \n\nBy requiring a potential team member to put in a lot of time you're basically making sure you only get the ones desperate for a job. The money is meaningless to an experienced dev too; only the jobless ones care about an extra day's pay. For experienced devs the interview process is more about selling your company than it is about her/him selling her/his skills."], [5, "> They can check my blog ... and even my [fully-working apps](http://www.coverr.me/)\n\nIt amuses me that the fully-working app he links to [prints the following at the moment](http://i.imgur.com/t4kBR2b.png). \n> Application Error\nAn error occurred in the application and your page could not be served. Please try again in a few moments.\nIf you are the application owner, check your logs for details.\n\n;)"], [4, "I love coding tests, within reason. I just have a few simple requirements that I will push back on.\n\n1) I have a day job and a family life. If you want me to do a coding test for you please allow me adequate time. One week is sufficient in most cases but if my kids have sporting events all weekend then I may ask for two. Respect me as a human and provide me enough time to satisfy your requirements given the restraints on my time.\n\n2) If you are hiring a programmer to write REST API's, make the test a REST API, if you are hiring a programmer to write your integration points with someone else SOAP/REST API then expose an API and let me write some code to it. If you are hiring a front end developer who needs Angular/Bootstrap/JQuery then provide a test that uses these technologies.\n\nI don't want to write a recursive file seek when I am interviewing for Angular, I don't want to write an MVC webpage when I am being hired to write a Windows App. Lastly, I need enough time to research, request further clarifications, and write the project in my off time, while providing for and raising a family. "], [3, "Our company makes interviewees do coding tests to weed out schmoes who refuse to do coding tests."], [4, "It's ok. I'll take the coding test and collect the higher salary. It's not just about pride, or proving you can solve something (although that's part of it). It's really about getting to see the how you think through the problem, and showing that you can ask the right questions about the requirements if anything is unclear. It's then nice to walk through the result, seeing that you're able to follow a consistent coding style, and that you're able to explain why you made the decisions you did. Also, if you're too high and mighty to complete some small tasks, it says a lot about you. As awesome of a coder as you are, you're going to have a bunch of menial CR's throughout each year and you're going to have to complete them too."], [3, "Why I won't read your blogspam"], [2, "I interview people all the time, and I have seen people with very impressive resumes, that actually do not know much about programming. There's plenty who have listed 7+ years of full-time Java experience, yet when I ask what type erasure is, they have no idea what I'm talking about. \n\nThere is an obvious need to filter out candidates, as you recognize in the article as well, given the alternatives you propose. The one viable suggestion I did like was the bugfix + NDA, but even that is tricky. Having a candidate work on a feature on a non trivial codebase is asking a lot, especially in such a short window such as an interview day. You also need to  coincide with having a verified easy bug to be fixed at the time of the interview. \n\nI think a lot of coding tests are bad, (ex: implement quick sort on the spot), because all you are asking is if the candidate read Cracking the Coding Interview or not, but if you ask the candidate to program a lightweight program (idk, a command line checklist that you can add/remove/sort items from based on user input), you'll have a good chance to see how they program and separate concerns.\n\nTldr; coding tests are not inherently bad, although they can be.\n\nDouble tldr; shades of grey exist."], [4, "> My main gripe with coding tests is that they ask me for an investment of my time and resources so that they can gather information about me, but I'm getting nothing back\n\nOK."], [3, "I can understand the authors sentiment. Interviews can and should be as much for the candidate to make a decision as the hiring company. \n\nGood on the author! I also will not be treated as though some recruiting company is doing me a favor or be made to feel like I am just a cash cow for them. I got a call from a large IT staffing firm here and they acted as though I should be so lucky as to be placed by them. Um no, I have 15+ years of proven work history as a linux/unix admin. I don't need you, so get over yourself. \n\nTL;DR I'm picky about what kind of staffing/recruiting firms I'll deal with. "], [3, "Would love to know how many times he's actually said \"No, I won't do your coding test\".  I'm betting it's actually zero unless he was applying for jobs for fun..  When you need a job, find one you like and there are 100 other people applying, I'd love to see you say \"You know what? I like the job prospects, the pay is good, career prospects are great and the location is perfect but I'm not spending an hour of my time writing some code to prove to you I can write code..\"\n\nI hire developers and giving them a little problem to solve ahead of time separates the good ones from the time wasters (lots of people can get through tech questions in phone interviews based on info they've heard while they've been in good teams but can't actually code).  Your code on github may have taken you months to write when it should have taken days, maybe you wrote it alone, maybe you didn't.  Plus I'm not asking my team to waste an hour or two of their time pair programming with you so you can learn something when I'm recruiting for more developers because they're already stretched and stressed.  I can see why people who've never actually done any hiring may agree with the post and I partly agree with the sentiment, in later stages of a recruitment process, it is very suitable and definitely advised for the candidate to meet the team, do some pair coding, talk through problems and solutions, but you have to show me some code to prove you qualify for consuming some of my team's valuable time before I let you near them.  We're not hiring so you can get a free (or even paid!) hour of experience from us.  Imagine if I did that with all of the dozens of CVs I have to trawl through, phone interview, background check, reference check etc.\n\nAnd yes, there are a couple of other tests in there.  Did you appropriately question some vague details in the instructions to check you were taking the right approach?  Did you pick up on a bug in the instructions and either ask for correction or just assume you knew best?  Lots of things for me to check before I devote too much of my team's time to you.."], [3, "Link to \"fully-working apps\" is broken at least on Android. Lol"], [3, "I applied for a job - did their coding tests in the interview (about 45min to an hour of working together which was really good).\n\nthen they had a delay in the job being ready - so they offered me some contract work for money. No worries, knocked it up and did it got paid. Everyone was happy.\n\nThen the company emailed me again and asked me to do another programming test in my own time that will only take 3 hours.\n\nI declined. 3 hours, of my own time, when I had already proven my skills is not a company I want to work for.\n"], [3, "Anyone here ever been in a group project in school?  Remember that one guy who didn't do jack, but could talk well and claimed credit while contributing nothing or next to nothing?  It's that one guy that makes me happy when they ask for a (simplistic) test of your basic coding skills at interview.  I don't like the types who save up their toughest problem from the last year to spring on you to solve in an hour, but a solid FizzBuzz given as a mandatory test is one indicator that you at least will not be working with the really terrible 'that guy' people. \n\n"], [3, "I don't agree with this guy's stance at all. Phone screens in CS are absolutely terrible and awkward, and I hope the trend of giving them goes away soon, so I'm happy to do a take home project instead. It gives me flexibility on when I can complete the task, and more importantly it simulates a real development environment where developers generally have a couple weeks to complete some tasks on a sprint board as opposed to trying to cram a bunch of code into an awkward 45 minute phone call. That said, there are good take home exercises and bad take home exercises. Stuff like \"implement some function that computes some sum using an array\" is a dumb take home exercise, while problems like \"implement an algorithm that figures out the best route from A -> B -> C while avoiding various obstacles\" is much more interesting and useful. I just got the latter at a transportation company similar to Uber and I know for sure, now that I work there, that they have a driver dispatching algorithm in production that is closely related to the algorithm they had me do as a take home exercise. Additionally, I disagree with his claim that doing a take home exercise provides **no** value for the interviewee because it definitely does: I really like when a company gives me a problem that their developers probably dealt with at some point because it gives me a glimpse into how their product works before I commit to an onsite interview.\n\nLastly, the author claims that companies can see he has relevant experience by looking at his GitHub and therefore no take home project or coding test is necessary, but it's possible that the code he has made public isn't relevant to the job being applied for. What I mean by this is that, for example, web app development experience is fairly useless for an embedded position, and vice versa. IMO, a senior dev should not only know simply \"how to code\" in general, but should also be more than well versed in the specific technology stack and problem space the company is working on, especially if the company is smaller and needs someone who can hit the ground running as opposed to waiting for someone to ramp up on unfamiliar tech."], [3, "Asking the candidate to write something executable in the interview, even something as well known as fizzbuzz tells you a lot about a programmer.  It even tells you something about senior rock star attitude fountains like the blogger here. "], [3, "> I get nothing in return \n\nUhh.. How about a job? You get nothing out of it if you fail. Stop being a prima donna. It's perfectly reasonable for someone to ask that you prove you can perform a job. A good restaurant would never hire a chef without bringing him in to cook something. "], [2, "Don\u2019t see how the listed \u201cAlternatives\u201d avoid the conflict with the Day Job issue in problem number 2. "], [2, "The problem with tests as a \"filter\" is that they can hurt companies because, in my opinion, they are evaluating the wrong set of cognitive skills.\n\nThe most important features to check when a company is looking for a new developer are: he is not a jerk who will destroy the office environment with his toxic necessity to humiliate other developers in order to prove how smart he is, he has an \"architectural\" mind that embrace several technologies and he has a sense of simplicity when he is re-factoring code. \n\nBut the last two features require a \"landing\" of the semantics in the modeling, and by definition that will pass only after some weeks working and \"chewing\" the processes that the code tries to implement. Even when they are taking a shower or walking the dog they are thinking about that \"ugly\" class or how mocking the test in the right way.\n\nMany times that kind of developers ended making the difference between a failed and a successful company because in the long run they keep the technical debt low, and many of those developers totally will fail doing the FizzBuzz kind of tests in an interview. \n\nIf you run marathons your time running 100 meters won't be impressive, but the job is to run marathons.\n\n\n\n\n    "], [2, "For junior roles coding tests are essential. For experienced coders their history speaks volume and it's a bit of a waste of time. There again juniors can be moulded into what you need. You only find out an experienced dev is a raging lunatic after they've been on your team for a few months and is causing mayhem. With experienced devs the later is the most likely bad hire and what you are trying to protect against."], [2, "I had one prospective employer/customer (forget which) who wanted me to do 8 hours worth of work to \"evaluate\" me. Um sure, that \"evaluation\" will cost you a few hundred bucks. TY."], [2, "I've spent about 24 hours in total doing programming tests and got flown out to 3 companies afterwards. For one job, programming wasn't even part of the position, they provided that and an \"iq\" test upon arrival (I probably got a 99). Another test was really fun, create a finance based program for them- I failed the algorithms part of the interview since I'm a structural engineer by education. The last interview I miserably failed the background test since I couldn't adequately prove what I was doing overseas. All of the positions were $82-110k entry level positions. It was a lot of fun and I learned a lot. I'd recommend the experience for entry level graduates.\n\nThe tests themselves were administered shittly in most cases by third party vendors (except for the Chicago project test). "], [2, "My last coding test experience was like this: A recruiter reached out to me via LinkedIn.  I arranged a call for the next day since it was Thanksgiving and I had the week off (vacation before holiday).  She calls me, we talk, and at the end she sends me the coding test.  It's due the next week.  Unfortunately, I cannot get to it until the night before it's due because of life.  I crack open the test to find several issues in the questions that make them difficult to answer.  For example, one question asks me to convert bases and display the result as a string in C/C++.  However, one of the numbers they use as input is negative and the resulting conversion is positive.  Even worse, the conversion is flat out wrong unless the output was prepended with \"-\" (this was a decimal to hex conversion).\n\nGiven that I only had an hour late at night there was no way I was going to get the answer before the due date.  There likely was no way I was going to get the answer anyways since I had gotten the test over Thanksgiving anyways.  So I documented the issue, stated that the conversion wasn't correct but that this matched the requested output, and said what the correct answer should be.\n\nThis happened on every question.\n\nWhich is why today I have two rules: don't ask me to do a coding test over the holidays and you must provide me a route for feedback on the test.  I don't care if I get the job or not but I want to know if I did things correctly."], [1, "My rule is 1 hour max on interview tests.\n\nCandidates have hostility to coding tests because many employers are abusing them.\n\nThe reason I've soured on coding tests and interview projects is the number of times I've done them, know I gave a correct answer, but I get no interview and no feedback.\n\nThere's also some shady people who try to get free consulting out of interview projects.  They take a task they actually need done and give it as an interview project.\n\nSome employers give a coding test to everyone who applies.  I give a valid solution, THEN they read my resume and decide they don't want to interview me.\n\nWhat was the point of getting a CS degree with honors if everyone is giving me a coding test before an interview?  Does your test measure more than the 4 years I spent on a degree?\n\nFor the automated computer-based coding tests (Brainbench, Hackerrank, Codility, etc), many employers will only give interviews to people who score in the top 5%-10%.  A poorly-written test can't distinguish between 95% and 70%.  So I do them, score 80th-90th percentile, then they conclude \"I'm not elite enough for them\" and no interview."]], [[{"comment": "omg working with this guy must be awful.", "id": "d1p7c84"}, {"comment": "The article has \"Expert Beginner\" written all over it. Write one successful for loop, and all of a sudden you are the master of the entire software industry.\n\nWhy is it that the best programmer's I've worked with tend to be really humble? ", "id": "d1p9bq3"}, {"comment": "The best programmers to work with can be really good programmers or simply average programmers at best, but if they have the right attitide, working together will always be more pleasant than working with a self-proclaimed jesus rockstar programmer with a shitty attitude. ", "id": "d1p9e3q"}, {"comment": "But you do not need to work with the super ninja programmer, because he can solve all the problems himself from the shadows.", "id": "d1pnni2"}, {"comment": "Heh...I wonder if he just failed a coding test actually.", "id": "d1pbmwb"}, {"comment": "I'm an expert coder, programming since childhood, with 30 years professional experience. I've failed many coding tests, because coding tests are unrealistic, stressful, and deprive us of the tools that we depend on when actually working (IDEs, google, etc).\n\nI don't claim to know the best way to interview people, but a series of toy white boarding problems simply favor the people who spend hundreds of hours practicing with the book Cracking The Coding Interview.\n\n(And, I am actually a humble person, bordering on imposter syndrome at times)", "id": "d1prh2g"}, {"comment": "That really, really depends on the purpose of the test. There's a wide spectrum of possible tests, so you can't really paint all coding tests with the same brush.\n\nIf you're an \"expert coder\" and can't find your way through FizzBuzz on a whiteboard, you're either not actually an expert or *so* sensitive to stress that you shouldn't be hired for that reason.\n\nThat said, unless you're being hired as an expert on binary trees anyone asking you to invert binary trees on a whiteboard is likely more interested in their own ego than proper candidate evaluation.", "id": "d1pt86i"}, {"comment": "Of course I can do a fizzbuzz. I could have written one in elementary school. And I can do it on a whiteboard.\n\nThe problem is when the challenges are complex, and that is where people like myself get brain freezes due to stress. In an actual work situation, if I forget some trivial thing, I would google it, or use code-completion in my IDE, and I would be unblocked. In an interview, I don't want to look stupid (\"How could he not know fact X?\")", "id": "d1q1hai"}, {"comment": "That's exactly what I want to see in a candidate though...do they fold in a pressure situation. Also are they still trying to solve the problem or do they freeze up and bash their head against the wall.\n\nIt also really depends on the job. I'm in a cushy fortune 50 job these days where social skills are more important than technical talent...when I still doing startups I needed raw talent that could handle hard timelines and intense pressure.\n\n", "id": "d1pus3p"}, {"comment": "I've had to code emergency server patches late at night, I've seen stress. In those situations, I have the support of my team (the ones who bother to stay late and help that is), and I have all the tools I normally use at my disposal.\n\nWhite boarding challenges are a different kind of stress, and entirely unrealistic. I do much better on tests where the interviewer told me to bring a laptop (or use a provided one), and then I was given an hour to solve a problem using any tools I wished (including google). And I solved some problems in which apparently few applicants could get a working solution in an hour.", "id": "d1q1oyt"}, {"comment": "I was interviewing years ago and had them all write out tree traversal on the whiteboard.\n\nThe man we ended up hiring didn't get the algorithm right, but I wasn't interested in that, I wanted to make sure he understood trees and recursion.  Our app was full of that sort of code and it's basic enough knowledge that I felt it was reasonable to test for (and I stand by that, even to this day).", "id": "d1pvbpu"}, {"comment": "Depending on what you need that's reasonable...the point of a coding test isn't necessarily to pass...it's to prove you can think your way through a problem.\n\nThe most painful memory I have of those is someone wanted me to write a multithreaded application in C. I told him I'd just use an existing library for that and go from there (and I'd more likely use C++). He wasn't happy with that answer due to him writing said library and was immensely proud of it. Me telling him his application was probably a waste of his company's money sealed that one as a failure. I learned that day that the interview is a two way conversation and there's no way in hell I'd work under that guy.", "id": "d1py7kp"}, {"comment": "> Why is it that the best programmer's I've worked with tend to be really humble?\n\nConfirmation bias most likely.  Good developers who aren't humble will also be annoying, the fact they're annoying makes you think of them more harshly \"yeah, he did <solve difficult problem>, but he also <made mistake we all make>, he's not so great\".  Where as humble developers will be forgiven their errors, so are perceived to be better than they are.", "id": "d1pfqib"}, {"comment": "Seems like an interesting hypothesis there. Makes me wonder if there is any research along those lines.", "id": "d1phywm"}, {"comment": "Yeah, there's some [here](https://www.reddit.com/r/programming/comments/4daew9/why_i_wont_do_your_coding_test/d1pfqib).", "id": "d1ple18"}, {"comment": ">Why is it that the best programmer's I've worked with tend to be really humble? \n\nOoh, ooh, over here!\n\nI'm humble, I'm humble!", "id": "d1pbk80"}, {"comment": "You are not very humble about being humble.", "id": "d1pe7f7"}, {"comment": "You don't even know! I am literally the most humble person on earth. My greatest attribute is probably even how great at being humble I am.", "id": "d1pey7x"}, {"comment": "I'm humbler than you!", "id": "d1pi451"}, {"comment": ">Why is it that the best programmer's I've worked with tend to be really humble?\n\nI think most of the best *people* are humble. Great trait to have. Attitude and personality are so important. \n", "id": "d1paw6l"}, {"comment": "I don't know, sometimes I feel like I'm *too humble*. You know what I mean? \\s", "id": "d1pb5dz"}, {"comment": "> Why is it that the best programmer's I've worked with tend to be really humble?\n\nBecause it's the difference between being a [scientist](https://www.cs.utexas.edu/~EWD/transcriptions/EWD03xx/EWD340.html) and being a code monkey. The more you learn the more you know how vast the entire CS space is. All you can hope to achieve is make an outward dent somewhere at the edge. ", "id": "d1pelsd"}, {"comment": "All I ever wanted to be a code monkey.\n\nNow I will soon have a PhD.\n\nDoes that make me a scientist?", "id": "d1pnpru"}, {"comment": "As a student, I can't express how hard it is to grapple with this concept. I am never sure whether I am woefully unprepared for graduation or if it's just the nature of the field that you always feel like there's an overwhelming amount of things still to learn. ", "id": "d1pniyx"}, {"comment": "Because the pompous \"Expert Beginners\" are desperately trying to mask their own ignorance and insecurity, while the humble programmer isn't bothered by being \"shamed\" by asking a \"stupid\" question, and ends up learning.", "id": "d1pglhl"}, {"comment": "Because the best programmers understand that they don't know nothing in the face of everything.", "id": "d1pi316"}, {"comment": "[Berkson's paradox](http://mathemathinking.blogspot.ca/2014/10/berksons-paradox.html)", "id": "d1p9yrk"}, {"comment": "written like someone who's never tried to hire anyone\n\ntl;dr:\n\n>me. **mememememe** also *me*. y yo. ", "id": "d1pa47g"}, {"comment": "I agree. While a coding test might be boring and dumb it can sure help weed out the people who SAY they know something but really don't. \n\nI don't care how senior the position is.\n\nTests are usually not fun, and there are probably better ways.....\n\n\nBut this guy is so full of himself. Jesus", "id": "d1pb8t5"}, {"comment": "And that is why nothing beats 15 to 30 minutes coding tests to filter out the useless and arrogant. ", "id": "d1q1xsv"}], [{"comment": "OP's \"numerous repositories on GitHub\" could be copy-pasted. Anyone in the universe can write a blog, that doesn't mean they know anything about practical coding. Many projects involve other developers, so linking to them isn't enough. A coding test shows what one single developer can do.\n\nThe proposed alternatives either involve the candidate coming in to the office, or the company ... paying the person to interview (ellipses to highlight the boldness of this suggestion). The point of the coding test would be to make sure an in-person isn't a total waste of time.\n\nI find the arrogance of this article to be disturbing. There are people who would die for a job as cushy and well-paying as a software developer, but OP thinks that jobs are an ego fulfillment apparently. Take the coding test or don't, but stop whining about it. \n\nEDIT: I have a mortgage, a wife, and 2 children. My company closed in March, 2 weeks before my second child's due date. I took coding tests until I got another job. It wasn't personally offensive. ", "id": "d1p719k"}, {"comment": "I've been on both sides of the coding test: giving it and taking it.\n\nThe number of people with great looking resumes that fail some pretty basic coding tests is huge. What's more costly is not asking the coding questions and not figuring that out until they're a month into their contract. I've seen this more with serial contractors than with people who have full time positions of 3+ years.\n\nI'm also usually concerned when I interview somewhere and they don't ask technical questions to figure out my level of proficiency. When I interview, I like to find the \"edge\" of their knowledge, where they become uncomfortable or outright start guessing. It also speaks to their character if they admit that they don't know something or just confidently make something completely wrong up.", "id": "d1pc98s"}, {"comment": "[deleted]", "id": "d1pjhd0"}, {"comment": "Contract can just mean \"employment contract\", it doesn't necessarily mean \"contractor\". ", "id": "d1plt98"}, {"comment": "Would you do it for 3x the pay? because that's about what the rate for contractors is at a good company.", "id": "d1pkxn5"}, {"comment": "$150/hr?", "id": "d1pkzfq"}, {"comment": "For me that would be $202/hour, about 2.5 times more than anyone has ever paid me to contract... I've yet to find those companies. They are probably the same people who allegedly pay $300K+ for COBOL programmers.", "id": "d1prrvj"}, {"comment": "I've billed that in the past. That's as a contractor though so there's no payroll deductions.", "id": "d1plfp4"}, {"comment": "> The number of people with great looking resumes that fail some pretty basic coding tests is huge.\n\nThat is truth right there!  I personally give simple coding tests with the expectation that they will get the problem but I just want to see their style.  \"char\" or \"uint8_t\"?  Things like that tell you a lot about their approach.  If they fail the test (which for me is just a simple copy data loop), well....that tells you a lot right there.", "id": "d1pl77v"}, {"comment": "*Waves in* noob here. Copy data loop?", "id": "d1pwz8f"}, {"comment": "I ask a C question. Write me a function that takes a source pointer, destination pointer and a length. The object is to copy the data from the source to destination for the given length. You aren't allowed to call any functions. Go. \n\n\nNote there is a lot of open ended parts of the question. I expect the candidate to ask about them. Most will write a simple for loop and then we discuss lots of things about it. Pointer or array arithmetic? How are they different? Which one is faster? Did you check your arguments? What data types did you pick and why? How do you speed it up? What makes sense for a return value? I can do down routes such as compiler and architecture optimization, DMA usage and many avenues depending on where the candidate can and does go. The possibilities are pretty large for a simple memcpy clone. If they show weakness in pointers I will see how bad it is. High level guys don't know about registers so I go there to see if they get the concept, ect. It's all about seeing how much someone knows about architecture agnostic stuff, their thought process and discovering a weakness. The best candidates and I can talk about this simple 5 line function and its implications for hours. ", "id": "d1q1wdy"}, {"comment": "The first two solutions he proposes are IMO much worse than passing a test.\n\n_Work together with a company team for a day? Pair programming?_\n\nWhat the hell would I be doing with a project I do not know, with tools I do not know, with a workflow I do not know, except annoying the current employees who have a real work to produce? I mean, how long does it generally takes for you, when you start a new job, to get moderately productive? A few days if it is easy and mostly familiar, a few weeks otherwise. Heck, just setting up one's work environment in a barely sufficient way to get things done often takes a day or two.\n\nYou can see how an outsider fits in an existing team in a few hours? You're a genius. My first relations with people are distant and awkward, and with time it evolves into something completely different. I guess it is more or less the same for everybody. The people you though were interesting the first day you met them turn out to be boring, or assholes; on the contrary you grow a good work relation with others whom you though were to be avoided.\nMost of the relation within the first days are fake, in a way. You don't know who you should trust, you don't don't know with whom you should remain formal, etc. Just imagine now that your behaviour is evaluated and your job depends on it! How fake will your interactions with other people become?!", "id": "d1phs23"}, {"comment": "I worked at a small startup that was once courting a developer, and the CEO invited him to work with us for a day, and it was an *awful* experience for both parties. It took him almost the entire day to get his environment set up (yes, we *should* have been using Vagrant or similar, but we weren't, so it was what it was), which involved periodic help from two developers, and then he left once he had his environment set up anyway (I don't think he really wanted the job to begin with, which makes the whole experience even worse). Even if he'd stayed a few hours, he probably wouldn't've gotten anything useful done (\"useful\" here being \"something we could use to estimate his abilities\").\n\nI don't think the author of this article understands how much work interviewing is for a company, especially if they're actively hiring and interviewing lots of people.", "id": "d1pj91t"}, {"comment": "Yeah, all the times I've started somewhere, it takes a day or so to get the environment set up, then another few days to get your head around how things fit together. This seems like a bad environment to show off your abilities. ", "id": "d1plxvt"}, {"comment": ">I mean, how long does it generally takes for you, when you start a new job, to get moderately productive? \n\nThe term here is \"Pair Programming\" (something I'm not actually fond of, but I digress...) The point is that the interviewee doesn't need to know the workflow, tools, etc, the partner will provide that.\n\n> You can see how an outsider fits in an existing team in a few hours? You're a genius. My first relations with people are distant and awkward, and with time it evolves into something completely different. I guess it is more or less the same for everybody. \n\nNo, it is not the same for everybody. I'm one of those \"distant, awkward\" guys, and it kills me in interviews. A full day to get to know someone would result in a much more positive impression on an interviewer, than the typical 30 minute chat. Standard interview format favors people who are good at socializing.", "id": "d1psdax"}, {"comment": "> I find the arrogance of this article to be disturbing\n\nSometimes you can afford to be arrogant. If I'm not hurting for a job and if find the idea of a code test insulting or offensive I would probably refuse them too", "id": "d1p9sgr"}, {"comment": "Just because you can afford to be arrogant, doesn't mean you should be arrogant.", "id": "d1pdmah"}, {"comment": "In this case you can be arrogant and politely decline, saving everyone  time and effort.", "id": "d1pvx3h"}, {"comment": "> My company closed in March, 2 weeks before my second child's due date\n\nYikes. That's kind of stress I'd reserve for my worst enemies. \n", "id": "d1pct3f"}], [{"comment": "I agree that for senior programmers, they make little sense once the company has access to your information.   However, I find them useful as a gatekeeper.  \n\nIn the past, I would publish a job ad, and the majority of responses would be recruiters and people from India who wanted my company to sponsor a Visa.  (Even when publishing the ad only locally)\n\nIn desperation, the last ad I placed did not have a contact email.  In order to figure out who to contact, the ad contained a simple programming puzzle.  (Doable in 10-15 minutes).  Solving the puzzle gave the applicant our email address.  \n\nI got a couple of people who emailed me just to say they had fun doing the puzzle even though they didn't want the job.  The rest were qualified applicants.  \n", "id": "d1p6j0e"}, {"comment": "What was the puzzle? Sounds interesting", "id": "d1p6sma"}, {"comment": "[I wrote it up a while back](http://geek-2-live.blogspot.com/2012/05/few-days-ago-i-read-article-on-hacker.html)", "id": "d1p6wm1"}, {"comment": "Very interesting approach to coding tests.", "id": "d1p843x"}, {"comment": "You may be interested to know that the mobile version of your site doesn't really work. Some of the code goes off the screen, but horizontal scroll is replaced with browsing through posts. I find this especially annoying as I absentmindedly drag my finger around the screen while reading, and leaving the page unexpectedly is not fun.\n\nThanks for sharing the post though, it was interesting.", "id": "d1poc49"}, {"comment": "Didnt work on the desktop either :P", "id": "d1qfsal"}, {"comment": "Having the .com part of the email address is a big giveaway.\nI didn't look at anything other than the comment text that told me it was a Caesar cipher, but I guessed that the email address would be a .com, counted the letters between c and p, then guessed that the key.", "id": "d1paz0s"}, {"comment": "If you've spent enough time in the wrong sorts of places [ROT13](https://en.wikipedia.org/wiki/ROT13) is familiar enough that pbz <=> com is a known substitution, and you know sheesh <=> furrfu (which tells you that the mail address begins hr@ - another clue that ROT13 is the right idea).\n\nThus, it's a really, really weak test (which kinda fits the goal) - it's *just* hard enough to stop a scraper bot or a non-technical \"recruitment consultant\", without blocking anyone who could reasonably do the job.", "id": "d1pc7i3"}, {"comment": "`g??` in vim to decode the email.", "id": "d1puvtw"}, {"comment": "Cool :)  It wasn't meant to be a Mensa entrance exam.  Just a bit of a gatekeeper.", "id": "d1pb9za"}, {"comment": "the point of the challenge isn't to be hard, it's to be a roadblock to spammers", "id": "d1q2fl4"}, {"comment": "Was fun. World definitely needs more of this", "id": "d1p8hdf"}, {"comment": "My favorite: https://challenge.synacor.com/ (Warning, getting to the final code may take a few days.)", "id": "d1pcj7p"}, {"comment": "Ooh, this is cool. It'll probably take me more than a few days, I've never written virtual machines or the like before. It's going to be fun.\n\nEdit: Though I'm not sure if it's going to be half as hard as I imagine it would when I first read it. I just have to implement the OpCodes, have some area for storage and basically just run through the file parsing it through my OpCode functions, right? More complicated, but that's my initial first thought.", "id": "d1pfhi8"}, {"comment": "Yeah! Implementing a VM is pretty straightforward (for a programmer!) . This is the first step. I think you find the first code soon after being able to run the binary blob... and that's where the real fun begins. ;)", "id": "d1ph1l1"}, {"comment": "You get the first code just by downloading the challenge files.", "id": "d1q64pt"}, {"comment": "Synacor was a lot of fun if you like the idea of writing a VM. Once you get the program running, there are puzzles it presents that you have to solve.\n\nOne of the problems you run into requires going beyond a simple interpreter. That's where most people give up. You'll know it when you get to it. :)", "id": "d1q6br9"}, {"comment": "I don't even need to write a single line of code to figure this one out.", "id": "d1pbdyb"}, {"comment": "That website sucks on mobile. Can't read the challenge.", "id": "d1pdb7i"}, {"comment": "Not only does it suck, it's kind of impressivly bad. When I try to scroll horizontally to see the source code it navigates to the next blog post. Seems like they have overridden the default scroll behavior with \"navigate to next blog post\". I can't even.........", "id": "d1plnio"}, {"comment": "This is so cool! And great blog title. Now I am on the hunt for more puzzles. ", "id": "d1rml75"}, {"comment": "Bandcamp does something similar for their application contact address.  I did the same thing, figured the puzzle out just for fun, even though I had no interest in applying.", "id": "d1pajfl"}, {"comment": "Damn man I wish there were more people like you who take that approach to hiring for junior roles; that idea is quite clever!\n\nEDIT: I just took a look at the puzzle you provided in the other comment; unfortunately it was a bit too obvious that the Caesar cipher shifted 13 characters, as pretty much every website uses a *.com* domain. However, I guess the point of it is to find the solution using code anyway ;)", "id": "d1plyh2"}], [{"comment": "For a company it makes more sense to annoy a competent person with coding tests than to waste time on a person who can't code.\n\nThe company probably doesn't look to hire only people who have github repos and have blogs. Should they adjust their hiring practices just for you?\n\nMaybe, but if they don't its understandable, right?", "id": "d1p6luw"}, {"comment": "> The company probably doesn't look to hire only people who have github repos and have blogs.\n\nWell remember this. Fact is, a lot of companies are okay with going with a mediocre programmer over no programmer at all. We don't all have the luxury of being able to hire top-of-the-line senior programmers with years of experience under their belts, especially not locally. Sometimes - frequently, even, for junior positions - your pool of applicants simply doesn't have that kind of programmer in it, and that's all right, for some positions. If you think actually interviewing and having your skill tested in a situation like this is beneath you, well, by all means feel free to neither interview nor get hired.", "id": "d1p9t7v"}, {"comment": "I think a part a lot of people miss about programming tests in general, is that hey are more of a shit filter than a way to find \"leet ninja rock stars\".  This is important because the terrible programmers cause more harm than good, they can be a force multiplier of technical debt.", "id": "d1pbp0a"}, {"comment": "Seriously this. We use a programming test that's multiple choice and should take a competent person no more than 30 minutes to complete (if they really know their stuff they can finish in in 15 minutes, but we don't really care about how long they took on the test as long as it wasn't hours (which indicates they can't even google efficiently)). And why did we institute this? Because the number of people who flat out lie on their resume about their technical skills, thus draining the team's time with pointless interviews, is not trivial. The technical test is simply a way for us to filter out people who have no idea what they're doing by wasting as little of our time as possible.\n\nAnd if you're above taking 30 minutes out of your day to get a new job, we probably don't want to hire you anyway.", "id": "d1pdbc5"}, {"comment": "To be fair I don't know how many people lie vs over estimate their abilities, especially for fresh college grads.", "id": "d1pdzal"}, {"comment": "\"I see you have iOS listed under technical knowledge, can you tell me a little bit about your experience developing for the platform?\" \n\n\"Oh. I have an iPhone and I'm really familiar with the operating system\"\n\nThis was for an engineer position and the guy had a bachelors degree. ", "id": "d1pm63q"}, {"comment": "[deleted]", "id": "d1q0if3"}, {"comment": "> proficient in C/C++\n\nDidn't know what a pointer was.\n\n(Plus, mixing C and C++ as if they're the same language is a red flag to me anyways.)", "id": "d1q8t2j"}, {"comment": "Most of the people I'm referring to aren't fresh college grads. For them we have a completely different set of evaluation criteria (we'll still have them do the test just to see what they know, but we're not expecting much).", "id": "d1pedmf"}, {"comment": "Fair enough.  Sounds our companies are very similar in hiring practices.", "id": "d1pefi7"}, {"comment": "When I applied for the first job that didn't come via recommendation, they gave me fizz buzz to do. I expressed surprise that they'd bother, but they said that more people fail this than pass it. ", "id": "d1pm4ri"}, {"comment": "Great, I might want to interview there! Unfortunately, most companies aren't like that.\n\nThe \"coding tests\" many people complain about are far different. It includes 1+ hour screening problems, before they will even bring you in for the interview. I've had some take 5 hours (hello Yelp... not even an interview after wasting all that time)\n\nMost interviews I've had in the last 5 years involve solving several semi-hard toy problems on a whiteboard, 30 minutes for each one, while the interviewer looks on. There are stressful and unrealistic. What they actually measure is how many hours the candidate spent practicing problems from Cracking the Coding Interview.", "id": "d1psxvb"}, {"comment": "> our pool of applicants simply doesn't have that kind of programmer in it\n\nThe amount of shit programmers interviewing is much higher than the amount of really good ones.  Why?  Because really good ones will get hired faster with less interviews while crappy ones will likely have to interview a LOT more before someone hires them.", "id": "d1pcch3"}, {"comment": "> Fact is, a lot of companies are okay with going with a mediocre programmer over no programmer at all.\n\nExcept that's not the case here. We're talking same skill programmer just one has an attitude of elitism and doesn't think he needs to be tested. I.e. you don't wanna hire that guy in the first place.", "id": "d1pcn6n"}], [{"comment": "> I have a day job, and several side projects: I won't spend a sizable chunk of my free time so they can tick some boxes about my coding skills.\n\nYou say this, but then suggest:\n\n> Bring the candidate to the office for a day, and work together.\n\nDoesn't it seem that if free time is a concern, that you would rather do a one-hour coding test than spend a whole day on an interview? Me, I'm not going to work for free for a whole day. I'm not going to fix one of their bugs for free either. If they're a for-profit company, then I fully expect to be paid for my work.", "id": "d1p8ov0"}, {"comment": "I know the idea that developers should be paid for full-day interviews gets floated a lot, but I really wouldn't care about this. $300 or whatever they'd pay you is nothing to me. If I'm unemployed, it won't alleviate my stresses about finances and so forth. \n\nThe coding test works because I am either positively moving forward or the process is over within an hour. And when thinking about it like a sales pipeline where only x% converts from one stage to another (phone interview->in person->management interview, etc), I want to drop anything that won't later convert as quickly as possible. So if salary is too low or they're not comfortable with my skill level, I want that to kill it early and not after I make small talk for eight hours. Really seems, in the most practical sense, that the current \"coding test\" standard is pretty good for both parties.", "id": "d1pag05"}, {"comment": "> $300 or whatever they'd pay you is nothing to me.\n\nOne of the challenges is that, if anything you do is remotely useful to their business, then I think they need to pay you at least minimum wage. And then, since you would be essentially self-employed for that day, your taxes would potentially get much more complicated.", "id": "d1pvdrk"}, {"comment": "Most coding tests worth a damn are not 1 hour long. \n\nnote: I do not disagree with your point.", "id": "d1pdsuq"}, {"comment": "> Doesn't it seem that if free time is a concern, that you would rather do a one-hour coding test than spend a whole day on an interview? \n\nIt's not an either-or. Whether or not the company requires a coding test, they're still going to require you to come on site for an interview.", "id": "d1puop7"}], [{"comment": "\"I don't have time to do your coding challenge\" but \"I do have a full day to visit your office and program with you\"", "id": "d1p9h6x"}, {"comment": ">\"I don't have time to do your coding challenge\" but \"I do have a full day to visit your office and program with you\"\n\nWhat I understood was that he doesn't have time to do the test but he would make time to get to know the company and its employees because he believes that it's a better way of interviewing.\n", "id": "d1pi5t5"}, {"comment": "I was trying to think of it from the company's perspective. It's a lot of effort and time spent by me aswell to even for a day onboard someone to work on the software. ", "id": "d1ptmca"}, {"comment": "I guess you missed the part about getting paid. And, when you figure in 1+ screening phone calls, a optional screening tech problem (1-5 hours), the typical 3-5 hours of an on-site interview, plus driving time, then we are talking about a full days work (unpaid) in the typical interview.", "id": "d1ptaln"}, {"comment": "This makes sense, because coming into the office requires investment from both parties.  What if a hirer asks 30 people to do the challenge, and they all do it right and well? 29 people wasted their time.  \n\nDon't ask your applicants to invest more time than you are willing to, once you've screened them.  ", "id": "d1q4z9r"}], [{"comment": "> I know how to code, and can show it. They can check my... [apps](http://www.coverr.me/) and sites out there.\n\nIt's a fucking application error on that link. Whoever hires this guy is making a big mistake.", "id": "d1pahlc"}, {"comment": "Don't be an idiot. It's his side project and it's probably being bombarded as this article was shared in many places including HackerNews.\n\nYou think he would pay $500 or more to bump up hosting capacity for a day for a side project?\n\nI wouldn't, I'd just let the app croak under load until the world forgets about it tomorrow.", "id": "d1pkw4s"}, {"comment": "> You think he would pay $500 or more to bump up hosting capacity for a day for a side project?\n\nI dunno, even cheap servers are pretty powerful these days.  A well-configured $10/month server can handle [hundreds or even thousands](http://stackoverflow.com/questions/30893178/how-to-increase-the-request-per-second-on-amazon-ec2-t2-micro-instance) of concurrent dynamic requests per second.   My little, dinky t2.micro Jenkins server can throw down 100 RPS even on APIs that require expensive computation, and thousands on more trivial ones.", "id": "d1py3wd"}, {"comment": "the beautiful irony..", "id": "d1pdvd1"}], [{"comment": "Why I won't hire you", "id": "d1p9kcq"}], [{"comment": "Self contradictions abound...\n\n> Bring the candidate to the office for a day  \n\nI thought you said you \"have a day job\" no? are you going to waste a vacation day for every possible employer?\n\n> I've already expressed interest in their position\n\nThis seems unrelated to the point of doing something in an \"ordered and timely manner.\" which is something you have not yet demonstrated.\n\n> Assign the candidate a real feature/bugfix to implement\n\nThat's only possible if your product build environment is trivial to set up, which is never the case. Also, I probably don't want to send my whole code base to every candidate and spend a week teaching them what they need to know in order to do the most basic thing. \n", "id": "d1pblw9"}, {"comment": "Seriously. Getting used to the environment takes more than a day for anything non-trivial... ", "id": "d1pgs3s"}, {"comment": "I guess people here missed the part about getting paid for that day of work, and also that it would might pair programming (in which the partner of the intervewee would presumably provide a set-up machine and the knowledge of the environment)", "id": "d1ptiy9"}, {"comment": "Even still. You're not going to get any meaningful changes that aren't extremely well-defined or trivial in a day's work, especially if it's a framework they aren't familiar with.\n\nEven finding or crafting a problem to be sufficiently well-defined for a newbie to tackle in a day seems like it would be a fairly difficult task, moreso if you'd have to assign someone to that task to follow up (and/or finish anything leftover/vet the solution) afterwards.\n\nIf you're dealing with a large codebase (say, it's an interview for the Microsoft Excel team), I'm not sure even pair programming would get you all that far.", "id": "d1pwxp1"}, {"comment": "I was with him in the beginning, but it went WTF at the end.", "id": "d1poitu"}], [{"comment": "Coding tests are simpler to manage from the company's side. You get , what you regard as, a standardised measure of the applicant.\n\nWhile I agree with yours, and many others', suggestions, it adds a lot of overhead to the companies recruitment process. And many are not that eager to make a lengthy process even longer. Where they ask you to do a coding test, it probably means that they have not head-hunted you and there are other applicants. So you may not be willing to do their tests but someone else will be. ", "id": "d1p6af8"}, {"comment": "This is true.\n\nI have noticed that recruiters are red hot and then cold.\n\nFirst they are red hot.  \"We here at google want to bring you in.  You are the singular rock star that we need to go to the next level.\"\n\nThen they are ice cold.  \"We have decided to go with another candidate.\"\n\nIt actually makes sense.  Before they decided to go with another candidate they were busy selling themselves and an easy way to do that is to stroke your ego.  It costs them nothing to tell you that you are a rock star.\n\nBut if they have too many candidates, they need some way to winnow it down and a coding test is cheap.\n\nTrue \"rock stars\", \"ninjas\", and \"10X's\" are not asked to take coding tests.  If someone is telling you that you are a rock star and you should take a coding test, then you should not listen to them.", "id": "d1p6klj"}, {"comment": "I don't really agree with this... But I love the word winnow. Seriously one of my top 5 favorite words.", "id": "d1p78h9"}, {"comment": "> It actually makes sense. Before they decided to go with another candidate they were busy selling themselves and an easy way to do that is to stroke your ego. It costs them nothing to tell you that you are a rock star.\n> \n\nI once went to a \"rock star\" interview drunk (I didn't want the job). They were NOT impressed", "id": "d1pxx3q"}, {"comment": "By \"rock star\" interview, do you mean that their recruiter pumped you up as a \"rock star\".  Genuine rock stars can show up hours late, drunk, and still headline the show.", "id": "d1pzj29"}, {"comment": "I get that impression, too.", "id": "d1p6vu1"}, {"comment": "I feel like a good middleground would be to ask the FizzBuzz style questions, but not expect one definite answer. If I would ask somebody to do FizzBuzz in an interview I'd be much less interested in them writing perfect code on a whiteboard, but rather in their thought process in approaching the problem.", "id": "d1p7api"}, {"comment": "I think this is what the code test was meant to be initially. Others have just converted it to become a \"prove that you think the way that I do because I think that I am smart\" test.", "id": "d1p7j1z"}, {"comment": "I don't get (have) to sit in on many interviews, but I always though of it more as \"prove that you can think.\"  An applicant could not come up with a solution but still demonstrate an ability to reason through the problem, explain the proposed solution, debug the failing solution, etc.", "id": "d1pbcvf"}, {"comment": "> \"prove that you think the way that I do because I think that I am smart\"\n\nI finished one of these yesterday, the reasons for failing were hilarious. Apparently I wasn't doing TDD because the tests were committed at the same time as the code, not before.\n\nApparently I wasn't following OOD because many classes had very little behaviour. In reality I'd separated my behaviour and data.\n\nApparently I wasn't following OOD because too much logic was in $file. $file was a hundred lines long and contained half a dozen related classes.\n\nIt's the last time I'm going to bother with that company.", "id": "d1pwpva"}, {"comment": "And this is the downside (for a company) of a bad interview process, embodied in your last line; interviewing is a two-way process for any job where you don't simply need a warm body that'll put in a reasonable amount of labour in a day.\n\nIn this case, the company's interview process told you that they would nit-pick unimportant details because your working style wasn't the same as theirs - they're almost certain to be surprised when they can't recruit good developers, because the good devs come to exactly the same conclusion as you.", "id": "d1rw7w2"}, {"comment": "Copied and pasted from a comment I made a while back.\n\nI was working for a consultant company, but the clients still liked to interview newer consultants to make sure they weren't getting duped. While I hated the company, it led me to one of my favorite interviews.\n\nThe interviewer asked if I'd heard of FizzBuzz. I thought when I said yes he would ask something else, but he had me do it anyway. So I wrote the for loop. Initially I just had it in the 'main' method that was already created.\n\nThen he asked, \"Ok, what if we want to call this multiple times?\" So I made it into a method.\n\nThen, \"Ok, what if we wanted to be able to specify different numbers instead of 3 and 5?\" So I added parameters.\n\nThen, \"Ok, what if we wanted to call this from another controller?\" So I created it into it's own class (and specified that it would be a separate file, we were doing this on an online editor so he could see me type).\n\nAnd I think by doing that I was able to show that I understood the setup of a program/project beyond the concept of a for loop. I very much enjoyed that interview.", "id": "d1pew3m"}, {"comment": "That's actually a pretty good interview question.  You'll see whether the person is an engineer or a \"code monkey\" (I hate that term but I'm not coming up with a better term for someone who just wants to write code all day and isn't interested in solving non-coding problems other than maybe \"junior,\" but junior implies experience level and it's easy to find devs with 10 years of experience that can't think about problems other than from a coding perspective).", "id": "d1phh7h"}, {"comment": "Last time I was recruiting, we asked FizzBuzz style questions as a phone screen, using an etherpad-style shared text editor to let people show us their code as they wrote it.\n\nThe rules were simple; you had to use one of the programming languages we asked for in the job advert, and you had to ask for help any time you got stuck - we were watching, and would comment if you appeared completely stuck, or were going the wrong way. Beyond that, we gave you the problem (check a URL for sanity), and expected you to make progress towards a solution.\n\nAbout 3 in 4 candidates failed dramatically at this, which was scary given how little we demanded. For example, we'd have accepted:\n\n    main()\n    {\n        const char * url = \"https://url/\";\n        if(url[0] != h or f)\n    }\n\nas the beginning of a C solution to the problem, and helped you get over the issues with that code - in practice, people couldn't even get that far.", "id": "d1pduvm"}, {"comment": "I don't give nor take coding tests.  On the hiring side I don't think they really screen for anything more than the ability to take a coding test.  On the applicant side, it is an offensive waste of my time.  I want to talk to someone technical first to find out if we are good fit before spending a lot of time on the interview.", "id": "d1po0mx"}, {"comment": "While I'm sure it does add overhead to them, why is that my concern? They're the ones looking to attract people like us, we're not necessarily looking to work at that specific company.", "id": "d1pmq8s"}, {"comment": "It's not your concern at all. But it is there process and you are more than welcome not to partake in it.", "id": "d1qec0p"}], [{"comment": "The reason this dreaded \"coding test\" exists is to save time. A company can hand out the test and step away from the candidate and if the candidate fails to complete _no valuable time was lost_; however, if a candidate is brought in, knows nothing about the language and fails to learn from large code bases all the time spent pairing with another senior engineer is _wasted_. \n\nI also like the concept of a coding test to weed out attitudes. If you do not have enough humility to do a code challenge then your attitude probably doesn't work well with the team. If you think your time is too valuable to take part in the interview process for my company then I'll find a candidate more interested. The quality of engineers on the team is higher when the company includes a coding portion of their interview. I've worked a company that looked at \"code samples\" and the quality of engineers was much lower. \n\nOn that last point, the engineer who felt that coding tests were offensive and evil things promoted code samples and pointed to his \"genius\" code sample of some date manipulation in some XML language. It came out later in unrelated conversations that was the result of a team effort but he uses it to show off \"his\" coding abilities. So frankly I don't care what you _might have_ done on your own, I want to see what you _can_ do on your own. \n\ntl;dr your suggestions end up becoming larger time wastes than a code challenge. And other alternative don't always give you the read you think your getting. ", "id": "d1p92wx"}, {"comment": "We moved from bringing candidates into the office to doing basic coding over a phone screen using online coding portals.  The number of candidates that couldn't follow the simple email instructions to get to the website was very telling, let alone watching them code some basic stuff.\n\nWe weren't in a tech hotbed so when we bought people in we were usually on the hook for over a thousand dollars: Flights, hotels, meals, etc were all expensed to our company.\n\nEarly filtering was essential to save large amounts of both time and money. The worst feeling ever was getting into a room with a candidate with a great resume for a C++ job and couldn't even explain inheritance.", "id": "d1pcpo1"}, {"comment": "[This article](http://blog.codinghorror.com/getting-the-interview-phone-screen-right/) was the inspiration for the process I use when doing the initial phone screen and it's been great so far. I ask a super simple coding question (implement a fib function that returns the nth value) and let them use Wikipedia or another resource if they don't know the algorithm off the top of their head (which I, of course, do not expect them too). Then I follow up with asking them to convert from/to recursive/iterative depending on which they implemented first. This gives me a basic read on whether they can 1) Understand an algorithm, 2) Implement said algorithm in code, 3) transition from one thought process (i.e. recursion) to another (i.e. iteration). I don't feel any of this is taxing and it usually takes 15-20 minutes of the hour screen. The remaining questions I ask are problem solving or general computing knowledge questions (yes, I ask questions about binary and bitwise operations but I state up front I'm not expecting them to know this immediately but like them to take at least a guess at what's happening -- I do expect them to know what binary is and that it's a very crucial part of their job as an engineer to understand the day they're manipulating).\n\nSome of my opinions are different than other coworkers but everyone I've screened has been very pleasant to both screen and those that pass who have come in have not flunked any part of our onsite technical interviews so that's a bonus in favor of the screen. \n\nBut you hit a key point that I really liked:\n\n> we brought people in we were usually on the hook for over a thousand dollars: Flights, hotels, meals, etc were all expensed to our company.", "id": "d1pjgj8"}, {"comment": "I'm in embedded, so if they don't know how to mask the nth bit out of an 8 bit number we pretty much pass on them (especially when they list 5+ years embedded experience).", "id": "d1po4kn"}, {"comment": "> A company can hand out the test and step away from the candidate and if the candidate fails to complete no valuable time was lost\n\nI'm all for remote interactive technical screenings as early in the interview process as possible, but fire-and-forget homework assignments are something I strongly dislike. It promotes a massive disparity in investment between the company and prospect, and to me it shows a lack of respect for the prospect's time. Interviews are a two way street... the prospect needs to sell themself to the company, definitely, but the company also needs to sell itself to the prospect. Good developers aren't a captive audience, and companies can't just assume they'll do anything it asks because it has a position it's trying to fill.\n\nI'll gladly spend an hour or two with another developer showing that I know what I know, but if I get an boilerplate email telling me to create a WordPress clone using a specific set of tools before anyone at the company will talk to me then it's simply not worth it. I have plenty of other companies to talk to, and I know that they have skin in the game and aren't around to waste my time.", "id": "d1pf43u"}, {"comment": "I wasn't very clear, and that's my fault. But this applies to phone screens as well (which I've done a lot lately). Your handing off the assignment and then you're letting them take the lead to finish it. I wasn't being exclusive to emailed assignments from a company that you haven't spoken to yet. I think, at there very least, there should be a basic intro screen that you go through before anything tech related begins so you have the opportunity to learn about the company and the job you're going to fill. ", "id": "d1pj4e0"}, {"comment": "I may be hiring different types of people, but I prefer them block diagramming a system and to tell me about it.  While they are explaining the block diagram, I listen for \"We did this\" and \"I did this\" to determine just how much responsibility they had.   I also asked questions about how parts fit together, explain the interfaces,  how were sections synchronized, etc...  I feel like this does a good job of separating out individuals who are just good at math or syntax from those who know how to put together solutions.  It also relaxes people because it doesn't feel like a test with right and wrong answers.", "id": "d1ppc08"}, {"comment": "Oh, definitely! I was hoping to avoid making it sound like I was disagreeing with you, since I think we're actually on the same page, it's just that specific kind of assignment I have a problem with", "id": "d1pm8wp"}, {"comment": "> The reason this dreaded \"coding test\" exists is to save time. A company can hand out the test and step away from the candidate and if the candidate fails to complete no valuable time was lost; however, if a candidate is brought in, knows nothing about the language and fails to learn from large code bases all the time spent pairing with another senior engineer is wasted.\n\nExactly. It's a time saver on both sides as well. We have a non technical interview, then a code test and then a technical interview. For the technical interview, since we're a consulting company, we have to pull people away from the customer. So it literally costs us money. Which we're fine with of course as long as you're at least semi-competent. \n\nUnfortunately the idea of sitting behind a computer and making good money appeals to a lot of people lacking the skills (and making up with the ability to lie about them). We simply need the coding tests as a gateway for the rest of the process.", "id": "d1pf2i0"}], [{"comment": "> My main gripe with coding tests is that they ask me for an investment of my time and resources so that they can gather information about me, but I'm getting nothing back.\n\nExcept for the opportunity for a job.", "id": "d1par8b"}, {"comment": "It may or may not be worth the trouble. Fizzbuzz or similar are pretty quick to do no trouble but homeworks are.\n\nI once received by email after an interview that went well a homework that asked that I do a CRUD webapp for a car dealership to add and remove cars with an admin section. Bonus points for making it look nice. Bonus points for code coverage. Bonus points for an API. Bonus points for selenium testing. And so on and so forth.\n\nAnd they also wanted that I spend a day with them coding to see if I was a good fit!\n\nHad I known before the interview, I would have skipped. That was massively disrespectful of my time. I considered it a good warning against working there. Never replied and moved on.\n\nLinked in kept poking me about this job being available for people like me for a long time, I was not surprised it kept not being filled.\n\nHomeworks can be a great tool for companies but they need to tell in advance they do that *and offer financial compensation*. If the interview went great but the applicant completely flunked the homework, you saved a bundle.", "id": "d1pgsre"}, {"comment": "> but homeworks are.\n\nI was given a homework (unpaid of course) during an interview for a .NET position (which, do mind, is not my primary stack). Except for taking a peek at the template they gave me, I completely disregarded it, and yet they wanted to give me that job. I declined, mostly because I found something better in the meantime.\n\nI think they were really thin when it comes to competent candidates. I wonder if they found anyone.", "id": "d1pvf6c"}], [{"comment": "Why I won't hire you: you're so fucking full of yourself.", "id": "d1pb5i4"}], [{"comment": "Dude says it's a waste of his time to do an hour test then turns around to suggest a whole day at the office.. Lol.. No just no way am I going to bother my whole team with candidates that obviously can't code after 10 minutes.\n\nSorry dude but you have no idea how to recruit and select candidates. If you got off your pedestal for 5 minutes you'd realise that your attitude of mr special snowflake that thinks he's better than everyone else enough to not need to test is exactly what no one wants to hire for. The fact that you'll never apply is a feature, not a bug.", "id": "d1pc3dq"}], [{"comment": "Uh, the fully working app, uh, isn't. \n\n> Application Error\n\n> An error occurred in the application and your page could not be served. Please try again in a few moments.\n\n> If you are the application owner, check your logs for details.", "id": "d1pcpw0"}], [{"comment": "1. Some companies are great tech companies but have terrible HR from the previous century.  (Tests are pretty common even for folks becoming a bank teller).  HR needs some common way to gauge folks that somehow got past their ATS (Applicant Tracking System).\n\n2.  For every good developer I've hired, I've had to interview probably 30-40 bad ones.  Ones that couldn't past FizzBuzz but have been (verifiably) a \"Java Architect\" at major companies for the past 10 years.  Our industry has terribly bad imposter syndrome.  Where folks with degrees in Humanities are now software architects after taking a 6 week code camp.  There aren't too many industries where you can make 6 figures regardless of your education or experience.  If you invited every one of these on site for a day of coding, you'll end up wasting months of time just because they have blogs or GitHub profiles.\n\n3.  Maybe 1% of the developer community has blogs or do open source software.  Just because you don't have a blog or have a GitHub profile doesn't mean you're not a good coder.  Some of the best technical fellows at Google or Microsoft don't have blogs or GitHub profiles.\n\n4.  The author's blog doesn't even pull up and has an application runtime error.  No wonder that company sent that guy a coding test...\n\n", "id": "d1pkap3"}, {"comment": "> Our industry has terribly bad imposter syndrome. Where folks with degrees in Humanities are now software architects after taking a 6 week code camp.\n\nYou are describing the [Dunning-Kruger effect] (https://en.wikipedia.org/wiki/Dunning\u2013Kruger_effect)\n\nImpostor syndrome is the opposite.", "id": "d1ptvk8"}], [{"comment": "[deleted]", "id": "d1pbkhl"}, {"comment": "> i really dont care about the word list part. I just want to know if they realize they shouldnt trust user input, and sanitize it before putting it back on to a page. if i can put javascript into the text box and it executes, they dont get the job. It is easier for me to teach someone to code, than it is to teach them to be security conscious when coding.\n\nBefore you test it you should ask the applicant what kind of improvement they would make to it if it was meant for production. Interview coding is to make toys due to the time constraints and many usual restrictions can go out of the window.\n\nMaybe the test was to see if they would use unit tests or who knows what.\n\nOf course, it's best if the candidate asks for your assumptions before starting to code.", "id": "d1ph1s8"}, {"comment": "> I just want to know if they realize they shouldnt trust user input, and sanitize it before putting it back on to a page\n\nAs a candidate, this is the sort of thing that truly makes me scared:  The key criteria of the test is not called out in the spec of the test.\n\n>they dont get the job\n\nThis is the sort of reasoning that makes me dislike coding tests; when the test is a poor reflection of the real world.  The best places I've worked, they've had code reviews.  People point out what I've done wrong, or what I could improve, and I have an opportunity to learn from the mistakes and get better.  From your description, it sounds like you don't point out the problem and give them a second chance to write a better, more secure solution.  They're not given a chance to learn from the initial mistake.", "id": "d1pxrbi"}], [{"comment": "I've interviewed multiple devs with 5+ years of experience that were completely clueless on how to solve a problem unless you basically hand-held them through the algorithm.\n\nCoding, they could do fine.\n\nSo yeah, a toy problem is still relevant for senior programmers. I'm not looking for code monkeys.", "id": "d1pocqf"}, {"comment": "One interview question I ask regularly is about the worst bug/hardest problem they have ever had to deal with and how they went about solving it. Usually you can tell the serious programmers by the complete brain-melting awfulness of the problems they have seen. The programmers who *think* they are good have the nice, reproducible crashes that they found in half a day and were fixed by someone else.\n", "id": "d1q3l93"}], [{"comment": "I was asked to interview/test a kid like this a couple of years back for your basic LAMP-monkey slot. His \"portfolio\" was a pair of shitty HTML5 games... made in GameMaker. \n\nWhen the then-boss asked him to mock up something little and silly (I think it was a single-table address book), just to demonstrate something resembling \"passing familiarity,\" he got all huffy and proclaimed indignantly that he 'didn't work for free,' but he'd look forward to hearing back from us when we decided to get serious. \n\nHe wasn't even out the office door before I took his \"resume\" from the boss and round filed it. ", "id": "d1pcv0a"}], [{"comment": "I would hate to work with this guy. He just reeks of that sole dev who goes off on his own and causes havoc.\n\nThe test serves a multitude of purposes:-\n\n* Can you actually code?\n\n* Show casing problem solving ability\n\n* How you approach the solution\n\n* Whether or not the person is used to pairing etc.\n\nWe hold our coding test in the same environment as the devs, with the same hubble and banter going on in the background. This also lets us know how the person copes with distractions.\n", "id": "d1ple2r"}], [{"comment": "I don't actually mind take-home coding tests. Much better than whiteboard coding and logic puzzles IMO.", "id": "d1peuo6"}], [{"comment": "> I won't spend a sizable chunk of my free time so they can tick some boxes about my coding skills.\n\nSounds good.\n\n> Bring the candidate to the office for a day, and work together.\n>\n> Pair program with people from your team for an hour or two.\n>\n> Assign the candidate a real feature/bugfix to implement from home, remunerated accordingly.\n\nUh...", "id": "d1phya7"}], [{"comment": "He's revealed a fourth purpose: ability to cooperate. I.e. if asked to do a trivial task that will take you no time at all, will you just do the task or go write a blog post complaining about how it's beneath you instead?", "id": "d1pmvjl"}], [{"comment": "I will do your test. I enjoy doing tests.", "id": "d1pbxbx"}, {"comment": "I'm with you.  Coding is _fun_, that's why I got into this profession in the first place.  If most companies really wanted to weed out the \"serious\" candidates, they'd give them a \"sit in a dull meeting for an hour but pay close attention because you're going to have to talk at some point and it had better sound good when you do\" test.", "id": "d1pcw9k"}], [{"comment": "i'll do your programming test....IF YOU DO MINE\n\nyou see, it is still a candidate's market out there...and i want to know if the people i am hooking up with are actually competent or just childhood friends with the one person who can code....\n\nif you have over five years of experience in this market, you have opportunities. you should spend as much time grilling the company as they spend grilling you. only new grads should be exposed to fully one-sided interviews", "id": "d1pd9cu"}], [{"comment": ">  I have a day job, and several side projects: I won't spend a sizable chunk of my free time so they can tick some boxes about my coding skills.\n\nAlternatives he gives:\n\n> Bring the candidate to the office for a day\n\n> Pair program with people from your team for an hour or two\n\n> Assign the candidate a real feature/bugfix to implement from home, remunerated accordingly.\n\nOoooookay. So instead of a take home coding assignment (which can easily be an hour tops) you'd have to spend a lot more time. It's not just that in general your time is precious; it's often a lot easier to find time somewhere to do a quick online test than it is to spend hours / a day working on 'real' stuff. \n\nBy requiring a potential team member to put in a lot of time you're basically making sure you only get the ones desperate for a job. The money is meaningless to an experienced dev too; only the jobless ones care about an extra day's pay. For experienced devs the interview process is more about selling your company than it is about her/him selling her/his skills.", "id": "d1pee9f"}], [{"comment": "> They can check my blog ... and even my [fully-working apps](http://www.coverr.me/)\n\nIt amuses me that the fully-working app he links to [prints the following at the moment](http://i.imgur.com/t4kBR2b.png). \n> Application Error\nAn error occurred in the application and your page could not be served. Please try again in a few moments.\nIf you are the application owner, check your logs for details.\n\n;)", "id": "d1plnfa"}], [{"comment": "I love coding tests, within reason. I just have a few simple requirements that I will push back on.\n\n1) I have a day job and a family life. If you want me to do a coding test for you please allow me adequate time. One week is sufficient in most cases but if my kids have sporting events all weekend then I may ask for two. Respect me as a human and provide me enough time to satisfy your requirements given the restraints on my time.\n\n2) If you are hiring a programmer to write REST API's, make the test a REST API, if you are hiring a programmer to write your integration points with someone else SOAP/REST API then expose an API and let me write some code to it. If you are hiring a front end developer who needs Angular/Bootstrap/JQuery then provide a test that uses these technologies.\n\nI don't want to write a recursive file seek when I am interviewing for Angular, I don't want to write an MVC webpage when I am being hired to write a Windows App. Lastly, I need enough time to research, request further clarifications, and write the project in my off time, while providing for and raising a family. ", "id": "d1pe1f2"}], [{"comment": "Our company makes interviewees do coding tests to weed out schmoes who refuse to do coding tests.", "id": "d1qbdgi"}], [{"comment": "It's ok. I'll take the coding test and collect the higher salary. It's not just about pride, or proving you can solve something (although that's part of it). It's really about getting to see the how you think through the problem, and showing that you can ask the right questions about the requirements if anything is unclear. It's then nice to walk through the result, seeing that you're able to follow a consistent coding style, and that you're able to explain why you made the decisions you did. Also, if you're too high and mighty to complete some small tasks, it says a lot about you. As awesome of a coder as you are, you're going to have a bunch of menial CR's throughout each year and you're going to have to complete them too.", "id": "d1qbzz5"}], [{"comment": "Why I won't read your blogspam", "id": "d1qfmvv"}], [{"comment": "I interview people all the time, and I have seen people with very impressive resumes, that actually do not know much about programming. There's plenty who have listed 7+ years of full-time Java experience, yet when I ask what type erasure is, they have no idea what I'm talking about. \n\nThere is an obvious need to filter out candidates, as you recognize in the article as well, given the alternatives you propose. The one viable suggestion I did like was the bugfix + NDA, but even that is tricky. Having a candidate work on a feature on a non trivial codebase is asking a lot, especially in such a short window such as an interview day. You also need to  coincide with having a verified easy bug to be fixed at the time of the interview. \n\nI think a lot of coding tests are bad, (ex: implement quick sort on the spot), because all you are asking is if the candidate read Cracking the Coding Interview or not, but if you ask the candidate to program a lightweight program (idk, a command line checklist that you can add/remove/sort items from based on user input), you'll have a good chance to see how they program and separate concerns.\n\nTldr; coding tests are not inherently bad, although they can be.\n\nDouble tldr; shades of grey exist.", "id": "d1p87y5"}, {"comment": "> I interview people all the time, and I have seen people with very impressive resumes, that actually do not know much about programming. There's plenty who have listed 7+ years of full-time Java experience, yet when I ask what type erasure is, they have no idea what I'm talking about.\n\nOf course there are. Why would a working programmer know what type erasure is off the top of their head, unless they specifically work on compilers? This is exactly the kind of gotcha people are complaining about regarding interview processes. \"Ah yes, you have a strong educational background and experience, excellent references and a great portfolio. But quick, define eta-conversion!\"", "id": "d1p9hdh"}, {"comment": "If they've got 7 years of Java experience I would kind of expect them to know how generics work in the JVM, even if they don't use the exact words *type erasure* though", "id": "d1p9v0d"}, {"comment": "That's entirely subjective and a terrible metric.\n\nThink of it this way: Is knowing that particular fact in any way predictive of the candidate's performance at his potential position? Are you really saying he simply CAN'T do the job without that knowledge?\n\nAnyone can find ways to disqualify candidates and that makes for a terrible interviewer. The interviewer's job is to FIND effective candidates, not disqualify them.\n\nIf he has several confirmed projects under his belt and verifiable years of experience and you disqualify him for not knowing a concept that he could learn in under 30 seconds of googling, then you kind of failed spectacularly at your job as an interviewer.", "id": "d1pbccm"}, {"comment": "As /u/_____sh0rug0ru_____ points out though, this is a fairly fundamental concept in Java programming.\n\nIf you've been programming the language for a number of years and haven't heard of it, or found the benefits and limitations of how the JVM handles things then I'd wonder just what you've actually been programming.\n\nThe sole point of not knowing that one probably wouldn't disqualify the candidate, but it would at least give me a cue to find out more about what they had been doing that they hadn't come across it.", "id": "d1pdc4k"}, {"comment": "I agree with this. As a counter-point, we interviewed a guy for a python position a few months ago, who was ok, and he kept talking about parallel processing with python, and how he would solve problems with threading. At the end of our time, I started a conversation talking with him about issues with threading in python. It turns out he had never actually used threading in python, or heard of the multiprocessing or subprocess modules, etc, and had never even heard of the global interpreter lock. If you make it a point to talk about a concept, be prepared to back it up.", "id": "d1pk5hy"}, {"comment": "Maybe I'm being ignorant, but I can't imagine a single situation where knowing how the compiler handles generics makes any difference to the actual use of them, or how it could inform your programming at all.", "id": "d1pasal"}, {"comment": "Type erasure is more than a compiler implementation detail in Java.\nIt allows backwards compatibility with older libraries that use raw collections instead of generic collections. The difference between a raw collection and a generic collection exists only in the source code.\n\nSo, while type erasure has the upside of backwards compatibility, if you want to instantiate the generic type, you have to essentially pass a `Class<T>` instance and use reflection.\n\nContrast with .NET, which uses reified types for generic collections, where the object code is aware of the generic type bound. The \"raw\" collection library in .NET is actually different than the generic collection library, and cannot be used interchangeably.\n\nBut, while .NET loses out on backwards compatibility, you can do `new T()`.\n\nThus, type erasure and type reification have practical consequences.\n\nI wouldn't expect a junior to know all this, but a senior Java developer should definitely know this. In fact, I would also say that a senior Java developer should have passing knowledge of .NET, because having general industry knowledge better informs them about Java and better coding practices in general.", "id": "d1pbqt3"}, {"comment": "I would hope that after 7 years of working with a language full time, sometime would have the intellectual curiosity to do a little digging into how Java handles generics. Nevertheless, maybe type erasure is a bad example. What I meant to say is that people can have very impressive resumes, but still fail fizzbuzz type questions.", "id": "d1pa33r"}, {"comment": "Try to calibrate what you think of as fizzfuzz though. Obviously you were wrong on that one.\n\nPersonally, I think asking for things off the top of a candidate's head is pretty lousy. I've been programming professionally for 4 years and I would easily fail this test 90% of the time. I look stuff up a lot and memorize very little.\n\nYou could think I'm a bad programmer on a personal level, and that's fine. But if you want to be professional, you need to accept other people's methodologies and evaluate based on their results.\n\nMaybe you like to get very intimate with the inner workings of your preferred language. I think that's awesome, but if your candidate doesn't like that, that doesn't make him a bad programmer and is probably in no way indicative of his usefulness to your team. I jump around languages a lot and I've done tons of work effectively with very superficial knowledge.\n\nNot saying that's ideal in a perfect world, but if it works it works. That's what you should care about.", "id": "d1pb5x0"}, {"comment": "> Why would a working programmer know what type erasure is off the top of their head, unless they specifically work on compilers? \n\nType-erasure is a incredibly useful concept/idiom in no way limited to compiler writers.", "id": "d1pabem"}, {"comment": "Still doesn't answer the question \"why?\"", "id": "d1pblit"}, {"comment": "Backwards compatibility. \n\nA fair chunk of Java code is legacy, and was not written with generic collections. Your new code can benefit from the added type safety, but you can pass a generic collection to old code that only understands raw collections and the old code would be none the wiser. This argument applies not only to third-party libraries, but to existing codebases as well, since it allows you to migrate seamlessly to generics without major disruption.\n\nIn C#, which has reified types, a generic collection instance is different than a \"raw\" collection instance, so you have to convert a generic collection to a raw collection in order to use it with legacy code.", "id": "d1pchpt"}, {"comment": "The trick is sorting the people with Okay educational backgrounds, what looks like good experience on paper, Limited references, and no portfolio who can program from those who can't.\n\nGetting someone who applies with a strong education, great experience, references that mean anything, and has a published portfolio is rare.", "id": "d1pcv04"}, {"comment": "> Why would a working programmer know what type erasure is off \n> the top of their head, unless they specifically work on compilers?\n\nBecause otherwise, a *senior* Java developer would be putting in `@SuppressWarnings(\"rawtypes\")` or `@SuppressWarnings(\"unchecked\")` to address the boundary conditions that are the consequence of type erasure without having any idea of why they are doing it (other than, it shuts the compiler up).\n\nAlso, this *senior* Java developer would have no idea why some methods require a `Class<T>` argument or why they should need to include it in their own methods. \n\nThus, I would be very concerned about a *senior* developer who doesn't know what type erasure is, since the consequences are so obviously apparent to Java code.\n\n(actually, in an interview, if a Java developer told me he didn't know what type erasure was, I'd raise these points up and ask \"why?\").", "id": "d1pd2fd"}, {"comment": "What the actual fuck? Type erasure is significant for pretty much everything related to generics in Java, in a practical sense. If you have never heard that term, you have never extensively used Java's generics and then I can only assume you don't have 7 years of professional Java experience.", "id": "d1peigh"}], [{"comment": "> My main gripe with coding tests is that they ask me for an investment of my time and resources so that they can gather information about me, but I'm getting nothing back\n\nOK.", "id": "d1pbd1a"}], [{"comment": "I can understand the authors sentiment. Interviews can and should be as much for the candidate to make a decision as the hiring company. \n\nGood on the author! I also will not be treated as though some recruiting company is doing me a favor or be made to feel like I am just a cash cow for them. I got a call from a large IT staffing firm here and they acted as though I should be so lucky as to be placed by them. Um no, I have 15+ years of proven work history as a linux/unix admin. I don't need you, so get over yourself. \n\nTL;DR I'm picky about what kind of staffing/recruiting firms I'll deal with. ", "id": "d1pgk93"}], [{"comment": "Would love to know how many times he's actually said \"No, I won't do your coding test\".  I'm betting it's actually zero unless he was applying for jobs for fun..  When you need a job, find one you like and there are 100 other people applying, I'd love to see you say \"You know what? I like the job prospects, the pay is good, career prospects are great and the location is perfect but I'm not spending an hour of my time writing some code to prove to you I can write code..\"\n\nI hire developers and giving them a little problem to solve ahead of time separates the good ones from the time wasters (lots of people can get through tech questions in phone interviews based on info they've heard while they've been in good teams but can't actually code).  Your code on github may have taken you months to write when it should have taken days, maybe you wrote it alone, maybe you didn't.  Plus I'm not asking my team to waste an hour or two of their time pair programming with you so you can learn something when I'm recruiting for more developers because they're already stretched and stressed.  I can see why people who've never actually done any hiring may agree with the post and I partly agree with the sentiment, in later stages of a recruitment process, it is very suitable and definitely advised for the candidate to meet the team, do some pair coding, talk through problems and solutions, but you have to show me some code to prove you qualify for consuming some of my team's valuable time before I let you near them.  We're not hiring so you can get a free (or even paid!) hour of experience from us.  Imagine if I did that with all of the dozens of CVs I have to trawl through, phone interview, background check, reference check etc.\n\nAnd yes, there are a couple of other tests in there.  Did you appropriately question some vague details in the instructions to check you were taking the right approach?  Did you pick up on a bug in the instructions and either ask for correction or just assume you knew best?  Lots of things for me to check before I devote too much of my team's time to you..", "id": "d1pr5lp"}], [{"comment": "Link to \"fully-working apps\" is broken at least on Android. Lol", "id": "d1psvuk"}, {"comment": "Ouch. That's your job interview over right there. ", "id": "d1q18nf"}], [{"comment": "I applied for a job - did their coding tests in the interview (about 45min to an hour of working together which was really good).\n\nthen they had a delay in the job being ready - so they offered me some contract work for money. No worries, knocked it up and did it got paid. Everyone was happy.\n\nThen the company emailed me again and asked me to do another programming test in my own time that will only take 3 hours.\n\nI declined. 3 hours, of my own time, when I had already proven my skills is not a company I want to work for.\n", "id": "d1pybju"}], [{"comment": "Anyone here ever been in a group project in school?  Remember that one guy who didn't do jack, but could talk well and claimed credit while contributing nothing or next to nothing?  It's that one guy that makes me happy when they ask for a (simplistic) test of your basic coding skills at interview.  I don't like the types who save up their toughest problem from the last year to spring on you to solve in an hour, but a solid FizzBuzz given as a mandatory test is one indicator that you at least will not be working with the really terrible 'that guy' people. \n\n", "id": "d1q0hk2"}], [{"comment": "I don't agree with this guy's stance at all. Phone screens in CS are absolutely terrible and awkward, and I hope the trend of giving them goes away soon, so I'm happy to do a take home project instead. It gives me flexibility on when I can complete the task, and more importantly it simulates a real development environment where developers generally have a couple weeks to complete some tasks on a sprint board as opposed to trying to cram a bunch of code into an awkward 45 minute phone call. That said, there are good take home exercises and bad take home exercises. Stuff like \"implement some function that computes some sum using an array\" is a dumb take home exercise, while problems like \"implement an algorithm that figures out the best route from A -> B -> C while avoiding various obstacles\" is much more interesting and useful. I just got the latter at a transportation company similar to Uber and I know for sure, now that I work there, that they have a driver dispatching algorithm in production that is closely related to the algorithm they had me do as a take home exercise. Additionally, I disagree with his claim that doing a take home exercise provides **no** value for the interviewee because it definitely does: I really like when a company gives me a problem that their developers probably dealt with at some point because it gives me a glimpse into how their product works before I commit to an onsite interview.\n\nLastly, the author claims that companies can see he has relevant experience by looking at his GitHub and therefore no take home project or coding test is necessary, but it's possible that the code he has made public isn't relevant to the job being applied for. What I mean by this is that, for example, web app development experience is fairly useless for an embedded position, and vice versa. IMO, a senior dev should not only know simply \"how to code\" in general, but should also be more than well versed in the specific technology stack and problem space the company is working on, especially if the company is smaller and needs someone who can hit the ground running as opposed to waiting for someone to ramp up on unfamiliar tech.", "id": "d1q9j5s"}], [{"comment": "Asking the candidate to write something executable in the interview, even something as well known as fizzbuzz tells you a lot about a programmer.  It even tells you something about senior rock star attitude fountains like the blogger here. ", "id": "d1qb5eg"}], [{"comment": "> I get nothing in return \n\nUhh.. How about a job? You get nothing out of it if you fail. Stop being a prima donna. It's perfectly reasonable for someone to ask that you prove you can perform a job. A good restaurant would never hire a chef without bringing him in to cook something. ", "id": "d1qeeit"}], [{"comment": "Don\u2019t see how the listed \u201cAlternatives\u201d avoid the conflict with the Day Job issue in problem number 2. ", "id": "d1pdala"}], [{"comment": "The problem with tests as a \"filter\" is that they can hurt companies because, in my opinion, they are evaluating the wrong set of cognitive skills.\n\nThe most important features to check when a company is looking for a new developer are: he is not a jerk who will destroy the office environment with his toxic necessity to humiliate other developers in order to prove how smart he is, he has an \"architectural\" mind that embrace several technologies and he has a sense of simplicity when he is re-factoring code. \n\nBut the last two features require a \"landing\" of the semantics in the modeling, and by definition that will pass only after some weeks working and \"chewing\" the processes that the code tries to implement. Even when they are taking a shower or walking the dog they are thinking about that \"ugly\" class or how mocking the test in the right way.\n\nMany times that kind of developers ended making the difference between a failed and a successful company because in the long run they keep the technical debt low, and many of those developers totally will fail doing the FizzBuzz kind of tests in an interview. \n\nIf you run marathons your time running 100 meters won't be impressive, but the job is to run marathons.\n\n\n\n\n    ", "id": "d1pghct"}, {"comment": "> If you run marathons your time running 100 meters won't be impressive, but the job is to run marathons.\n\nBut a person who complains loudly as soon as you ask them to run 100 meters will probably not be a nice running partner for your marathons.", "id": "d1pjmmt"}, {"comment": "If running marathons was well paid, hard to supervise, and was taught to people by having then run just 100 metres a day, you'd definitely get dozens of people who would claim to be able to run marathons while being actually totally unfit.\n\nThe best way to weed out most of the impostors in less than 5 minutes is to have them run a kilometre. The worst impostors will fail, and the remaining impostors can be evaluated further or trained.\n\nFrom time to time, you'd get someone who'd say: \"A kilometre? I won't learn anything about your company during such a short run, and you should have already known I can run marathons: see all those photos of me running in marathons I posted to Gitrun! I also have a blog about running! Stop wasting my time!\"", "id": "d1pvxxw"}], [{"comment": "For junior roles coding tests are essential. For experienced coders their history speaks volume and it's a bit of a waste of time. There again juniors can be moulded into what you need. You only find out an experienced dev is a raging lunatic after they've been on your team for a few months and is causing mayhem. With experienced devs the later is the most likely bad hire and what you are trying to protect against.", "id": "d1pk23y"}], [{"comment": "I had one prospective employer/customer (forget which) who wanted me to do 8 hours worth of work to \"evaluate\" me. Um sure, that \"evaluation\" will cost you a few hundred bucks. TY.", "id": "d1pkzob"}], [{"comment": "I've spent about 24 hours in total doing programming tests and got flown out to 3 companies afterwards. For one job, programming wasn't even part of the position, they provided that and an \"iq\" test upon arrival (I probably got a 99). Another test was really fun, create a finance based program for them- I failed the algorithms part of the interview since I'm a structural engineer by education. The last interview I miserably failed the background test since I couldn't adequately prove what I was doing overseas. All of the positions were $82-110k entry level positions. It was a lot of fun and I learned a lot. I'd recommend the experience for entry level graduates.\n\nThe tests themselves were administered shittly in most cases by third party vendors (except for the Chicago project test). ", "id": "d1pmozs"}], [{"comment": "My last coding test experience was like this: A recruiter reached out to me via LinkedIn.  I arranged a call for the next day since it was Thanksgiving and I had the week off (vacation before holiday).  She calls me, we talk, and at the end she sends me the coding test.  It's due the next week.  Unfortunately, I cannot get to it until the night before it's due because of life.  I crack open the test to find several issues in the questions that make them difficult to answer.  For example, one question asks me to convert bases and display the result as a string in C/C++.  However, one of the numbers they use as input is negative and the resulting conversion is positive.  Even worse, the conversion is flat out wrong unless the output was prepended with \"-\" (this was a decimal to hex conversion).\n\nGiven that I only had an hour late at night there was no way I was going to get the answer before the due date.  There likely was no way I was going to get the answer anyways since I had gotten the test over Thanksgiving anyways.  So I documented the issue, stated that the conversion wasn't correct but that this matched the requested output, and said what the correct answer should be.\n\nThis happened on every question.\n\nWhich is why today I have two rules: don't ask me to do a coding test over the holidays and you must provide me a route for feedback on the test.  I don't care if I get the job or not but I want to know if I did things correctly.", "id": "d1po8vz"}], [{"comment": "My rule is 1 hour max on interview tests.\n\nCandidates have hostility to coding tests because many employers are abusing them.\n\nThe reason I've soured on coding tests and interview projects is the number of times I've done them, know I gave a correct answer, but I get no interview and no feedback.\n\nThere's also some shady people who try to get free consulting out of interview projects.  They take a task they actually need done and give it as an interview project.\n\nSome employers give a coding test to everyone who applies.  I give a valid solution, THEN they read my resume and decide they don't want to interview me.\n\nWhat was the point of getting a CS degree with honors if everyone is giving me a coding test before an interview?  Does your test measure more than the 4 years I spent on a degree?\n\nFor the automated computer-based coding tests (Brainbench, Hackerrank, Codility, etc), many employers will only give interviews to people who score in the top 5%-10%.  A poorly-written test can't distinguish between 95% and 70%.  So I do them, score 80th-90th percentile, then they conclude \"I'm not elite enough for them\" and no interview.", "id": "d1pcofy"}, {"comment": "> What was the point of getting a CS degree with honors if everyone is giving me a coding test before an interview? Does your test measure more than the 4 years I spent on a degree?\n\nPotentially. There are a significant number of CS grads that I've interviewed who finished their degrees and can't work through a basic coding test. ", "id": "d1pgrfb"}, {"comment": "Indeed. You can get a CS degree with a focus on all the mathematical theory and only minimal classes involving actual programming.\n\nThough I expect if you focused your education on the theory you would be looking into graduate studies and a career in academia rather than applying to programming jobs. But then, folks are rarely that rational.", "id": "d1phrsc"}]]], "3xushd": ["Are you ready to migrate to Angular 2.0? Learn the changes and develop a migration strategy with this case study from iVision", "2015-12-22 20:18:43", 0, "http://ivision.com/blog/changes-angular-2-migration-case-study/", [[4, "Funny that a company named iVision has a font on their blog that I can hardly read."], [1, "I only skimmed through the text but it seemed like very well written text with clear examples.\n\n>  I think there will be a far more significant learning curve even disregarding the jump to TypeScript and/or ECMAScript 6\n\nThe part above was interesting. I see Angular 1 as somewhat hard to learn, if Angular 2 is worse it might be costly to switch and re-learn. This might give other frameworks a push instead. We'll see what happens next year and the year after."]], [[{"comment": "Funny that a company named iVision has a font on their blog that I can hardly read.", "id": "cy8941l"}], [{"comment": "I only skimmed through the text but it seemed like very well written text with clear examples.\n\n>  I think there will be a far more significant learning curve even disregarding the jump to TypeScript and/or ECMAScript 6\n\nThe part above was interesting. I see Angular 1 as somewhat hard to learn, if Angular 2 is worse it might be costly to switch and re-learn. This might give other frameworks a push instead. We'll see what happens next year and the year after.", "id": "cy8uwgh"}]]], "43kpq0": ["Git 2.7: a Major New Release with Many New Features and Improvements", "2016-01-31 23:20:31", 0, "http://www.infoq.com/news/2016/01/git-27-released", [[7, "Bit late to the ball is that article. 2.7 was released January 4th."]], [[{"comment": "Bit late to the ball is that article. 2.7 was released January 4th.", "id": "cziwhir"}]]], "559kno": ["Code Valley opens Marketplace, starting the industrial revolution of coding today", "2016-09-30 23:20:52", 0, "http://bravenewcoin.com/news/code-valley-starts-the-industrial-revolution-of-coding-today-with-the-help-of-bitcoin", [[12, "Is this a joke ?  seriously.  I've been writing software for decades and this make no sense to me.\n\n"], [7, "> a mass produced software components industry has yet to emerge\n\n... What?\n\nThis entire article feels like someone has read a book about the industrial revolution and modern supply chain logistics, and then, completely clueless to the existing software ecosystems of the world, decided they'll blow our mind with a strategy we've been implementing for decades now."], [6, "Looks like the software industry has outsourced its buzzword production to /r/anarchocapitalism..."], [4, "What? The whole point of programming is to custom make software for specific tasks and to certain design specs. You can't possibly make a different piece of software for every single potential use case."], [1, "This is the best tl;dr I could make, [original](http://bravenewcoin.com/news/code-valley-starts-the-industrial-revolution-of-coding-today-with-the-help-of-bitcoin) reduced by 93%. (I'm a bot)\n*****\n> The current cost of building a Vendor bot is 5 mBTC. There is a token fortnightly fee of 1 mBTC to advertise your Vendor in the Valley, to keep the Valley from becoming unmanageable or hard to navigate.\n\n> Since a Vendor is a fairly complex piece of machinery, according to Lovisa, it is not unreasonable for the build cost to be substantially higher than 5 mBTC. As the system is designed to build software, the marketplace itself can build the Vendor for the developer.\n\n> Over 600,000 contracts went out to Vendors in the marketplace, half of them to &#039;byte&#039; Vendors at the ends of the supply-chain.\n\n\n*****\n[**Extended Summary**](http://np.reddit.com/r/autotldr/comments/55akz5/code_valley_opens_marketplace_starting_the/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ \"Version 1.65, ~108835 tl;drs so far.\") | [Theory](http://np.reddit.com/r/autotldr/comments/31bfht/theory_autotldr_concept/) | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr \"PM's and comments are monitored, constructive feedback is welcome.\") | *Top* *keywords*: **Vendor**^#1 **developed**^#2 **software**^#3 **Valley**^#4 **program**^#5"], [3, "I looked at their site, watched all their videos, read some documentation and I still cannot wrap my head around this. I understand that they are using user programmers to define vendors and use emergent code to generate a binary. But I am not sure what kinda of applications you could make or what platform it would run on.\n\nMy biggest concern is that once they have 1000xxxx of programs define vendor specification what is to stop them from taking that and running with it? I am I missing something or do guys feel this is a possibility?"], [2, "This is a clear nonsense advertisement being upvoted by bots while real people legitimately try to get rid of it."], [-2, "Fuck off with this Bitcoin echo chamber shit."], [0, "I might go on to note that the example they use,  accessing an element in array is very precisely described with a few letters in almost every computer language and it is a well understood process for compilers and interpreters to \"run\" that spec.  \n\ne.g.\n\nx = array[i];\n\nbreaking this down further is pretty absurd."]], [[{"comment": "Is this a joke ?  seriously.  I've been writing software for decades and this make no sense to me.\n\n", "id": "d88uze9"}, {"comment": "Have you had a chance to skim through our [documentation](https://codevalley.com/documentation)? You might find the \"How is it different?\" section of some use.", "id": "d8977ei"}, {"comment": "Here is the problem. If I want to precisely describe the behavior I want some other entity to create (be it human or computer), I have actually already created that behavior in whichever language I described it.\n\nAnything with less precision than that will necessarily require the implementing entity to understand my problem domain as well as I understand it.  In which case what my role in the organization ?  This is why junior developer will ask important useful clarifying question when given a \"spec\"  and is why \"offshoring\" coding has been an abysmal failure.\n", "id": "d89n5c9"}, {"comment": "Excellent point. And one that has come up a few times now... I'm going to add it to our FAQ asap. (Thanks for the feedback.) \n\nI'll take what I responded with in another comment and modify slightly to answer your question.\n\n> \"If I want to precisely describe the behaviour I want some other entity to create...\"\n\nThat's just it. You are describing high-level behaviour in a language that was not created to sit at the same level of abstraction. This gives you an insane amount of freedom... but that comes with the dark side of scope creep, changing requirements etc.\n\nIn this system, in order to achieve rapid construction of software, we relinquish the right to a 'smooth space' of requirements. When I contract the *webserver* Vendor [here](https://www.youtube.com/watch?v=U6jtCVOQiuA), I'm contracting him for his expertise... one part of which is setting up that menu. I trust that he will design it to fit with the other elements of the site (that I put him in touch with via committees). I have no say over positioning, RGB colour codes etc. That is his job. \n\nBefore you throw your arms up in frustration... it is not as bad as it seems. The concept I'm talking about is 'constructability' (see pg. 7 of the [whitepaper](https://codevalley.com/whitepaper.pdf)). It is present in all other industries... except software. (And that's because all other industries have a physical product as opposed to our intangible and easily replicated one.)\n\nIn the Civil construction industry for example, if my design called for a 520 mm wide I-beam, I would go check the specs (similar to researching your suppliers in this system) and see that nobody can provide such a beam. I have to go with the 500 mm or the 600 mm wide suppliers. It will be the same in this system. If you want a particular type of menu as part of your webserver core that is not offered by any existing supplier... you have to either modify your design and select one that is 'close' to what you wanted... *or* you can incentivise a supplier to be created that will do what you want. Bear in mind, that last option will be substantially higher in cost and time than the former. (It would be like the Civil engineer commissioning an entirely new beam to be created that is 520 mm wide... an expensive exercise indeed.)\n\nHowever, keep in mind that if there is a *market* for a \"520 mm beam\" in this marketplace, suppliers will cater to that demand. In fact, the \"520 mm beam\" might even become the norm!", "id": "d8a9nvt"}], [{"comment": "> a mass produced software components industry has yet to emerge\n\n... What?\n\nThis entire article feels like someone has read a book about the industrial revolution and modern supply chain logistics, and then, completely clueless to the existing software ecosystems of the world, decided they'll blow our mind with a strategy we've been implementing for decades now.", "id": "d88ubu6"}, {"comment": "You are clearly mistaken.\n\nThis article is the outcome of someone getting a liberal arts degree.", "id": "d88wbpt"}, {"comment": "hmmm, I'm not so sure.  A liberal arts degree would have driven more squishy, fluffy language and artsy-ness into it.  To me this feels like an MBA \"ideas guy\" that is either woefully ignorant, or deliberately scamming money out of people.  \n\nProbably not ignorant.\n\nAnd scamming?  Well, really, is it scamming if you show this to someone and ask for $50k, and they give it to you?  At some point one must fall back on \"a fool and their money are soon separated\"\n", "id": "d89fk67"}], [{"comment": "Looks like the software industry has outsourced its buzzword production to /r/anarchocapitalism...", "id": "d88vzap"}, {"comment": "I'm from r/ancap, don't really get what this article is saying. I was a C# developer for three years and this made no sense. Seemed like a bunch of handwaving woowoo. ", "id": "d899wau"}, {"comment": "Basically you feed the system with some requirements (which, as we all know, are always perfectly specified without any ambiguity) and it coordinates several nested layers of subcontracting where individual developers end up contributing components so small they can't be broken down lower. The system assembles these components into a functioning codebase that won't have bugs because the subcomponents don't have bugs (and bugs of course never arise from the integration of components which work in isolation), and doesn't need to be readable for audit or review purposes because the people providing those atomic subcomponents are subject to a rating system (not open to abuse at all, I'm sure regulators will love it). \n\nI suspect the people behind this have not actually been involved in software development or IT since maybe the early 90s, and even back then this would have been a ridiculous idea. The industrial revolution analogy is pretty good though, because anything this system produces is going to be a clanking, hissing, monstrosity (like their website).", "id": "d89hgb2"}, {"comment": "> Basically you feed the system with some requirements (which, as we all know, are always perfectly specified without any ambiguity)\n\nThey *can* be specified without any ambiguity in this system. How? Because you - the specifier - have a finite list from which you can express your requirements. You no longer have a 'smooth space' of requirements that developers currently enjoy. We sacrifice that for expedited software design and construction. So instead of a developer specifying their requirements, we say that Vendors *capture* requirements. You can read more about it here in the [whitepaper](https://codevalley.com/whitepaper.pdf) - pg 3. It is one of the key concepts underlying this technology. \n\n> (and bugs of course never arise from the integration of components which work in isolation)\n\nThe components don't work in isolation. That's just it. A Vendor is a program that is designed to accept contracts (requests) from other Vendor programs, make internal decisions, and then contract other Vendor programs, giving them the necessary information for them to proceed with their own internal processing. \n\nBy itself, a Vendor is useless. However, when a Vendor is contracted as part of a build (i.e. it is part of a unique supply-chain created just for that project), it will *eventually* return a binary fragment of code. This fragment is the result of its cooperation with other Vendors like itself (during the build). That is why we have taken to calling this system of development 'emergent coding' - binary code production is the higher order complexity that arises out of the interaction of the cooperating agents of the system (Vendors). \n\n> and doesn't need to be readable for audit or review purposes because the people providing those atomic subcomponents are subject to a rating system (not open to abuse at all, I'm sure regulators will love it).\n\nThe rating system *cannot* be abused, because ratings aren't assigned by biased humans. The reputation of a Vendor is completely objective and updated with each contract the Vendor program retires. There could be 6 Vendors underneath a classification, all competing for business. Each one will design the same 'feature', but they could return (on average) vastly different-sized binary fragments. We call this the code footprint of a Vendor. The smaller the code footprint, the better the Vendor. A developer can make their Vendor achieve a smaller code footprint by automating it to better cooperate with its peers at run-time (design-time of the overall application being built) in order to more efficiently design their features. \n\n> because anything this system produces is going to be a clanking, hissing, monstrosity (like their website).\n\nIf developers come in and build Vendors to compete with our own set (that we currently contract to build our site) and they do a better design job? We'll happily switch to contracting them... and then the website (with backend server) returned to us 67 minutes later will no longer be a clanking, hissing, monstrosity. ", "id": "d8ac1m7"}], [{"comment": "What? The whole point of programming is to custom make software for specific tasks and to certain design specs. You can't possibly make a different piece of software for every single potential use case.", "id": "d88w5ym"}, {"comment": "> The whole point of programming is to custom make software for specific tasks and to certain design specs.\n\nThat is exactly what this system achieves. Each Vendor provides a 'design-contribution' (a kind of indirect code contribution). On it's own, a Vendor is useless. It is a program designed to accept contracts, make decisions, and further contract other Vendors. But when a Vendor is part of a build, and therefore part of a unique supply-chain just for that project, it will eventually return binary code as a result of its cooperation with other Vendors. That is why we have come to refer to this process as 'emergent coding' - code itself emerges as a higher order complexity out of the agents (Vendors) of the system.", "id": "d8979po"}, {"comment": "What? this is pretty incoherent.", "id": "d8987y2"}, {"comment": "\nYou can be forgiven for such a reaction. This software technology is *substantially* different from current methods. May I suggest to take a look at page 4 of the [whitepaper](https://codevalley.com/whitepaper.pdf) and/or the [documentation](https://codevalley.com/documentation). It would be well worth your effort.", "id": "d8bt1lt"}, {"comment": "You might be retarded, fyi.", "id": "d89q5zp"}], [{"comment": "This is the best tl;dr I could make, [original](http://bravenewcoin.com/news/code-valley-starts-the-industrial-revolution-of-coding-today-with-the-help-of-bitcoin) reduced by 93%. (I'm a bot)\n*****\n> The current cost of building a Vendor bot is 5 mBTC. There is a token fortnightly fee of 1 mBTC to advertise your Vendor in the Valley, to keep the Valley from becoming unmanageable or hard to navigate.\n\n> Since a Vendor is a fairly complex piece of machinery, according to Lovisa, it is not unreasonable for the build cost to be substantially higher than 5 mBTC. As the system is designed to build software, the marketplace itself can build the Vendor for the developer.\n\n> Over 600,000 contracts went out to Vendors in the marketplace, half of them to &#039;byte&#039; Vendors at the ends of the supply-chain.\n\n\n*****\n[**Extended Summary**](http://np.reddit.com/r/autotldr/comments/55akz5/code_valley_opens_marketplace_starting_the/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ \"Version 1.65, ~108835 tl;drs so far.\") | [Theory](http://np.reddit.com/r/autotldr/comments/31bfht/theory_autotldr_concept/) | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr \"PM's and comments are monitored, constructive feedback is welcome.\") | *Top* *keywords*: **Vendor**^#1 **developed**^#2 **software**^#3 **Valley**^#4 **program**^#5", "id": "d88xl5t"}], [{"comment": "I looked at their site, watched all their videos, read some documentation and I still cannot wrap my head around this. I understand that they are using user programmers to define vendors and use emergent code to generate a binary. But I am not sure what kinda of applications you could make or what platform it would run on.\n\nMy biggest concern is that once they have 1000xxxx of programs define vendor specification what is to stop them from taking that and running with it? I am I missing something or do guys feel this is a possibility?", "id": "d89xbck"}, {"comment": "> I looked at their site, watched all their videos, read some documentation and I still cannot wrap my head around this. \n\nThanks for taking the time to read through our documentation and watch a few videos. \n\n> I understand that they are using user programmers to define vendors and use emergent code to generate a binary. But I am not sure what kinda of applications you could make or what platform it would run on.\n\nWe've got a thread [here](https://www.reddit.com/r/codevalley/comments/52hfvz/register_your_demand_what_applications_are_you/) where we're trying to capture demand with regards to which applications people want to see the marketplace target first. This will help give us and newly joined developers an idea as to which Vendors we should identify first. \n\nAt present, we're still populating the data layer of the marketplace. We have all four layers populated in an older (and incompatible) version of the marketplace that we used to build our website. So instead of us contracting Vendor's we've created to build our site, the plan is to have developers come through and build the required Vendors for the public marketplace and use them to rebuild our site anew. That is, we want to *pay* non-CV Vendors to build our site. So you could say that the very first type of application the marketplace will build is a 'corporate website.' That said, we have no control over which Vendors developers choose to build... they can go off in any direction or area they please. For instance, we've already seen users creating Vendors in the data layer that will design hashing, PKI etc. in preparation for building a full-blown Bitcoin wallet. \n\n> My biggest concern is that once they have 1000xxxx of programs define vendor specification what is to stop them from taking that and running with it? I am I missing something or do guys feel this is a possibility?\n\nA developer's IP - the decisions they automate their Vendor to make and the supplier that Vendor is automated to contracted - stays protected inside their Vendor program. We are not privy to how you designed your Vendor any more than any other user in the network is. \n\nPlease do let me know if you have any other questions or concerns. I would love to clear them up.\n\n", "id": "d8ac9pc"}], [{"comment": "This is a clear nonsense advertisement being upvoted by bots while real people legitimately try to get rid of it.", "id": "d88yzsd"}], [{"comment": "Fuck off with this Bitcoin echo chamber shit.", "id": "d88vz2s"}], [{"comment": "I might go on to note that the example they use,  accessing an element in array is very precisely described with a few letters in almost every computer language and it is a well understood process for compilers and interpreters to \"run\" that spec.  \n\ne.g.\n\nx = array[i];\n\nbreaking this down further is pretty absurd.", "id": "d89n7mv"}, {"comment": "The example is more closely described as *implementing* the array[i] functionality, not utilising it. To utilise the functionality would simply involve contracting the example Vendor.", "id": "d8aixff"}, {"comment": "So in some machine code this is literally a single instruction.  Why do I need to contract for that ?  Seems absurd.\n\nperhaps I should contract for a 2's complement add ?  How about a NAND operation.  Or perhaps I should contract for the construction of a CMOS transistor ?", "id": "d8b7q4d"}, {"comment": "You've hit the nail on the head. If you're an expert in a particular cpu instruction set then *you* can create a byte-layer Vendor who delivers machine code to achieve such things.\n\nOnce you publish your Vendor, it'll be available for others to contract. Those who contract (and pay) your Vendor will be happy to do so because they're designing at a higher level and don't want to be concerned with the intricacies of the instruction set, nor the complexities of deciding what are the most efficient instructions to use, etc.\n\n*Edit: fixed typo*", "id": "d8bfprp"}, {"comment": "But this is basically done for free in a gajillion different languages and compilers.  So I'm lost as to why anyone would contract a vendor for a single machine language instruction.  \n\nLet's try something more high level.\n\n\"Implement a user login system\"\n\nI've literally had JIRA ticket which said that.  And yet it's so devoid of so many details that it's pretty much impossible to get started.\n\n", "id": "d8bnlao"}, {"comment": "> So I'm lost as to why anyone would contract a vendor for a single machine language instruction. \n\nThe answer is derived from one of the powerful properties exhibited by these vendor-bots. They *integrate* code into your project rather than you selecting, say a library function, and shouldering the burden of integration yourself. One scales nicely while the other does not. Strategically, we could have terminated the emergent coding at some HLL but that would have introduced some unacceptable centralisms. By taking it to the binary, *we now incorporate the workings of the compiler*. While this has meant an extra layer of vendors in the implementation, it has the powerful side-effect of exposing these inner workings to the marketplace making its performance subject to these market forces. For example, if you can conceive of a superior [register allocation scheme](https://en.wikipedia.org/wiki/Register_allocation), you can immediately enjoy a financial reward for your innovation. While I am confident that taking it to the binary is the correct decision, only time will tell.\n\n>Let's try something more high level.\n\nAs stated above, vendors in emergent coding scale nicely. Surprisingly, a vendor delivering a contribution at a high level is no more complex in implementation than a vendor delivering a single binary instruction. Check out the last paragraph of page 6 in the [whitepaper](https://codevalley.com/whitepaper.pdf). While there are some nice worked examples of expressing a vendor in the [documentation](https://codevalley.com/documentation), may I suggest you first familiarise yourself with the *Reversing requirements responsibility* on page 3 of the whitepaper. Higher level vendor examples are coming. Thank you for your interest.\n\nedit: clarity.", "id": "d8budj7"}]]], "41e334": ["10 examples of grep command in UNIX", "2016-01-17 19:02:01", 4, "http://javarevisited.blogspot.com/2011/06/10-examples-of-grep-command-in-unix-and.html", [[2, "If you want something faster, try silversearch a.k.a ag, its programmer friendly.\n\nHere is some quick benchmark on bootstrap git repository,\n\n    ~/git/bootstrap\n    ms 130 % time grep -R http . | grep -v https > /dev/null\n    grep --color=auto -R http .  0,16s user 0,09s system 97% cpu 0,264 total\n    grep --color=auto -v https > /dev/null  0,02s user 0,00s system 10% cpu 0,264 total\n\n    ~/git/bootstrap\n    ms 0 % time ag -R http . | ag -v https > /dev/null\n    ag -R http .  0,12s user 0,01s system 114% cpu 0,111 total\n    ag -v https > /dev/null  0,03s user 0,00s system 24% cpu 0,110 total\n\n"]], [[{"comment": "If you want something faster, try silversearch a.k.a ag, its programmer friendly.\n\nHere is some quick benchmark on bootstrap git repository,\n\n    ~/git/bootstrap\n    ms 130 % time grep -R http . | grep -v https > /dev/null\n    grep --color=auto -R http .  0,16s user 0,09s system 97% cpu 0,264 total\n    grep --color=auto -v https > /dev/null  0,02s user 0,00s system 10% cpu 0,264 total\n\n    ~/git/bootstrap\n    ms 0 % time ag -R http . | ag -v https > /dev/null\n    ag -R http .  0,12s user 0,01s system 114% cpu 0,111 total\n    ag -v https > /dev/null  0,03s user 0,00s system 24% cpu 0,110 total\n\n", "id": "cz1ne9z"}, {"comment": "what is the difference if you ignore the .git directory which ag does by default?", "id": "cz27tgt"}, {"comment": "Oh, you mean if I ignore the .git directory when using grep. My mistake. I will do it again.\n\n\nBootstrapping to let OS cache the files,\n\n    ~/git/bootstrap\n    ms 0 % time grep --exclude-dir=.git -R http . | grep -v https > /dev/null\n    grep --color=auto --exclude-dir=.git -R http .  0,25s user 0,36s system 18% cpu 3,200 total\n    grep --color=auto -v https > /dev/null  0,03s user 0,02s system 1% cpu 3,200 total\n\ngrep running three times,\n\n    ~/git/bootstrap\n    ms 0 % time grep --exclude-dir=.git -R http . | grep -v https > /dev/null\n    grep --color=auto --exclude-dir=.git -R http .  0,15s user 0,08s system 96% cpu 0,239 total\n    grep --color=auto -v https > /dev/null  0,01s user 0,01s system 9% cpu 0,238 total\n    \n    ~/git/bootstrap\n    ms 0 % time grep --exclude-dir=.git -R http . | grep -v https > /dev/null\n    grep --color=auto --exclude-dir=.git -R http .  0,14s user 0,10s system 95% cpu 0,254 total\n    grep --color=auto -v https > /dev/null  0,03s user 0,00s system 10% cpu 0,254 total\n    \n    ~/git/bootstrap\n    ms 0 % time grep --exclude-dir=.git -R http . | grep -v https > /dev/null\n    grep --color=auto --exclude-dir=.git -R http .  0,14s user 0,09s system 96% cpu 0,238 total\n    grep --color=auto -v https > /dev/null  0,01s user 0,01s system 9% cpu 0,237 total\n\nag running three times,\n\n    ~/git/bootstrap\n    ms 0 % time ag -R http . | ag -v https > /dev/null\n    ag -R http .  0,12s user 0,01s system 113% cpu 0,112 total\n    ag -v https > /dev/null  0,03s user 0,00s system 24% cpu 0,111 total\n    \n    ~/git/bootstrap\n    ms 0 % time ag -R http . | ag -v https > /dev/null\n    ag -R http .  0,11s user 0,01s system 118% cpu 0,104 total\n    ag -v https > /dev/null  0,02s user 0,01s system 25% cpu 0,103 total\n    \n    ~/git/bootstrap\n    ms 0 % time ag -R http . | ag -v https > /dev/null\n    ag -R http .  0,11s user 0,01s system 121% cpu 0,096 total\n    ag -v https > /dev/null  0,02s user 0,00s system 20% cpu 0,096 total", "id": "cz2skpb"}, {"comment": "Speed.", "id": "cz2gtya"}]]], "4bk374": ["You think Java is slow and heavy? The fastest web server in the world is written in Java!", "2016-03-23 03:46:22", 2, "https://www.techempower.com/benchmarks/#section=data-r12&hw=peak&test=plaintext", [[7, "The JVM is a well engineered piece of machinery."], [3, "While this is interesting to say the least, I feel that the tests aren't fully detailed.  \nIt doesn't take into account the potential overhead of lookup of set paths.  \neg: If I have 30 different endpoints, will it take longer to resolve the handler?  \nWe can't assume all frameworks use a O(1) lookup.\n "]], [[{"comment": "The JVM is a well engineered piece of machinery.", "id": "d1a6d2m"}], [{"comment": "While this is interesting to say the least, I feel that the tests aren't fully detailed.  \nIt doesn't take into account the potential overhead of lookup of set paths.  \neg: If I have 30 different endpoints, will it take longer to resolve the handler?  \nWe can't assume all frameworks use a O(1) lookup.\n ", "id": "d1adajp"}]]], "4bkmmy": ["Richard Stallman Braved a Winter Storm Last Night to March Against DRM", "2016-03-23 06:05:42", 0, "https://motherboard.vice.com/read/we-marched-with-richard-stallman-at-a-drm-protest-last-night-w3-consortium-MIT-joi-ito", [[1, "\"If there is no code in your link, it probably doesn't belong here.\""], [-1, "The Gen X/Y definition of \"brave\"... Lol."]], [[{"comment": "\"If there is no code in your link, it probably doesn't belong here.\"", "id": "d1bjxra"}], [{"comment": "The Gen X/Y definition of \"brave\"... Lol.", "id": "d1a2la2"}, {"comment": "\"braving the winter\" is a common expression in English to mean going outside even though it's cold.", "id": "d1a89ty"}]]], "4a8ulq": ["Your code is always outdated - and that's OK", "2016-03-13 20:17:22", 7, "http://ebergstedt-blog.logdown.com/posts/612022-replacing-old-code", [[3, ">The moment your hands are lifted from your keyboard and your unit tests are passing - then your code is old and outdated.\n\nNot the same kind of outdated as \"updating PHP to 5.4\" breaks out codebase, mind you. "], [1, "Your code is only outdated if it doesn't have tests to verify it's spec."]], [[{"comment": ">The moment your hands are lifted from your keyboard and your unit tests are passing - then your code is old and outdated.\n\nNot the same kind of outdated as \"updating PHP to 5.4\" breaks out codebase, mind you. ", "id": "d0yj28w"}], [{"comment": "Your code is only outdated if it doesn't have tests to verify it's spec.", "id": "d0zba9c"}]]], "4i9ee8": ["Bad Engineering Properties of Object-Oriented Languages", "2016-05-07 13:33:46", 0, "http://doc.cat-v.org/programming/bad_properties_of_OO", [[10, "Quality has many facets. Beware of perspectives, you are always looking from one and ignoring others.\n\nThis article seems to forget or ignore that a program is always related to something outside the program, the world of human concepts. A desirable engineering quality is a certain harmony between the program and the concepts outside the program. At least in theory, the better the harmony, the easier it is to understand the code and modify it. \n\nThe rationale of OOP is to increase this harmony. It is debatable whether it succeeded or not, but you cannot leave that objective outside of any analysis."], [10, ">Object-oriented style is intrinsically less efficient that procedural style. In pure object-oriented style, every routine is supposed to be a (virtual) method. This introduces additional indirections through method tables and prevents optimizations such as inlining.\n\nWow, *massive* strawman. Stopped reading . :-)"], [5, "The spirit of OO during the 80's and 90's was all about explaining taxonomies of dogs and cats and squares and rectangles. This childish mindset reflected into the design of OO languages from that era. Inheritance was seen as something beautiful when in fact it introduces the worst kind of coupling. Orthogonal type systems and modularization were never the goal back then."], [5, "Wouldn't it be nice if this site mentioned the publication date of the articles? \n\nOn internal evidence, this doccie comes from between 1997 (the latest reference) and 1998 (when DEC went belly-up)."], [0, "This is way too charitable to object oriented programming.  For example, I don't buy that OOP is more efficient at all for small projects.  Libraries and package managers can help get things started, but what does it matter if they are OO or not?"]], [[{"comment": "Quality has many facets. Beware of perspectives, you are always looking from one and ignoring others.\n\nThis article seems to forget or ignore that a program is always related to something outside the program, the world of human concepts. A desirable engineering quality is a certain harmony between the program and the concepts outside the program. At least in theory, the better the harmony, the easier it is to understand the code and modify it. \n\nThe rationale of OOP is to increase this harmony. It is debatable whether it succeeded or not, but you cannot leave that objective outside of any analysis.", "id": "d2wd7ts"}, {"comment": "I don't think any single paradigm is best for all programming. OO is great for GUIs, FP is great for compilers, array languages are great for data analysis, etc.", "id": "d2webix"}, {"comment": "Agreed. Thats why, for example, The best oop languages are those flexible enough to support FP style, and viceversa", "id": "d2wew8s"}, {"comment": "> OO is great for GUIs\n\nI see this repeated frequently and I have to say I don't understand it. Leaving aside the fact that functional programming and OO are answers to different questions and can be used in harmony, GUIs can and should be declarative, not imperative. A well designed system would not make you define the way the thing starts and also define the way it changes. This encodes the same knowledge into the program in multiple ways.", "id": "d2wr1zh"}, {"comment": "Do you mean something like Angular, where the data model is the single source of truth? That's just MVC, a classic OO pattern. The M->V logic can be declarative, but the C->M logic is usually nontrivial and best described imperatively.", "id": "d2ws60d"}, {"comment": "It probably depends on the application but the C->M logic is just a series of model declarations given a model and an event from where I sit. A state machine. More complicated models might be state machines composed of other state machines.\n\nI should say I've never used angular... for context.", "id": "d2wsj4y"}, {"comment": "> state machines composed of other state machines\n\nThat's basically what OOP is. Each object is sort of a state machine.", "id": "d2wudwj"}, {"comment": "No, OOP is a programming paradigm involving encapsulation, polymorphism, and inheritance. No programming paradigm owns the concept of state machines, and I'd wager every nontrivial program written in any language or paradigm contains some kind of state machine.", "id": "d2wwye0"}, {"comment": "I don't think OOP did anything to enhance this harmony youre describing. The gains I see from it are all about code organization and consistency guarantees in data that may or may not model something in the real world.", "id": "d2wnrhv"}], [{"comment": ">Object-oriented style is intrinsically less efficient that procedural style. In pure object-oriented style, every routine is supposed to be a (virtual) method. This introduces additional indirections through method tables and prevents optimizations such as inlining.\n\nWow, *massive* strawman. Stopped reading . :-)", "id": "d2wersf"}], [{"comment": "The spirit of OO during the 80's and 90's was all about explaining taxonomies of dogs and cats and squares and rectangles. This childish mindset reflected into the design of OO languages from that era. Inheritance was seen as something beautiful when in fact it introduces the worst kind of coupling. Orthogonal type systems and modularization were never the goal back then.", "id": "d2w99er"}, {"comment": "I'd say the complaints you have are more recent. Late 90s->2000s, only after we got OO like Java with memory management built-in. Back in the 80s and early 90s OO was all about objects managing their own memory with constructors/destructors, which was a giant improvement IMO.", "id": "d2wai11"}, {"comment": "I still remember most of the C++ books from the mid 90s going to great lengths about `CAnimal`, `CShape` and `CPerson`.", "id": "d2wao43"}, {"comment": "That was only in C++ and didn't really have to do with OOP. Most OO languages were already GCed in the 80s. Simula, Smalltalk, Common Lisp, Eiffel, Modula-3...", "id": "d2wgdpj"}], [{"comment": "Wouldn't it be nice if this site mentioned the publication date of the articles? \n\nOn internal evidence, this doccie comes from between 1997 (the latest reference) and 1998 (when DEC went belly-up).", "id": "d2wf8g7"}], [{"comment": "This is way too charitable to object oriented programming.  For example, I don't buy that OOP is more efficient at all for small projects.  Libraries and package managers can help get things started, but what does it matter if they are OO or not?", "id": "d2wdlm5"}]]], "4jfg4x": ["Software shouldn't guess gender \u00b7 SJW now attacking software development community", "2016-05-15 13:38:25", 0, "https://github.com/nlp-compromise/nlp_compromise/issues/117", [[32, "There is nothing wrong in trying to guess gender, race, age, sexual orientation or religion from physical (and other) characteristics. Humans do it all the time.\n\nIt's only wrong if it's used for discrimination."], [34, "This is what happens when you give an inch to socjus bullies. All of this bullshit was predictable since the purging of Eich, and probably earlier. [Entryism](https://en.wikipedia.org/wiki/Entryism) can only be meaningfully confronted if the people attempting it are institutionally denied entry from the start. Tech is either an acceptable outlet for subversion by radical political manifestations, or it is not. There's no middle ground with these people."], [13, "Oh, so it's that time of the year again?"], [12, "What I don't understand: is it not allowed to implement that works in the common case, but can't deal with certain edge cases? The common case, binary genders, are the vast majority, after all. Also, this is NLP. NLP has never gotten it 100% right so far. But here the argument against gender detection is that the algorithm doesn't get it 100% right. As long as these limitations are known and well-documented, it should be fine for users."], [7, "On a final note, if your feelings get hurt over something this trivial, that sounds more like a personal problem that you shouldn't be outsourcing"], [6, "They targeted software developers. \n\nSoftware developers."], [3, "There's a disparity of life between inorganic and organic material. All life should die so all matter can all have an equal experience of living. /s"], [1, "It shouldn't matter, honestly social issues should stay out of the way of progressive engineering. It's like we're allowing personal feelings to get rid of useful applications that could in turn help out multiple fields of research."], [1, "I'm about 95% sure this is a troll. "], [1, "I think computers should guess more, say you are entering your details into a website, and you type Neil in the first name field, it can use that to automatically fill out title (Mr), and even use it to guide autocomplete on the surname (using race, it means that surname is more likely to be Smith / Jones, etc, rather than Li). The problem is not guessing, the problem is not storing data and using the guess without the ability to override it."], [-5, "this is a sensationalist post I'd say."]], [[{"comment": "There is nothing wrong in trying to guess gender, race, age, sexual orientation or religion from physical (and other) characteristics. Humans do it all the time.\n\nIt's only wrong if it's used for discrimination.", "id": "d366cic"}, {"comment": "There's also the fact the language is gendered. Other languages, like French or Spanish, go far beyond just having different pronouns such that you must keep gender in mind to even grammatically parse a sentence. It seems like gender guessing would be a functional requirement of a NLP library even if you only support English.", "id": "d36bmz6"}, {"comment": "Even English retains some of it, ships are female for example.", "id": "d36tjl7"}, {"comment": "Not Boaty McBoatface.", "id": "d38tl5v"}, {"comment": "I'm not sure if that's really germane. Ships being female is a cultural convention, rather than a language construct. For example, your grammar is perfectly correct referring to a ship as an \"it\". But using the wrong gender in some languages could result in your sentence changing meaning completely. As an example, 'Derecho' in Spanish is \"right\" in a moral/legal sense, and in the phrase 'sigue derecho' means \"go straight (ahead)\". 'Derecha' is \"right\" in a directional sense, like right vs. left. Fouling the \"-o\" (masculine) ending vs. the \"-a\" (feminine) ending could cause errors in, say, giving navigational directions. Worse, 'Sigue' is a conjugation of 'seguir', \"to follow\". So 'sigue derecho' and 'sigue derecha' mean very different things: \"go straight\", and essentially \"bear right\". ", "id": "d37ox7f"}, {"comment": "> Even English retains some of it~~,~~**;** ships are female**,** for example.\n\n", "id": "d381khj"}], [{"comment": "This is what happens when you give an inch to socjus bullies. All of this bullshit was predictable since the purging of Eich, and probably earlier. [Entryism](https://en.wikipedia.org/wiki/Entryism) can only be meaningfully confronted if the people attempting it are institutionally denied entry from the start. Tech is either an acceptable outlet for subversion by radical political manifestations, or it is not. There's no middle ground with these people.", "id": "d3665af"}, {"comment": "> There's no middle ground with these people.\n\nCareful, that's exactly the kind of militant-absolutism you hear from these people who don't believe in a middle-ground. \n\nIf you fall too far into a narrative of some epic culture clash full of hidden significance, then you're just giving the attention-seekers the legitimacy they want. ", "id": "d36hwt2"}, {"comment": "http://i.imgur.com/aUbk9ha.gif", "id": "d36s058"}, {"comment": "> There's no middle ground with these people.\n\nI think there's no middle ground with [holocaust deniers, antisemites, racists, homophobes, and other monsters](https://www.reddit.com/r/europeannationalism/comments/4j5ln2/i_fucking_told_you_so/d340owf), but garbage like you are apparently just fine on reddit.\n\n----\n\nPeople who are kneejerk upvoting comments like this: maybe it should give you pause that you are agreeing with __actual Nazis__.", "id": "d36766s"}, {"comment": "you are wrong there; he is wrong in so parts but still his opinion and comparing that to same level of nazis is plain wrong; and make you sound like entitled brat; \n\nedit: Tech should accept all kind of people, but politics/religion has not place in tech either science. and last time I checked SJW looks like a freaking cult! holding hands, repeating verses, calling for violence for anyone that do not agree with them ... cult", "id": "d367cbe"}, {"comment": "__This user is an actual Nazi__. This user's post history is full with holocaust denial and antisemetic, racist, and homophobic slurs. I linked to only the most recent example of an endless stream of wrong and offensive shit. You are the crybaby brat posting bullshit about SJWs because someone opened an issue on github. ", "id": "d367dv8"}, {"comment": "He may be. I don't know; but they are talking about /r/European being banned since some of their members were acting like little spoiled girls; Since went participating in a sub makes you a nazi? If so therefor I am a: racist, bigot, nazi, etc... Because I did participate a lot  in /r/European ", "id": "d367ghe"}, {"comment": ">This user is an actual Nazi.\n\nI'll have you know I identify as a neoreactionary traditionalist. But I can see how someone from the opposite end of the political spectrum might fail to notice or care about the difference. You're all communists to me, after all.", "id": "d369a36"}, {"comment": "Someone has linked to this comment from /r/ShitRedditSays in a possible attempt to brigade this thread:\n\n* [\\[After being called out for being a literal Nazi\\] \">This user is an actual Nazi. I'll have you know I identify as a neoreactionary traditionalist.\"](https://np.reddit.com/r/ShitRedditSays/comments/4jib0c/after_being_called_out_for_being_a_literal_nazi/)", "id": "d36suxa"}, {"comment": "wew lad", "id": "d3767zy"}, {"comment": "Fascinating, you only need to read 10 comments down before Godwin's law is invoked.", "id": "d369frt"}, {"comment": "I fail to see the relevance to the topic at hand. I'm not the one inserting my political views into completely unrelated issues, you are. I have the good sense to know where my views are welcome, and where they are not, and no desire to mix the two.", "id": "d3696me"}, {"comment": "> garbage\n\nUses the \"garbage person\" insult? Oh, look, an SJW flag flying high. These people and their mannerisms and unoriginal language conformations make they easy to spot.", "id": "d38tvzl"}], [{"comment": "Oh, so it's that time of the year again?", "id": "d367k2a"}, {"comment": "It's that time of [current year].", "id": "d36qhoe"}, {"comment": "/r/StatingCurrentYear", "id": "d3828sf"}, {"comment": "When all the SJWs' menstrual cycles coincide?", "id": "d38tnye"}], [{"comment": "What I don't understand: is it not allowed to implement that works in the common case, but can't deal with certain edge cases? The common case, binary genders, are the vast majority, after all. Also, this is NLP. NLP has never gotten it 100% right so far. But here the argument against gender detection is that the algorithm doesn't get it 100% right. As long as these limitations are known and well-documented, it should be fine for users.", "id": "d366eji"}, {"comment": ">We should never try to do something unless we get it completely right the first time!", "id": "d38tpje"}, {"comment": "no, you are wrong, the comment made is clear as water: \n\n>People shouldn't guess gender and gendered pronouns. Neither should software. Would you write code to guess someone's race using heuristics?\n\nthat person is being racist and big SJW bigot and that should never be welcome in github or this community.\n\nif you scroll down she also says she is planning to use the library therefore why complain? just to be a asshole", "id": "d366g65"}, {"comment": "I think you're too emotional about another person voicing their opinion, even if you don't agree with it, and all you do is attack that person for it.", "id": "d366jfg"}, {"comment": "Not even close, but I saw how gamergate stared and from one day to another we all will be woman haters, bigots and so on just because we do not agree with them. ", "id": "d366ndh"}, {"comment": "> \"Not even close\"\n\nyour emotionally charged response disagrees", "id": "d36okqc"}], [{"comment": "On a final note, if your feelings get hurt over something this trivial, that sounds more like a personal problem that you shouldn't be outsourcing", "id": "d36uufz"}, {"comment": ">you shouldn't be associating with society at large and should have a mental health caretaker assigned to you from the county assistance office.\\*", "id": "d38txs4"}], [{"comment": "They targeted software developers. \n\nSoftware developers.", "id": "d37cnyu"}, {"comment": "Isn't that abelist bullying? I mean, they're attacking foreveralone basementdwelling neckbearded autists.", "id": "d38tt63"}], [{"comment": "There's a disparity of life between inorganic and organic material. All life should die so all matter can all have an equal experience of living. /s", "id": "d36tm5h"}], [{"comment": "It shouldn't matter, honestly social issues should stay out of the way of progressive engineering. It's like we're allowing personal feelings to get rid of useful applications that could in turn help out multiple fields of research.", "id": "d36unxg"}, {"comment": "But binary body morphology don't real cuz feelz and gender  is a societal construct absent of millennia of biological evolution.", "id": "d38tzjo"}], [{"comment": "I'm about 95% sure this is a troll. ", "id": "d37xrv1"}], [{"comment": "I think computers should guess more, say you are entering your details into a website, and you type Neil in the first name field, it can use that to automatically fill out title (Mr), and even use it to guide autocomplete on the surname (using race, it means that surname is more likely to be Smith / Jones, etc, rather than Li). The problem is not guessing, the problem is not storing data and using the guess without the ability to override it.", "id": "d36o6s6"}, {"comment": "As a guy with an androgynous name, that would be *pretty annoying*. American websites would assume I was female because most Americans with my first name are female, but actually, most of my fellow Brits with the same first name as me, are male.", "id": "d36rf1c"}, {"comment": "I used a gender determining function that uses census data, and it name is 90% male / female it would use that gender, but otherwise it would not fill it out (So Pat would not have a gender associated with it), if you are a boy named Sue then you should expect to be called Miss occasionally :)", "id": "d36sqpf"}, {"comment": "I hate that name!", "id": "d38u33t"}, {"comment": "...Leslie?", "id": "d37wa8a"}, {"comment": "No, Robin. ", "id": "d37xlrj"}, {"comment": "Dick?", "id": "d38u23u"}, {"comment": "Would it really be that annoying though? The worst case scenario is that you have to click the same amount of times (I.e, correcting she to he is the exact same amount of work as selecting he in the first place)", "id": "d3kkq2o"}, {"comment": "It's not that that would be annoying, it would be the being misgendered that would be annoying. (For cis women it can be more than annoying. And for trans people it's horrible.)", "id": "d3kqtem"}, {"comment": "I knew a guy named Ashley. He was a youth minister. And, yes, by guy a mean XY chromosomes.", "id": "d38u1i1"}, {"comment": "Ashley was originally a masculine name, then it flipped, now it's more gender neutral. I know several guys named Ashley. ", "id": "d3dcxru"}], [{"comment": "this is a sensationalist post I'd say.", "id": "d36684g"}, {"comment": "how come? is from the github treat that those people are trying to push! if we dont stand ground now, later it will be too late ", "id": "d3668i3"}, {"comment": "lol \"don't stand ground now\" that sounds like we are in a holy war. The best thing is to just ignore any sjw posts. Give attention is the best somebody could hope for.\n\nAlso the Thread starter did distantiate from sjw in the thread. One could argue that this issue has some points in it that could be discussed. Not everytime you read about gender you have to jump a bandwagon about sjw, to what have we come in life that we can't discuss anything anymore without getting put into boxes.\n\nHonestly I don't give a fuck about sjw.", "id": "d366jgb"}, {"comment": "Well it has not point, is just complaining about it, since she also says is not planning in using the library. But you are right. those people are attention whores", "id": "d366o3z"}, {"comment": "In my experience, it's best to close such issues and move on as soon as possible. I decline participation in any project that actually listens to them.", "id": "d366wqx"}, {"comment": "That is actually a good advice. Since they are so little in numbers; just noisy ", "id": "d36721v"}, {"comment": "How dare you gender xir.", "id": "d38u432"}, {"comment": "[deleted]", "id": "d36717h"}, {"comment": "because the thread starter took distance from sjw. And the issue is disscusable and has not really a lot to do with sjw", "id": "d36752z"}]]], "454cux": ["Discussing shitty programming languages considered harmful", "2016-02-10 22:05:07", 0, "http://blog.aurynn.com/86/contempt-culture", [[16, "As I read it, I was following the remarks about how the writer was mocking other languages for bad reasons, but then suddenly it skips to women and minorities.\n\nI am not sure if the writer somehow feels his remarks about PHP damaged women and minorities (how?), or if they only see it as a metaphor for that."], [14, "What a lot of bullshit! If he has been talking shit about users of other languages as if they are inferior, that is his problem.\n\nBut don't tell me that I can't criticize a programming language for being bad. As long as you criticize an idea rather than people, there is nothing to excuse here. To make this into people getting offended , well that is just indicative of another disease spreading: the disease of micro aggressions. People having developed this ridiculous notion that they have a right to not be offended by way of somebody holding different views or opinions than them on a subject.\n\nBoth democracy and science is dependent on our ideas getting challenged by others. You will learn nothing if all you do is retreating to a cave of likeminded people holding the same views.\n\nIn my case I programmed C++ for over 13 years. I think it is a terrible language, and I have very many reasons for thinking that, which I will happily iterate in any debate. You don't need to agree with me, but you don't have a right to demand that I shut up about telling people why C++ sucks, just because you happen to think C++ is the best thing since sliced bread.\n\nI think OP is attacking a strawman. It isn't criticism of other languages which is a problem, but when people start posturing trying to make themselves look better by using language X, and telling everybody else they are stupid.\n\nThis just reminds me of people who says we can't criticize religion because that offends religious people. Screw that I am not going to listen to that. The mere suggestion is frankly offensive."], [9, "Ok, now PL-theory debates are getting branded as harming minorities. Keep your hands off the science you SJW retards!"], [7, "I don't agree with this. The language I heap the most criticism on is PHP. It is my least favourite language by far. I am a PHP developer so according to the article that's OK, but I don't know if I'd have come to that realisation myself as quickly without developers in better languages criticising it.\n\nCertainly when I started I was a stereotypical self-taught LAMP developer who just hacked stuff together without any thought. And I think that's not only due to the shortcomings of PHP itself but also its culture (for example, the shitty tutorials on w3schools and the like).\n\nI have improved a lot since then and part of that is by reading criticism of the kind of development I was practising. It doesn't matter if that comes from other PHP developers or developers of other languages. Personally I'm grateful for that criticism and I think if everyone just talked to other users of their language, there would be a lot less spread of good ideas.\n\nA case in point: [PHP: a fractal of bad design](http://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/). Written by a Python developer. When I read this I was aware of PHP being a bit shit, but that really spells out in detail how shit. It's educational and I think can help PHP developers, even if they stay in PHP."], [6, "I've interviewed hundreds of people.  The ones who primarily wrote PHP and JS, and to a lesser extent, Java, were much more likely to do poorly at basic programming tasks before and during an interview (we gave a take-home exercise before bringing people in).  These weren't anything crazy, just things that require code on the order of a loop or two.  Of those people who did poorly on the exercises, the ones we hired anyway were very likely to do poorly on the job.  Sometimes generalizations are appropriate. :(\n\nAnd the author's hand-wringing about \"keeping women out of STEM\" is just ridiculous.  (Woman here.)"], [9, "> My self-taught narrative is not other peoples\u2019 self-taught narrative, and I was very firmly reminded of that. Other self-taught narratives, such as starting with Wordpress-based design backgrounds and moving from more simple themes to more complex themes where PHP knowledge is required, to plugin development is a completely valid narrative, but a path that is predominately for women.\n\nThis is hands-down the most sexist thing I have read in a long while.\n\n> Find some amazing project to celebrate in a language you\u2019re contemptuous of.\n\nI tried. Boy did I try. But after 20 years, I'm done. PHP really is that bad, if not the language, then the culture. And when I say \"bad\", I mean toxic and outright reckless. Voicing criticism of this language, and anyone who knowingly and willingly uses (or even advocates) it, is not only OK, but a moral duty. OTOH, calling out everyone who uses it as a moron is idiotic and shouldn't be happening; but if you read carefully, 90% of the criticism doesn't actually do that at all. They're not saying, \"if you use PHP, then you are a moron and I'm going to ignore you\", they're saying, \"if you use PHP, then you should stop, and here's why\"."], [6, "\"There are two kinds of programming language: the ones everybody complains about, and the ones nobody uses.\" - Bjarne Stroustrup (creator of C++)"], [6, "Unexpectedly about PHP mostly, kek."], [6, "> I\u2019m tired of people dumping on Windows, that most popular operating system, because it\u2019s not what we choose to use\n\nI don't 'dump on' Windows because it's the most popular OS. I 'dump on' Windows because Microsoft has done illegal things to essentially force it to be the most popular OS. [Microsoft is a convicted monopolist.] (https://en.wikipedia.org/wiki/United_States_v._Microsoft_Corp.) Microsoft very frequently [plays dirty](https://en.wikipedia.org/wiki/Criticism_of_Microsoft), using FUD tactics and their stranglehold on the market to get what they want. Insult to injury that Windows is probably one the [worst written pieces of software](https://en.wikipedia.org/wiki/Criticism_of_Microsoft_Windows) in the history of the industry. [It even extends to the user programs](https://en.wikipedia.org/wiki/Internet_Explorer#Security_vulnerabilities). But that doesn't matter, [because Microsoft is bullying the OEMs](https://en.wikipedia.org/wiki/Bundling_of_Microsoft_Windows).\n\nIf Microsoft was capable of playing by the rules, and not resort to illegal means to advance its agenda, I wouldn't take issue. If Windows was \"just anther OS\", which gained its market dominance by fair means, I wouldn't care.\n\nBut doing illegal things to forcibly shove trash onto everyone in a bid for domination is **not** something I'm okay with.\n\n/endrant\n\nIt's a serious frustration point for me that people think I bash Microsoft \"because they're popular\" or \"because my choice of OS isn't the market leader\". I do it \"because they are a lot of bastards that are willing to go to illegal lengths for money, and need to be shut down\"."], [5, "So the solution is to control the speech of every programmer working in the field today who says negative things? Let me know how that goes for you."], [6, "Why is it acceptable to insist that all languages are equally good? That we are not as programmers allowed to bash languages with horrible choices.\n\nThis is my career, I have spent years upon years learning a dozen languages. PHP is the worst. By far. I am going to tell you my opinion if you ask, and honestly, that it is shit.\n\nJava is better. Ruby is better. C# is better. Basically any other language that isn't intentionally a joke / toy is a more appropriate choice than PHP. If saying so offends your delicate sensibilities, maybe you shouldn't be talking to others.\n\nThere are languages that suck. You don't suck if you only know that language. I hold no animosity towards you as a programmer. You can write great software in a shitty language. But don't act like Brainfuck and C++ are on the same level."], [4, "PHP is now great because... Women? "], [1, "When people heap criticism on a programming language, there's usually a good reason: it's popular.\n\nThe natural response people have toward other people doing what they do, but differently, is to question the differences in the other's approach.  This makes sense.  You've figured out how to solve a problem, so obviously you have found *the* solution.  With a little bit of introspection, you could come to the conclusion that there might be more than one way to solve the problem.  However, you're often busy moving on to the next problem to solve, so the next best thing to do is question the other guy.\n\nThis isn't necessarily a bad thing, as long as we remember to question *choices*, but not *people*.  However, we have to remember that the other people are feeling the same things that we are.  They're probably feeling the same way you feel about their solution about yours.  The only difference is that they were polite enough to not say anything.  But now, you're attacking their ideas.  It's time to go on the offensive and regain some ground!\n\nAnd a flamewar starts.\n\nI think that it's important for us to engage those with differing ideas, not by changing *what* we are saying, but changing *how* we say it.  Instead of...\n\n\"Java Sucks.  You can't write maintainable software in it.\"\n\nTurn it around.\n\n\"I have a hard time figuring out how to write maintainable software in Java.\"\n\nThe latter is more correct.  Your intentional exclusion of yourself from that technology's conversation means that you are naturally unable to perceive new solutions to the problems with it.  Even if you still use the technology, your *attitude* about it makes it impossible for you to take a positive approach in evaluating those solutions.\n\nAt the end of the day, we're all doing pretty much the same thing.  The negativity might actually be the greatest source of difficulty in building good programming communities.  You don't have to like alternative solutions, but your own intellectual honesty in discussing your problems with those solutions with their proponents can really make or break the attitude of the conversation.\n\nUnless you like Perl.  Shouldn't you be selecting beard balm?\n\nEDIT: As an aside, I completely disagree with the assertion that this attitude is the reason some technologies have inferior tool experiences.  The fact that it stinks to write Python on Windows (less now than it used to) has everything to do with the average developer of Python software using an operating system other than Windows than their bias against Windows.  If I don't use your platform, I shouldn't be held to write tools for your platform.\n\nIf you want good tools, write 'em yourself.\n\nEDIT: Changed the language used in the example because apparently insinuating that a rational human being could like PHP induces brain damage."], [1, "This is a good post, but I'm not surprised to see the comments dodging its main point and battling straw men.\n\nLet's all just pretend that we never attack PHP or Java *developers*, all our vitriol is directed at the languages, and we only spew it to help others. Now tomorrow can be business as usual and our toxic culture can live on."], [0, "Every programming language which has been around for any reasonable length of time has been providing sufficient solutions for a reasonably large group of people. \n\nWhat I like to think about is for what type of project is each language appropriate ?  I use $PHP for little web pagey things. It works great.  I wouldn't choose anything else.   But I would not write a next gen ERP system in PHP.   \n\nI think a danger zone exists when a programmer learns a language in one space, and then attempts to use that same language in a space where a different lanugage would be a far better choice.  This is why polyglot programmers are better, they're more likely to choose the appropriate tool for a particular job.\n\nAnd it's not just languages, it's tools as well.  Checkout the flame wars that start when people talk about Java IDEs.\n\nLots of people have mentioned the \"I have a hard time figuring out how to write maintainable software in PHP.\"   The key thing here is that you can't flame something you haven't tried to do.  If you are a Ruby programmer flaming java for \"being too wordy\"  then you had better have spent a year or so writing java with an appropriate toolset before you state that.\n\nToo many people just slag on things they haven't actually spent the time to use properly."], [0, "Modern PHP is such a different beast. Applications developed by sane people using good PHP frameworks and design patterns resemble anything but the old crappy PHP spaghetti that uninformed trolls love to bash on.\n\nSource: I`ve been a full-stack developer for over a decade. Worked with most of the mainstream tech stacks and all sizes of teams including Python Django, ASP.NET C# MVVM, Java Spring, Node.js express but mostly PHP Zend and Symfony frameworks."], [-2, "Probably one of the most well-written articles I've read in a while.\n\nI have made my living developing in PHP since '99, but since around mid 2005 and to this day, I have felt awkward admitting as much to other developers. I freely admit and concede some of the more objective criticisms of the language, and as I start to look at other languages, I see them in real-life scenarios almost every day. But still, I enjoy writing it, I enjoy my job.\n\nNow until mid-article, I thought I had little to worry about in the unfairness department until I saw this bit\n\n> ..growing contempt around people whose first or primary language is JavaScript\n\n...oh s**t son, that's me.\n\nWell guess what? I'm going to stop. Why? Because [Personal] introspection tells me that the reason for my contempt is to be exclusionary for the purposes of entry to the \"Backend Developers\" club. Precisely what the OP is writing about."], [-2, "tl;dr:\n\n>don't talk smack about muh PHP, because minorities\n\nDon't let the door slap your ass on the way out, toots"]], [[{"comment": "As I read it, I was following the remarks about how the writer was mocking other languages for bad reasons, but then suddenly it skips to women and minorities.\n\nI am not sure if the writer somehow feels his remarks about PHP damaged women and minorities (how?), or if they only see it as a metaphor for that.", "id": "czv6xi5"}, {"comment": "I was also confused by this. The author claims that \"starting with Wordpress-based design backgrounds\" is \"predominately for women\" and that they were \"actively participating in the exclusion of women from STEM\", but doesn't explain how they came to these conclusions. I was not aware that starting with Wordpress themes was \"predominately for women\". In all honestly, unless there are statistics (or at least some sort of logical reasoning) to support this, then saying this path is predominately for women is fully based on the stereotype that women prefer visual things over logical things.", "id": "czv8s8z"}, {"comment": "The worst of the stereotype is that I don't really see where it is. My experience has been quite the opposite, most of the women I know in tech started with low-level stuff. The majority of them started as digital hardware engineers. The one who works on the \"highest-level stuff\" is an AI researcher at Google. I only know one woman who came to tech from a designer background, but she sticks to UX-design, not coding, and was originally an industrial designer. Even then most of the people I know from that background are men, and the ratio in that specific sub-set is far far worse than the opposite.\n\nThen again I might be lucky and only see a small view. There might be research and studies that support them, but as far as I can tell this view does come from stereotypes.", "id": "czvdh6g"}, {"comment": "Yeah, I felt like the women-and-minorities thing was shoe-horned into the article *hard*, and that the article would have been better off without it.\n\nI'm working hard on not being such a toxic douchewad, and it's not because of women and minorities. It's because I, as a white, cis male have been on the receiving end of venom similar to mine and I didn't like it. It's entirely self-serving.\n\nWe (people like me) could all endeavour to be a little more pleasant to each other, and we would - by default - end up being nicer and more welcoming to women and minorities as well. Those who wouldn't, won't be persuaded by the SJW language because they're bigots.", "id": "czvbpy3"}, {"comment": "I feel in the middle of this thing too.\n\nA couple of months ago, my mate, who is as liberal as they come, got accosted at an LGBT party. His friend, who is also an acquaintance of mine, and who is, I believe, perfectly gay-friendly, had been trying to help out a transsexual girl who was trying unsuccessfully to order a beer. But he mistakenly referred to her as \"he\", which, it turns out, she really hates.\n\nShe sought him out in an alley and punched him and dislocated his jaw, which meant a trip to the hospital and, I think, pins in his head.\n\nThis caused repercussions in the community, with my mate being called out as transphobic because he was trying to support the other guy while he was getting beat up, even though my mate is probably, literally the least judgemental guy you will ever meet, and had given lots of support to LGBT causes himself.\n\nI know that was just one girl, in one situation, in one place, but I am starting to feel like this is getting out of hand too.\n\nI noticed the article was full of rhetorical codewords, which made it feel like it was coming out of someone else's mouth, but I think \"SJW\" is a codeword for the other side. I wish people would stop using it.", "id": "czvdpbv"}, {"comment": "> I noticed the article was full of rhetorical codewords, which made it feel like it was coming out of someone else's mouth, but I think \"SJW\" is a codeword for the other side. I wish people would stop using it.\n\nShrug.  Mega-lefty here, and I don't think 'SJW' is so bad.  It does have bad connotations for some people, including marking someone out as a member of a 'side'.  \n\nI've started using \"authoritarian left\" to describe 'SJWs'.  It's nice in that it's descriptive and not overtly judgmental, but it's a bit of a mouthful, and doesn't have a nice singular form.\n\nPS: That's was a really shitty situation you described.  I'm sorry that happened to your friend; there isn't any excuse for what those people did to him.", "id": "czvjeja"}, {"comment": "Was the tranny convicted for aggravated assault?", "id": "czvk5dg"}, {"comment": "I'm not sure how things stand at the moment. Last I heard I think it was under review.", "id": "czvsuuw"}, {"comment": "What's \"under review\"? Which jurisdiction is that?", "id": "czw59dd"}, {"comment": "I meant that the cops were investigating the situation. It was complicated because, IIRC, the people who attacked my friends alleged that it was transphobia-related. (This happened in the Netherlands.) I don't really want to claim much more about it because I haven't seen my friends in a while and so frankly I don't know the outcome, although if you are really interested I could find out.", "id": "czw95a5"}, {"comment": "> It was complicated because, IIRC, the people who attacked my friends alleged that it was transphobia-related. (This happened in the Netherlands.)\n\nThanks. I thought it was either prosecutor's review (whether to press charges or drop them), or an appeals stage (judicial review).\n\nMostly I'm wondering if there's some way to disprove a hypothesis that the assault in question is related to an attitude common to a certain kind of holier-than-thou LGBT activist types, where they'll justify pre-planned gang-style violence with an excuse they'd scrounge up (\"he said something inexcusable earlier that night, so we ganged up and hospitalized him!\"). Certainly an investigation shouldn't be dropped by such allegations on the perpetrator's part.", "id": "czwlits"}, {"comment": "Tranny is a pejorative term.", "id": "d40tcm6"}, {"comment": "No way. SJWs are too fucking real. There is no better term to describe this stinky lot.", "id": "czvvgsu"}, {"comment": "If someone is rude to me, I assume it's because they're not very nice or something.\n\nIf someone is rude to a woman, it's because they're sexist!  \nIf someone is rude to a black person, it's because they're racist!  \netc.\n\nI think people tend to assume that any vitriol pointed at someone that isn't a white male is bigoted. ", "id": "czvuqaj"}], [{"comment": "What a lot of bullshit! If he has been talking shit about users of other languages as if they are inferior, that is his problem.\n\nBut don't tell me that I can't criticize a programming language for being bad. As long as you criticize an idea rather than people, there is nothing to excuse here. To make this into people getting offended , well that is just indicative of another disease spreading: the disease of micro aggressions. People having developed this ridiculous notion that they have a right to not be offended by way of somebody holding different views or opinions than them on a subject.\n\nBoth democracy and science is dependent on our ideas getting challenged by others. You will learn nothing if all you do is retreating to a cave of likeminded people holding the same views.\n\nIn my case I programmed C++ for over 13 years. I think it is a terrible language, and I have very many reasons for thinking that, which I will happily iterate in any debate. You don't need to agree with me, but you don't have a right to demand that I shut up about telling people why C++ sucks, just because you happen to think C++ is the best thing since sliced bread.\n\nI think OP is attacking a strawman. It isn't criticism of other languages which is a problem, but when people start posturing trying to make themselves look better by using language X, and telling everybody else they are stupid.\n\nThis just reminds me of people who says we can't criticize religion because that offends religious people. Screw that I am not going to listen to that. The mere suggestion is frankly offensive.", "id": "czvcw6d"}], [{"comment": "Ok, now PL-theory debates are getting branded as harming minorities. Keep your hands off the science you SJW retards!", "id": "czv7g2h"}, {"comment": "This just in: calling Rust a B&D language is _suuuper_ offensive to the descendants of black slaves in the US. Synergy!", "id": "czv7nrv"}], [{"comment": "I don't agree with this. The language I heap the most criticism on is PHP. It is my least favourite language by far. I am a PHP developer so according to the article that's OK, but I don't know if I'd have come to that realisation myself as quickly without developers in better languages criticising it.\n\nCertainly when I started I was a stereotypical self-taught LAMP developer who just hacked stuff together without any thought. And I think that's not only due to the shortcomings of PHP itself but also its culture (for example, the shitty tutorials on w3schools and the like).\n\nI have improved a lot since then and part of that is by reading criticism of the kind of development I was practising. It doesn't matter if that comes from other PHP developers or developers of other languages. Personally I'm grateful for that criticism and I think if everyone just talked to other users of their language, there would be a lot less spread of good ideas.\n\nA case in point: [PHP: a fractal of bad design](http://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/). Written by a Python developer. When I read this I was aware of PHP being a bit shit, but that really spells out in detail how shit. It's educational and I think can help PHP developers, even if they stay in PHP.", "id": "czv7f8z"}, {"comment": "I also disagree with the author. The idea that calling out a language for being a piece of shit is insulting to its practitioners reeks of entitlement.\n\n\"Don't say anything bad about my language! BUT MUH LANGUAGE, it hurts me when you say search functions in the standard library should  standardize needle/haystack args\"", "id": "czv9hyq"}, {"comment": "This is the fine advocacy line I've tried to walk in public speaking (and concluded that I've failed, which I find both sad and liberating): it really is not true that all languages and frameworks are _any_ good, let alone _equally_ good. It's 2016, so we don't even have the excuse that Microsoft BASIC is the only game in town (it was when I bought my first computer, a Model I TRS-80, in 1979). So the way I see it is: programmers are smart people by definition, so why would I be so callous as to watch so many of them suffer needlessly?\n\nThe converse, of course, is that it's _very human_ to feel offended when someone criticizes a tool you've spent years mastering, and besides, mastering a new one\u2014even one with stellar conceptual foundations, like functional or logic programming\u2014still takes years, too. So between the emotional and economic loads, encouraging people to switch is asking _a lot_.\n\nI think, ultimately, this all goes back to education (rants about teaching \"computational thinking\" that don't even utter the word \"logic\" make me stabby), but that is its own special rant; I'm old and tired; and the odds of my changing the world are nil. Writing this sort of note requires about as much energy as I'm willing to put into these issues anymore.", "id": "czvdhb4"}, {"comment": "> programmers are smart people by definition\n\nYou've got some really weird definitions here. Programmers are people. The same good old bell curve thing applies.", "id": "czveuow"}, {"comment": "> Programmers are people. The same good old bell curve thing applies.\n\nWithin the domain of programmers, sure. I'm relating the domain of programmers to the domain of the general population.", "id": "czvgg57"}, {"comment": "I'm yet to see any evidence that programmers are not selected uniformly from the general population. Average programmer IQ is still the same, 100 points.", "id": "czvuw7k"}, {"comment": "Even if we accept both the assumption that IQ is a reasonable measure of intelligence, and that the average programmer IQ is 100, how does that in any way change:\n\n> so why would I be so callous as to watch so many of them suffer needlessly?\n\nTo me, it sounds like you're saying the merely average in intelligence should be stuck with crappy tools!", "id": "czw2p21"}], [{"comment": "I've interviewed hundreds of people.  The ones who primarily wrote PHP and JS, and to a lesser extent, Java, were much more likely to do poorly at basic programming tasks before and during an interview (we gave a take-home exercise before bringing people in).  These weren't anything crazy, just things that require code on the order of a loop or two.  Of those people who did poorly on the exercises, the ones we hired anyway were very likely to do poorly on the job.  Sometimes generalizations are appropriate. :(\n\nAnd the author's hand-wringing about \"keeping women out of STEM\" is just ridiculous.  (Woman here.)", "id": "czv9urj"}, {"comment": "I think this kind of has to do with the huge repository of copy/pasteable shit code all over the internet in php and javascript, because they have been around so long and the nature of them allows people to just copy/paste functions with no context, framework, etc.\n\nPeople are able to call themselves 'programmers' and understand virtually nothing about what they are doing, yet still actually get work done because they can fight with ishtar's indian code in the comments of php.net", "id": "czv9wy7"}], [{"comment": "> My self-taught narrative is not other peoples\u2019 self-taught narrative, and I was very firmly reminded of that. Other self-taught narratives, such as starting with Wordpress-based design backgrounds and moving from more simple themes to more complex themes where PHP knowledge is required, to plugin development is a completely valid narrative, but a path that is predominately for women.\n\nThis is hands-down the most sexist thing I have read in a long while.\n\n> Find some amazing project to celebrate in a language you\u2019re contemptuous of.\n\nI tried. Boy did I try. But after 20 years, I'm done. PHP really is that bad, if not the language, then the culture. And when I say \"bad\", I mean toxic and outright reckless. Voicing criticism of this language, and anyone who knowingly and willingly uses (or even advocates) it, is not only OK, but a moral duty. OTOH, calling out everyone who uses it as a moron is idiotic and shouldn't be happening; but if you read carefully, 90% of the criticism doesn't actually do that at all. They're not saying, \"if you use PHP, then you are a moron and I'm going to ignore you\", they're saying, \"if you use PHP, then you should stop, and here's why\".", "id": "czvdano"}], [{"comment": "\"There are two kinds of programming language: the ones everybody complains about, and the ones nobody uses.\" - Bjarne Stroustrup (creator of C++)", "id": "czv4fpb"}, {"comment": "He would say that.", "id": "czv7ld7"}, {"comment": "The third one is kept secret.\n\n(He makes an off by one error, probably, unknowingly)", "id": "czv7hgg"}, {"comment": "Of course that doesn't mean that any language people complain about SHOULD be used, or that the magnitude of complaints somehow indicates usability. COBOL has been heavily used and complained about. I hope nobody thinks that implies that COBOL was a good programming languages, or that one could not have used better suited ones.", "id": "czvdql0"}], [{"comment": "Unexpectedly about PHP mostly, kek.", "id": "czv4wyg"}], [{"comment": "> I\u2019m tired of people dumping on Windows, that most popular operating system, because it\u2019s not what we choose to use\n\nI don't 'dump on' Windows because it's the most popular OS. I 'dump on' Windows because Microsoft has done illegal things to essentially force it to be the most popular OS. [Microsoft is a convicted monopolist.] (https://en.wikipedia.org/wiki/United_States_v._Microsoft_Corp.) Microsoft very frequently [plays dirty](https://en.wikipedia.org/wiki/Criticism_of_Microsoft), using FUD tactics and their stranglehold on the market to get what they want. Insult to injury that Windows is probably one the [worst written pieces of software](https://en.wikipedia.org/wiki/Criticism_of_Microsoft_Windows) in the history of the industry. [It even extends to the user programs](https://en.wikipedia.org/wiki/Internet_Explorer#Security_vulnerabilities). But that doesn't matter, [because Microsoft is bullying the OEMs](https://en.wikipedia.org/wiki/Bundling_of_Microsoft_Windows).\n\nIf Microsoft was capable of playing by the rules, and not resort to illegal means to advance its agenda, I wouldn't take issue. If Windows was \"just anther OS\", which gained its market dominance by fair means, I wouldn't care.\n\nBut doing illegal things to forcibly shove trash onto everyone in a bid for domination is **not** something I'm okay with.\n\n/endrant\n\nIt's a serious frustration point for me that people think I bash Microsoft \"because they're popular\" or \"because my choice of OS isn't the market leader\". I do it \"because they are a lot of bastards that are willing to go to illegal lengths for money, and need to be shut down\".", "id": "czvf5sp"}], [{"comment": "So the solution is to control the speech of every programmer working in the field today who says negative things? Let me know how that goes for you.", "id": "czv6dig"}], [{"comment": "Why is it acceptable to insist that all languages are equally good? That we are not as programmers allowed to bash languages with horrible choices.\n\nThis is my career, I have spent years upon years learning a dozen languages. PHP is the worst. By far. I am going to tell you my opinion if you ask, and honestly, that it is shit.\n\nJava is better. Ruby is better. C# is better. Basically any other language that isn't intentionally a joke / toy is a more appropriate choice than PHP. If saying so offends your delicate sensibilities, maybe you shouldn't be talking to others.\n\nThere are languages that suck. You don't suck if you only know that language. I hold no animosity towards you as a programmer. You can write great software in a shitty language. But don't act like Brainfuck and C++ are on the same level.", "id": "czv9pvf"}, {"comment": "That's not the point at all. There are other factors than technical excellence - you could write a technically flawless piece of malware, or a shittily coded website that helps reunite lost puppies with their owners. I know which one I'd prefer in existence.", "id": "czvaefm"}, {"comment": "You're talking about applications, the rest of us are discussing languages used to write applications.", "id": "czvce9b"}], [{"comment": "PHP is now great because... Women? ", "id": "czveekn"}], [{"comment": "When people heap criticism on a programming language, there's usually a good reason: it's popular.\n\nThe natural response people have toward other people doing what they do, but differently, is to question the differences in the other's approach.  This makes sense.  You've figured out how to solve a problem, so obviously you have found *the* solution.  With a little bit of introspection, you could come to the conclusion that there might be more than one way to solve the problem.  However, you're often busy moving on to the next problem to solve, so the next best thing to do is question the other guy.\n\nThis isn't necessarily a bad thing, as long as we remember to question *choices*, but not *people*.  However, we have to remember that the other people are feeling the same things that we are.  They're probably feeling the same way you feel about their solution about yours.  The only difference is that they were polite enough to not say anything.  But now, you're attacking their ideas.  It's time to go on the offensive and regain some ground!\n\nAnd a flamewar starts.\n\nI think that it's important for us to engage those with differing ideas, not by changing *what* we are saying, but changing *how* we say it.  Instead of...\n\n\"Java Sucks.  You can't write maintainable software in it.\"\n\nTurn it around.\n\n\"I have a hard time figuring out how to write maintainable software in Java.\"\n\nThe latter is more correct.  Your intentional exclusion of yourself from that technology's conversation means that you are naturally unable to perceive new solutions to the problems with it.  Even if you still use the technology, your *attitude* about it makes it impossible for you to take a positive approach in evaluating those solutions.\n\nAt the end of the day, we're all doing pretty much the same thing.  The negativity might actually be the greatest source of difficulty in building good programming communities.  You don't have to like alternative solutions, but your own intellectual honesty in discussing your problems with those solutions with their proponents can really make or break the attitude of the conversation.\n\nUnless you like Perl.  Shouldn't you be selecting beard balm?\n\nEDIT: As an aside, I completely disagree with the assertion that this attitude is the reason some technologies have inferior tool experiences.  The fact that it stinks to write Python on Windows (less now than it used to) has everything to do with the average developer of Python software using an operating system other than Windows than their bias against Windows.  If I don't use your platform, I shouldn't be held to write tools for your platform.\n\nIf you want good tools, write 'em yourself.\n\nEDIT: Changed the language used in the example because apparently insinuating that a rational human being could like PHP induces brain damage.", "id": "czv3hr7"}, {"comment": "> When people heap criticism on a programming language, there's usually a good reason: it's popular.\n\nOr maybe it's because the language is actually positively bad / harmful. Which, I believe, is the case for PHP.\n\nPHP the language comes with PHP the community and PHP the culture, and those have a peculiar set of priorities: Getting Shit Done, at the expense of everything else, above all correctness and theoretical soundness. The mantra is, just write what you want done, and we'll see about the rest later. It's a very productive approach for the first few days and weeks of a project, but after that, it becomes toxic, and you have to suffer severe tunnel vision to stick with it for more than a few years of your career. That is why PHP is bad - not because it's full of bugs and inconsistencies and idiotic design decisions and badly named functions cluttering an gargantuan global namespace: those things are just symptoms. The real badness is in the toxic culture that has reckless priorities cemented into its collective conscience and will not tolerate a significant change in this arena.", "id": "czvcc9w"}, {"comment": "I feel like you've maybe missed the entire point of the article, and my response.  The merits of PHP have nothing to do with this.  You locked on a problem you had with the example I gave.  I could easily replace PHP with \"Java\" or \"C#\" or \"Python\" in my response, and it would have the same meaning.", "id": "czvckg1"}, {"comment": "> \"PHP Sucks. You can't write maintainable software in it.\"\n\n> Turn it around.\n\n> \"I have a hard time figuring out how to write maintainable software in PHP.\"\n\nBetter yet, \"I have a hard time figuring out how to write software in PHP that is as maintainable as the software I can write in $LANGUAGE because of $THING_I_CAN_DO_IN_LANGUAGE_BUT_CANT_IN_PHP\".\n\nWhen talking about the advantages and disadvantages of something, it's often useful to know what you're comparing it to.  For example, the advantages and disadvantages of Java are very different when you're comparing it to C than when you're comparing it to Haskell.", "id": "czv7l42"}, {"comment": "True, but it's also important to note the context.\n\n\"I have difficultly doing <type of work> in <language> because I don't know the equivalent of <feature> in <other language>.\"\n\nOtherwise you end up with fanboys, trolls and the easily distracted engaging in a game of \"who's got the biggest feature list\".  (As an example of this phenomenon, look at what happens every time someone compares C#\u00a0with anything: [here's a recent example](https://www.reddit.com/r/programming/comments/438tr4/what_ive_learned_about_net_native/czh6vfu) )", "id": "czv9ht0"}, {"comment": "Sure.  Arguments with substance are always better than ones without.  The point of the matter is avoiding criticizing the PHP programmer when what you intended to criticize is PHP itself.", "id": "czv9539"}, {"comment": ">Unless you like Perl. Shouldn't you be selecting beard balm?\n\nI like Perl and have never had a beard.\n\n", "id": "czvfmwl"}, {"comment": "That was a joke.  ;). Perl is okay.", "id": "czvfpxi"}, {"comment": "Yes, I was trying to play along, my joke was bad :(.  I'm sorry, I'll go grow a beard.", "id": "czvk10d"}, {"comment": "It's okay.  You can't get good at it without trying :)\n\nYou're better off with the beard, anyway.", "id": "czvk7xu"}, {"comment": ">  \"PHP Sucks. You can't write maintainable software in it.\"\n> \n> Turn it around.\n>\n>\"I have a hard time figuring out how to write maintainable software in PHP.\"\n\nThis... Removing yourself from the above statement removes yourself of the responsibility of actually figuring it out. Stop being lazy, stupid, and ignorant. Learn something new!", "id": "czv4yve"}, {"comment": "Learn something ill designed and thoroughly broken instead of choosing any sane technology? Well, the only legitimate reason to closely study PHP is to learn how *not* to design languages.", "id": "czv7njp"}, {"comment": ">Well, the only legitimate reason to closely study PHP is to learn how *not* to design languages.\n\nYou're indeed correct, because PHP *wasn't designed*. It started as a pile of scripts that grew because people wanted more features out of it.", "id": "czvb0wn"}, {"comment": "You're part of the problem.", "id": "czv8jsw"}, {"comment": "Thanks for proving the point of OP's article above.", "id": "czv8l8u"}, {"comment": "What exactly is not true of what I've said? I do not care if anyone get offended, but on a PL design side - where exactly am I wrong?", "id": "czv92y3"}, {"comment": "Maybe it is hard to write maintable software in certain languages because they are shit.\n\n> Brainfuck sucks, you can't write an os in it\n \n> i have a hard time figuring out how to write an operating system in a joke language\n\n", "id": "czv9k8t"}, {"comment": "BrainfuckOS is the future!", "id": "czvpi95"}, {"comment": "Funny how people who don't like their language getting criticized so easily grasp at the defense that you simply don't know my language. When in fact the direct opposite is more often the case IMHO. People stick to shit language because they are to lazy to learn something else and expand their narrow horizon.\n\nEvery time I have argued with people in person why the language they use isn't any good, they typically know their language very good at all, nor do they have much grasp of the alternatives.\n\nI admit not knowing much about JavaScript, but I am surprised by how people who have programmed JavaScript for years and love it are so clueless about even basic stuff in JavaScript.\n\nThis is quite different from say the hate I experience towards say Objective-C, where people just rant about how terrible it is because they just looked at the syntax and didn't like it.", "id": "czve5lj"}, {"comment": "> Learn something new!\n\nOr don't!  I don't care!  Just don't blame the technology for your lack of understanding in it!", "id": "czv52vd"}, {"comment": "PHP is Rube Goldberg kind of mess that often breaks in unexpected ways.", "id": "czv7iw0"}, {"comment": "My argument had nothing at all to do with PHP itself.  Replace \"PHP\" with any other technology you like or dislike and the meaning remains the same.", "id": "czvcmdw"}, {"comment": "Actually, none of the valid critics of PHP are of the type who doesn't understand PHP. Almost all of them (us?) are the kind who has been dealing with PHP for years, due to the economics of the software development job market, and, being familiar with a half dozen or more languages, all of which do virtually everything better than PHP, are thoroughly fed up with it.", "id": "czvcfl0"}, {"comment": "You may be right, but you're also missing the point.  This isn't about PHP at all.", "id": "czvcixz"}, {"comment": "It is, though.\n\n> \"PHP Sucks. You can't write maintainable software in it.\"\n\nTo which you replied:\n\n> Just don't blame the technology for your lack of understanding in it!\n\nAnd in this context, I'm saying that if an intelligent person who has no trouble figuring out any given mainstream programming language cannot figure out how to write maintainable software in one particular language after 20 years of trying hard and passionately, then maybe, just maybe, the conclusion that the particular language really is to blame might not be too far fetched. The particular language is PHP, both because that's the language that was mentioned earlier, and because it is literally the only mainstream language for which the verdict from highly experienced programmers is this devastating.", "id": "czvdpwg"}, {"comment": "Alright.  I've edited it for you.  The meaning has not changed.", "id": "czvdzmx"}], [{"comment": "This is a good post, but I'm not surprised to see the comments dodging its main point and battling straw men.\n\nLet's all just pretend that we never attack PHP or Java *developers*, all our vitriol is directed at the languages, and we only spew it to help others. Now tomorrow can be business as usual and our toxic culture can live on.", "id": "czvasm6"}, {"comment": "Sure people attack developers and look down on them. That is just people being shit heads though. Contempt for a language is not the same as contempt for its users. Some people are not able to grasp that, while the rest of us can acknowledge some languages are bad and some good programmers use those bad languages despite their flaws. And also bad programmers, but there are awful programmers in all ecosystems. ", "id": "czvcm93"}, {"comment": "The shitheads stand out more than people like you.", "id": "czw92zr"}, {"comment": "Well perhaps, but decrying debate around a language or toolset because some people are assholes is silly.", "id": "czw9j5u"}, {"comment": ">So when I started programming in 2001, it was du jour in the communities I participated in to be highly critical of other languages. Other languages sucked, the people using them were losers or stupid, if they would just use a real language, such as the one we used, everything would just be better.\n\nDoes that sound like debate, or people being assholes?", "id": "czwbpx2"}, {"comment": "People being assholes. Why would you continue frequenting places where this is the \"discussion\" that takes place? \n\nLike... if what she is describing actually took place on a forum or at a meetup... quit going?", "id": "czwc66g"}], [{"comment": "Every programming language which has been around for any reasonable length of time has been providing sufficient solutions for a reasonably large group of people. \n\nWhat I like to think about is for what type of project is each language appropriate ?  I use $PHP for little web pagey things. It works great.  I wouldn't choose anything else.   But I would not write a next gen ERP system in PHP.   \n\nI think a danger zone exists when a programmer learns a language in one space, and then attempts to use that same language in a space where a different lanugage would be a far better choice.  This is why polyglot programmers are better, they're more likely to choose the appropriate tool for a particular job.\n\nAnd it's not just languages, it's tools as well.  Checkout the flame wars that start when people talk about Java IDEs.\n\nLots of people have mentioned the \"I have a hard time figuring out how to write maintainable software in PHP.\"   The key thing here is that you can't flame something you haven't tried to do.  If you are a Ruby programmer flaming java for \"being too wordy\"  then you had better have spent a year or so writing java with an appropriate toolset before you state that.\n\nToo many people just slag on things they haven't actually spent the time to use properly.", "id": "czv6ts5"}, {"comment": "I disagree with your seemingly underlying assumptions that all languages are equally good. That is like telling all kids they are winners to make them feel good about themselves. You are not doing those kids any favors.\n\nYour hinting at the premise here that criticizers of a language have no clue about said language. As if the only reason to dislike a language is ignorance. That might be the worst interpretation of your statement. But a more sympathetic interpretation is that, while not always the case, this is the common case.\n\nNeither of us has any statistics to back up any of this but I got to say my personal experience points to the opposite. I find that a lot of fans of languages like Java, JavaScript, PHP, C++ etc have hardly ever tried anything else. They like it simply because they don't know anything better.\n\nYou know that is fine if you are happy with what you use. But it is rather tiring when people who have not basis for comparison triumphantly state that their language is the most awesome programming language ever.\n\nI used to developed C++ for many years and you know the ones most happy about C++, where the ones who knew the language the least well and no alternatives. I was originally a big C++ fan and tried to learn the language really well. I held workshops to get people to know modern C++, templates etc. Yet I found myself to be the one who come to hate the language the most of my colleagues.\n\nWhy is that? Because I found that despite years and years of investment in the language and lots of time spent getting good at it, still stuff keeps blowing up in your face. When you don't know the alternatives, you sort of accept that as a fact of programming. But as you start using other languages and notice, you spend far less mental capacity using this language and shit just doesn't blow up in your face anymore, then yeah you realize that C++ was in fact a dam big mistake.\n\nActually, it probably wasn't so much my own mistakes as the myriad of mistakes I saw other people make, which I realized simply wouldn't be possible in many other languages.\n\nWhen you realize your company is losing countless hours and money by using a technology causing a lot more problems than it solves, then you ought to speak out against it.\n\nI totally agree with your assessment that you should use the right tool for the job. But that is the very problem here. Far too many people use something like Java or C++ for every possible job, even when it is completely unsuited for the task. ", "id": "czvdkjf"}, {"comment": "Actually I don't think all languages are equal.  Far from it. You should hear my co-workers talk about my language complaining. Jokes abound! \n\nBut I do think that even 'crappy' language MUST have a reason why you and I have heard of them.  Let's leave the likes of brainfuck aside.  WHY has PHP been as \"successful\" as it clear has been ? .\n\nI can only think that it's really scarily easy to start writing PHP and feel productive in some way.  The onramp is quite simple. Lot's of people take it.   So if you are doing a bunch of \"onramps\"  perhaps PHP really is the right language( and in fact that is why if I have a simple two button web page to control a hacked up IoT think i built, it's PHP ).  The problem is when people stick with the familiar and try to extend using that language to a place where the language is an awful choice. ( My poster boy for this is a PHP framework called symfony ).\n\nMy point about having personal experience, and I don't mean a few hours of it, is that it's easy to jump on bandwagons by listening to all the online noise about which language is good or bad and even why.  This is a case where the loudest voices have the largest effect even when the basis of the judgements are flawed.  So what I really liked about this article is that the _phrasing_   where the \"I\" is included implies that not only you have tried a language, but that you're are prepared to defend your experience.\n\n\"When you don't know the alternatives, you sort of accept that as a fact of programming.\"  So True!  OMG,  when I realized how much less I was thinking about memory management.   And honestly, having done a decent amount of javascript recently, it's kinda nice not to have to think about concurrency issues.  I know I'm paying a price in other areas ( no real parallelism), but it does lower the mental energy.   But OH GOD, I miss strong(er) typing.  I think the likes of typescript have a strong future because it hits three sweet spots there.\n\n\n\n\n", "id": "czveksv"}], [{"comment": "Modern PHP is such a different beast. Applications developed by sane people using good PHP frameworks and design patterns resemble anything but the old crappy PHP spaghetti that uninformed trolls love to bash on.\n\nSource: I`ve been a full-stack developer for over a decade. Worked with most of the mainstream tech stacks and all sizes of teams including Python Django, ASP.NET C# MVVM, Java Spring, Node.js express but mostly PHP Zend and Symfony frameworks.", "id": "czvdihe"}, {"comment": "Yeah, I did write a big application once in zend framework in like 2009 and it was pretty fucking nice. It almost wasn't like php. But I have also used wordpress, and I'd rather commit genocide than suggest wordpress to anybody.\n\nThere is a real book, written recently, titled \"Wordpress as an application framework\" - that guy needs to be hung in public.", "id": "czw1ncr"}, {"comment": "Yep I agree that WordPress code is spaghetti. One would think that Automattic, being valued over 1 billion USD, could fix WordPress but AFAIK the main reason Wordpress code still resembles its initial versions is because of backwards compatibility. Half of the internet knows how to do stuff for Wordpress and changing it would be bad for business.\n\nAbout Zend. Frameworks are for PHP what jQuery is for JavaScript DOM manipulation: It just works.", "id": "czwfphb"}], [{"comment": "Probably one of the most well-written articles I've read in a while.\n\nI have made my living developing in PHP since '99, but since around mid 2005 and to this day, I have felt awkward admitting as much to other developers. I freely admit and concede some of the more objective criticisms of the language, and as I start to look at other languages, I see them in real-life scenarios almost every day. But still, I enjoy writing it, I enjoy my job.\n\nNow until mid-article, I thought I had little to worry about in the unfairness department until I saw this bit\n\n> ..growing contempt around people whose first or primary language is JavaScript\n\n...oh s**t son, that's me.\n\nWell guess what? I'm going to stop. Why? Because [Personal] introspection tells me that the reason for my contempt is to be exclusionary for the purposes of entry to the \"Backend Developers\" club. Precisely what the OP is writing about.", "id": "czv4q6i"}, {"comment": "If you are actually being exclusionary to other devs, then i'm glad you rethought your actions. But I argue that it is acceptable to discuss that javascript is kind of a fucking trainwreck *without* worrying that js devs will get really butthurt.", "id": "czv9ukh"}, {"comment": "This. If we let people get convinced that \"crappy language\" and \"used by protected political classes\" are strongly correlated, it will bring progress in PLT to a screeching halt. Yes, we can all likely do a better job of opening up the (white) boys' club. That goal is not furthered by pretending languages, etc. that suck don't.", "id": "czvdpba"}], [{"comment": "tl;dr:\n\n>don't talk smack about muh PHP, because minorities\n\nDon't let the door slap your ass on the way out, toots", "id": "czv7aj5"}]]], "4aootc": ["What US Software Developers Should Understand About The Rest Of The World.", "2016-03-16 20:53:29", 48, "https://medium.com/@did_78238/what-us-software-companies-should-understand-about-the-rest-of-the-world-783e8dbca758#.e8ty7addg", [[81, "This isn't about developers; it's about the companies who employ them. This doesn't seem relevant to /r/programming."], [40, "This article is a bit short-sighted.  The author should have reframed this as \"what US developers should understand about this Eastern European developer's opinions\".\n\n> You aren\u2019t always #1\n\nThis is a bit of a strawman.  It's seen across many industries, not just software, that products popular in one country are a complete flop in another.  This has been taught in business school for decades now.\n\n> Your prices are probably too high\n\nThe market sorts out prices, as the author indicates.  It's only when a company ignores the market that it suffers the consequences.  Something one would learn in a 100-level economics class.\n\n> You are paying your developers how much?\n\nAgain, the market sorts out prices.  You get what you pay for.\n\n> It really helps to have R&D office in Europe, India or Philippines, you definitely should consider this if you want to keep your dev costs down.\n\nThis only keeps salary cost down.  It doesn't keep development cost down: the cost incurred to develop a given unit of software.\n\nSE Asia doesn't exactly have a great reputation for software quality.  May be cheap to have software written there, but it'll be much more expensive to maintain that software in the long term.\n\n> *political rants*\n\nSeems the author is beating up strawmen, again.  Interesting that he is lambasting the valley for being in a bubble, yet fails to see past the end of his own nose. \n\n> Whether your startup generates profit or not, is not really important.\n\nThis author hasn't been paying attention to all the articles about \"the bubble\".  What \"the bubble\" really is, is that investors are no longer writing fat checks to startups that aren't successful.\n\nAll to say, yes, it's vitally important that your startup generates profit, otherwise it's going to flame out much quicker than in previous years."], [21, "Come on guys, despite the unnecessary jabbing style of this post, #3 gives me the butterflies right in the Impostor Syndrome and #4 I've had to deal with directly.\n\nNot interested in the little bubble I live in - I think this was insightful.  Just not sure about the over-bitching in the post."], [15, "[deleted]"], [12, "I would wager that a developer in the Ukraine lives with a higher standard of living than a developer in SF making 100k/year. Rents for a studio apartment are above 2k/mo in SF. Buying a shack to call home is over a million. Food is probably 5-10x Ukraine. "], [8, "> A good developer in Eastern Europe now costs $1000-$1500 a month.\n\nMy rent is $1500 a month."], [8, "[deleted]"], [4, "Though I think there are some good ideas here, some of this seems like nonsense. Right off the bat I thought that the comment about Dropbox wasn't quite on the mark. That policy isn't related to Prism. It is related to Dropbox not being a secure platform to secure personal information by design."], [3, ">that can guarantee that it will function in all Russia, including Crimea\n\nJust to be clear: Crimea is a part of Ukraine currently occupied by Russia. And, well, yes, if you start war against other country - you should be ready to live in isolated environment - and it is not a problem of US companies or US developers if Russia wants to go its own way without international laws, software and hardware. It's anyway impossible to have a business with a country where people ignore laws.\n"], [2, "Keep in mind the cost of living when comparing.\n\nExample: \n\nI'm in South Africa. Exchange rate around R16 per Dollar.\n\nRent = R4700 (Wifi & water & Geyser included)\n\nElectricity = R250\n\nVehicle = R2100 (2014 Chev Spark, no deposit, no balloon, 60 months)\n\nMobile data = R29/500MB LTE for GPS & Whatsapp\n\nFood = R2500\n\nFuel = R1400\n\nCar Insurance = R370\n\nCleaning Equipment = R200  (wahing powder etc)\n\nToiletries = R200\n\nCar Wash = R80\n\n\nSo in general I need about R12000 to survive and to service most of my obligations.\n\nIncome as a midlevel developer around is R23000 of which almost R4000 becomes tax. Thus you can see that even living \"comfortably\" I still have a lota left over money. Sure comparing to the US it seems like nothing, but I'm earning more than 80% (or more?) than the rest of the population in the country. I still have to budget for car services, licenses, web domain renewals etc.\n\nI don't smoke/drink so that means I can buy more snacks, healthy foods & proper fruit and I can afford more trips around town (meaning an extra 200 to 300 kilometers over a weekend, every weekend). I dont have medical aid (I dont get sick..) but that would cost me around R1500 to R2500 per month. I don't gym - I'm naturally lean so thats pretty cool.\n\nCurrently I buy all my food from woolworths (basically very upmarket food in this country), which is quite expensive. If I go shop around at markets (which we have plenty of them, but mostly only over the weekends and I need to go to the ATM to get cash), then I can get almost double the amount of fresh goods than from Woolies with the same money, and often time the same quality or better than WoolWorths.\n\n\nIf you have a partner with a decent income (above R10K per month), then you can start saving money and maybe think of buying property (ie after you start earning R30000 per month). \n\nAs time goes by and you start earning above R40000 per month, you are considered very rich. I know a few people who earns considerably more than this per month, but they usually get paid in dollars and work from home.\n\nLately with our government screwups, our economy is tanking, so things like food, electricity, electronics & other services - the prices are rapidly rising. For instance, I bought a brand new Lumia phone last year a month after release at R2500 with free shipping, that same phone cost R3400 now. A 128GB SSD that I bought in September cost R999, now R1300. So ya. \n\nAny questions?\n"], [1, "I would say something about the government, but then they would start reading my messages more than they already do."], [1, "This is the best tl;dr I could make, [original](https://medium.com/@did_78238/what-us-software-companies-should-understand-about-the-rest-of-the-world-783e8dbca758#.p5d598thj) reduced by 94%. (I'm a bot)\n*****\n> I think it&#039;s a good idea to give a general overview that would help US software companies to better understand what&#039;s going on with the rest of the world and why they may be failing in the foreign markets.\n\n> We now know that they have every right to be concerned about safety of their data stored with US companies.\n\n> Passed a law that allowed government and state corporations to only buy software from vendors that can guarantee that it will function in all Russia, including Crimea, essentially shutting out US companies from billions of dollars in government contracts.\n\n\n*****\n[**Extended Summary**](http://np.reddit.com/r/autotldr/comments/4tbbcq/what_us_software_companies_should_understand/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ \"Version 1.6, ~80168 tl;drs so far.\") | [Theory](http://np.reddit.com/r/autotldr/comments/31bfht/theory_autotldr_concept/) | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr \"PMs and comment replies are read by the bot admin, constructive feedback is welcome.\") | *Top* *keywords*: **company**^#1 **simply**^#2 **think**^#3 **really**^#4 **good**^#5"], [-1, "I wonder what the author thinks about open source software (one which is not developed by a company desiring to maximize profit with it) which is developed in the US."], [-3, "[deleted]"], [-3, "This was just a huge anti American rant. From my experience, US developers, especially silicon valley devs are paid a lot because we build cutting edge applications, try finding a competent foriegn angular or react developer, they'll be $100k + just like American devs.\n\nI"], [-6, "R&D in second world.... seriously?    You already admit that the concepts of daily life are drastically different.   Most companies ship maintenance out to 2nd world."]], [[{"comment": "This isn't about developers; it's about the companies who employ them. This doesn't seem relevant to /r/programming.", "id": "d127nfm"}, {"comment": "Yea I was expecting something about how fname/lname doesn't always work, or currencies, or timezones, or whatever.  Instead was just some dude complaining.", "id": "d12937g"}, {"comment": "agreed", "id": "d129fwg"}, {"comment": "that and also the author is a sales guy rater than engineering or product which really limits his perspectives. \n\nRe developer compensation, it is rather irrelevant how much an Eastern European dev makes compared to a U.S based one. With the current trend toward TDD, rapid prototyping and iterations it is essential for devs to be  in house (or remote from the same/similar time zone who can be in the office in an hour) as opposed to some devs who are thousands of miles and 10 time zones away. \n\nNot to mention with the way new frameworks come into vogue everyday (for better or for worse) a dev in Eastern Europe may not be sufficiently familiar with the latest tech stacks being deployed at U.S based companies to be as productive as their U.S counterparts who are immersed in these.", "id": "d12blhu"}, {"comment": "while I agree about timezone difference or on-premise presence, I don't think framework adoption is slower. it's not like it requires capital outlays to get the newest js thing, which would be a case for machinery, but not software. and developers in eastern europe like shiny new libraries as much as anybody else.", "id": "d135l9m"}, {"comment": "The cost of adopting a new framework is low. What I meant is that, given their geographic remoteness, the eastern euro devs are not plugged into the u.s ecosystem and may not be aware of which frameworks or modules are becoming popular in the valley.", "id": "d13cflv"}], [{"comment": "This article is a bit short-sighted.  The author should have reframed this as \"what US developers should understand about this Eastern European developer's opinions\".\n\n> You aren\u2019t always #1\n\nThis is a bit of a strawman.  It's seen across many industries, not just software, that products popular in one country are a complete flop in another.  This has been taught in business school for decades now.\n\n> Your prices are probably too high\n\nThe market sorts out prices, as the author indicates.  It's only when a company ignores the market that it suffers the consequences.  Something one would learn in a 100-level economics class.\n\n> You are paying your developers how much?\n\nAgain, the market sorts out prices.  You get what you pay for.\n\n> It really helps to have R&D office in Europe, India or Philippines, you definitely should consider this if you want to keep your dev costs down.\n\nThis only keeps salary cost down.  It doesn't keep development cost down: the cost incurred to develop a given unit of software.\n\nSE Asia doesn't exactly have a great reputation for software quality.  May be cheap to have software written there, but it'll be much more expensive to maintain that software in the long term.\n\n> *political rants*\n\nSeems the author is beating up strawmen, again.  Interesting that he is lambasting the valley for being in a bubble, yet fails to see past the end of his own nose. \n\n> Whether your startup generates profit or not, is not really important.\n\nThis author hasn't been paying attention to all the articles about \"the bubble\".  What \"the bubble\" really is, is that investors are no longer writing fat checks to startups that aren't successful.\n\nAll to say, yes, it's vitally important that your startup generates profit, otherwise it's going to flame out much quicker than in previous years.", "id": "d129xyc"}, {"comment": "Costs of remote administration of dev resources is non zero. ", "id": "d12bs2d"}, {"comment": "Costs of fixing non-native english speakers copywriting is also non zero. Applies to British vs American english as well.", "id": "d12i3s3"}, {"comment": "> May be cheap to have software written there, but it'll be much more expensive to maintain that software in the long term.\n\nHeck it will be much more expensive just to get it to pass QA.", "id": "d12huzk"}, {"comment": ">May be cheap to have software written there, but it'll be much more expensive to maintain that software in the long term.\n\nI would honestly much rather trust code written by people in Eastern Europe than trust code written by Americans under the nose of the NSA.\n\n>political rants\n\nThey're not political rants. Silicon Valley's VC bullshit **is** a bubble, **is** a ponzi scheme. When it bursts it will fuck a lot of people over.", "id": "d12pwzo"}, {"comment": "Right, because Mr. NSA sent agent Bob to stand over my shoulder while I code, or was that memo 666 from this morning, to compel me to install backdoors in all my programs. /s\n\nI'm sure most developer/companies don't like the  government tempering with their products. Besides, if a program is successful enough from Eastern Europe, I'm sure the NSA will get their tentacles on it. ", "id": "d12qfli"}, {"comment": "It doesn't really matter if you claim on /r/programming that the NSA doesn't literally sit over your shoulder while you program because I never claimed he did.\n\nThe fact is that the problem of the US government forcing US technology companies to insert backdoors in their products is a real one.", "id": "d12qi8t"}, {"comment": "> The fact is that the problem of the US government forcing US technology companies to insert backdoors in their products is a real one\n\nYou're leaving out numbers here.  How many products have been backdoored?  How many software products has the US produced in total?  Something tells me there's many orders of magnitude of difference between those two numbers.  Don't you think?", "id": "d12zw39"}, {"comment": "Oh, numbers.\n\nHow many \"National Security Letters\" are issued each year in the USA?   Just the FBI allone create 10000s a year. And the FBI isn't the only 3-letter agency doing them. The NSLs have the \"nice\" property that the receiver cannot publicly talk about them, they can't even oppose them at a real court.\n\nAnd then, for comparison, how many NSL-equivalents do the Netherlands, Denmark, Germany, Austria issue per year? Answer: zero, democratic countries don't have gag-orders.\n\nThat you want numbers is nice goal, but then first ask the US  government to play open. The US government makes drastic steps to keep things secret.\n\nAnd up to now Microsoft never really told us why there was an \"NSA Key\" in Windows.", "id": "d132jsq"}, {"comment": "> How many \"National Security Letters\" are issued each year in the USA?\n\nHow many of those dictate a backdoor?  How many of those are actually followed up on?  A letter does not magically make a door appear.\n\n> That you want numbers is nice goal\n\nNo, numbers should be the crux of anyone's argument.  If they point to one thing and say 10,000 other things are suspect, I can't take them serious.  Now if they point to 100 things and say 1,000 others are suspect, then we might start talking.", "id": "d13iz4b"}, {"comment": "Every single copy of Android, Windows, Windows Phone, iOS and OS X will have backdoors in them.", "id": "d1300r4"}, {"comment": "Source please", "id": "d13118r"}, {"comment": "The PATRIOT Act.", "id": "d131335"}, {"comment": "You've postulated (not confirmed) a half-dozen pieces of software are suspect.  Out of how many tens of thousands of projects?  You do realize how insignificant a fraction this actually is, yes?", "id": "d13ivjg"}, {"comment": "A Ponzi scheme and a bubble are two very different things.", "id": "d12u3ld"}, {"comment": "Yet they are not mutually exclusive.", "id": "d12z5x5"}, {"comment": "Fed inflated bubbles give first value to those who they inflate for so its quite like a ponzi. ", "id": "d132340"}, {"comment": "> Silicon Valley's VC bullshit is a bubble\n\nVC-funded startups go bust all the time.  It is the very nature of a startup.  Maybe 1 in 10 startups even make it to a second round of financing.  Out of those, maybe 1 in 20 will become profitable, be acquired, or IPO.  This has been the norm as long as venture capital has existed.\n\nIf VCs decide to pack up and go home, there may be a few thousand folks out of work, okay.  But not for long.  Because the valley has some rather large corporations operating here, and some of them are VC investors themselves: Facebook, Google, Apple, Oracle, Intel... and they're not going anywhere.\n\nThing is, VCs aren't going to disappear.  They're just going to get smarter and be more selective with their investment.  This is the actual \"bubble\" people are talking about that has already burst.  VCs in the valley aren't extending B and C rounds to companies that aren't on a short path to profit.  It's been happening for a year now, if not longer.\n\nDid anyone get fucked over?  Not really.  The numbers have always been against the dot com entrepreneur.  Always.  Nothing's really changed.", "id": "d1308hi"}, {"comment": "the next one to go is ridiculously inflated stock valuations and future return expectations, unleashing a tsunami of unserviceable debt. that will for sure fuck people over.", "id": "d133yum"}, {"comment": "> ridiculously inflated stock valuations and future return expectations\n\nAlthough there are some tech companies that exhibit this problem, this problem is not limited to tech.  Happens across the market.  Nothing to do with the valley.\n\n> unleashing a tsunami of unserviceable debt\n\nI'd call it more of a happy-hour-$3-a-pitcher-of-beer-piss of debt.  Not a tsunami.  Not all companies here are backed by \"I'll trade you a pile of vaporware for $100BB in cash\".  That might have been the case in the 90s, but that is not the 2010s.\n\nAfter the first dot-com boom, after the mortgage crisis and ensuing crash, you'd think VCs and banks smartened up a bit.  And you'd be right.  'Cause it's one hell of a lot harder to get money these days.\n\nWill people be fucked?  Only speculators and hedge funds.  They'll miss payments on their yachts.  Boo hoo.\n\n", "id": "d13jf3n"}, {"comment": "two wrongs don't make a right.\n\neven if banks and investors did smarten up, pension funds and peoples savings (whether they know it or not) is invested. hedgefunders, vc:s and banks are not often among those to pick up the tab at the end of the party. but i'm happily proven wrong. time will tell, but if history has its say...", "id": "d14e9nq"}], [{"comment": "Come on guys, despite the unnecessary jabbing style of this post, #3 gives me the butterflies right in the Impostor Syndrome and #4 I've had to deal with directly.\n\nNot interested in the little bubble I live in - I think this was insightful.  Just not sure about the over-bitching in the post.", "id": "d129wv4"}], [{"comment": "[deleted]", "id": "d127u56"}, {"comment": "[deleted]", "id": "d12csi5"}, {"comment": "And god forbid you need a house for your family in SV. What's a 100k salary given the housing market in the Bay Area... especially in the attractive areas.", "id": "d12joru"}, {"comment": "I'm never going to have a house in SF", "id": "d12p6eh"}, {"comment": "It'll be worthless by the time you pay off the mortgage anyway.\n\nDo we really think this SF housing bubble is going to last 30 years?", "id": "d12ucdv"}, {"comment": "I hope not, I really want a house", "id": "d12y2az"}, {"comment": "You're never going to have a house in SF", "id": "d12zrfa"}, {"comment": "Barring (natural) disaster(s), yes.  Is it really still a bubble?\n\n* parenthetical disaster", "id": "d1312pt"}, {"comment": "I'll sell you the shed in my back yard on that salary.", "id": "d12o5p7"}, {"comment": "For UK (outside of London) it's ok, for Lithuania, Poland, and Romania I'd say it's really really great.", "id": "d12enmh"}, {"comment": "It that's after taxes it would be great in Spain too, if it's before taxes it would be average to a little low for a senior. ", "id": "d12iz5w"}, {"comment": "Depends where. $3k in Warsaw is not bad, but not really glorious either.", "id": "d12lv1q"}, {"comment": "You mean gross or net?\n\nIn Italy 3k/m gross is above average, but not great.\n\n3k/m net is really an exception instead.", "id": "d12j6xf"}, {"comment": "http://www.economist.com/content/big-mac-index\n\nhttp://stackoverflow.com/research/developer-survey-2015#work-complang\n\nWhen you factor in actual purchasing power, those EU devs do pretty well and (in some cases) do better than the US.", "id": "d12wtiq"}, {"comment": "[deleted]", "id": "d12xlsj"}, {"comment": "X is in no way the average wage in Y. It's probably being distorted by Z. \n\nAverages. Not even once. ", "id": "d12ydak"}, {"comment": "Well London is at least 10% of the country so...", "id": "d13x3r6"}, {"comment": "Maybe you're getting confused with median income? ~3000 pounds a month is pretty average, but in most places programmers make more.....", "id": "d130zo6"}, {"comment": "I may have had my view skewed by being in London too long, but $3K a month equates to around \u00a325K a year using current FX rates.\n\nSurely average salaries outside of London are a little higher than that?", "id": "d133tqf"}, {"comment": "[deleted]", "id": "d13axtk"}, {"comment": "I'm not disputing the jobs thing - hell I'm a product of that. I moved to London a while ago for work reasons.\n\nI'm originally from the north and back in the early 2000s the going rate for entry level jobs was around \u00a318-\u00a320K though, so \u00a325K seems very low for someone with some experience.", "id": "d13ds2l"}], [{"comment": "I would wager that a developer in the Ukraine lives with a higher standard of living than a developer in SF making 100k/year. Rents for a studio apartment are above 2k/mo in SF. Buying a shack to call home is over a million. Food is probably 5-10x Ukraine. ", "id": "d12kmoc"}, {"comment": "Even considering that people might prefer living in SF to Ukraine?", "id": "d12m8kz"}, {"comment": "Well, it may be a war zone, but at least it's not SF...", "id": "d1310da"}, {"comment": "This skin isn't going to tan itself.", "id": "d12wgkm"}, {"comment": "SF is hands down the place I would live if I had gobs of money.  ", "id": "d1313ml"}, {"comment": "Why?", "id": "d1324tg"}, {"comment": "SF is exactly the right kind of weird for me, it's such an eclectic city.\nIt has an amazing music scene, which is my real jam; especially for the jamband scene.\nGreat restaurants and it's CA which has so much to offer.\n\nDownside is almost nobody can really afford to live there, especially if you want to have enough square footage to actually live in.\n\n\n ", "id": "d13e1mc"}, {"comment": "I dunno. Portland probably fits most of that.  ", "id": "d15h34k"}, {"comment": "Ya, love that town too.", "id": "d19oij0"}, {"comment": "Forget studios...I was just visiting a friend in SF...they were paying $2k for a *room* in a house of 15 people.", "id": "d136top"}, {"comment": "A friend of mine is renting a closet in Oakland, no joke. I don't know the price.", "id": "d13lm64"}, {"comment": "I bet $100k/yr is probably functionally poor in SF. No thanks. :)", "id": "d13u48n"}, {"comment": "Well he isn't making 100K/year, that is part of the reason he is renting a closet :)  No, 100K is just fine for a single guy.", "id": "d13y5yv"}], [{"comment": "> A good developer in Eastern Europe now costs $1000-$1500 a month.\n\nMy rent is $1500 a month.", "id": "d12l2v7"}, {"comment": "This is not confined to other countries, it is also poignant when I talk to other generations / lifestyles.\n\nMy family can not understand that i have a shitty apartment and can hear my neighbors fighting (literally) right now and I pay double in rent vs what they pay in mortgage. \"Then move\" This is the shittiest apartment in the area!! \"Move out of the city\" Then I spend 2 hours a day swearing on the highway. \"Save money by changing your own oil\" I don't have a driveway, let alone a garage, I have to park on street and some kids tried to steal my factory honda wheels last month. You think i have a full sized jack and a oil wrench in my third floor apartment?\n\nIt does no good to compare pay. Even within a 50 mile radius. ", "id": "d12xrbp"}], [{"comment": "[deleted]", "id": "d12j0zp"}, {"comment": ">USA is pretty much entirely unique\n\nA M E R I C A N  \nE X C E P T I O N A L I S M ", "id": "d12pyis"}, {"comment": "> USA is pretty much entirely unique in that it's massive and people live in all parts of it(contrast this to i.e, Russia's Siberia, Australia's desert, Canada's tundras.) \n\nUnique, my ass.  Contrast it to China or India or another large country in a similarly benign climatic zone if you want to say it's unique, rather than countries that have dissimilar and extreme biomes for a big chunk of their area.\n\nWhen you take that into account and look at areas with similar climates, there's little to no difference for the number of people who 'live in all parts of it'.  For instance [Alaska](https://en.wikipedia.org/wiki/List_of_U.S._states_by_population_density) and [Siberia](https://en.wikipedia.org/wiki/Siberia) have similar population densities: 1.3 and 1.2, respectively.  Or New Mexico at 17.6 and [Australia](https://simple.wikipedia.org/wiki/List_of_countries_by_population_density) at 8.3 - roughly double, but that's not a hugely significant difference given the more extreme climates over larger proportions of AUS.\n\nWhich isn't to say that your point isn't valid - that devs get paid relative to cost of living, which varies by locale - but attaching to it to some kind of bizarro American geographicial exceptionalism is ridiculous.\n\nFinally, one can fairly easily presume that the author is targeting SV as that's where the majority of the US software industry is centered and gets the most attention - VCs aren't exactly swarming the plains of Kansas or Iowa.  So it's not unreasonable for the author to generalize from that; it's no different that associating Detroit with the auto industry, for instance.  Dragging the wages of devs working in Podunk, Montana isn't really germaine to his argument as you won't find teeming hordes of devs willing to work for lower pay (60% of SV wages) in MT, while one would find exactly such in Poland (33% of SV wages).", "id": "d12x323"}, {"comment": "> USA is pretty much entirely unique\n\nThe USA is pretty much entirely unique in that its inhabitants have this ridiculous belief that, despite knowing jack all about the rest of the world, the USA is *entirely different* from everything else on the planet.\n\nThat is how the USA is unique. It is not unique in being big, and it is not unique in being populated.", "id": "d132edx"}, {"comment": "[deleted]", "id": "d132jib"}, {"comment": "Good for you. But that doesn't change the fact of Americans' absurd belief in American exceptionalism.\n\nNor does it change the fact that you're wrong about the USA being unique in being massive and having people live all over it.\n\nSo how is your birth place relevant, exactly?", "id": "d132xmi"}, {"comment": "Buzzwords don't mean much. Most countries have their own brand of nationalism.", "id": "d1rt2nf"}], [{"comment": "Though I think there are some good ideas here, some of this seems like nonsense. Right off the bat I thought that the comment about Dropbox wasn't quite on the mark. That policy isn't related to Prism. It is related to Dropbox not being a secure platform to secure personal information by design.", "id": "d12lg13"}], [{"comment": ">that can guarantee that it will function in all Russia, including Crimea\n\nJust to be clear: Crimea is a part of Ukraine currently occupied by Russia. And, well, yes, if you start war against other country - you should be ready to live in isolated environment - and it is not a problem of US companies or US developers if Russia wants to go its own way without international laws, software and hardware. It's anyway impossible to have a business with a country where people ignore laws.\n", "id": "d132un0"}], [{"comment": "Keep in mind the cost of living when comparing.\n\nExample: \n\nI'm in South Africa. Exchange rate around R16 per Dollar.\n\nRent = R4700 (Wifi & water & Geyser included)\n\nElectricity = R250\n\nVehicle = R2100 (2014 Chev Spark, no deposit, no balloon, 60 months)\n\nMobile data = R29/500MB LTE for GPS & Whatsapp\n\nFood = R2500\n\nFuel = R1400\n\nCar Insurance = R370\n\nCleaning Equipment = R200  (wahing powder etc)\n\nToiletries = R200\n\nCar Wash = R80\n\n\nSo in general I need about R12000 to survive and to service most of my obligations.\n\nIncome as a midlevel developer around is R23000 of which almost R4000 becomes tax. Thus you can see that even living \"comfortably\" I still have a lota left over money. Sure comparing to the US it seems like nothing, but I'm earning more than 80% (or more?) than the rest of the population in the country. I still have to budget for car services, licenses, web domain renewals etc.\n\nI don't smoke/drink so that means I can buy more snacks, healthy foods & proper fruit and I can afford more trips around town (meaning an extra 200 to 300 kilometers over a weekend, every weekend). I dont have medical aid (I dont get sick..) but that would cost me around R1500 to R2500 per month. I don't gym - I'm naturally lean so thats pretty cool.\n\nCurrently I buy all my food from woolworths (basically very upmarket food in this country), which is quite expensive. If I go shop around at markets (which we have plenty of them, but mostly only over the weekends and I need to go to the ATM to get cash), then I can get almost double the amount of fresh goods than from Woolies with the same money, and often time the same quality or better than WoolWorths.\n\n\nIf you have a partner with a decent income (above R10K per month), then you can start saving money and maybe think of buying property (ie after you start earning R30000 per month). \n\nAs time goes by and you start earning above R40000 per month, you are considered very rich. I know a few people who earns considerably more than this per month, but they usually get paid in dollars and work from home.\n\nLately with our government screwups, our economy is tanking, so things like food, electricity, electronics & other services - the prices are rapidly rising. For instance, I bought a brand new Lumia phone last year a month after release at R2500 with free shipping, that same phone cost R3400 now. A 128GB SSD that I bought in September cost R999, now R1300. So ya. \n\nAny questions?\n", "id": "d130u03"}], [{"comment": "I would say something about the government, but then they would start reading my messages more than they already do.", "id": "d12qgja"}], [{"comment": "This is the best tl;dr I could make, [original](https://medium.com/@did_78238/what-us-software-companies-should-understand-about-the-rest-of-the-world-783e8dbca758#.p5d598thj) reduced by 94%. (I'm a bot)\n*****\n> I think it&#039;s a good idea to give a general overview that would help US software companies to better understand what&#039;s going on with the rest of the world and why they may be failing in the foreign markets.\n\n> We now know that they have every right to be concerned about safety of their data stored with US companies.\n\n> Passed a law that allowed government and state corporations to only buy software from vendors that can guarantee that it will function in all Russia, including Crimea, essentially shutting out US companies from billions of dollars in government contracts.\n\n\n*****\n[**Extended Summary**](http://np.reddit.com/r/autotldr/comments/4tbbcq/what_us_software_companies_should_understand/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ \"Version 1.6, ~80168 tl;drs so far.\") | [Theory](http://np.reddit.com/r/autotldr/comments/31bfht/theory_autotldr_concept/) | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr \"PMs and comment replies are read by the bot admin, constructive feedback is welcome.\") | *Top* *keywords*: **company**^#1 **simply**^#2 **think**^#3 **really**^#4 **good**^#5", "id": "d5fyzxv"}], [{"comment": "I wonder what the author thinks about open source software (one which is not developed by a company desiring to maximize profit with it) which is developed in the US.", "id": "d12jydu"}, {"comment": "isnt one of the points of FOSS to have kind of decentralized development? so you could hardly say \"developed in US\", when you have people from around the world contributing. I am of course talking about semi-decent to big projects", "id": "d12qmsn"}, {"comment": "Developers still have to follow local laws and such when writing programs however. There is also the consideration that a software project which is primarly based and ran by US citizens would have to still follow US laws (when accepting patches for example). The developers may potentially only care about legality in a specific set of countries, rather than every single one of them.", "id": "d12rfdp"}, {"comment": "TIL all open source software is written in the USA.", "id": "d12v4nl"}, {"comment": "This thread is wonderful. I learned that Internet delivers its bits and bytes more slowly in Europe than in the great America. And the bytes are even bigger in California, they have 9 bits! Ha, take this, peasants! ", "id": "d12wmg1"}, {"comment": ">And the bytes are even bigger in California, they have 9 bits! \n\nSounds like it was designed by Oracle. ", "id": "d1314bq"}, {"comment": "Nah. For oracle that would be 8.766666 bits, or 9.21463333 for enterprise edition.", "id": "d132wc2"}, {"comment": "I think it's something to do with the fact that 80% of commercial routers are designed in America.", "id": "d130elw"}], [{"comment": "[deleted]", "id": "d126zfz"}, {"comment": "I think you dont understand what means \"living\".", "id": "d127ip7"}], [{"comment": "This was just a huge anti American rant. From my experience, US developers, especially silicon valley devs are paid a lot because we build cutting edge applications, try finding a competent foriegn angular or react developer, they'll be $100k + just like American devs.\n\nI", "id": "d12mlgs"}, {"comment": "> silicon valley devs are paid a lot because we build cutting edge applications, \n\n/r/programmingcirclejerk\n\n", "id": "d12oah7"}, {"comment": "Just no. What do you think do foreign programmers use? Perl CGI? They use the same technologies as everyone else, it's not like Github is inaccessible from outside the US or that Angular is so monumentally complicated that non-US devs just don't have the mental capacity to use it. \n100k+ salaries for developers (especially javascript ones) are pretty much unheard of in the rest of the world, Idk about places like Australia, but at least in most European countries, if you earn half of that, you are doing well. Germany may be the exception where salaries for developers are more in the 50-80k range in certain areas.", "id": "d12ouu8"}, {"comment": "Ya, coworkers in England and France make absolutely over $100k. They just stay on top of the ball of single page applications\n\nAlso anything big data like hadoop / nosql etc pays a $h17 ton in Europe because they're just now moving to those methodologies, especially London FinTech jobs, those start at over $150k\n\nAlso Netherlands and Norway, those guys make ridiculous money. I used to party with the people from rovio and can absolutely tell you they pay on par with Google \n\nWhat it comes down to is specialty and ability. I know the kind of devs you get for $1000 / month. They're great at pulling down and stitching a bunch of github clones together (IE the 24mb oauth monstrosity I got from Ukraine that I did in like 2kb)\n\nI stick to my original point. If you're ahead of the curve and in the right niche you make bank as a dev anywhere if you're in the right specialty. And you can actually make more in Europe in some specialties than you can in the US", "id": "d12p1zc"}, {"comment": "Can't speak about England, but \"absolutely over 100k$\" is absolutely NOT the norm in France.  \nGross yearly salaries tend to range between 28 and 70k, depending on location (income in Paris is usually 10-20% higher to account for superior life costs), experience, technology (javascript/PHP usually pay less, C#/Java/Ruby tend to top the chart) and sector of activity (finance/bank/insurance pay really well, web agencies tend to be below average).  \nRealistically, a +5y exp dev in Paris can expect a net 2500/mo income, plus bonuses if in a company doing well.  \nNow, you should remove around 1 month of salary that will go away in annual taxes to have a clearer picture.  \nOf course there is a big variance, if you have the luck to be in a \"success story\" company you can make higher wages quicker.  \nImportant thing to note: even if this can seem low compared to other countries in term of pure money, in France the taxes taken on your wages cover for unemployment compensation, medical costs, and retirement fund.  ", "id": "d138zj0"}, {"comment": "In Australia $100k+ is around where senior developers are, but our living expenses are much much higher.", "id": "d131ils"}, {"comment": ">  try finding a competent foriegn angular or react developer\n\nIf your definition of \"cutting edge applications\" is just \"uses the JavaScript framework that's cool today\", then hooo boy, you just made the author's point about living in a bubble.", "id": "d132b97"}, {"comment": "It's fine, just ignore the way he prefaced that with the word \"competent\".", "id": "d13ruzu"}], [{"comment": "R&D in second world.... seriously?    You already admit that the concepts of daily life are drastically different.   Most companies ship maintenance out to 2nd world.", "id": "d12k6d0"}, {"comment": "Some big companies like Intel, Samsung or Apple often hire teams in universities worldwide to do R&D. Some of the tech many consider coming from Palo Alto or SF are really from Novosibirsk or Moscow.", "id": "d1308ao"}, {"comment": "Examples with proof? Not that i doubt you but you know, internets...", "id": "d136s6v"}, {"comment": "Here's a lab in Moscow State University, for one: http://compression.ru/video/\n\nThey mention some of their big customers but don't list all the projects they're doing for them and other companies. I've worked with these guys personally.\n\nA friend of mine has been R&D-ing compiler stuff for Intel and Samsung in another Moscow institute. http://www.ispras.ru/en/projects/", "id": "d142yyz"}, {"comment": "Way to make the author's point. But for the record, I don't think you need to be quite *that* ignorant of the world outside the US.\n\nWhat, do you think people in Eastern Europe live in mud huts and only have electricity one hour a day?", "id": "d132cq5"}]]], "4si7zv": ["6 Best JavaScript Frameworks to Learn In 2016", "2016-07-12 21:27:27", 0, "http://www.discoversdk.com/blog/6-best-javascript-frameworks-to-learn-in-2016/#/wow", [[5, "Next year in JavaScript: Top 6 Therapists for Framework Overload!"], [3, "To be clear; I don't think anyone would suggest that you learn 6 frameworks in year.  The intent here is \"here are six good frameworks, from which you can pick one to use\", not \"learn all of these\"."], [2, "Where do I download the release of Angular2?"]], [[{"comment": "Next year in JavaScript: Top 6 Therapists for Framework Overload!", "id": "d59hllx"}, {"comment": "If there's one thing the Javascript community does well, it's reinvent the wheel.", "id": "d59jzes"}, {"comment": "Or, as Alan Kay put it, the flat tire.", "id": "d5gwyhc"}], [{"comment": "To be clear; I don't think anyone would suggest that you learn 6 frameworks in year.  The intent here is \"here are six good frameworks, from which you can pick one to use\", not \"learn all of these\".", "id": "d59i0mk"}, {"comment": "I thought the standard number was at least 52 frameworks per year.", "id": "d59j9y2"}, {"comment": "Yeah, if your primary source of information about JS is the reddit circlejerk, I can see why you'd think that.  ", "id": "d59nbu5"}, {"comment": "Good point ", "id": "d59iy8c"}], [{"comment": "Where do I download the release of Angular2?", "id": "d59m24j"}, {"comment": "https://github.com/angular/angular", "id": "d59mbqb"}, {"comment": "It says right there on the page it is a release candidate.", "id": "d59oq7v"}, {"comment": "It's version 2. Isn't that what you want?", "id": "d59pa0r"}, {"comment": "I was mocking the claim in the article that Angular 2 has been released.", "id": "d59phe9"}, {"comment": "Oh sorry. Not officially. It's still a RC as far as I know. But even on their website it shows version 2. ", "id": "d59pu38"}]]], "4g8adp": ["The birth, life and death of tech empires, DEC and Microsoft.", "2016-04-24 18:13:49", 1, "http://delphicodemonkey.blogspot.com/2016/04/patterns-in-history-of-computing-birth.html", [[3, "This tech company life cycle seems incomplete. If the company reaches a sufficient level of success, it tends to hang around for a long, long time as a progressively emptier shell that makes all of its money as a patent troll.\n\nMicrosoft is such a huge monstrosity of an organization that its life cycle may be unique. It has massive cash reserves that could keep it going for decades, but at the same time maintains a significant desktop OS market share and a major patent-trolling operation."], [6, "Oh come on! Microsoft pivoted half a decade ago. Azure was not created yesterday. Let alone things like Xbox."], [4, "I expected this to be more insightful than it was."], [2, "Xerox is an even more interesting case. They knew that someday the photocopier would be made obsolete by computers. They set up a research facility to develop this threatening technology before somebody else did. The results were spectacular; they were 20 years ahead of the competition. And this turned out to be a huge problem: the required hardware was far too expensive. Xerox abandoned the project and couldn't compete in the market when the hardware became finally affordable. So Apple and (much later) Microsoft were successful in marketing the PC with Ethernet and windowing GUI that Xerox had envisioned in the 1970s. "], [1, "> Will Microsoft ..... unlike DEC, still be around in 20 years?\n\nProbably not.\n\nThe Vaxen with VMS were killed off by the rise of the UNIX systems. Microsoft whose Windows (ironically with a beating heart of VMS also) is inexorably becoming a niche market, in vain competing against the ascendant mainstream of UNIX-like Operating Systems."], [1, "risc is dead except for the billions of ARM processors in phones, tablets and devices. "]], [[{"comment": "This tech company life cycle seems incomplete. If the company reaches a sufficient level of success, it tends to hang around for a long, long time as a progressively emptier shell that makes all of its money as a patent troll.\n\nMicrosoft is such a huge monstrosity of an organization that its life cycle may be unique. It has massive cash reserves that could keep it going for decades, but at the same time maintains a significant desktop OS market share and a major patent-trolling operation.", "id": "d2fj4hc"}, {"comment": "E.g IBM. Has died many times but still around.", "id": "d2fuuqk"}], [{"comment": "Oh come on! Microsoft pivoted half a decade ago. Azure was not created yesterday. Let alone things like Xbox.", "id": "d2fk36j"}], [{"comment": "I expected this to be more insightful than it was.", "id": "d2fkmwq"}], [{"comment": "Xerox is an even more interesting case. They knew that someday the photocopier would be made obsolete by computers. They set up a research facility to develop this threatening technology before somebody else did. The results were spectacular; they were 20 years ahead of the competition. And this turned out to be a huge problem: the required hardware was far too expensive. Xerox abandoned the project and couldn't compete in the market when the hardware became finally affordable. So Apple and (much later) Microsoft were successful in marketing the PC with Ethernet and windowing GUI that Xerox had envisioned in the 1970s. ", "id": "d2hwdww"}, {"comment": "Smalltalk and Ethernet and modern wysiwyg guis and so on lived on even though xerox profitted very little. It really is a good story.", "id": "d2i3res"}], [{"comment": "> Will Microsoft ..... unlike DEC, still be around in 20 years?\n\nProbably not.\n\nThe Vaxen with VMS were killed off by the rise of the UNIX systems. Microsoft whose Windows (ironically with a beating heart of VMS also) is inexorably becoming a niche market, in vain competing against the ascendant mainstream of UNIX-like Operating Systems.", "id": "d2fztp0"}, {"comment": "DEC was a major player in the world of commercial UNIX.", "id": "d2g6vwi"}, {"comment": "Later on. Many VAXes were used to run UNIX instead of running VMS. So when Sun (also running UNIX) arrived on the scene, they were a cheaper alternative to DEC\n\n[Cheaper? They were still *horribly* expensive!]", "id": "d2g8fbf"}, {"comment": "I haven't found a lot of VAX pricing information on the web.  MicroVAXen originally retailed in the $35,000 USD range right? How about the original Vax 11/780 in 1978, this CHM page says $120K to $160K. The CHM page below also says these were cloned in eastern europe. I'd like to read about these clones.\n\nhttp://www.computerhistory.org/revolution/mainframe-computers/7/182/736", "id": "d2ge5m6"}, {"comment": "Don't forget, *any* computing equipment in the 80s and 90s was exorbitantly costly  by today's standards. I can remember a 30Mhz 486 Intel around 1994 with around 32 MB of RAM and a 60MB hard drive cost around $4500. About that time, a five-year-old SPARCStation 1 was also around the same price, but that was 'fat' with 1700MB of SCSI disk and 64MB of RAM.\n\nBoth of those machines would most likely be blown away by a $40 Raspberry Pi today. ", "id": "d2giuda"}], [{"comment": "risc is dead except for the billions of ARM processors in phones, tablets and devices. ", "id": "d2ghhpm"}, {"comment": "The article points out that RISC is hardly the point of RISC, and so RISC is not only alive on phones, it's innovations are alive inside CISC. The point of RISC was that it lead to fabs finding ways to make parts that worked at higher clock speeds and at denser scales with more transistors per cubic centimeter of die space.  These and many general improvements that RISC pioneered, including superscalar cache architectures, fed back into the juggernaut of the PC CISC (intel x86, x64) and lead CISC to ultimately defeat RISC on workstation class machines.  So It's one of the hard problems of computer science. Turns out RISC is not as great as billed. Turns out that fundamental research into silicon architectures is huge.  Even a modern Phone cpu, is it really RISC? Not so reduced instruction set. Is Apple's A10 CPU really RISC? yes it's ARM based. But at what point is it no longer a RISC machine?  I am not sure where to draw the line.", "id": "d2gsnev"}]]], "4lf2ig": ["The Five Top Reasons to Use JavaScript", "2016-05-28 12:37:48", 1, "https://medium.com/javascript-non-grata/the-five-top-reasons-to-use-javascript-bd0c0917cf49", [[51, "1) It's the only choice you have for client side programming.\n2) It's the only choice you have for client side programming.\n3) It's the only choice you have for client side programming.\n4) It's the only choice you have for client side programming.\n5) It's the only choice you have for client side programming."], [14, "tl;dr you have no choice."], [11, "Expected pro-JS clickbait, it's anti-JS clickbait."], [10, "The top 5 reasons are:\n\n- Monopoly in the browser world\n- Monopoly in the browser world\n- Monopoly in the browser world\n- Monopoly in the browser world\n- Monopoly in the browser world"]], [[{"comment": "1) It's the only choice you have for client side programming.\n2) It's the only choice you have for client side programming.\n3) It's the only choice you have for client side programming.\n4) It's the only choice you have for client side programming.\n5) It's the only choice you have for client side programming.", "id": "d3msrpw"}, {"comment": "Like I always say: No one chooses JavaScript. It's just the only option.", "id": "d3mw6jr"}, {"comment": "A ton of people willfully choose javascript, because they prefer writing in it to say java.  Cases in pont: node and gulp.  Neither have a monopoly in their respective domains.", "id": "d3mwhc4"}, {"comment": "People who've been forced to learn JavaScript for front-end development choose node and gulp, because they want to move out of their ghetto without learning anything else.", "id": "d3mxh3k"}, {"comment": "Yeah a lot of people actually prefer node as async and even driven come naturally with it. There are people writing programs for non web applications (iots, and even nasa satellite apps) with js/node because they like it.", "id": "d3n3fgr"}, {"comment": "If you don't transpile.", "id": "d3mt84x"}, {"comment": "Aha I just read your response here. I wrote a very similar thing before looking at you here.\n\n+1 for you, it is so true and obvious", "id": "d3mvbc1"}, {"comment": "Not strictly true. You don't have to write your entire client-side application in JavaScript. You just need to use enough for jQuery (< 5%) and write the rest of your application (> 95%) in a transpiled language.", "id": "d3pc8ku"}], [{"comment": "tl;dr you have no choice.", "id": "d3mtk8z"}], [{"comment": "Expected pro-JS clickbait, it's anti-JS clickbait.", "id": "d3muh0k"}, {"comment": "That's all this guy ever does.  He's literally on a one-man crusade to dissuade people from using Javascript.  Don't remember his Reddit username, but he said as much in a comment thread a couple months back.", "id": "d3n37gx"}, {"comment": "Yet he uses a blog provider that is a clusterfuck of js and big images, leading to an atrocious loading time nearly 10 seconds with a not too bad connection. Kind of disrespecting.\n\nOh well, after all, the only post I've seen on medium worth looking at may be [this](https://medium.com/@sdboyer/so-you-want-to-write-a-package-manager-4ae9c17d9527#.ewo6m1dje) one, but apart from that, this blog provider is a bleach to the internet.", "id": "d3n3j0s"}, {"comment": "What is his problem? Is someone forcing him to use JS? He should really learn to focus this energy towards something positive.", "id": "d3n3zts"}, {"comment": "In fact, I'm doing exactly that! I've devoted the last 10 years or so to [doing pro bono IT work for worthy causes](https://medium.com/p/since-retiring-from-it-ive-spent-the-last-few-years-doing-pro-bono-it-work-for-worthy-causes-36e62cc2b91a).", "id": "d3pbxor"}, {"comment": "That's awesome! So why do you spend so much energy on anti-JS posts then? I'm genuinely curious.", "id": "d3pc8hr"}, {"comment": "As I stated in the linked response: \"This year, I\u2019m campaigning against JavaScript because I firmly believe that its inappropriate use as a software engineering language is a threat and a danger to the IT profession that I know and love.\"\n\nI further said: \"I do this out of love; I do this as a public service. It\u2019s certainly no skin off my nose.\"\n\nSo I do all this because it's what I believe. I realize that some of you do not share my belief. Just because I'm a lone voice shouting in the wind doesn't make me wrong. History will either prove me right or wrong, but we shall have to wait another decade or so to know.\n\nIt's not unlike the situation with climate change deniers or Edward Snowden-like whistleblowers or anti-Muslim paranoia sweeping Europe. We won't know the outcome of these things until it's too late.", "id": "d3pjbvn"}, {"comment": "[I do more than that](https://medium.com/p/since-retiring-from-it-ive-spent-the-last-few-years-doing-pro-bono-it-work-for-worthy-causes-36e62cc2b91a).", "id": "d3pc19y"}, {"comment": "Confusing, isn't it? ;-)", "id": "d3pbpig"}], [{"comment": "The top 5 reasons are:\n\n- Monopoly in the browser world\n- Monopoly in the browser world\n- Monopoly in the browser world\n- Monopoly in the browser world\n- Monopoly in the browser world", "id": "d3mvaz3"}]]], "3zg6g4": ["Java is TIOBE's Programming Language of 2015!", "2016-01-04 22:16:37", 0, "http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html?languageof2015=java", [[12, "How can you seriously not consider Github & Stackoverflow in the rankings but consider Ebay? WTF? \n\nhttp://www.tiobe.com/index.php/content/paperinfo/tpci/programminglanguages_definition.html"], [1, "Since they use search engines for part of it I wonder how much is a result of first-year CS students searching for homework help and the subsequent content generated for that market."], [-24, "[deleted]"]], [[{"comment": "How can you seriously not consider Github & Stackoverflow in the rankings but consider Ebay? WTF? \n\nhttp://www.tiobe.com/index.php/content/paperinfo/tpci/programminglanguages_definition.html", "id": "cylws6r"}, {"comment": "Github is candidate and for Stackoverflow it says \"sources not parsable\" while stackexchange is a candidate again.\nHead over to [RedMonk](http://redmonk.com/sogrady/2015/01/14/language-rankings-1-15/) index, I think it's based on those two.", "id": "cylx8zv"}, {"comment": "CANDIDATE, but still not qualified :(\nand SO they can use the API, tags will satisfy their need", "id": "cyly8hw"}, {"comment": "The big market for used Java books must be pushing it to the top!", "id": "cylzf5c"}, {"comment": "Haha, people still buy physical books (the horror!!) ", "id": "cymrplp"}], [{"comment": "Since they use search engines for part of it I wonder how much is a result of first-year CS students searching for homework help and the subsequent content generated for that market.", "id": "cymdbjd"}], [{"comment": "[deleted]", "id": "cyltdsi"}, {"comment": "It's about Java, not javascript, silly.", "id": "cylv3ok"}, {"comment": "[deleted]", "id": "cylvdnj"}, {"comment": "DISCLAIMER: my main language nowadays is javascript, has it's good and it's bad\n\nFirst of all javascript and java are 2 completely different beasts, and should not be compared. You're comparing a car to a tractor trailer, both have their uses but are made for completely different purposes\n\nSecond of all Java and Javascript both appeared around the same time, so calling Java a dinosaur is calling Javascript a dinosaur. \n\nThird, why all the java hate?\n\nAnd finally, don't listen to TIOBE, look at their collection strategy http://www.tiobe.com/index.php/content/paperinfo/tpci/programminglanguages_definition.html. The most popular developer sites, Sourceforge, Github, StackOverflow are not considered in the rankings", "id": "cylwpg3"}, {"comment": "> Third, why all the java hate?\n\nI think he's the resident MS troll. Shows up to tell people how much Java sucks and how he's C# master race.", "id": "cylyhth"}, {"comment": "Haha, ahh I see. C# was my primary pre Javascript, but I still think Java has it's advantages in various usecases, just as C# has it's ", "id": "cymronq"}, {"comment": "C# and Java are so similar that I don't see the point of the arguing. Besides just being a troll.\n\nAnd I prefer C#.", "id": "cymz0kk"}, {"comment": "[deleted]", "id": "cylx5ds"}, {"comment": ">Nope. At least js evolves properly. Look at async/await, retarded java will never get that, because it's retarded.\n\nJS evolves now, but this is a recent development (past 5 years maybe), before JS developers hated themselves lol \nAlso Java has the Future and FutureTask, which AFAIK are their async implementation. Not to mention, you can do Parallel in Java which (sadly) will never exist natively in JS", "id": "cylxwxk"}, {"comment": "There's also annotations like `@Asynchronous` in the standard library. Not yet as universally usable as a language level async/await, but it's still there.\n\nAnd indeed, there's Future, but also CompletableFuture, (managed) executor services, fork/join and lots of other parallel goodies.", "id": "cym2f8c"}, {"comment": "> and lots of other parallel goodies.\n\nLike parallelStream(). Free fork/join (shared or [not](http://blog.krecan.net/2014/03/18/how-to-specify-thread-pool-for-java-8-parallel-streams/comment-page-1/)) threadpool for everyone.\n", "id": "cyp93ax"}, {"comment": "Still waiting on you to tell me what your username means.", "id": "cylxwlz"}, {"comment": "It means agleiv through agleiv_16 were banned.", "id": "cylzef2"}]]], "4wwzel": ["The must-ask question for your software engineering interview", "2016-08-09 20:15:15", 0, "https://morethancoding.com/2016/08/09/the-must-ask-question-for-your-software-engineering-interview/", [], []], "4zbc1p": ["My journey to becoming a web developer from scratch without a CS degree", "2016-08-24 11:16:57", 5, "https://medium.com/@sgarcia.dev/my-journey-to-becoming-a-web-developer-from-scratch-without-a-cs-degree-2-years-later-and-what-i-4a7fd2ff5503#.x52sfv3ls", [[15, "To be perfectly frank, and ostensibly crude, but getting a CS degree --- or a Software Engineering degree for that matter --- to become a Web developer (HTML/CSS/SASS/JavaScript + JS libs) is like becoming a doctor so you can apply a band-aid. "], [10, "Very nice. Not to shit on the author though, I think is obvious you have a huge potential by demonstrating being self taught. And I want to personally congratulate you for such a long way, and may this serve as an example to people that you can achieve anything. Great blog post.\n\nBe careful with too much current tech knowledge. You have accumulated a good set of tools and languages, whose lifespan might be 5 to 4 years. There will always be a new tool tomorrow. What is not going to change though is the principles. The turing completeness of the languages. The usual grammar patterns. The time complexity of execution of algorithms. New technologies require academia, and great minds. We have a great mind here, maybe is time to get a cs degree to get to the next level! (Unless quantum computing becomes the thing then we are all back to school :/)"], [2, "[deleted]"], [2, "beware of programmers who blog"], [1, "The content is good."], [1, "Thanks a lot for this! Very helpful and it also linked to a very interesting blog. I'm an Android Developer and have always been meaning to develop my dad a nice website and these are the perfect resources to do it well."], [1, "I skipped to the \"shortest route\" section and it was just a bunch of links to resources?"]], [[{"comment": "To be perfectly frank, and ostensibly crude, but getting a CS degree --- or a Software Engineering degree for that matter --- to become a Web developer (HTML/CSS/SASS/JavaScript + JS libs) is like becoming a doctor so you can apply a band-aid. ", "id": "d6ugsol"}, {"comment": "I think a more apt analogy is that this person's education was like learning how to use a particular brand of syringe, a particular brand of stethoscope, and particular brand of painkiller, and then writing an article about how they became a doctor without a medical degree.\n\nThere is nothing inherently easy about web development. We shit on it because its culture has lower standards than every other sub-field.", "id": "d6uk5sd"}, {"comment": "[deleted]", "id": "d6ur36z"}, {"comment": "Poor analogy. A mechanic understands more about how an engine works than the people who learn buzzword \"technology\" bingo know about how a computer works.", "id": "d6us0yz"}, {"comment": "[deleted]", "id": "d6us84o"}, {"comment": "It's still the best filter we have for weeding out morons (after fizzbuzz). Why do people without degrees get so bent out of shape when they're mentioned?\n\nAnd while I know plenty of skilled programmers who didn't go to college, or dropped out of college, it is still a red flag on your resume. Why didn't you go to school?\n\nIt's not hard to get into a good one, you get to spend four years doing nothing but learning and drinking and fucking, and even if you must get student loans, it isn't hard to pay them back on a software developer's salary. If you admit to chasing the money, it only shows a lack of delayed gratification.", "id": "d6utfp9"}, {"comment": "> There is nothing inherently easy about web development.\n\nThe current state of HTML evolved specifically to be as forgiving as possible wrt coding errors (like missing or mis-nested tags).  JavaScript's philosophy of implicit casts and OO without classes was also an attempt to make the language easy to use for non- to beginning programmers.\n\nedit: \"proof\"\n\nFrom Brendan Eich himself, the creator of JavaScript (emphasis mine):\n\n\"The impetus was the belief on the part of at least Marc Andreessen and myself, along with Bill Joy of Sun, that HTML needed a \"scripting language\", a programming language that was *easy to use by amateurs and novices*, where the code could be written directly in source form as part of the Web page markup. We aimed to provide a \"glue language\" for the *Web designers and part time programmers* who were building Web content from components such as images, plugins, and Java applets. We saw Java as the \"component language\" used by higher-priced programmers, where the glue programmers -- the Web page designers -- would assemble components and automate their interactions using JS.\"", "id": "d6ul2py"}, {"comment": "That's not JavaScript's philosophy.  The reason it didn't have those features at launch was because it was designed in 10 days.  ES6 has classes.  It was not designed with the philosophy of being beginner friendly.", "id": "d6ulb9d"}, {"comment": "According to the guy who created it, yes it is.  See above edit.", "id": "d6uolur"}, {"comment": "Have you seen the sheer volume of shitty, bedroom taught, web hackers out there?  CS degrees separate those who possess the cognitive and logical aptitude to write and architect code and solutions - from those who majored in Accounting and decided it was time for a career change.  It doesn't mean you have to have a CS degree to be a good software engineer - but I've often found your Business Administration degree doesn't lend itself to understanding the dimensions and complexities required to write good software.\n\nSorry, I'll hire someone with a CS degree every time. ", "id": "d6v1dai"}, {"comment": "Do not make the mistake my sentiments to mean that a CS-major does not have a higher likelihood of writing better software. I am just pointing out that most web-shops do not have an engineering degree as a barrier-to-entry and that if you just want to do Web-development a CS-degree is overkill. Side-note: there are people with CS/CSE-degrees that write poorly architected and non-performant software just as well as there being self-taught individuals writing really good software ", "id": "d6v27iu"}, {"comment": "DAE web devs aren't real programmers guise?!", "id": "d6up4ua"}, {"comment": "DAE?", "id": "d6usedo"}, {"comment": "Does Anybody Else.\n\nA lot of posts that are blatant pandering to the crowd start with \"Does Anybody Else think (some awesome nostagia thing) is awesome???\"  Lots of comments that call out pandering use DAE-style fake pandering.", "id": "d6uw5gj"}, {"comment": "dw he's just memeing", "id": "d6uy40s"}, {"comment": "I see people saying this a lot, and I think I agree to an extent, but I have a clarification question. When you say \"Web Developer\" and then mention HTML, CSS, JS, are you using the term Web Dev just to describe those that are touching primarily the UI? What about someone who writes Python, Java, etc ... which still pertains to the \"web\", albeit on the server side. I am confused as to what the general distinction is between a \"Web Developer\" and a \"Software Engineer\". What are your thoughts? ", "id": "d6unbv2"}, {"comment": "The article did not address those that write Python, Java, etc. but I'll be happy to do that too.\n\nPython and Java are just languages, neither has any pre-requisites with respect to any formal education.\n\nIn the context of the degrees offered at my university, I'd say that a CS degree is most appropriate for research. This does not mean that one's research has to be limited to studying computation, logic- and formal proof verification but also extends to matrix computations, distributed systems, federated databases etc.\n\nAs far as a CSE-degree goes for primarily front-end together with some server-side stuff whether or not that is in Python, Java or (yuck) Node.js, I think that learning statistics, discrete mathematics, embedded systems, systems programming, linear algebra, physics, machine vision, computer graphics, cloud computing, emergent systems, artificial intelligence, distributed systems, etc. might not be the best allocation of your time.\n\nIf the back-end has to be as performant as Netflix, Pornhub, Gmail, etc. then yes you'd probably be very well served by a CSE-degree. If \"all\" you are using is Ruby/RoR, Django, Wordpress etc. then you'd be better served by a more narrow course-selection.", "id": "d6ut1ww"}, {"comment": "I agree with most of your points here. I do want to point out that most universities offer their CS programs for free auditing online. So, if you are interested in getting a more complete understanding of Computer Science, there are resources available to you outside of actually going to college.\n\nI'm a self-taught web developer myself. My scope is as follows:\n\n    -Python\n    -Javascript\n    -HTML/CSS\n    -A bit of C\n    -Bash\n    -PostgreSQL/SQLite \n    -Linux server administration\n    -Unix Sockets\n    -knowledge of http and ws protocols and standards(TCP, UDP)\n    -A bit of cryptography for hashing PWs and stuff\n    -Text Encoding\n    -Data transfer protocols(JSON, XML, YAML)\n    -Various Design patterns(MVC, OOP, FP, etc)\n    -Time complexity/big O(everyone who works in software should know this)\n    -Probably a lot of other stuff I'm forgetting\n\nPoint is, I don't know how to implement a Markov Chain, but I do know what a Markov Chain is, and I know where I can go to learn how to implement it. I think for most self taught people, we end up learning what we need at the time. For instance, I had to design a database structure for arbitrarily nested comments. I didn't know the best way to do this, so I looked it up and found Modified Preorder Tree Traversal. Luckily there was a Python package that I could use so I didn't have to write it myself, but I still took the time to learn how it works.\n\nI think Web Development gets a bad wrap from a lot of software engineers because they don't see the delineation between someone who builds Wordpress websites and someone trying to keep a sharded database with trillions of records concurrent across the world without race conditions or data corruption.", "id": "d6uuxkb"}, {"comment": "Completely off topic, but I know what a Markov Chain is, but I have no idea how to implement it or where I could go to find out. Do you have any links to resources?", "id": "d6uvvp3"}, {"comment": "You can start [here](http://quant-econ.net/py/finite_markov.html) and [here](https://golang.org/doc/codewalk/markov/).", "id": "d6uwir5"}, {"comment": "Right now there aren't many formal delineations within the field of software development.  I _like_ that this lack of rigidity gives me career flexibility.  But it means people who want to describe development to people outside of it (or even it in) are completely lost when it comes to understanding the shape of the skill curve. \n\nThe writing about programming online is really bad at convening anything meaningful w/r/t barriers to entry.  It does a huge disservice to everyone, not just to the person interested in webdev that might think they need a CS degree.\n\nThe pressure to make programming accessible and get more people in means gung-ho writers gloss over the limitations of introductory knowledge. You don't need a degree to build a website.  But a coding bootcamp probably won't prepare you to grab an RFC, and sit down to design and build a network daemon.\n\nAnd on the other end, every single development methodology \"expert\" thinks I'm a schmuck stuck in the past using \"waterfall\" just because we can't push a new build to every device in the field 15 minutes after writing the patch.", "id": "d6uqzcv"}, {"comment": "In case of CS it is more like becoming a nuclear physicist to apply a band-aid", "id": "d6uhq11"}, {"comment": "I've never seen so much cs major circle jerking in one thread. I was electrical and computer engineering major, now a software developer. Never have I been out of my depth in any conversation with any cs majors where I work. We came in to things from different perspectives, is all. ", "id": "d6uwsu9"}, {"comment": "Well... you studied different things didnt' you? Surely they did modules at uni that you didn't? (or at least had the option to) I do Physics and if a Nuclear Engineer the only way they would be able to understand everything I could talk about is if I only did Nuclear physics modules. However I did theoretical modules, so obviously they won't understand when I start talking about the principle of least action or something. It's the same with CS, they have the option to do a lot more theoretically intense modules than you do in your electrical and computer engineering degree", "id": "d6uycj2"}, {"comment": "It's not, is just that CS teaches basically nothing useful in web development", "id": "d6v0ymj"}, {"comment": "You compared majoring in computer science to becoming a nuclear physicist. Self inflating much?", "id": "d6v4h9q"}, {"comment": "first, it is to show that those 2 things are completely different and poke different skillset\n\nsecond, I'm not CS  ;)\n\nthird, i work with one (not nuclear tho), he's not that good coder and he doesnt know anything about first aid.\n\n4th, fuck you", "id": "d6vvrmh"}, {"comment": "That's a better analogy", "id": "d6uiy3s"}], [{"comment": "Very nice. Not to shit on the author though, I think is obvious you have a huge potential by demonstrating being self taught. And I want to personally congratulate you for such a long way, and may this serve as an example to people that you can achieve anything. Great blog post.\n\nBe careful with too much current tech knowledge. You have accumulated a good set of tools and languages, whose lifespan might be 5 to 4 years. There will always be a new tool tomorrow. What is not going to change though is the principles. The turing completeness of the languages. The usual grammar patterns. The time complexity of execution of algorithms. New technologies require academia, and great minds. We have a great mind here, maybe is time to get a cs degree to get to the next level! (Unless quantum computing becomes the thing then we are all back to school :/)", "id": "d6ukof6"}, {"comment": "good thing i'm doing a thesis on quantum computing then", "id": "d6umnod"}, {"comment": "Mind sharing? Im a computer scientist, specialized in graphics and formal languages. 0 training on quantum computing. I've read some stuff and sounds incredibly mind blowing", "id": "d6vgnm6"}, {"comment": "I'm just an undergrad btw. I've just started working on it. I am reading this book and will finish it:  http://www.michaelnielsen.org/qcqi/QINFO-book-nielsen-and-chuang-toc-and-chapter1-nov00.pdf\n\nAfter that, I'll probably read some of the recent papers on the topic and work on a problem that my professor gives me.", "id": "d6vuqyy"}, {"comment": "Everything folds and moves gradually. It isn't too hard to pick up react if you already know angular. Sure it's a completely different mindset, but the really hard bit is getting used to tooling. HTML, CSS, Javascript are things that won't die for a very long time. The thing about these modern day toolkits and frameworks is that you don't need to know much about them to be able to use them effectively and idiomatically.\n\nI don't think there's much worth in the principles, especially time complexity is important for sure, but turing completeness? Grammar patterns? They're totally useless for a front-end developer...", "id": "d6uy2mg"}, {"comment": "It's the principles that gotten us this far. If a front end developer just wants to do Javascript pages then sure, it's useless. If the front end developer strives for innovation, say creating an alternative to Javascript, or branch prediction, etc, then yes you need principles. It depends where your mind stands; I rather solve interesting problems :)", "id": "d6vggav"}, {"comment": "Web assembly is here. Javascript's days are numbered (maybe a few years?). As /u/kecho said, tools and languages come and go.\n\nTo understand the fundamentals of CS one does not need to go to school anymore. All the resources are available online, for example, MIT's opencourseware, etc.", "id": "d6vul5n"}, {"comment": "What a joke", "id": "d6vvnrp"}, {"comment": "script kiddy will always just be that, script kiddy :) jokes on you pal\n", "id": "d6x4jzl"}], [{"comment": "[deleted]", "id": "d6uh6es"}, {"comment": "I imagine mobile dev is crazy for its own but different reasons. ", "id": "d6uhafe"}, {"comment": "Possibly worse, because moving to a different architecture means none of what you previously learnt is useful anymore. Also on Android you have to program in Java which is possibly the most demoralising language in the world", "id": "d6uyfjp"}, {"comment": "What do you mean by \"different architecture\"?", "id": "d6vawtp"}, {"comment": "Sorry I meant going from Android to iOS or Windows Phone, I really meant \"platform\"", "id": "d6vbamw"}, {"comment": "did you do Java coding for a long time? why do you feel that way?  I left Java and .net but for different reasons. I found I was too dependent on their respective IDEs and wasn't understanding things deeply.", "id": "d6vewb6"}, {"comment": "For mobile, there's still some of that 'new shiny library that will change your life' going on.  But its nothing compared to the insane web world.  And there are good first party libraries in Android and iOS that you can choose to use.\n\nI much prefer it.  Feels more like software development then js frameworks.", "id": "d6ul310"}, {"comment": "After working on web development using mainly .NET + JS and sometimes in PHP I'm starting to think seriously about switching to native mobile development. I'm really getting tired of all this web frameworks reinventing the wheel over and over again every 3-6 months.", "id": "d6vei3v"}, {"comment": "Mainframe programming (ex Cobol) is about the polar opposite compared to webdev.  Nothing's changed in like 50 years.  Back-end webdev (ex Java, Ruby, PHP) is somewhere in the middle, but tending toward faster changes.  Desktop dev is in the middle, but tending toward slower changes.", "id": "d6ulwla"}, {"comment": "In my experiences no. I wrote desktop EHR software for a long time before moving over to web-based applications. It's all about the platform. It's much easier to insist that users use the latest Chrome browser than a particular OS, for example, and I think users are much less forgiving of desktop-application bugs then they are of browser-application bugs, so there's a tendency to stick with what works vs. what's new.", "id": "d6uw0in"}, {"comment": "Server-side programming is nearly as bad - a lot of it uses long-established Java or .NET frameworks, but, especially at start-ups, there's a tendency to grab whatever new hotness there's buzz about (Go, Kotlin, Node, etc). The turnover is less quick than what happens client side, but still pretty high compared to desktop applications.", "id": "d6uljh2"}, {"comment": "Pretty much everything is bad except C++", "id": "d6uyfjq"}, {"comment": "I like C++ and even I'll admit C++ is huge parts bad. It's so fragmented and littered with historically dead ends that choosing something as simple as the right string isn't always easy. Then there's genuinely broken things like the [most vexing parse](https://en.wikipedia.org/wiki/Most_vexing_parse).", "id": "d6xdvat"}, {"comment": "No I mean that C++ stays reasonably stable. People have been using Boost for years", "id": "d6xg72v"}, {"comment": "True it is stable, but that's more a consequence of timing and age. It was **the** goto language for most things, then even as people moved off of it, it still had a large userbase. Unfortunately the stability comes with the costs I mentioned before.", "id": "d6xhhkf"}, {"comment": "Yes of course. It's definitely not my favourite language by any means, but it is the only popular language I know of that's really this stable. Maybe Python?", "id": "d6xhziw"}, {"comment": "Depends if you count the 2.7/3 split as staying stable ;)", "id": "d6xi45c"}, {"comment": "Yeah you're right, it's probably the biggest blight on python. That and the lack of a standardised way of managing versions. `package.json` is a godsend compared to `venv`...", "id": "d6xilvi"}], [{"comment": "beware of programmers who blog", "id": "d6vpka2"}], [{"comment": "The content is good.", "id": "d6uemkq"}], [{"comment": "Thanks a lot for this! Very helpful and it also linked to a very interesting blog. I'm an Android Developer and have always been meaning to develop my dad a nice website and these are the perfect resources to do it well.", "id": "d6ufg8l"}], [{"comment": "I skipped to the \"shortest route\" section and it was just a bunch of links to resources?", "id": "d6uxx67"}]]], "4nny37": ["NASA's Director of Software Engineering confirms that NASA uses node in Space Suits", "2016-06-12 04:04:43", 0, "https://twitter.com/CollinEstes/status/738767017843515393", [[34, "They use Node.js in \"systems supporting spacesuit operations and development\", which is not at all the same thing as using it in space suits."], [7, "This is why SpaceX is going to take over."], [3, "[**@BenjaminCoe**](https://twitter.com/BenjaminCoe):\n>[2016-06-03 16:10:35 UTC](https://twitter.com/BenjaminCoe/status/738764829746286592)\n\n>[@CollinEstes](https://twitter.com/CollinEstes) I heard a rumor that NASA uses Node.js for space\\-suits. I'm curious, do you use the npm ecosystem to develop these apps?\n\n[**@CollinEstes**](https://twitter.com/CollinEstes):\n>[2016-06-03 16:12:15 UTC](https://twitter.com/CollinEstes/status/738765249407504384)\n\n>[@BenjaminCoe](https://twitter.com/BenjaminCoe) You heard correctly, and yes we do.\n\n[**@BenjaminCoe**](https://twitter.com/BenjaminCoe):\n>[2016-06-03 16:15:12 UTC](https://twitter.com/BenjaminCoe/status/738765990226321408)\n\n>[@CollinEstes](https://twitter.com/CollinEstes) that's amazing, and I'm proud to help people to do such amazing work :\\)\n\n[**@CollinEstes**](https://twitter.com/CollinEstes):\n>[2016-06-03 16:19:17 UTC](https://twitter.com/CollinEstes/status/738767017843515393)\n\n>[@BenjaminCoe](https://twitter.com/BenjaminCoe) Absolutely, you can say you are helping build the present and future systems supporting spacesuit operations and development.\n\n----\n\n[^[Mistake?]](/message/compose/?to=TweetPoster&subject=Error%20Report&message=/4nny37%0A%0APlease leave above link unaltered.)\n[^[Suggestion]](/message/compose/?to=TweetPoster&subject=Suggestion)\n[^[FAQ]](/r/TweetPoster/comments/13relk/)\n[^[Code]](https://github.com/joealcorn/TweetPoster)\n[^[Issues]](https://github.com/joealcorn/TweetPoster/issues)\n"], [4, "to use javascript by choice seems masochistic "], [1, "The loss of marginal litmus test and critical thinking absent to make the leap from \"Node.JS is involved in the planning / coordination of space walks\" to \"Spacesuits run Node.JS\" is astounding."], [0, "No wonder Parmitano had to face live critical issues in one recently."], [-1, "I guess they won.\n\nTime to learn to like JavaScript."]], [[{"comment": "They use Node.js in \"systems supporting spacesuit operations and development\", which is not at all the same thing as using it in space suits.", "id": "d45g69y"}, {"comment": "I can't find this quote you referenced. How do you know the suit doesn't run it?", "id": "d4624ty"}, {"comment": "NASA isn't totally insane?", "id": "d4729w6"}, {"comment": "From what I understand they use it in Space Suit development, the same way we use for an application development.", "id": "d45g8wx"}, {"comment": "The title is worded ambiguously to imply that node is running on the suits themselves.", "id": "d45lakg"}, {"comment": "How do we know the newer prototype suits don't run apps? They must have some kind of control system for the air, etc.", "id": "d45o0a8"}, {"comment": "Because Javascript.", "id": "d45ynu5"}, {"comment": "Yeah I was totally wrong, the guy clarified in this x-post from /r/node: https://www.reddit.com/r/node/comments/4nnydh/nasas_director_of_software_engineering_confirms/d47e5cf", "id": "d47e97c"}], [{"comment": "This is why SpaceX is going to take over.", "id": "d45nvgf"}], [{"comment": "[**@BenjaminCoe**](https://twitter.com/BenjaminCoe):\n>[2016-06-03 16:10:35 UTC](https://twitter.com/BenjaminCoe/status/738764829746286592)\n\n>[@CollinEstes](https://twitter.com/CollinEstes) I heard a rumor that NASA uses Node.js for space\\-suits. I'm curious, do you use the npm ecosystem to develop these apps?\n\n[**@CollinEstes**](https://twitter.com/CollinEstes):\n>[2016-06-03 16:12:15 UTC](https://twitter.com/CollinEstes/status/738765249407504384)\n\n>[@BenjaminCoe](https://twitter.com/BenjaminCoe) You heard correctly, and yes we do.\n\n[**@BenjaminCoe**](https://twitter.com/BenjaminCoe):\n>[2016-06-03 16:15:12 UTC](https://twitter.com/BenjaminCoe/status/738765990226321408)\n\n>[@CollinEstes](https://twitter.com/CollinEstes) that's amazing, and I'm proud to help people to do such amazing work :\\)\n\n[**@CollinEstes**](https://twitter.com/CollinEstes):\n>[2016-06-03 16:19:17 UTC](https://twitter.com/CollinEstes/status/738767017843515393)\n\n>[@BenjaminCoe](https://twitter.com/BenjaminCoe) Absolutely, you can say you are helping build the present and future systems supporting spacesuit operations and development.\n\n----\n\n[^[Mistake?]](/message/compose/?to=TweetPoster&subject=Error%20Report&message=/4nny37%0A%0APlease leave above link unaltered.)\n[^[Suggestion]](/message/compose/?to=TweetPoster&subject=Suggestion)\n[^[FAQ]](/r/TweetPoster/comments/13relk/)\n[^[Code]](https://github.com/joealcorn/TweetPoster)\n[^[Issues]](https://github.com/joealcorn/TweetPoster/issues)\n", "id": "d45g1b0"}], [{"comment": "to use javascript by choice seems masochistic ", "id": "d45zsci"}, {"comment": "Some people just like how asynchronous programming comes so naturally with the language. Nothing wrong with that.", "id": "d4707kb"}, {"comment": "but it doesn't thats why we're bolting on async/await api's now....", "id": "d478e6s"}], [{"comment": "The loss of marginal litmus test and critical thinking absent to make the leap from \"Node.JS is involved in the planning / coordination of space walks\" to \"Spacesuits run Node.JS\" is astounding.", "id": "d4aue61"}], [{"comment": "No wonder Parmitano had to face live critical issues in one recently.", "id": "d45wuc6"}], [{"comment": "I guess they won.\n\nTime to learn to like JavaScript.", "id": "d45g7g6"}]]], "5abunz": ["Being A Developer After 40", "2016-10-31 16:09:45", 0, "https://medium.freecodecamp.com/being-a-developer-after-40-3c5dd112210c#.jsx0xz9tu", [[88, ">If you are a white male remember all the privilege you have enjoyed since birth just because you were born that way. \n\nDon't waste your time with that trash, avoid clicking on it."], [28, "This was a great article if you subtract the preachy bits.\n\n> Do not take a job just for the money.\n\nSometimes, needs must.\n\n>  \u201cyou pay me a salary, but I give you my brain in exchange, and I refuse to comply with this order.\u201d\n\n...lol.\n\n> If you are a white male remember all the privilege you have enjoyed since birth just because you were born that way. \n\nWhat?"], [25, "Great concept for an article (coming from a 45 year old developer).  But yeah, the white privilege comment ended it for me.  I love being told I haven't actually worked for what I have by someone who has no idea what I've gone through."], [17, "There's only one part of that senseless rambling that is actually good advice for being relevant regardless of age or (lack of) life experience:\n\n> Most of what you see and learn in computer science has been around for decades, and this fact is purposedly hidden beneath piles of marketing, books, blog posts and questions on Stack Overflow.\n\nThe rest is rationalizing his life choices as if they were ideal for everyone. No, you don't need to read six meta books a year, no, you don't need to drink Apple's kool-aid instead of Microsoft's, no you don't need to learn a new toy language each year. That's all just circle-jerking and mental masturbation.\n\nJust know how shit actually works, and you're fuckin' golden. If you absolutely must read a book to signal how smart you are, read a textbook, or papers published in CS journals.\n\n> If you are a white male remember all the privilege you have enjoyed since birth just because you were born that way. It is your responsibility to change the industry and its bias towards more inclusion.\n\nlol, no, not really.\n\nIt's funny how these people think the great luck responsible for our success is being born white and male, and not, like most programmers (even those not white and male), having a brain that effortlessly does well in mathematics and analytical thinking."], [12, "The portion describing the fallacy of thinking all best work is done while young resonates with me.\n\nThe more I learn the more fresh ideas I have. Even if some of those ideas have already been explored and matured a long time ago by others it's awesome to see \"how\" they arrived at their inspirations."], [5, "I'll be 50 next year. If I remember I'll post up my list of wise words.\nThey'll be more cynical and be accompanied by zero images of Swindon from the air."], [5, "I clicked on this expecting to read about burnout or age discrimination; turns out the article isn't about being a developer after 40--it's more like a grab-bag of opinions from a developer who happens to have reached that age."], [2, "[deleted]"], [2, "I thought the graph about life satisfaction of Normal vs Nerds was good. Rest was hit and miss."], [2, "I will be 70 next June. My French employer can legally put me in retirement, and they do. It was fun; thanks to our company, best wishes and all respect to those who remain."], [1, "I was expecting the article was going to be about some guy \"starting\" a programming career after 40...disappointed :/"], [-7, "ITT: Everyone ignores pages of good advice because they disagree with helping colored people out."]], [[{"comment": ">If you are a white male remember all the privilege you have enjoyed since birth just because you were born that way. \n\nDon't waste your time with that trash, avoid clicking on it.", "id": "d9fcj3o"}, {"comment": "Some of it was really good and then suddenly, out of nowhere, the entire tone of the article changed for the worse....", "id": "d9fd311"}, {"comment": "I started reading the article before the comments and it wasn't a bad article until that part. I agree with you, completely unnecessary. I'm not going to go around all my life feeling guilty for being a white male.", "id": "d9fdqsp"}, {"comment": "It's not about \"feeling guilty\", it's just about staying aware. It's like Trump calling $1mil a \"small loan\". To him, that is a small loan. To most people, it's not. Don't let the extreme tumblristas detract from the actual virtue of not taking one's fortunate circumstances for granted.", "id": "d9fh91l"}, {"comment": "Really? I thought he was all over the place.", "id": "d9fe9gr"}, {"comment": "Why does it always have to be about race? People still don't get that it's mostly about the money, not the color. Sure white people are still generally richer than non-white people in the US, but this kind of talk makes it seem like non-white privileged people cannot possibly exist.", "id": "d9fgcoq"}, {"comment": "> this kind of talk makes it seem like non-white privileged people cannot possibly exist.\n\nThis kind of talk is intended as a reminder for privileged people to take note of their privilege and share the wealth, so to speak. I agree that we should stop trying to generally address \"white people\" or \"white males\" as though they were some sort of cohesive group. However, racial discrimination is still very much in play; it's more than just wealth.", "id": "d9fhunz"}, {"comment": "Sure, but saying \"You're a white male therefore you have it all just fucking dandy\" is just adding oil to the fire. How about \"remember you're a guy from a stable middle-class or up family and you generally had an easier time in life\"?", "id": "d9fi1k2"}, {"comment": "I do agree that your proposed wording is more tactful. However, removing race and gender from the discussion doesn't quite strike me as the solution, when our industry clearly has a bias towards a certain race and gender.", "id": "d9fjfl3"}, {"comment": "More white males graduate from computer science related fields, thus more white males are getting hired by the industry. In my first year in university there were less than ten women for about a hundred and fifty students. Please explain to me how bias and racism is the issue here.", "id": "d9fk03p"}, {"comment": "The bias exists at all stages of the pipeline. What you notice here is the bias in effect at the beginning of the pipeline. That doesn't mean the bias doesn't also exist at later stages as well.\n\nSo ok, the problem isn't just \"our industry\", it's our society and the expectations and opportunities we project onto various demographics. Isn't a 1:15 female:male ratio in CS indicative to you of some sort of imbalance?", "id": "d9fkvat"}, {"comment": "Yes, it's indicative of an imbalance. So what? Gender equality doesn't mean that magically every gender is interested in an exact 50% proportion in every topic. Also even with that imbalance you still fail to explain why the cause would be bias and racism.", "id": "d9fl1lk"}, {"comment": "> you still fail to explain why the cause would be bias and racism.\n\nYou're right. I can't pick a university and point out that the imbalance exists because professors X, Y, and Z are bigots. That's not the point I'm trying to make.\n\nI'm not a specialist in the field of social studies, so I won't claim to know what the cause is. But I'm pretty sure some of the causes for the imbalances we observe are the cultural expectations that we set.\n\nI don't know what the \"acceptable\" balance is. It doesn't have to be 50:50, but 10:150 seems very off to me.", "id": "d9fmmoj"}, {"comment": "Well surely it can't be because of professors because the imbalance already exists in the enrollment numbers.\n\nA lot of people I know that studied computer science were avid gamers. Gaming leads to tinkering with your computer and maybe even building your own. Sometimes even writing your own add-ons / plugins to certain games\n\nNow if I look at the ratio of girls / boys that played video games in high school I would say that 1:15 is pretty close.\n\nThese days video games are much more popular than ten years ago so I'm sure this will help increase the number of women in tech but it has nothing to do with bias or racism.", "id": "d9fnlmc"}, {"comment": "There is a similar disbalance among the grave diggers, garbage collectors and lorry drivers. Something must be done about it ASAP!!!", "id": "d9gm4z3"}, {"comment": "Funny, you never hear about this male privilege / gender privilege when you are talking about the fact that the majority of garbage collectors are male . . .it only seems to be the top jobs / most desirable positions that have this 'problem' . . . \nIn NYC Garbage collectors that are female :200 out of 7000. Sewage workers:  5 of 426: \n\nAmazing I never see arguments over those jobs and the obvious gender inequality there.. \n\n\n", "id": "d9gf6f9"}, {"comment": "Asian males out earn white males.  They get better grades.\n\nIs there Asian privilege then?", "id": "d9fz8yt"}, {"comment": "If true (citation needed) then yes. Even if they don't earn more than white people, they do seem to be better off than other minorities.\n\nRecognizing privilege isn't about making privileged people feel guilty. It's about staying mindful of the underprivileged and making efforts to lift them up to higher levels of privilege.", "id": "d9g0fzd"}, {"comment": "i am curious...what is the privilege? that their culture encourages hard work in school?", "id": "d9g8cvi"}, {"comment": "Maybe a better idea is to stop all this bullshit about \"privilege\" and recognise the fact that some cultures are more pushing towards hard work/persistent learning than the other. Just as simple as that. There is  no such a thing as a \"privilege\".\n\nTry to sell your SJW agenda to anyone of an older generation from the Eastern Europe, where non-white faces were exotic up until recent, and ladies had it easier simply because learning hard was a default thing for them, while for the lads being too eager to study was somewhat uncool.", "id": "d9gm1v1"}, {"comment": "https://www.youtube.com/watch?v=yEFRcVMRyYM", "id": "d9gxy0j"}, {"comment": "Read what you just said. Then read it again. Then I'll mail you the novel I'm printing on circular logic that I've copy and pasted that comment into 35000 times. Then read the novel. Then ask yourself again how we're supposed to stop making things about race if we don't continue making things about race and realize how stupid that sounds.", "id": "d9fuklx"}, {"comment": "Here's why I don't see it as circular. If there's a problem, and we simply don't talk about it, that doesn't make the problem go away.\n\nThe solution to racial discrimination is not to stop talking about racial discrimination.\n\nSo let's do avoid guilt tripping based on race/gender/whatever (e.g. \"You're a white male therefore you have it all just fucking dandy\") but let's not pretend like there aren't obvious demographic disparities, either. Systemic bias is not a solved problem.", "id": "d9fz2fj"}, {"comment": "Honestly, didn't seem like a big deal to me. The guy went off the rails for a minute. Who knows... Maybe it was a lame attempt at humor? Beyond that, I thought it was a fair representation of one perspective.", "id": "d9fe79g"}, {"comment": "Seriously, it was like two paragraphs out of 50.  But no, let's forget the entire article because it says one thing that makes us feel uncomfortable about ourselves.", "id": "d9fkvj3"}, {"comment": "> says one thing that makes us feel uncomfortable about ourselves.\n\nThere is nothing uncomfortable about that, it is just a sign of self hating stupidity, which in an article that tries to give life advice to others is important.", "id": "d9fmlya"}, {"comment": "He started programming in Argentina in 1997, and now programs from Switzerland, is 40 years old and has what looks to me like a Polish surname, though he was born in Argentina. Remember what Poland looked like in the 1980s?   Do you think *just maybe* that there's a chance he's had a very  different set of life experiences than you? A chance?\n\nI think the reaction on this thread is both provincial and utterly ridiculous.  There are earlier paragraphs where the author talks about this part:\n\n> Even worse; in most workplaces you will be harassed, particularly if you are a woman, a member of the LGBT community or from a non-caucasian ethnic group. I have seen developers threatened to have their work visas not renewed if they did not work faster. I have witnessed harassment of women and gay colleagues.\n\nNo one is complaining about those. Does anyone seriously disagree with that part? Only an idiot could hope to. \n\nYet as soon as we describe the same problem in a different syntax e.g. \"let privilege = ~woman & ~gay & ~ethnicminority\" it is suddenly considered a pretty valid reason to write off not only the whole article that barely touches on these issues (which is an absurd response), but to to write the person off entirely.\nI guess God help us if we ever need to form a cohesive understanding about something by drawing on a wide variety of different perspectives. To render this specifically in more I.T. terms, maybe a failure to be able to perform this conceptual integration is part of why software architecture is done so poorly. ", "id": "d9fx2jv"}, {"comment": ">  Do you think just maybe that there's a chance he's had a very different set of life experiences than you? A chance?\n\nEveryone has different life experiences from others, nobody is an exact copy of others. We can only judge his writing, not his background.\n\n> No one is complaining about those. \n\nOf course, nobody can complain about someone's experiences. And the way he wrote those (e.g using \"most workplaces\", so you cannot comment on his experiences with your own that contradict his, because he didn't say \"all\") doesn't really leave room for comments - what can you comment beyond \"sure, ok\" there? And really, what sort of comment do you expect to get when someone says what was pointed out by the top post? At some point it becomes pointless to even bother, which is why the top post recommended to just ignore the text altogether.", "id": "d9g01jc"}, {"comment": "You're misreading me. I'm not arguing \"waah people shouldn't complain about experiences they didn't have\"; that's a given.\n\nI'm pointing out that readers don't find his highlighting of poor treatment for women, LGBT people and ethnic minorities in the industry objectionable or even notable when it was first introduced, but later they are having a completely allergic reaction to the exact same content when expressed in a different way with the word \"privilege\", which coming from a different background than you, is a word he may have perfectly good reasons for using.\n\nIf we programmers like to laud ourselves as a broadly intelligent group that emphasises rational and objective approaches to issues as a better way than an overly-emotional a \"pack-up-our-toys-and-go-home\" approach, then our reaction here to the word privilege - when we don't object to the same content earlier in the piece phased in different words - is *demonstrably* the type of emotional tantrum we often like to imagine we are somehow above.", "id": "d9g0pl9"}, {"comment": "Sorry, but you are making many assumptions about what people think and then you go to make conclusions about them. For a lot of people this isn't \"the exact same content\" - being unable to see and understand the difference is why you don't understand why people focused on that.", "id": "d9g4plb"}, {"comment": "> For a lot of people this isn't \"the exact same content\" -\n\nWhy don't you tell me what it means to you instead? \n\nBut actually, you've already made my point for me anyway: suppose your claim here was indeed the case - that what \"privilege\" means *differs quite dramatically from person to person*, then clearly: \n\n* it must be an abysmal idea to dismiss an entire 4500 word article (or the author of it) for using including word or concept of \"privilege\" in one or two sentences.  And *even more so* if you make a case to me that \"privilege\" means quite different things to different people.\n", "id": "d9g65pj"}, {"comment": "> Why don't you tell me what it means to you instead? \n\nBecause it is irrelevant to the point i was making and i don't want my personal opinion act as a way to shift the focus away from what i was originally saying...\n\n> that what \"privilege\" means\n\n...although TBH i wonder if that too is hopeless since you do not seem to understand what i'm saying in the first place. I never claimed that what \"privilege\" means is different from person to person.\n\nWhatever, i do not see we have a common ground for discussion anyway, so i'm stopping here since i dislike having to explain things more than once, especially to people who do not seem (in my view at least) interested in actually understanding what i'm saying and instead just want to be right no matter what.", "id": "d9g75qp"}, {"comment": "Had to click just to make sure you were not kidding. Now I feel stupid for giving him more views.", "id": "d9fd3rr"}, {"comment": "Is a good thing that I click on comments before the actual post.", "id": "d9fh42b"}, {"comment": "This is why I come to the comments first.", "id": "d9fhst4"}, {"comment": "Why are you so fucking triggered? Jesus the people here are absolute pussies", "id": "d9flx8l"}, {"comment": "Look at his next sentence.\n\n> It is your responsibility to change the industry and its bias towards more inclusion.\n\nLook at your coworkers. Most of them are white men, no? Possibly all of them. How many are Latino? Black? Women? Very few, right? Possibly none.\n\nOur industry clearly has a bias towards certain demographics. Sorry you got triggered by the phrase \"white male\", but if you can learn to look past that, I think you'll find the author has a valid point.", "id": "d9fivn2"}, {"comment": "Huh, most of our engineers are men, but I'm actually the only white male on the engineering team.", "id": "d9fm8w7"}, {"comment": "I remember telling a Latino friend that my new programming job had a lot of diverse coworkers. He replied \"so, europeans, Indians, and Asians, then?\" And he was right. Is that about right for yours too? (It was still much more diverse than the area where I used to work though, so that's something.)\n\nIt seems weird to me that latinos in particular are such a large minority in the San Francisco area (that's my area, not sure about yours) and yet are so underrepresented in programming.", "id": "d9fn2a8"}, {"comment": "Pretty much, we do a latino and black guy on our team and no indians though.", "id": "d9fo643"}, {"comment": "> Look at your coworkers. Most of them are white men, no? Possibly all of them. How many are Latino? Black? Women? Very few, right? Possibly none.\n\nIf you are a babysitter look at your coworkers. Most of them are women, no? Possibly all of them. How many are Latino or Black men? Very few, right?\nYour industry clearly has a bias towards certain sex/demographics.", "id": "d9fkt0r"}, {"comment": "I get you're joking, but as a teen, I couldn't get hired to babysit because no one trusts boys.", "id": "d9fmbvn"}, {"comment": "It... actually does though. The qualifications needed for babysitter are much less strenuous than those needed for programmer. Our society is biased towards empowering certain demographics to achieve those qualifications, so the other demographics are consequently over represented in jobs with lower barrier to entry.\n\nCEO and board of directors, more likely male. Secretary, more likely female. It's not because women are better secretaries than CEOs, it's because our society pigeonholes people into roles based on demographics.\n\n[edit] just noticed username, will resist temptation to feed the troll any more", "id": "d9flhyn"}, {"comment": "> Most of them are white men, no?\n\nNo.  I sit next to two Indian guys, an Asian guy, three white guys, and an Indian gal.  A row over sits a Latino guy and a Filipino guy.\n\nI still didn't have a problem with those two paragraphs; people are overreacting to \"white male\" and missing the point.  I feel very privileged to make good money doing what I do.", "id": "d9fl2j8"}], [{"comment": "This was a great article if you subtract the preachy bits.\n\n> Do not take a job just for the money.\n\nSometimes, needs must.\n\n>  \u201cyou pay me a salary, but I give you my brain in exchange, and I refuse to comply with this order.\u201d\n\n...lol.\n\n> If you are a white male remember all the privilege you have enjoyed since birth just because you were born that way. \n\nWhat?", "id": "d9febip"}, {"comment": "He's implying that because of your race you didn't work as hard to get where you are as someone of a different race. It's 2016 get with the times you bigot.\n\n/s", "id": "d9fpr9j"}, {"comment": "> IT'S CURRENT YEAR", "id": "d9fs92p"}], [{"comment": "Great concept for an article (coming from a 45 year old developer).  But yeah, the white privilege comment ended it for me.  I love being told I haven't actually worked for what I have by someone who has no idea what I've gone through.", "id": "d9fe0nb"}, {"comment": "Yeah, not sure why a programming article needs to make racist comments.", "id": "d9feaga"}, {"comment": ">  I love being told I haven't actually worked for what I have by someone who has no idea what I've gone through.\n\nThe author didn't say that, he said remember the privilege you've enjoyed.  That's just how you reacted to it.", "id": "d9flar2"}, {"comment": "By speaking to privilege, you indicate that an individual would not have achieved their current status had they not been born the way they were.  \n\nThat is the epitome of negating the work that someone has put into their career to achieve their level of success.  ", "id": "d9fmv0s"}, {"comment": "Not really, it is just what you got from it. When I read the article it did not even cross my mind that he is trying to say that \"you would not have achieved their current status had they not been born the way they were\". What he said is \"you had probably better start to life than a lot of other people. Use it to help them\". You can disagree, that's fine, but throw such a tauntrum, that I see in this thread (this long article is apparently trash because of one sentence), because of it, is ridiculous.", "id": "d9fz3ec"}, {"comment": "And he has no way of knowing that.  He's making an assumption based on his own biases.", "id": "d9k1uei"}, {"comment": "I'm not negating anything when I say that my circumstances helped me to get to where I am today.  That doesn't mean it just happened and that I didn't have to work for it, it just means that I had an easier time of it than others.  I feel no shame in acknowledging that, and it does nothing to diminish my pride in my achievements.", "id": "d9fo7i4"}, {"comment": "But you are.\n\nI grew up in a poor Appalachian town in south eastern Ohio to a single mother.  I knew I wanted to work with computers since I was six years old, and got to write basic programs for an apple IIe at school.  \n\nMy mom couldn't afford to pay for myself or any of my two brothers to go to school, nor could she afford a computer for me to mess around with while in school.  It was everything she could do to keep a roof over our heads and food on our plate.   I got a job at 14 years old, because I wanted to buy a computer and I saved for three years to be able to afford a computer.\n\nBut what you are implying, is that because I am white and male, my drive and determination to overcome a disadvantaged youth, means nothing and that If I had been black and born to a single mother, I could not possibly have become a successful engineer.\n\nYou may have had an advantageous birth, with a silver spoon in your mouth, but just because I'm white doesn't mean I had the same opportunities. ", "id": "d9fqm9f"}, {"comment": "The fact that you were born with less privilege than me doesn't mean others weren't born with less than you.\n\n> But what you are implying, is that because I am white and male, my drive and determination to overcome a disadvantaged youth, means nothing and that If I had been black and born to a single mother, I could not possibly have become a successful engineer.\n\nAgain, not saying that at all, you're making that up in your head.  In fact, I specifically said:\n\n> That doesn't mean it just happened and that I didn't have to work for it\n\nSo clearly I'm not saying that your work means nothing, or that you could not possibly have become an engineer.", "id": "d9ftg2r"}, {"comment": "You're proving my point\n\n> The fact you were born with less privilege than me doesn't mean others weren't born with less than you.\n\nYou cannot extrapolate the color of skin and privilege, there is always someone less privileged than you, and you are going to be less privileged than others.  So your best course of action, is to ignore it, and take the person for whom they currently are, not what they came from, nor how they grew up.  Those things influence them, but it does not define them.\n", "id": "d9fturf"}, {"comment": "You're extrapolating wildly.  Nowhere am I suggesting that anyone should judge anyone else based on how they grew up.", "id": "d9fu9bk"}, {"comment": "What else is privilege for?  Am I supposed to thank my lucky stars that I'm not black?  Am I supposed to look at a black engineer and say \"WOW, he was black and he made it as an Engineer!  That's amazing!\" \n\n\"Thank god, I won the evolutionary lottery, I can't be cognizant of the opportunities presented to me and the work that I performed to take advantage of those opportunities, without acknowledging the fact that somehow, someway, the universe decided I would be white, and I wouldn't have had those same opportunities otherwise.\"", "id": "d9fupbb"}, {"comment": "Do you feel better after getting all that rage off your chest?\n\nYou want to know what you are supposed to do, according to the author?  Here is the entirety of what the author wants you to do as regards race, sex, or whatever:\n\n> Speak out your salary, say it loud, blog about it, so that your peers know how much their work is worth. Companies want you to shut up about that, so that women are paid 70% of what men are paid. So speak up! Blog about it! Tweet it!\n\nAnd:\n\n> It is your responsibility to change the industry and its bias towards more inclusion.\n\nThat's it.  Be inclusive, resist bias, and tell people how much you make.", "id": "d9g0yh2"}, {"comment": "I fail to see the difference, given the author has no idea what privilege I have or have not had.", "id": "d9k1si4"}], [{"comment": "There's only one part of that senseless rambling that is actually good advice for being relevant regardless of age or (lack of) life experience:\n\n> Most of what you see and learn in computer science has been around for decades, and this fact is purposedly hidden beneath piles of marketing, books, blog posts and questions on Stack Overflow.\n\nThe rest is rationalizing his life choices as if they were ideal for everyone. No, you don't need to read six meta books a year, no, you don't need to drink Apple's kool-aid instead of Microsoft's, no you don't need to learn a new toy language each year. That's all just circle-jerking and mental masturbation.\n\nJust know how shit actually works, and you're fuckin' golden. If you absolutely must read a book to signal how smart you are, read a textbook, or papers published in CS journals.\n\n> If you are a white male remember all the privilege you have enjoyed since birth just because you were born that way. It is your responsibility to change the industry and its bias towards more inclusion.\n\nlol, no, not really.\n\nIt's funny how these people think the great luck responsible for our success is being born white and male, and not, like most programmers (even those not white and male), having a brain that effortlessly does well in mathematics and analytical thinking.", "id": "d9fni06"}], [{"comment": "The portion describing the fallacy of thinking all best work is done while young resonates with me.\n\nThe more I learn the more fresh ideas I have. Even if some of those ideas have already been explored and matured a long time ago by others it's awesome to see \"how\" they arrived at their inspirations.", "id": "d9f8xxb"}], [{"comment": "I'll be 50 next year. If I remember I'll post up my list of wise words.\nThey'll be more cynical and be accompanied by zero images of Swindon from the air.", "id": "d9fnxwu"}], [{"comment": "I clicked on this expecting to read about burnout or age discrimination; turns out the article isn't about being a developer after 40--it's more like a grab-bag of opinions from a developer who happens to have reached that age.", "id": "d9fvcos"}], [{"comment": "[deleted]", "id": "d9feyr2"}, {"comment": "It's not really a stamina thing.\n\nIt's that you start realizing just how much of what you do at work is bullshit that doesn't matter. Then you start learning how much you can get away with not doing, while still getting paid the same amount of money.\n\nAnd there you go.", "id": "d9ffkus"}, {"comment": "This. The best thing, hands down, about being 40+ is having acquired the ability to simply reject the industry standard running in place to look busy.", "id": "d9fh17n"}, {"comment": "That.", "id": "d9fh1q4"}, {"comment": "So true.  I just crossed the 40 year line.  One of the best things I've learned is knowing which tasks to completely ignore because they will go from hair-on-fire important to totally unnecessary in a week's time.\n\nedit: the converse is also true and useful to learn: knowing what yet unknown/unassigned task to work on because it will need to be done in the near future. Doing this just once every year or two has made me golden.", "id": "d9fjt48"}, {"comment": "I was fortunate to get this lesson early in my career.  My second lead would come to me every week with a month's worth of tasks that must be done in a week or everything is fucked.  I'd just ask him which one to do first.  By next week I'd completed 4 out of 20 of the tasks and he'd come to me with a completely different list of 20 tasks that must be done this week or everything is fucked.  This went on for three years.", "id": "d9fnndi"}, {"comment": "[deleted]", "id": "d9fhv8f"}, {"comment": "Yeah.  \"Move fast and break things\" becomes \"move at a sustainable pace and look before you leap\" with experience.\n\nAlso, I don't think either of these is wrong.  When you're young, you learn more rapidly by moving fast and breaking things.", "id": "d9fle94"}, {"comment": "Are there no senior developers that you look up to? Might be time to look for a new employer. You don't want the complacent people as mentors.\n\nBe careful to distinguish between just plain \"slow\" versus \"a steady, deliberate pace.\" Junior developers sometimes go full-throttle only to spin their wheels, putting too much time into the wrong tasks or creating a lot of technical debt. Good senior developers know how to balance current and future needs, and how to deliver value consistently.", "id": "d9fie5y"}], [{"comment": "I thought the graph about life satisfaction of Normal vs Nerds was good. Rest was hit and miss.", "id": "d9fhm3g"}], [{"comment": "I will be 70 next June. My French employer can legally put me in retirement, and they do. It was fun; thanks to our company, best wishes and all respect to those who remain.", "id": "d9fxcc6"}], [{"comment": "I was expecting the article was going to be about some guy \"starting\" a programming career after 40...disappointed :/", "id": "d9fpu0f"}], [{"comment": "ITT: Everyone ignores pages of good advice because they disagree with helping colored people out.", "id": "d9fqrn0"}, {"comment": "Advice is pretty shitty too.", "id": "d9fxn05"}]]], "4ead0e": ["Google considering making Swift a first class language for Android", "2016-04-11 15:50:41", 0, "http://tnw.to/i4zix", [[31, "Not that garbage article again...\n\nThere are zero sources in that article, it's 100% speculation.\n"], [17, "I doubt this will happen"], [12, "> But, Kotlin is billed as a language that \u201cworks everywhere Java works,\u201d and has \u201cseamless\u201d support for projects that mix it and Java.\n\nBesides above and the fact that it needs JVM to run, I do not know how it can be considered any improvement over Java at all as far as Oracle litigation is concerned. Seems more like a wishful thinking on someone's part."], [6, "I like Swift but I doubt Google will replace Java on Android any time soon. From a practical point of view, Google will need to reimplement the Android API in Swift which is not something that you do overnight. This will also risk to alienate their Java programer base. Because Swift doesn't currently work with C++, every C++ system library will need to add a C interface.\n\nIt will be way easier for Google to switch to C# and .NET now that Xamarin is open source, but I don't think this will happen. Going from Java to C# seems more natural than going from Java to Swift.\n\nGiven the fact that Google recently started to migrate to OpenJDK I think Java will remain Android's programming language for the foreseeable future.\n"], [4, "Rust for Android :P"], [1, "Well I guess I should consider swapping my Kotlin books for Swift ones now"], [1, "Why on earth wouldn't they pick Go if they moved away from Java? I don't see why they would move away from Java though. If anything I'd expect them to assist in providing shims for their APIs in multiple languages so they're more idiomatic for consumers."], [-1, "I don't think Swift is such a great language. Sure it's an improvement over Obj-C, but there are much better languages out there. I wished Google would embrace Scala more. It gives you already a next generation highly expressive and mature system right now. If they are concerned about Oracle and the JVM, Scala already runs on other VMs such as Avian, or on JS using Scala.js, and possibly soon natively with an LLVM backend.\n\nThe main problem they will have in all cases is that they need to build an entirely new API - as the case with Oracle is precisely about the API."], [0, "does that mean it would be better to use swift than java?"]], [[{"comment": "Not that garbage article again...\n\nThere are zero sources in that article, it's 100% speculation.\n", "id": "d1yfcm4"}, {"comment": "Wait so, do we reject anonymous sources now? Does TNW putting their credibility on the line mean nothing at all?", "id": "d1zii5w"}, {"comment": "Saying \"X is considering doing Y according to anonymous sources\" is hardly putting your credibility on the line since it's an unfalsifiable claim.\n", "id": "d1zxqlf"}, {"comment": "Why does everyone who submits this make a big deal about TNW's reputation and credibility.  They're a by-the-numbers tech blog, they're not going to be winning a Pullitzer Prize any time soon.", "id": "d1zn3eo"}, {"comment": "Im not, really. A certain amount of pride is ordinary.", "id": "d1znkso"}], [{"comment": "I doubt this will happen", "id": "d1yeohf"}, {"comment": "Why? Swift is a much nicer language for developers than Java, and iOS still has the biggest share of app development. Adopting Swift would bring more development to Android, which benefits Google greatly.\n\nHonestly, I was expecting Microsoft to make this move before Google. They are already working on their Objective-C bridge, and it only makes sense they would want to bring Swift over too, as most new iOS development is going to happen in Swift rather than Objective-C.", "id": "d1yexii"}, {"comment": "Because Google was never interested in a nicer language for Android?\nEnough devs accepted for years the Java 6.5 that Google allowed them to write to not force them to worry about developer feelings.", "id": "d1yf6gt"}, {"comment": "Android was almost a .NET stack device back in the day...If only...", "id": "d1yftoa"}, {"comment": "Can you link me to a source? That sounds interesting af", "id": "d1yhwql"}, {"comment": "I can't seem to find the blog post but it was a devlog way back in the day.  Ultimately they decided on Java over .NET because Java wasn't owned by an abusive corporate entity.  I still find that funny.", "id": "d1yuvkt"}, {"comment": "There is no such source.\n\nWhat there is, is an email between a senior person in the Android project and someone else at Google worrying about Intellectual Property saying: \"If Sun won't play ball we can either: a) go ahead anyway, or b) rewrite everything in C#\u00a0or something.\"\n\nThe context made it clear that everything already was Java by the time this exchange took place, nothing said anything about Android \"almost\" being a .NET stack.", "id": "d1zn4x7"}, {"comment": "What.", "id": "d1yfnda"}, {"comment": "Is most iOS development going to Swift though?  The few teams I've known who work with it complain about constantly breaking API's, missing features and talk about the language itself as being half baked at best.  The only real advantage is has is that it's not Objective-C which is why people are using it.  Java seems like a better development language in almost every way.  I say that as someone who doesn't really like Java.", "id": "d1yfs9q"}, {"comment": "> Is most iOS development going to Swift though? The few teams I've known who work with it complain about constantly breaking API's, missing features and talk about the language itself as being half baked at best. \n\nAPI changes are slowing down, and from 2.0 forward it is far from half-baked. It is by far my favourite language at this point.\n\n> The only real advantage is has is that it's not Objective-C which is why people are using it. Java seems like a better development language in almost every way.\n\nNot even close. Swift is much more expressive and comfortable to use.\n\nI seriously doubt you will find many new projects being started in Objective-C.", "id": "d1yksmk"}], [{"comment": "> But, Kotlin is billed as a language that \u201cworks everywhere Java works,\u201d and has \u201cseamless\u201d support for projects that mix it and Java.\n\nBesides above and the fact that it needs JVM to run, I do not know how it can be considered any improvement over Java at all as far as Oracle litigation is concerned. Seems more like a wishful thinking on someone's part.", "id": "d1yepda"}, {"comment": "just go to the website and look up all the nice features it has. Srsly, i cannot understand how someone not go crazy about it. We switched to kotlin and it is sooooo much easier, better and more maintanable with these new language features.", "id": "d1yfcig"}, {"comment": "You're missing the point. This isn't about whether Kotlin is good or not. This is about Google choosing to move away from Java and, ergo, the JVM.", "id": "d1ygiak"}, {"comment": "Android doesn't even use the JVM. Dalvik (now ART) has no Oracle/OpenJDK code in it, it was written from scratch and doesn't even rely on Java byte code. Java code is compiled into Java byte code and then to Dalvik byte code (and with the new Jack compiler, it compiles straight from Java to Dalvik byte code).\n\nThe litigation with Oracle was about the Java standard library APIs. And even then, Android used the Apache Harmony project for it's implementation of those APIs. In Android N Google is actually switching to the OpenJDK implementation of those APIs, which doesn't exactly sound like \"Google choosing to move away from Java\".\n\nAnd finally, Kotlin doesn't rely on the JVM at all, in fact it already has a JavaScript target, and they are/were also consider adding an LLVM target.", "id": "d1yltmd"}, {"comment": "I agree with you completely. The litigation is ridiculous and there is no reason for Google to ditch Java. That is a completely separate issue from whether Kotlin is any good or not, which is what the previous poster was getting tied up on.", "id": "d1yovuc"}, {"comment": "\"A benefit of Swift is that it can serve as both a forward-facing language as well as a server-side one.\"\n\nbut swift can run on the server! /s", "id": "d1zo8ch"}], [{"comment": "I like Swift but I doubt Google will replace Java on Android any time soon. From a practical point of view, Google will need to reimplement the Android API in Swift which is not something that you do overnight. This will also risk to alienate their Java programer base. Because Swift doesn't currently work with C++, every C++ system library will need to add a C interface.\n\nIt will be way easier for Google to switch to C# and .NET now that Xamarin is open source, but I don't think this will happen. Going from Java to C# seems more natural than going from Java to Swift.\n\nGiven the fact that Google recently started to migrate to OpenJDK I think Java will remain Android's programming language for the foreseeable future.\n", "id": "d1yext1"}, {"comment": "> Because Swift doesn't currently work with C++, every C++ system library will need to add a C interface.\n\nNeither does Java. JNI functions need to be `extern \"C\"`.", "id": "d1yf47v"}, {"comment": "Interestingly, Xamarin already did a conversion of Android Ice Cream Sandwich to C# a few years ago and it was faster and more efficient than the Java version. You can see the story [here](https://blog.xamarin.com/android-in-c-sharp/)", "id": "d1yircc"}, {"comment": "Hail C#!", "id": "d1zehiq"}], [{"comment": "Rust for Android :P", "id": "d1yggjk"}, {"comment": "Already happening. Rust for iOS seems much further off though :<", "id": "d1ziiht"}], [{"comment": "Well I guess I should consider swapping my Kotlin books for Swift ones now", "id": "d1ydmab"}], [{"comment": "Why on earth wouldn't they pick Go if they moved away from Java? I don't see why they would move away from Java though. If anything I'd expect them to assist in providing shims for their APIs in multiple languages so they're more idiomatic for consumers.", "id": "d1ytjdu"}], [{"comment": "I don't think Swift is such a great language. Sure it's an improvement over Obj-C, but there are much better languages out there. I wished Google would embrace Scala more. It gives you already a next generation highly expressive and mature system right now. If they are concerned about Oracle and the JVM, Scala already runs on other VMs such as Avian, or on JS using Scala.js, and possibly soon natively with an LLVM backend.\n\nThe main problem they will have in all cases is that they need to build an entirely new API - as the case with Oracle is precisely about the API.", "id": "d1yg7i0"}], [{"comment": "does that mean it would be better to use swift than java?", "id": "d1yij19"}]]], "42wt6d": ["The High Price of Free", "2016-01-27 12:53:44", 0, "http://alistapart.com/article/the-high-price-of-free", [[4, "[deleted]"], [2, "> Despite having very marketable skills, I don\u2019t own a home, much less have a pension and savings in place.\n\nNot having a home might be a life choice, however I can only urge the OP to correct the last two points; especially at 41 it's high time to think about it :x"], [0, "Its hard to believe you can't spare a couple of hours every now and then -- once a week, maybe once a month -- to file a bug report, push a simple fix, etc\n\nWriting with the perspective that there's an overwhelming expectation that everyone contribute boatloads of time to some OSS project is disingenuous. This just seems like an article to subtly sneak in links to GeekFeminism and more shit about 'privilege'\n\n> Do we want our future to be dictated by big companies, with independent input coming only from those young or privileged enough to be able to work some of the time without payment?\n\nlol"], [0, "This is stupid on so many levels"]], [[{"comment": "[deleted]", "id": "czdpwo9"}, {"comment": "> The author also argues that contributing to open source is a privilege!\n\nIt is.\n\nYou need to be in a job that allows you to allocate time for open source projects, or you need to have the financial resources to do that work in your spare time.\n\nYou also need to _have_ that spare time. Talk to somebody doing several minimum wage jobs to feed their families about setting aside a couple of hours every week.", "id": "czdvavm"}, {"comment": "[deleted]", "id": "czeuupr"}, {"comment": "Everybody should in theory be able to contribute to open source and free software. You are limiting tour scope to people that are high!y privileged (they had the resources to get the necesary training) to work in IT already.\n\nAnd even in IT there are lots of soul-crushing jobs that do not leave you the energy to contribute to open source in your spare time. And contracts that basically make the company own all source code you ever write or make you require written permission from the legal department to do anything not directly work related.\n\nGo out and look at the real world once in a while.", "id": "czevdf0"}, {"comment": "[deleted]", "id": "czewo9m"}, {"comment": "What makes you think that there are no privileged people in Africa? It is a entire continent full of people with very different backgrounds!\n\nIt is almost always not \"you\" that sells a license to something, it is the company you work for. In most cases the developer-you is employed by that company. That \"you\" is not free to decide to support free or open source software during work hours: It has to work on what its boss tells it to work on. \"You\" might not even be allowed to contribute in your spare time!\n\nAdmittedly the author is owning the company she works for, so she is in the great position of not having to ask for permission to contribute to free software and open source projects. She definitely is privileged there!\n\nThe whole article is about her being unable to sustainably set aside a certain amount of time to work on projects of her own choosing (most likely open source/free software). She needs that time to earn the money necessary to feed herself and her family and to set aside some savings for later. Apparently she is not privileged enough to contribute after all:-/\n\nI do agree that there is a _moral_ obligation to contribute back to the free and open source software community, but as long as you follow the licenses there is no _legal_ obligation to do so. I can think of a number of things that trump the moral obligation: The need to keep yourself and your family clothed and feed is definitely one of those. And this of course includes being able to set aside some money for your retirement.\n\nThat is exactly what the author wants to raise awareness for.", "id": "czf70xw"}, {"comment": "Good that you feel that way. Check in with me when you are 45 and see if you begin to share her worries.", "id": "czdrw0g"}], [{"comment": "> Despite having very marketable skills, I don\u2019t own a home, much less have a pension and savings in place.\n\nNot having a home might be a life choice, however I can only urge the OP to correct the last two points; especially at 41 it's high time to think about it :x", "id": "czdz8ue"}], [{"comment": "Its hard to believe you can't spare a couple of hours every now and then -- once a week, maybe once a month -- to file a bug report, push a simple fix, etc\n\nWriting with the perspective that there's an overwhelming expectation that everyone contribute boatloads of time to some OSS project is disingenuous. This just seems like an article to subtly sneak in links to GeekFeminism and more shit about 'privilege'\n\n> Do we want our future to be dictated by big companies, with independent input coming only from those young or privileged enough to be able to work some of the time without payment?\n\nlol", "id": "czdyp7l"}], [{"comment": "This is stupid on so many levels", "id": "czew1jm"}]]], "56hk5q": ["Data denormalization is broken", "2016-10-08 19:58:41", 2, "https://hackernoon.com/data-denormalization-is-broken-7b697352f405#.fkenz7mx0", [[1, "Database in Depth by C.J. Date (which surprisingly is only 10 years old) already discussed how extracting information from a denormalized schema is hard and error prone. What the article gets wrong is that in most situations, a normalized schema will be fast- and when it doesn't, indexing will probably do. And yes, there will be situations where a properly indexed normalized schema won't do, but those should be exceptions. "]], [[{"comment": "Database in Depth by C.J. Date (which surprisingly is only 10 years old) already discussed how extracting information from a denormalized schema is hard and error prone. What the article gets wrong is that in most situations, a normalized schema will be fast- and when it doesn't, indexing will probably do. And yes, there will be situations where a properly indexed normalized schema won't do, but those should be exceptions. ", "id": "d8kbhlv"}]]], "44alu9": ["IBM Launches Cloud Data and Analytics Marketplace", "2016-02-05 15:25:17", 56, "http://cloudtweaks.com/2016/02/ibm-launches-cloud-data-and-analytics-marketplace-for-developers/", [[27, "[deleted]"], [28, "Yay!  Reddit has gone full \"Native Advertising\"!\n\nFuck I hate this place"], [10, "I read the word \"Enterprise\" and my eyes glaze over from not understanding why I would care about their products."], [3, "price??"], [4, "Butt data?"], [3, "Compose is awesome, so there's that."], [2, "Coke is delicious and good for you.   Don't take my word for it, stop by your neighborhood market and pick up an ice-cold bottle today!\n\n\n"], [1, "On a quick scan I thought this was a post about an Intercontinental Ballistic Missile Launch. ... no need to do the dishes."], [1, "I hope they are not using [JSONx](https://www-01.ibm.com/support/knowledgecenter/SS9H2Y_7.2.0/com.ibm.dp.doc/json_jsonxconversionexample.html) in these services"], [-4, "[deleted]"]], [[{"comment": "[deleted]", "id": "czou5w1"}, {"comment": "The upvote to comment ratio doesn't seem right to me", "id": "czou725"}, {"comment": "Why the fuck is this third on my front page", "id": "czouust"}, {"comment": "[deleted]", "id": "czovbap"}, {"comment": "Why is it terrible?", "id": "czovhnf"}, {"comment": "[deleted]", "id": "czow50i"}, {"comment": "Which \"IBM Cloud\" are you talking about? \n\nSoftLayer, BlueMix, SmartCloud Enterprise, ^IBM ^Cloud ^Manager ^with ^OpenStack, ^^IBM ^^Cloud ^^Orchestrator, ^^^IBM ^^^Cloud ^^^Managed ^^^Services ...?", "id": "czp0l6e"}, {"comment": "Why do all of those things exist? What's the difference between them?", "id": "czp9s3y"}, {"comment": "[deleted]", "id": "czp14x7"}, {"comment": "I think IBM is going to provide a CloudFactory from which you can make your own clouds if you do not like default one.", "id": "czp0j75"}, {"comment": "CloudFactoryFactoryBuilderFactory", "id": "czp1s1o"}, {"comment": "are you just figuring out that reddit is completely gamed???", "id": "czovw9d"}, {"comment": "Yes, and it's a turd. If you'd like APIs and dev tools from the 90s this is the platform for you. ", "id": "czouyb6"}], [{"comment": "Yay!  Reddit has gone full \"Native Advertising\"!\n\nFuck I hate this place", "id": "czowmsf"}, {"comment": "This is what caused the Great Digg exodus of '010", "id": "czoxbe7"}, {"comment": "Now we just need a polarizing redesign!", "id": "czoyuc2"}, {"comment": "Got a good alternative yet?  I actually installed apps for the NYTimes and Guardian on my phone", "id": "czoy3dd"}, {"comment": "HackerNews is one alternative, although the people there  can be a little... intense.   ", "id": "czpio8o"}, {"comment": "I  hate the pub at the end of my street, so I stopped going. ", "id": "czoy4cu"}, {"comment": "Jaybus. I just realized Vice is a Reddit advertising partner. No wonder so many of their shit \"news\" articles end up all over the place.\n", "id": "czp1jw1"}], [{"comment": "I read the word \"Enterprise\" and my eyes glaze over from not understanding why I would care about their products.", "id": "czovesg"}, {"comment": "They're targeted at the \"bosses of developers\", which is different than what you or I care about. There's a lot of really interesting tech underneath but the packaging is just dire.", "id": "czpc3hg"}], [{"comment": "price??", "id": "czou5ro"}, {"comment": "If you have to ask, you can't afford it. ", "id": "czouwys"}, {"comment": "Yes.", "id": "czouul1"}, {"comment": "I was trying to figure this out too. I'm not so interested in the \"cloud data and analytics\" just wondering how regular VPS services compare to AWS/GCE/Azure, and maybe see what watson has to offer.  Seems like there's some info at https://console.ng.bluemix.net/pricing/  \n\nThis documentation is ... verbose, yet unhelpful (things like \"Business analytics for the proactive enterprise\"). It seems a lot of services are in beta, and free at the moment, until live launch. Price after launch is not apparent. Like the IBM version of S3: \"free tier: Single Service Instance with 5GB limit; beta tier: Storage usage becomes pay go at service go live (cost: free).\" Or prices are just insane: runtime for python/php/etc for $0.07/gb-hr ($47/mo)?!\n\nAnyways, here's what I was able to find, from https://console.ng.bluemix.net/catalog/  \n\nNote: this is not a complete or accurate listing, just a quick summary.  \n\n-----\n\n## [Runtimes](https://www.ng.bluemix.net/docs/cfapps/runtimes.html)    \n\n[xsp](https://console.ng.bluemix.net/catalog/starters/ibm-xpages/) / [java liberty](https://console.ng.bluemix.net/catalog/starters/liberty-for-java/) / [nodejs](https://console.ng.bluemix.net/catalog/starters/sdk-for-nodejs/) / [go](https://console.ng.bluemix.net/catalog/starters/go/) / [php](https://console.ng.bluemix.net/catalog/starters/php/) / [python](https://console.ng.bluemix.net/catalog/starters/python/) / [ruby](https://console.ng.bluemix.net/catalog/starters/ruby/) -- $0.07/GB-Hr  \n\n-----\n\n## [Containers](https://www.ng.bluemix.net/docs/containers/container_index.html)  \n\n$0.0288 USD/GB-Hour (for memory)  \n$2.06 USD/additional public IP address  \n$14.40 USD/additional 20 GB external storage  \n\n-----\n\n## [Virtual machines](https://www.ng.bluemix.net/docs/virtualmachines/vm_index.html)  \n\nCan't find info? \n\n-----\n\n## [Watson](https://www.ng.bluemix.net/docs/services/watson.html)  \n\n[alchemy api](http://www.alchemyapi.com/api) -- \"understand the content and context within text and images\"  \n1 - 250,000 requests -- $0.007 USD/Events  \n250,001 - 5,000,000 requests -- $0.001 USD/Events  \n5,000,000+ requests -- $0.0002 USD/Events  \n\n[Concept Expansion](https://www.ibm.com/smarterplanet/us/en/ibmwatson/developercloud/concept-expansion.html) -- \"analyzes large amounts of text to create a dictionary of contextually related words\"  \nbeta -- free  \n\n[Concept Insights](https://www.ibm.com/smarterplanet/us/en/ibmwatson/developercloud/concept-insights.html) -- \" maps input text to a concept graph that is based on the English language Wikipedia\"  \n1 - 1,000,000 requests -- $0.002 USD/api call  \n1,000,001 - 10,000,000  requests -- $0.0015 USD/api call  \n10,000,000+  requests -- $0.001 USD/api call  \n\n[dialog](https://www.ibm.com/smarterplanet/us/en/ibmwatson/developercloud/dialog.html) -- \"automate branching conversations between a user and your application\" (NLP)   \n$0.02 USD/api call  \n\n[Document Conversion](https://www.ibm.com/smarterplanet/us/en/ibmwatson/developercloud/document-conversion.html) -- \"The input is a single PDF, Word, or HTML document and the output is an HTML document, a Text document, or Answer units that can be used with other Watson services\"  \n$0.05 USD/MEGABYTE  \n\n[Language Translation](https://www.ibm.com/smarterplanet/us/en/ibmwatson/developercloud/language-translation.html) -- \"domain-specific translation utilizing Statistical Machine Translation techniques\"  \nBase Service (First million characters are free)  -- $0.02 USD/THOUSAND CHAR  \nAdvanced Model Add-on -- $3.00 USD/THOUSAND CHAR  \n\n[Natural Language Classifier](https://www.ibm.com/smarterplanet/us/en/ibmwatson/developercloud/nl-classifier.html) -- \"create natural language interfaces for their applications\"    \n1 Natural Language Classifier instance free per month -- $20.00 USD/ Instance per month\n1000 API calls free per month  -- $0.0035 USD/ API call\n4 Training Events free per month  -- $3.00 USD/ Training Event\n\n[Personality Insights](https://www.ibm.com/smarterplanet/us/en/ibmwatson/developercloud/personality-insights.html) -- \"analyzes a spectrum of personality attributes to help discover actionable insights about people and entities\"  \n1 - 100,000 requests -- $0.20 USD/api call  \n100,001 - 250,000 requests -- $0.10 USD/api call  \n250,000+ requests -- $0.05 USD/api call  \n\n[Relationship Extraction](https://www.ibm.com/smarterplanet/us/en/ibmwatson/developercloud/relationship-extraction.html) -- \"Parses sentences into their various components and detects relationships between the components\"  \nbeta -- free  \n\n[Retrieve and Rank](https://www.ibm.com/smarterplanet/us/en/ibmwatson/developercloud/retrieve-rank.html) -- \"helps users find the most relevant information for their query\"  \nretrieve -- $0.30 USD/dedicated high availability Retrieve Solr cluster per instance hour  \nrank -- $0.0009 USD/Rank API call  \n\n[speech to text](https://www.ibm.com/smarterplanet/us/en/ibmwatson/developercloud/speech-to-text.html) -- \"convert speech in multiple languages into text\"  \n$0.02 USD/MINUTE\n\n[text to speech](https://www.ibm.com/smarterplanet/us/en/ibmwatson/developercloud/text-to-speech.html) -- \"generate synthesized audio output \"  \t\n$0.02 USD/THOUSAND CHAR  \n\n[Tradeoff Analytics](https://www.ibm.com/smarterplanet/us/en/ibmwatson/developercloud/tradeoff-analytics.html) -- \"helps people make decisions when balancing multiple objectives\"  \n$0.03 USD/api call  \n\n[Visual Recognition](https://www.ibm.com/smarterplanet/us/en/ibmwatson/developercloud/visual-recognition.html) -- \"understand the contents of an image\"  \nbeta -- free  \n\n-----\n\n## [mobile](https://www.ng.bluemix.net/docs/mobile/index.html)  \n\n[Push Notifications](https://www.ng.bluemix.net/docs/services/mobilepush/index.html)  \n$20.00 USD/Million Digital Message  \n\n[Mobile Application Content Manager](https://www.ng.bluemix.net/docs/services/macm/index.html) -- \"enables a mobile project team to engage app users with personal and contextual content\"  \n$500.00 USD/Million API calls  \n\n[Mobile Client Access](https://www.ng.bluemix.net/docs/#services/mobileaccess/index.html) -- \"Finely tune mobile apps with operational analytics from real time performance and data usage\"  \n$0.03 USD/Daily Client Device  \n\n[Mobile Quality Assurance](https://www.ng.bluemix.net/docs/#services/MobileQualityAssurance/index.html#MobileQualityAssurance) -- \"enables mobile app testing, user validation, and streamlined quality feedback with sentiment analysis\"  \n$199.00 USD/application-platform,  $0.02 USD/addressable device  \n\n[Presence Insights](https://www.ng.bluemix.net/docs/#services/presenceinsights/index.html) -- \"helps you understand mobile activity in and around a physical location\"  \nfree tier -- Allows up to 500,000 events per month  \nbasic tier -- $1,000.00 USD/Instance  \n\n", "id": "czp3onq"}, {"comment": "(continuted)  \n\n-----\n\n## Web and Application  \n\n[Business Rules](https://www.ng.bluemix.net/docs/#services/rules/index.html#rules) -- \"spend less time recoding and testing when the business policy changes\"  \n$1.00 USD/1,000 API calls  \n\n[Data Cache](https://www.ng.bluemix.net/docs/#services/DataCache/index.html#data_cache) -- \"Improve the performance and user experience of web applications\"  \nstarter tier -- 1 GB of cache space and a replica -- $55.00 USD/Instance  \n\n[Message Hub](https://www.ng.bluemix.net/docs/services/MessageHub/index.html) -- \" scalable, distributed, high throughput message bus to unite your on-premise and off-premise cloud technologies\"  \n1 - 200,000,000 requets tier -- $0.10 USD/Million Digital Messages  \n\n[MQ Light](https://www.ng.bluemix.net/docs/#services/MQLight/index.html#mqlight010) -- \"Develop responsive, scalable applications with a fully-managed messaging provider\"  \n$5.00 USD/Million digital messages  \n\n[Session Cache](https://www.ng.bluemix.net/docs/#services/SessionCache/index.html#session_cache)  -- \"storing session state information across many HTTP requests\"  \nstarter tier -- $55.00 USD/Instance  \n\n[WebSphere Application Server](http://www.ng.bluemix.net/docs/services/ApplicationServeronCloud/index.html) -- \"This service gives you the WebSphere Application Server experience in Bluemix\"  \nWAS Core Plan -- $0.41 USD/Hour  \n\n[Workflow](https://www.ng.bluemix.net/docs/#services/workflow/index.html#workflow) -- \"makes it easy for you to create workflows that orchestrate and coordinate the REST-based services that you use in your apps\"  \n$0.01 USD/Started Task  \n\n[Workload Scheduler](http://www.ng.bluemix.net/docs/#services/WorkloadScheduler/index.html#gettingstarted) -- \"Exploit our APIs to trigger the execution of simple or complex sequences of actions (REST call, database query, etc..)\"  \n$0.056 USD/Job  \n\n-----\n\n## network  \n\n[vpn](https://www.ng.bluemix.net/docs/services/vpn/index.html)  \nbeta - free  \n\n-----\n\n## integration  \n\n[API Management](https://www.ng.bluemix.net/docs/services/APIManagement/index.html) --  \"enables developers and organizations to manage and enforce policies around the consumption of their business services\"  \n$5.65 USD/100K API calls  \n\n[Cloud Integration](https://www.ng.bluemix.net/docs/#services/CloudIntegration/index.html#gettingstartedwithcloudintegation) -- \"enables users to integrate cloud services with enterprise systems of record\"  \n$150.00 USD/Endpoint  \n\n[Connect & Compose](https://www.ng.bluemix.net/docs/services/ConnectandCompose/index.html) -- \"enables users to integrate cloud services with enterprise systems of record\" (same text...)  \nbeta -- free  \n\n[Secure Gateway](https://www.ng.bluemix.net/docs/#services/SecureGateway/index.html#gettingstartedsecuregateway) -- \" brings Hybrid Integration capability to your Bluemix environment\"  \n$0.10 USD/GIGABYTE  \n\n[Service Discovery](https://www.ng.bluemix.net/docs/services/ServiceDiscovery/index.html) -- \"lightweight directory that enables microservices to dynamically register and locate each other at runtime\"  \nfree  \n\n-----  \n\n## [Data and Analytics](https://www.ng.bluemix.net/docs/services/data_analytics.html) (lots of broken links)  \n\n[Analytics for Apache Hadoop](https://www.ng.bluemix.net/docs/#services/AnalyticsforHadoop/index.html#analyticsforhadoop)   \nUp to 50 GB of HDFS data -- free  \n(no other plans)  \n\n[Apache Spark](https://www.ng.bluemix.net/docs/services/AnalyticsforApacheSpark/index.html) -- \"open source cluster computing framework\"  \n$0.70 USD/Instance-Hour  \n\n[BigInsights for Apache Hadoop](https://www.ng.bluemix.net/docs/#services/BigInsights/index.html#biginsights) -- \"Develop analytics applications by using open source Apache Hadoop and BigInsights\"  \nplan: enterprise (no price info)  \n\n[Cloudant NoSQL DB](https://www.ng.bluemix.net/docs/#services/Cloudant/index.html#Cloudant)   \n$1.00 USD/GB, $0.03 USD/1000 Light API Calls, $0.15 USD/1000 Heavy API Calls  \n\n[dashDB](https://www.ng.bluemix.net/docs/#services/dashDB/index.html#dashDB) -- \"data warehousing and analytics solution\"  \nentry tier -- $50.00 USD/Monthly  \n\n[DataWorks](https://www.ng.bluemix.net/docs/#services/dataworks1/index.html#dataworks) -- \"fully managed data preparation and movement service\"  \nstart tier -- Up to 10GB per activity -- free  \nno other price info.  \n\n[Elasticsearch by Compose](https://docs.compose.io/getting-started/compose.html) \nfree  \n\n[Geospatial Analytics](https://www.ng.bluemix.net/docs/#services/geospatial/index.html#geospatial)   \n$3.00 USD/1M Region Checks\n\n[IBM DB2 on Cloud](https://www.ng.bluemix.net/docs/services/DB2OnCloud/index.html) -- \"provides a database on IBM's SoftLayer\u00ae\"  \nsmall tier -- $1,000.00 USD/Instance  \n\n[IBM Graph](https://www.ng.bluemix.net/docs/services/graphdb/index.html) -- \"graph database service for storing, querying, and visualizing data points\"  \nfree  \n\n[Insights for Twitter](https://www.ng.bluemix.net/docs/#services/Twitter/index.html) -- \"sentiment and other enrichments\"  \nfree tier -- 5 million tweets  \nentry plan -- 1 (yes) million tweets  -- $2,000/month  \n\n[Insights for Weather](https://www.ng.bluemix.net/docs/services/Weather/index.html) -- \"integrate historical and real-time weather data\"  \nfree tier -- 10 Calls Per Minute, 500 Calls Per Day  \n\n[MongoDB by Compose](https://docs.compose.io/getting-started/compose.html)   \nfree  \n\n[Object Storage (v1)](https://www.ng.bluemix.net/docs/services/ObjectStorageV1/index.html) -- \" for IBM Analytics for Apache Spark only\"  \nbeta -- free  \n\n[PostgreSQL by Compose](https://docs.compose.io/getting-started/compose.html)   \nfree  \n\n[Predictive Analytics](http://www.ng.bluemix.net/docs/#services/PredictiveModeling/index.html) -- \"integrate predictive capabilities with their applications\"  \nfree tier,  \npaid plan -- $10.00 USD/Instance, $0.50 USD/1,000 Real-time predictions  \n\n[Redis by Compose](https://docs.compose.io/getting-started/compose.html)   \nfree  \n\n[SQL Database](http://www.ng.bluemix.net/docs/#services/SQLDB/index.html) -- \"Powered by DB2\"  \nfree tier, limit 100mb  \npremium -- $400/instance  \n\n[Streaming Analytics](https://www.ng.bluemix.net/docs/services/StreamingAnalytics/index.html) -- \"Ingest, analyze, monitor, and correlate data as it arrives from real-time data sources.\"  \n$3.75 USD/Node hour  \n\n[Time Series Database](https://www.ng.bluemix.net/docs/#services/TimeSeries/index.html#timeseriesdatabase) -- \"purpose-built for fast and efficient storage and analysis of time series data\"  \n$50.00 USD/Instance  \n\n-----\n\n## [security](https://www.ng.bluemix.net/docs/security/index.html)  \n\n[Application Security](https://www.ng.bluemix.net/docs/#services/ApplicationSecurityManager/index.html#app_sec_manager)   \nfree  \n\n[AppScan Dynamic Analyzer](https://ng.bluemix.net/docs/#services/AppScanDynamicAnalyzer/index.html) -- \" identifying security issues in web applications, to help you keep them secure. IMPORTANT: THIS SERVICE WILL BE DEPRECATED ON FEBRUARY 11, 2016\"   \n$1,250.00 USD/Scan  \n\n[AppScan Mobile Analyzer](https://ng.bluemix.net/docs/#services/AppScanMobileAnalyzer/index.html) -- \" identifying security issues in your Android applications, to help you keep them secure. IMPORTANT: THIS SERVICE WILL BE DEPRECATED ON FEBRUARY 11, 2016\"    \n$1,250.00 USD/Scan  \n\n[Mobile Analyzer for iOS](https://ng.bluemix.net/docs/#services/AppScanIOS/index.html) -- \"identifying security issues in your iOS applications, to help you keep them secure. IMPORTANT: THIS SERVICE WILL BE DEPRECATED ON FEBRUARY 11, 2016\"    \nfree  \n\n[Single Sign On](https://www.ng.bluemix.net/docs/#services/SingleSignOn/index.html#sso_gettingstarted) -- \"Implement user authentication for your web and mobile apps quickly, using simple policy-based configurations.\"  \nstandard -- $2.00 USD/Application-User  \n\n[Static Analyzer](https://ng.bluemix.net/docs/#services/StaticAnalyzer/index.html) -- \"Find security vulnerabilities early in development, so you can fix them before deployment. IMPORTANT: THIS SERVICE WILL BE DEPRECATED ON FEBRUARY 11, 2016\"  \nfree  \n\n-----\n\n## [storage](https://www.ng.bluemix.net/docs/services/storage.html)  \n\n[Object Storage](https://www.ng.bluemix.net/docs/services/ObjectStorage/index.html) -- \"provides an unstructured cloud data store\"  \nbeta -- free  \n\n-----\n\n## [Business Analytics](https://www.ng.bluemix.net/docs/services/businessanalytics.html)  \n\n[Embeddable Reporting](https://www.ng.bluemix.net/docs/#services/EmbeddableReporting/index.html#gettingstartedtemplate) -- \"Include dashboards and reports in your web or mobile application\"  \nfree  \n\n[Cupenya Insights](http://cupenya.github.io/ibm-bluemix-support/) -- \"Business analytics for the proactive enterprise\"  \nfree  \n\n-----\n\n## [Internet of Things](https://www.ng.bluemix.net/docs/services/internetofthings.html)  \n\n[Internet of Things Foundation](https://www.ng.bluemix.net/docs/#services/IoT/index.html) -- \"lets your apps communicate with and consume data collected by your connected devices, sensors, and gateways\"  \nfree tier -- 20 active devices, 100MB data, 1GB storage  \nbronze tier -- free tier plus up to 100 devices, $20.00 USD/Instance, $0.20 USD/Active Device, $0.01 USD/Megabytes Exchanged  \n\n[IoT Real-Time Insights](http://www.ng.bluemix.net/docs/services/iotrtinsights/index.html) -- \"allows you to understand IoT data in context and monitor the conditions of your devices and operations\"  \nfree tier -- 25 MB data analyzed/month  \nbronze tier -- $100.00 USD/Instance, $1.00 USD/Megabyte Exchanged, $2.00 USD/100 Megabyte Month", "id": "czp3p2h"}, {"comment": "> API Management -- \"enables developers and organizations to manage and enforce policies around the consumption of their business services\"\n> $5.65 USD/100K API calls\n\nIs this expensive?\n\nAmazing info gathering by the way", "id": "czp8fi2"}, {"comment": "It's expensive.\n\nAWS has API gateway which has the same function and that's $3.50 per million calls for proxying, auth, rate limiting, analytics etc.\n\nThere's also the open source api gateway kong, it can handle 84,373,200 api requests per day* on a m3.medium (on demand cost is $49 per month) according the benchmark on their website.\n\n**Edit:** *Forgot to put per day.", "id": "czp9uz6"}], [{"comment": "Butt data?", "id": "czov6b1"}, {"comment": "People without the cloud2butt extension will not get this joke :)", "id": "czoxydh"}], [{"comment": "Compose is awesome, so there's that.", "id": "czoyn3b"}], [{"comment": "Coke is delicious and good for you.   Don't take my word for it, stop by your neighborhood market and pick up an ice-cold bottle today!\n\n\n", "id": "czoyvcx"}], [{"comment": "On a quick scan I thought this was a post about an Intercontinental Ballistic Missile Launch. ... no need to do the dishes.", "id": "czoxtis"}], [{"comment": "I hope they are not using [JSONx](https://www-01.ibm.com/support/knowledgecenter/SS9H2Y_7.2.0/com.ibm.dp.doc/json_jsonxconversionexample.html) in these services", "id": "czoy1ke"}], [{"comment": "[deleted]", "id": "czot90b"}, {"comment": "Watson doesn't like you.", "id": "czotqim"}, {"comment": "IBM staff are paid not to have any opinions.", "id": "czotz11"}, {"comment": "But they apparently are paid to upvote Reddit posts about their new products ", "id": "czowj87"}, {"comment": "[deleted]", "id": "czp18eo"}, {"comment": "IBM is smart enough to hire an outside company to create upvote bots.  \nI have a lot of friends who's parents worked for IBM.  The nicest thing any of them said about it was they got decent buyouts.  ", "id": "czp1fvl"}]]], "43kxax": ["A Small, Nice Thing", "2016-02-01 00:05:44", 1, "http://codahale.com/a-small-nice-thing/", [[7, "I was expecting the punchline to be\n\nMatlab:\n\n    a + b"], [7, "Slightly unfair comparison.  For the case with two lists, you can use the exact same form of expression in Python as in Clojure, i.e. `map(operator.add, a, b)`.  And don't give me that crap about `map()` being un-Pythonic.  Code is Pythonic if it's readable.  Do you think `map(operator.add, a, b)` is more readable than `[sum(t) for t in zip(a, b)]`?  I do.  (Note that in 3.x `map()` returns an iterator and not a list, so they aren't directly comparable, but in most cases you can just use that iterator wherever you were going to use a list.  If you just have to have a list you can wrap it in `list(...)`.)\n"], [5, "haskell pulls people in like this too...some programs can be expressed with incredible economy and elegance...but real-world programs are ugly in any language, particularly those that try to change your worldview about state"], [3, "I'm not convinced by this in the same way that I don't buy the \"need to understand 12 concepts in order to write hello world in java\". first of all, hello world in itself is not important. second of all, it's not representative. third of all, most of it can be handvawed and deferred to a later time.\n\nAnd I still like the Haskell/Scala approach to this over the Lisp one."]], [[{"comment": "I was expecting the punchline to be\n\nMatlab:\n\n    a + b", "id": "czizll2"}], [{"comment": "Slightly unfair comparison.  For the case with two lists, you can use the exact same form of expression in Python as in Clojure, i.e. `map(operator.add, a, b)`.  And don't give me that crap about `map()` being un-Pythonic.  Code is Pythonic if it's readable.  Do you think `map(operator.add, a, b)` is more readable than `[sum(t) for t in zip(a, b)]`?  I do.  (Note that in 3.x `map()` returns an iterator and not a list, so they aren't directly comparable, but in most cases you can just use that iterator wherever you were going to use a list.  If you just have to have a list you can wrap it in `list(...)`.)\n", "id": "cziyz4w"}, {"comment": "Yes, he skips over a lot of things that need to be explained in the Clojure context. `+` is a variadic function and so is `map` in this case. So you first have to explain what variadic functions are. Another thing to explain is `+`. It is in lisp land what's known as a symbol. You can say that s-expressions are simple but this trips people up all the time. So far we have variadic functions, symbols, s-expressions. Continuing. The docs say `map` returns a lazy sequence. Ok, so now you have to figure out what is a lazy sequence and what that means in terms of eager sequences. Then there is this\n> Returns a transducer when\nno collection is provided.\n\nOk, what is this transducer thing now? Anyway. The simplicity is illusory. Clojure is a nice language but the irreducible conceptual complexity of mapping over collections is inherent in all the examples and Clojure doesn't make it magically go away.", "id": "czizi3x"}, {"comment": "There's absolutely nothing special about `+` in Lisp. It's just a function. A symbol is just a label that points to whatever you assign it to, it has nothing to do with semantics of the `+` function. Therefore, exactly same semantics apply everywhere as opposed to in languages where you have operators, functions, expressions, methods, and so on. Each of those things has its own behaviors and rules regarding how and where they can be used.\n\nYou're of course correct that the underlying mechanics have inherent complexity. However, these are not things that the user has to know or care about most of the time as they don't affect the language semantics.  You can use `map` and `+` without having to know what a transduecer is.\n\nI think the article is correct pointing out that you have to learn very few rules to use Clojure effectively. I find that Clojure has far less complexity than most languages out there.", "id": "czj0sd4"}, {"comment": "The `map(operator.add, a, b)` approach doesn't extend well to a third list. If you're looking for a properly analogous example, it would be better to do `map(sum, zip(a, b))`. It's slightly more complex since you have to use the `zip` function, but now you can generalize easily: `map(sum, zip(a, b, c))`.\n\nIn any case, Guido van Rossum himself argued for [removing map from python 3](http://www.artima.com/weblogs/viewpost.jsp?thread=98196), so I think it's fair to say that the list comprehension is the more pythonic version; though I'll admit I'm partial to the `map(sum, zip(..))` version.", "id": "czjbise"}, {"comment": "The only real difference is that `add` isn't variadic. Given that defining a variadic one is as trivial as `def add(*args): return sum(args)`, I don't see why you wouldn't do that.\n\nThen you can just do `map(add, a, b, c)`, and it's just like Clojure.", "id": "czjvwwx"}, {"comment": "Well, sure, but most of these languages can produce a similar result if you start defining new functions. I could certainly define appropriate `map` and `add` functions in javascript to make that exact same `map(add, a, b, c)` work just fine, but I think it's fair to say that that wouldn't be idiomatic.\n\nIf I were reviewing real code that included your version of `add` I would totally tell the coder to rewrite the thing using `zip` (or better yet, the list comprehension from the original article). Defining extra functions for simple operations when you could be using built-ins hurts readability for very little benefit.", "id": "czjy15b"}, {"comment": "I don't have any particular version to having lots of small functions (on the contrary I'm fine with it), but my point wasn't to say that this is what you *should* do. I was merely trying to say that judging Clojure as simpler because it happens to have a variadic addition function is extremely odd.\n\nFWIW, my preference would almost always be `(x + y for x, y in zip(xs, ys))`; it gives the opportunity for meaningful names, which I like, and it's more clear than `map(sum, zip(xs, ys))`.\n", "id": "czjyeqj"}], [{"comment": "haskell pulls people in like this too...some programs can be expressed with incredible economy and elegance...but real-world programs are ugly in any language, particularly those that try to change your worldview about state", "id": "czj3mux"}, {"comment": "Just because real world problems are ugly, that doesn't mean that the language doesn't play a role. I've been developing with Clojure in the real world for the past 5 years, and it's certainly a lot cleaner than most of the languages I've used.", "id": "czjbne1"}], [{"comment": "I'm not convinced by this in the same way that I don't buy the \"need to understand 12 concepts in order to write hello world in java\". first of all, hello world in itself is not important. second of all, it's not representative. third of all, most of it can be handvawed and deferred to a later time.\n\nAnd I still like the Haskell/Scala approach to this over the Lisp one.", "id": "czjdhqj"}]]], "5akszl": ["Future of Programming - Rise of the Scientific Programmer (and fall of the craftsman)", "2016-11-01 22:33:58", 0, "http://byterot.blogspot.com/2015/01/future-of-programming-rise-of-the-scientific-developer-bigdata-datascience-machine-learning-and-fall-of-the-craftsman.html", [[11, "oh god help us."], [3, "Wow that was insular."], [1, "Yada yada yada Look at me, I went to Camridge yada yada yada. Hope he'll stay away from Indonesian sex workers."], [1, "I personally think it was a good article to read"]], [[{"comment": "oh god help us.", "id": "d9h8n41"}, {"comment": "My thoughts exactly ", "id": "d9hmde7"}, {"comment": "But it is good! \nYou know, progress is important in IT and this IS progress.", "id": "d9i8uyw"}], [{"comment": "Wow that was insular.", "id": "d9ho05z"}], [{"comment": "Yada yada yada Look at me, I went to Camridge yada yada yada. Hope he'll stay away from Indonesian sex workers.", "id": "d9hnyj8"}], [{"comment": "I personally think it was a good article to read", "id": "d9k1z7i"}]]], "4rhb6m": ["How to run Linux and Bash on \"Windows 10 Anniversary Update\"", "2016-07-06 11:11:09", 0, "http://www.hanselman.com/blog/VIDEOHowToRunLinuxAndBashOnWindows10AnniversaryUpdate.aspx", [[2, "That was a very informative video. This looks amazing and I'm excited for the 2nd August."], [1, "The only issue I've encountered so far is that you cannot have the 'Use Legacy Console' config option set in Command Prompt else Bash will immediately force close.\n\nThis may break workflow for some. In my case, I had to adjust a number of Atom plugins I was using that required the legacy flash for command prompt integration.\n\nA little bit of permissions juggling in one instance as well since root is disabled in Ubuntu by default (and Windows Bash is an Ubuntu userspace).\n\nThe only other quirk is that the Linux Subsystem folders are hidden in some way and you can't actually navigate to them via the file explorer, but you can manually enter the path to access the folder.  Creating a shortcut with the folder path was my workaround for that. \n\nAside from those little things, Bash is a very welcome addition to Win 10."], [-3, "Yuck... just run Linux. "]], [[{"comment": "That was a very informative video. This looks amazing and I'm excited for the 2nd August.", "id": "d51dudw"}], [{"comment": "The only issue I've encountered so far is that you cannot have the 'Use Legacy Console' config option set in Command Prompt else Bash will immediately force close.\n\nThis may break workflow for some. In my case, I had to adjust a number of Atom plugins I was using that required the legacy flash for command prompt integration.\n\nA little bit of permissions juggling in one instance as well since root is disabled in Ubuntu by default (and Windows Bash is an Ubuntu userspace).\n\nThe only other quirk is that the Linux Subsystem folders are hidden in some way and you can't actually navigate to them via the file explorer, but you can manually enter the path to access the folder.  Creating a shortcut with the folder path was my workaround for that. \n\nAside from those little things, Bash is a very welcome addition to Win 10.", "id": "d51gzty"}], [{"comment": "Yuck... just run Linux. ", "id": "d51gzfl"}, {"comment": "Why would we do that and introduce all the tradeoffs of Linux when Bash is available for Windows?\n\nI don't find it particularly practical or efficient to have to maintain a Linux VM to do occasional builds when I can now ctrl-alt-t into Bash while in Windows.\n\nIf there's a downside, I'm certainly hard-pressed to see it.", "id": "d51hfi0"}, {"comment": "I love spaghetti. I love chocolate.\n\nI don't want chocolate-covered spaghetti.\n\nThe downside is: The trend toward monoliths. Not everything should be mixed together to have a 'me too' featureset. And also, the other ugly trend: vendor-lock-in.", "id": "d51jujx"}, {"comment": "Microsoft is pushing for end-all monolith of development. They are supporting every platform and language under the sun in VS and VSCode. They are using it as a pipe to keep users but promote Azure for people to host what they make in whatever platform. They aren't using it to promote users use Windows to run Linux apps in any form beyond development.", "id": "d51lfs0"}, {"comment": "If you can't run Linux because your corporate VPN or Email system is not supported, and your employer only supports Windows and Mac, and you find it petty to leave a good job over an OS restriction... Near-native Ubuntu on Windows is pretty fucking welcome.", "id": "d51zc7v"}]]], "51sxiq": ["Sophisticated OS X Backdoor Discovered", "2016-09-08 22:54:53", 23, "https://securelist.com/blog/research/75990/the-missing-piece-sophisticated-os-x-backdoor-discovered/", [[44, "So \"rootkit\" is now passe, now we're calling malware a backdoor?  **BOOO!!!!**"], [28, "\"Sophisticated\" \"OS X\" \"Backdoor\"\n\ntl;dr - It's not sophisticated, it's a Window/Linux exploit adapted to Mac, and it isn't a backdoor."], [26, "Truly awful title. Not sophisticated, not OS X specific, not a backdoor."], [15, "I don't understand how this is a rootkit, or why it is sophisticated.\n\nThis is a simple userspace application which copies itself to a location and provides userspace data acquisition and command execution."], [13, "op, this is not really /r/programming content. might go better in netsec or another reddit. "], [9, "A backdoor comes in the OS. This is not a backdoor."], [9, "Because of the mac vs pc ads, almost all new users walked into our Apple reseller thinking osx was immune against stuff like this. \n\nI'm actually surprised that Apple was never sued for false advertising "], [4, "That title makes it sound like it's a backdoor built-in by Apple. It's very misleading."], [2, "How to test for and remove?"], [2, "Doesn't sound sofisticated though."], [2, "https://news.ycombinator.com/item?id=12455034\n"]], [[{"comment": "So \"rootkit\" is now passe, now we're calling malware a backdoor?  **BOOO!!!!**", "id": "d7eqzmd"}, {"comment": "*Sophisticated* Backdoor.", "id": "d7esrhb"}, {"comment": "I thought that the determining feature of rootkit was that they ran with elevated/kernel privileges? This malware appears to run in user mode, in a non elevated context.", "id": "d7evw3n"}, {"comment": "Yeah, exactly.  Particularly the defining characteristic of a rootkit is that it uses those higher privileges to hide itself from the rest of the system.", "id": "d7ezxa0"}, {"comment": "..that is runs as 'root', hence the name? ", "id": "d7ffeck"}, {"comment": "Just running as root isn't enough to be a rootkit; actively hiding itself from the rest of the system is a large (and arguably most important) part of the definition.  This piece of malware isn't doing things like hooking system calls so that it's binary doesn't show up in directory listings, or running the rest of the kernel in a super thin virtual machine so that it doesn't show up in /dev/mem.\n\nEDIT:  And re-reading the article, it's not even clear that this malware runs as root.  Everything it does is stuff that normal user code can do.", "id": "d7fpizc"}, {"comment": "It's a rootkit when you do it yourself, a backdoor when somebody else fucks you.", "id": "d7ezyhy"}], [{"comment": "\"Sophisticated\" \"OS X\" \"Backdoor\"\n\ntl;dr - It's not sophisticated, it's a Window/Linux exploit adapted to Mac, and it isn't a backdoor.", "id": "d7ewyij"}, {"comment": "> tl;dr - It's not sophisticated, it's a Window/Linux exploit adapted to Mac, and it isn't a backdoor.\n\nIt's a three-platform exploit. Hardly \"adapted to mac\" - nobody knows which platform they made first and which last. Unless you do know?", "id": "d7fd43x"}, {"comment": "This is winning the \"Bad Title Contest\" \u2013 not OP fault but: Stefan Ortloff  is the awardee. Smells like Click-bait :( ", "id": "d7fekol"}], [{"comment": "Truly awful title. Not sophisticated, not OS X specific, not a backdoor.", "id": "d7exqhy"}, {"comment": "I'll just leave the rest of the title then: ~~Sophisticated OS X Backdoor~~ Discovered\n\nHm.", "id": "d7fgrrq"}], [{"comment": "I don't understand how this is a rootkit, or why it is sophisticated.\n\nThis is a simple userspace application which copies itself to a location and provides userspace data acquisition and command execution.", "id": "d7ew15x"}], [{"comment": "op, this is not really /r/programming content. might go better in netsec or another reddit. ", "id": "d7euxtf"}, {"comment": "[deleted]", "id": "d7f3dz9"}, {"comment": "OP wouldn't give a shit I reckon. Check is submission history, they just spams dozens of submissions every day so I doubt they spend much time caring about how appropriate the submission is past \"Could I get karma?\"  \n  \nEdit: Correction, I just did the math and in the past month OP has submitted 300 articles so JUST under a dozen a day.", "id": "d7fqpb3"}], [{"comment": "A backdoor comes in the OS. This is not a backdoor.", "id": "d7f43gg"}], [{"comment": "Because of the mac vs pc ads, almost all new users walked into our Apple reseller thinking osx was immune against stuff like this. \n\nI'm actually surprised that Apple was never sued for false advertising ", "id": "d7eqpbk"}, {"comment": "They (ie this post by securelist)  don't present any evidence that this is self-installing.   It sounds like this is a user-installed program that requires the user to bypass the usual OSX protections against unsigned code.\n\nIt *seems* like this is a 'backdoor' that is installed only if the user actively bypasses OSX security in order to install it, which requires clicking a lot of yes boxes.\n\nA real rootkit (like the recent Israeli iPhone hack) would take control from the web and/or from non-privileged userland.  \n\nThis is like saying \"we found a firebomb that hits Macs, but requires the user to douse the computer with gasoline and drop a match.\"\n\n\n\n", "id": "d7eu5p3"}, {"comment": "You just need to use the hipster *curl |sh* to be owned by it.\n\nQuite a few people still disable those annoying security dialogs (from their point of view).", "id": "d7fb594"}, {"comment": "Yes.. However, we had salespeople there telling people they don't need Anti-virus, even before Apple started blocking unsigned apps. \n\nThe way the Mac vs PC ads played out strongly implied Mac's had security against trojans too. \n\nAnd I was the only salesperson there who actually told customers they weren't immune, but just there weren't many trojans available for them. \n\nThis was also at a time that Apple had huge gaping Java exploits built in that took ages to fix. ", "id": "d7ezetm"}, {"comment": "And for a long time you didn't really need antivirus, because the ecosystem didn't sustain viruses, as you say.\n\nToday, the signed app restrictions seem pretty robust.\n\nAt every point, I think that Apple users were much less likely to get viruses.  Not immune, but just a lot safer than Windows. First it was because of obscurity, but also because it had comparatively few glaring holes compared to Windows, like the fact that Macs needed a password to install software.\n\nToday, I'll hazard a guess that Windows has caught up, but I think that Microsoft's insistence on backward compatibility turned them into a viral cesspool for years and years, which the Mac *mostly* escaped, not because it was great, but because Windows was awful.", "id": "d7f0tf6"}, {"comment": "Before Mac OS X, Mac OS was a Swiss cheese.", "id": "d7fb6wp"}, {"comment": "I don't use antiviruses for both Mac and Windows. And I don't have problems on both platforms. There are few basic security rules that allows to live without viruses, but usually I recommend to install anti-viruses for not experienced users. ", "id": "d7fduth"}, {"comment": "has apple ever made such a statement?", "id": "d7es2vk"}, {"comment": "[No, but they were certainly thinking it loudly.](https://www.youtube.com/watch?v=ZwQpPqPKbAw)", "id": "d7eu01i"}, {"comment": "If it ever went to court they could probably say they only claim immunity to \"windows malware\" which is obviously true, because it's not Mac software\n\nEdit: apparently the wording was [\"PC viruses\"](http://m.imgur.com/2dbqfiC?r)", "id": "d7etofl"}, {"comment": "That was at a time where a fresh install of XP would be infected by malware before you could even download the patches to prevent it.", "id": "d7f0mcg"}], [{"comment": "That title makes it sound like it's a backdoor built-in by Apple. It's very misleading.", "id": "d7fdwxk"}], [{"comment": "How to test for and remove?", "id": "d7er6bv"}, {"comment": "Look for all the files that they've listed and for the associated launchd PLIST, I'm guessing.", "id": "d7evxbn"}], [{"comment": "Doesn't sound sofisticated though.", "id": "d7f96ak"}], [{"comment": "https://news.ycombinator.com/item?id=12455034\n", "id": "d7ffda5"}]]], "4diqh0": ["Link \"GitHub organizations can now block abusive users\" removed from this subreddit, despite 72 points (86% positive upvotes) and many comments. Why?", "2016-04-06 01:57:13", 20, "https://www.reddit.com/r/programming/comments/4demnr/github_organizations_can_now_block_abusive_users/", [[28, "Maybe it was removed because it's not about programming, but the politics of programming. Like this thread, which has the same problem."], [15, "Because Github PR."], [12, "> If there is no code in your link, it probably doesn't belong here."], [9, "Geez ppl. It's not like Reddit was designed as a system for readers to decide what info should bubble up without mods."], [-2, "Github != programming"], [-11, "Because your reactionary \"lol le TRIGGERED\" bullshit got old before it even started. Grow up."]], [[{"comment": "Maybe it was removed because it's not about programming, but the politics of programming. Like this thread, which has the same problem.", "id": "d1rh6gn"}, {"comment": "If that's the criteria then the majority of posts to this subreddit should be removed.", "id": "d1rl3r2"}, {"comment": "And they frequently are.\n\nEvery week there's a new \"Codeless Code\" link posted, and every week it gets promptly reported and removed (I'm amazed the whole site hasn't just been banned yet).  I'm not a mod, but it has always been my understanding (and the observations fit) that \"/r/programming\" is subtly different to \"/r/programmers\".  Politics, interview techniques, freelancing, etc are all things of interest to \"programmers\", but they are not code, so they are not \"programming\".  From the side-bar:\n\n> Just because it has a computer in it doesn't make it programming.\n\n> If there is no code in your link, it probably doesn't belong here.\n\nThere is even a link to [this](https://en.wikipedia.org/wiki/Computer_programming) page, whose first paragraph is a pretty good summary.  That page does also list several non-code considerations that could be argued to fall under \"programming\" without having any code (thus justifying the \"probably\" in the no code rule), such as maintainability, comments, robustness etc.  Those are all things important when actually writing code, but that are not code, so articles on them would be in scope without actually necessarily containing any code.\n\nBut as I say, that's just my understanding and I'm not at all an official spokesperson.  There are plenty of other related subreddits where things like github politics would be maybe more relevant.", "id": "d1rz1qx"}, {"comment": "I agree, but many non-programming links are left alone too, the rule seems enforced sporadically, which is not a great basis for a rule, it basically comes down to moderators choice what stays and what goes.", "id": "d1s8g2d"}, {"comment": "Oh please, it's relevant to software developers who use Github. I imagine at least 60% of the userbase in this subreddit uses Github in some capacity.", "id": "d1rs7qd"}, {"comment": "Yes, that seems reasonable. I really don't know what's acceptable as a topic here. I'm just offering a guess. But the fact is that it was removed, for some reason.", "id": "d1rsfrh"}, {"comment": "This is a meta post though.  Should be fine.", "id": "d1rqkba"}, {"comment": "I guess that's true. People sometimes need to sort out what's topical, so short what's-topical discussions are accepted.", "id": "d1rsd9b"}, {"comment": "/r/techculture", "id": "d1rm2do"}, {"comment": "Meta discussions are acceptable, though.", "id": "d1rqz2p"}, {"comment": "I would imagine that some meta discussions are acceptable, like what's topical, like this. But I imagine the politics of programming might be regarded as off-topic. I'm just guessing here, I don't actually know.", "id": "d1rs8lu"}], [{"comment": "Because Github PR.", "id": "d1rjcsg"}], [{"comment": "> If there is no code in your link, it probably doesn't belong here.", "id": "d1rd78g"}, {"comment": "Are you kidding me? There is no code in 8 from top 10 submissions which are now in _hot_ either.", "id": "d1rdte9"}, {"comment": "Why the downvotes? I literally copied and pasted from the sidebar. Be mad at the mods, not me.", "id": "d1rhnr9"}, {"comment": "In addition to the fact that the sub is literally flooded with posts with no code (the most popular post last week was [Microsoft is bringing the Bash shell to Windows 10](https://www.reddit.com/r/programming/comments/4clk26/microsoft_is_bringing_the_bash_shell_to_windows_10/)), none of the other posts about new Github features ([Squash your commits on Github](https://www.reddit.com/r/programming/comments/4cx9a8/squash_your_commits_on_github/), [Github adds Reactions to Pull Requests, Issues, and Comments](https://www.reddit.com/r/programming/comments/49vqzv/github_adds_reactions_to_pull_requests_issues_and/), etc. currently [GitHub - GPG signature verification](https://github.com/blog/2144-gpg-signature-verification)) have been delisted.", "id": "d1rni8e"}, {"comment": "I don't understand why people find that so difficult to understand.", "id": "d1rl72v"}, {"comment": "/r/programming/comments/4diqh0/link_github_organizations_can_now_block_abusive/d1rdte9", "id": "d1rpbfw"}], [{"comment": "Geez ppl. It's not like Reddit was designed as a system for readers to decide what info should bubble up without mods.", "id": "d1rrnoq"}], [{"comment": "Github != programming", "id": "d1rk36c"}, {"comment": "Are you saying that version control systems are not relevant to programming?", "id": "d1rvs5y"}, {"comment": "[deleted]", "id": "d1rxk1c"}, {"comment": "It's a company which has a website which is a user interface to a version control system. \n\nSo if that's off-limits, then I guess IDEs are off limits, after all they're just an interface to compilers and editors, aren't they?", "id": "d1s1v60"}, {"comment": "Git is a CVS, Guthub is a shitty website that uses Git, big difference.", "id": "d1ryu95"}], [{"comment": "Because your reactionary \"lol le TRIGGERED\" bullshit got old before it even started. Grow up.", "id": "d1rvia1"}]]], "4lp9a5": ["Builder in C#", "2016-05-30 16:16:02", 1, "http://blogs.tedneward.com/patterns/Builder-CSharp/", [[10, "this is very, very wrong. I can see absolutely no reason to follow this. some of the issues:\n* Product can apparently exist in an invalid state, prevention of which is only reason for the pattern\n* proliferation of classes, if you want to encapsulate logic for complex components, extension methods should be easier\n* modifying object in a property getter? a big no\n"], [5, "\nIs it just me that prefers the first version? Its clean, readable and less code meaning more maintainable. \n\nDon't get me wrong, the fluent version is all jazzy but what do you gain? (or am I missing something)"], [4, "I don't get it. With the introduction of object and collection initializers, what's the point of having a builder like that?\n\nThat said, I will use fluent syntax for mutating immutable objects. But that's because they can't use initializers."], [4, "Your instantiating a class to basically build a class. A shared function on the class could do the same thing and be a lot easier to find. The only caveat would be if all the \"parts\" don't inherit from the same base class; since you don't really want to take an array of objects as a constructor; nor do you want to limit what it takes to construct it.  \n  \nHaving to call Begin and Build means you need to tell people how to use your builder class. Most people would glance over the Product class and then wonder how do i create one.  \n  \nFunctions should be used instead of a property getter since a getter shouldn't be modifying the underlying object.  \n  \n    var p = Product.ConstructThing(new Engine(EngineType.V8),  \n                                   new Tire(TireType.Radial, 200, 100), \n                                   new Tire(TireType.Radial, 200, 100), \n                                   new SteeringWheel(Color.Black));"], [3, "I thought we stopped making these kinds of huge fucking messes about ten years ago.  "]], [[{"comment": "this is very, very wrong. I can see absolutely no reason to follow this. some of the issues:\n* Product can apparently exist in an invalid state, prevention of which is only reason for the pattern\n* proliferation of classes, if you want to encapsulate logic for complex components, extension methods should be easier\n* modifying object in a property getter? a big no\n", "id": "d3p9unx"}], [{"comment": "\nIs it just me that prefers the first version? Its clean, readable and less code meaning more maintainable. \n\nDon't get me wrong, the fluent version is all jazzy but what do you gain? (or am I missing something)", "id": "d3pb7aa"}, {"comment": "I use builders quite a bit to make legacy code more testable. Fluent builders lend themselves to method chaining which is less syntax for the consumer.", "id": "d3pgmls"}, {"comment": "Okay, I see. I understand about the method chaining. Not thought about the testability aspect.  I am still on the fence though.", "id": "d3ph9e7"}], [{"comment": "I don't get it. With the introduction of object and collection initializers, what's the point of having a builder like that?\n\nThat said, I will use fluent syntax for mutating immutable objects. But that's because they can't use initializers.", "id": "d3pdw7m"}, {"comment": "Builders make sense for some uses.\n\nMany libraries like Moq or Autofac use fluent builders or something similar.", "id": "d3q24kn"}, {"comment": "Mocking libraries and DI frameworks. Or in other words, things I find to be useless pains in the ass.", "id": "d3qmfey"}], [{"comment": "Your instantiating a class to basically build a class. A shared function on the class could do the same thing and be a lot easier to find. The only caveat would be if all the \"parts\" don't inherit from the same base class; since you don't really want to take an array of objects as a constructor; nor do you want to limit what it takes to construct it.  \n  \nHaving to call Begin and Build means you need to tell people how to use your builder class. Most people would glance over the Product class and then wonder how do i create one.  \n  \nFunctions should be used instead of a property getter since a getter shouldn't be modifying the underlying object.  \n  \n    var p = Product.ConstructThing(new Engine(EngineType.V8),  \n                                   new Tire(TireType.Radial, 200, 100), \n                                   new Tire(TireType.Radial, 200, 100), \n                                   new SteeringWheel(Color.Black));", "id": "d3piaxt"}, {"comment": "Error: Test DriveInStraightLine failed with CarIntegrityException. Message: \"Driving in straight line requires four tires to be mounted\".", "id": "d3ti3q0"}], [{"comment": "I thought we stopped making these kinds of huge fucking messes about ten years ago.  ", "id": "d3rdjab"}]]], "4b56qt": ["Don't Learn C the Wrong Way", "2016-03-20 02:53:58", 19, "http://hentenaar.com/dont-learn-c-the-wrong-way", [[56, "I wrote a book on C and went through the technical review process. The vast majority of reviewers were awesome and really helpful, but I can tell you there were plenty of guys like this who will nit-pick every small technical detail without any attempt to hold the bigger picture in their head. All they really care about is making themselves look smart - they feel intimidated that someone else felt they had the expertise and experience to write a book on a subject _they_ felt they knew more about. When I was writing my book this couldn't have been shown more clearly than the fact almost all the reviewers of this type submitted a \"correction\" to a block of code that was in early chapters and not meant to be read by the reader - just meant to be copy and pasted to get them started on more interesting things. All they wanted to show was that they understood this \"secret\" bit of code. Turns out the code I'd written was correct because unlike the reviewers, who only took a cursory glance and declared \"wrong!\", I'd actually taken the time to check it thoroughly.\n\nOne reviewer complained that my book tried to explain the stack and the heap - citing the standard and saying these were implementation defined. I wanted to ask this reviewer how he thought it was meant to taught to beginners? To start taking about the C abstract machine? Language Standardization? Well of course this reviewer would have no idea - because it was clear from their comment that they weren't actually at all interested in my book or teaching beginners C - they just wanted to be the person delivering the \"well actually\" comment.\n\nHaving the technical details correct is important for sure - but once they are correct, they become the least important aspect of producing a good book. In C you can't add two numbers without getting language lawyers on your ass screaming about undefined integer overflow. In this case how the hell are you meant to explain what is going on to a beginner without completely alienating them? The most important part of writing a good book is giving something back to the reader for their investment. You're meant to be doing the hard work for them - if it is too dry and difficult to read they may as well just read the C standard and get started from there.\n\nAdditionally, you simply can't learn C in this pedantic way. You need to learn it like everyone does - by making lots of mistakes - gathering information from a whole bunch of sources, correct or incorrect - and slowly, incrementally creating your own mental model of how it works.\n\nIt's like learning physics - first they tell you there are three states of matter - then later on you learn \"well actually\" there are five. First you learn particles are like billiard balls - then layer you learn \"well actually\" they are like waves. Some things are just complex and so in teaching them you can't avoid these \"well actually\" moments - this isn't a technical failing.\n\nHentenaar is like a university physics professor coming in and correcting the technical details of a high school physics class - except if it was a physicist it wouldn't actually happen like that in real life because it seems only programmers have the delusions and lack of self awareness for this kind of dick-swinging contest."], [28, "jesus....i get the guy doesn't like the work....but nitpicking every fucking thing?\n\nI'd like to see what he'd do to TAOCP...knuth would probably have to sign over his estate."], [17, "I don't know why, but it seems that by Zed's getting Tim Hentenaar as a \"technical reviewer\" for his book, he just wants someone to fix his mistakes, so he can hide the fact he doesn't know a lot about programming in C."], [18, "Oh, it's just Zed again.  Move along, nothing to see here.\n\nEDIT: WTF, it's Zed vs. [some](http://i.imgur.com/kEqVX2f.png) [guy](https://twitter.com/asswhup) who uses the Confederate flag as his Twitter pic.  Weird."], [15, "~~It's unfortunate that the author uses the term \"K&R C\" to refer to the second edition of Kernighan & Ritchie's book \"The C Programming Language\".~~ -- Update: This has been corrected.\n\nThe phrase \"K&R C\" almost universally refers to the version of the language descried in the 1978 first edition of the book. (Note that it refers to the language, not to the book.) The two editions of the book are commonly referred to as \"K&R 1\" and \"K&R 2\". The language described in the second edition is commonly referred to as \"ANSI C\", but is more accurately called \"ANSI C89\" or \"ISO C90\"."], [14, "    kod@nb:~$ cat > hello.c\n    int main () {\n    printf(\"hello\\n\");\n    return 0;\n    }\n    kod@nb:~$ make hello\n    cc    -c -o hello.o hello.c\n    hello.c: In function \u2018main\u2019:\n    hello.c:2:1: warning: implicit declaration of function \u2018printf\u2019 [-Wimplicit-function-declaration]\n     printf(\"hello\\n\");\n     ^\n    hello.c:2:1: warning: incompatible implicit declaration of built-in function \u2018printf\u2019\n    hello.c:2:1: note: include \u2018<stdio.h>\u2019 or provide a declaration of \u2018printf\u2019\n    cc   hello.o   -o hello\n    kod@nb:~$ ./hello\n    hello\n\nseems like i imagined a makefile up just fine and didnt need a header after all. author is talking out of his ass."], [11, "Wow, that rebuttal is not what I would call \"Taking the high road\" .. It start personal, and then goes down from that.\n\nWith so many books out there, why read something clearly written by an ass ?"], [12, "As the author of the Better String Library, I feel the need to say something about the critique of this part of Zed A. Shaw's book.\n\n> The main difference, is that the use of C strings is abstracted away, hidden by a struct that also contains a length member.\n\nThe length of the string in a bstring is not considered hidden in any way.  You literally access the ->slen entry of the struct if you want to know the length.  The library includes safe macros such as blengthe() if you want to access this attribute safely, but this is optional.\n\n> I would guess that the author would prefer Pascal strings, which look like: \"<6>Hello!\" as they embed the length within of the string.\n\nI have no idea what the author means here.  The bstring library maintains the length along with the string contents.  The reason for doing this is to improve safety *and* speed.  I did this as a challenge to show why any software that was vulnerable to buffer overflow attacks could mitigate the problem easily without paying a performance penalty in their code.  No code I have written using the better string library (which is a lot) has ever exposed a performance bottleneck within some function in the library.  Pascal is an entire language that truly does abstract the representation of strings, and operates under other assumptions as well -- I've never seen Pascal strings represented with its length embedded within the quotes of the string like that.  So I truly have no idea what the point of comparing it to some misrepresentation of Pascal is even meant to show.\n\n> You can see that this particular function, bassigncstr has similar functionality to the copy function, and that the loop that actually does the copying is functionally equivalent to the loop in the function which the author so loudly decries. This function also makes use of the dreaded strlen, wow...\n\nbassigncstr() is a *bridge function*.  Its purpose is to get you out of the char \\* universe and into the bstring universe.  There is no way to touch raw char\\* strings completely safely.  The real problem is that you are starting in that universe.  This function is a way to get you out of that universe.  If bassigncstr() ends up crashing, it is because of some corruption your code brought to it, not because of corruption that is being fostered in the better string library.\n\nIf programmers are writing code from scratch (as opposed to adapting something which uses char\\* strings) it is much safer to use the bassignStatic() function if your string content is a string literal.  This function is perfectly safe and does not call the strlen() function.  If you are reading from a file or have some other way of importing string data, then you never need a function like bassigncstr() and can just use the basic bassign() function, which just deals with bstrings and is, therefore, inherently safer.\n\n> Even these strings are just as vulnerable to data corruption as plain 'ol C strings. What happens if the length gets corrupted? \n\nThis is just tautological nonsense.  If your memory gets corrupted in the C language, then you always are in an undefined state.  The Better String library asserts that *IT* will not corrupt your strings.  So the more you rely on the library to do your low-level string work, the less likely you are to have memory corruption in your code.\n\nThis is *NOT* true of char\\* strings at all.  Functions like fgets() and snprintf() will literally leave off the trailing '\\0' in some cases.  C89 included the gets() library function which can never be used safely.  And if you try to execute something like strcat (p, p) you'll just end up  in an infinite loop.\n\nThe Better String Library does not have cases like this, or anything like it, in the library anywhere.  If you start with good data and feed it to the Better String Library in *any way that you like*, the result will never be undefined or corrupted.  If the inputs to any better string library function are independently valid in of themselves, then the results will never be corrupted.\n\nThis is in stark contrast to the C library where you can create corruption just using the library functions themselves.\n\n> Well, if we were reading the data over a blocking socket, we might just block until the socket is closed, waiting for bytes that don't exist to come over the wire (because we didn't ensure the length was valid.)\n\nThis is just such an ignorant statement.  One of the main motivations for writing the better string library was to write cleaner, safer, and faster low-level networking code.  Anyone who tries this will see immediately how much nicer it is to write such code using the better string library.\n\n(BTW, I have never had so much as a conversation with Zed A. Shaw, he just used the Better String Library as an example of how to use safe strings in C.  He and I have posted to the same USENET groups in the past, otherwise we have no overlap.)"], [8, "There are [books](https://www.safaribooksonline.com/library/view/macintosh-terminal-pocket/9781449328962/ch03s02s02.html) on \"installing Xcode\", and it's a different subject than learning C.\n\nCoincidentally, that's where I got tired of the nitpicking."], [3, "Tim is right on some points, but is really ripping Zed to shreds whilst not considering the target audience, which is like the first fucking thing you learn when writing critically. The book is targeted for people who program in either python, ruby or what have you. The book is showing *naive* readers that operations in the real world, i.e using a compiled language like C, is not as cut and dry as other places. I know a ton of students that have no idea about any of the concepts here, and copy paste code out of their ass. Calling it the \"Wrong Way\" is a little heavy, Zed is an asshole, but the theme of these books is \"Type everything out and actually figure some things out on your own\". I never assume everything is the A++ go to idiomatic style from him. "], [-2, "C is not consistent across architectures, platforms, and compilers due to undefined behavior and implementation specific details.\n\nThis costs the ease of writing large portable programs in C, because if you do not know where you are stepping then you could fall into a spiked pit.\n"], [-36, "God, C is fucking horrible. "]], [[{"comment": "I wrote a book on C and went through the technical review process. The vast majority of reviewers were awesome and really helpful, but I can tell you there were plenty of guys like this who will nit-pick every small technical detail without any attempt to hold the bigger picture in their head. All they really care about is making themselves look smart - they feel intimidated that someone else felt they had the expertise and experience to write a book on a subject _they_ felt they knew more about. When I was writing my book this couldn't have been shown more clearly than the fact almost all the reviewers of this type submitted a \"correction\" to a block of code that was in early chapters and not meant to be read by the reader - just meant to be copy and pasted to get them started on more interesting things. All they wanted to show was that they understood this \"secret\" bit of code. Turns out the code I'd written was correct because unlike the reviewers, who only took a cursory glance and declared \"wrong!\", I'd actually taken the time to check it thoroughly.\n\nOne reviewer complained that my book tried to explain the stack and the heap - citing the standard and saying these were implementation defined. I wanted to ask this reviewer how he thought it was meant to taught to beginners? To start taking about the C abstract machine? Language Standardization? Well of course this reviewer would have no idea - because it was clear from their comment that they weren't actually at all interested in my book or teaching beginners C - they just wanted to be the person delivering the \"well actually\" comment.\n\nHaving the technical details correct is important for sure - but once they are correct, they become the least important aspect of producing a good book. In C you can't add two numbers without getting language lawyers on your ass screaming about undefined integer overflow. In this case how the hell are you meant to explain what is going on to a beginner without completely alienating them? The most important part of writing a good book is giving something back to the reader for their investment. You're meant to be doing the hard work for them - if it is too dry and difficult to read they may as well just read the C standard and get started from there.\n\nAdditionally, you simply can't learn C in this pedantic way. You need to learn it like everyone does - by making lots of mistakes - gathering information from a whole bunch of sources, correct or incorrect - and slowly, incrementally creating your own mental model of how it works.\n\nIt's like learning physics - first they tell you there are three states of matter - then later on you learn \"well actually\" there are five. First you learn particles are like billiard balls - then layer you learn \"well actually\" they are like waves. Some things are just complex and so in teaching them you can't avoid these \"well actually\" moments - this isn't a technical failing.\n\nHentenaar is like a university physics professor coming in and correcting the technical details of a high school physics class - except if it was a physicist it wouldn't actually happen like that in real life because it seems only programmers have the delusions and lack of self awareness for this kind of dick-swinging contest.", "id": "d16lu1k"}, {"comment": "In a generalizing way you could say that c programmers work with tiny details alot. Perhaps it influences their way to analyze your book.", "id": "d16mc5i"}, {"comment": ">  they just wanted to be the person delivering the \"well actually\" comment.\n\nI really, really hate those guys. Usually their comments add exactly zero to anyone's understanding. And they don't come off as looking like a sage either, just like an insecure child. So basically everyone comes out for the worse from their \"well actually\".", "id": "d16q9ve"}, {"comment": "It would actually make an interesting book that first starts by teaching C the normal way and after explaining most important parts  you start looking back at those parts and seeing what stuff is undefined behaviour, the abstract machine and all other dick-swinging madness you can come up with.", "id": "d16u8ce"}, {"comment": "Yeah, and the author of this is not even consistent with his criticism.\n\nHe says:\n\n>The sizes for the integer types are implementation-defined. This is why we have limits.h. Hell, I can have a machine with 1024-bit long, 512-bit int, and 256-bit short; and it would be perfectly standards compliant so long as I define the sizes appropriately in limits.h.\n\nThen later:\n\n>Also wrong. Even if such a function was stuck in an \"infinite loop\" condition, it would eventually reach the end of the memory block and cause a segmentation fault, or depending on architecture may cause the CPU to lock-up, a watchdog timer to kill the process or reboot the system, a CPU/MMU exception to be triggered, or some signal to be asserted (e.g. ARM's data-abort exception, the ABORT signal on the 65816, a page fault exception, memory protection exception, invalid memory access exception, etc.).\n\nSo which is it gonna be man? Is this book going by the abstract C machine standard or the implementation specific details?", "id": "d178scc"}, {"comment": "Since gcc and clang appear to be doubling down on their fuck-the-programmer style of UB handling, I wonder how long it will be before beginners *have* to get handy with undefined behaviour, right from day 1, in order to get even the simplest of programs to do anything.\n", "id": "d16xci0"}, {"comment": "Just curious, do you have examples of this?", "id": "d16ygvx"}, {"comment": "Well, it is speculation about the future... the [Friendly C proposal](http://blog.regehr.org/archives/1180) has some links that might show examples of the sort of thing that compilers do already. And I'm imagining this will get worse over time, not better - since the compiler will always be *much* better at proving code technically undefined than beginners are at figuring out why, and over time people will invent ever more ways for it to prove it. This is already unhelpful for experts and I believe it is of even less benefit to beginners.\n\nIf you don't agree with me, you can disagree with these other fine people as well ;) - [\"Everyone is fired\"](http://robertoconcerto.blogspot.co.uk/2010/10/strict-aliasing.html); [\"these people simply don't understand what most C programmers want\"](https://groups.google.com/forum/#!msg/boring-crypto/48qa1kWignU/o8GGp2K1DAAJ); [\"please don't do this, you're not producing value\"](http://blog.metaobject.com/2014/04/cc-osmartass.html).\n\n", "id": "d16znqp"}, {"comment": "Not necessarily disagreeing, it's just not something I run into often.", "id": "d171n6v"}, {"comment": "I haven't had the chance to use it in practice yet, but maybe flags such as [-fsanitize=undefined](http://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html) can help with that?", "id": "d179l0l"}, {"comment": "I like correctness, and I'm not a big fan of C, but I quite liked  reading through your Make A Lisp and looking at your Cello library; both of these inspired me quite a lot in my own work.\n\nThe reviewers you faced (no doubt regulars of Freenode's C channel, would I be right in saying?) are the worst kind of decadent philistines. Their degenerate attitude, refusing to consider the practical implications of anything they speak of, is the bane of compsci.", "id": "d175gbs"}, {"comment": "Many thanks :) I completely agree - Freenode's C channel is extremely toxic, and they definitely aren't a fan of any of my projects.", "id": "d1775lc"}], [{"comment": "jesus....i get the guy doesn't like the work....but nitpicking every fucking thing?\n\nI'd like to see what he'd do to TAOCP...knuth would probably have to sign over his estate.", "id": "d166iuq"}, {"comment": ">> Those who've felt the need to pick on this point are either being really pedantic (for which I congratulate you), or they're missing the point\n\nhaha, the irony, it's killing me!", "id": "d16a7w9"}], [{"comment": "I don't know why, but it seems that by Zed's getting Tim Hentenaar as a \"technical reviewer\" for his book, he just wants someone to fix his mistakes, so he can hide the fact he doesn't know a lot about programming in C.", "id": "d166z12"}, {"comment": "It's confusing, but Hentenaar first links to Shaw's rebuttal written *after* the exchange that he screencaps. IOW, Hentenaar writes the article, Shaw offers to pay him to review the book, Hentenaar declines and Shaw goes into a tirade against him.", "id": "d168v8t"}, {"comment": "Yeah. It's a similar problem with the way how Zed writes ruby code.\n\nLong time ruby hackers would not write ruby in that way.\n\nI can't judge Zed's python code but I am wary of someone who dances on a big drama (\"rails is a ghetto\").", "id": "d16lz27"}], [{"comment": "Oh, it's just Zed again.  Move along, nothing to see here.\n\nEDIT: WTF, it's Zed vs. [some](http://i.imgur.com/kEqVX2f.png) [guy](https://twitter.com/asswhup) who uses the Confederate flag as his Twitter pic.  Weird.", "id": "d169mep"}, {"comment": "Is Learn C The Hard Way actually considered harmful here, or is it just some sort of ongoing personal conflict between these two?", "id": "d16aeln"}, {"comment": "Zed is a well-known self-promoting tool.  The other guy is apparently some weird racist.  It's just fun to watch the slap-fight.", "id": "d16at3l"}, {"comment": "As someone who is currently using Learn C the Hard Way to try and learn C. Should I not be?\n\nEDIT: General consensus is that Learn C the Hard Way is generally not well liked or recommended. It may be good for those that find a more colloquial approach to learning as more inviting but K&R is a stronger resource that has better foundations and is generally better to learn.", "id": "d16bosr"}, {"comment": "Well the book is by the guy who when he announced the book gave the reasoning on why K&R is bad, mostly because of the fragile code fragments found throughout the book, despite K&R explaining already that they are fragile, offering information how to fix it for a better example, and offering more robust versions sometimes later in the text or as an exercise. It's like the guy read every fourth page of the book and was like this sucks and put a bunch of words in K&R's mouth. So that being said, I don't really trust his book based on his nonsensical mistruths about other people's books. ", "id": "d16dbmg"}, {"comment": "Zed did redact his critique on K&R, [albeit in a really petty and non-constructive way](http://c.learncodethehardway.org/book/krcritique.html). Overall, however, he is right in stating that modern C (programming in any language, for that matter), requires a much greater degree of security scrutiny than in the pre-world-wide-web era K&R was written. Both books are good in their own right: K&R is an essential resource on learning C and the structured-imperative programming style in general, while Zed's book is a useful, if sometimes flawed, introduction to the modern C ecosystem, tooling (one of the best Valgrind tutorials out there), and programming concerns.", "id": "d16r58z"}, {"comment": "K&R legitimately teaches you a lot of bad habits though.", "id": "d16xo7m"}, {"comment": "I don't know much about *Learn C the Hard Way*, but the traditional book for learning C is *The C Programming Language*, which is so well known people usually refer to it as \"K&R\". Because I don't really know anything about it, I don't want to say don't read *Learn C the Hard Way*, but you should definitely also be reading K&R.", "id": "d16czi3"}, {"comment": "Yes thank you. After reading the article I went and found a pdf and i'm also going to buy a copy of The C Programming Language.", "id": "d16e43g"}, {"comment": "I don't like K&R, it's too dry. Just because some people like it doesn't make it the best book on the C language.", "id": "d16k95a"}, {"comment": "C is dry, so that's OK. :-)", "id": "d16z2q9"}, {"comment": "There are better books to learn programming and better books to learn C.", "id": "d17jfr1"}, {"comment": ">\nint main()  \n{  \n &nbsp; int age = 10;\n//...\nThen you're using a variable named age and setting it to 10. \n\nYeah, don't bother with *Learn C the Hard Way* if it has doozies like that in it.", "id": "d16e1ub"}, {"comment": "You need to be careful because there are some errors in K&R, but the bigger issue is that most of the code shown in the K&R book can lead to buffer overflows.\n\nIts probably one of the best books I've ever read for learning a language but it is getting old.", "id": "d16f077"}, {"comment": "Let's just say if author is throwing `malloc` around because \"how modern systems do it\" in places it doesn't make any sense to use it, it doesn't speak well about his knowledge about language. His pinnacle of achievement in C was pretty bad app server for ruby (altho mongrel2 looks pretty interesting). \n\nSo if you want to learn C instead of \"Angry Ruby guy idea how C works\", get K&R", "id": "d16gfs6"}, {"comment": "Go ahead it's fine. You go through it you'll know enough C to be a bit dangerous. And then if you keep at it you'll gain some experience and you'll be less dangerous. If you switch to K&R you'll just give up half way though and that's arguably worse.\n", "id": "d16jnrf"}, {"comment": "Shaw put out some initial chapters a few years ago for comment to various C discussion fora, including IRC, but instead of listening to the concerns of experts he solicited advice from, dismissed their concerns or labeled their corrections as unrealistic or impractical or out-of-the-mainstream and thus not worth engaging and certainly not worth qualifying his gorgeous prose. He's trying to bend the language to his pedagogical approach, perhaps not as bad as Schildt, but he likewise cops to an expertise he doesn't have.", "id": "d16jolk"}, {"comment": "Well, the moral of this story is: everyone should learn C, but nobody should use it!\n\nPart of learning C is to be able to determine when it's appropriate to use it. Today, there are actually very few places where it's appropriate. In nearly every situation, there is a better alternative. Still, learning C is valuable, since you're learning how things work \"under the hood\", and that will make you a better programmer, regardless of language.", "id": "d16jop2"}, {"comment": "You can write bad code with any language.  And frankly,  learning someones new abstract simplification of a framework every 2 years is exhausting. \n\nNo I don't want some 'desk drawer' object, that is going to revolutionize the way programmers think about input/output,  to write a file to disk.  Just give me a damn filedescriptor. ", "id": "d16xh3l"}, {"comment": "What does file descriptors have to do with C? C doesn't have file descriptors; POSIX does.\n\nThere are still some situations where C is the only reasonable alternative, for example when developing for a bare metal environment on some obscure CPU architecture, or when you want to squeeze the last drop of performance out of your program (although, in all honesty, Fortran or assembly are better tools for this). In almost all other situations you're better off choosing a different language.\n\nI have more than 20 years of experience with C, and it's really one of the worst languages out there. There is just way too much *undefined* or *implementation defined* behavior in C for it to be a reliable language, not to mention a complete lack of safety, in all aspects. If you enjoy hunting bugs caused by the weird semantics of volatile variables or strict aliasing, or any other generally misunderstood part if the language, then go ahead and use C. I'll just stick with some more modern language, thank you!", "id": "d16zdks"}, {"comment": "My point is,  C is more freeing than all the frameworks I know.  If you want to do something slightly different,  a lot of abstracted languages and frameworks fall apart.  There are safer ways of writing C,  but yes it is very verbose. ", "id": "d19hw2h"}, {"comment": "I can certainly agree that many \"frameworks\" are bloated and feel clunky, but my view on that is that it's due to poor design of the framework, rather than an issue with the language. In my experience, this is more prevalent in the realm of dynamic, web focused, programming languages, although some of them are really good. There is no excuse for poor design, regardless of language! As a matter of fact, the POSIX file descriptors are also a kind of framework; it's an abstraction for all kinds of I/O operations.\n\nI'm not saying you should abandon C in favor of something like PHP (which arguably is one of the worst languages ever ;)), unless you're into painful web programming. 5 years back I would have agreed that there were no real good substitutes for C for \"systems programming\", but today we have languages like Rust, Swift, Go (although I personally dislike Go, it's liked by many others), among others, which are really competitive in that space.", "id": "d19ixbw"}, {"comment": "POSIX is a superset of the C standard library; the C standard library contains file I/O.", "id": "d17kcqx"}, {"comment": "I'm well aware of that. Even with the POSIX library (which tries to fix some of the most obvious flaws in the standard library), my point is still valid, though: C is a language full of pitfalls which even the most talented and experienced people fall into over and over again. If you're in an environment where you have access to the POSIX library, you shouldn't be using C; there are plenty of alternatives; both safer and more portable.", "id": "d17mch8"}, {"comment": "Essentially, you can use it if you want but fact-check _everything_ Zed says because he spouts a lot of bullshit.", "id": "d16n7du"}, {"comment": "So, as someone who professionally writes C and tutors students as a hobby on the side, K&R C is an old book from a different time that teaches you a lot of bad habits.  Learn C the Hard Way is much better for learning C in 2016.", "id": "d16xlas"}, {"comment": "You are the first person to hold that opinion in all the responses I've received. ", "id": "d17g1a6"}, {"comment": "I wouldn't take those responses too seriously. K&R is like the holy bible of the C community and Zed Shaw said mean things about it while being, well, Zed Shaw (read: a dick). So naturally they're jumping on the opportunity to shit on him and his book. When I first read Hentenaar's blog post I just kinda rolled my eyes since it was pretty obvious he saw that K&R critique, got irked by it, and then skimmed the **alpha** (or beta version - I honestly forget which but LCTHW was a WIP at the time) version of Zed's book while cranking the nitpicky pedantry up to 11 trying to find things to criticize.\n\nLCTHW is by no means perfect, but it's a completely acceptable resource to learn C programming. Try picking up the finished version though; the one online seems to be the beta version still. [The Art of Exploitation](http://www.amazon.com/Hacking-The-Art-Exploitation-Edition/dp/1593271441) is another good read I'd recommend; it'll teach you how to exploit insecure C code.\n\nOf course, you could always just read both K&R and LCTHW and decide for yourself which is better.", "id": "d18mxpz"}, {"comment": "\n**Hacking: The Art of Exploitation, 2nd Edition** \n\n||||\n--:|:--|:--\nCurrent|$26.79|Amazon (New)\nHigh|$34.54|Amazon (New)\nLow|$21.50|Amazon (New)\n|Average|$26.96|30 Day\n\n[Price History Chart and Sales Rank](http://i.imgur.com/nZSNYLw.png) | [PriceZombie is shutting down...](https://www.reddit.com/r/PriceZombie/comments/4ar70l/pricezombie_shutting_down_end_of_the_month)\n", "id": "d18mxzy"}, {"comment": "> EDIT: WTF, it's Zed vs. some guy who uses the Confederate flag as his Twitter pic. Weird.\n\nHis LinkedIn photograph is worth seeing, too :-)", "id": "d17461z"}, {"comment": "\"Linux Engineer, Reverse Engineer, and Visionary.\"  Indeed.", "id": "d17f6v3"}], [{"comment": "~~It's unfortunate that the author uses the term \"K&R C\" to refer to the second edition of Kernighan & Ritchie's book \"The C Programming Language\".~~ -- Update: This has been corrected.\n\nThe phrase \"K&R C\" almost universally refers to the version of the language descried in the 1978 first edition of the book. (Note that it refers to the language, not to the book.) The two editions of the book are commonly referred to as \"K&R 1\" and \"K&R 2\". The language described in the second edition is commonly referred to as \"ANSI C\", but is more accurately called \"ANSI C89\" or \"ISO C90\".", "id": "d16cszw"}], [{"comment": "    kod@nb:~$ cat > hello.c\n    int main () {\n    printf(\"hello\\n\");\n    return 0;\n    }\n    kod@nb:~$ make hello\n    cc    -c -o hello.o hello.c\n    hello.c: In function \u2018main\u2019:\n    hello.c:2:1: warning: implicit declaration of function \u2018printf\u2019 [-Wimplicit-function-declaration]\n     printf(\"hello\\n\");\n     ^\n    hello.c:2:1: warning: incompatible implicit declaration of built-in function \u2018printf\u2019\n    hello.c:2:1: note: include \u2018<stdio.h>\u2019 or provide a declaration of \u2018printf\u2019\n    cc   hello.o   -o hello\n    kod@nb:~$ ./hello\n    hello\n\nseems like i imagined a makefile up just fine and didnt need a header after all. author is talking out of his ass.", "id": "d16i6nm"}, {"comment": "I never knew you could do that. Wow.", "id": "d16xr9v"}, {"comment": "It's because it finds printf in the link phase in the standard library. You shouldn't rely on this kind of thing in general though because you're basically forfeiting type checking.\n\nIIRC it's also not allowed in C99 and up.", "id": "d170a3u"}, {"comment": "Not the printf thing, I knew about that, but the `make hello` command, that's new to me.", "id": "d17aown"}], [{"comment": "Wow, that rebuttal is not what I would call \"Taking the high road\" .. It start personal, and then goes down from that.\n\nWith so many books out there, why read something clearly written by an ass ?", "id": "d16ds3v"}], [{"comment": "As the author of the Better String Library, I feel the need to say something about the critique of this part of Zed A. Shaw's book.\n\n> The main difference, is that the use of C strings is abstracted away, hidden by a struct that also contains a length member.\n\nThe length of the string in a bstring is not considered hidden in any way.  You literally access the ->slen entry of the struct if you want to know the length.  The library includes safe macros such as blengthe() if you want to access this attribute safely, but this is optional.\n\n> I would guess that the author would prefer Pascal strings, which look like: \"<6>Hello!\" as they embed the length within of the string.\n\nI have no idea what the author means here.  The bstring library maintains the length along with the string contents.  The reason for doing this is to improve safety *and* speed.  I did this as a challenge to show why any software that was vulnerable to buffer overflow attacks could mitigate the problem easily without paying a performance penalty in their code.  No code I have written using the better string library (which is a lot) has ever exposed a performance bottleneck within some function in the library.  Pascal is an entire language that truly does abstract the representation of strings, and operates under other assumptions as well -- I've never seen Pascal strings represented with its length embedded within the quotes of the string like that.  So I truly have no idea what the point of comparing it to some misrepresentation of Pascal is even meant to show.\n\n> You can see that this particular function, bassigncstr has similar functionality to the copy function, and that the loop that actually does the copying is functionally equivalent to the loop in the function which the author so loudly decries. This function also makes use of the dreaded strlen, wow...\n\nbassigncstr() is a *bridge function*.  Its purpose is to get you out of the char \\* universe and into the bstring universe.  There is no way to touch raw char\\* strings completely safely.  The real problem is that you are starting in that universe.  This function is a way to get you out of that universe.  If bassigncstr() ends up crashing, it is because of some corruption your code brought to it, not because of corruption that is being fostered in the better string library.\n\nIf programmers are writing code from scratch (as opposed to adapting something which uses char\\* strings) it is much safer to use the bassignStatic() function if your string content is a string literal.  This function is perfectly safe and does not call the strlen() function.  If you are reading from a file or have some other way of importing string data, then you never need a function like bassigncstr() and can just use the basic bassign() function, which just deals with bstrings and is, therefore, inherently safer.\n\n> Even these strings are just as vulnerable to data corruption as plain 'ol C strings. What happens if the length gets corrupted? \n\nThis is just tautological nonsense.  If your memory gets corrupted in the C language, then you always are in an undefined state.  The Better String library asserts that *IT* will not corrupt your strings.  So the more you rely on the library to do your low-level string work, the less likely you are to have memory corruption in your code.\n\nThis is *NOT* true of char\\* strings at all.  Functions like fgets() and snprintf() will literally leave off the trailing '\\0' in some cases.  C89 included the gets() library function which can never be used safely.  And if you try to execute something like strcat (p, p) you'll just end up  in an infinite loop.\n\nThe Better String Library does not have cases like this, or anything like it, in the library anywhere.  If you start with good data and feed it to the Better String Library in *any way that you like*, the result will never be undefined or corrupted.  If the inputs to any better string library function are independently valid in of themselves, then the results will never be corrupted.\n\nThis is in stark contrast to the C library where you can create corruption just using the library functions themselves.\n\n> Well, if we were reading the data over a blocking socket, we might just block until the socket is closed, waiting for bytes that don't exist to come over the wire (because we didn't ensure the length was valid.)\n\nThis is just such an ignorant statement.  One of the main motivations for writing the better string library was to write cleaner, safer, and faster low-level networking code.  Anyone who tries this will see immediately how much nicer it is to write such code using the better string library.\n\n(BTW, I have never had so much as a conversation with Zed A. Shaw, he just used the Better String Library as an example of how to use safe strings in C.  He and I have posted to the same USENET groups in the past, otherwise we have no overlap.)", "id": "d16y5rp"}], [{"comment": "There are [books](https://www.safaribooksonline.com/library/view/macintosh-terminal-pocket/9781449328962/ch03s02s02.html) on \"installing Xcode\", and it's a different subject than learning C.\n\nCoincidentally, that's where I got tired of the nitpicking.", "id": "d16ip0c"}, {"comment": "That's my point learning C is about 10% of the battle.  Just like learning Java is.\n", "id": "d16jr0p"}, {"comment": "For the down voters, C though it has various gateways to the netherworld is a simple language like Java. If anything simpler actually. The devils is in all the other things you need to learn. You need to know the tools. How to fix things when stuff goes wrong. All the libraries and the frameworks.\n", "id": "d174wp7"}], [{"comment": "Tim is right on some points, but is really ripping Zed to shreds whilst not considering the target audience, which is like the first fucking thing you learn when writing critically. The book is targeted for people who program in either python, ruby or what have you. The book is showing *naive* readers that operations in the real world, i.e using a compiled language like C, is not as cut and dry as other places. I know a ton of students that have no idea about any of the concepts here, and copy paste code out of their ass. Calling it the \"Wrong Way\" is a little heavy, Zed is an asshole, but the theme of these books is \"Type everything out and actually figure some things out on your own\". I never assume everything is the A++ go to idiomatic style from him. ", "id": "d16x2oq"}], [{"comment": "C is not consistent across architectures, platforms, and compilers due to undefined behavior and implementation specific details.\n\nThis costs the ease of writing large portable programs in C, because if you do not know where you are stepping then you could fall into a spiked pit.\n", "id": "d16hehh"}, {"comment": "It is if you stick to the standard.", "id": "d16mema"}, {"comment": "If you stick with standard C and do not use the preprocessor or any non-standard includes and you want it to compile it on any standards compliant compiler, then you lose the following:\n\n * Network sockets\n * Advanced filesystem access:\n    * Directories\n    * Manipulation of symbolic links\n    * Access to alternative data streams and resource forks.\n    * Permissions and ACLs.\n * GUI interfaces\n * Threads (C11 if supported)\n * Atomic Operations (C11 if supported)\n * Terminal support\n", "id": "d16q23f"}, {"comment": "That is not the C language. Those are libs. Very different thing.\n", "id": "d16qsih"}, {"comment": "Yes, exactly- portable C is mostly useless, which is why it's annoying when the C pedants start trotting out their bullshit like 'C doesn't have a stack' or whatever that is technically correct and completely worthless.", "id": "d17bw0v"}, {"comment": "Useless for what? C is a tool. Not a universal problem solver.\nClaiming that portable C \"is mostly useless\" is very ignorant.\n\nC is a portable assembler. It can do wonders if you want the same code to be able to run in almost every CPU/MCU/DSP out there. If you don't use C you are in for an assembly fest that will go on every time you want to support a new CPU.\n", "id": "d18cz77"}, {"comment": "Yes, those things are called \"programming a computer\".  It is kind of meaningless to make claims of portability if you are sacrificing the main things you are trying to do when you program a computer.", "id": "d16zoy6"}, {"comment": "You don't seem to understand what portability means in the terms that C defines it. It has nothing to do with network APIs or GUIs. C does not even try to solve those problems by definition. \"Programming a computer\" is not C's job.\n\nIf you want that kind of support you will need frameworks and higher level APIs. Maybe you don't even need C and can get away with java/python/whatever. But C has its place, you just have to know when to use it. Basically it boils down to using the right tool for the job.\n", "id": "d18ders"}, {"comment": "> You don't seem to understand what portability means in the terms that C defines it.\n\nPlaying the definitionism game is the last refuge of scoundrels.  Portability is defined as writing code once, and applying it to varying platforms without modifying the code.\n\nIf you redefine the word to mean a very narrow set of functionality that ignores a platform's capabilities, or worse yet, just that code compiles and runs, but may have varying actual behavior, then you are just being absurd.  It becomes a way of avoiding the criticism of not being portable, by simply ignoring the meaning of the criticism, as if it doesn't exist.\n\n> It has nothing to do with network APIs or GUIs.\n\nRight, the two most important features of computers for the last 30 years.  Are you not aware that TCP/IP is an open portable, universal protocol that has identical semantics no matter what machine you are running it on?  Networking in of itself is an exercise in portability.  Microsoft was, in fact, forced to adopt socket programming from the UNIX world, in order to conform to the needs of networking.\n\nGUIs might all have behavioral differences, but at the end of the day, sub-windows, mouse input, and keyboard interfaces are what is being abstracted.  And as Qt has demonstrated, it certainly is possible to create portable GUI layers.\n\n> C does not even try to solve those problems by definition.\n\nRight.  Because by definition, C is not a portable programming language.  Both Python and Java support multithreading and networking in substantially identical ways over different platforms.  The C perspective of what is or is not portable is just obsolete.\n\n> But C has its place, you just have to know when to use it. Basically it boils down to using the right tool for the job.\n\nThis is just an excuse.  There is no reason why you couldn't make core libraries abstract devices in a portable way over an arbitrary number of platforms.  Even in C as people have done.  The standards committee just fails to see the value or use in this.", "id": "d18e52n"}, {"comment": "The standard isn't free bro.", "id": "d183k47"}, {"comment": "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf", "id": "d18cfoq"}, {"comment": "That's a draft.", "id": "d18vffv"}, {"comment": "And never use an integer greater than 32767 (or less than -32768), and never use the value of a floating point number in control code, and somehow be agnostic as to whether or not char is signed or unsigned.", "id": "d16zmw6"}], [{"comment": "God, C is fucking horrible. ", "id": "d169lzy"}, {"comment": "When you think about the waste that all other languages create, (C creates waste too, just not as much) You realuse that all other languages are horrible, not C.", "id": "d16pu4v"}, {"comment": "In that case the CPU must be horrible.", "id": "d16e4kg"}, {"comment": "A modern multicore CPU is a frighting piece of work.\n", "id": "d16jqcg"}, {"comment": "Right and that's why C is hard to use properly and why DevastatingAttack is a troll or ignorant.", "id": "d16jwoa"}, {"comment": "Two examples I remember. \n\nOne when Apple started shipping dual core ARM machines suddenly there was a small flurry of bug reports on libraries that implemented lockless data structures, because of write order issues on ARM. Didn't matter on single core ARM or multicore Intel machines.\n\nSecond is a guy I talked to that works at google who was drinking after finding a low level race condition that was causing production failures for them, a couple per hour. Again due to cache read/write issues with multi-core processors. If it was me and my crummy software I'd never see that kind of thing ever.\n\nYou might say these are C were problems but they aren't. They exist because the architectures get scary and hard to reason about at the edges.\n", "id": "d16klhz"}, {"comment": "I am not saying they are C problems. WTF. That was DevastatingAttack all along and I am saying the complete opposite.", "id": "d16pdy7"}, {"comment": "Sorry wasn't implying you were.", "id": "d16zjdh"}, {"comment": "Ah, I need to remember this sub is not like most of reddit.", "id": "d172amd"}, {"comment": "Read \"C++ Concurrency in Action: Practical Multithreading\" by Anthony Williams, to see how truly fucked everything is.\n\nWith weak memory ordering on architectures like AArch64, not only do you have non-determinism, you essentially lack cache-coherency between cores (with relaxed memory operations)!\n\nMemory synchronization is not a simple topic.  Hardware designers are not making software designers lives easier!", "id": "d16ylyd"}]]], "3zkwoa": ["j \u2013 a small tool to quickly jump between directories", "2016-01-05 19:35:53", 0, "https://github.com/ssriram/j", [[15, "Or you could learn how to use cd.\n\n    mkdir ~/.jump-targets  \n    ln -s ~/src/whatever ~/.jump-targets/proj  \n\n    CDPATH=.:~/.jump-targets #put this in your profile!  \n    cd proj  "], [3, "Related: https://github.com/rupa/z - Jump to a directory by fuzzy match, sorted by how frequently you go to that directory. "], [5, "META: I like this kind of post. Just because it's not the perfect solution, or there are existing alternatives, doesn't detract from the fact that OP took the time to develop a useful tool and share it with the community. It's a shame honest efforts are met with so much negativity here. Constructive suggestions and critiques are great, *if* they come from a good place. \n\nAlso, TIL about CDPATH, so the discussion provoked was really valuable. "], [2, "Neat; it's nice that it's tiny. I use https://github.com/wting/autojump to jump around."], [2, "I get a flutter when I saw the name, then I read the rest of the title and realised that it wasn't about the J programming language."], [1, "Now that looks interesting. I'll try it out this week! Thank you."], [1, "[jump](https://github.com/gsamokovarov/jump) is another fuzzy directory jumper written in Go"], [1, "Look up autojump, it is the same idea but done very well. It's also in most repositories."]], [[{"comment": "Or you could learn how to use cd.\n\n    mkdir ~/.jump-targets  \n    ln -s ~/src/whatever ~/.jump-targets/proj  \n\n    CDPATH=.:~/.jump-targets #put this in your profile!  \n    cd proj  ", "id": "cyn3df9"}, {"comment": "Seems like there's at least a weekly post where someone reinvents CDPATH.", "id": "cynegxy"}, {"comment": "Ya, I didn't know so many of these things are out there. I can assure j will be KISSable.", "id": "cynm9hq"}, {"comment": "Works 90% of the time, but not a great solution, since the symlinks can cause problems with some programs.  Example: Perforce, which expects ~/src/whatever to be at ~/src/whatever, and not ~/.jump-targets/proj.", "id": "cyn9jlx"}, {"comment": "If you set -P, it works in 100% of cases where j works.", "id": "cyna8ya"}, {"comment": "Though not a feature but more out of design, the same key can point to different arbitrary paths in different terminals in j and still need not touch the disk.", "id": "cynmcoz"}, {"comment": "CDPATH works well, but feels way too old. j -a, j -d is rather quick than manually maintaining a folder full of symlinks.", "id": "cynm5sp"}, {"comment": "[deleted]", "id": "cynat3v"}, {"comment": "No, I don't have this crap memorized.  I used this novel contraption called a [reference manual](https://www.gnu.org/software/bash/manual/).", "id": "cynavbm"}, {"comment": "For a less snarky answer (though I'm not him), I didn't memorize what he wrote but I understood it and now I can do it on my own because I realize what's going on. Understanding is not the same as memorization.", "id": "cynv1ty"}], [{"comment": "Related: https://github.com/rupa/z - Jump to a directory by fuzzy match, sorted by how frequently you go to that directory. ", "id": "cymxugw"}, {"comment": "Thats cool.. didn't know there are so many out there. j is not competing here, but a fuzzy search can be done by j -l | agrep ... might be??", "id": "cynmfl0"}], [{"comment": "META: I like this kind of post. Just because it's not the perfect solution, or there are existing alternatives, doesn't detract from the fact that OP took the time to develop a useful tool and share it with the community. It's a shame honest efforts are met with so much negativity here. Constructive suggestions and critiques are great, *if* they come from a good place. \n\nAlso, TIL about CDPATH, so the discussion provoked was really valuable. ", "id": "cynx33s"}], [{"comment": "Neat; it's nice that it's tiny. I use https://github.com/wting/autojump to jump around.", "id": "cyn0psn"}, {"comment": "I can assure it will stay tiny and KISSable.", "id": "cynmgh6"}], [{"comment": "I get a flutter when I saw the name, then I read the rest of the title and realised that it wasn't about the J programming language.", "id": "cyn8iuo"}, {"comment": "Sorry.. I first went with jmp then jp and finally got stuck with j to save few keystrokes.", "id": "cynlyx3"}], [{"comment": "Now that looks interesting. I'll try it out this week! Thank you.", "id": "cymwnbg"}, {"comment": "You're welcome !!", "id": "cymwoq6"}], [{"comment": "[jump](https://github.com/gsamokovarov/jump) is another fuzzy directory jumper written in Go", "id": "cyneg8e"}], [{"comment": "Look up autojump, it is the same idea but done very well. It's also in most repositories.", "id": "cynqpvo"}]]], "47e8rx": ["Microsoft to acquire Xamarin & empower more developers to build apps on any device", "2016-02-24 22:05:54", 6, "http://blogs.microsoft.com/blog/2016/02/24/do-not-delete-224/", [[9, "Not sure if empower is the right word."], [5, "so much spin in that title"]], [[{"comment": "Not sure if empower is the right word.", "id": "d0ca9rm"}, {"comment": "Maybe another E word? Embrace... extend... what's that other one?", "id": "d0cmdx6"}, {"comment": "[deleted]", "id": "d0cpzmn"}, {"comment": "Maybe Google for \"prolapse anus\", which is a likely result from simultaneous rape.  PHP doesn't look that bad.", "id": "d0cqp5g"}], [{"comment": "so much spin in that title", "id": "d0cfbbe"}]]], "56wzaa": ["Crash: how computers are setting us up for disaster | Tim Harford | Technology", "2016-10-11 11:49:35", 1, "https://www.theguardian.com/technology/2016/oct/11/crash-how-computers-are-setting-us-up-disaster", [[15, "I'm not really one of the \"IT'S NOT PROGRAMMING REEEEE\" crowd but this is just pop sci trite, it really doesn't belong here. Try /r/technology."], [9, "The guardian as a source xD"], [3, "\"Children of the magenta\" is often recommended when issues of automation in aviation come up:\nhttps://www.youtube.com/watch?v=pN41LvuSz10"], [0, "[deleted]"], [1, "An interesting read but I'm not surprised by the negative comments here either.  If all you have to say at the end of this is some stuff about 'debugging' I think you missed the point."], [1, "This is the best tl;dr I could make, [original](https://www.theguardian.com/technology/2016/oct/11/crash-how-computers-are-setting-us-up-disaster) reduced by 98%. (I'm a bot)\n*****\n> A tactful translator between human and machine, it observes the pilot tugging on the controls, figures out how the pilot wanted the plane to move and executes that manoeuvre perfectly.\n\n> Something else happened at the same time and for the same reason: the fly-by-wire system downgraded itself to a mode that gave the pilot less help and more latitude to control the plane.\n\n> While he had spent many hours in the cockpit of the A330, most of those hours had been spent monitoring and adjusting the plane&#039;s computers rather than directly flying the aircraft.\n\n\n*****\n[**Extended Summary**](http://np.reddit.com/r/autotldr/comments/56zqkm/a_computer_that_is_a_hundred_times_more_accurate/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ \"Version 1.65, ~5208 tl;drs so far.\") | [Theory](http://np.reddit.com/r/autotldr/comments/31bfht/theory_autotldr_concept/) | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr \"PM's and comments are monitored, constructive feedback is welcome.\") | *Top* *keywords*: **plane**^#1 **pilot**^#2 **more**^#3 **computer**^#4 **control**^#5"], [0, "> there is a risk to building a plane that protects pilots so assiduously from even the tiniest error. It means that when something challenging does occur, the pilots will have very little experience to draw on as they try to meet that challenge.\n\nTHat something that is challenging is likely to be way beyond the pilots ability as all the merely \"challenging before automation\" stuff is catered for.\n\nDon't discount the 15 year safety record of the plane."], [0, "Great article! Doesn't have anything to do with programming and as such doesn't belong in /r/programming though, as is obvious from the knee-jerk negative commenting going on here. I'd love to read some more about preventing diminishing human skills through automation though; anyone know of a good read? "], [-7, "[deleted]"]], [[{"comment": "I'm not really one of the \"IT'S NOT PROGRAMMING REEEEE\" crowd but this is just pop sci trite, it really doesn't belong here. Try /r/technology.", "id": "d8n5ru4"}], [{"comment": "The guardian as a source xD", "id": "d8n5plq"}], [{"comment": "\"Children of the magenta\" is often recommended when issues of automation in aviation come up:\nhttps://www.youtube.com/watch?v=pN41LvuSz10", "id": "d8n8iva"}], [{"comment": "[deleted]", "id": "d8n6wfz"}], [{"comment": "An interesting read but I'm not surprised by the negative comments here either.  If all you have to say at the end of this is some stuff about 'debugging' I think you missed the point.", "id": "d8n7qo8"}], [{"comment": "This is the best tl;dr I could make, [original](https://www.theguardian.com/technology/2016/oct/11/crash-how-computers-are-setting-us-up-disaster) reduced by 98%. (I'm a bot)\n*****\n> A tactful translator between human and machine, it observes the pilot tugging on the controls, figures out how the pilot wanted the plane to move and executes that manoeuvre perfectly.\n\n> Something else happened at the same time and for the same reason: the fly-by-wire system downgraded itself to a mode that gave the pilot less help and more latitude to control the plane.\n\n> While he had spent many hours in the cockpit of the A330, most of those hours had been spent monitoring and adjusting the plane&#039;s computers rather than directly flying the aircraft.\n\n\n*****\n[**Extended Summary**](http://np.reddit.com/r/autotldr/comments/56zqkm/a_computer_that_is_a_hundred_times_more_accurate/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ \"Version 1.65, ~5208 tl;drs so far.\") | [Theory](http://np.reddit.com/r/autotldr/comments/31bfht/theory_autotldr_concept/) | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr \"PM's and comments are monitored, constructive feedback is welcome.\") | *Top* *keywords*: **plane**^#1 **pilot**^#2 **more**^#3 **computer**^#4 **control**^#5", "id": "d8npn02"}], [{"comment": "> there is a risk to building a plane that protects pilots so assiduously from even the tiniest error. It means that when something challenging does occur, the pilots will have very little experience to draw on as they try to meet that challenge.\n\nTHat something that is challenging is likely to be way beyond the pilots ability as all the merely \"challenging before automation\" stuff is catered for.\n\nDon't discount the 15 year safety record of the plane.", "id": "d8ngmuk"}], [{"comment": "Great article! Doesn't have anything to do with programming and as such doesn't belong in /r/programming though, as is obvious from the knee-jerk negative commenting going on here. I'd love to read some more about preventing diminishing human skills through automation though; anyone know of a good read? ", "id": "d8nk5fp"}], [{"comment": "[deleted]", "id": "d8n41cw"}, {"comment": "You didn't read the article, did you? This has absolutely nothing to do with bugs. ", "id": "d8njyc7"}]]], "5esv7m": ["Mathematical Notation Is Awful", "2016-11-25 12:56:16", 25, "http://blackhole12.blogspot.com/2016/07/mathematical-notation-is-awful.html", [[81, "The author's problem is that he doesn't understand how random variables and expected value work. He just wants to plug numbers into formulas to get answers without understanding what any of the math actually means.\n\nTake his example E[ x^2 ], this means finding the expected value from taking a random number from the distribution of x and squaring it. The notation shows this just fine.\n\nSame with E[ XY ], which means finding the expected value from multiplying a random value from the distribution of X with a random value from the distribution of Y. Notation works well here too.\n\nExpected value is not just some formula you plug numbers in, but a concept with a practical meaning, that it is the probability weighted mean of all outcomes, the value that a long running mean of samples approaches.\n\nIf the author actually understood how expected value works, then he would not need to lookup or memorize those formulas. Take finding the formula for E[ x^2 ] for example. Each xi from x has a probability of p(xi) of occurring. When squaring x, you are squaring each xi, but the probabilities of each xi when squared stays the same. Squaring the number that comes from a dice roll for example does not effect the probability of which face is up after the roll.\n\nI will say that there is a disconnect between the authors that write math textbooks and students that read them. The authors seem to easily overlook pitfalls that students often find themselves in. This is because they can struggle to empathize with people who are not as familiar with math as they are.\n"], [44, "That particular case is not awful. The author just failed to appreciate the distinction between a variable and a random variable."], [36, "Statistics is notorious for having god awful notation.  Leave other mathematical fields out of this!\n\nI don't really agree with his other points outside of statistics though.  The multiple current notations for the derivative are trying to express different properties.  Noone really uses the \"x-dot\" anymore*, it's basically a vestigial organ of Newtonian notation and calculus books only bring it up in case you run into it.\n\nAs for different symbols meaning different things in different fields of Mathematics; this is not ideal but as long as you're clear on the concepts you are working with the meaning is usually clear from context.\n\n*edit: maybe I should have said noone in mathematics still uses it, which is what my background is in.  I'm actually curious if it's use in Physics is correlated to culture, i.e. if countries that were always on Leibniz's side of the debate tend to stick to Leibniz's notation."], [20, "I'm sure mathematical notation can be short and sweet to practitioners in-context, but I often find myself wishing for some pseudocode, or at least formulations where the names are more-verbose than a dozen single-letter units."], [19, "There's also the fact that for some reason *(sin(x))^2* is written as *sin^2 x*, which does *not* mean *sin(sin(x))*."], [10, "/r/badmathematics \n\nThe probleme here is not the notation, the problem is that the author doesn't understand anything about random variables or probabilities and treat it as just writing formulas "], [10, "In essence: mathematical notation is not awful. Awful notation is awful."], [10, "> I understand most of higher math by reformulating it in terms of lambda calculus and type theory\n\nI find that a little hard to believe, and even if that were true, I don't think this will make things easier to understand. Restricting math to computable functions *at the notation level* is unlikely to make things easier to understand."], [9, "Reading this in *Reddit is fun* on mobile make mathematical notation extra horrible."], [7, "\"Mathematical notation fundamentally sucks.\" -- Gerald J. Sussman\n\nThat's a quote from this awesome video: https://www.youtube.com/watch?v=arMH5GjBwUQ\n\nThe author is not wrong. Also see this appendix about the notation in \"Structure and Interpretation of Classical Mechanics\":\n\nhttps://mitpress.mit.edu/sites/default/files/titles/content/sicm/book-Z-H-79.html#%_chap_8\n"], [6, "If only mathematicians were 10x like us hackers"], [4, "This article is retarded. E[X^(2)] makes perfect sense since the expected value is defined as a Lebesgue integral. I won't bother with the rest of the article because it is clear that the author made no effort to look up the proper definition of the mathematical object he is complaining about.\n\nHowever, I can't stop myself from commenting on the obvious lack of understanding of derivatives, differentials and their notation. And while there *is* some redundancy with the different notations, there is good reason for their existence.\n\nAnd finally, it looks like the author doesn't like mathematics because he hates the fact that to understand a single formula, you have to understand *everything* it is built on. While the author is right that curricula that lack fundamental concepts confuse students, it must be noted that in many cases, it is the students that don't want anything to be described rigorously."], [3, ">Personally, I understand most of higher math by reformulating it in terms of lambda calculus and type theory\n\nWe have a fedora tipper on our hands here boys"], [2, "Suggest a useful alternative and I'm sure people will take it up. It's telling that no one has come up with a better system of notation that retains the desirable properties of mathematical notation. \n\nAlso, this last paragraph:\n\n> Personally, I understand most of higher math by reformulating it in terms of lambda calculus and type theory, because they map to real world programs I can write and investigate and explore. Interpreting mathematical concepts in terms of computer programs is just one way to make math more tangible. There must be other ways we can explain math without having to explain the extraordinarily dense, outdated notation that we use.\n\nI think you're confusing syntax with semantics. Understanding the meaning of mathematical statements can be tough. You're blaming the syntactic mechanisms used to convey that meaning, when I don't think they're universally to blame (although as you indicated there are notational weirdnesses).\n\nYou can write a type theory proof with just the same mathematical notation as everyone else, and it's going to be just as confusing looking (if not [more so](http://www.cse.chalmers.se/~nad/listings/lib/Data.Integer.Properties.html) ). The syntax isn't as big a part of the problem as you make it out."], [3, "I really need to step up my maths game."], [2, "His definition of the expected value is just a special case of a more general case:\n\n    E[f(X)] = \\sum_{i=1}^{\\infty} f(x_i) p(x_i)\n\nwhere f(x) = x.\n\nWith this general definition, the ambiguity goes away."], [1, "I'm going to disagree with the author. Mathematical notation does have some disadvantageds, but it is very good at what it does. Mathematical notation is very precise and concise. To achieve those goals it sacrifices detail, leaving a lot of essential information out, counting on the reader's knowledge of the notation to explain the meaning. It allows people to easily manipulate the formulas, while still having all the essential information. The existence of Wolfram alpha is proof that the language is precise enough to allow a computer to solve problems.\n\nThe main disadvantage that I see is that mathematical notation requires a huge amount of knowledge to use properly. It's closer to a natural language than a computer language. I see students get tripped up all the time on simple problems because they don't understand the meaning of things. However, I believe that trade-off is worth it. Not everyone needs a very strong background in math, but those that do have the background will find that putting in the work to understand the meaning of the notation makes future problems easier."], [1, "Don't really see a problem with context dependent operators based on argument types, it's usually due to the operators being analogous, and I like it in my programming as well.\n\nSure, if you don't know what type you have, you won't know the operator, but that's your problem right there, you should know what type you have.\n\nNow of course, having both *, \u22c5, \u00d7 etc for the same operator is just silly, but probably a lost cause to try and fix.\n\nAs for the ^X ^/ ^p(x i^) ,  example, it sucks that common sense is required to figure it out, but they did actually give you the hint that you couldn't treat it as a regular function by using [] instead of (). A bit lazy though to not have properly defined \"split in infinitesimal pieces and apply to each piece\" operators."], [1, "\"applied mathematician\". what the fuck, revoke his diploma."], [0, "\\>fursona\n\nopinion discarded"], [0, "Expectation is not a function in the elementary sense, it's an operator. It operates on a function to produce a new function. The brackets are a pretty good suggestion you can't expect it to work as if it were plug and chug, imo."], [-2, "Awful indeed, yet OpenMath still did not deliver an alternative."]], [[{"comment": "The author's problem is that he doesn't understand how random variables and expected value work. He just wants to plug numbers into formulas to get answers without understanding what any of the math actually means.\n\nTake his example E[ x^2 ], this means finding the expected value from taking a random number from the distribution of x and squaring it. The notation shows this just fine.\n\nSame with E[ XY ], which means finding the expected value from multiplying a random value from the distribution of X with a random value from the distribution of Y. Notation works well here too.\n\nExpected value is not just some formula you plug numbers in, but a concept with a practical meaning, that it is the probability weighted mean of all outcomes, the value that a long running mean of samples approaches.\n\nIf the author actually understood how expected value works, then he would not need to lookup or memorize those formulas. Take finding the formula for E[ x^2 ] for example. Each xi from x has a probability of p(xi) of occurring. When squaring x, you are squaring each xi, but the probabilities of each xi when squared stays the same. Squaring the number that comes from a dice roll for example does not effect the probability of which face is up after the roll.\n\nI will say that there is a disconnect between the authors that write math textbooks and students that read them. The authors seem to easily overlook pitfalls that students often find themselves in. This is because they can struggle to empathize with people who are not as familiar with math as they are.\n", "id": "daeycc7"}, {"comment": "In fact agree with the author to some degree. Saying he does not understand how random variables work does not help: he is clearly trying to learn about them, so it is natural he does not understand everything!\n\nAs far as I remember, most elementary textbooks skip from E{X} to E{X^(2)} directly when they talk about mean and variance and do not explicitly say that E{f(X)} is defined as sum(f(x)p(x)) but not sum(f(x)p(f(x)). If this is the first time you see this definition, it is very natural to be confused. The reader would wonder how to even express e.g. sum(x^(2)p(x^(2))) with the E{} notation? Why it is not an interesting operation and is rarely needed? Most elementary textbooks doe not cover such things.", "id": "daf16f1"}, {"comment": "Yeah, I think we mostly agree. I am just arguing that the notation the author complained about is not the problem. We could be blaming the textbook for the poor explanation instead.", "id": "daf1c2n"}, {"comment": "I wish that Math teachers had spent some time on the subject of Notations being something mathematicians use differently across domains and then spoke about why they do it.  The human brain is amazingly elastic, and once the notation and the notions behind its use are made explicit (instead of hoping we can guess it), appreciation for Math in general grows.\n", "id": "daokr58"}, {"comment": "> E{f(X)} is defined as sum(f(x)p(x)) but not sum(f(x)p(f(x)).\n\nAren't they equal? You can use the latter as definition, it's just easier to write and calculate the former.", "id": "daf723w"}, {"comment": "In the second case, you would need the probability function p_f(f(x)) instead, otherwise it is incorrect. A clear example of when this is false is to consider Uniform X from 1 to 6 (a die roll) and to use the function f(x) = x + 100. The expectation of the random variable Y = f(X) is 103.5. However, the probability function in X is 0% for all values greater than 6. Carelessly using p_x(f(x)) in Sum[f(x)**p**(f(x))] would equal 0. ", "id": "dafd2uv"}, {"comment": "Of course one needs to use probabilities of f(X) when calculating E(f(X)), that goes without saying. ", "id": "dag3vlx"}, {"comment": ">that goes without saying\n\nNot always to someone unfamiliar with the math notation for expectation. It wasn't 100% clear which camp your were in from your question, but upon second reading, you seemed to know what's up and what's down.", "id": "dag4e77"}, {"comment": "At the end of the day yes they are equal, but it is not a trivial result; especially not for someone who is learning about probability for the first time. At that level they probably have not even heard about measure theory.", "id": "daf8hrl"}, {"comment": "Nice explanation of the LOTUS rule. ", "id": "daf1x9h"}, {"comment": "[LOTUS](https://en.wikipedia.org/wiki/Law_of_the_unconscious_statistician)", "id": "daf2116"}, {"comment": "To be fair, this is partly to blame on the given formula. \nIf it was written as E(X)=\u03a3\\_(\u03c9\u20ac\u03a9) X(\u03c9)P({\u03c9}) or E(X)=\u03a3\\_(x\u20acX(\u03a9)) xP(X=x) it would probably be easier to see that X refers to the random variable and does not mean \"replace all the x\\_i s\".\nMathematics has lots of great notation that can make things a lot shorter to write down, but I somewhat agree with the author they can be rather confusing to figure out, if one does not understand the underlying mathematics.\n\nP.S. I also hate the E(X^2 ) notation, as I'm one of those persons who prefer powers to denote composition instead of multiplication for functions (although composition with itself rarely makes sense for random variables).", "id": "daf4ql6"}], [{"comment": "That particular case is not awful. The author just failed to appreciate the distinction between a variable and a random variable.", "id": "daexigk"}, {"comment": "Right. A random variable *X* denotes a relation, and the notation *X*^(2) denotes the squaring function *lifted* to the relation (whereas E[*X*]^(2) denotes the squaring function directly applied to the real-valued expectation itself.) Lifting is a very common form of type punning in mathematical notation, and you should recognize it immediately if you are minimally fluent in it.", "id": "daey74f"}, {"comment": "> Lifting is a very common form of type punning in mathematical notation, and you should recognize it immediately if you are minimally fluent in it.\n\nBut the counterargument to this is that it's not a big deal to require notation to explicitly show where functions are being lifted.  I mean, it's not hard.  For example, in pseudo-Haskell:\n\n    expected ((^2) <$> x)\n\n...where the `<$>` operator lifts the squaring function `^2` to the random variable `x`.  We explicitly notate lifting (a.k.a. \"mapping\") **everywhere** in Haskell programming, and increasingly in other programming languages (every time a functional programming newcomer writes `someArray.map(someFunction)` in some language like Javascript, they've just lifted `someFunction` to operate on arrays).  Why can't mathematical notation do the same?  (Not a rhetorical question!)\n\n**EDIT:** Another thing I noticed:\n\n> A random variable *X* denotes a relation, and the notation *X^2* denotes the squaring function lifted to the relation [...]\n\nI think here you stealthily got something right that the article and most commenters are getting wrong, but you failed to highlight it: the original article is talking about E[ X^2 ] but this is a failure to \"factor\" the problem accurately, because, as you ninja-corrected it, the E[...] part is not relevant\u2014the X^2 part has a meaning that's independent of the E[...] part.  The key concept is how to lift a function to probability distributions.  Again in pseudo-Haskell, we have:\n\n    -- The type of random variables that take on values of type `a`\n    type Random a\n\n    -- We can \"lift\" a regular function to one that works on\n    -- random variables of the corresponding element types.\n    -- We can also call this \"mapping\" the function over the \n    -- random variable.\n    (<$>) :: (a -> b) -> Random a -> Random b\n\n    -- If a random variable ranges over real numbers, we can compute its \n    -- expected value. \n    expected :: Random Real -> Real\n\nAnd this gets us back to my `expected ((^2) <$> x)` pseudocode.", "id": "daflv43"}, {"comment": "> We explicitly notate lifting everywhere in Haskell programming. Why can't mathematical notation do the same? (Not a rhetorical question!)\n\nMathematical notation exists for pretty much the sole purpose of increasing information density.  Explicit lift operations convey almost no information, so you'll only really see them when needed to resolve ambiguities (and sometimes not even then!).  Basically, if you're only writing `(^2) <$> x` because `x^2` isn't defined for the \"type\" of `x`, you might as well just define it instead.\n\nIn contrast, (good) programming languages are designed to be clear and unambiguous at a glance.  Mathematics is not usually just glanced at -- it is read as slowly as necessary for you to understand it completely.", "id": "dafmo6g"}, {"comment": "> Mathematics is not usually just glanced at -- it is read as slowly as necessary for you to understand it completely.\n\nI don't buy the implication that code is \"just glanced at.\"  And in software we often see the opposite argument: programmers spend an inordinate amount of time reading code (as opposed to writing it), therefore code ought to be more explicit.", "id": "dafnfzd"}, {"comment": "Yes, programmers spend a lot of their time reading code.  But they generally do not read each line of code as thoroughly or for as long as mathematicians read lines of mathematics.  My point is that good programming languages (and good code itself) allow you to understand code without thinking about it very hard, and without having to look at a bunch of other code.  Mathematical notation is not like this.", "id": "dafo4fs"}, {"comment": "> Yes, programmers spend a lot of their time reading code. But they generally do not read each line of code as thoroughly or for as long as mathematicians read lines of mathematics.\n\nHow is that not just a vacuous reflection of the fact that mathematical notation is so dense and programming notation so terse?  If the notational density was the other way around, wouldn't the time spent per line flip around as well?\n\n> My point is that good programming languages (and good code itself) allow you to understand code without thinking about it very hard, and without having to look at a bunch of other code.\n\nIt may be a common sentiment, but I think this is a chimera.  Programmers *do* need to think very hard and look at a bunch of other code and specifications to understand programs they didn't write.  For example, there's no purely local way to understand the *factoring* of a program into separate functions or modules.  If the question is whether the code is well factored, you need to compare it to alternatives that put stuff from here elsewhere or stuff from elsewhere here.", "id": "dafoc55"}, {"comment": "Because in Haskell composition is a function but application is syntax, so you're forced to introduce a \"fake\" `$` or a `<$>` just to make the corresponding `Applicative` typeclass match. This is a kludge, not a feature: if the blank space between expressions were a function you could instantiate the typeclass directly on it, no need for the dollar signs.", "id": "dafmsx0"}, {"comment": "I think this is only shifting the problem around.  You want an expression like `x^2`, where `x :: Random Real`, to be read like `(^) x 2` where:\n\n* The first space is read as `<$> :: Functor f => (a -> b) -> f a -> f b`;\n* The second space is read as `<*> :: Applicative f => f (a -> b) -> f a -> f b`;\n* The `2` is read as `pure 2 :: Random Real`.\n\nOr alternatively, you want to read both spaces as `<*>`, but read `(^)` and `2` as `pure (^)` and `pure 2` respectively.  The latter is cleaner, but I think in both cases spelling it out explicitly makes it clear why it confuses the heck out of people.\n\nIn any case, I'm starting to think it's maybe not the notation that's the biggest problem here, but the failure to model the types more explicitly.  In order to use implicit lifting as a notational convenience we need to get the student to a point where, when they see E[ X^2 ], they understand the **type environment** for the expression, and call out lifting as a *bona-fide* operation:\n\n* X : Random \u211d\n* exponentiation : \u211d \u2192 \u211d \u2192 \u211d\n* E : Random \u211d \u2192 \u211d\n* lifting : \u2200a.\u2200b. (a \u2192 b) \u2192 Random a \u2192 Random b\n\nTherefore, because E[ X^2 ] must have type \u211d, X^2 must have type Random \u211d, and the only way to get that given the types of X, exponentiation and 2 is through implicit lifting.\n\nSo even if we used the same implicitly lifted notation, why not just be more explicit about the types of the terms?  In typed functional programming we talk a lot about using types as a documentation and expositional tool, and that is something that I wish mathematicians would do more of.", "id": "dafpigl"}, {"comment": "> the failure to model the types more explicitly\n\nI do think so. I used to try to be more principled in the type usage of my mathematical formulas but I found it quickly becomes unwieldy with a net loss of clarity. It's all about the what, not the how.", "id": "dafpm34"}], [{"comment": "Statistics is notorious for having god awful notation.  Leave other mathematical fields out of this!\n\nI don't really agree with his other points outside of statistics though.  The multiple current notations for the derivative are trying to express different properties.  Noone really uses the \"x-dot\" anymore*, it's basically a vestigial organ of Newtonian notation and calculus books only bring it up in case you run into it.\n\nAs for different symbols meaning different things in different fields of Mathematics; this is not ideal but as long as you're clear on the concepts you are working with the meaning is usually clear from context.\n\n*edit: maybe I should have said noone in mathematics still uses it, which is what my background is in.  I'm actually curious if it's use in Physics is correlated to culture, i.e. if countries that were always on Leibniz's side of the debate tend to stick to Leibniz's notation.", "id": "daexhrz"}, {"comment": "The dot notation is used quite often still in physics. I've only taken one engineering class, but it is used there frequently as well.", "id": "daexsjy"}, {"comment": "Yeah but there it is a short hand for a specific derivative, derivative over time. Everything else is Leibniz notation.", "id": "dagrqey"}, {"comment": "I think the dot notation is often used to denote a derivative with respect to time (at least this is what I was told in school), which I would guess is why it appears more in differential equations modelling physical events etc.", "id": "daey2i0"}, {"comment": "Exactly. A lot of physics is in the form of a PDE in space and time, so having gradients and general vector calculus notation (nablas) in space and the dot notation for time derivatives makes a lot of sense.", "id": "daeym1y"}, {"comment": "I think it is awful from an CS point of view, but so are notations and terms in almost all sciences. CS is just so young that they started to unify everything right from the beginning. You can't compare that to mathematics where some fields were developed thousands of years ago.", "id": "daeyeax"}, {"comment": "I'm not a CS person. Could you link me to some summary of CS notation?\n\n(something like https://en.wikipedia.org/wiki/List_of_mathematical_symbols)", "id": "daf8tb4"}, {"comment": "I don't know if wikipedia has a page like that for CS, but the page for the simply typed lambda calculus has a decent amount of notation https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus#Syntax", "id": "dafmxwc"}, {"comment": "[deleted]", "id": "dafol85"}, {"comment": "The '::=' symbol usually means that the symbol on the left can be substituted for one of the pipe-delimited symbols on the right. See https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form#Example, which uses that symbol to define a postal address.\n\nAs for the image you linked, it is saying that a type *tau* is defined as either a function type (*tau* arrow *tau*), or a base type *T*, where T is in the set of base types *B*. For example, *int* would be a base type and the function\n\n    fun (x: int) =\n        return x + 5\n\nwould have the type *int -> int*.", "id": "dafq2g1"}, {"comment": "'::=' or just ':=' can usually be read as \"is defined to be.\"\n\n'|' is usually read \"where\" but in this case reads \"or.\" \n\nIf I understand it right, the image you linked would be read \n\n\"a type *\u03c4* is defined to be either \n  \n1. a function, which given an input of type *\u03c4*, will produce an output of type *\u03c4*, or\n\n2. an atomic type.\"\n\nI don't quite understand the bit about a function from *\u03c4\u2192\u03c4*. I guess they may simply have meant each of the three \u03c4's to refer to a separate type. If so, I think it might have been clearer had they instead defined the set of types, which as I understand it would be\n\n*T* ::= {*b* | *a* \u2192 *c*} where *b* \u2208 *B* and *a*, *c* \u2208 *T*", "id": "dafr5fb"}, {"comment": "This is a very standard syntax definition. As I understand it, the primary difference between it and your formalism is that your formalism presumes the validity of the constructions themselves; aka. that `a \u2192 c` even makes sense to write. The rules as given in the image define the constructions instead, and then the language `\u03c4` is defined as the reflexive transitive closure of those constructions.\n\nIn particular, the formalism in the image is specific that `(a \u2192 b) \u2192 c` is different to `a \u2192 (b \u2192 c)`; the same is not obvious from your example, as `a \u2192 c` could easily refer to concatenation of strings if not defined explicitly.\n", "id": "dag4mat"}, {"comment": "Oh, and what mathematical field doesn't have tons of overloaded meanings and things that act as impure macros and whatnot?\n\nAn example that I find is especially irksome is Big-O notation:\n\n    O(n^2) = n^2 +3n + 7\n\nSure, it looks like a function, but actually its a macro, defining a set of functions, and turning the equal sign into an \"element of\" operator. Oh, and if you are doing numeric approximation or some other mathematics, it means something similar but subtly different.", "id": "dafpoip"}, {"comment": "That's why O denotes a set and you use the element of operator. The equal sign in your example is sloppiness. ", "id": "dag4ipp"}, {"comment": "That's how it is commonly notated... see the wikipedia article on big-o notation for example. The sloppyness is not on my part, but on the part of the apparent bulk of mathematicians.\n\nAdditionally what about notation like this:\n\n    f(x) = 1 + x + (1/2) x^2 + O(x^3)\n\nSimilar notation, but the definition is now backwards and it's purpose in the expression different.", "id": "dag4te7"}, {"comment": "Uh, I used the dot notation for all my scolarity, during high school and college (I'm 24)", "id": "daexq2k"}], [{"comment": "I'm sure mathematical notation can be short and sweet to practitioners in-context, but I often find myself wishing for some pseudocode, or at least formulations where the names are more-verbose than a dozen single-letter units.", "id": "daexacz"}, {"comment": "The case against verbose variable names is that they tend to obscure the functional content in the formula. Instead of verbosity, you use supporting text that gives context and provides definitions.  \n\nIf you try to cram everything into the formula, you lose sight of the relations between variables, and you actually make your definitions more terse, since they now have to be contained in the variable name instead of a paragraph of text.", "id": "daeyq5e"}, {"comment": "There is no reason you couldn't do both. There is no reason a simple pseudo code language couldn't exist that could provide optional clarity to anyone who doesn't already understand mathematical notation and the meaning of the variables involved.\n\nWhat you are describing with reducing the variable names and semantic content is part of what we do explicitly to code to make it difficult to understand by other developers.", "id": "dafg0vz"}, {"comment": "I agree completely, but I feel we are not quite talking about the same thing. Mathematics have become terse and difficult to understand for outsiders because it's developed to express complex difficult concepts in the first place. If you forced mathematics to use verbose variable names and drop all the special operators, you would not really provide the layman with any understanding, because that requires understanding the underlying concepts. On the other hand, you would make life a lot harder for people who do understand what's going on, because they can no longer recognise the expressions at a glance.\n\nRegarding the article here, the author is looking to compute something and tries to do so solely by reading formulas. And that is fundamentally missing the point of mathematical notation, since he clearly doesn't understand the concept of an expectation. The formulas are shorthand for people that do understand the notation, such that you can quickly relay complex ideas. \n\nIt is kinda similar to trying to learn programming by just reading code. Even the neatest, easiest to read syntax won't teach you fundamental concepts, and you will be stuck copy pasting stuff from stack overflow, getting frustrated and angry with the language if you try to modify the code - exactly like the author is doing with statistics.", "id": "dafl613"}, {"comment": "> you would not really provide the layman with any understanding\n\nI was thinking for software developers, specifically. Not laymen.\n\n> The formulas are shorthand for people that do understand the notation, such that you can quickly relay complex ideas.\n\nRight, which makes the notation pretty poor for anyone trying to understand all of the concepts that make up that formula from top to bottom.\n\n> It is kinda similar to trying to learn programming by just reading code.\n\nIn .NET I can open up the source code to all of the built in functions and read what the method I am calling is doing. What I am saying is that there is no simple way to do that with mathematical notation. The answers you are looking for might be spread across a number of different papers or non standard definitions.", "id": "dafn5m2"}, {"comment": "Yes, especially since we use computers a lot now, writing something like\n\n    Sum[ i = 0 -> inf] ( some_function(i) ) \n\nseems better. It's easier to handle when you want to write fast or don't have a fancy editor with math symbols and formats. It also makes it more clear to people that don't use mathematical notation that much.", "id": "daexpxn"}, {"comment": "Yeah, I am a programmer. I spend my days looking at code, reading math notation is not a skill spend that much time doing, a pseudo code is much easier for me to understand because it's writen in a way that values simplicity and ease of understanding. Seems to me math notation values being concise and compact.", "id": "daf024a"}, {"comment": "So when taking a mathematics course, you expect the formulas to be written in pseudo-code ?", "id": "daeyy8c"}, {"comment": "No, as developers who want to use real math in our applications it becomes a pain to try and translate.", "id": "dafg2ph"}, {"comment": "You read words for understanding,  not formulas.\n\nYou calculate formulas for understanding. \n\nYou never have to evaluate programs by hand, so you can afford to use words. ", "id": "dah8ipy"}, {"comment": ">You never have to evaluate programs by hand, so you can afford to use words. \n\nUh, what industry did you say you worked in? The only programmers who never step through a program mentally are the ones who copy-paste from \"how do I\" searches, and run it until their print-statement \"debugging\" randomly  looks right.\n\n\n\n", "id": "dah8sta"}, {"comment": "Mentally stepping through is not the same thing as calculating by hand.\n\nFor some of my physics problems I would define c(x) = cos(x), and then drop the x. Then c'' = -s' = -c, which makes solving differential equations much faster.\n\nIf I'm writing a program with a symbolic algebra system, of course I would write out derive[cos(x)] == sin(x), or whatever. The intent is much clearer.\n\nIf I was talking out loud and using a blackboard, but had a long calculation, I might say \"c means cosine here\" and then life moves on.\n\nI don't feel like I'm saying anything controversial.\n\nThe point I was trying to communicate with the original post though, was read the surrounding words and context. And listen to what the speaker is saying. Don't try to understand equations completely out of context, that isn't how math and physics culture works. The equations are there to keep track of details, not hold your understanding.", "id": "damqo2r"}], [{"comment": "There's also the fact that for some reason *(sin(x))^2* is written as *sin^2 x*, which does *not* mean *sin(sin(x))*.", "id": "daexeoj"}, {"comment": "However, *sin^-1 (x)* does *not* mean *1/sin(x)*...!", "id": "daey78u"}, {"comment": "It depends on where you live actually. In Russia, inverse sine is always notated as *arcsin(x)*, so *sin^-1 (x)* *may* actually mean *1/sin(x)*.\n", "id": "daf0aqc"}, {"comment": "[deleted]", "id": "daeyx2l"}, {"comment": "I realize this is a game long lost, but why pun notation like this to begin with?\n\nI feel like mathematical notation suffers greatly from not consistently treating functions as values. If you want the inverse of f, write inv f. If you want a function that takes the sine of a number and then squares it, write ^2 \u2022 sin. The difference between inv f x and (f x)^-1 is as clear as day.", "id": "daf1d4g"}, {"comment": "It is not a pun notation.The set of functions X->X form a monoid  under composition (that is pretty much the essence of thinking of functions as values) and f^k is just standard notation for repeatedly combining an element with itself in a monoid. Just as f^-1 is the standard notation for the invers.\nBesides that, your notation would be quite unpleasant, if you want to compose a function (or its invers) with itself multiple times.\n\nAs for sin^2 (x) meaning sin(x)\\*sin(x), I'm not a huge fan of it, but it does make sense, if it is clear that you are referring to the functions X->X (where X is also a monoid written in multiplicative notation) under element wise multiplication. How ever, since that is not always clear and since composition is the \"default\" operation on functions (since it doesn't require the set mapping to to also be a monoid), I prefer sin^2 (x) to mean sin(sin(x)).\nIf you are talking about functions X->Y where Y is a monoid and not a subset of X, though, it does make sense for the default interpretation of f^2 (x) to be f(x)\\*f(x)", "id": "dafj1a8"}, {"comment": "If there are multiple valid interpretations of a notation, then the notation is inconsistent. If the right semantics have to be inferred from context and culture, well, that's a really shitty isn't it?", "id": "dafpzhj"}, {"comment": "Making all of mathematical notation completely unoverloaded and unambiguous would also make it completely unreadable.", "id": "dafvvks"}, {"comment": "It does not have to be perfect, but it could easily be a lot better in many cases. And I am don't see how making it unambiguous, if only by specifying and explicit context, allowing a clear path for resolving a symbols meaning, would so destroy readability.", "id": "dag4ksh"}, {"comment": "The first part is a fair point. I hadn't considered that x^k is k combinations of x in a monoid!\n\nI still think sin^2 (x) is inexcusably awful though. ;_;", "id": "dafpm88"}, {"comment": "[deleted]", "id": "daf2hvx"}, {"comment": "I don't think any of the relies I received were smug.", "id": "dafppao"}, {"comment": "I was thinking more about the entire reddit thread. Smug overload.", "id": "dai0ll4"}, {"comment": "Right, but to /u/CaptainAdjective's point f^2 (x) = (f \u2218 f)(x) = f(f(x)), but sin^2 (x) != sin(sin(x))", "id": "daeznsl"}, {"comment": "[deleted]", "id": "daf03zv"}, {"comment": "I think the point was that either way, the notation is inconsistent.", "id": "daf5g1z"}, {"comment": "[deleted]", "id": "daf903l"}, {"comment": "The entire point of this article and the deep problem in mathematical notation is exactly this sort of pervasive overloading. A million minor conveniences have resulted in an inconsistent clusterfuck of notation.", "id": "dafpuw3"}, {"comment": "It's not a convention you write it however you like and the meaning is clear in 99% of the cases ", "id": "daeyxju"}], [{"comment": "/r/badmathematics \n\nThe probleme here is not the notation, the problem is that the author doesn't understand anything about random variables or probabilities and treat it as just writing formulas ", "id": "daeyzfg"}], [{"comment": "In essence: mathematical notation is not awful. Awful notation is awful.", "id": "daex5f8"}, {"comment": "In essence: people shouldn't write blog posts on things they don't understand.", "id": "daf2ht8"}], [{"comment": "> I understand most of higher math by reformulating it in terms of lambda calculus and type theory\n\nI find that a little hard to believe, and even if that were true, I don't think this will make things easier to understand. Restricting math to computable functions *at the notation level* is unlikely to make things easier to understand.", "id": "daeyz8n"}, {"comment": "> Restricting math to computable functions\n\n???\n\nType theory supports relations and non-computable stuff just fine. Not even with corecursion. Just define an indexed type `A -> A -> Type` and there's your relations on As.\n\nIt's possible to embed higher order logic and ZFC inside type theory. The author's use of type theory is presumably just because of the existence of mature tools for proving and reasoning in such logics.", "id": "daezyzy"}, {"comment": "I wasn't referring to type theory (although the desire to express all math formally -- in *any* foundation -- also seems untenable), but to the desire to express every definition as code.", "id": "daf0qm8"}, {"comment": "But you can do that without \"restricting math to computable functions\". It just doesn't follow that expressing math as code means you can only express computable things.\n\n> although the desire to express all math formally -- in any foundation -- also seems untenable\n\nSure, Hilbert's programme is silly, but that's a separate discussion", "id": "daf0wc3"}, {"comment": "That's how I interpret their mention of lambda calculus; otherwise, it's just replacing one formal foundation with another, which doesn't help with notation. I don't think that's what was meant because the author doesn't sound like a logician, and their explicit motivation is knowing how to compute things (esp. definitions), not how to formally deduce theorems.\n\nEven when things can be defined as computations, doing so may make things far more complicated (e.g. real numbers and calculus).", "id": "daf1z36"}, {"comment": "> That's how I interpret their mention of lambda calculus; otherwise, it's just replacing one formal foundation with another, which doesn't help with notation.\n\nLambda calculus just gives a more precise notation for _bindings_, which is something mathematical notation routinely screws up. You can express non-computable things just fine with lambda calculus \"notation\", specifically using higher order abstract syntax (this what is done in HOL for example).\n\nReplacing one formal foundation with another indeed doesn't really help the significant notational problems. But trying to construct a formalism yourself (in type theory or anything else) is a great way to understand it better. That's why I was saying that the blame is misplaced: The author is frustrated by not understanding the mathematics well, but this is just a result of poor teaching/learning of mathematics, not really much about the notation.\n\n(although, if lambda calculus/HOL style notation were used in this example it would be far less confusing)\n\n", "id": "daf3oay"}, {"comment": "> Lambda calculus just gives a more precise notation for bindings, which is something mathematical notation routinely screws up.\n\nI guess you're right. Maybe that is what the author meant...", "id": "daf5qwp"}, {"comment": "> Lambda calculus just gives a more precise notation for bindings, which is something mathematical notation routinely screws up.\n\nWell, maybe you're thinking of the untyped lambda calculus in this quote, but *typed* lambda calculi do much more than just that:\n\n1. They explicitly define a consistent syntax for *terms*/expressions;\n2. They introduce the notion of *type environments* that explicitly associate a type to each variable that appears in a term. For example the type environment for the E[ X^2 ] example is something like:\n * X : Random \u211d\n * exponentiation : \u211d \u2192 \u211d \u2192 \u211d\n * lifting (implicit) : \u2200a.\u2200b. (a \u2192 b) \u2192 Random a \u2192 Random b\n * E : Random \u211d \u2192 \u211d\n\nMore importantly, they provide *concise*, *explicit* notations for things that in conventional mathematics are informal natural language statements.  Instead of saying something like \"let X be a random variable that ranges over \u211d,\" I can write \"X : Random \u211d\" as above.  Just the ability to concisely say \"E[ X^2 ] : \u211d (where X : Random \u211d)\" (explicit clarification of the type environment) is already a big boost in legibility, IMHO, for notational peanuts.", "id": "dafq7at"}, {"comment": "You're right of course, but as a notational thing I think traditional mathematical notation doesn't do this so badly. The bit where it's really atrocious is the binding.\n\n> Well, maybe you're thinking of the untyped lambda calculus in this quote\n\nNah, because if you use untyped lambda calculus as the \"term language\" of a logic you can prove false just by using the term `Y not` which reduces to `not (Y not)` so you're in deep trouble.. To resolve these problems, you only need the simplest of type systems. ", "id": "dafvld4"}, {"comment": "Wait a second. How do you define an uncomputable *function* in typed-LC? Perhaps you could define it as a relation, but then it's not the same object as a function (you can't apply it in the same way). Isn't it true that typed-LC notation must *inherently* treat computable and non-computable objects differently?", "id": "dairys8"}, {"comment": "Raw typed lambda calculus of course can't express non-computable functions, but if you're just using lambda calculus as a framework for higher order abstract syntax (as in HOL), you can very easily just use Hilbert's epsilon operator (for example) to (once again, for example) define busy beaver.\n", "id": "daismy1"}, {"comment": "Is there a good introduction to HOL (or *a* HOL) outside of a long tutorial on Isabelle?\n\nEDIT: Would [this 1989 paper by Paulson](https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-175.pdf) do?", "id": "daiswnu"}, {"comment": "Paper looks OK. The main point is that Isabelle's meta logic (which includes the lambda calculus) needs only support the bits of logic necessary to encode the axioms of HOL with higher order abstract syntax. ", "id": "daiu9pu"}], [{"comment": "Reading this in *Reddit is fun* on mobile make mathematical notation extra horrible.", "id": "daexhz4"}], [{"comment": "\"Mathematical notation fundamentally sucks.\" -- Gerald J. Sussman\n\nThat's a quote from this awesome video: https://www.youtube.com/watch?v=arMH5GjBwUQ\n\nThe author is not wrong. Also see this appendix about the notation in \"Structure and Interpretation of Classical Mechanics\":\n\nhttps://mitpress.mit.edu/sites/default/files/titles/content/sicm/book-Z-H-79.html#%_chap_8\n", "id": "daffngl"}], [{"comment": "If only mathematicians were 10x like us hackers", "id": "daexc0g"}], [{"comment": "This article is retarded. E[X^(2)] makes perfect sense since the expected value is defined as a Lebesgue integral. I won't bother with the rest of the article because it is clear that the author made no effort to look up the proper definition of the mathematical object he is complaining about.\n\nHowever, I can't stop myself from commenting on the obvious lack of understanding of derivatives, differentials and their notation. And while there *is* some redundancy with the different notations, there is good reason for their existence.\n\nAnd finally, it looks like the author doesn't like mathematics because he hates the fact that to understand a single formula, you have to understand *everything* it is built on. While the author is right that curricula that lack fundamental concepts confuse students, it must be noted that in many cases, it is the students that don't want anything to be described rigorously.", "id": "daeyeo8"}, {"comment": "The problem with such a notation is that *you* can look up the relevant definitions. You're a human. And only a hypothetical strong AI can match your ability. Which means this notation is not machine-readable, not verifiable, not suitable for an automated translation and even for a semantic search. And it sucks.\n\nA simpler and strongly typed notation would have been much better. Yet, nobody managed to invent one. OpenMath was the closest bet.", "id": "daeyvx0"}, {"comment": "I completely agree that we should move towards making all scientific content machine-readable. That, however, doesn't mean that the current notation doesn't make sense, because in most cases it does.", "id": "daeyyl1"}, {"comment": "Eh, I think it is pretty machine readable. You just have to realize that evaluating math is more like macros then like expressions, but computers can expand those macros just as well.", "id": "dafqchv"}, {"comment": "Everything is nothing but a term rewriting. But with the mathematical notation the problem is with referenced definitions being unaccessible unless you have a strong AI which can read all the vague natural language blah-blah-blah accompanying your expressions.", "id": "dafr4xj"}, {"comment": "> E[X^2 ] makes perfect sense since the expected value is defined as a Lebesgue integral.\n\nWhich you can discover because you already know this notation and know the entire reasoning behind it. If I'm a beginner and see a snippet on, say, math.stackexchange.com, I'm SOL.\n\nCompare with programming, where we at least have longer and more descriptive names for everything.\n\n> I won't bother with the rest of the article\n\nWhich goes on to describe notational inconsistencies. It would be bad enough if you had a ton of impossible-to-search notation to deal with, but there are a bunch of operators that are reused for vastly different purposes.", "id": "daf958n"}, {"comment": ">Which you can discover because you already know this notation and know the entire reasoning behind it. If I'm a beginner and see a snippet on, say, math.stackexchange.com, I'm SOL.\n\nIf you had read my post, you would notice that that is exactly the point I am making. Mathematics, due to its nature, requires you to know the definitions and the concepts that the concept you need depends upon, and there is no way to cut corners.\n\nWith this particular formula though, it's very easy to see the logic behind it because it's simply a Lebesgue integral of a simple function.\n\nMathematics would benefit from longer and more descriptive names, but in this particular case everything is either crystal clear, or not clear at all. Knowing the names for things won't give you much insight into their mathematical structure and meaning.\n\n>Which goes on to describe notational inconsistencies. It would be bad enough if you had a ton of impossible-to-search notation to deal with, but there are a bunch of operators that are reused for vastly different purposes.\n\nNo, the rest of the article is \"I didn't read about any of the shit I am complaining about\". The bit about covariance, is, once again, caused by him not knowing the definition of expectation, and, at the very end of that bit, he displays his lack of understanding of what *Wikipedia* is.\n\nThe bit about the notation for derivatives and differentials holds no value because while some notations are just shorthands for others (introduced to reduce the clutter and make manipulation easier), the others aren't equivalent at all.\n\nOn multiplication: why even bring up elementary school? And the vector product is perfectly reasonable, because it forms a Lie algebra together with vector addition. The scalar product, on the other hand, doesn't really fit into my understanding of multiplication, but still, it deserves to be denoted by a dot because it exhibits a lot of the properties normal multiplication exhibits.\n\nI can't say anything about the commutator notation, because the only notation for commutators I've encountered is the standard [g h].\n\nEDIT: I would like to add that I think that we need a large database of mathematical concepts and their relations to make navigation easier, but that would be a huge task and would require a giant collaborative effort.", "id": "dafbnen"}, {"comment": "How do I know which particular definition of each symbol I am looking at? E, [ ], X, and ^2 can all mean very different things in different contexts.", "id": "dafqejw"}, {"comment": "> This article is retarded. E[X2] makes perfect sense\n\nNo, it does not make perfect sense. \"Expected value\" in the English sense of the phrase for discrete distributions *does not* mean the arithmetic mean of the random variable. It means the mode. As the author laments at the end, properly typing your variables (as classical mathematicians practically never do) yields the insight that often the arithmetic mean doesn't even exist or make sense, while the mode *always* makes sense as a notion for discrete random variables and is precisely compatible with the English meaning of the phrase \"expected value.\"\n\nFor example, iPhones come in 5 colors, pink, white, gold, black, and shiny black. I can define a probability density function `p(x : iPhoneColor) -> Probability` using the popularity stats from Google and I immediately get a meaningful definition of mode (it's black), but the arithmetic mean *does not even exist*. It means no sense to say the expected color of my friend's iphone is 50% black 20% really black 15% pink 10% gold and 5% white paint.\n\nThe official mathematical name is *wrong* and doing mathematics from a typed perspective makes this very clear.", "id": "daezh6z"}, {"comment": ">\"Expected value\" in the English sense of the phrase for discrete distributions does not mean the arithmetic mean of the random variable.\n\nWho gives a shit what the English (layman) sense of the phrase is? \"Measurable\" in the English sense of the phrase doesn't mean what it means in functional analysis either. And mode doesn't make sense for a *huge* amount of problems.\n\n> It means no sense to say the expected color of my friend's iphone is 50% black 20% really black 15% pink 10% gold and 5% white paint.\n\nI agree with you that \"expected value\" isn't the best terminology since it may give the illusion that it must belong to the codomain of g (assuming we are calculating E[g(X)]) or even the sample space itself, and it seems that most people use the term \"expectation value\" or \"mathematical expectation\" (the latter being the most popular in my circles).\n\nEDIT: Changed an assertion to be clearer.", "id": "daf3pw9"}, {"comment": "> Who gives a shit what the English (layman) sense of the phrase is?\n\nProfessor, professor! *Shh!* This is why the comp sci department gets so much more grant money than we do!", "id": "dafbho6"}, {"comment": "> Who gives a shit what the English (layman) sense of the phrase is?\n\nA person who knows that lay people and technically astute people tend to communicate from time to time. Science reporting. Teaching  students. Trying to inform policy makers.", "id": "dafhhgj"}, {"comment": "I was with you until the last sentence. The entire reason for defining random variables the way we have is so we can integrate them over a probability space, which gives us an arithmetic mean in the discrete case. Everything is defined to make the types work: a random variable is a measurable function from a probability space to a measurable space.\n\nPerhaps it should have been called the long-run average value or something like that, but the mathematical types make sense.", "id": "dafv1x7"}, {"comment": "I'm... gonna disagree. You're just changing definitions so that you can say your arithmetic mean is always defined, and that should immediately raise red flags, like for example, the fact that your mode is no longer the type of the original random variable (in this case, `iPhoneColor`).\n\nIn my world, discrete random variables can be of any finite type, simply by defining `pdf : t -> Probability` for that type. This immediately gives you a mode of the proper type. If you need an arithmetic mean, you need to give a `t -> Rational` and then use that with the pdf to get what you need.\n\nI recognize that the mathematical community doesn't exactly like this, but... that's why we made our own world, with blackjack and hookers.", "id": "dahshue"}, {"comment": "The mode is also not always expected. In fact it may even be that the probability of getting the mode value is 0.\n\nAlso, maybe it would be more of a problem if it was actually called \"expected value\". It's not. It's \"expectation value\". I'd say it is different enough from everyday English to ring alarm bells when you hear it.", "id": "dafajkb"}, {"comment": "> Also, maybe it would be more of a problem if it was actually called \"expected value\". It's not. It's \"expectation value\".\n\nI've never heard it called this and Wiki confirms my experience, listing \"expectation value\" among many alternative names.\n\n> The mode is also not always expected. In fact it may even be that the probability of getting the mode value is 0.\n\nFor discrete density functions? I want to see an example of this. And no classical nonsense using the choice axiom! We banned that, too.", "id": "dafbeh2"}, {"comment": "> For discrete density functions?\n\nWhy do you restrict yourself to discrete functions?", "id": "dafcot8"}, {"comment": "cuz that's what I specified in the post you replied to", "id": "dafflly"}], [{"comment": ">Personally, I understand most of higher math by reformulating it in terms of lambda calculus and type theory\n\nWe have a fedora tipper on our hands here boys", "id": "daf2bk3"}], [{"comment": "Suggest a useful alternative and I'm sure people will take it up. It's telling that no one has come up with a better system of notation that retains the desirable properties of mathematical notation. \n\nAlso, this last paragraph:\n\n> Personally, I understand most of higher math by reformulating it in terms of lambda calculus and type theory, because they map to real world programs I can write and investigate and explore. Interpreting mathematical concepts in terms of computer programs is just one way to make math more tangible. There must be other ways we can explain math without having to explain the extraordinarily dense, outdated notation that we use.\n\nI think you're confusing syntax with semantics. Understanding the meaning of mathematical statements can be tough. You're blaming the syntactic mechanisms used to convey that meaning, when I don't think they're universally to blame (although as you indicated there are notational weirdnesses).\n\nYou can write a type theory proof with just the same mathematical notation as everyone else, and it's going to be just as confusing looking (if not [more so](http://www.cse.chalmers.se/~nad/listings/lib/Data.Integer.Properties.html) ). The syntax isn't as big a part of the problem as you make it out.", "id": "daexmti"}, {"comment": "The best example I can think of this is the delta-epsilon definition of the limit.  In real analysis you spend a good couple of weeks building up to a formal rigorous definition of a limit, and once you've put in the work and understand where more intuitive definitions break down the notation is fairly natural to work with.\n\nWithout that work though?  It's just a mess of symbols that you plug numbers into and seems needlessly obtuse.  You run into the formal definition early in Calculus I but without the rigor of analysis you just do some simple plug-and-play problems with it and it's never seen again.", "id": "daexruk"}, {"comment": ">The best example I can think of this is the delta-epsilon definition of the limit. \n\nOn the other hand, the Dirac delta function always leads to a notational mess \n\nStarting with the fact that it is not actually a function", "id": "daf4frf"}, {"comment": "I've never studied Fourier Analysis, but the couple times I've tried to dig into it, so much of it just felt like voodoo.", "id": "daf4ty2"}, {"comment": "What if we all contributed to and learned from a standard library of code with a defined routine? Then we can use a simple syntax, function(arguments) for every mathematical function.\n\nWe could combine programming classes and mathematics classes, why should they be separated?\n\nBest of all, we could have it compatible with current syntax by adding optional arguments to print the function using a certain syntax.", "id": "daeyso1"}, {"comment": "But then you'll be limiting your *notation* to things that are computable and easily expressed in code. For example, how would you code supremum/infimum? It is often helpful to separate what can be said from what can be computed. Even if all you really care about is what can be computed, non-computable concepts often serve as succinct, conceptually useful shorthand.", "id": "daeywv0"}, {"comment": "You could iterate through the provided set and find the greatest upper bound/lower bound, but I understand where you are coming from. You have a good point, not every problem is computable.", "id": "daez0dv"}, {"comment": "> You'd could iterate through the provided set and find the greatest upper bound/lower bound\n\nHow do you iterate over an uncountable set? You can't even define what iteration means for such a set. Some mathematicians may claim that philosophically such sets don't even \"exist\". But I think that 1. such philosophical debates should be kept out of the notation, and 2. most people would agree that pretending such sets exist makes for simpler math.", "id": "daez5ky"}, {"comment": "> Some mathematicians may claim that philosophically such sets don't even \"exist\"\n\nwut?", "id": "daf2g1k"}, {"comment": "https://en.wikipedia.org/wiki/Intuitionism#Intuitionism_and_infinity", "id": "daf2q2i"}, {"comment": "That is philosophy, not math.\n\nIn mathematics uncountable sets are very real (get it? because the set of real numbers is uncountable, get it?).", "id": "daf3245"}, {"comment": "Well, some mathematicians would disagree. But you're right that this is more the realm of logicians, who are on the border between math and philosophy.", "id": "daf3f7n"}, {"comment": "No, they would not, if you take ZFC you get uncountable sets, there's no agree or disagree. If you take different axioms you get different stuff of course.", "id": "daf3lr4"}, {"comment": "It's a legitimate branch of maths. Not one I have much time for myself, but all they're really doing is using a slightly different set of axioms than the usual ZFC for their proofs.\n\nMaybe just dropping C; maybe the axiom of infinity too; sometimes even reformulating the whole thing in terms of computability.\n\nGetting into which one should be preferred is probably philosophy, but that doesn't affect the actual proofs of either school.", "id": "daf3qh0"}, {"comment": "Ok, but saying that something doesn't exist and saying that there are axiomatic systems where that something doesn't exist are pretty different things.\n\n> Getting into which one should be preferred is probably philosophy\n\nWhy? It's a matter of what one wants to study, there is no right or wrong.", "id": "daf40fc"}, {"comment": "[deleted]", "id": "daf2na8"}, {"comment": "That works if the set is infinite but countable. I asked for uncountable.", "id": "daf2pq0"}, {"comment": "Why does it have to be countable? If your for loop allows for non-deterministic order of iteration, it doesn't have to countable.", "id": "dafjj5a"}, {"comment": "Because part of writing your algorithm for supremum/infimum must be comparing items to each other. Its unclear how a for loop can express this for uncountable sets even if you allow non-determinism, but maybe I am just not thinking about it the right way?", "id": "dafq7si"}, {"comment": "Whatever order you iterate, that order creates a mapping from the natural numbers (the first number you iterate, the second, etc.; you can think of it as incrementing a counter in every iteration), and an onto mapping from the natural numbers to uncountable sets simply does not exist. For countable sets, you know that eventually you'd reach every element, but in an uncountable set, you'd never reach most elements even in infinite time. Some definitions in math, even simple ones, cannot be described as an algorithm (in the Turing-computable sense, unless we expand the notion of an algorithm to take the operations that describe every axiom in set theory -- like selection, union, choice, comprehension etc. -- to be primitive operations). Even seemingly simple definitions like \"pick an irrational number in the interval `(0, 1)`\" -- which is doable according to the axiom of choice -- cannot be described algorithmically, because it would take you an infinite amount of time to say which number it is that you picked.", "id": "dag2lxp"}, {"comment": "Well, ok then imageine that not as a traditional for loop but as a function mapping,  i.e. everything happens in parallel with no defined order on uncountably infinite processors. In functional programming that's a common construct (map).", "id": "dag34j3"}, {"comment": "It needn't be uncountable, e.g. find the upper bound of the identity function over the natural numbers", "id": "daf2yu4"}, {"comment": "But the set of natural numbers doesn't have an upper bound. The set {x \u2208 \u211d| 0 \u2264 x^2 < 2} does.", "id": "daf3gjz"}, {"comment": "So what?", "id": "daf3jxp"}, {"comment": "And how would that work for `y=(0,1)` (the set of real numbers >0 and <1)? What would it even mean? What is the first value that x would take?", "id": "daf48np"}, {"comment": "Clearly you need to iterate over [0,1], but skip the first and last element", "id": "daf53wu"}, {"comment": "Oh, right! 'How to iterate over arbitrary sets using this one weird trick'", "id": "daf5fax"}, {"comment": "\"What mathematicians do not want you to know\"", "id": "daf5ois"}], [{"comment": "I really need to step up my maths game.", "id": "daezaui"}], [{"comment": "His definition of the expected value is just a special case of a more general case:\n\n    E[f(X)] = \\sum_{i=1}^{\\infty} f(x_i) p(x_i)\n\nwhere f(x) = x.\n\nWith this general definition, the ambiguity goes away.", "id": "daezh83"}], [{"comment": "I'm going to disagree with the author. Mathematical notation does have some disadvantageds, but it is very good at what it does. Mathematical notation is very precise and concise. To achieve those goals it sacrifices detail, leaving a lot of essential information out, counting on the reader's knowledge of the notation to explain the meaning. It allows people to easily manipulate the formulas, while still having all the essential information. The existence of Wolfram alpha is proof that the language is precise enough to allow a computer to solve problems.\n\nThe main disadvantage that I see is that mathematical notation requires a huge amount of knowledge to use properly. It's closer to a natural language than a computer language. I see students get tripped up all the time on simple problems because they don't understand the meaning of things. However, I believe that trade-off is worth it. Not everyone needs a very strong background in math, but those that do have the background will find that putting in the work to understand the meaning of the notation makes future problems easier.", "id": "daf23yn"}, {"comment": "You missed the complaints about inconsistent notation. You might be forgiven for that because it's below the fold.", "id": "daf8ks9"}, {"comment": "The thing is, all language is \"inconsistent\". Even programming languages perform entirely different actions for addition depending on the type of the data. The reason is because requiring a different symbol for every single thing would cause just as many problems and requiring rules for how to interpret the symbols.\n\nThings like sin^-1 not being 1/sin are explained with very logical and consistent rules, like when you have a function ^-1 means the inverse. Sin is a function, so it obeys those rules. Just like Java will perform string concatination or addiction depending on the type of data.\n\nHaving a language that is context sensitive is a useful tool when used properly and fully understood. There are no ambiguities in mathematical notation. Only bad explanations from teachers, missing knowledge, or individuals that don't understand the meaning.", "id": "dag40kl"}, {"comment": "> Even programming languages perform entirely different actions for addition depending on the type of the data.\n\nJava doesn't let you override any operators specifically to protect people reading code from this problem. People develop IDEs that make it easy to navigate from use to declaration specifically because it's not always easy to grep by method name. We have type systems in part to make that practical.\n\nThat doesn't exist in math.\n\n> context sensitive\n\n> no ambiguities\n\nIf you're lacking some of the context, it's ambiguous. It's like seeing a snippet of java:\n\n    a.add(b);\n\nAre those bignums added together? Is `a` a collection and `b` an element appended to it?\n\nThis is a big reason that it's considered good practice to use descriptive variable names -- it reduces the amount of context you need. In math, it's preferred to give every variable a single-character name that has no relation to its meaning.\n\n> Only bad explanations from teachers, missing knowledge, or individuals that don't understand the meaning.\n\nWhich are quite common in practice. Less ambiguity, less context sensitivity, and more descriptive naming would give people a better chance to overcome those problems.", "id": "dagf39h"}], [{"comment": "Don't really see a problem with context dependent operators based on argument types, it's usually due to the operators being analogous, and I like it in my programming as well.\n\nSure, if you don't know what type you have, you won't know the operator, but that's your problem right there, you should know what type you have.\n\nNow of course, having both *, \u22c5, \u00d7 etc for the same operator is just silly, but probably a lost cause to try and fix.\n\nAs for the ^X ^/ ^p(x i^) ,  example, it sucks that common sense is required to figure it out, but they did actually give you the hint that you couldn't treat it as a regular function by using [] instead of (). A bit lazy though to not have properly defined \"split in infinitesimal pieces and apply to each piece\" operators.", "id": "daf9d1t"}, {"comment": "How is type information supposed to help me me identify that in the specific case of trigonometric functions on the left side and positive numbers on the right side, the ^ operator has been overloaded to mean something like `f ^ 2 = (^2) . f`, when for all other functions of identical type it means `f ^ 2 = f . f`?\n\nIts not even like mathematical notation usually specifies what type anything is anyways: it just provides some implicit context that you have to work out some of the types from, and then hopefully work from there. Often, its based on conventions like \"these letters usually mean a variable has this purpose\".\n\nIts as if programmers wrote a function to sum numbers like \"sum = for r += i\". Whats the for looping over? The input of course. Whats returned? r, duh. What does r start out as? 0, obviously. What is the iteration variable? Everyone knows thats i. See, its better then normal code cause its \"more dense\".", "id": "dafr5fs"}], [{"comment": "\"applied mathematician\". what the fuck, revoke his diploma.", "id": "daffonp"}], [{"comment": "\\>fursona\n\nopinion discarded", "id": "daf2h5f"}], [{"comment": "Expectation is not a function in the elementary sense, it's an operator. It operates on a function to produce a new function. The brackets are a pretty good suggestion you can't expect it to work as if it were plug and chug, imo.", "id": "daf7lcv"}], [{"comment": "Awful indeed, yet OpenMath still did not deliver an alternative.", "id": "daexkyt"}]]], "4k6aaa": ["The promise of static typing", "2016-05-20 07:07:49", 20, "http://labs.ig.com/static-typing-promise", [[96, "I don't think \"fewer bugs\" is the (only/full) promise of static type checkers; to me, it isn't even the most important reason to use a statically-typed language.\n\nWhat it really boils down to, IMO, is the Assumption Metalanguage Problem. Let me explain.\n\nWhen we write code, we write for multiple recipients at once: we write code for the computer to execute, the main objective being that the code does what we want it to do, with reasonable performance. We write code for future readers, the objective being that the code accurately describes our intent. And we write code for ourselves, the objective being that we cannot keep the entire logic of a complex application in our heads at once, so we need to write things down, so that we can quickly come back to it later when we want to reason about it.\n\nProgramming languages themselves generally solve the first objective (talking to computers) very well; it is usually the first, sometimes the only, concern in programming language design. The second one (talking to future readers) has received increasing attention in the past years, and programming languages have gotten a bit better at it, although the main weapon here is still documentation and best practices (i.e., using existing language features better, rather than adding language features). The third one, however, using the code as a brain dump and optimizing it to keep the required working memory on the programmer's side small, is often forgotten about, and seldom mentioned explicitly - yet it is a huge factor to productivity and quality.\n\nIn order to efficiently use code as a brain dump, we need an assumption metalanguage: that is, a language in which we can formulate assumptions about and properties of the code that it accompanies, such that a trained programmer can effortlessly read and write them, and reliably check them against the code. As an example, when I write this code:\n\n    def blah(foo):\n        return bar(foo)\n\n...I am making some assumptions:\n\n- The first argument to `blah` must be of a type that is also a valid argument to `bar`\n- If `blah` returns a value, it is of the same type as what `bar` returns\n\n...and maybe more, e.g.:\n\n- Both `bar` and `blah` are pure, that is, they have no side effects\n- `foo` must be a number\n- `blah` returns a value of the same type as its argument\n- ...\n\nTraditionally, such assumptions are written down as comments, but they become more useful when at least *some* of the verification (\"does the code match my assumptions\") is automated. Asserts, early failures, unit tests, etc., are all ways of doing that, moving the assumptions from free-form documentation into the realm of the programming language itself; however, this can become cumbersome, and a fully expressive set of asserts or unit tests is often not very good at expressing the intended assumptions in a readable way at all. A formal declarative metalanguage can often fill the gap, expressing the above constraints in a concise, well-defined way that is reasonably easy to understand for humans and computers alike.\n\nAnd that's where I see the added value of static type systems: not directly preventing bugs by adding a layer of bureaucracy; but taking mental burden off of the programmer by giving them an expressive metalanguage that covers about 90% of the assumptions that you want to express, thus making the code easier to reason about, and making sure that the programmer's assumptions actually hold.\n\nThe crux here is that in order to reap maximum benefits from such a type system, it has to be powerful and mandatory - if it's opt-in, then the guarantees we can get are much weaker, to the point of not being worth it, and the thing does indeed get reduced to a half-useful replacement for lousy unit tests; if it's not expressive enough, then the restrictions it puts on what you can write make coding a Kafkaesque experience."], [72, "> compare the number of issues labelled \"bug\" versus the number of repositories in GitHub for different languages\n\nAwful measurement. For fuck's sake, reddit's  anecdotes are more scientific than that."], [48, "Even if we do accept his argument that programs written in simpler languages have less bugs, it kind of begs the question, are simple languages better or just used for simpler tasks?"], [43, "The approach seems flawed to me, because it doesn't take project size/complexity into consideration at all. Let's assume you have 10 Ruby projects with 100 lines of code each, and 1 C++ project with 100k lines of code, then you should certainly expect more \"bugs per project\" in C++."], [19, "I would say that the definition of 'simple' there isn't quite right: rather, the yardstick of simplicity how hard is it to express what you want to say in the language.\n\nBy this yardstick, Go isn't terribly simple: expressing something like \"a heap of any ordered type\" is not (AFAIK) possible at all, let alone merely hard.  In C, it's merely hard: you've got to figure out some way to represent orderings, which probably means passing around function pointers or similar.\n\nDynamic languages are Rich Hickey's \"easy.\"  You don't have to think about types.  But it's not simple, because the lack of types means your program will fail at runtime.\n\nUncle Bob's notion that tests are equivalent to static types is barmy, for two reasons.  The first is that tests are for behaviour, while types are for structure - you use types as a means to provide shapes to your plugs and sockets, so you don't do this:\n\nhttps://pbs.twimg.com/media/B3Fvg-sCYAAkLSV.jpg:large\n\nThe second is that tests are _existential_.  There exists some set of examples for which the behaviour is correct.  Types are _universal_.  For all ways in which functions are plugged together, they fit.\n\nI think we'll see the opposite trend: better type systems with more expressiveness leading to simpler implementations of ideas.  Further, I expect over the next few decades we'll see a greater rise in the use of theorem assistants, which do give a universal qualifier over behaviour, as the convergence of functional programming, type systems, and formal methods continues."], [19, "Just for fun, I looked at the most starred repos in C++ (most bugs in repose with > 100 stars)  and Clojure (least bugs) in github\n\nhttps://github.com/search?l=&o=desc&q=language%3AC%2B%2B+stars%3A%3E100&ref=advsearch&s=stars&type=Repositories&utf8=%E2%9C%93\n\nhttps://github.com/search?o=desc&q=language%3AClojure+stars%3A%3E100&ref=searchresults&s=stars&type=Repositories&utf8=%E2%9C%93\n\nHere are the top 10 C++ repos\n\n1. Swift\n2. Electron (Used to be Atom Shell - source code includes chromium)\n3. nw.js - Way to write desktop apps using node.js\n4. tensorflow - Google's distributed machine learning loolkit\n5. rethinkdb\n6. hhvm - Facebook's VM for executing programs in Hack and PHP\n7. textmate\n8. caffe - Deep learning framework\n9. opencv - Computer vision\n10. Mongo\n\n\nHere are the top 10 Clojure repos\n\n1. LightTable - an IDE\n2. clojurescript - Clojure to JS compiler\n3. om - Clojurescript interface to Facebook's React\n4. FiraCode - Monospaced font with programming ligatures\n5. Leiningen - Clojure build system\n6. overtone - Collaborative Programmable Mused\n7. compojure - routing library\n8. riemann - network event stream processsing system\n9. metabase - some sort of data query and visualization system\n10. clojure-koans\n\n\nThere is a vast difference in both the complexity of the projects, and the production usage. Many of the C++ projects are used in production code by major companies and so bugs will aggressively get found/reported/fixed.\n"], [15, "Wow this article is completely worthless. He seriously based his argument on the number of commit messages containing the word \"bug\"? Those are some olympic level mental gymnastics.\n\nIf this is the best argument for dynamically typed languages then they lost the argument by default."], [14, "Ruby, JavaScript and Python are all pretty similar languages. And they're all over the place in these graphs. If the \"simple languages\" hypothesis is correct I don't see why Ruby and Python would end up so differently.\n\nThere are large confounding factors that have to do with culture: perhaps Ruby people star projects more eagerly on Github, and less used projects end up with more stars. Perhaps Java projects attract a lot of bug *reports* but don't actually have more bugs as they're duplicates or mistakes. Perhaps Clojure developers are less likely to leave a mistaken bug report. I don't know whether any of these in particular are true, but it's plausible that some stuff like that is going on.\n"], [12, "Wow. This is terrible. A shallow and naive comparison of the number of bugs in select GitHub projects. I'm not sure what conclusions can be drawn from these charts, given that there was no attempt to control for things like project size, project complexity, project popularity, project domain, project age, bug type, etc. Then there are the 'soft' / hard-to-quantify benefits like maintainability .. "], [11, "In theory, I agree with the notion that a simpler language will lead to less bugs; I mean, the easier it is to reason about your code, the easier it will be to squash bugs before they pop up.\n\nStill, I think the metric used here doesn't show the whole picture. Project complexity, for example, is not a factor. Could be some languages are used for simpler projects. Obviously some projects could have unreported bugs as well, but that's just conjecture."], [9, "So, is Python more complicated than Haskell and Scala? \n\nOr is there anything special in Python that makes seemingly simple language so buggy?"], [7, "> I was quite surprised at a recent blog post by Uncle Bob Martin, titled: \"Type Wars\", in which he writes: \"Therefore, I predict, that as Test Driven Development becomes ever more accepted as a necessary professional discipline, dynamic languages will become the preferred languages. The Smalltalkers will, eventually, win.\"\n\nThe problem with this claim is if you are using your test system to enforce types then suddenly you have a lot more test code. They are not comparable."], [9, "Dumb logic. Ignoring all the other problems in the design of his \"experiment\", it is a flawed premise to begin with that safer languages result in code with less bugs. This is like thinking that more roads must result in less congestion or that better engines must lead to lower aggregate fuel consumption.\n\nThe characteristics of languages like C++ and Java directly affect which tasks they are chosen for. The low bugcount of Golang may simply indicate that it is being used for simpler projects."], [5, "Many commenters have already commented on the methodology: simply put, there are too many variables that are not taken into account in his study.  For example, some projects consider that errors in the documentation is a bug and would probably use the \"bug\" tag for such an issue, while another project could tag it under \"documentation\".  Clearly this has nothing to do with type systems or testing, and can skew the results.\n\nThe other problem I have is his conclusion: simple language implies less bugs.  Taking this argument to its logical extreme, it stands that Lambda Calculus and Turing Machines would be the languages where people write programs with the least bug.  The reality --- as most people who took a theory of computation class in school know --- is that writing even the most trivial programs in LC or TM is extremely hard."], [4, "[deleted]"], [4, "Dynamic typing zealots are getting visibly desperate."], [2, "It promise me better tooling and IDE integration...it delivered."], [2, "I did something similar recently. I tried to score each language for safety, then use the github data to see if it correlates. http://deliberate-software.com/safety-rank-part-2/"], [1, "Someone should test with TypeScript vs JavaScript or even better TypeScript vs Babel-transpiled projects since the languages and the communities are otherwise equal."], [1, "Really proud of Clojure's numbers here. :-)"], [1, "It's interesting that nearly all of his \"good properties of simple languages\" apply to Haskell, the exceptions being \"No complex type system\" and \"Not academic\" (which both sound like advantages to me...)."], [1, "C++ being first by a long lead has nothing to do with static typing, and everything to do with C++ being a pile of crap."], [1, "There are so many proponents of static typing it this thread, and they all raise good points. \n\nHere's the problem: in virtually every language (other than maybe Haskell) you can trample all over the type system, and usually will if your project reaches a certain complexity. C users end up with data type tags, void pointers thrown around everywhere, and function pointers to operate on everything. C++ users end up with template hell. Java users end up with a set of abstractions that becomes too large to fit in the mind. Basically, everyone is hacking dynamic typing into their language and saying \"look how great static typing is!\" \n\nThe situation gets worse when I have a service based architecture. Gee, it's great that I have this sweet Haskell micro-service architecture. Maybe my type system even lets me make cool guarantees about the accuracy of my services. But then I chain them all together, and I basically end up with an object model, and all my guarantees fall out the window. Meanwhile, my simple service was never the source of the bugs; I can completely understand a 500 line file. \n\nI'm not saying dynamic typing is **better** than static typing -- I'm saying its not really better or worse. Different situations will definitely have different results. Usually, the result of bugs comes from poor architecture: a lack of orthogonality and modules bleeding information into each other. If there are simple and clean interfaces with few entry points, then it's easy to reason about the data exchanges between different components and be convinced of their correctness without the additional mental burden of a type system. \n\nEDIT: adding this. I have a rather low opinion of the dynamically typed object-oriented languages. They combine the problems associated with OOP and lack any form of annotation or guarantees for the developer to read with. A language like Clojure, on the other hand, is free from the burden of OOP so this criticism doesn't apply. "], [0, "[deleted]"]], [[{"comment": "I don't think \"fewer bugs\" is the (only/full) promise of static type checkers; to me, it isn't even the most important reason to use a statically-typed language.\n\nWhat it really boils down to, IMO, is the Assumption Metalanguage Problem. Let me explain.\n\nWhen we write code, we write for multiple recipients at once: we write code for the computer to execute, the main objective being that the code does what we want it to do, with reasonable performance. We write code for future readers, the objective being that the code accurately describes our intent. And we write code for ourselves, the objective being that we cannot keep the entire logic of a complex application in our heads at once, so we need to write things down, so that we can quickly come back to it later when we want to reason about it.\n\nProgramming languages themselves generally solve the first objective (talking to computers) very well; it is usually the first, sometimes the only, concern in programming language design. The second one (talking to future readers) has received increasing attention in the past years, and programming languages have gotten a bit better at it, although the main weapon here is still documentation and best practices (i.e., using existing language features better, rather than adding language features). The third one, however, using the code as a brain dump and optimizing it to keep the required working memory on the programmer's side small, is often forgotten about, and seldom mentioned explicitly - yet it is a huge factor to productivity and quality.\n\nIn order to efficiently use code as a brain dump, we need an assumption metalanguage: that is, a language in which we can formulate assumptions about and properties of the code that it accompanies, such that a trained programmer can effortlessly read and write them, and reliably check them against the code. As an example, when I write this code:\n\n    def blah(foo):\n        return bar(foo)\n\n...I am making some assumptions:\n\n- The first argument to `blah` must be of a type that is also a valid argument to `bar`\n- If `blah` returns a value, it is of the same type as what `bar` returns\n\n...and maybe more, e.g.:\n\n- Both `bar` and `blah` are pure, that is, they have no side effects\n- `foo` must be a number\n- `blah` returns a value of the same type as its argument\n- ...\n\nTraditionally, such assumptions are written down as comments, but they become more useful when at least *some* of the verification (\"does the code match my assumptions\") is automated. Asserts, early failures, unit tests, etc., are all ways of doing that, moving the assumptions from free-form documentation into the realm of the programming language itself; however, this can become cumbersome, and a fully expressive set of asserts or unit tests is often not very good at expressing the intended assumptions in a readable way at all. A formal declarative metalanguage can often fill the gap, expressing the above constraints in a concise, well-defined way that is reasonably easy to understand for humans and computers alike.\n\nAnd that's where I see the added value of static type systems: not directly preventing bugs by adding a layer of bureaucracy; but taking mental burden off of the programmer by giving them an expressive metalanguage that covers about 90% of the assumptions that you want to express, thus making the code easier to reason about, and making sure that the programmer's assumptions actually hold.\n\nThe crux here is that in order to reap maximum benefits from such a type system, it has to be powerful and mandatory - if it's opt-in, then the guarantees we can get are much weaker, to the point of not being worth it, and the thing does indeed get reduced to a half-useful replacement for lousy unit tests; if it's not expressive enough, then the restrictions it puts on what you can write make coding a Kafkaesque experience.", "id": "d3cmp8l"}, {"comment": "tl;dr: typing is documentation that is used both by the developer and by the compiler for correctness", "id": "d3cq7cj"}, {"comment": "> The crux here is that in order to reap maximum benefits from such a type system, it has to be powerful and mandatory\n\nI was with you until this last paragraph. A static type system does not have to be powerful or mandatory! 75% of the benefits are reaped by what you describe as \"formalized comments,\" like \"this returns a list.\" And the remaining benefits require rapid increases in complexity to realize: we need generics, now we need higher-kinded types, now we need dependent types...\n\n> if it's opt-in, then the guarantees we can get are much weaker, to the point of not being worth it\n\nThey are worth it! Ask any Objective-C, TypeScript, Dart, etc. developer. These are languages with optional static typing.\n\nSecond, getting any guarantee out of a static type system comes at a high price: it requires that the code you type check against is the code you run against. Consider what it would mean to typecheck JavaScript. My code typechecks against Chrome; does that guarantee anything about how it will run in the previous or next version of Chrome, or IE or Safari or Firefox? Of course not.\n\n> if it's not expressive enough, then the restrictions it puts on what you can write make coding a Kafkaesque experience\n\nThis is why static type checking is at its best when it's *not* mandatory. The static type checker serves me, but if it restricts what I can express, then I'm serving it instead.", "id": "d3cqf4g"}, {"comment": "> I was with you until this last paragraph. A static type system does not have to be powerful or mandatory! 75% of the benefits are reaped by what you describe as \"formalized comments,\" like \"this returns a list.\"\n\nOnly if this is enforced statically. Otherwise you're back to documentation.\n\nBut documentation as a free benefit of static types is just one aspect of it. Type systems in powerful languages are themselves powerful languages, allowing you to express arbitrary logic in a way that is:\n\n* Formally verifiable - this is a big one. With a strong type system you get about a century of formal math and proofs for free.\n\n* Compile time logic - another big one. Since types are ideally evaluated at compile time/ statically, you can ensure that no one is writing code that doesn't make sense. This goes *far* beyond \"this takes a list\". Instead you can encode logic like \"this takes a nonempty list\" and assert that users of that function can never call the function with a nonempty list. You can encode logic far more complex than that - leveraging the type system in order to prevent memory corruption, or design flaws. All before the program runs.\n\nThe power here really can not be understated. And I think something that modern languages have proven is that the cost is trivial - type inference can be done across an entire program so it *feels* like you're not writing with types at all, until you make a mistake, and they save you.\n\nI certainly agree with the tdammers that one of the best benefits is the documentation aspect of it. I find it difficult to know what I can do with an object in Python because I only ever have the object's label and not the type.\n\nBut here's the point I want to make - you *do* need a strong type system to reap the benefits. When you make static typing optional, it's like taking a painting and bleaching spots onto it - the more holes you make in your static type system the more muddled and confusing the painting becomes. And this really bleeds into the rest of your program. The second a typed variable touches an untyped interfaces, you've got problems - all code from this point forward, typed or untyped, can only make assumptions, not guarantees.\n\n> Second, getting any guarantee out of a static type system comes at a high price: it requires that the code you type check against is the code you run against. Consider what it would mean to typecheck JavaScript. My code typechecks against Chrome; does that guarantee anything about how it will run in the previous or next version of Chrome, or IE or Safari or Firefox? Of course not.\n\nI don't understand this point. Why would Chrome or Firefox matter at the type level? Types are not even involved at runtime in a statically typed language. If your code type checks in Chrome it type checks in Firefox. Maybe it has a bug in one or the other (and you could encode the different behaviors into your type system) or some such thing but at that point you're talking about a whole other phase of the program.\n\nI think optional static typing is nice for languages that didn't have it before, I wouldn't go so far as to say it's pointless, but for those languages it's typically only good for the basic stuff - some free documentation, and linters having a bit more to go on. I simply don't agree that static type systems come at a high price. I don't see much cost at all, they're pretty trivial to use in modern languages with type inference.", "id": "d3crmac"}, {"comment": "Let's make this even more concrete: take, for example, [this  CircleCI blog post](https://circleci.com/blog/why-were-no-longer-using-core-typed/), \"Why We're No Longer Using Core.typed,\" the optionally typed dialect of Clojure. tl;dr they had a _lot_ of polymorphic map-py code they couldn't type in Core.typed and used a _lot_ of third-party libraries that weren't typed and would therefore have to type themselves (where possible given Core.typed's type system) and in any case would have to maintain themselves if the upstream vendor didn't, which was nearly always the case.\n\nBy contrast, take [Scala.js](http://www.scala-js.org/). You have the entire Scala language with a [tiny handful](http://www.scala-js.org/doc/semantics.html) of things to pay attention to vs. running on the JVM. You have a [staggering array](http://www.scala-js.org/libraries/) of libraries at your disposal, including [multiple bindings for popular JavaScript libraries](http://www.scala-js.org/libraries/facades.html) including jQuery, Angular, and React. You have [the hardcore of the hardcore](http://www.scala-js.org/libraries/libs.html) of Scala libraries, including scalaz, Shapeless, and Cats. You have whole new web application frameworks like [Udash](http://udash.io/) and [sri](https://github.com/chandu0101/sri). You have [hot reloading in your browser while building with sbt](https://github.com/lihaoyi/workbench). And you have all of this with [extremely good generated JavaScript](http://www.scala-js.org/doc/internals/performance.html).\n\nThere is simply no reason to use an \"optional\" static type system, other than, as you say, if you're starting with a language that has no type system at all. But even then, you risk having the CircleCI experience, when you could have something like the Scala.js experience.", "id": "d3cu5gn"}, {"comment": "> The power here really can not be understated. And I think something that modern languages have proven is that the cost is trivial - type inference can be done across an entire program so it feels like you're not writing with types at all, until you make a mistake, and they save you.\n\nThe power you're describing earlier (where you're essentially describing dependent types) is most definitely not free - just look at how long it takes to write a program in Coq, and how large a program has ever been written. \n\n> I don't understand this point. Why would Chrome or Firefox matter at the type level? Types are not even involved at runtime in a statically typed language. If your code type checks in Chrome it type checks in Firefox. [...]\n\nBecause the JavaScript \"standard-library\" doesn't expose the same types across different versions of different browsers (for example, `[1 2].find(1)` should be a type error in old versions of IE or Firefox - arrays didn't have a `find` function). Of course, this is a problem with JavaScript and its ecosystem, not actually related to typing.\n\n> I simply don't agree that static type systems come at a high price. I don't see much cost at all, they're pretty trivial to use in modern languages with type inference.\n\nYou should take a look at some of the standard functions in Common Lisp (usually a very nice, time-tested example of how to really use the power of a dynamic language) to understand how hard it would be to type check them, and how byzantine the type system would have to be. Take a look for example at [`map`](http://www.lispworks.com/documentation/HyperSpec/Body/f_map.htm#map). How many functions would you normally add to you API to achieve this in, say Haskell, or OCaml?", "id": "d3czhom"}, {"comment": "> Take a look for example at map. How many functions would you normally add to you API to achieve this in, say Haskell, or OCaml?\n\nEither 2 functions or n functions.\n\nedit:\n\nEither you explicitly defined\n\n    zipWith :: (a->b->c) -> [a] -> [b] -> [c]\n    zipWith3 :: (a->b->c->d) -> [a] -> [b] -> [c] -> [d]\n    ...\n\nOr you just define\n\n    <$> :: (a -> b) -> [a] -> [b]\n    <*> :: [a -> b] -> [a] -> [b]\n\nand say something like\n\n    f <$> xs <*> ys <*> zs <*> ...\n\nThis works via currying and partial application: since (a -> b -> c) == (a -> (b -> c), `f <$> xs` will give you back a [b -> c] that you can then pass to <*>.\n\nIn Haskell, <$> and <*> are actually part of the Applicative typeclass.  For reasons of consistency with another part of the standard library, the Applicative instance for lists actually does a Cartesian product of the lists:\n\n    Prelude> (,) <$> [1..3] <*> [1..3]\n      [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]\n\nand in order to get it to zip the lists together you need to use the ZipList newtype wrapper:\n\n    Prelude> (*) <$> ZipList [1..3] <*> ZipList [1..3]\n      ZipList {getZipList = [(1,1),(2,2),(3,3)]}\n\nIt's a pretty general pattern, though.  For example, in order to define FromJson instances for the JSON parsing library aeson, you can say\n\n    data Coord = Coord { x :: Double, y :: Double, z :: Double }\n\n    instance FromJSON Coord where\n      parseJSON (Object v) = Coord    <$>\n                             v .: \"x\" <*> \n                             v .: \"y\" <*>\n                             v .: \"z\"", "id": "d3d2uy2"}, {"comment": "> The power you're describing earlier (where you're essentially describing dependent types) is most definitely not free - just look at how long it takes to write a program in Coq, and how large a program has ever been written.\n> \n\nIf one is simply interested in a non-empty list (which is what I understand from /u/staticassert's comment) rather than knowing its length statically, dependent types aren't needed:\n\n    (* OCaml syntax *)\n    type 'a non_empty_list = 'a * 'a list\n\nRicher type systems are harder to use, but let's not throw the baby with the bathwater: the invariants that you can state using an ML-like type system are useful and don't impose a very high cost in your code.", "id": "d3d26fl"}, {"comment": "True, I extrapolated a bit from the non-empty list example, which I probably shouldn't have.\n\nStill, my second example (Common Lisp's `map`) is something I still think would be very difficult/impossible to express as simply in an ML-like language; even if you could, you could still fail with a runtime type-error if the function arity doesn't match the number of lists provided, unless you move to dependent types.\n\nOf course, you could argue that you wouldn't want to express this kind of code, that having multiple functions with more expressible types would be cleaner etc. Still, a relatively experienced community may disagree with you, and in any case, it's an example of a perfectly correct useful program (not some contrived example) that can't even be done in most strongly-typed languages - proof by example that there is non-trivial cost to static typing.", "id": "d3d2u4o"}, {"comment": "> Still, my second example (Common Lisp's map) is something I still think would be very difficult/impossible to express as simply in an ML-like language; even if you could, you could still fail with a runtime type-error if the function arity doesn't match the number of lists provided, unless you move to dependent types.\n\nOleg Kiselyov has a [good page on polyvariadic functions in ML-like languages](http://okmij.org/ftp/Haskell/polyvariadic.html), which includes an implementation of \"the double-generic zipWith -- generic in the number of arguments and in the sort of the collections\".  It's not exactly simple, though, although it does statically check the arities.\n\nAs I mentioned in my other post, though, if you're willing to split map up into 2 binary functions that you use to combine all the arguments, you can solve this pretty simply.", "id": "d3d4ygn"}, {"comment": "> Take a look for example at map. How many functions would you normally add to you API to achieve this in, say Haskell, or OCaml?\n\nTwo. Use an `Applicative` instance.", "id": "d3e4tpc"}, {"comment": "> \nThe power you're describing earlier (where you're essentially describing dependent types) is most definitely not free - just look at how long it takes to write a program in Coq, and how large a program has ever been written.\n\nYou definitely don't need Coq to get that type of validation. You can simply have an Empty and NonEmpty list type, or you can have typed variants, or likely many other ways of doing it that end up invisible to the consumer.\n\n> Because the JavaScript \"standard-library\" doesn't expose the same types across different versions of different browsers (for example, [1 2].find(1) should be a type error in old versions of IE or Firefox - arrays didn't have a find function). Of course, this is a problem with JavaScript and its ecosystem, not actually related to typing.\n\nHuh, yeah I guess I just don't consider this an issue with type systems and really just a sort of nutty issue with Javascript.\n\n> Take a look for example at map. How many functions would you normally add to you API to achieve this in, say Haskell, or OCaml?\n\nUnfortunately, I'm entirely unfamiliar with Lisp (and at work so I don't want to spend too much time digging into it :( sorry) so I couldn't comment here. But this just looks like any old 'map', which Haskell and OCaml have very short, elegant syntax for. Perhaps I'm missing something, I only glanced.", "id": "d3d4wl4"}, {"comment": "> But this just looks like any old 'map', which Haskell and OCaml have very short, elegant syntax for. Perhaps I'm missing something, I only glanced.\n\nLisp's map is variadic:  you can say `(map f xs ys ... zs)` and it Just Works.  Defining variadic functions in Haskell or OCaml, on the other hand, is a bit tricky.  The standard approach in Haskell is to take advantage of currying and use binary functions (usually defined as operators so you get nice infix syntax) that partially apply the arguments one at a time: `f <$> xs <*> ys <*> ... <*> zs`.", "id": "d3d5972"}, {"comment": "> You definitely don't need Coq to get that type of validation. You can simply have an Empty and NonEmpty list type, or you can have typed variants, or likely many other ways of doing it that end up invisible to the consumer.\n\nYou're right, I jumped a little too far there.\n\n> Unfortunately, I'm entirely unfamiliar with Lisp so I couldn't comment here. But this just looks like any old 'map', which Haskell and OCaml have very short, elegant syntax for.\n\nIt's not the same - it's essentially a generalization of their `map` from taking a unary function and 1 list and returning another list to taking an N-ary function and N lists and returning any sub-type of list you specify (e.g. a string).", "id": "d3d5fw4"}, {"comment": "> Because the JavaScript \"standard-library\" doesn't expose the same types across different versions of different browsers  (for example, `[1 2].find(1)` should be a type error in old versions of IE or Firefox - arrays didn't have a find function).\n\nWhy do you call this a type error?  It's just an undefined identifier error.  ML/Haskell can give you the same sort of error if you have newer code and try to compile it against older libraries.\n\nA type error is when:\n\n1. You have an expression of type `t0`;\n2. Appearing in a context of type `t1`;\n3. And the types `t0` and `t1` are not compatible.\n\nBut if you have an undefined name, there are no types to compare!\n\n> You should take a look at some of the standard functions in Common Lisp (usually a very nice, time-tested example of how to really use the power of a dynamic language) to understand how hard it would be to type check them, and how byzantine the type system would have to be. Take a look for example at map. How many functions would you normally add to you API to achieve this in, say Haskell, or OCaml?\n\n[The minimal answer is two.](https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Applicative.html)  Oh, and while I'm at it: \n\n* https://hackage.haskell.org/package/semigroups-0.18.1/docs/Data-List-NonEmpty.html", "id": "d3da8s8"}, {"comment": "> Why do you call this a type error?  \n\n\n1. You have an expression of type `array`;\n2. Appearing in a context of type `things that implement find`;\n3. And the types `array` and `things that implement find` are not compatible.\n\n", "id": "d3djt9p"}, {"comment": ">They are worth it! Ask any Objective-C, TypeScript, Dart, etc. developer. These are languages with optional static typing.\n\nWhat's the worth? In a non-optionally typed system you can mark everything as an 'Object' and you'll get 95% of the 'benefits' of an optionally typed system. So is the worth, that you save a few characters? \n\n>My code typechecks against Chrome; does that guarantee anything about how it will run in the previous or next version of Chrome, or IE or Safari or Firefox? Of course not\n\nWhat are you talking about? This makes no sense. Regardless, a dynamic type will not give you those guarantees either, you'll just get to find out about it at runtime.\n\n>The static type checker serves me, but if it restricts what I can express\n\nLike what?", "id": "d3cu2ud"}, {"comment": "> In a non-optionally typed system you can mark everything as an 'Object' and you'll get 95% of the 'benefits' of an optionally typed system. \n\nDepends on your optional static typing, but a good optionally typed language does at least some type inference. TypeScript as an example will infer quite a few types from plain old javascript, you don't get that with required typing and object.\n\n> > if it restricts what I can express\n> \n> Like what?\n\nMost type system will restrict a lot of what you can express. As a basic and common example `Matrix<T>` is a generic type that can't be expressed in a lot of languages, because you can't limit `T` to say support only classes that support certain operations. \n\nYou can definitely fix those with better type systems, but the point is optional typing means that when your type system fails to be expressive enough the user has an out and can still write their code.", "id": "d3cwcs3"}, {"comment": "> but a good optionally typed language does at least some type inference\n\nType interference is great. But we're not talking about type inference and type inference is no help to you in dynamically typed languages. \n\nI should be clear, I don't really have a problem with optionally typed languages - it's the non-typed programming languages that are a problem.\n\n> but the point is optional typing means that when your type system fails to be expressive enough the user has an out and can still write their code\n\nAgain, give me an example, because in every mainstream strongly-typed language, you can fallback on generic objects and explicit casting. And yeah if you do that you don't have compiler support, but then you're in the same place as you would had you been programming in a dynamically typed language. \n\n>As a basic and common example Matrix<T> is a generic type that can't be expressed in a lot of languages, because you can't limit T to say support only classes that support certain operations.\n\nCan you elaborate? Are you saying that you want Matrix<T> to be more expressive than bounding T like \"Matrix<T extends Number>\" (java example)? If so, you can bound it to any type or Object. No you usually don't get DuckTyping for free but you don't want it anyway.\n", "id": "d3cxm1l"}, {"comment": "> > but the point is optional typing means that when your type system fails to be expressive enough the user has an out and can still write their code\n\n> Again, give me an example, because in every mainstream strongly-typed language, you can fallback on generic objects and explicit casting. And yeah if you do that you don't have compiler support, but then you're in the same place as you would had you been programming in a dynamically typed language.\n\nYes. Even statically typed systems with restricted type systems are an improvement over dynamically typed languages in what you can express and prove with them.\n\n", "id": "d3cyod1"}, {"comment": "> Again, give me an example,\n\nGave you one.\n\n> Can you elaborate?\n\n`Matrix<T>`  can't work with any type that isn't object in many languages (C# in particular, java is likely the same, but as I don't work very in depth with it I could be wrong). You can't create a meaningful `Matrix` generic class that can be used to instatiate `Matrix<int>` or `Matrix<float>`. Yes you can resort to case by case hacks, but even just casting to object and running `+` wouldn't work (operators are resolved at compile time, not runtime). You'll end up with code that looks like\n\n    if (typeof(T) == typeof(int))\n    {\n        result = (int)a + (int)b;\n    }\n    else if (typeof(T) == typeof(short))\n    {\n        result = (short)a + (short)b;\n    }\n\nBut that doesn't handle custom types (like `Vector`) so then you have to resort to reflection that searches the type for the definition of that operand and applies it. That code will be extremely nasty and won't work on something like mobile, so yeah you actually can't represent it. You end up having to have a wrapper around the value types and an interface that has `Add` on it. \n\nSince dynamic was introduced this might be possible with that, but I don't know how dynamic works with operands so you'd have to test it (and do lots and lots of very nasty casting). But before dynamic you couldn't even do it.\n\nNow this is easily solved with structural types (specifically structural interfaces) but even if the language didn't support it, at least with optional typing you can just write the code anyways and it'll work, if not type check.", "id": "d3czns3"}, {"comment": "Some type systems have limitations, but the take-away is not to dump the type system. In your example, you may not able to specify a generic version of Matrix that can work with primitive types. Sucks, but not the worst thing. You'll simply have to define an API that explicitly specifies the types it expects. Oh well, still better than nothing.\n\n>You end up having to have a wrapper around the value types and an interface that has Add on it.\n\nThis specific concern seems to be on the benefits of operator overloading which is not universally supported by typed or untyped programming languages. So dynamic typing isn't going to save you there.\n\n>Since dynamic was introduced this might be possible with that ...\n\nNo. That has nothing to do with it. ", "id": "d3d3zg4"}, {"comment": "It's not really around operator overloading, I just picked that because that was a common sealed type with common method names. It's any two classes that contain `Foo`. You can't generalize on them unless the author implemented an interface for them. \n\nThis example is not about static vs dynamic typing (it's about structural vs nominal) but the point is that type systems aren't perfect and it can be very difficult to get it right, and since you can easily circumvent the type system in a dynamic language it's easier to write code that goes against your type system.\n\n> No. That has nothing to do with it.\n\nI was curious so I fired up linqpad. Seems you're wrong:\n\n    void Main()\n    {\n    \tvar a = new Vector2D<int> { X = 1, Y = 1 };\n    \tvar b = new Vector2D<int> { X = 1, Y = 3 };\n    \tvar c = new Vector2D<double> { X = 0.5, Y = 0.1};\n    \ta.Add(b).Dump();\n    \tc.Add(b).Dump();\n\ta.Add(c).Dump();\n    }\n    \n    // Define other methods and classes here\n    class Vector2D<T>\n    {\n    \tpublic T X { get; set; }\n    \tpublic T Y { get; set; }\n    \tpublic Vector2D<T> Add<S>(Vector2D<S> other)\n    \t{\n    \t\tvar result = new Vector2D<T>();\n    \t\tresult.X = (T)((dynamic)X+(dynamic)other.X);\n    \t\tresult.Y = (T)((dynamic)Y+(dynamic)other.Y);\n    \t\treturn result;\n    \t}\n    }\n\nThis compiles and produces the exact output you would expect (2,4) and (1.5,3.1), (1,1). It's less safe but it works and doesn't require any nasty reflection. So yeah looks like optional typing helped us out great here :)", "id": "d3dbp7t"}, {"comment": "From earlier comment:\n\n> > > Most type system will restrict a lot of what you can express. As a basic and common example `Matrix<T>` is a generic type that can't be expressed in a lot of languages, because you can't limit `T` to say support only classes that support certain operations.\n\nThere's several problems with this argument.  First, you can always shoot down *any* mechanism like static types by judging it by its *worst* examples.  This isn't a good argument, because we could just turn around and judge dynamically typed languages likewise\u2014by PHP or Javascript and not, say, Lisp, Python or Ruby.\n\nSecond, your statement that such languages cannot limit `T` to only classes that support certain operations *presupposes* that they *can* express the generic type `Matrix<T>` that doesn't have that restriction.  But you start this statement by denying that.  Doesn't make sense.\n\nThird: thinking about generically typed languages that I know, I can more easily list languages that *allow* you to do this than cannot.  Just two examples:\n\n1. Java: `List<? extends Comparable>` limits the element types to instances of the `Comparable` interface.\n2. Haskell: `Ord a => [a]` is the rough equivalent of the same Java type.\n\n> `Matrix<T>` can't work with any type that isn't object in many languages (C# in particular, java is likely the same, but as I don't work very in depth with it I could be wrong). You can't create a meaningful `Matrix` generic class that can be used to instatiate `Matrix<int>` or `Matrix<float>`.\n\nThis is a limitation of the languages, not of type systems.  If anything, this is an *advantage* of a static type system, because it's forbidding you from compiling code that the language could not possibly execute.  Having a static type system or generics doesn't magically make it possible for the language to carry out operations that it couldn't without the type system!", "id": "d3dbp3k"}, {"comment": "1. That's kinda the point. Type systems are difficult. Which is why providing some bailout mechanism for when you are confident what you are doing works, the compiler just can't verify it, is handy to have. You may choose to do safety over ease of development, but then I hope you are using nominal types to the fullest and never have `string name` in your code.\n\n2. I don't think it presupposes that at all. My point is merely that you can't make a generic matrix (or vector) class.\n\n3. That's `Comparable`, which means you'll only be able to use the comparison operators. Can't do much with matrices if you are only allowed to compare the elements. Haskell would work here because haskell has structural typing (at least with type inference), but AFAIK java does not. You can limit the type to certain nominal types yes, but then you can only use those nominal types, and not the other common members. Union types would also solve this, so haskell is golden, but java and many other languages aren't.\n\n> This is a limitation of the languages, not of type systems.\n\nI think you are confusing static vs dynamic typing with type systems. Type systems are the rules for what can and cannot be expressed and are separate from whether those rules are enforced at compile or runtime. \n\n> because it's forbidding you from compiling code that the language could not possibly execute.\n\nNot at all. The code could run perfectly fine, the compiler just can't tell. Here's an example of the generic matrix class using the type system bailout dynamic type in C#\n\n    void Main()\n    {\n    \tvar a = new Vector2D<int> { X = 1, Y = 1 };\n    \tvar b = new Vector2D<int> { X = 1, Y = 3 };\n    \tvar c = new Vector2D<double> { X = 0.5, Y = 0.1};\n    \ta.Add(b).Dump();\n    \tc.Add(b).Dump();\n    \ta.Add(c).Dump();\n    }\n    \n    // Define other methods and classes here\n    class Vector2D<T>\n    {\n    \tpublic T X { get; set; }\n    \tpublic T Y { get; set; }\n    \tpublic Vector2D<T> Add<S>(Vector2D<S> other)\n    \t{\n    \t\tvar result = new Vector2D<T>();\n    \t\tresult.X = (T)((dynamic)X+(dynamic)other.X);\n    \t\tresult.Y = (T)((dynamic)Y+(dynamic)other.Y);\n    \t\treturn result;\n    \t}\n    }\n\nWithout dynamic here you'd have to resort to reflection, but with the dynamically typed variable the compiler leaves it up to the runtime to find the `+` operation on those objects, which it finds perfectly fine. Yes it's certainly more dangerous, but that's the trade off (nice code vs safe code)", "id": "d3dcljo"}, {"comment": "> Without dynamic here you'd have to resort to reflection\n\nDynamic typing is just syntactic sugar for reflection. (Or in some languages, dictionary look-ups.)\n", "id": "d3djx9m"}, {"comment": "In c# it's actually syntax sugar for reflection, and then generating a new version of the function and patching it in. In a case like the example, where the objects involved are always the same type, you pay for dynamic once and then it is the same as if you'd just written a proper matrix class.\n\nIncidentally, this is a terrible example. You don't need to make a matrix generic on the numeric type... You need to make it generic on the dimensions.\n\nAlso, the language you are looking for is c++. It can define this perfectly fine, with any restraint on the types you want.", "id": "d3e231t"}, {"comment": "> Dynamic typing is just syntactic sugar for reflection\n\nAnd types are just syntactic sugar as well. Your point is?", "id": "d3eq382"}, {"comment": "> Most type system will restrict a lot of what you can express. As a basic and common example\u00a0Matrix<T>\u00a0is a generic type that can't be expressed in a lot of languages, because you can't limit\u00a0T\u00a0to say support only classes that support certain operations.\n\n> You can definitely fix those with better type systems, but the point is optional typing means that when your type system fails to be expressive enough the user has an out and can still write their code.\n\nThere's an easy answer, here: when you're writing a language, don't create an anemic type system.  Yes, an optional type system is better than a bad static type system, but isn't a good static type system even better?\n\nAs for the matrix example, typeclasses are a good solution.", "id": "d3e2edg"}, {"comment": "> but isn't a good static type system even better?\n\nYes for sure. But type systems are very hard to get right, and the vast majority of languages have gotten it wrong. If you know of a language that has gotten it perfect and still managed to get good tooling and real world usage (and no despite all the cries, haskell is not anywhere near mainstream. The vast majority of developers don't even know what it is. Go is already more familiar). Most stronger type systems get too confusing for most developers, or too impractical, or just too difficult to work with.\n\nBy allowing optional typing you are being humble and saying \"we haven't figured it out yet. But we're working towards it and getting better\". That was TypeScript's approach, and as they continue they are adding more and more to it, building out a better type system. I don't think this is the approach everyone should take, because I don't think dynamic languages belong everywhere. I'd much prefer a static type system than a dynamic one, but giving me the option when you know you are imperfect is quite nice.\n\n> As for the matrix example, typeclasses are a good solution.\n\nYep, and if it wasn't for the confusing terminology haskell introduces you'd probably see it a lot more. TypeScript's interfaces are typeclasses (as far as I'm aware, again the haskell terminology gets way too confusing to really understand what's going on here). That is structural typing and is very convenient to use. It's something I think .NET needs to get, and I know there have been talks at least about adding it to C#. It is more dangerous type-wise to use structural types, but it's worth it for the power you get.", "id": "d3erlq7"}, {"comment": ">  Yep, and if it wasn't for the confusing terminology haskell introduces you'd probably see it a lot more. TypeScript's interfaces are typeclasses (as far as I'm aware, again the haskell terminology gets way too confusing to really understand what's going on here). That is structural typing and is very convenient to use.\n\nFrom googling a bit, it seems TypeScript's approach is quite different - they're just a structural variant of normal OO interfaces.\n\nIn OO, you combine data and implementation into a single thing.  Typeclasses, on the other hand, make it so your data and vtables stay separate.  It's very similar to implicit arguments in Scala; in fact, one use of implicits in Scala is called the 'type class pattern' because it's the same idea as Haskell typeclasses.\n\nIn Scala, you might define something like\n\n    trait Order[A] {\n       // returns 0 if they're equal, -1 if x < y and 1 if x > y\n       def compare(x: A, y: A): Int\n    }\n\n    def sort[A](list: List[A])(implicit ord: Order[A]) = ...\n\nThe key thing is that your List is completely separate from the implementation for Order, and that functions that rely on that ordering have to take both the data and the \"implementation dictionary\" for the typeclass, although the compiler itself handles creating and passing around the implementation dictionaries.\n\nTypeclasses have some interesting advantages:\n\n1. Classes can conditionally implement a type class.  For example, in Haskell lists implement the Ord typeclass iff the underlying element type implements the Ord typeclass.  In the [matrix library on hackage](https://hackage.haskell.org/package/matrix-0.3.4.4/docs/Data-Matrix.html), Matricies implement the Num typeclass iff the underlying elements implement Num.  This is the nice bit for working with Matrixes, btw.\n\n2. You have access to typeclass instances even if you don't have access to any actual data.  This means, for example, that even if someone gives you an empty list you can still use a type class to give you a default value.\n\n3. Related to 2, you get a sort of \"return-type polymorphism\".  For example, [aeson has the method](https://hackage.haskell.org/package/aeson-0.11.2.0/docs/Data-Aeson.html) `fromJSON :: FromJSON a => Value -> Result a`.  In Java, on the other hand, you'd see methods like JSONtoInt, JSONtoDouble, JSONtoFoo, etc. etc. etc.\n\n4. You can extend existing types with new typeclasses.  In OO, on the other hand, classes are typically closed to extension; you need to make a new subclass that extends a new interface but that won't affect instances of the original.", "id": "d3evwra"}, {"comment": "I'm not sure how not allowing data in the structural interface makes a real difference. I get that you can pass the functions separate from the data, but you could certainly do that already. \n\nI'm going to speak to each of your points independently:\n\n1. This is neat and a useful feature, but I can imagine this being built into any language with generic and constraints. I'd imagine it'd be slightly awkward syntactically in most languages, so I'm going to check it out in haskell (I imagine it'd be smoother there). I do see some scenarios this would be useful, but having to extend the type and provide the implementation there isn't the end of the world, and I can't think of something where that'd fail.\n\n2. I'm not sure what exactly what you mean by this, but if I understand it correctly it'd be something like\n\nC#\n\n\n    void Foo<T>(List<T> items)\n    {\n        items.Add(default(T));\n    }\n\nYou can pass the type around as is. It's a bit harder to get functions off of it (it requires reflection) but you could also pass around a separate object if you wanted to pass around functionality without data and still get nice type checking and compiler support. TypeScript may be a bit more difficult cuz of the nature of emulating JavaScript but I've been quite surprised by it's type system before\n\n3. The \"return-type polymorphism\" statement is throwing me off a bit, but C# certainly can return generic types\n\ne.g.\n\n    function fromJSON<T>(value : string) : T {}\n    \n    let x = fromJson<number>(\"3.14159\"); //x is a number\n    \nIt's also possible in C#, and C# has the benefit of actually supporting different kinds of numbers (typescript makes a huge effort to be a compile time only thing, so it can't extend javascript with new number types)\n\n\n4. This is possible in C# by using extension methods. They can't access private or protected members, but that was the point of making them private or protected anyways, so that's a good thing. C# is looking at adding extension properties too, as well as other things. You can't extend it to add new interfaces yet, but that is being discussed.\n\n\n", "id": "d3fxxyy"}, {"comment": "> What's the worth? In a non-optionally typed system you can mark everything as an 'Object' and you'll get 95% of the 'benefits' of an optionally typed system. So is the worth, that you save a few characters? \n\nIt's not \"a few characters\". It's generally a LOT of characters, significantly adding to the cognitive load of both writing and reading the code. \n\nDon't get me wrong, I'm all for static typing in the vast majority of cases. There are, however, cases where a static type system has to jump through a LOT of hoops (and bypass the benefits of the static typing) to accomplish certain things. In those cases, the code winds up being a lot harder to read/reason about than it would be in an untyped (or optionally typed) language.\n\nMy preference, of course, would be for a mandatory, statically typed language with a powerful/simple enough type system that there's nothing that can't be done in a way that is easy to both write and read. Alas, there is no such type system yet (that I'm aware of).", "id": "d3d00fo"}, {"comment": "> There are, however, cases where a static type system has to jump through a LOT of hoops (and bypass the benefits of the static typing) to accomplish certain things. In those cases, the code winds up being a lot harder to read/reason about than it would be in an untyped (or optionally typed) language.\n\nExample?", "id": "d3d2nie"}, {"comment": "Reading it I immediately thought of TypeScript. The optional static typing combined with pretty decent type inference and structural typing gives you one of the best type experiences I've ever had. I've developed with C#, Haskell, TypeScript and JavaScript and it's not an exaggeration to say that TypeScript was definitely the most pleasant experience in terms of types (it wasn't nearly as fun because of libraries but that's a matter of maturity). \n\nMicrosoft did a little case study when they converted TFS online from javascript to typescript and found quite a few bugs. It was code that was well written, with both unit and functional tests, documentation and lots more. And after just a week of basic bare bones conversion they found quite few:\n\nhttps://blogs.msdn.microsoft.com/bharry/2012/10/24/typescript-a-real-world-story-of-adoption-in-tfs/\n\nThis to me is the most real study that shows static typing helps find bugs", "id": "d3cvle5"}, {"comment": "> Bug 987071:RichContentTooltip _setPosition calls a non-existing function \u2013 looks like casing typo\n\nThis is insanity, but it has nothing to do with static typing, and everything to do with JavaScript's crazy choose-your-own-adventure style of object construction.", "id": "d3d46x3"}, {"comment": "I'm really confused what you mean. It looks like the problem was a typo, which is the exact kind of issue that static typing would notify you of immediately. It was difficult for linters and tooling to notify you of this problem due to javascript's insane rules but the typo is still a typo.", "id": "d3dbbck"}, {"comment": "> which is the exact kind of issue that static typing would notify you of immediately.\n\nYou don't need static typing for use of undeclared identifiers to be caught by a linter.", "id": "d3dmh0p"}, {"comment": "simple ones, like local variables and functions, can be caught yes, but more complex things like object properties can be quite tricky.", "id": "d3eq4hj"}], [{"comment": "> compare the number of issues labelled \"bug\" versus the number of repositories in GitHub for different languages\n\nAwful measurement. For fuck's sake, reddit's  anecdotes are more scientific than that.", "id": "d3cjaq1"}, {"comment": "Yeah, no controlling for project size, project complexity, amount of submitters or pull requests.\n\nBad statistics. D-", "id": "d3cop98"}, {"comment": "Why would pull requests be a factor?", "id": "d3cp6s6"}, {"comment": "They indicate interest in the project which correlates with eyeballs looking for bugs, which in turn correlates with bug discovery rate.", "id": "d3cpayd"}, {"comment": "Don't bugs more often come from users, rather than developers?", "id": "d3cprkj"}, {"comment": "Developers are users too. Especially in the context of a GitHub repository.", "id": "d3cqsp6"}, {"comment": "I'd argue it depends on the repo. Either way, if you care about users, you should look for users, instead of going for other populations of people that may or may not overlap with the population of interest.", "id": "d3cr30c"}, {"comment": "I guess the number of unique git clones/downloads is another major factor. ", "id": "d3cpssr"}, {"comment": "I think the list more accurately describes the popularity of each language.", "id": "d3cpou5"}, {"comment": "The anecdotes are certainly worse. Anyone arguing for either side of this really needs to start showing some kind of empirical data, or they should stop pretending to be right about their assertions. ", "id": "d3d96u7"}], [{"comment": "Even if we do accept his argument that programs written in simpler languages have less bugs, it kind of begs the question, are simple languages better or just used for simpler tasks?", "id": "d3cjhn3"}, {"comment": ">Even if we do accept his argument that programs written in simpler languages have less bugs\n\nI wouldn't. Simplicity is hard to define, particularly in a manner everyone can agree on. Some value syntactical simplicity (Lisp, Forth), others value abstraction simplicity (C, the so-called \"portable assembly\"), others think of it in terms of how concise the code is allowed to be (Perl), or how shallow the features are (Haskell has straightforward features, but they're total rabbit holes once you start reasoning with them).\n\n>are simple languages better or just used for simpler tasks?\n\nI agree. It's easy to not have memory-related bugs but only if you're willing to forego the control over it together with the responsibility of not screwing it up. Same for OOP and other paradigms. Also, I don't find Erlang's syntax particularly simple.", "id": "d3cpfu5"}, {"comment": "Could not agree more, using the right tool greatly reduces effort.", "id": "d3d39kg"}, {"comment": "All problems are ultimately hierarchical. So, you can always break up a large problem into a set of small simple problems. For example, I work with Clojure, and it's rare that I have individual projects that are over a few thousand lines in size. However, I often combine these projects to solve large problems.\n\nThere's really no good reason to write large monolithic projects regarding of the type discipline.", "id": "d3egz3w"}, {"comment": "Should normalize it by LOC.", "id": "d3cokoj"}, {"comment": "That would be interesting but since some languages have more compact code it'd still be hard to interpret. Compact code can not only happen for surface syntax reasons but also because the language encourages higher level abstractions in one way or another.\n\nSo imagine a smaller codebase that does as much as a bigger codebase, and also has a lot fewer bugs. If you then normalize by LOC the smaller codebase might come off worse -- more bugs per lines of code.\n\nYou really want to measure it by \"feature points\" but how do you even start measuring that?\n", "id": "d3coq1k"}, {"comment": "Should also normalize it by intrinsic complexity (i.e., the complexity of the problem itself), the community's bias for or against labelling something as a bug, the quality standard that the project members decided to shoot for, priorities, man-hours sunk into the project, and a million other factors.", "id": "d3cpn0f"}, {"comment": "Yes, this is one of the main points of DSLs.", "id": "d3d8igy"}], [{"comment": "The approach seems flawed to me, because it doesn't take project size/complexity into consideration at all. Let's assume you have 10 Ruby projects with 100 lines of code each, and 1 C++ project with 100k lines of code, then you should certainly expect more \"bugs per project\" in C++.", "id": "d3cobp0"}, {"comment": "There's so many factors ignored. You not only need size of the project, but you need who the project is for (less people using it means less bugs reported, but also if the users are more accepting of certain kinds of bugs) how bugs are organized (are there lots of duplicates, do they just label using the word bug or do they break it down. Do they mark feature requests as bugs, or confuse the numbers in some other way).  One huge thing is do development branches get bugs reported here, and even user reported bugs, what if they use a different tool?\n\nYou also need to factor in how serious the project is. It doesn't surprise me that languages often seen as toys have \"the least bugs\" because those repos might not actually be real projects. They might be demos, prototypes or something else. Meanwhile the C++ and java ones might be giant 10 year old software.\n\nIt's never going to be actually properly studied (it'd cost way too much), and these fake studies make it worse. ", "id": "d3cuue6"}, {"comment": "Additionally, size is difficult to compare cross-language - for example, clojure code is going to have fewer lines than equivalent java due to not putting end-parens on their own line or requiring auto generated boilerplate getters and setters.  And you should probably correct for how complex and involved the projects are.", "id": "d3dc3tp"}], [{"comment": "I would say that the definition of 'simple' there isn't quite right: rather, the yardstick of simplicity how hard is it to express what you want to say in the language.\n\nBy this yardstick, Go isn't terribly simple: expressing something like \"a heap of any ordered type\" is not (AFAIK) possible at all, let alone merely hard.  In C, it's merely hard: you've got to figure out some way to represent orderings, which probably means passing around function pointers or similar.\n\nDynamic languages are Rich Hickey's \"easy.\"  You don't have to think about types.  But it's not simple, because the lack of types means your program will fail at runtime.\n\nUncle Bob's notion that tests are equivalent to static types is barmy, for two reasons.  The first is that tests are for behaviour, while types are for structure - you use types as a means to provide shapes to your plugs and sockets, so you don't do this:\n\nhttps://pbs.twimg.com/media/B3Fvg-sCYAAkLSV.jpg:large\n\nThe second is that tests are _existential_.  There exists some set of examples for which the behaviour is correct.  Types are _universal_.  For all ways in which functions are plugged together, they fit.\n\nI think we'll see the opposite trend: better type systems with more expressiveness leading to simpler implementations of ideas.  Further, I expect over the next few decades we'll see a greater rise in the use of theorem assistants, which do give a universal qualifier over behaviour, as the convergence of functional programming, type systems, and formal methods continues.", "id": "d3cnp3t"}, {"comment": "> The second is that tests are existential. There exists some set of examples for which the behaviour is correct. Types are universal. For all ways in which functions are plugged together, they fit.\n\nThis is actually a really big deal, because, among other things, it means that unlike unit tests, type signatures don't grow exponentially in size and complexity as the project grows.", "id": "d3cpod2"}, {"comment": "    template <class Event,class FSM,class STATE>\n        typename ::boost::enable_if<\n            typename ::boost::mpl::has_key<\n                typename Target::tag_type,state_action_tag>::type,\n                typename state_action_result<Event,FSM,STATE>::type >::type\n     operator()(Event const& evt,FSM& fsm,STATE& state )const...\n\nIf that's not exponential growth, then P = NP.", "id": "d3cqi11"}, {"comment": "This says something about the general hideousness of complex C++ template code, but little about how the complexity of the type signatures relates to the size or scope of the project.\n\nI would wager that once your types reach a certain level of complexity, and the project grows further, the types will not get any more complex, you'll just see more of them, and at some point, generalization might even make some of them simpler again.\n\nAlso, I would like to note that C++ is probably not the best candidate for illustrating the benefits of static type systems, and definitely not for demonstrating how to write statically typed code in a clean, readable way.", "id": "d3cu32d"}, {"comment": "concepts to the rescue !", "id": "d3cur90"}, {"comment": "Couple types of properties and their proofs (ie, programs) and you also have universal qualification of behaviour.", "id": "d3cu4ze"}, {"comment": "Really interesting points.  I think though that the \"dynamic typing + exponentially expanding unit tests\" vs \"static typing + inherent correctness\" is a false dichotomy.  What if one were to argue that carefully chosen integration tests with real-world use cases is the sweet spot?  (Real-world use-cases should not be growing exponentially or else whatever you are making will probably be unstable no matter what else you do.)  IMHO any serious project (typed or untyped) still needs integration tests, so it's not like a statically-typed language is saving you work there.  Actually, since writing good integration tests is notoriously difficult, it might be simpler in a more dynamic language.  ", "id": "d3dncf6"}, {"comment": "Simulation tests, absolutely. Types cannot replace these.\n\nIntegration tests, to taste, but probably yes. Types cannot replace these entirely, but they can seriously reduce the surface area thay needs testing.\n\nUnit tests for the things the type system doesn't capture. The ideal type system would allow you to fully express the desired behavior, but such a system does not exist in practice, and I would wager that it is impossible in theory as well. Still, maximizing type-based checks is very beneficial.", "id": "d3dwi4b"}, {"comment": "> which probably means passing around function pointers or similar.\n\nYou can pass around function pointers in Go too.", "id": "d3csuuo"}, {"comment": "Yes, I'm not really sure what I was thinking when I wrote that - you can have just as bad a time in Go as you can in C, using `interface{}` and type casts all over the shop.  Well, maybe even a slightly better time, because Go will runtime assert an error when you cast, while C will let you trample memory.", "id": "d3dt3m6"}, {"comment": "> The second is that tests are existential. There exists some set of examples for which the behaviour is correct. Types are universal. For all ways in which functions are plugged together, they fit.\n\nTo expand on that, I wrote in some detail about what tests can and can't tell you about your program [here](http://kevinmahoney.co.uk/articles/tests-vs-types/#comparison)", "id": "d3db6gb"}, {"comment": "> The second is that tests are existential. There exists some set of examples for which the behaviour is correct. Types are universal. For all ways in which functions are plugged together, they fit.\n\nOut of curiosity, did you recognize that, get it from [Types vs. Tests](https://www.infoq.com/presentations/Types-Tests) or one of Amanda Laucher's follow-up presentations, or somewhere else? I'm not asking for attribution's sake, only because it'd be nice to get a sense of how that insight, which for me was the key one from TvT, may or may not be spreading.", "id": "d3cubm2"}, {"comment": "I recognised it after about a year of learning things like quickcheck (stochastic existential!) and the difference between _thinking_ something works because I tried a few variations, and _knowing_ it works because I proved it.\n\nI skipped Amanda's presentation at Yow! 2015 to be in another track, because by that time I didn't need selling on property-based testing, and haven't watched TvT.", "id": "d3cunbk"}, {"comment": "Awesome. Thanks!", "id": "d3cuovg"}], [{"comment": "Just for fun, I looked at the most starred repos in C++ (most bugs in repose with > 100 stars)  and Clojure (least bugs) in github\n\nhttps://github.com/search?l=&o=desc&q=language%3AC%2B%2B+stars%3A%3E100&ref=advsearch&s=stars&type=Repositories&utf8=%E2%9C%93\n\nhttps://github.com/search?o=desc&q=language%3AClojure+stars%3A%3E100&ref=searchresults&s=stars&type=Repositories&utf8=%E2%9C%93\n\nHere are the top 10 C++ repos\n\n1. Swift\n2. Electron (Used to be Atom Shell - source code includes chromium)\n3. nw.js - Way to write desktop apps using node.js\n4. tensorflow - Google's distributed machine learning loolkit\n5. rethinkdb\n6. hhvm - Facebook's VM for executing programs in Hack and PHP\n7. textmate\n8. caffe - Deep learning framework\n9. opencv - Computer vision\n10. Mongo\n\n\nHere are the top 10 Clojure repos\n\n1. LightTable - an IDE\n2. clojurescript - Clojure to JS compiler\n3. om - Clojurescript interface to Facebook's React\n4. FiraCode - Monospaced font with programming ligatures\n5. Leiningen - Clojure build system\n6. overtone - Collaborative Programmable Mused\n7. compojure - routing library\n8. riemann - network event stream processsing system\n9. metabase - some sort of data query and visualization system\n10. clojure-koans\n\n\nThere is a vast difference in both the complexity of the projects, and the production usage. Many of the C++ projects are used in production code by major companies and so bugs will aggressively get found/reported/fixed.\n", "id": "d3czuyp"}, {"comment": "These two lists are enough to show that the results described in the post are pretty much just noise", "id": "d3de63g"}], [{"comment": "Wow this article is completely worthless. He seriously based his argument on the number of commit messages containing the word \"bug\"? Those are some olympic level mental gymnastics.\n\nIf this is the best argument for dynamically typed languages then they lost the argument by default.", "id": "d3cosvp"}, {"comment": "He better not go to olympics. Your mental gymnastics would still win.", "id": "d3cpytf"}], [{"comment": "Ruby, JavaScript and Python are all pretty similar languages. And they're all over the place in these graphs. If the \"simple languages\" hypothesis is correct I don't see why Ruby and Python would end up so differently.\n\nThere are large confounding factors that have to do with culture: perhaps Ruby people star projects more eagerly on Github, and less used projects end up with more stars. Perhaps Java projects attract a lot of bug *reports* but don't actually have more bugs as they're duplicates or mistakes. Perhaps Clojure developers are less likely to leave a mistaken bug report. I don't know whether any of these in particular are true, but it's plausible that some stuff like that is going on.\n", "id": "d3cox65"}, {"comment": "Js, ruby and Python are not at all similar though. The rest of your logic is sound though. ", "id": "d3df6yf"}], [{"comment": "Wow. This is terrible. A shallow and naive comparison of the number of bugs in select GitHub projects. I'm not sure what conclusions can be drawn from these charts, given that there was no attempt to control for things like project size, project complexity, project popularity, project domain, project age, bug type, etc. Then there are the 'soft' / hard-to-quantify benefits like maintainability .. ", "id": "d3cxypz"}], [{"comment": "In theory, I agree with the notion that a simpler language will lead to less bugs; I mean, the easier it is to reason about your code, the easier it will be to squash bugs before they pop up.\n\nStill, I think the metric used here doesn't show the whole picture. Project complexity, for example, is not a factor. Could be some languages are used for simpler projects. Obviously some projects could have unreported bugs as well, but that's just conjecture.", "id": "d3ckd48"}, {"comment": "> In theory, I agree with the notion that a simpler language will lead to less bugs; \n\nLike assembly? Or Brainfuck? Or Whitespace?\n", "id": "d3cnssw"}, {"comment": "I think you're confusing syntactic simplicity with expressive power, or to put it another way, doing more with less. Assembly is pretty syntactically simple, but the assembly equivalent to your average program written in a high-level language would be quite a bit larger, and more complex to boot. \n\nSorry if I didn't make that clear in my original comment.", "id": "d3cnvro"}, {"comment": "I was simply underlining the fact that you didn't specify what you mean by \"simple\".\n", "id": "d3cnzja"}, {"comment": "> I mean, the easier it is to reason about your code, the easier it will be to squash bugs before they pop up.\n\nStatic types doesn't make it harder to reason about your code, it makes it easier.", "id": "d3colft"}, {"comment": "I didn't mention static or dynamic typing anywhere, though, and the author wasn't making a case for one or the other, either - see: \"Static vs Dynamic is not th\u200b\u200be issue\"", "id": "d3coo8k"}, {"comment": "Not always. It can make code harder to read by masking the intent into layers of types. See scala.", "id": "d3d95j2"}], [{"comment": "So, is Python more complicated than Haskell and Scala? \n\nOr is there anything special in Python that makes seemingly simple language so buggy?", "id": "d3cnlqb"}, {"comment": "Python is a prime example for the Simple vs. Easy problem. Python is, without doubt, an *easy* language, both for people with no previous programming background, as for people who have been programming in other imperative languages for years. But it is not, by any objective measure, a *simple* language, in the sense that the number of concepts required to perform a given task is minimal, or that the language contains only the minimum feature set that is required to achieve its expressive power.\n\nAnother issue is the *visibility* of complexity. Many of the things that Haskell makes explicit, such as I/O, mutability, nondeterminism, nullability, errors, thread-safety, etc., are implicit in Python, and the community consensus seems to be to rely on documentation and unit tests instead. However, this involves a lot of manual labor (which is error prone), and it is less powerful, because unlike type signatures run through a good static type checker, unit tests are, by design, isolated, that is, if I assert a property of function `foo` in a unit test, that property is not checked when I write calls to `foo` - that part I have to check manually, or at least I have to manually write separate integration tests. A type checker, however, checks the validity of my claims (expressed in type signatures) on both ends: when I write that `foo` returns an integer, then the type checker verifies that it does indeed return an integer, but it also verifies that any call site expects an integer.", "id": "d3cpklt"}, {"comment": "Easy counterargument: Ruby has one of the lowest bug densities. If your points explain the difference between Haskell and Python, Ruby should be sitting right alongside Python.\n\n(The obvious conclusion is that the article is claiming things it cannot justify.)", "id": "d3cz3v3"}, {"comment": "\"The obvious conclusion is that the article is claiming things it cannot justify.\"\n\nAgreed, but the author did more to justify his claims than 99% of the arguments for static typing I've seen. ", "id": "d3d9e97"}, {"comment": "[I present to you the only article on the topic worth reading.](http://web.archive.org/web/20151013014554/http://danluu.com/empirical-pl/)", "id": "d3da02l"}, {"comment": "Thanks! I've been compiling a list like that and hadn't seen this before.\n\n\"As for the rest of the experiments, the main takeaway I have from them is that, under the specific set of circumstances described in the studies, any effect, if it exists at all, is small.\"", "id": "d3dd26y"}, {"comment": "I'm not sure python is \"easy\". For example python has a lot of syntax and keywords for things that many languages achieve with composition of their fundamental building blocks. Think list comprehensions, decorators, with, etc. This is all additional syntax that of is done in other languages with just first class functions. Python may make a piece of code look \"simple\" at first glance, but I'd argue it's actually more complex than most people realize. ", "id": "d3d9ciw"}, {"comment": "Yes, Python is quite a complex beast. Look up Rich Hickey's \"Simple vs. Easy\" talk on YT, it's not the same thing. \"Simple\" means \"few concepts\"; \"easy\" means \"similar to something I'm familiar with\". Python is easy to many, but it's not simple.", "id": "d3djsty"}, {"comment": "I love Rich's talk. I rewatch it every now and again. ", "id": "d3dnnyr"}, {"comment": "It might be that python has a lot of magic (the [bad kind](http://www.rafekettler.com/magicmethods.html)) that makes actually complex behaviors *look* simple. This kind of design is a bug-magnet - seemingly innocent looking statements can have all sorts of far-reaching side effects.", "id": "d3cp2fy"}, {"comment": "bullfuckingshit. *Hurr durr there is word magic, magic is bad therefore they are bad.*\n\n \"Magic methods\" are nothing more than methods constituting an interface without the need of inheriting from a shitload of abstract classes. You implement the method responsible for indexing? Congrats, your class supports obj[idx] now.    \nHow is writing `__eq__()` different from implementing isEqual() in java?\n\nFor every problem caused by \"magic\" you will get 100 off-by-ones in \"simple languages\" that force the user to fuck around with mundane shit like indices to get to contents the user cares about.", "id": "d3csbpr"}, {"comment": ">  How is writing __eq__() different from implementing isEqual() in java?\n\nFor one, `isEqual` won't be called automatically when you say `a == b`; if you want to call `isEqual`, the invocation is explicit...", "id": "d3cuaia"}, {"comment": ">For one, isEqual won't be called automatically when you say a == b; if you want to call isEqual, the invocation is explicit...\n\nAnd I hate this\n\nEspecially if you have strings. string1 == string2, who would ever want that?", "id": "d3cvnr3"}, {"comment": "At least you don't have javascript's fine equals behavior... which is not so fine.", "id": "d3cxbk4"}, {"comment": "Once you understand the nuances of it, it's actually great, because it gives you options for loose comparisons. If you don't like loose comparisons, you can follow the Crockfordites and use `===` and `!==` everywhere. ", "id": "d3dec49"}, {"comment": "Sure, that's true.    Except in circumstances where you've redefined true.   Because \"true\" is converted to NaN, while true is converted to 1.   So  \"true\" == true is not actually true.  \n\nI'd FAR rather have it be very straightforward, and then treat those cases with need for \"loose\" comparisons in an explicit way.", "id": "d3dhjtf"}, {"comment": "And the number of people who give more fucks about implementation details vs utility derived from it is exactly 0. \n\nI take it you have problem with operator overloads in c++ too? Domain specific logic in custom classes is not kosher because it's not explicit? Vectors and complex numbers should not support basic math operators because we'd rather jump through the \"explicit\" hoops because it's somehow more pure? I'd rather have opportunity to plug into operators to have shit like `vec3d_1 + vec3d_2` working, thank you very much.\n\n", "id": "d3cupck"}, {"comment": "my take: python is often sold as a gateway language to programming, so you have relatively more mediocre programmers in its ranks. On the other hand Haskell is a hardcore nerd orgy. Scala too, being not so mainstream, will draw relatively more experienced programmers who shop around.", "id": "d3cu4mp"}, {"comment": "Haskell is not hardcore and nerdy, its just for people who enjoy mental masturbation, a lot of tangential abstracted complexity for no real world gain.\n\nBut sure if Haskell makes you feel superior then more power to you. ", "id": "d3d38m7"}, {"comment": "There is a lot of C in it, I suspect this to be the cause, combined with the fact that people run it any every platform possible (and many impossible ones too)", "id": "d3cqrdh"}, {"comment": "Python is much more complicated than Haskell, I can't vouch for Scala.\n\nIf you stick to a sane subset then they're comparable, but as soon as you start using any of python's metaprogramming techniques, or come across libraries that don't invoke __init__ and use __new__ instead or import a library that has to monkey patch the standard library to give you some nice syntax, then yeh, Python is a Cthulian nightmare.", "id": "d3cr4nd"}, {"comment": "Scala is incredible complex", "id": "d3cvolw"}], [{"comment": "> I was quite surprised at a recent blog post by Uncle Bob Martin, titled: \"Type Wars\", in which he writes: \"Therefore, I predict, that as Test Driven Development becomes ever more accepted as a necessary professional discipline, dynamic languages will become the preferred languages. The Smalltalkers will, eventually, win.\"\n\nThe problem with this claim is if you are using your test system to enforce types then suddenly you have a lot more test code. They are not comparable.", "id": "d3cqgxy"}, {"comment": "I thought people had started to come around to the fact that many if not most of the people preaching TDD don't actually practice it.\n\nI had a discussion in rl where someone was claiming static typing was pointless, and that proper testing would fix everything.  When I pointed out that not very much code is tested in places I've worked, and that none of the tests we do have in our own software ever seem catch anything, he said it was because we weren't writing enough tests.\n\nI don't even know how to respond to it.", "id": "d3d406t"}, {"comment": "> Static type systems are simply a DSL for unit testing object models. So if aren't writing enough tests, it follows that we need stricter type systems.", "id": "d3dk1eu"}, {"comment": "My theory is the real issue is normally a management/culture problem that has nothing to do with langs/devs.  In an environment with dynamic languages that are well suited to rapid prototyping, devs can churn out features at a rate that satisfies management but depts are not given time/money to write all the tests they want to (which would help ensure stability).  In an environment with a typed language, all development is intrinsically more stable with or without tests, but features get created much much slower.  Basically MoarFeatures always flies in the face of stability and vice versa", "id": "d3dmlha"}, {"comment": "> In an environment with a typed language, all development is intrinsically more stable with or without tests, but features get created much much slower. \n\nNot where I work. I can crank out features a hell of a lot faster with the compiler watching by back.", "id": "d3expkt"}, {"comment": "Soo.. what are you making faster?  If we just contradict each other without adding any more context it's not much of a discussion.\n\nAnother aspect of my argument is this: from the point of view of productivity for a *business* instead of productivity for the developer, it doesn't count as \"adding features faster\" if you're building things in strongly typed languages that their more dynamic language counterparts won't need.  So regardless of how \"fast\" it is to make an ORM in C#, if there are already 5 good options for ORMs in python/ruby you're still moving slow.  Haskell's type system is interesting and powerful.. but if you're rebuilding Erlang's OTP with it from scratch then you're ultimately moving very slow.", "id": "d3f9j9e"}, {"comment": "Yes, I am talking about business features.", "id": "d3fbceg"}], [{"comment": "Dumb logic. Ignoring all the other problems in the design of his \"experiment\", it is a flawed premise to begin with that safer languages result in code with less bugs. This is like thinking that more roads must result in less congestion or that better engines must lead to lower aggregate fuel consumption.\n\nThe characteristics of languages like C++ and Java directly affect which tasks they are chosen for. The low bugcount of Golang may simply indicate that it is being used for simpler projects.", "id": "d3cpmuh"}, {"comment": "But if static typing leads to fewer bugs, wouldn't we see a different correlation?\n\nThe conclusion to this line of thinking isn't \"therefore use dynamic languages\", it's \"therefore, we have failed to empirically establish the claim that static typing leads to fewer bugs\".", "id": "d3ctdet"}, {"comment": "Only if comparing projects of equal size, complexity and difficulty. Which he didn't do.", "id": "d3d10bg"}, {"comment": ">But if static typing leads to fewer bugs, wouldn't we see a different correlation?\n\nNot in this dataset. Depending on the other variables involved, \"safer\" languages might consistently correlate with projects with more bugs, less bugs, or the same amount of bugs.", "id": "d3dx1br"}], [{"comment": "Many commenters have already commented on the methodology: simply put, there are too many variables that are not taken into account in his study.  For example, some projects consider that errors in the documentation is a bug and would probably use the \"bug\" tag for such an issue, while another project could tag it under \"documentation\".  Clearly this has nothing to do with type systems or testing, and can skew the results.\n\nThe other problem I have is his conclusion: simple language implies less bugs.  Taking this argument to its logical extreme, it stands that Lambda Calculus and Turing Machines would be the languages where people write programs with the least bug.  The reality --- as most people who took a theory of computation class in school know --- is that writing even the most trivial programs in LC or TM is extremely hard.", "id": "d3cv3z0"}], [{"comment": "[deleted]", "id": "d3cvwtj"}, {"comment": "> C(Integer)=Integer_Infinity\n\nThe integers are isomorphic to the naturals. `Integer_Infinity = Infinity`.  But, the natural numbers are far simpler than the (isomorphic) integers or rationals, because they can be described in fewer rules. This is related to the theoretical notion of [Kolmogorov Complexity](https://en.wikipedia.org/wiki/Kolmogorov_complexity). Natural numbers are basically just:\n\n    data Nat = Zero | Suc Nat\n\nBut Integers are\n\n    data Int = Positive Nat | NegativeSuc Nat \n\nLater, your definition of complexity seems to change as you say:\n\n    C(Pair)=C(Integer)+C(Integer)\n\n\nBut should this not be a product? As you seem to be counting the inhabitants of a type, the number of inhabitants of a pair are the product of the inhabitants of the components, not the sum. Furthermore, the `Infinity * Infinity` is isomorphic to `Infinity` (cantor showed this) so there's no larger sense of size here.\n\n> 257 infinities is quite complex\n\n257 infinities are exactly as complex as one infinity (they're isomorphic).\n\n\n", "id": "d3cx9qb"}, {"comment": "[deleted]", "id": "d3cyfm9"}, {"comment": "> `Int` is \"more infinite-y\" or at least more complex\n\n`Int` is isomorphic to `Nat`, so it cannot be inherently more complex.\n \n    natToInt n =\n       let (d, r) = n `divmod` 2 in\n       if r == 0 then Positive d\n       else NegativeSuc d\n\n    intToNat (Positive x) = Nat (x * 2)\n    intToNat (NegativeSuc x) = Nat (x * 2 + 1)", "id": "d3czwl9"}, {"comment": "[deleted]", "id": "d3d0xn9"}, {"comment": "I should clarify what I meant there: _Under your definition of complexity_, ints are no more complex than nats. It's possible to construct a notion of complexity which is different, but I suspect can't be easily calculated (K-complexity is undecidable after all).", "id": "d3e12yf"}, {"comment": "> A set of integers has more potential, intuitively, than just one integer.\n\nIntuitively, but not factually. 1 Integer can express precisely the same amount of information as 2 integers.\n\nEdit:\n\n> like the real numbers? \n\nThe real numbers are uncountable. A finite set of integers is countable.", "id": "d3d0gqw"}, {"comment": "[deleted]", "id": "d3d1ha9"}, {"comment": "You can't use some complexity measure here. Because they have the same number of inhabitants, you fundamentally can't rely on counting. \n\nThe complexity that comes from the integers as opposed to the naturals isn't in the _amount of possible values_ (as it's the same), but in the computations that manipulate them. This seems close to Kolmogorov complexity to me.\n\nSeeing as memory is finite, you can avoid this problem by using `Int32` and other finite types. Then two `Int32`s is definitely bigger than one.\n\n\n\n", "id": "d3d2q4t"}, {"comment": "There are a few odd things in what you say.\n\n- If `Null` has a complexity of one, I would expect `Boolean` to have a complexity of two.\n\n- Your qualification of infinities goes against mathematics, in which the cardinality of integers and naturals is identical.\n\nThis is happening because you are being vague on what these numbers actually mean. For some, you use Cantor-like cardinalities, for others you count witnesses, etc...\n", "id": "d3cx8cd"}], [{"comment": "Dynamic typing zealots are getting visibly desperate.", "id": "d3cuk26"}], [{"comment": "It promise me better tooling and IDE integration...it delivered.", "id": "d3d8g4d"}], [{"comment": "I did something similar recently. I tried to score each language for safety, then use the github data to see if it correlates. http://deliberate-software.com/safety-rank-part-2/", "id": "d3diwvu"}], [{"comment": "Someone should test with TypeScript vs JavaScript or even better TypeScript vs Babel-transpiled projects since the languages and the communities are otherwise equal.", "id": "d3ctwto"}, {"comment": "I think this idea.  Start with a very bug prone language (javascript,  even the language itself has bugs [I'm looking at you equality 'operator' ] ).\n\nThen add basically only a type system and see what happens.", "id": "d3cxipe"}, {"comment": "My productivity and error improved measurably from JavaScript to typescript. ", "id": "d3d0yng"}, {"comment": "Typescript provides better tooling.", "id": "d3d8mr2"}], [{"comment": "Really proud of Clojure's numbers here. :-)", "id": "d3cywn2"}], [{"comment": "It's interesting that nearly all of his \"good properties of simple languages\" apply to Haskell, the exceptions being \"No complex type system\" and \"Not academic\" (which both sound like advantages to me...).", "id": "d3czjhl"}], [{"comment": "C++ being first by a long lead has nothing to do with static typing, and everything to do with C++ being a pile of crap.", "id": "d3d5pjj"}], [{"comment": "There are so many proponents of static typing it this thread, and they all raise good points. \n\nHere's the problem: in virtually every language (other than maybe Haskell) you can trample all over the type system, and usually will if your project reaches a certain complexity. C users end up with data type tags, void pointers thrown around everywhere, and function pointers to operate on everything. C++ users end up with template hell. Java users end up with a set of abstractions that becomes too large to fit in the mind. Basically, everyone is hacking dynamic typing into their language and saying \"look how great static typing is!\" \n\nThe situation gets worse when I have a service based architecture. Gee, it's great that I have this sweet Haskell micro-service architecture. Maybe my type system even lets me make cool guarantees about the accuracy of my services. But then I chain them all together, and I basically end up with an object model, and all my guarantees fall out the window. Meanwhile, my simple service was never the source of the bugs; I can completely understand a 500 line file. \n\nI'm not saying dynamic typing is **better** than static typing -- I'm saying its not really better or worse. Different situations will definitely have different results. Usually, the result of bugs comes from poor architecture: a lack of orthogonality and modules bleeding information into each other. If there are simple and clean interfaces with few entry points, then it's easy to reason about the data exchanges between different components and be convinced of their correctness without the additional mental burden of a type system. \n\nEDIT: adding this. I have a rather low opinion of the dynamically typed object-oriented languages. They combine the problems associated with OOP and lack any form of annotation or guarantees for the developer to read with. A language like Clojure, on the other hand, is free from the burden of OOP so this criticism doesn't apply. ", "id": "d3h75fr"}], [{"comment": "[deleted]", "id": "d3daohs"}, {"comment": "Wrong article.", "id": "d3dk3yq"}]]], "3x3sws": ["Why I'm not using your open source project", "2015-12-16 21:00:34", 26, "https://www.nczonline.net/blog/2015/12/why-im-not-using-your-open-source-project/", [[71, "TL;DR:  \n1. Your project doesn't have a license  \n2. Your project is GPL/LGPL licensed  \n3. You aren't maintaining the code  \n4. You don't have documentation or tests  \n5. You aren't using the project  \n\n> So when you license code as GPL, that license becomes viral whenever you distribute it, which means including the code in your own open source project. That is a showstopper for businesses wishing to incorporate code from these projects.\n\nAnd the question is, why should I care about my open-source code not being used by non-GPL-friendly businesses."], [52, "> So when you license code as GPL, that license becomes viral whenever you distribute it\n\nYep, that's precisely the point. What if I want my work only to be useful to people contributing back? And why should I care if businesses can't make money out of my work without giving anything back neither to me nor to the community?\n\nAnd, finally, why should I care _at all_ for you to use my product? I find this article to be extremely arrogant."], [46, "Sometimes code is not maintained because nobody showed in the door saying they use the code.  If you love some project, tell the author.  If the author lose interest in something, and he or she think nobody use it, is going to be abandoned.  But if a piece is popular and people love it, is going to be more prone to get updates."], [17, "[deleted]"], [12, "This author mistakenly believes that just because the source is provided gratis that the maintainence is also done gratis. The reason open source projects of this nature are open source is so that the cost of maintainence is shared between the people using it. \n\nThey don't have restricted licenses because it is in the best interests of the companies that need features or bug fixes to contribute patches or at least bug reports upstream lest they take the maintainence burden of the entire codebase in the form of a fork, or pay for maintainence in the form of a support contract.\n\nWhether GPL licensed or not, if the software is too expensive to maintain, don't fucking use it."], [8, "Do you really think you are punishing these people by not using their project?\n\nObviously you don't which is why you also blog about it.\n\nBut I don't think you are hurting them as much you think are. I don't think you are going to convince any of them to change their behavior."], [5, "> So when you license code as GPL, that license becomes viral whenever you distribute it, which means including the code in your own open source project. That is a showstopper for businesses wishing to incorporate code from these projects. (You can still safely use the code locally, such as running Linux on a server or using a build-time tool. It's just including the code in your application that can be problematic.)\n\nThis does _not_ affect businesses that use GPL in Software as a Service (SaaS), only businesses that wish to ship binaries. You can also get around this by invoking GPL programs and parsing their output. I also believe GPLv3 loosened the language, stating that the source can be \"made available\" instead of requiring it be bundled with the binaries."], [2, "On the positive side, with open source you know what you get, and you can improve the product in several ways, assuming the project is alive and maintained.\n\n\nOver the years I have realized that the state of most proprietary software is even worse than what you find in open source.\nSoftware is often terribly old, has been unmaintained for long periods of time, and only get some patchwork done when it no longer works on a modern OS and the owners finds it absolutely necessary to hire a fixer.\n\n\nThe process of buying software, at least for governments and official entities, also makes it close to impossible to avoid ending up with more or less useless software solutions. The restrictions and limitations surrounding such deals are often completely crippling for the buyer, and it doesn't make things easier when the whole thing is created by lawyers, for lawyers. A non-technical customer is pretty much powerless and can only hope to get through the process without lethal wounds."], [2, "\"A lack of documentation means I need to dig through the code to figure out how to use it and a lack of tests means there's no way to tell when something breaks\"\n\nIf your code is so fragile and difficult to work with that you need tests to tell you if you've broken something, then you need to go and flush your code down the crapper, where it belongs.\n\nTests are there to help you design and make your code easy to refactor and understand, and that it fits a particular contract.   Its not there to tell you that something has broken.  What I mean is if you change something in one area of your code, which causes a test to fail in a totally different area, then your code is fucked....no amount of tests will fix it."], [1, "now _*I*_ feel frustrated though the author is. And I really don't get the idea behind the activity. When I learned Ada, I found code from 1985 that still works today."], [1, "The one part of this article that I strongly agree with is that we have to be better about documentation, people like to make cool stuff no one can use"], [1, "Whether or not you like what the article is saying, knowing is better than not knowing, IMO. You can decide for yourself which of things listed that you want to change. For instance, you could decide you are not going to change when it comes to GPL, but you are willing to do more documentation and use the project more yourself if that will get you more users."], [-38, "[deleted]"]], [[{"comment": "TL;DR:  \n1. Your project doesn't have a license  \n2. Your project is GPL/LGPL licensed  \n3. You aren't maintaining the code  \n4. You don't have documentation or tests  \n5. You aren't using the project  \n\n> So when you license code as GPL, that license becomes viral whenever you distribute it, which means including the code in your own open source project. That is a showstopper for businesses wishing to incorporate code from these projects.\n\nAnd the question is, why should I care about my open-source code not being used by non-GPL-friendly businesses.", "id": "cy1edoz"}, {"comment": "[deleted]", "id": "cy1fmrj"}, {"comment": "It is usually for other reason, \"you can't take my code I've developed in my spare time and make money out of it without contributing back\"", "id": "cy252ul"}, {"comment": "Essentially, yes. The OP touched on this at the beginning:\n\n> There's a peculiar mix of altruism and egotism that goes into releasing an open source project. On the one hand, you might be solving a problem that others are struggling with, and sharing your solution will save them a lot of time. On the other, the near-fantastic rock star status of those who have created successful open source projects (think John Resig, Ryan Dahl, and Linus Torvalds) drives people to overshare in the hopes of also achieving such status.", "id": "cy1q2e2"}, {"comment": "It's not really that simple. You put your shit online because why hide it. Sure you might write some baller code that everyone loves, but that comes with so much friggin effort its not worth it. \n\nAll I'm saying is that there's way more than just altruism and egotism at play here.", "id": "cy1v9d0"}, {"comment": "And because Github/Bitbucket/Gitlab is an awesome free backup for your code.", "id": "cy1xy0t"}, {"comment": "> Only wimps use tape backup: real men just upload their important stuff on ftp, and let the rest of the world mirror it ;)\n\n[Linus Torvalds](http://www.webcitation.org/6P8EBZqQX)", "id": "cy2310r"}, {"comment": "> Linus Torvalds\n\nYou mean the guy who created git :P", "id": "cy234yr"}, {"comment": "Yes. This was before he did that.", "id": "cy237vp"}, {"comment": "Besides it can often be practical to snatch a function from someone elses code. In that case his arguments, besides from the license, are moot.", "id": "cy2f1jg"}, {"comment": "[Basically.](https://i.imgur.com/nYLoJ7C.jpg)", "id": "cy2e2ao"}, {"comment": "> And the question is, why should I care about my open-source code not being used by non-GPL-friendly businesses.\n\nIf you are a free software advocate, you largely don't. Nevertheless, many people who license things under the GPL don't seem to understand the restrictions the GPL puts on would-be users of your code. \n\nThis is much less of a problem than it was even just a few years ago, as MIT and 2-clause BSD licenses have become the standard for small, do-as-you-wilt libraries, but I still semi-regularly find LGPL'd projects in languages without any notion of dynamic linking with the author under the misimpression that people will be able to use the code in non-GPL/LGPL contexts.", "id": "cy1jvzi"}, {"comment": "> I still semi-regularly find LGPL'd projects in languages without any notion of dynamic linking\n\n^(Technically, dynamic linking isn't required; you have to be able to update and modify the LGPL'd code. Supplying the .o files to re-link the application statically works, too.)", "id": "cy1kylf"}, {"comment": "Points for technical correctness, but there's still lots of programming environments where there's no (already developed) way to allow end users to swap out library code without giving them access to the complete source.", "id": "cy1ln6w"}, {"comment": "> many people who license things under the GPL don't seem to understand the restrictions the GPL puts on would-be users of your code. \n\nConversely, many people are terrified of GPL because of the obligations they _think_ they put on them.\n\nE.g., some people believe you can't sell GPL software, which you very much can.", "id": "cybrah6"}, {"comment": ">If you are a free software advocate, you largely don't. Nevertheless, many people who license things under the GPL don't seem to understand the restrictions the GPL puts on would-be users of your code.\n\nNot users.\n\nThe GPL does not effect the users of your code at all. The only people it affects are people who modify the source code AND distribute the modified version.\n\n", "id": "cy2038c"}, {"comment": "I think it's very clear from context that in this case *user* means the person *using* your library in their codebase, not the would-be end-users of their project. \n\nBut, if we're going to play pedant, the GPL and LGPL certainly *effect* the end-users usage of their copy of the software, too. It's a legally binding license that they must agree to to use GPL-licensed software, after all. It provides them a great deal of grants in exchange for some considerations most end-users won't trigger.\n\n---\n\nFun question: if I give my friend a cd with a ubuntu live installer and charge him $1 for some combination of the medium and convenience, that means I'm commercially distributing the software and must myself either provide all source along-side or make a written offer to provide him a physical copy of the source, good for 3 years after I've given him the CD, right?", "id": "cy221ae"}, {"comment": ">I think it's very clear from context that in this case user means the person using your library in their codebase, not the would-be end-users of their project.\n\nI don't think it was clear. If you had said programmers who want to build on top of your code that would have been clear.\n\n>It's a legally binding license that they must agree to to use GPL-licensed software, after all.\n\nNo. The license says you don't need to agree to the license in order to use it.\n\n>Fun question: if I give my friend a cd with a ubuntu live installer and charge him $1 for some combination of the medium and convenience, that means I'm commercially distributing the software and must myself either provide all source along-side or make a written offer to provide him a physical copy of the source, good for 3 years after I've given him the CD, right?\n\nNo because you didn't modify it. The license says you are free to distribute without modification.", "id": "cy22sxm"}, {"comment": "> No. The license says you don't need to agree to the license in order to use it.\n\nThat's true that the GPLv2 says that, I don't think that's accurate for the GPLv3 though:\n\n>> This License explicitly affirms your unlimited permission to run the unmodified Program.\n\nSince everyone except the FSF and a few OpenBSD contributors think you do need a license to run a program, and then they explicitly granted you the permission to run the program in the license, I don't think any US court would say you're not governed by it. Though I don't think this has any particular effect if it were decided the other way.\n\n> No because you didn't modify it. The license says you are free to distribute without modification.\n\nI don't think that's correct. As a distributer, you must provide some mechanism by which the recipient can retrieve the source. If the distribution is unmodified and noncommercial, you can re-ship Canonical's source offer (because it is valid to anyone who receives the software), but if your distribution is commercial, I think you must satisfy the clause yourself\u2014either shipping the source along-side or making your own offer for providing the source on some durable media.\n\n>> c) Accompany it with the information you received as to the offer to distribute corresponding source code. (This alternative is allowed only for noncommercial distribution and only if you received the program in object code or executable form with such an offer, in accord with Subsection b above.)\n", "id": "cy2jx81"}, {"comment": ">I don't think that's correct\n\nRead the license. It's not that complicated. \n\n>As a distributer, you must provide some mechanism by which the recipient can retrieve the source. \n\nIf you didn't modify it then it's already there.\n\n>but if your distribution is commercial, I think you must satisfy the clause yourself\u2014either shipping the source along-side or making your own offer for providing the source on some durable media.\n\nIf you didn't modify it then you can ship it without problems. That was your original question. Now you have changed your question and are asking \"what if I took this software and modify it can I distribute it any way I want without being subject to the license\" The answer to that question is no. If you modify and distribute the license applies.\n\n", "id": "cy364la"}, {"comment": "> Read the license. It's not that complicated.\n\nI did\u2014you may have noticed the relevant quotation, which, as far as I can tell, says nothing about an exception for non-modification but rather for noncommercial distribution. That also seems to be [SFLC's reading](https://www.softwarefreedom.org/resources/2008/compliance-guide.html).\n\n> If you didn't modify it then you can ship it without problems. That was your original question. Now you have changed your question and are asking \"what if I took this software and modify it can I distribute it any way I want without being subject to the license\" The answer to that question is no. If you modify and distribute the license applies.\n\nEr, I've not said anything about modifications in regards to this hypothetical.\n\n", "id": "cy37lra"}, {"comment": ">Er, I've not said anything about modifications in regards to this hypothetical.\n\nYes you did. Let me quote you.\n\n>, but if your distribution is commercial, I think you must satisfy the clause yourself\u2014either shipping the source along-side or making your own offer for providing the source on some durable media.\n\n\n", "id": "cy37vma"}, {"comment": "Selling a CD is commercial distribution. I don't see where modification enters the discussion.", "id": "cy37yye"}, {"comment": "This is not true; for example merely linking against a GPL'd library will restrict me, even if I don't modify its source code.\n\n\"Distribution\" is one of the scariest parts, since it's not super clear what that means. Say my company customizes the Linux kernel and then allows a contractor to use a machine in which it's installed; is the company now required to make its modifications available to the contractor? After all this is \"offering access from a designated place,\" right? Whether you think the answer is yes or no isn't important; the concern is whether a court *might* interpret this unfavorably, and suddenly the company is in a bind.", "id": "cy21tib"}, {"comment": ">This is not true; for example merely linking against a GPL'd library will restrict me, even if I don't modify its source code.\n\nThat's pretty pedantic. \n\n> Say my company customizes the Linux kernel and then allows a contractor to use a machine in which it's installed; is the company now required to make its modifications available to the contractor?\n\nYes.\n\n> the concern is whether a court might interpret this unfavorably, and suddenly the company is in a bind.\n\nThe license is pretty clear. You must provide the source.\n\nIf you want to make use of free labor of others then you have to avoid the GPL.  This is why so many people use the GPL, because they don't want to provide free labor to you and your company. ", "id": "cy22tyi"}, {"comment": "Yep. \"Fuck you, pay me\". I accept payment in return contributions, but I also accept it in cash.\n\nThere are a few things I've licensed under GPL. If you want to use them, I'll be glad to sell you the code under a license of your choice. And if you don't want to pay me, why should I care if you use it?", "id": "cy1sg98"}, {"comment": "That would be a dual-license then and something that isn't solely licensed as GPL.  I would imagine the author would be OK with this.  I know the company I work for has paid commercial license fees for dual-licensed software.", "id": "cy22r3i"}, {"comment": "I think his point is pretty clear: if you hope your open source project will be ubiquitously used, like jQuery, and you want the associated fame and glory, then Gpl is a surefire way to prevent that from happening.", "id": "cy1init"}, {"comment": "My understanding is that by using any non-viral license you essentially give up any demands to be credited for your work. In particular, I can't see anything in MIT license that prevents distributing derivative work without mentioning the original authors.\n\nAlso, there's this tacit assumption that businesses using the software contribute significantly to author's fame. In case of jQuery, I'd actually expect free code like the snippets from StackOverflow to have way more impact.\n\nAnd that's Javascript that's inherently somewhat visible. Sometimes you have to go great lengths to realize that busybox is in fact there somewhere.", "id": "cy1jwej"}, {"comment": "[MIT requires crediting the authors.](https://tldrlegal.com/license/mit-license)", "id": "cy1mlaq"}, {"comment": "> I can't see anything in MIT license that prevents distributing derivative work without mentioning the original authors.\n\nIANAL but doesn't this mean you have to include to the `(C) <author name>` part (and hence credit the author):\n\n> The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.", "id": "cy1l1li"}, {"comment": "> if you hope your open source project will be ubiquitously used, like jQuery, and you want the associated fame and glory, then Gpl is a surefire way to prevent that from happening.\n\nThat seems like a testable hypothesis.\n\nLet's check to see if there are any popular GPLed software out there. If there are then you are obviously wrong.", "id": "cy203wj"}, {"comment": "In the article he's very clear about the project being a library as opposed to a binary for this restriction.  (Using a Linux distro is OK as is using Gimp or other compiled software.)  Also the term 'ubiquitous' implies it is used everywhere -- including business environments.  So let our testing hypothesis be \"are there any ubiquitous GPLed libraries out there that even most corporations use?\"", "id": "cy22tr3"}, {"comment": ">. So let our testing hypothesis be \"are there any ubiquitous GPLed libraries out there that even most corporations use?\"\n\nYea I am pretty sure there are tons of GPLed drivers being used. Also every GPLed product has tons of GPLed libraries in them.  In any linux distribution there are tons of GPLed libraries.  You knew that right?", "id": "cy22v43"}, {"comment": "That's why in any Linux distribution you won't find much non GPL code\u2026    \nAnd it is not linking to or using any GPL code.   \n", "id": "cy24hmk"}, {"comment": ">That's why in any Linux distribution you won't find much non GPL code\u2026\n\nyea so?\n\nAll you are doing is making my point. The guy said corporations don't use any GPLed libraries and you and I say they use tons of GPLed libraries.", "id": "cy36815"}, {"comment": "> The guy said corporations don't use any GPLed libraries and you and I say they use tons of GPLed libraries.\n\nNo, I'm saying they stay away from GPL whenever they can because they consider it \"a virus\".   \nConsider how much a Microsoft Office for Linux or an Adobe Creative Suite could have helped linux on the desktop.   \nI'm not saying it is a good idea or that I would like it, but that's what drive mass consumer adoption.   \nOn the other hand, it is the logical outcome of designing a system around the idea of free software, it obviously scares away closed companies, but that's not bad per se, it's just a fact.   \nSo if I'm working on a closed software or software licensed in a way that I cannot release *all* the source code, I cannot use GPL code and contribute back, because it would mean giving back everything, and I simply can't (regardless of what I would like to do).   ", "id": "cy3abby"}, {"comment": ">No, I'm saying they stay away from GPL whenever they can because they consider it \"a virus\".\n\nThat's clearly not true because in every major corporation there are tons of linux installs. Even in Microsoft.\n\n>Consider how much a Microsoft Office for Linux or an Adobe Creative Suite could have helped linux on the desktop.\n\nI am guessing not that much.\n\n>On the other hand, it is the logical outcome of designing a system around the idea of free software, it obviously scares away closed companies, but that's not bad per se, it's just a fact.\n\nBut it doesn't. Both Microsoft and Adobe have tons of GPLed stuff in their companies. \n\n>So if I'm working on a closed software or software licensed in a way that I cannot release all the source code, I cannot use GPL code and contribute back, because it would mean giving back everything, and I simply can't (regardless of what I would like to do).\n\nI know. You want to steal code, not contribute anything back. I understand that. But your desire to profit from the labor of others just makes you a bad person and is not relevant to the conversation here.\n\nThe fact is even Microsoft has GPLed stuff in their corporation. ", "id": "cy3awpn"}, {"comment": "> That's clearly not true because in every major corporation there are tons of linux installs. Even in Microsoft.\n> \n\nwhat does that even mean?    \ndo you know the difference between using a software and developing a software?   \nYou can **use** Emacs to write closed source software or Photoshop to make something creative commons...   \n\n> But it doesn't. Both Microsoft and Adobe have tons of GPLed stuff in their companies.\n\nand practically all of the people writing GPL software are using a ton of closed source software, so what?   \n\n> I know. You want to steal code, not contribute anything back. \n\nAre you 16 or what?   \nI never had a single issue with GPL and I'm sure the first time I met RMS you weren't even born\u2026   \nI'm just saying that if you work for Blizzard and you'd like to use that GPL engine you can't because that would mean releasing all the game code together with it.   \nWhat's so hard to understand?    \n\n> The fact is even Microsoft has GPLed stuff in their corporation.\n\nShow me a single Microsoft product licensed under the GPL...    \nMicrosoft and other corporations see GPL as a way to release something they don't want to support anymore relying on free support from the community, they don't have a strategy for releasing GPL software, on the contrary, they actively fight GPL.   \nOr they create foundations to separate the company from the free facade.    \nOr they inflate committees or free projects with people lobbying for them.   \nIt's nothing new\u2026   ", "id": "cy3b68s"}, {"comment": "Oh golly.  You caught me in a loophole of my own words!\n\nDid you read the article or just commenting on other people's comments?  I ask because it looks like the latter.  It's clear in the article that when he talks about using, he means *developing a software project that will be distributed and must include the library as part of distribution*.  Yes, practically all of us use open-source code all day long (thanks to Android phones, e-mail servers, etc...).  But that is clearly not what the article is about!", "id": "cy2a6oc"}, {"comment": "> he means developing a software project that will be distributed and must include the library as part of distribution.\n\nIf he meant that he would have said that. He said \"use\".\n\nI can't help it if he is incapable of expressing himself.", "id": "cy3660o"}, {"comment": "> I can't help it if he is incapable of expressing himself.\n\nOh, the irony\u2026", "id": "cy4lwgv"}, {"comment": "OK, you obviously didn't read the article.  All quotes must be taken in context.  If you read the article, it is obvious what he means by \"use\".", "id": "cy3l1cs"}, {"comment": "My rule is: if it's and end user program = gpl\n\nIf it's a library =bsd", "id": "cy1udgg"}, {"comment": "/thread", "id": "cy1vylv"}, {"comment": "Pretty much this, or at least LGPL for libs. I really don't care if someone closes my lib that does one stuff that can probably be recreated by any decent programmer in a week, but if someone wants to reuse whole app, contribute back.", "id": "cy254lj"}, {"comment": "Can you explain your reasoning?\n\nI mean, I understand some of the basis.. but what's specifically powerful for libraries that warrants a BSD license?\n", "id": "cy2e60l"}, {"comment": "> why should I care about my open-source code not being used by non-GPL-friendly businesses.\n\nAlternatively, why should I care whether the person using my code is GPL-friendly?", "id": "cy1kukf"}, {"comment": "It's the difference between cooperating towards a goal where people help a movement move in the direction of a common purpose where the improvements contributed by any one member are shared among the entire group vs volunteering to be an unpaid employee with no expectation of any reciprocation.\n\nPut it this way.  Nicholas C. Zakas is an employee of \"box\", whatever that is.  In the background section he talks about replacing custom code developed within box with open source code...\n\nWhy isn't all of box' code under mit or bsd license?", "id": "cy1mhn2"}, {"comment": "Box is not a software company, they are a service.  Box is similar in many ways to Dropbox.  How it works efficiently is a trade secret, which is why it's not in their interest to be bound by the GPL.  They're not interested in helping competitors.", "id": "cy20t98"}, {"comment": "Just so we're clear I was playing Devil's advocate there, pointing out that /u/arsv's isn't the only point of view.\n\nPersonally I would love it if all software was completely open sourced \u00e0 la GPL, but in my opinion all the GPL does is create two camps of people (those who are working in open source and those who aren't). In my opinion if we want more software (especially businesses) to move towards a more open work ethic we need permissive licenses like MIT so that people who can't open source their work can still use and contribute to open source.\n\n> Put it this way. Nicholas C. Zakas is an employee of \"box\", whatever that is. In the background section he talks about replacing custom code developed within box with open source code...\n\n> Why isn't all of box' code under mit or bsd license?\n\nI'm not entirely certain what you mean by that.", "id": "cy1nktu"}, {"comment": "> I'm not entirely certain what you mean by that.\n\nWhy doesn't box release all it's code with a permissive license mit or bsd style license?  They would get nothing out of it and people could use it or sell it all they wanted.  Why doesn't box release all their code like that?  Why does box use a license that explicitly forbids exactly what this guy is arguing for, bsd/mit licenses?\n\nIt doesn't make any *SENSE* /s", "id": "cy1o34a"}, {"comment": "Ah I misread that slightly, sorry.\n\nIt's because box is greedy and box is never going to release software under the GPL. What box might do however is release parts of their software (which don't directly make them any money) under a permissive open source license (Apple and Microsoft are two prime examples of this), which isn't ideal but is a huge step forward.", "id": "cy1okob"}, {"comment": "Parts that are fairly useless unless you have all the platform libraries that microsoft didn't open source in the case of .net for instance, iirc?  So yes, you can do math, but no, you can't, for instance, make a GUI.", "id": "cy1oowe"}, {"comment": "[Typescript](https://github.com/Microsoft/TypeScript) and [vscode](https://github.com/Microsoft/vscode) are both on there in their entirety, and there are a fuckton of other repos which look to be regularly updated. Call me an optimist but I would say that's a good thing.", "id": "cy1oxud"}, {"comment": "...  What's the benefit of typescript which compiles into javascript?  Is it compile time checks and development benefits of using oop?\n\nAnd vscode is a development tool for .net, which is basically lashed to microsoft platforms?\n\nI guess maybe vscode could be used as a basis for a similar tool with cross-language support?", "id": "cy1p6pe"}, {"comment": "> ... What's the benefit of typescript which compiles into javascript? Is it compile time checks and development benefits of using oop?\n\nOne would presume so, yes, but I'm not a JS dev so I couldn't give you a run-down of the benefits. But the point is Microsoft have created an entirely new language (which is their attempt to improve on JS) and have open sourced this language and it has absolutely nothing to do (as far as I can tell) with Microsoft-only software.\n\n> And vscode is a development tool for .net, which is basically lashed to microsoft platforms?\n\nAs far as I'm aware vscode is a programmer's text editor; nothing more, nothing less. But considering the fact that it's [aimed at web and cloud applications](https://code.visualstudio.com/) my guess would be that it has nothing to do with Microsoft platforms.", "id": "cy1pgg8"}, {"comment": ">It's because box is greedy and box is never going to release software under the GPL. \n\n\nNo. Box should release it under the MIT BSD license like the author advocates.", "id": "cy201kn"}, {"comment": "That is literally what I'm saying. ", "id": "cy21t68"}, {"comment": "Since I obviously haven't done a very good job of explaining myself, I'll break it down.\n\n1. In my ideal world all code would be open sourced and all programmers would contribute to all projects they use.\n2. I realise this is still a pipe dream at this stage.\n3. A big reason why this is still a pipe dream is because companies are scared of losing money (whether they actually would or not is another matter).\n4. There is precedent for comapnies open sourcing the parts of their code which doesn't directly make them money (Apple did it with swfit (and also contribute to LLVM), Microsoft did it with a bunch of stuff, Dropbox do it I believe), but I've only ever seen these licensed under either MIT or BSD.\n5. I don't think this would ever have happened if these projects had to be license under the GPL.\n6. Therefore I believe we _need_ permissive open source licenses (such as MIT and BSD), and that this push for GPL all the things is not really helping the state of open source as much as people think.", "id": "cy222lu"}, {"comment": ">I don't think this would ever have happened if these projects had to be license under the GPL.\n\nIf they were licensed under the GPL they would be forced to open it up.\n\nNot quite sure what you are getting at here.\n\n>Therefore I believe we need permissive open source licenses (such as MIT and BSD), and that this push for GPL all the things is not really helping the state of open source as much as people think.\n\nReal world evidence says otherwise but I guess you are free to think whatever you want.", "id": "cy22s3h"}, {"comment": "> If they were licensed under the GPL they would be forced to open it up.\n\nWhich is why they never would have released them under the GPL/used them if they were released under the GPL.\n\n> Real world evidence says otherwise\n\nIt really doesn't, they seem to be at best about equal. On the GPL side I can find Linux, MySQL, and Maidsafe.\n\nMeanwhile LLVM and co. have essentially been paid for by Apple and get many contributions from them (as well as Microsoft, ARM, Intel and others). Pyston is being developed by Dropbox. Typescript and vscode were developed by Microsoft. Netflix has a fuckload of stuff which I can't be arsed to troll through.\n\nFace it, GPL just isn't the open source revolution everyone thought it was.\n\nJust another bit of food-for-thought: the two biggest open source non-profits I can think of (Mozilla and Apache) both release all their stuff with permissive licenses.", "id": "cy23ege"}, {"comment": ">Personally I would love it if all software was completely open sourced \u00e0 la GPL, but in my opinion all the GPL does is create two camps of people (those who are working in open source and those who aren't). In my opinion if we want more software (especially businesses) to move towards a more open work ethic we need permissive licenses like MIT so that people who can't open source their work can still use and contribute to open source.\n\nI don't think so. Companies will only contribute if they are legally required to.", "id": "cy200v5"}, {"comment": "Because you don't want people to profit off your hard work. Helping people is one thing, and working for free is another. The GPL lets you do the first while avoiding the second.\n", "id": "cy1yi21"}, {"comment": "that depends on the level of the contribution you receive back.   \nsometimes money is better than shitty contributed code\u2026", "id": "cy4ly7q"}, {"comment": "Because you care about other people and you want to help the community.", "id": "cy20075"}, {"comment": "Then why aren't you using a permissive open source license (like MIT or BSD), instead of trying to further your agenda of making comanies do something they're never going to do. As I've said in other places all I think the GPL does is split programmers into two camps, if we truly want a unified world of software the first step has to be permissive open source licenses.", "id": "cy22b1y"}, {"comment": ">Then why aren't you using a permissive open source license (like MIT or BSD), instead of trying to further your agenda of making comanies do something they're never going to do. \n\nBecause the GPL is the only license which sustains a commons. \n\n>As I've said in other places all I think the GPL does is split programmers into two camps, if we truly want a unified world of software the first step has to be permissive open source licenses.\n\nNo all that license does is provide slave labor for corporations.\n\nCorporations are the only companies which object to the GPL because it won't let them profit from free labor.", "id": "cy22rds"}, {"comment": "Exactly. Unfortunately we don't live in perfect little world where corporations will suddenly drop everything to become open source companies, we do live in a world where we can coax them into open source using permissive licenses.", "id": "cy2319i"}, {"comment": ">Exactly. Unfortunately we don't live in perfect little world where corporations will suddenly drop everything to become open source companies,\n\nNo we live in a world where they constantly whine, bitch and moan about how they are not allowed to benefit from free labor.\n\n>we do live in a world where we can coax them into open source using permissive licenses.\n\nNot these companies. They are complaining they can't steal code, what makes you think they have any intent to contribute anything. ", "id": "cy233db"}, {"comment": "> Not these companies. They are complaining they can't steal code, what makes you think they have any intent to contribute anything.\n\nIt is not as black and white as you say. There is a lot of grey in the middle.\n\nLike if company writes custom sofware and sells it to their customers (with source code). They can't use GPLed code if their client doesnt accept it, but they are fine with more permissive licenses and contribute back.\n\nI even worked in the [company](https://github.com/TouK/) that gave their clients a discount if they allowed them to open source parts of the code.\n\n", "id": "cy25835"}, {"comment": ">It is not as black and white as you say. There is a lot of grey in the middle.\n\nnot that grey.\n\n>Like if company writes custom sofware and sells it to their customers (with source code). They can't use GPLed code if their client doesnt accept it, but they are fine with more permissive licenses and contribute back.\n\nGive me five examples of this. If as you say there is A LOT OF GREY then you should have no problems coming up with examples.\n\n", "id": "cy3679n"}, {"comment": "nah, you're waste of time", "id": "cy39ch5"}, {"comment": "Because they have. I'll do this just once more before I get bored:\n\n- Swift\n- LLVM (including clang)\n- Typescript\n- vscode\n- Other smaller Microsoft projects\n- Pyston\n- Other smaller Dropbox projects\n- A bunch (5 pages of github repos) of small Netflix projects", "id": "cy23h69"}, {"comment": "That's a tiny bit compared the amount of code they have taken from the community.", "id": "cy3694y"}, {"comment": "> And the question is, why should I care about my open-source code not being used by non-GPL-friendly businesses.\n\nExactly. If oyu goal is to create an environment around your product/software that is open-source you need the license. Else anyone can \"steal\" your work. I actually used the AGPL in a project of mine because GPL has the loophole that you can just offer web services and hence are not distributing the application and code and hence no need to disclose source code.\n\nAnother thing most lawyers and many IT people don't get is, that if you use it in-house only on the intranet, GPL doesn't matter because you are not redistributing the code. So your own code remains protected. That's why I think GPL is good for certain software. People can use it internally for free but if they want to directly make money from it, they have to contribute. GPL seems good for a specific high level problem.\n\nOf course for low-level projects, GPL is not very good. Your logging framework in GPL? Not a good idea. Your web framework in GPL / AGPL? not a good idea.", "id": "cy24mtn"}], [{"comment": "> So when you license code as GPL, that license becomes viral whenever you distribute it\n\nYep, that's precisely the point. What if I want my work only to be useful to people contributing back? And why should I care if businesses can't make money out of my work without giving anything back neither to me nor to the community?\n\nAnd, finally, why should I care _at all_ for you to use my product? I find this article to be extremely arrogant.", "id": "cy1fg63"}, {"comment": "> And, finally, why should I care at all for you to use my product?\n\nFrom the article:\n\n> realize that there is a significant bar for open source projects that are reliable enough to use in a product. If you want your project to succeed, you should be aiming for that bar.\n\nGranted, other people may have other definitions for what success is, but I think author is pretty clear about he means.\n\nYou don't have to care, but if you do, the article provides some guidelines. A lot of the article is commonsense. I understand using GPL for projects, but it's a fair point to bring up that many people might not otherwise consider.", "id": "cy1gnfa"}, {"comment": "Documentation and test coverage have more impact on \"reliability in production\", than the OSI license the authors decided on.", "id": "cy1l3bc"}, {"comment": "Most companies require both, so they're equally as important.", "id": "cy1psqf"}, {"comment": "> > realize that there is a significant bar for open source projects that are reliable enough to use in a product. If you want your project to succeed, you should be aiming for that bar.\n> \n> Granted, other people may have other definitions for what success is, but I think author is pretty clear about he means.\n\n^(Technically, the quote you quoted concerns reliability, which has nothing to do with licensing.)", "id": "cy1l17y"}, {"comment": "success defined in his terms, of course.", "id": "cy1i6s2"}, {"comment": "Thanks.", "id": "cy1if1s"}, {"comment": "Exactly. I don't write open source software to improve a businesses bottom line. If you want hundreds of hours of my free labor you have to accept it on my terms.", "id": "cy1gt96"}, {"comment": "[deleted]", "id": "cy1lcek"}, {"comment": "If open source developers got paid 2-3x market on average I think you would see a lot more open source work. But it's just not the case.", "id": "cy1y0yy"}, {"comment": "[deleted]", "id": "cy1z9kr"}, {"comment": "More often than not, they don't. Most of the time, what companies want to hear about is how much _money_ was involved, and whether there were _deadlines_. Free Software projects are generally distributed gratis, and few have hard deadlines to speak of.\n\nThe only exceptions are the projects your recruiter has heard of _beforehand_. Things like OpenSSL.", "id": "cy22tl7"}, {"comment": "[deleted]", "id": "cy2hpos"}, {"comment": "Source? My own job interviews, where I was _specifically_ asked about clients, sells, and deadlines, about a personal project of mine (an attempt at making a video game, for which I could show a simple demo).\n\nAlso, we also need to define what's a successful open source project. [This one](http://loup-vaillant.fr/projects/ussm/) is open source, and is successful. It does the job I need it to do, and even had a couple _users_ that wrote back to me \u2014one of them even fixed a bug. Find any employer who cares. OCaml and Haskell shops might. The rest of the world haven't even heard of those languages.\n\nYour definition of \"success\" may be different. You may have thought about _famous_ open source projects, or about _big_ open source projects (that necessarily have several, or even many, contributors). But if it's so big, you can't have done it all, so how would you impress an employer with it?\n\nNow if you're talking about being the _maintainer_ of something so famous even the recruiter has heard of it\u2026 Sure, that's very shiny on the resume. That's also utterly impossible. Few people in the world ever achieve this.\n\n---\n\nNow my actionable advice: don't start an open source project just for the sake of your resume. This is not an efficient way to make a resume. You will spend tons of unpaid time doing something most employers won't recognise the value of, because, well, nobody paid you for it. Instead, you should seek _jobs_, and the external validation they give: someone paying you makes your resume more attractive. (By the way, if you're currently unemployed, don't ever let it show in your resume. Put on vague dates, plug the holes, don't state the end of your last gig\u2026 unemployment is a stigma that feeds on itself.)\n\nIf on the other hand there is some project you'd *like* to work on, by all means do so! It probably won't help your resume much, but it certainly can't hurt.\n", "id": "cy2o8uc"}, {"comment": "> Source? My own job interviews,\n\nthat's just your job interviews, not the whole world.", "id": "cy4m2tk"}, {"comment": "Yeah, yeah, anecdotal evidence and all that. My point stands however: employers hardly care about your impressive coding skills. They care about your ability to use them to get them money.\n\nWhatever you're showing them, it has to convince them you're capable of delivering _money_. This means programming stuff people _pay for_, and programming it _fast enough_ \u2014under a deadline. Having done so in the past is a very good argument that you can do so in the future. If on the other hand you show them something with no paying customer and no deadline, you'd better show the link between that, and money.\n\nThe less technical the recruiter, the more pronounced the effect.\n", "id": "cy5gdtu"}, {"comment": ">But if you did (write the software) and you do (improve the business) then you've written your own ticket into any number of great job opportunities.\n\nBullshit. ", "id": "cy204xp"}, {"comment": "&gt;But if you did (write the software) and you do (improve the business) then you've written your own ticket into any number of great job opportunities. \n\nBullshit.\n\n([Obligatory](https://i.imgur.com/QyAPRAl.jpg))", "id": "cy3etxn"}, {"comment": "[deleted]", "id": "cy2ec74"}, {"comment": "[deleted]", "id": "cy2hzgx"}, {"comment": "You're reading into our statements wrong.\n\nThat quote is a carrot. The delusion is commonly deployed when the person saying it wishes to get work for a pittance so it 'helps our resumes'.\n\nThis is a common tactic in the software industry and **it's considered a red flag**.\n\nIt's not us, it's the contempt the person uttering that sentence has for software developers.\n\nOr fuck it, go ad hominem, your choice. Unfortunately.", "id": "cy3esma"}, {"comment": "[deleted]", "id": "cy3nym9"}, {"comment": "\"You're not making your code good enough for me to us it\" is an argument of contempt of the time of the developers making the software. It's not a \"here, let's bring it up to quality, here let's provide an incentive\".. no, it it reads as 'I want your code to do what I want but I don't want to pay for it'. \n\nThis comes up periodically when a businessman/developer has his taste of open source and the nuance of what 'open source' means (licensing, attitude, culture, community). Over and over this argument is made.\n\nThe open source developer has a fundamentally different paradigm than from the business concept of providing value to a business. \n\nPeople write open source for open source's sake. People write business software to make money. Though not mutually exclusive, it's a different MO. Different attitude.\n\n> the more pieces he has with which to negotiate his way into more positions, to negotiate a higher salary\n\nAgain, that's the carrot. \n\nIf you can make awesome software, you can do it period.. it has nothing to do with contributing to open source. If anything, contributing to open source shows community involvement.. THAT'S the power of open source. ", "id": "cy3oexg"}, {"comment": "[deleted]", "id": "cy3q5hn"}, {"comment": "That's what someone says when they want free labor.", "id": "cy2eafv"}, {"comment": "> Yep, that's precisely the point. What if I want my work only to be useful to people contributing back?\n\nBy *requiring* that any distributors of your code give back you limit the pool of people who *could* contribute to the subset that *can* thanks to various types of restrictions. Besides there's nothing in the GPL requiring that the output of GPLed code be open. So someone can still use your GPLed code all day long for their business without ever contributing back. Since they're not distributing the code they don't owe any modifications back to the GPL'ed project.\n\nThe GPL does not prevent others from making money off of your work nor requires them to feed back into a GPLed project so long as they don't distribute their modifications (or linked software etc). You're not guaranteed to get any input from people making money off your GPLed project.", "id": "cy1l088"}, {"comment": "And yet in practice don't gpl projects get more code contributed by companies than bsd or mit projects?", "id": "cy1mjmc"}, {"comment": "I don't think commit logs would bear that out. According to [Github's license survey](https://github.com/blog/1964-license-usage-on-github-com) around 62% of projects are using BSD, Apache, and MIT licenses. That would suggest commits from businesses are more likely to end up in those projects than GPL ones. ", "id": "cy26l0z"}, {"comment": "Maybe. Maybe not. ~~Maybe fuck yourself.~~ But we should definitely base any answers to that question on facts and figures.", "id": "cy1ns2v"}, {"comment": "OK.\n\nFreeBSD lines of code contributed by companies vs Linux.  Companies have contributed more to linux, willingly and unwillingly than they have to freebsd.\n\nMicrosoft, for instance, wants linux to run in hyper-V?  Well, obviously they violate the GPL.  Then they get sued.  Then they contribute the code.  Then they become one of the biggest (unwilling, court mandated) contributors to the linux kernel.  The linux community celebrates microsoft's contributions when they incorrectly believe are voluntary as the second coming of christ, and the dawn of a new era for microsoft.\n\nMicrosoft wants to get freebsd to work in hyper-V.  They do, and they don't commit a single loc.", "id": "cy1nywl"}, {"comment": "I don't agree that the licence has anything to do with the number of contributions. A company is very very rarely obligated under the GPL to contribute their changes back to the community. Unless you are selling the actual operating system with your custom kernel it just doesn't apply to you.\n\nHowever lots of companies contribute back because they don't want to maintain a fork, and that's true also for more free licences like BSD or Apache", "id": "cy1u1ct"}, {"comment": "> more free licences like BSD or Apache\n\n\"More free\" isn't accurate. While those licences do maximise the *individual* freedom of whoever has a copy of the software, not being viral means they don't maximise the *collective* freedom of all users, since some of those users probably have a proprietary copy/derivative work they can't look at nor modify.\n\n", "id": "cy235y1"}, {"comment": "What?", "id": "cy2pko9"}, {"comment": "I'll take that as a genuine misunderstanding. It's quite simple.\n\nA \"more free\" licence, as you put it, let you release completely _un-free_ derivative works. You're maximally free, but your users don't have to be \u2014you have the freedom to take away _their_ freedom.\n\nThe GPL on the other hand has *one* practical restriction: it forbids you to put _further_ restrictions in your derived works. In other words, by being \"less free\", the GPL actually guarantees the freedom of your users.\n\nNow which licence is indeed _more free_? The one that lets you do anything, or the one that guarantees the freedom of your users? Depends how you look at it, really.", "id": "cy2v4sy"}, {"comment": "I think you don't understand how copyright and licensing works. Licenses like the BSD and Apache licenses don't allow you to take anything away from other people. You cannot add your own code to a project and by doing so restrict people's freedom to use the original project. It just doesn't work like that.\n\nYou can only choose the license under which you give away your own original work. Under GPL you can choose to not give it away at all and keep it secret (if you don't distribute binaries, which is 99.99% of the time). Under any open source project with any license at all, if you choose to give away your work under a license more restrictive than the original project, then your work will not be incorporated into that open source project and most likely ignored.", "id": "cy55t05"}, {"comment": "^(Just so you know I wasn't actually telling you to go fuck yourself, I was quoting The Departed, sorry.)\n\nOn the flip side would something like Swift ever have been released under the GPL?^(I realise that wasn't a fact or a figure, just a point for discussion.)", "id": "cy1oced"}, {"comment": " > On the flip side would something like Swift ever have been released under the GPL?I\n\nIf Apple wanted contributions more than they cared about ubiquity, they could have. But Apple's business goals imply otherwise.", "id": "cy1slmr"}, {"comment": "But then they would have had to open source a lot of the rest of their software as well, and let's be realistic here they're never going to do that.\n\nSwift wasn't actually the best example here (Dropbox probably would have been better) but the point is these companies aren't going to go full open source, at least not for the forseeable future. What there is precedent for however, is them open sourcing the parts of their software which don't directly make them money which in my book is a huge step forward. In my opinion this has only happened because of the existance of MIT or BSD style licenses.", "id": "cy228rp"}, {"comment": "[Departed scene](https://s-media-cache-ak0.pinimg.com/originals/cd/50/60/cd5060bdac1d4eab166c0f31f600e1e3.gif)", "id": "cy1oikn"}], [{"comment": "Sometimes code is not maintained because nobody showed in the door saying they use the code.  If you love some project, tell the author.  If the author lose interest in something, and he or she think nobody use it, is going to be abandoned.  But if a piece is popular and people love it, is going to be more prone to get updates.", "id": "cy1ivyh"}, {"comment": "Fully agree with this.\n\nEDIT: Also, I have come across a few good projects that don't seem to be active (no recent commits), but mainly because the project is in a reasonably complete state with no obvious features to implement.", "id": "cy1iytu"}, {"comment": "Exactly. If my project isn't being used (as in I get 0 feedback) I will almost certainly further develop it if I no longer need it or the feature set is good enough for me.\n\nProblem is with open source you don't know, if someone is using it. So if you are using it either actually create issues on the issue tracker.  I used to think that it's logical to create an issue in case of problems but most users will just move on, and a few passively wait till bug is fixed.", "id": "cy24hpw"}, {"comment": "Actually Github now shows amount of views and git clones in Graphs->Traffic tab", "id": "cy250rt"}], [{"comment": "[deleted]", "id": "cy1e3lr"}, {"comment": "well, you would think about it... the question is what you would think :D", "id": "cy1fb07"}, {"comment": "actually, it's the first one I would think of, if I think about failing at security. ", "id": "cy4m0dw"}], [{"comment": "This author mistakenly believes that just because the source is provided gratis that the maintainence is also done gratis. The reason open source projects of this nature are open source is so that the cost of maintainence is shared between the people using it. \n\nThey don't have restricted licenses because it is in the best interests of the companies that need features or bug fixes to contribute patches or at least bug reports upstream lest they take the maintainence burden of the entire codebase in the form of a fork, or pay for maintainence in the form of a support contract.\n\nWhether GPL licensed or not, if the software is too expensive to maintain, don't fucking use it.", "id": "cy1zdfo"}, {"comment": "> Whether GPL licensed or not, if the software is too expensive to maintain, don't fucking use it.\n\n\nI think that's his point\u2026", "id": "cy4m4iy"}, {"comment": "The source of my disagreement is that the author seems to think that the end goal of open source developers is to have people use their code.\n\nThis completely misses the point of open source is supposed to be. Whenever you use an open source project, you have to factor in that it needs to be maintained. Almost all OSS is provided explicitly without a warranty for a reason. Whether it's a well known community project or some throwaway code someone pasted on github, the maintainence cost is never zero.\n\nThe author is saying that the maintainence cost must be zero for him in order to consider using it, meaning that he wants to have his cake and eat it too. If you use open source code, you own the copy of the code you are using therefore you are responsible for maintaining it.", "id": "cy6zw62"}, {"comment": "the problem is that IRL is the exact opposite.   \nyou own it, but you can't really maintain it, the risk is to diverge from the mainstream version in a way that will make any subsequent release useless or very hard to merge in.   \non the other side in almost every successful OS project getting PR merged is a very long process.   \nSo yeah, in theory it's great that you can contribute, in practice it rarely happens because the cost is too high.   \nI don't see it as 'I want the cake and eat it too' but more as 'there are cheaper cakes, no hard feelings'.  \nregardless of the fact that I think that free software is the best option we have ever had in history to really build a distributed network of humans improving each other's work, I cannot deny that [the 1% rule]( https://en.wikipedia.org/wiki/1%25_rule_\\(Internet_culture\\)) it's a real thing.", "id": "cy70cac"}, {"comment": "This doesn't change the fact that you're on the hook for any bugs the code may have, not the author the code. The author of a piece of OSS doesn't care whether you decide to use his code or not because he is not being compensated for his work, nor is he responsible if it fails when you use it. This article is trying to set standards for people with no obligation or incentive to meet them and that is my major problem with it.", "id": "cy7vtn0"}, {"comment": ">  The author of a piece of OSS doesn't care whether you decide to use his code or not because he is not being compensated for his work,\n\nNobody's happy if the code he wrote is not used.   \nEverybody likes to have a lot of stars on Github.   \nPopularity has a value itself.   \nWe're being a little bit out reality here\u2026\n\n> This article is trying to set standards for people with no obligation or incentive to meet them and that is my major problem with it.\n\nThat's not what I understood from the article.  \nI just read it as \"sometimes the gratis option is not the cheapest\"   ", "id": "cy81c7m"}, {"comment": "Successful open source code solves a problem that either the developer wanted to solve or certain stakeholders wanted solved. It is being used regardless of whether other programmers decide to use it or not, or are you honestly claiming that successful open source developers spend their time writing code solely for the sake of popularity? Even all the criteria the author set are met, there is no guarantee that the project will continue if the developers lose interest in it. If that happens the maintainence burden goes back on the author, which defeats the entire purpose of having these criteria in the first place.\n\nI have no response to your second point beyond the fact that I disagree with your interpretation. No point in arguing it further.", "id": "cy8et98"}, {"comment": "Successful open source projects are successful because people use them.    \nsolving problems is a marginal requirement for success. ", "id": "cy8fb71"}, {"comment": "> Successful open source projects are successful because people use them.\n\nThe response is literally the second sentence of my previous reply\n\n> solving problems is a marginal requirement for success. \n\nNo it is a prerequisite. If your code doesn't solve a problem other people have, they will not use your code.", "id": "cy8pkde"}, {"comment": "> No it is a prerequisite. If your code doesn't solve a problem other people have, they will not use your code.\n\n\n[na\u00efve](http://rosettacode.org/wiki/Hello_world/Text) - [at best](https://en.wikipedia.org/wiki/Brainfuck)", "id": "cy8tcqk"}], [{"comment": "Do you really think you are punishing these people by not using their project?\n\nObviously you don't which is why you also blog about it.\n\nBut I don't think you are hurting them as much you think are. I don't think you are going to convince any of them to change their behavior.", "id": "cy1zzg6"}], [{"comment": "> So when you license code as GPL, that license becomes viral whenever you distribute it, which means including the code in your own open source project. That is a showstopper for businesses wishing to incorporate code from these projects. (You can still safely use the code locally, such as running Linux on a server or using a build-time tool. It's just including the code in your application that can be problematic.)\n\nThis does _not_ affect businesses that use GPL in Software as a Service (SaaS), only businesses that wish to ship binaries. You can also get around this by invoking GPL programs and parsing their output. I also believe GPLv3 loosened the language, stating that the source can be \"made available\" instead of requiring it be bundled with the binaries.", "id": "cy1kztc"}, {"comment": "Yes, but a lot of large companies still won't touch it even so because the legal teams would (rightly or wrongly) rather not touch it with a barge pole.\n\nI'm firmly in the permissive licensing camp. So some people will make money off your work. Maybe they'll contribute back, maybe they won't. The only way you can ensure for certain that a company won't contribute back is to stick a GPL on it. ", "id": "cy1qy5j"}, {"comment": "> The only way you can ensure for certain that a company won't contribute back is to stick a GPL on it. \n\nCounter example: IBM, Intel, HP, Novell paying developers to work full-time on Linux. People are more likely to use, contribute, or donate to a project, if it's useful and interesting.", "id": "cy1umsz"}, {"comment": "That's a good counter-example. Linux is a bit of a special case I think, but I take your point.", "id": "cy2uwst"}, {"comment": "> The only way you can ensure for certain that a company won't contribute back is to stick a GPL on it. \n\nIt's also the only way to ensure for certain that *if* a company ships your code in a product, they'll pay you for it. Which matters more to some people.", "id": "cy1ysok"}, {"comment": "How often has that happened? I'm genuinely curious.", "id": "cy2uwdm"}, {"comment": "I don't know about the case of individuals, but dual-licensed commercial products (effectively the same thing) do exist - for example Qt, or many game engines.", "id": "cy302by"}, {"comment": "We don't use GPL in our product although I believe we could without any problems. I've submitted bug fixes and feature implementations to multiple permissive open source projects on the clock. My employer needed the changes, the maintainer wanted the changes, I did the work, employer/me doesnt have to maintain a separate fork. Everyone wins.\n\nMy pervious job and boss wouldn't allow GPL even for things that were clearly acceptable. Apparently they had been sued before over licenses, (not GPL), but had shell shock involving any non-permissive license.", "id": "cy1tx27"}, {"comment": ">My employer needed the changes, the maintainer wanted the changes, I did the work, employer/me doesnt have to maintain a separate fork. Everyone wins.\n\nNot really. If the free/open source library didn't exist in the first place or used GPL you would have to replicate the work and your employer would pay for it.\n\nSo with the proprietary-favouring licenses like MIT or BSD you've essentially reduced the cost to the business of *doing* business. They aren't paying license fees, they're only paying for the diff of your code which, to be frank, isn't very much money though it does produce a lot of value.\n\nNot everyone wins. Your employer and you win because you're getting something for free and your changes are cheap in comparison to all the patches and code that you're getting for free. The maintainer(s) of the software do not win, they don't get paid for all the time they're putting into the software.\n\nWant to make it a win-win situation? Get your employer to write a big fat check to all the open source projects that you're relying on to do business.", "id": "cy1vhl1"}, {"comment": "Actually we are paying for support from one of the projects, and I still did the changes, lol", "id": "cy26dk5"}, {"comment": "Sometimes it is just lawyers not wanting to deal with it, or rather just incompetent", "id": "cy25bxs"}, {"comment": "So they don't use any proprietary software at all in your company?", "id": "cy20730"}, {"comment": "Oh no, we pay for plenty of software! But I don't think any is gpl - at least not the area I work in.", "id": "cy26j3z"}, {"comment": ">Oh no, we pay for plenty of software! But I don't think any is gpl - at least not the area I work in.\n\nYou said restrictive licenses were banned. Proprietary licenses are restrictive.", "id": "cy366ii"}, {"comment": "Read it again. I said we don't use GPL at my current job or previous job. Then I said my previous boss had shell shock over non-permissive licenses. Meaning that he was overly concerned about them- not that we didn't pay for software.", "id": "cy3c2j8"}, {"comment": "> I said we don't use GPL at my current job or previous job\n\nBecause it's restrictive. That's what you said.\n\n>Then I said my previous boss had shell shock over non-permissive licenses.\n\nProprietary licenses are non-permissive\n\n>Meaning that he was overly concerned about them- not that we didn't pay for software.\n\nI'd quit if I were you. Your boss is retarded and can't make rational decisions.", "id": "cy3ugx0"}, {"comment": "I'll play your game of quotes. Let me break down the original comment for you in a format that you might understand:\n\n--------------------------------\n> We don't use GPL in our product although I believe we could without any problems.\n\n**What it is saying**\n\n - We don't use GPL in our product\n\n**What it is not saying but you somehow decided it did**\n\n- We don't use restrictive licenses\n- restrictive licenses are banned\n- we don't use any proprietary software in our company\n\n--------------------------------------------------------------\n\n> I've submitted bug fixes and feature implementations to multiple permissive open source projects on the clock. My employer needed the changes, the maintainer wanted the changes, I did the work, employer/me doesnt have to maintain a separate fork. Everyone wins.\n\nYou had no comments on this section - at least not yet. I included it just to be thorough. I'm sure I can look forward to some comments.\n\n--------------------------------------------------------------\n\n> My pervious job and boss wouldn't allow GPL even for things that were clearly acceptable.\n \n**What it is saying**\n\n- I don't work for this company anymore\n- They didn't allow GPL\n\n**What it is not saying but you somehow decided it did**\n\n- We didn't use restrictive licenses\n- Restrictive licenses are banned\n- That I still work for this company\n\n---------------------------------------------------------------\n\n> Apparently they had been sued before over licenses, (not GPL), but had shell shock involving any non-permissive license.\n\n**What it is saying**\n\n- My old employer and boss had shell shock involving any non-permissive license\n- Shell shock: 'psychological disturbance caused by prolonged exposure to active warfare, especially being under bombardment.'\n- In this context it means my old boss and employer were abnormally concerned and worried over any non-permissive license. \n\n**What it is not saying but you somehow decided it did**\n\n- We didn't use restrictive licenses\n- Restrictive licenses are banned", "id": "cy3voah"}, {"comment": ">What it is not saying but you somehow decided it did\n\nHe specifically used the phrase \"restrictive licenses\".\n\n\n>My old employer and boss had shell shock involving any non-permissive license\n\nProprietary licenses are restrictive.\n\n>In this context it means my old boss and employer were abnormally concerned and worried over any non-permissive license.\n\nAs I mentioned his boss is mentally ill and is incapable of making rational decisions. He should quit.\n\nAs an aside since the number companies actually sued for GPL violations are so few we can probably figure out which company he works for and who this mentally ill boss is.\n\nIf he had claimed his boss was sued for software patents by Microsoft then it would be so much harder since Microsoft threatens and sues hundreds of companies every year for patents and license violations.", "id": "cy454tq"}], [{"comment": "On the positive side, with open source you know what you get, and you can improve the product in several ways, assuming the project is alive and maintained.\n\n\nOver the years I have realized that the state of most proprietary software is even worse than what you find in open source.\nSoftware is often terribly old, has been unmaintained for long periods of time, and only get some patchwork done when it no longer works on a modern OS and the owners finds it absolutely necessary to hire a fixer.\n\n\nThe process of buying software, at least for governments and official entities, also makes it close to impossible to avoid ending up with more or less useless software solutions. The restrictions and limitations surrounding such deals are often completely crippling for the buyer, and it doesn't make things easier when the whole thing is created by lawyers, for lawyers. A non-technical customer is pretty much powerless and can only hope to get through the process without lethal wounds.", "id": "cy1t9vb"}], [{"comment": "\"A lack of documentation means I need to dig through the code to figure out how to use it and a lack of tests means there's no way to tell when something breaks\"\n\nIf your code is so fragile and difficult to work with that you need tests to tell you if you've broken something, then you need to go and flush your code down the crapper, where it belongs.\n\nTests are there to help you design and make your code easy to refactor and understand, and that it fits a particular contract.   Its not there to tell you that something has broken.  What I mean is if you change something in one area of your code, which causes a test to fail in a totally different area, then your code is fucked....no amount of tests will fix it.", "id": "cy20ibo"}, {"comment": "Regression tests are a thing, so you may be the odd one out here.\n\nWith that said, you should have tests covering *your* functionality; if a library breaks to the point where your functionality is affected, your tests should discover it. You shouldn't need my tests for that...", "id": "cy2235j"}, {"comment": "> If your code is so fragile and difficult to work with that you need tests to tell you if you've broken something...\n> \n> ...\n> \n> Tests are there to help you design and make your code easy to refactor...\n\nSo why do tests make code easy to refactor?", "id": "cy29w2l"}], [{"comment": "now _*I*_ feel frustrated though the author is. And I really don't get the idea behind the activity. When I learned Ada, I found code from 1985 that still works today.", "id": "cy1mi76"}, {"comment": "Author writes JS and HTML. Those are clusterfucks of incompatibility (altho it gets better than in IE6 days)", "id": "cy25cyz"}, {"comment": "oh, yes, you are right; I haven't thought about it.", "id": "cy2iyme"}], [{"comment": "The one part of this article that I strongly agree with is that we have to be better about documentation, people like to make cool stuff no one can use", "id": "cy1ugee"}], [{"comment": "Whether or not you like what the article is saying, knowing is better than not knowing, IMO. You can decide for yourself which of things listed that you want to change. For instance, you could decide you are not going to change when it comes to GPL, but you are willing to do more documentation and use the project more yourself if that will get you more users.", "id": "cy2gfla"}], [{"comment": "[deleted]", "id": "cy189ud"}, {"comment": "[deleted]", "id": "cy19ck5"}, {"comment": "He's a troll, just ignore him.", "id": "cy1y1wv"}, {"comment": "[deleted]", "id": "cy1bmyx"}, {"comment": "And I still don't understand what your username means.", "id": "cy1en9g"}, {"comment": "I think leiva is a common last name in south america.", "id": "cy1kp9x"}, {"comment": "Did go on a rant about yankee imperialism in Spanish once...", "id": "cy1x14t"}, {"comment": "It's North Korean slang for the pleasure felt when you shove wooden spoons up your butt while saluting the leader (so to speak). It is so very much unlike the pleasure felt when using Java, so he feels the constant need to reaffirm that - it being quite a different thing after all.", "id": "cy23gxs"}]]], "4pxeii": ["Why is Object-Oriented Programming today's key programming methodology?", "2016-06-26 15:37:51", 0, "https://www.quora.com/Why-is-Object-Oriented-programming-todays-key-programming-methodology/answer/Richard-Eng-1?srid=iCOB", [[48, "> because it was more intuitive, more natural to the way people think\n\nThat's debatable. I've never found OOP to be particularly natural in real use cases. Sure, the textbooks have some crap like Car extends Vehicle extends Machine, but that's just simplified fantasy. There are very few instances where the real world can be modelled that way, and even if you find one there will be exceptions (I'm looking at you, platypus) that require hacks to fit. I think when people say that OOP is natural, it's because they've been trained to believe that.\n\n> It\u2019s much easier to model the world as a collection of collaborating objects than as a collection of cooperating functions.\n\nNo, it's not. But it is a lot harder to reason about a program consisting of a collection of stateful objects. I think people dismiss functional programming because its not immediately obvious to them how certain problems can be solved by composing functions. It's not that it can't be done, it's that they never learned the techniques.\n\n> it is, after all, based on the lambda calculus\n\nNon sequitur. All programming models have a mathematical formalism. Lambda calculus turns out to be a very elegant and simple one.\n\n> It\u2019s harder to model the world as functions and data. People simply do not think this way.\n\nPerhaps some people don't, but many of us do think in terms of data and transformations. \n\n> Pragmatically, OOP is a better way to organize very large code bases.\n\nThis deserves a wat. Especially since the author cites Python as an example of a success story for OOP. I would rather slit my wrists with a circular saw than work on a million line Python program. \"FP languages? Not so much.\" Citation needed.\n\nI'm not trying to bash on OOP, as it's a good fit for many problems. However, I can't stand this kind of uninformed nonsense."], [27, "Quora. Where opinions become facts."], [17, "[deleted]"], [18, "Rather than any abstract modularity benefits that OO might bring, I think the \"killer app\" was the need for programming first GUIs for mid 1980s/early 90s micro computers  (Macintosh, Atari ST, Amigas and then first Windows PCs).This was a time when programming was usually taught using some procedural language (BASIC, Pascal or even C) and sudently new and existing programs need to be use the mouse, react to events, etc. OO was a reasonable good fit because you have many widgets (naturally organized into into hierarchies) but the number of operations is fixed (cf. Wadler's [expression problem](https://en.m.wikipedia.org/wiki/Expression_problem)).  This is also why languages such C++ or Objective-C and many object extensions of Pascal became popular --- rather than switch to a \"pure\" OO paradigm such as Smalltalk.\nIt was only later in 90s (by the time Java came about) that OO started to be taught (poorly, in my opion) as a paradigm for modeling the \"real world\".\n"], [9, "Inertia. When C++ came into existence, the other industrial grade languages were Pascal, Fortran, C, etc., and functional paradigms were mostly found in research languages. You can argue with me about Lisp's role in industrial software, but in terms of size, C dominated. C++ brought in features from Smalltalk, which in terms of output binary, had a negligible increase in size, during a time when the bytes in RAM and Spinning Media were at a premium. C with Classes had a familiar syntax, so migration to it was easier."], [2, "The most significant difference between most functional and OOP languages (once we put aside isomorphic constructs like a closure and an object), and this is the mutability of variables.\n\nOOP languages typically have less discipline regarding mutable state, which affords more flexibility, especially when the code we write heavily interacts with the world around us. It also allows more bugs and problems, that's the trade-off.\n\nAnd the second difference is lazy execution. While good for pure mathematical modeling, it makes code performance somewhat unpredictable and has pathological edge cases. Which is why in OOP languages there's no implicit laziness. Instead of you want laziness you wrap on-demand logic in a method and call it explicitly when needed.\n\nSo in short, functional is stricter, more idealistic, but a lot less practical for modeling the kind of problems programmers model day to day. And functional is better for modeling purely mathematical problems (including pure data transforms etc.). It has its place."], [1, "I'll take a wild guess and say that it's because tab completion in IDE's is much more straight forward and narrows down much faster when you are constrained to operating on values with only the package of functions they carry with them."], [1, "The premise is wrong. It isn't. It only looks like it because structured programming is now seen as obvious and implicit. "], [1, "Conspicuously missing from this discussion is anyone providing examples of really large, purely-FP applications. Can anyone point to a pure FP application that runs close to a million lines of code?"], [1, "Jesus. The anti-OOP brigading in this thread is embarrassing. "], [0, "Haven't read the article yet, but I will. If I had to guess its about control and management of teams of developers of vastly varying skill levels. \n\nJust seems easier for me to isolate a junior developer into a couple classes to get the work done. \n\nThat being said I work in a very OO framework so the structure is all already there. "], [-3, "Because it allows us to program around *interfaces* which can be associated with arbitrary data as needed, allowing part of a program to receive objects which will fulfill a role, but without having to specify how or with what data structures ahead of time and without excessive boilerplate or typecasting on order to get it to work. It's this flexibility that is valuable, not really much to do with conceptual hierarchies (I hate 'zoo animal' classes)."], [-2, "Most computer scientists (let alone language designers, developers) don't bother to understand their tools beyond some informal mapping onto an idealized processor/memory. \"OOP\" slaps together a bunch of different features into a single language mechanism that has a relatively easy to understand implementation. \n\nIt's only a \"natural way of thinking\" in that people prefer to reason by fuzzy analogies to the \"real world\". And of course, the marketing effort that made sure it's how the vast majority of students are introduced to programming probably helps it seem \"natural\"."], [-5, "A complex system deals with a lot of different types of data. Different functionality can be separated into different programs (like: make, link, cc, ls).  \n \nIn a object-oriented system, you focus on the abstractions of this data. Which makes the handling of different types of data more easy, if this data has some kind of similarity.  \n\nWe can see this in reality. Very big systems are based on object-oriented structures. Smalltalk and Java and C# are huge.  \nVery big programs can be written in a short period. \n\nThey can be very quickly adapted to small changes in data-structures. Something that happens often in the process of development of commercial software. Shops want to add a few new products, or add new ways of payments.  \nThese adaptions often have the structure of: add more data types, keep the same functionality.  \nThe OO system also works well with simulated environments with lots of (different) objects, like computer games. ELM copied the MVC pattern in its functional programming system to make the implementation of games easier.\n\nThe complexity of it's functionality depends on the language. In C++ the functionality is very limited, due to the complex nature of C++. Then comes Java and next C#. The OOP has a bad name due to C++ and Java. Complex functionality can become even more complex due to the language systems.\n\nSmalltalk can create very complex functionality without real problems. It was based on Lisp. Smalltalk had closures built in from the start. It uses some functional constructs, which avoids quite some coding in some places. Smalltalk's dynamic typing allows some amazing tricks with lists and dictionaries.\n\nThe correctness and maintenance of these systems is a different problem. And low-level speed if your system uses a lot of late-binding and dynamic types.  \nBut these things are not what brought OO to the market. \n\nModern functional programming also uses OO tricks, while complaining about it. Erlang uses actors. Other use type-combinations to implement the same functionality for different types of data.  \nGenerally this works very well for small or well defined systems, and give the advantage of early binding which gives speed and certainty.\n\nMy proposal is to combine both, and get the best of each approach.  \n\nIn my [own programming language (unseen)](/r/unseen_programming), I am doing exactly that. I use functional programming to compose function-components on a low level (with some extra logic). I use classes to define systems on a higher level. \nI use both tests and types to define the validity of the functions.  \n\nIn normal text-programs this would become complex, but it is a graphical system that does not need text at all.\n\n---  \nAdded: \n\nHaha.. I think that am caught in a battle between:  \n\ndynamic versus static  \noop versus functional   \nTDD versus types  \n\nFor me these are shades of grey.\n\nSadly most people do not understand the real power of OOP and dynamic programming.\nAnyone know Python? Or ruby?  \nFor a completely dynamic and oop system,  \nI would advice people to try [Smalltalk / Pharo](http://pharo.org/) some time.  \nIt is just amazing how much it can do.  \n\n"], [-8, "Because we think in terms of objects, methods and properties..."], [-7, "It's you again, still with the same epic degree of ignorance."]], [[{"comment": "> because it was more intuitive, more natural to the way people think\n\nThat's debatable. I've never found OOP to be particularly natural in real use cases. Sure, the textbooks have some crap like Car extends Vehicle extends Machine, but that's just simplified fantasy. There are very few instances where the real world can be modelled that way, and even if you find one there will be exceptions (I'm looking at you, platypus) that require hacks to fit. I think when people say that OOP is natural, it's because they've been trained to believe that.\n\n> It\u2019s much easier to model the world as a collection of collaborating objects than as a collection of cooperating functions.\n\nNo, it's not. But it is a lot harder to reason about a program consisting of a collection of stateful objects. I think people dismiss functional programming because its not immediately obvious to them how certain problems can be solved by composing functions. It's not that it can't be done, it's that they never learned the techniques.\n\n> it is, after all, based on the lambda calculus\n\nNon sequitur. All programming models have a mathematical formalism. Lambda calculus turns out to be a very elegant and simple one.\n\n> It\u2019s harder to model the world as functions and data. People simply do not think this way.\n\nPerhaps some people don't, but many of us do think in terms of data and transformations. \n\n> Pragmatically, OOP is a better way to organize very large code bases.\n\nThis deserves a wat. Especially since the author cites Python as an example of a success story for OOP. I would rather slit my wrists with a circular saw than work on a million line Python program. \"FP languages? Not so much.\" Citation needed.\n\nI'm not trying to bash on OOP, as it's a good fit for many problems. However, I can't stand this kind of uninformed nonsense.", "id": "d4okxz7"}, {"comment": "> Sure, the textbooks have some crap like Car extends Vehicle extends Machine, \n\nThis isn't what OOP is about. OOP is largely about bundling mutable state with code which works with it. Inheritance is just an optimization trick which isn't really fundamental.\n\n> There are very few instances where the real world can be modelled that way,\n\nPretty much everything can be modeled using mutable state and functions.\n", "id": "d4ow0wm"}, {"comment": "I agree, which is why I believe that OOP should be seen as methods enabling practical ways of composing, a) Interfaces and b) Data structures. To mix these things up together while taking on the naive approach of conceptually \"modelling the real world\" as if it ought to match up with the specific structures in a program is a horrible mistake conceptually, and something that should be de-emphasized in education.", "id": "d4omn0h"}, {"comment": "Limit your interfaces to a single method and simply call them functions. It also helps to make your data immutable.", "id": "d4oofo7"}, {"comment": "> I agree, which is why I believe that OOP should be seen as methods enabling practical ways of composing, a) Interfaces and b) Data structures.\n\nI.e., instead of admitting that OOP is a bad idea, you prefer to redefine it to mean good ideas shared by *every paradigm*, so that you don't have to admit to having being wrong in the first place.  (Bonus points if you then suggest that those other paradigms are therefore \"forms of OOP.\")", "id": "d4osiqz"}, {"comment": "> (Bonus points if you then suggest that those other paradigms are therefore \"forms of OOP.\")\n\nFunctions are objects. QED /s", "id": "d4oypa4"}, {"comment": "Not only is Python a success story for OOP, so is Smalltalk. Both languages have been used to successfully write applications in the hundreds of thousands of lines. A decade ago, Smalltalk was used to write a *million-line* battle simulation program for the U.S. joint military called JWARS. I had the pleasure of speaking to one of the project architects. The software was quite manageable. And, of course, it was entirely object-oriented, because with Smalltalk you don't have any bloody choice!\n\nYes, it *is* debatable. That's why we're debating it here. Whether OOP is more natural or not, clearly it is widely accepted. The real question here is whether FP will ever be as widely accepted. Despite its penetration into the major OOP languages (with the addition of lambdas), *it remains to be seen* whether FP will actually be widely used. It's too early to tell. And I have my doubts.", "id": "d4qtrn3"}, {"comment": ">Not only is Python a success story for OOP, so is Smalltalk. Both languages have been used to successfully write applications in the hundreds of thousands of lines.\n\nSame can be said for COBOL though. If you spend enough time and money, you can write a large application in brainfuck as well.\n\nThe real question is how these solution stack up to similar ones that are written different paradigms.\n\n>The real question here is whether FP will ever be as widely accepted.\n\nThat's not really a question. FP is already widely accepted, what we're seeing now is move towards FP + immutable data. FP is very widely used, and especially so for greenfield development.", "id": "d4rnw1t"}, {"comment": "> FP is very widely used\n\nThat's just your opinion. I happen to disagree with it. I don't see the evidence of wide use, esp. not at the same scale as OOP.", "id": "d4rzzrv"}, {"comment": "It's not an opinion, FP is used in pretty much every domain nowadays. It's used at large companies for mission critical projects, and the usage is growing rapidly. Saying that an established paradigm is more widely used is a tautology.", "id": "d4s2qql"}, {"comment": "I know FP is used by some companies. It would be absurd to suggest FP is not used at all. **But I've not seen evidence of broad use**, certainly not to the extent of imperative/procedural nor object-oriented paradigms. Just saying that it's used in pretty much every domain does not make it so. I can say that Smalltalk is used in nearly every domain, but that doesn't make it so.", "id": "d4s5v5m"}, {"comment": "Broad use is pretty subjective. Erlang has been dominating the telecom sector for years. Some of the [largest telecom apps](https://pragprog.com/articles/erlang) are written in it. Meanwhile Walmart uses FP [at scale](http://blog.cognitect.com/blog/2015/6/30/walmart-runs-clojure-at-scale) in their own words.  So does Amazon and many other large companies. If OO did the job, these companies would use it. Their goal is to make money, and they have no skin in the game when it comes to language popularity.\n\nFP languages are increasingly used for large scale mission critical projects in the industry. Just because you personally haven't bothered to look up how widely used FP is, doesn't mean it's not.", "id": "d4s8bji"}, {"comment": "> Sure, the textbooks have some crap like Car extends Vehicle extends Machine, but that's just simplified fantasy. There are very few instances where the real world can be modelled that way, and even if you find one there will be exceptions (I'm looking at you, platypus) that require hacks to fit.\n\nAnd even when it does make sense, something changes next week and suddenly the cute little class hierarchy no longer works at all. As Uncle Bob said, you should be making the most important architectural choices as late into development as possible, and OOP is all about locking things down early and making change as difficult as possible.", "id": "d4or4zi"}], [{"comment": "Quora. Where opinions become facts.", "id": "d4oopi9"}, {"comment": "s/Quora/The Internet/", "id": "d4oqr69"}, {"comment": "Where are facts facts then?", "id": "d4ox1ep"}, {"comment": "Nowhere!\n\nActually, I don't know. I was just being silly with my previous comment.", "id": "d4p3f8b"}], [{"comment": "[deleted]", "id": "d4ojomf"}, {"comment": "It doesn't work well. It might work well enough, but even that is debatable.", "id": "d4opcyq"}, {"comment": "[deleted]", "id": "d4otsxr"}, {"comment": "You could say the same about PHP. The most popular tool is not always the best.", "id": "d4ou79c"}, {"comment": "[deleted]", "id": "d4ov69c"}, {"comment": "I have no idea what your point is", "id": "d4ox3e5"}, {"comment": "[deleted]", "id": "d4ox4h2"}, {"comment": "My point is that popularity != quality. Just because a large part of the web runs on PHP doesn't mean it's the best tool for the job, same goes for OO, and Donald Trump for that matter. Is Comcast a the best company because most of us are forced to use its service?\n\nI don't actually have a bone to pick with OO, I simply have a problem with you correlating quantity with quality.", "id": "d4ox70b"}, {"comment": "In the 90's, the people who decided \"what's best\" were educated engineers with many years of experience programming. Popularity today is measured by amateurs and hobbyists.  \n\nOO has quality __and__ quantity in its favor.", "id": "d4pu2l5"}, {"comment": "[deleted]", "id": "d4ox8pv"}, {"comment": "> It works so well the modern world is built on it. Not up for debate.\n\nOh give me a break... these are your words.", "id": "d4oxb3s"}, {"comment": "By that logic, I would have to eat shit for every meal, because billions of flies can't be wrong.", "id": "d4oxe1u"}, {"comment": "Do you feel that you are living in a world full of stable software? The software that is stable (and which the modern world is actually built on) is the software that is NOT object-oriented.\n\nThe modern world is not built on node.js-apps and java servlets.", "id": "d4ovgrh"}, {"comment": "OO works extremely well, denying that is absurd.", "id": "d4puc8x"}], [{"comment": "Rather than any abstract modularity benefits that OO might bring, I think the \"killer app\" was the need for programming first GUIs for mid 1980s/early 90s micro computers  (Macintosh, Atari ST, Amigas and then first Windows PCs).This was a time when programming was usually taught using some procedural language (BASIC, Pascal or even C) and sudently new and existing programs need to be use the mouse, react to events, etc. OO was a reasonable good fit because you have many widgets (naturally organized into into hierarchies) but the number of operations is fixed (cf. Wadler's [expression problem](https://en.m.wikipedia.org/wiki/Expression_problem)).  This is also why languages such C++ or Objective-C and many object extensions of Pascal became popular --- rather than switch to a \"pure\" OO paradigm such as Smalltalk.\nIt was only later in 90s (by the time Java came about) that OO started to be taught (poorly, in my opion) as a paradigm for modeling the \"real world\".\n", "id": "d4otkoh"}], [{"comment": "Inertia. When C++ came into existence, the other industrial grade languages were Pascal, Fortran, C, etc., and functional paradigms were mostly found in research languages. You can argue with me about Lisp's role in industrial software, but in terms of size, C dominated. C++ brought in features from Smalltalk, which in terms of output binary, had a negligible increase in size, during a time when the bytes in RAM and Spinning Media were at a premium. C with Classes had a familiar syntax, so migration to it was easier.", "id": "d4opmf8"}], [{"comment": "The most significant difference between most functional and OOP languages (once we put aside isomorphic constructs like a closure and an object), and this is the mutability of variables.\n\nOOP languages typically have less discipline regarding mutable state, which affords more flexibility, especially when the code we write heavily interacts with the world around us. It also allows more bugs and problems, that's the trade-off.\n\nAnd the second difference is lazy execution. While good for pure mathematical modeling, it makes code performance somewhat unpredictable and has pathological edge cases. Which is why in OOP languages there's no implicit laziness. Instead of you want laziness you wrap on-demand logic in a method and call it explicitly when needed.\n\nSo in short, functional is stricter, more idealistic, but a lot less practical for modeling the kind of problems programmers model day to day. And functional is better for modeling purely mathematical problems (including pure data transforms etc.). It has its place.", "id": "d4olzd6"}, {"comment": "> The most significant difference between most functional and OOP languages (once we put aside isomorphic constructs like a closure and an object), and this is the mutability of variables.\n\nNot true. There are FP languages that support mutability too (OCaml and Scala come to mind).\n\n> OOP languages typically have less discipline regarding mutable state\n\nNo, languages don't have discipline. Developers do.\n\n> especially when the code we write heavily interacts with the world around us.\n\nThe world around us is heavily mutable. Things change internally instead of producing a clone with just a few bits modified.\n\n> So in short, functional is stricter, more idealistic, but a lot less practical for modeling the kind of problems programmers model day to day. And functional is better for modeling purely mathematical problems (including pure data transforms etc.). It has its place.\n\nThat I totally agree with.\n", "id": "d4omrep"}, {"comment": "> The world around us is heavily mutable. Things change internally instead of producing a clone with just a few bits modified.\n\nThere's quite a philosophical debate about this.  If I write \"1, 2, 3\" on a sheet of paper, show that list to someone, then add \", 4\" and show them again, they haven't forgotten that the old \"1, 2, 3\" list existed.  The concepts of state and identity is a topic in many talks by Rich Hickey, and I highly recommend watching those; they are mind-opening and entertaining.\n\nAs to what the interface of \"real world things\" should be, that is another debate: we have long stopped programming at the individual bit level and instead opted for high-level constructs; we understand it's not the true nature of the computer, but it makes things simpler for us.  If one accepts that things in the real world are mutable, we still need to argue that it makes sense to present that mutability as-is rather than abstracting it away in a more manageable higher-level abstraction.", "id": "d4oqcl8"}, {"comment": "> The world around us is heavily mutable. Things change internally instead of producing a clone with just a few bits modified.\n\nNot to get all philosophical, but the distinction you're driving at here seems meaningless.  Hume went off on quite a tangent wondering how we can connect events through time (is the me that throws a bowling ball connected to the act of a bowling ball striking pins a few seconds later?)  He saw a series of events that we associate causally due to their co-location in time and dove quite deeply into the question of are they actually connected or not.  It's a fun mental game to play (like a lot of philosophy) that ultimately highlights that for most problems, I don't care if I'm looking at a clone with a few bits flipped or a mutable object.  \n\n**However** if I don't much care about the implementation, but using one method or the other allows me to write code that's easier to reason about and test, I will choose the later.\n\n> > So in short, functional is stricter, more idealistic, but a lot less practical for modeling the kind of problems programmers model day to day. And functional is better for modeling purely mathematical problems (including pure data transforms etc.). It has its place.\n> That I totally agree with.\n\nI just don't see it.  This is a super broad statement with no evidence or clearly defined terms.  I see such a disconnect between the reality of FP and what people claim about it that I'm regularly at a loss reading these posts.  In OO you've grouped together data and functions acting on that data.  In FP you've separated the two but are free to rejoin the two if you really want with a minor closure or two.  That's the big earth shattering modelling improvement we're talking about here?  That FP is less practical because data isn't automatically grouped with functions?   Practically speaking I see people do that 24/7 in OO code by defining a bunch of static methods that act direct on data heavy objects (you can tell me they're doing OO wrong and they probably are, but w/e, it happens *constantly*).  \n\n", "id": "d4oqgqk"}, {"comment": "> The world around us is heavily mutable.\n\nFacts don't mutate.", "id": "d4osevz"}, {"comment": "They do in the world of science.", "id": "d4qg450"}, {"comment": "An example?", "id": "d4qgy62"}, {"comment": "Light is a class of wave which propagates via the luminiferous aether.\n\nDinosaurs were a class of ancient reptile which existed millions of years ago.\n\nPluto is a planet.", "id": "d4r7wn4"}, {"comment": "Those are classifications and hypothesis, not facts. They were always open to investigation.", "id": "d4r8lgp"}, {"comment": "Ah, this must be some strange new usage of the word \"fact\".", "id": "d4rjxdk"}, {"comment": "The word you are looking for is \"deconstruction\", which within itself is a fact too. ", "id": "d4rmb4v"}, {"comment": "By \"the world\", I mean the physical world.\n", "id": "d4ot891"}, {"comment": "It's pretty clear that you haven't spent much time thinking about this, as you're making glib assertions about things that are actually quite deep and controversial.", "id": "d4ougmj"}, {"comment": "It's philosophy, everything is controversial.\n\nA lot of what I said is factual, though, i.e. when physical things change, they don't produce a clone with a tiny bit changed.\n", "id": "d4ouogi"}, {"comment": "That's not factual at all. Again, you should think about this more before talking about it.", "id": "d4outdl"}, {"comment": "I don't wish to pick a side as I have not formed an opinion on this matter, but how about you present yours instead of simply telling others there are wrong?\n", "id": "d4ow90t"}, {"comment": "I didn't say that he was wrong, only that he was making glib assertions about things that have been debated by many smart people for hundreds of years. When someone jumps in and proclaims certain things are \"facts\", it reveals that they haven't even grappled with the underlying issues, and are just being ideological rather than contemplative.", "id": "d4owjt2"}, {"comment": "Well, guess what: Most abstractions in the majority of OOP code don't deal with things on the physical world, they are mostly...abstract concepts. And when they do so, is more natural to translate the semantics in a language instead a hierarchical  taxonomy of objects.", "id": "d4owcuo"}, {"comment": "> The world around us is heavily mutable. Things change internally instead of producing a clone with just a few bits modified.\n\nWhat's the last time you did the equivalent of `person.setGender(Gender.MALE)` in the real world?  Or `weather.setHumidity(42)`?\n\nYes, the real world is changing, but it doesn't generally consist of *program-modifiable mutable reference cells*.", "id": "d4ostez"}, {"comment": "> person.setGender(Gender.MALE)\n\nWhen a person decides to change their gender, we don't produce a clone of that person with a different sex: we modify the sex of that person.\n", "id": "d4otrzh"}, {"comment": "I knew that.  I guess the example fell flat though.", "id": "d4ozzfc"}], [{"comment": "I'll take a wild guess and say that it's because tab completion in IDE's is much more straight forward and narrows down much faster when you are constrained to operating on values with only the package of functions they carry with them.", "id": "d4opkxw"}, {"comment": "Good luck getting this with Smalltalk or any other dynamically typed abomination.", "id": "d4opw7g"}, {"comment": "Yeah, that's the bad part about Smalltalk (I spent five years working as a Smalltalk programmer).", "id": "d4osozv"}, {"comment": "yah, poking about in the chrome dev console to get a working bit of JS reminds me an awful lot of dealing with smalltalk in VisualAge, not fun.", "id": "d4p9n25"}], [{"comment": "The premise is wrong. It isn't. It only looks like it because structured programming is now seen as obvious and implicit. ", "id": "d4q8o95"}], [{"comment": "Conspicuously missing from this discussion is anyone providing examples of really large, purely-FP applications. Can anyone point to a pure FP application that runs close to a million lines of code?", "id": "d4s651f"}], [{"comment": "Jesus. The anti-OOP brigading in this thread is embarrassing. ", "id": "d4otiev"}, {"comment": "Why? OOP is only applicable for a very narrow niche.", "id": "d4paocw"}, {"comment": "Are you serious? Do you guys actually listen to yourselves when you say stuff like that? One of the most widely used and popular methodologies is only applicable to a very narrow niche?", "id": "d4pfrw0"}, {"comment": "> Are you serious? \n\nYes. I don't get why so surprise. Care to name a niche where hierarchical taxonomies are the natural why of thinking?\n\n> One of the most widely used and popular methodologies\n\n\n\nBeing successful is far apart from being popular. Proofs of OOP success are none. Just a very sticky cargo cult and elitism around it.", "id": "d4pg5l9"}, {"comment": "> Care to name a niche where hierarchical taxonomies are the natural why of thinking?\n\nA shitload. Gui elements, user hierarchies, product hierarchies, file systems, billing...should I go on?\n\n> Being successful is far apart from being popular.\n\nExcept it is successful.\n\n> Proofs of OOP success are none. \n\nIf you live in fantasyland.\n\n> Just a very sticky cargo cult and elitism around it.\n\nI feel like I'm listening to a flat earther.", "id": "d4pgi84"}, {"comment": "> should I go on\n\nUnnecessary, none of the mentioned abstractions should be represented as low level hierarchical taxonomies, but are better as declarative rules base on domain specific languages to construct trees and graphs. For GUI: see TK and XAML.\n\n> Except it is successful\n\nProof? All I see is untamed complexity and an unnecessary boilerplate proliferation. Care to share an OOP codebase that you dim worthy? \n\n\n", "id": "d4pi2l9"}, {"comment": "> For GUI: see TK and XAML.\n\nThese are markup languages. Both are represented as object hierarchies. For instance, look at the hierarchy for a [Button in XAML](https://msdn.microsoft.com/en-us/library/system.windows.controls.button\\(v=vs.110\\).aspx)\n\n> Proof? All I see is untamed complexity and an unnecessary boilerplate proliferation. Care to share an OOP codebase that you dim worthy?\n\nNearly all video games are written in object oriented languages and rely heavily on object oriented designs. I think you are grossly underestimating the sheer amount of code that is object oriented.", "id": "d4ptbfz"}, {"comment": ">  These are markup languages.\n\nDomain specific language that map a domain at a higher level. I will give you that XAML adopts a wrong methodology, but the mentioned are still declarative rules, with less boilerplate and operate at a higher level than your low level constructs. \n\n> Nearly all video games are written in object oriented languages\n\nThey are irrelevant. No videogame is representative of good software. \n\n>  I think you are grossly underestimating the sheer amount of code that is object oriented.\n\nNo, I know, this why 99% of the software in the industry is an overly complex, low level, [pile of boilerplate which never last long](http://www.theregister.co.uk/2015/11/11/most_developers_never_seen_successful_project/).", "id": "d4pvlmt"}, {"comment": "> Yes. I don't get why so surprise. Care to name a niche where hierarchical taxonomies are the natural why of thinking?\n\nListening to heavy metal.  Now excuse me my favorite Finnish viking folk metal song is playing, next on my playlist is some atmospheric melodic death metal ;)", "id": "d4px5wn"}], [{"comment": "Haven't read the article yet, but I will. If I had to guess its about control and management of teams of developers of vastly varying skill levels. \n\nJust seems easier for me to isolate a junior developer into a couple classes to get the work done. \n\nThat being said I work in a very OO framework so the structure is all already there. ", "id": "d4oosao"}], [{"comment": "Because it allows us to program around *interfaces* which can be associated with arbitrary data as needed, allowing part of a program to receive objects which will fulfill a role, but without having to specify how or with what data structures ahead of time and without excessive boilerplate or typecasting on order to get it to work. It's this flexibility that is valuable, not really much to do with conceptual hierarchies (I hate 'zoo animal' classes).", "id": "d4ojn1l"}, {"comment": "Polymorphism and OOP are totally orthogonal.", "id": "d4okljn"}, {"comment": "[deleted]", "id": "d4ozbbs"}, {"comment": "All concepts alone are orthogonal to OOP, but three concepts in **conjunction** are the methodology of it: inheritance, polymorphism and encapsulation. \n\nIn short: If you are not using those three together, then you are not doing OOP.", "id": "d4ozx0j"}, {"comment": "I can't agree. The entire point of object orientation is to enable dynamic polymorphism. You can also achieve this with lambda constructs, but the ability to work around Liskov substututable interfaces with composeable objects is at the core of OOP.", "id": "d4ombak"}, {"comment": "You can do ad-hoc polymorphism with type classes. The Liskov substitution principle has never been a sound approach. For example , how do you define value semantics equality in a way that that satisfies both the properties of equality (reflexive, symmetric, and transitive) and the Liskov substitution principle? \n\nI've been a professional Java developer long enough to know that subtyping/inheritance is almost never the correct way to solve a problem, at least in the domains I work in.", "id": "d4oo1n9"}, {"comment": "> The Liskov substitution principle has never been a sound approach.\n\nThat's a bit of a sweeping generalization.\n\nYou're right that technically, you can't soundly define equality when subclassing is in the picture, but just because you can't implement something perfectly doesn't mean you shouldn't use it at all.\n\nPractically, this is rarely an issue because you hardly run into the situation where your equality mixed with subclasses is not sound. And on the other hand, the Liskov subtitution principle is a very powerful construct that underlies most of the OOP code bases today.\n", "id": "d4oog81"}, {"comment": ">You can do ad-hoc polymorphism with type classes\n\nOf course you can, I never said you couldn't or that this would be inferior. In fact, if you were to claim that multi-methods and independent dynamic dispatch are superior to single class based polymorphism we would have no disagreement. I'm simply arguing against the idea that you can meaningfully define OOP without including dynamic polymorphism as a fundamental aspect of it.\n\n>The Liskov substitution principle has never been a sound approach.\n\nNow this is a bit more interesting. I won't argue against the idea that there are exceptional cases where specifically not using Liskov substitution can be helpful, but in the vast majority of cases, thinking about design in terms of Liskov sustainability and using techniques that work with it is a good approach, at least better than the alternative of designing objects around abstract hierarchies or concrete structures and thinking about interfaces later.\n\nThe equality problem you mention is not something I've not encountered before, but then the whole point here is in designing interfaces around invariant contracts, which have no reason to include a specific version of equality if you don't want them to. If you choose to I see no reason why you couldn't simply have a specific contract just allow variation in behavior based on subclass if that's what you want, or not have this if you don't. If there's some subtlety of the problem I'm not seeing, please explain it to me. ", "id": "d4p6b3a"}, {"comment": "Type classes are a more powerful and general approach to ad hoc polymorphism.", "id": "d4opb6o"}, {"comment": "One of the pioneers of OOP would [disagree with you].(http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html)", "id": "d4omlxe"}, {"comment": "But all the other experts, and most of the industry, would agree with OP. Alan Kay has been trying to redefine what OOP means for a while but that ship sailed a long time ago.\n", "id": "d4omnl2"}, {"comment": "That's pretty much exactly what I'm saying, that OOP is about creating a system that focuses on the relations between abstract structures/interfaces and enables them to be dynamic, as opposed to being about the idea of objects themselves and their potentially rigid construction out of conceptual class hierarchies. I am trying to get at getting at what Alan is describing, with the additional possibilities of what meta-objects and metaobject protocols enable.", "id": "d4omwxq"}, {"comment": "What you describe is polymorphism and exists in many functional languages as well.", "id": "d4ol180"}, {"comment": "God. The only person actually explaining why OOP is good is marked controversial, while the top comment is someone fapping to functional programming and insisting that objects are hard to map to programming tasks.\n\nedit: We get it guys. No pro OOP comments allowed. Keep downvoting. ", "id": "d4oqo0n"}, {"comment": ">The only person actually explaining why OOP is good is marked controversial\n\nBecause:\n\n1. Polymorphism isn't unique to OOP\n2. OOP provides relatively weak mechanisms for polymorphism.", "id": "d4p1eld"}, {"comment": "I actually agree with the top comment and specifically disagree with the OP's article. Hence, I am confused why I'm being downvoted, as while I'm arguing that dynamic polymorphism is necessarily part of OOP (and hence, not orthogonal to it), I'm making no claims that it is somehow exclusive to OOP or even that OOP languages have necessarily 'better' polymorphism compared to alternatives.", "id": "d4p8hzn"}, {"comment": "Maybe it's you're regular appeal to deities which is sabotaging your comments. ;) Or just that your comments add no value to readers, as they come across like someone commenting to themselves or mumbling under their breath. (Not that my comment here is of value to anyone else.)", "id": "d4ovk6v"}], [{"comment": "Most computer scientists (let alone language designers, developers) don't bother to understand their tools beyond some informal mapping onto an idealized processor/memory. \"OOP\" slaps together a bunch of different features into a single language mechanism that has a relatively easy to understand implementation. \n\nIt's only a \"natural way of thinking\" in that people prefer to reason by fuzzy analogies to the \"real world\". And of course, the marketing effort that made sure it's how the vast majority of students are introduced to programming probably helps it seem \"natural\".", "id": "d4oprxs"}], [{"comment": "A complex system deals with a lot of different types of data. Different functionality can be separated into different programs (like: make, link, cc, ls).  \n \nIn a object-oriented system, you focus on the abstractions of this data. Which makes the handling of different types of data more easy, if this data has some kind of similarity.  \n\nWe can see this in reality. Very big systems are based on object-oriented structures. Smalltalk and Java and C# are huge.  \nVery big programs can be written in a short period. \n\nThey can be very quickly adapted to small changes in data-structures. Something that happens often in the process of development of commercial software. Shops want to add a few new products, or add new ways of payments.  \nThese adaptions often have the structure of: add more data types, keep the same functionality.  \nThe OO system also works well with simulated environments with lots of (different) objects, like computer games. ELM copied the MVC pattern in its functional programming system to make the implementation of games easier.\n\nThe complexity of it's functionality depends on the language. In C++ the functionality is very limited, due to the complex nature of C++. Then comes Java and next C#. The OOP has a bad name due to C++ and Java. Complex functionality can become even more complex due to the language systems.\n\nSmalltalk can create very complex functionality without real problems. It was based on Lisp. Smalltalk had closures built in from the start. It uses some functional constructs, which avoids quite some coding in some places. Smalltalk's dynamic typing allows some amazing tricks with lists and dictionaries.\n\nThe correctness and maintenance of these systems is a different problem. And low-level speed if your system uses a lot of late-binding and dynamic types.  \nBut these things are not what brought OO to the market. \n\nModern functional programming also uses OO tricks, while complaining about it. Erlang uses actors. Other use type-combinations to implement the same functionality for different types of data.  \nGenerally this works very well for small or well defined systems, and give the advantage of early binding which gives speed and certainty.\n\nMy proposal is to combine both, and get the best of each approach.  \n\nIn my [own programming language (unseen)](/r/unseen_programming), I am doing exactly that. I use functional programming to compose function-components on a low level (with some extra logic). I use classes to define systems on a higher level. \nI use both tests and types to define the validity of the functions.  \n\nIn normal text-programs this would become complex, but it is a graphical system that does not need text at all.\n\n---  \nAdded: \n\nHaha.. I think that am caught in a battle between:  \n\ndynamic versus static  \noop versus functional   \nTDD versus types  \n\nFor me these are shades of grey.\n\nSadly most people do not understand the real power of OOP and dynamic programming.\nAnyone know Python? Or ruby?  \nFor a completely dynamic and oop system,  \nI would advice people to try [Smalltalk / Pharo](http://pharo.org/) some time.  \nIt is just amazing how much it can do.  \n\n", "id": "d4omw61"}, {"comment": ">  Smalltalk's dynamic typing allows some amazing tricks with lists and dictionaries.\n\nYeah... no.\n\nEither these tricks are sound and they can be replicated with any statically typed language or they are not sound (can fail at runtime) and they are unsafe hacks, not tricks.\n\n", "id": "d4oojh7"}, {"comment": "Ha ha, I did not say that all these tricks were safe..  \nThings like #become: and #perform: can fuck up your system pretty bad. \n\nIn Smalltalk, I was able to create a matrix inversion in a library that did not previously know it. A library that I did not know, and I did not need to change the library itself. It took 15 minutes.  \nI can not do that in any other language.  \n\nRuby became famous due to its dynamic nature as well. The rails on ruby system is very dynamic and allows quick working prototypes.\n\nTo create safe dynamic systems, one needs to work more on design level than in other languages. \"Safe\" upgrades in Smalltalk are like one month of preparation and 1 week of coding.\n", "id": "d4os16b"}, {"comment": "> I can not do that in any other language.\n\nSure you can, e.g. with neural networks. Such algorithms are a property of the implementation, not of the language.\n\nI'm curious, though, what concepts of Smalltalk allowed you to add such a concept to a library? I'm completely speculating but I bet that this library was designed in the first place to be pluggable and I'd be very surprised if this can only be achieved in Smalltalk, but I'm genuinely curious about what you did.\n\nEverything that Ruby on Rails does has been replicated in statically typed languages. Again, it's an implementation concern, not a language one.\n", "id": "d4otc9u"}, {"comment": "**Libraries are very important**\n\nThe library contained the classes Vector and Matrix. They were declared in a separate Module/namespace. I used Squeak.   \nI can add a new method in the same Matrix class, in a different module/namespace.  \n\nAfter some investigation I found that the library did not contain an inverse function, but it contained a LU decomposition function.  \nI used the LU to create an inverse of a matrix.\n\nIterating through a list in Smaltalk is like:  \nList do:[:item| item DoThis].  \nIt uses a closure.  \nAll functions in Smalltalk are designed in a similar way, just like in LISP.\n\nI have worked a lot with Delphi and C++, and its libraries. With Smalltalk, I was amazed how easy it was to dive into the code and add another function.  \n\nRecently I tested some RSA encoding in Smaltalk (Pharo) as well. It can deal with any length numbers and has the necessary functions for power and modulus.  \nIt works very well for small prototypes and tests.  \nBecause Smalltalk tests all identifiers statically, it can catch a lot of the type-errors beforehand. Unlike javascript. \n\nI do think that static types are good too. I like Scala. Personally I am testing an (incremental) approach that both combines types and function-level tests.  \n\n**Tools are important**\n\n> Everything that Ruby on Rails does ...  \n\nThe tools around the programming language are important as well. Rails is a tool. Delphi has such tools with static typing for GUI and database programming. It works very well.  \nThese tools and the programming language have to work together well. In Smalltalk the classbrowers-tool is the basis of the system. And its language allows for easy extensions.\n\nIn many other languages, the text-editor is the only tool that we have got. So implementing something big becomes more difficult. Especially in a language as C++.  \n\n**Compilation speed /test speed is important**\n\nBut there is a language-dependency: Even with a very good tool, GUI programming in C++ is much slower than in Delphi or C#. That is because the program in Delphi/C# is a simple addition to something that already works.  \nIn C++ each additions is a completely new program. It needs a long recompilation, because of its lack of modules and its long compilation time.\n\nSmalltalk does not need compilation time at all. I can insert new code in a Smalltalk function during its execution. Which is great for testing/debugging. About 10 years ago, the same thing existed for Java, but sadly Microsoft had bought all rights for it. \n\nFor me a programming system, which is both the language and the tools, should allow dynamic composition of functions and other components... even while running. The interfaces of each component are static, and prevent wrong connections.  \nThat is the basis of the programming system that I am working on now. Also the reason why I am interested in these types of discussions ;-)\n", "id": "d4ov5hm"}, {"comment": ">  About 10 years ago, the same thing existed for Java, but sadly Microsoft had bought all rights for it.\n\nEr... what? This exists today in pretty much all JVM IDE's. Adding code is instant, as is reloading and redeploying, thanks to Hotswap.\n\nBack then, Smalltalk was the only language supporting this. Today, it's available everywhere and it's much more powerful and flexible than Smalltalk ever offered.\n\nOther than that, thanks for taking the time to describe your previous project. A lot of what you show is trivial to do today on the JVM (e.g. in Kotlin you'd simply create an extension function, e.g. `fun Matrix.myNewFunction()` and now, you've added a new function to the `Matrix` type. A similar capability is available in C#).\n\n\n", "id": "d4ow3re"}, {"comment": "> This exists today in pretty much all JVM IDE's.  \n\nI have not used the recent IDEs.  \nThanks for the info.\n\nHaha..  It seems that I am getting old.. ", "id": "d4ow75b"}, {"comment": "No worries, happens to everyone (including myself). There's only a finite amount of time in our lives, we can't learn and know about everything.\n\nBut yes, if you ever decide to learn a bit more about this, just install IDEA or Eclipse and play with Java or Kotlin for a bit: this combination has a lot of very clever and useful features that will make even the most hardcore Smalltalk fans nod in appreciation.\n", "id": "d4ox7i9"}, {"comment": "> Anyone know Python? Or ruby?\n\nYeah, both actually. since python is \"multi-paradigm\" I doubt that it properly demonstrates the \"real power of OOP\", it works just fine on composing functions to transform lists of dictionaries. Maybe Zope/Plone and the ideas explored there for decades showcase OO's strengths but most people who would be on reddit have either been burned hard with Zope/Plone or know someone who has or have read on reddit that it's bad and you should stay away from it. \n\nAs far as Ruby goes, I'll grant you that \"every thing is an object\" isfeature of the language is it's main attraction. But ruby developers seem to progress through their use of the language where they build consume objects for everything tie themselves up in knots with the mess they've made. start meta-programming to clean it up and make an even bigger mess, and then they move on to the latest hotness which currently seems to be elixir which is not known for it's OO strengths. \n\nSo if something demonstrates the \"real power of OO\" it sure as hell isn't python or ruby as far as I can tell. ", "id": "d4p1w2r"}], [{"comment": "Because we think in terms of objects, methods and properties...", "id": "d4oks4k"}, {"comment": "I am thinking in verbs and collections. Sorry.", "id": "d4ooo75"}, {"comment": "What are verbs? What are collections and its elements? Think about it...", "id": "d4ow6r7"}, {"comment": "Sequences, streams, structures, transformations, filters, searches, applications.", "id": "d4ox5bo"}, {"comment": "Yes, yes... when you hear objects and properties it's not always what you've learned in Java 101 class... Take yourself back centuries ago, mankind thinks, reasons about \"things\" (subjects/objects) and their properties and interactions with other \"things\"...", "id": "d4oxlol"}, {"comment": "But mathematically we have been thinking for centuries about transformations of distributions, mappings, of evaluating sequences to limits. These do not map well to objects.", "id": "d4oyaiv"}, {"comment": "Yes, it's declarative vs imperative... but even purist FP guys admit that it is easier to first come up with imperative method of coding algorithm, because it is more natural to what people are used to do when specifying things for \"what to do\", not \"what it is\". And declarative way requires more upfront thinking. I'd say, as with Prolog (LP), there are domains/tasks where it (FP) is the right thing.", "id": "d4oz04o"}, {"comment": "I'm not sure what imperative has to do with objects and message passing.", "id": "d4p1jrn"}, {"comment": "Passing a message is an action, an imperative command on an object.", "id": "d4p2fcs"}, {"comment": "Yes, but it's not the only way.\n\nJust because imperative is easier to come up with than declarative, doesn't mean objects make it easier to think about. You can just have a sequence of instructions.", "id": "d4p5a0r"}, {"comment": "No we don't.", "id": "d4opbw0"}, {"comment": "I'm thinking in terms of types, typeclass methods, and immutable record structures. Sorry.", "id": "d4osatt"}, {"comment": "Can you go slightly meta on this? You think of types as objects - you're using them and they have some properties... same goes for the rest of \"things\" (i.e. objects) you mention...", "id": "d4ow4gh"}, {"comment": "Sure, and in that case objects are just an implementation detail, they are not the primary way of thinking and reasoning about my program.", "id": "d4ozjid"}], [{"comment": "It's you again, still with the same epic degree of ignorance.", "id": "d4ojraa"}, {"comment": "its hard not to laugh at this link... goes to show that 20+ years of experience doesn't mean anything significant other than you may still not know any better 20 years later. ", "id": "d4ojvhj"}, {"comment": "It would actually be more useful if you pointed out exactly where I was wrong.", "id": "d4ok23o"}, {"comment": "> OOP was more generally attractive because it was more intuitive, more natural to the way people think\n\nThe cringe.\n\n", "id": "d4okj7w"}, {"comment": "Too much to cover in one post but here it goes:\n\nYou're repeating 1990s peak OOP platitudes about objects matching the way people think. This is similar to the outdated idea of programming languages that \"read like English.\" Toy examples are superficially convincing but the concept breaks down quickly in practice.\n\nInheritance seems like a good idea at first but implementation inheritance and deep inheritance hierarchies are now recognized as bad design - even amongst OOD purists (see the oft cited advice \"composition over inheritance\"). It's about interfaces and implementations now. These concepts aren't unique to OOP and can be realized in almost every language.\n\nOO inheritance provides a weak mechanism for polymorphism. Inheritance provides instance based polymorphism only. You can't define polymorphic behavior for types, over multiple arguments or for already existing classes. Polymorphism is often cited as a big advantage of OOP but it does a pretty poor job of it.\n\nThe idea that FP is too different to how people think is just not correct. People adjust their thinking to the domain. In many domains, people are thinking in terms of streams, relations, projections, functions, pipelines and transformations - not objects. OOP is not some natural extension of procedural/imperative programming. You can add functional features to procedural languages just like you can add OO features. Most general purpose languages support procedural, object-oriented and functional features to varying degrees.\n\nPutting all this aside - your answer is wrong because the basic premise of the question is wrong. OOP is not today's \"key programming methodology.\" It is the key methodology in some domains and has left a wide mark but the golden age of OOP is over. The field as a whole has been moving towards other paradigms for a while:\n\n* More FP focused languages have seen wider use (e.g. Scala)\n* More functional features have been incorporated into widely used languages (e.g. lambdas in Java 8, C++)\n* Newer languages have little to no OO focus (e.g. Go, Rust, Elixir, Swift, Julia)\n\nIt's also worth pointing out that there have been attempts to apply OO to almost every domain and few of these have stuck. If OOP is so great why has the industry been moving away from it for the last two decades? Why doesn't the cutting edge of any field seem to embrace it? Why does OOP have barely any representation in modern PL language and theory?", "id": "d4ot1pf"}, {"comment": "I think you're being a bit harsh.\n\nOOP is clearly EXTREMELY popular, and most programs that people encounter in the workplace or in consumer electronics have a strong OOP component. The OP put forth a theory for why that is, namely that it maps strongly to some sense of intuition. I'm no big fan of OOP, but there has to be a reason why it is and was so popular, and don't spout the \"marketing\" BS.\n\nI personally think there are two reason:\n\n1.) It has some intuitive appeal for a how people reason about problems.\n\n2.) It makes segmenting work on large teams easier.\n\nIt's not helpful to just criticize something popular and say that it sucks; there is a reason that it's popular, and usually there is a good reason.", "id": "d4ourj1"}, {"comment": "Being popular isn't the same as being \"the key programming methodology.\" OOP's popularity at this point is mainly due to path dependence. OO hype was massive in the 90s and OOP was seen as a panacea. It didn't live up to the hype and it has been declining in popularity ever since.\n\nI strongly disagree with 2. What is it about OOP that makes segmenting work so easy? OOP doesn't have a monopoly on the idea of separating interface from implementation.\n\n1 is arguably untrue but irrelevant either way. Part of being a developer is learning to adjust your intuition and way of thinking to match the domain rather than trying to force the domain into an OO bed of Procrustes. OO has turned out to be a poor fit in many areas.", "id": "d4ow7lb"}, {"comment": "OOP may be declining in popularity over the past 15 years, but so is C++. Nevertheless, C++ remains one of the three absolutely dominant IT languages in the industry (the other two being Java and Python). C++ is still enormously popular and widely used. Ditto for OOP.\n\nI was in the IT industry for over 20 years (I retired in 2000). My career peaked in the 1990s when OOP and C++ were still very big. So I may have lost touch with events in the industry over the past 15 years. My post stands as it is based on my industry experience.", "id": "d4qtcxx"}, {"comment": "It was the dominant approach in much of the programming world for 20 years, and probably still is, though I agree with you that it is declining.\n\nYour inability to come up with one genuine advantage to OOP suggests that you're just being a partisan.", "id": "d4owvsf"}, {"comment": "That's a weak response. What do you find to be particularly advantageous about OOP and why is it specific or unique to OOP? I'm not obliged to think of genuine advantages to OOP. I'm not the one advocating for it or defending it.\n\nI know OOP was the dominant approach. It was the dominant approach and so we keep using it for a variety of path dependent reasons including familiarity, ecosystem, language support, and people thinking it must be a great idea because it was the dominant approach for some time. You're providing an example of this - not a counterexample.", "id": "d4oyjkr"}, {"comment": "I don't particularly like OOP; I'm a data scientist whose work is expressed much better with a functional approach, so I definitely don't think it's the best or only approach to problem.\n\nBut it does have some advantages, or it wouldn't have taken over the entire programming world. Your attempt to ascribe all of its advantages to \"hype\" or \"path dependency\" is just ridiculous. Quit being a hipster, you can learn something from the past.", "id": "d4p5biw"}, {"comment": "Sure it has it's advantages. They're just not unique to OOP. \"Quit being a hipster\" isn't an argument. Things move forward. The dominant mode of thought N years ago isn't always right today. Why are you defending something you don't like and don't even seem familiar with? Give it a rest.", "id": "d4p6jj6"}, {"comment": "> implementation inheritance and deep inheritance hierarchies are now recognized as bad design - even amongst OOD purists\n\nI hear this all the time, but I'm not sure it's really true. I think many projects are still heavily OOP-based. Is the thinking starting to change about OOP? No doubt, but it's not yet a *fait accompli*.\n\nThe demand for class-based OOP is still strong enough that ECMA TC39 felt compelled to add class support to ES6.\n\nIt remains to be seen to what extent Scala will be used as a FP language. From what I hear, people are still using it predominantly for OOP. Ditto for the addition of lambdas to Java and C++.\n\nBut I do concede that the newest languages shy away from OOP.", "id": "d4pw6i0"}, {"comment": "The thinking on implementation inheritance changed a while ago. James Gosling recommends avoiding it wherever possible. This [article](http://www.javaworld.com/article/2073649/core-java/why-extends-is-evil.html) gives a few reasons why it is considered a bad idea. The GoF also recommends using composition rather than inheritance to achieve code reuse.\n\nDeep inheritance hierarchies have fallen so far out of favor that the Visual Studio Managed Code Analysis tool actually emits [warnings](https://msdn.microsoft.com/en-us/library/ms182213.aspx) when it detects them.\n\nMany projects are still heavily OOP-based but OOP has a lot of inertia and mindshare. The telling thing for me is that OOP is conspicuously absent in new technologies. Whether OOP represents a more intuitive way of thinking is not for me to say. It is a poor fit to software development that developers are moving past all the same.", "id": "d4pz1xo"}, {"comment": "I can understand avoiding deep inheritance hierarchies, but what about shallow hierarchies (in combination with composition)? Surely, no one is recommending avoiding *any kind* of inheritance. It's hard to imagine that inheritance has no value at all in software engineering.", "id": "d4q0xkh"}, {"comment": "You are right about that. No one is recommending avoiding shallow hierarchies + interface inheritance + composition. The thing is that none of these things are actually unique to OOP. Composition doesn't require OOP. Interfaces (ad hoc polymorphism) don't require OOP. Typed hierarchies don't require OOP. A lot of OOP features are found in more powerful and general forms outside of OOP. For example, trait-based polymorphism allows you to implement functions that are polymorphic on their return type. You can't do that with inheritance.\n\nThe real thing that distinguishes OOP from other paradigms is the philosophical idea that data should be tightly coupled to functions that operate on it. It is a deliberately crippled approach.", "id": "d4q4g31"}, {"comment": "Pretty much everywhere. Especially when you're calling this object abomination a \"natural\" way of thinking.", "id": "d4omzj5"}, {"comment": "Nice argument. Your elaborate explanations were enough to make me swear off using OO for the rest of my life. You also properly explained everything to do instead so it was much appreciated.", "id": "d4ooo2q"}, {"comment": "It is exactly the level of argumentation this shit stupid article deserves. No need to go any deeper when talking to the idiots.", "id": "d4op22t"}]]], "51y5vs": ["Flutter: A new cross-platform solution", "2016-09-09 20:06:23", 0, "http://tengio.com/blog/flutter-a-new-cross-platform-solution/", [[20, "Terrible title.\n\nFor a lot of us old farts (I say at the age of thirty), cross-platform means supporting Linux, Solaris, AIX, *BSD, etc. Or Linux, Windows, and OSX.\n\n\"Cross-platform\" looks like it's a property of the solution, so what's it solving? Is it a cross-platform solution for durable distributed messaging? Image processing? Reticulating splines? Setting fire to the processor?\n\nA better title would be: \"Flutter: a new cross-platform framework for mobile apps\". Then it's clear what it's for, and you get at least some idea what platforms it will support."], [7, "tl;dr: use dart for android and iOS development."], [3, "Flutter... Its it still slimmed down webkit + chromium base + mojo?\n\nI wonder how heavy it is compared to native on respective platform. "], [1, "That names sucks.  Flutter is thing related to aeroelasticity.  For airplanes it's very bad.  Why would you pick such a random name for your project?"], [0, "**puke**"]], [[{"comment": "Terrible title.\n\nFor a lot of us old farts (I say at the age of thirty), cross-platform means supporting Linux, Solaris, AIX, *BSD, etc. Or Linux, Windows, and OSX.\n\n\"Cross-platform\" looks like it's a property of the solution, so what's it solving? Is it a cross-platform solution for durable distributed messaging? Image processing? Reticulating splines? Setting fire to the processor?\n\nA better title would be: \"Flutter: a new cross-platform framework for mobile apps\". Then it's clear what it's for, and you get at least some idea what platforms it will support.", "id": "d7fvko5"}, {"comment": "> For a lot of us old farts (I say at the age of thirty), cross-platform means supporting Linux, Solaris, AIX, *BSD\n\nyou can't be serious....don't forget HP/UX and AmigaOS while you're at it", "id": "d7fwqnd"}, {"comment": "I had a college course where the objective was to port a tool to six different operating systems. HP/UX was in fact one of them.", "id": "d7fxl8y"}, {"comment": "are you sad that ITT Tech is now closed?", "id": "d7fys42"}, {"comment": "sure I guess I may have been a bit superficial on the title... anyway flutter is not limited to be only mobile (at least in theory)", "id": "d7fx6x3"}, {"comment": "In the article you say 'Declarative', yet I think 'pseudo-declarative' is a better way of putting it.  Let me explain - Angular (with ng-repeat and ng-show in 2009) took HTML from declarative* to pseudo-declarative.  Super cool.  QML is that too - a pseudo-declarative markup technology - with [Node.qml](https://github.com/trollixx/node.qml) as its standout if abandoned high-point.\n\nIt would be nice to see Flutter expanded to all platforms, so I could build an app that could deploy to any of them. At least one codebase and build-flags for each, and shared code including 'up' into the view/markup layer.", "id": "d7g7d0h"}, {"comment": "Flutter is literally limited to iOS and Android. ", "id": "d7hcuql"}, {"comment": "Times have moved on, cross platform now means works on ios and android.", "id": "d7gnheq"}, {"comment": "Times haven't moved on that much. Desktop and laptop computers still account for a large amount of application development.", "id": "d7h0xb8"}, {"comment": "I disagree. The market for desktop apps is retreating very fast and most apps these days are either web apps or mobile apps. \n\nIn fact I can't think of anybody who is actively writing desktop apps anymore.", "id": "d7hluki"}, {"comment": "Your lack of familiarity with development outside the mobile sector is pretty weak evidence, and it's somewhat hard to believe considering you're undoubtedly developing on a desktop or laptop, and any server-side components supporting your apps are running on Windows or Linux, not Android or iOS.", "id": "d7hm8li"}, {"comment": ">Your lack of familiarity with development outside the mobile sector is pretty weak evidence, \n\nNo I think it's strong evidence that desktop programmers are few and far in between.\n\n>it's somewhat hard to believe considering you're undoubtedly developing on a desktop or laptop, and any server-side components supporting your apps are running on Windows or Linux, not Android or iOS.\n\nNo I specifically said no desktop or laptop. You create a mobile app, you create a web service (and web site). That's your app. \n\n\n", "id": "d7hyrd1"}, {"comment": "And I suppose you type all this code into your phone?", "id": "d7j01t6"}, {"comment": "No but I don't see how that's relevant.\n\nProgrammers make up a tiny slice of the population. I never said PCs don't exist nor did I say they will cease to exist. They are specialty devices for a tiny percentage of the population who needs them. For most people there are phones, pads and chromebooks.", "id": "d7j6ujj"}, {"comment": "It's relevant because /u/tkannelid said \n\n>\"it's somewhat hard to believe considering you're undoubtedly developing on a desktop or laptop\" \n\nand your reply made no sense: \n\n>\"No I specifically said no desktop or laptop. You create a mobile app, you create a web service (and web site).\"\n\nThus I thought I'd contact you to see if we could clear this discrepancy up by asking you if you type code into your phone.", "id": "d7j728a"}, {"comment": "I already explained it to you. Do you want me to do it again since you didn't seem to understand it?\n\nMost developers don't develop for tiny little niche markets like programmers.  Most developers develop for consumers who are on mobiles or the web. Therefore the vast majority of developers you run into are developing for mobiles or web.\n\nPretty straightforward but apparently you are having trouble understanding this.", "id": "d7j79cp"}, {"comment": "People in those roles can still deploy services on Windows Server or Linux.", "id": "d7j5c8j"}, {"comment": "[deleted]", "id": "d7fwh1r"}, {"comment": "You're *trippin*'", "id": "d7fxlyq"}, {"comment": "Ha! That was a mis-paste. Sorry 'bout that!", "id": "d7fzb1y"}], [{"comment": "tl;dr: use dart for android and iOS development.", "id": "d7fzfly"}], [{"comment": "Flutter... Its it still slimmed down webkit + chromium base + mojo?\n\nI wonder how heavy it is compared to native on respective platform. ", "id": "d7fyq0q"}, {"comment": "It uses [Skia](https://skia.org/) not webkit. Skia is a very rudimentary rendering library.", "id": "d7g48dz"}, {"comment": "The engine part is still blink/webkit though... although heavily modified (called sky?); see e.g. https://github.com/flutter/engine/blob/master/sky/engine/core/rendering/RenderBlock.cpp\n\nEdit: Aha, it's only for text rendering; https://flutter.io/faq/#what-technology-is-flutter-built-with", "id": "d7g79t6"}], [{"comment": "That names sucks.  Flutter is thing related to aeroelasticity.  For airplanes it's very bad.  Why would you pick such a random name for your project?", "id": "d7h5iat"}, {"comment": "Pretty sure the name is related to the Butterfly Effect.", "id": "d7h7ih3"}], [{"comment": "**puke**", "id": "d7git81"}]]], "4gq29m": ["TypeScript won", "2016-04-27 23:09:13", 44, "https://medium.com/@basarat/typescript-won-a4e0dfde4b08#.uw4xqccro", [[71, "Like most Medium posts, this is an article that's good for getting upvotes and likes but bad for actually providing useful information.\n\nNote the author's tagline: \"That TypeScript Guy\". This isn't an exaggeration: he's published a book and released many TypeScript supporting extensions. I'm not saying this is a bad thing, just that he clearly isn't unbiased.\n\nAs the author says, it's not a competition, but he chose to continue rambling on even after making a reasonable argument for how useless this article is, so I will too. While TypeScript is probably better than Babel + Flow for the moment, it hasn't really \"won\" anything (unless you live in a world in which you are forced to choose between Babel + Flow and TypeScript).\n\nMany people are unaware of how much of ES6 is usable *today*. Take a look at the [es6 compatibility table](https://kangax.github.io/compat-table/es6/). Most of the high impact features (class syntax, arrow functions, etc.) have already been available for some time - no need for transpilation! Obviously, this does depend on your audience, but what I'm trying to point out is you shouldn't automatically reach for a transpiler whenever you go to write a JavaScript program, because for many people it's no longer necessary.\n\nThe reason I say that is to show that TypeScript mainly offers type checking and bundling, not transpilation. Which is fine, but most people don't really need it. So I'm not sure what TypeScript would actually be \"winning\"."], [35, "[deleted]"], [14, "It is a pretty great experience in Visual Studio now. Minimal hassle, and you see more of your errors at type time, annnd it is easier to explore libraries with autocomplete.\n\nSimilarly nice workflow in Atom and VSCode\n"], [9, "What's that? There were people who doubted Anders (Hallowed be His name)? Heretics!\n\nOn a more serious note when did the strong script experiments \"fail\"?\n\nAlso note that TypeScript 2 will add flow based typing (similar to Facebook's Flow) which means that even if you do not write a single type and go all dynamic TypeScript will still inform you about some errors. The tooling with some type definitions will also be very useful to people who do not care about types so TypeScript will be (or maybe is today) the best way to write dynamically typed JavaScript."], [7, "Winning against other JavaScript dialects is like winning in the Special Olympics. It's still fucking retarded."], [6, "As a newbie building little web apps to hopefully get hired later I'm just thinking I hadn't even started working with ES6 and there's apparently this other thing that's already beaten ES6 and has more things in it. I guess I wouldn't even know how to begin using typescript in my JS code."], [6, "The fact that Neatbeans Typescript third party plugin give better experience than default Javascript integration says something."], [3, "Are there any major features of TypeScript that aren't already supported by [Babel](https://babeljs.io/docs/plugins/syntax-flow/) + [Flow](http://flowtype.org/)? Embracing and *extending* JavaScript seems to be a non-goal of TypeScript (although it's not explicitly mentioned [here](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals)).\n\n The Babel codebase itself is written with type annotations. There's even a [plugin](https://github.com/codemix/babel-plugin-typecheck) which allows them to be enforced at runtime."], [3, "Does it have async/await already?\n\nThat's one killer feature Babel is worth using for."], [3, "I remember first hearing about TypeScript at a Microsoft demo years ago, didn't pay too much attention to it until now, seems like it's gotten big!"], [2, "I generally agree with other comments - declaring victory is kind of silly.\n\nI would say that TypeScript is the best way to write JavaScript today. That doesn't mean that it's the best for all eternity, but if you're going to start a project now (or even if you have an existing project), the selling points of TypeScript are too good to ignore."], [2, "Didn't WebAssembly win?"], [1, "I certainly find Typescript the most appealing non-Javascript around but ES is not staying idle, and it's instantly and natively supported in all browsers, which gives it a huge advantage.\n\nAs long as ES stays within reasonable distance of Typescript, it will stay ahead in mind share.\n\n"], [1, "That's not a Venn diagram. That's an Euler diagram."], [1, "Slightly OT: does the new ES6 spread operator ...args conflict with TypeScript's need to match parameters to call target (common compile error then \"Supplied parameters do not match any signature of call target.\")"], [1, "I can see that the author wants TypeScript to be \"winning\". That doesn't mean that it is. He is however mentioning a bunch of popular projects who are loosing popularity in favour of mostly ES6/ES2015; Dart and CoffeScript.\n\nIf you look at google search trends for TypeScript and ES6 you will see that they follow each other closely, and I have no reason to belive that TypeScript will go out of that battle victorious.  Just look at the examples that the article says \"failed\", namely Dart and CoffeScript. Both project try to do something different than JavaScript, and in fact; thats what TypeScript do as well. It might try to call itself a superset of JavaScript, but that still makes it something else than JavaScript. And I don't think its going to work, because it didn't work for CoffeScript and it didn't work for Dart. So why should it work for TypeScript?\n\nBabbel definitely looks like where the world is headed. It integrates nicely with a Gulp or Grunt workflow. It's the same principles that fuels PostCSS. We see a clear trend of creating small scoped plugins which we can compose as we see fit. Babel, Gulp, PostCSS; these are the tools are the future! What we need is a Babel plugin for adding and checking types. "], [1, "The author's line of reasoning is that, since ECMAScript 6 is introducing new features that also exist in TypeScript, it must be that TypeScript is winning. Except: ES6 started a couple of years before TypeScript - in other words it's not clear that ES6 is adopting new ideas from TypeScript rather than vice versa. And, of course, ES6 has indisputably *not* adopted static type annotations, which is kind of the main feature of TypeScript. That's kind of like saying that, when C99 introduced intermingled variable declarations like C++, C++ 'won'.\n\nTypeScript is great if you're into that sort of thing, just like C++ is great if you're into that sort of thing. But not everyone is."], [1, "these short lived languages never \"win\""], [1, "Man, I really wish there was a typed CoffeeScript...\nI like Dart a lot, but dart2js compile times can be atrocious."], [1, "I have no idea who \"won\", but the competition seems to be missing languages like Elm, Clojurescript & Purescript. If, as is the case with most new projects, you are transpiling anyways, you might as well go the whole way and choose a language that's not just an afterthought of JS."], [0, "I have no reason to use TypeScript"], [0, "Doesn't the rise of WebAssembly means that JavaScript is losing traction?"], [-1, "No it didn't.  \n\nActuality it looks like elm is going to win. "], [-2, "Until ES7 comes out and then what? Why use Typescript over that? "]], [[{"comment": "Like most Medium posts, this is an article that's good for getting upvotes and likes but bad for actually providing useful information.\n\nNote the author's tagline: \"That TypeScript Guy\". This isn't an exaggeration: he's published a book and released many TypeScript supporting extensions. I'm not saying this is a bad thing, just that he clearly isn't unbiased.\n\nAs the author says, it's not a competition, but he chose to continue rambling on even after making a reasonable argument for how useless this article is, so I will too. While TypeScript is probably better than Babel + Flow for the moment, it hasn't really \"won\" anything (unless you live in a world in which you are forced to choose between Babel + Flow and TypeScript).\n\nMany people are unaware of how much of ES6 is usable *today*. Take a look at the [es6 compatibility table](https://kangax.github.io/compat-table/es6/). Most of the high impact features (class syntax, arrow functions, etc.) have already been available for some time - no need for transpilation! Obviously, this does depend on your audience, but what I'm trying to point out is you shouldn't automatically reach for a transpiler whenever you go to write a JavaScript program, because for many people it's no longer necessary.\n\nThe reason I say that is to show that TypeScript mainly offers type checking and bundling, not transpilation. Which is fine, but most people don't really need it. So I'm not sure what TypeScript would actually be \"winning\".", "id": "d2jy3lv"}, {"comment": "> Many people are unaware of how much of ES6 is usable today. Take a look at the es6 compatibility table. \n\nHmm, looks like you can use `const` and `let`. Actually you can't, because IE10 doesn't support them.\n\nSeriously, who doesn't support at least IE11.", "id": "d2k59hl"}, {"comment": "I support IE 11. They had to go an fuck up flexbox.", "id": "d2kepvm"}, {"comment": "Unless you are building a product for web developers specifically I don't know how you can claim that ES6 is usable today. Even the most basic functions are not supported in like 1/3 of the browsers out there and I am not even taking into account mobile.", "id": "d2keeae"}, {"comment": "That's why there's babel and polyfills.", "id": "d2klvxx"}, {"comment": "Babel is a transpiler and /u/blaisio claimed that you can use ES6 today without a transpiler. Also in the presence of TypeScript choosing Babel is wrong :)", "id": "d2kmtu9"}, {"comment": "TypeScript is not the first compile-to-JS language that provided improvements over native JS. \n\nDart, CoffeeScript and ClojureScript all have some really nice features, but they are niche because JS is what is in the browser, and you will always be a slave to that mapping. There will always be little tripping points that make them hard to integrate and use. \n\nI see no reason to believe that TypeScript will fare any better, and ES6 will eventually end up in the browser. So, sorry i disagree -- not learning ES6 is a mistake.\n", "id": "d2kobar"}, {"comment": "It sounds like you don't know what TypeScript is. You cannot possibly learn TypeScript without learning ES6 because TypeScript IS ES6 + optional static typing.", "id": "d2koimq"}, {"comment": "I'm not aware of how much of ES6 is in TypeScript, this is true.\n\nI did actually use TS on a d3 project, but it wasn't really leveraging much that would be ES6 besides classes. It actually was a giant pain in the ass as the bindings for d3 that i could find were incomplete and it was too big a task to write them myself.\n\nMore trouble than it was worth when half the libraries i used didnt have bindings.", "id": "d2kqanz"}, {"comment": "TypeScript is not about ES6. It's not even about ES5. It's about static types. TypeScript being a superset of ES6 (previously ES5) is merely an artificially imposed restriction on the language with the specific purpose of making TypeScript adoption (and abandonment) extremely simple.", "id": "d2krgyp"}, {"comment": "I don't know why the \"abandonment\" feature is so underrated. It is great to have 0-risk solution. If it doesn't work just take the output and use it as you would have if it was written by hand.", "id": "d2ks3h4"}, {"comment": "If you do not use bindings you are back in pure ES6 land. The current version of TypeScript implements all of ES6 and they are adding features from ES7", "id": "d2krvnd"}, {"comment": "So i was using a handful of libraries, most of which didn't have bindings. A few of them were organized (strange module patterns) in a way that made creating bindings difficult or laborious.\n\nSo some of my code had types, and some didn't, with no real indicator to an outside reader as to why. In the end I thought it looked unprofessional and that delivering plain JS was a better choice.\n\nPlus there are so many developers using things like Scala.js, PureScript, CoffeeScript, ClojureScript, etc. They can interop with JS, so if your code is a library TS becomes even less attractive.\n\nI support providing TS bindings with your JS code, but i think you still need to write JS.", "id": "d2ksn0l"}, {"comment": "I don't see how the fact that you have some types is \"unprofessional\". Also if you write your library in TS you ship it as JS. As it happens Angular2 does just that. Why the hell would you write JS instead of TypeScript if you will provide TypeScript bindings. That is literally what the TypeScript compiler does - removes types and leaves pure, human-readable JS.", "id": "d2ktzhx"}, {"comment": "The static typing is the main win in Typescript imho, rather than the ES6 functionality. Parts of ES6 have existed in various libraries like Underscore.js for a long time. \n\nStatic typing is great when you walk into an unfamiliar codebase, because it prevents you from using the code in ways it wasn't meant to be used by mistake.\n\nFor those who wish they had access to static typing in the browser, I consider Typescript the strongest option out there.", "id": "d2kpd5u"}, {"comment": "I'm primarily a strongly-typed kind of guy, so i can appreciate that position. But there is always this small gap between the compile-to-js languages and js itself that can be real pain points when you have a lot of existing js codebase or want to use a lot of 3rd party js stuff.\n\nI found it was just simpler to stay with the JS standards and to hope for eventual browser inclusion.", "id": "d2kqfep"}, {"comment": "> The reason I say that is to show that TypeScript mainly offers type checking and bundling, not transpilation. Which is fine, but most people don't really need it.\n\nHe actually mentions that in the article. \"You want static analysis.\". Not many arguments for why but the common ones are that for medium sized or larger SPAs type checking can be very helpful and save a lot of time for refactoring or just getting to know someone else's code.\n\nThe thing keeping me off TypeScript for the moment is some problems people have had with combining different module systems (TS and commonjs) and getting soruce maps to work over everything. It might be better after TS 1.8 but is still something that might cause problems.", "id": "d2kgoei"}, {"comment": "Is Medium evolving into \"Long Form Hacker News\"?", "id": "d2kejrt"}, {"comment": "Are you guys aware that medium.com is a blogging platform, like wordpress or tumblr?", "id": "d2khe41"}, {"comment": "Yeah, it's actually a pretty great one imho, the editor and aesthetic is nice. But sadly the content is really all over the place because literally anyone can post on there. I tend not to click medium links until I've read the Reddit comments first to be sure the content is decent quality.", "id": "d2kphw0"}, {"comment": "Yes, but each platform seem to take on a sort of tone much like how food in the fridge all tends to taste the same if left open, flavors blend and average.\n", "id": "d2lxjhc"}], [{"comment": "[deleted]", "id": "d2js6cd"}, {"comment": "Frankly that may be irrelevant. In the past year I have not seen or heard anyone starting a real world project with JS that does not involve some kind of transpiler. If you are going to transpile your JS downlevel you can just use TypeScript and get additional benefits. One can also argue that browsers do support TypeScript just not the typing part :)", "id": "d2jtwu8"}, {"comment": "I might wanna warn you that you might be in a bit of a bubble. I do repair freelancing work and i still see base javascript php all the time.\n\nI just started seeing my first angular 2 thing that went to production.", "id": "d2jycp9"}, {"comment": "You're in a different bubble. Freelancers build small, visually pretty websites but with horrendous code.\n\nIf you're building a large scale web-app it's going to be a little more involved.", "id": "d2kb6lg"}, {"comment": "I don't think i was arguing that frameworks are not needed. I was just saying there is a lot of vainilla javascript still getting done. There is still a lot more code that is not transpiled than transpiled code out there. \n\n\nHeck there is still a lot of vb6 code being written :(", "id": "d2kcekx"}, {"comment": "For sure. I'm trying not to stray too far from vanilla JS because I still don't see a clear winner.", "id": "d2kd8rn"}, {"comment": "There's still a lot of COBOL and Fortran being written. Your point is?", "id": "d2kelui"}, {"comment": "Who writes Fortran? I figured they'd all moved to Python", "id": "d2keqzn"}, {"comment": "It's still in use because the compilers can produce very performant vectorized code. In some cases it can produce faster code than C++, or is significantly easier to get to that level of performance than bashing your head against the wall and trying to figure out SIMD hacks to squeeze more out of your code.\n\nThe biggest proponent is probably NASA [who can't quit it](http://www.nas.nasa.gov/publications/ams/2015/04-28-15.html).", "id": "d2kex8l"}, {"comment": "Oil companies do", "id": "d2kgd00"}, {"comment": "No need to throw poo", "id": "d2keuk9"}, {"comment": "What? Am I insulting freelancers? I do both freelance and full-time work. The code is actually shit in both scenarios. Full-time shit is just slightly more structured shit.", "id": "d2ljkvf"}, {"comment": "I have three projects in typescript across multiple companies. If it hasn't won, it should. ", "id": "d2k0emy"}, {"comment": "Im on your team i was just letting others know there is a lot of code still being created that doesnt even use jquery.", "id": "d2k0zjm"}, {"comment": "Well yeah. If you see PHP there is no wonder you see JavaScript. I mean unlike JS which happens to be the only language working in the browser nobody forces people into PHP. But honestly I'd rather quit IT and go take care for sheep in a farm or something than work with PHP.", "id": "d2ke1nz"}, {"comment": "Laravel is actually kinda cool for small websites. Ive seen some nice pages made with that and vue.js on the front.", "id": "d2keacc"}, {"comment": "Sorry I won't even check. Will still take the sheep.", "id": "d2kexvz"}, {"comment": "You're working on code that's already been written. What people are *choosing to write* today is a different mix entirely.\n\nWith frameworks like React and JSX, Microsoft's TypeScript, Rails and Ember popularizing CoffeeScript, plus other projects using Emscripten and asm.js there's a considerable amount of new JavaScript code being written and transpiled.\n\nFor example: It takes a *lot* of JQuery code to add up to a single heavy weight front-end project written in Ember, Angular or React.", "id": "d2kelfp"}, {"comment": "Or a better language altogether. I mean if you are already forced to go through  a compiler step, why not go all the way? I use purescript for example.", "id": "d2jxm9c"}, {"comment": "Woah, Purescript's tooling and IDE support have improved drastically in the past little while, That said, it feels like a matter of Haskell vs C#. Cleaner translation to and from JS is still (unfortunately) beneficial from a webdev's perspective, as is the first class support in VS, VS Code, Webstorm et al.", "id": "d2k39vd"}, {"comment": "Because excluding web assembly the underlying language dictates parts of the semantics of the compiled language and also because you still need to debug. Source maps work but even with TypeScript many tools fail to provide accurate information. They provide accurate line numbers but I have seen cases where a variable name means one thing in a TypeScript class/namespace and another in JavaScript. The final reason is the ecosystem and know-how. You can not only call into the JS ecosystem with TypeScript you can fully embrace it like literally copy/paste stuff into your codebase.", "id": "d2ke02c"}, {"comment": "> because you still need to debug.\n\n...because you still use crappy javascript (in the Typescript reincarnation). \n\nModern purely functional languages (purescript for example) approach state handling in a way that eliminates most causes of bugs. Add to it very rich Type system that allows proper handling of nulls (no null pointer errors) and you can see how working with purescript leads to a more productive time spent compared to TypeScript and js, even with debugger enabled.", "id": "d2kplg2"}, {"comment": "Sure great, now you only need to hire Haskell programmers somehow :)", "id": "d2kppj0"}, {"comment": "Isn't it the case with any programming language? You know better than me, that there's one good programmer for every 100 crappy ones. That's when you hire js, java, c# programmers. At least with haskell i know that the bar is so high, that anyone who cleared it is good enough for me. And in our day of global interconnectivity, remote hiring is not an exception anymore, which makes finding haskell programmers much easier.\n", "id": "d2kpv4k"}, {"comment": "That surely is a way to run a company but it doesn't scale :) Also unless you provide very good conditions you have to hire less than ideal programmers. Most companies better aim for the moneyball team.", "id": "d2krz2b"}, {"comment": "> That surely is a way to run a company but it doesn't scale :) \n\nOh i did not know i'm talking to a project manager from a Fortune 500 company :)\n\nHow many teams bigger than 10 programmers you've worked with?\n", "id": "d2ku6ky"}, {"comment": "No, I did not mean it won't scale in a company I meant it won't scale for the industry. A couple of companies will hire all the Haskell programmers and then what?", "id": "d2kuddg"}, {"comment": "JavaScript is the assembly language of the internet.", "id": "d2kirq4"}, {"comment": "That metaphor does not work especially in the presence of asm.js but even before that you can easily drive it to the point where it fails. Assembly does not dictate your null/undefined semantics or punish you with a severe performance penalty if you chose to have your own. Assembly does not provide an API surface that is riddled with specific high-level semantics that the language you implement must be compatible with if you want to do anything useful.", "id": "d2kj1tb"}, {"comment": "hopefully webassembly will fit that role", "id": "d2kjnb5"}, {"comment": "The metaphor is not that, it's that JavaScript seems to be the lowest common denominator for running things online. Want to run something on your computer? It's transformed to assembly. Want to run something in the browser? It's transformed into JavaScript.", "id": "d2kj81o"}, {"comment": "I started a \"real world\" project with JS just a couple weeks ago and I've never heard the word \"transpiler\" before.", "id": "d2k484y"}, {"comment": "You still have time to go back and switch to TypeScript.", "id": "d2ke2nv"}, {"comment": "Yeah, but how many people know how to write TypeScript in 5 years? It might dead by then for all we know. ES6 is atleast the standard. ", "id": "d2kln90"}, {"comment": "Writing TypeScript is not like writing CoffeeScript. It IS ES6 + optional types. Basically everyone who knows how to write JavaScript knows how to write TypeScript but will not use all its benefits. If you learn something about types (which takes probably a day to get used to if you know C++, Java or C#) then you get more benefits.\n\nHell, lets say that TS is dead in 5 years. Switch the output to ES6 take the resulting .js files and go on developing as if you were on ES6/Babel from the start. There is 0 risk in adopting TS.", "id": "d2kmrdr"}, {"comment": "It is irrelevant. \n\nMost professionals are linting and minifying their stuff already anyways -- a transpiler adds no real cost.", "id": "d2km2uy"}, {"comment": "By this time next year... April 28, 2017, I predict that ES6 + http2 will eliminate the need for transpiling to JS and bundling JS/CSS for most websites. Lots of companies who can't fathom dumping windows 7 yet are feeling pressure to allow chrome and firefox to be installed.", "id": "d2kertu"}, {"comment": "RemindMe! 1 year \"lets see how this works out\"", "id": "d2kezcw"}, {"comment": "* http2 eliminates the benefits from bundling multiple source files to save http requests. It will have 90% support and be backwards compatible for older browsers to be a little slower. Bundling is one of the reasons to transpile.\n\n* es6 adoption is 90+% among 80+% of browsers will be 100% support among 90% of browsers in a year. Lack of browser support is another reason to transpile.\n\n* Also Chrome is the most used browser so pressure will build among users and vendors to support/adopt it. Increased Crome adoption leads to increased browser support. Lack of browser support is another reason to transpile.", "id": "d2qlk2h"}, {"comment": "Which could happen with a Typescript to WebAssembly compiler.", "id": "d2juyc8"}, {"comment": "This argument is irrelevant.  Any language with a WebAssembly compiler could \"win.\"  That's STILL irrelevant because then it doesn't matter wich language people use.  ", "id": "d2jw8n7"}, {"comment": "Other than better performance, is there really a significant difference between compile-to-js and compile-to-WebAssembly?", "id": "d2jz6sc"}, {"comment": "From what I understand, web assembly acts like asm.js. That is you can't actually user the DOM.", "id": "d2kc3mf"}, {"comment": "Yes, there is no DOM access yet, but it's on the roadmap: https://github.com/WebAssembly/design/blob/master/GC.md\n\n> After the MVP, to realize the high-level goals of (1) integrating well with the existing Web platform and (2) supporting languages other than C++, WebAssembly needs to be able to:\n> \n> * reference DOM and other Web API objects directly from WebAssembly code;\n> * call Web APIs (passing primitives or DOM/GC/Web API objects) directly from WebAssembly without calling through JavaScript; and\n> * efficiently allocate and manipulate GC objects directly from WebAssembly code.\n", "id": "d2kfqud"}, {"comment": "Not until WASM supports garbage collection - which isn't the first thing on the roadmap. This means for the vast amount of languages Javascript will continue to be most valuable compilation target.", "id": "d2kfgm3"}, {"comment": "> browsers natively support typescript\n\nChrome and firefox let you debug the actual typescript by setting up a map path.  Pretty big win in my opinion. ", "id": "d2kobyz"}, {"comment": "How would the browser support typescript? You don't need types at runtime.", "id": "d2ks8z7"}, {"comment": "It could ignore type annotations, for example", "id": "d2ksjzg"}], [{"comment": "It is a pretty great experience in Visual Studio now. Minimal hassle, and you see more of your errors at type time, annnd it is easier to explore libraries with autocomplete.\n\nSimilarly nice workflow in Atom and VSCode\n", "id": "d2jv4fn"}, {"comment": "Webstorm will even code complete HTML inside strings, and even complete expressions in an HTML template. And it has infinite local history in case you fuck up your working copy", "id": "d2k0bjh"}, {"comment": "Love Webstorm/Phpstorm but I'd say it's support for TS is still shit.", "id": "d2kb7x1"}, {"comment": "11 is solid. what do you find lacking, specifically? I've had no issues.", "id": "d2m1rl2"}, {"comment": "how so? i get code completion, jump-to-definition shortcuts, interface violation checks, auto-compiling and map creation, auto-import... and a number of config options for TS. what specifically, do you think is lacking?", "id": "d323ant"}], [{"comment": "What's that? There were people who doubted Anders (Hallowed be His name)? Heretics!\n\nOn a more serious note when did the strong script experiments \"fail\"?\n\nAlso note that TypeScript 2 will add flow based typing (similar to Facebook's Flow) which means that even if you do not write a single type and go all dynamic TypeScript will still inform you about some errors. The tooling with some type definitions will also be very useful to people who do not care about types so TypeScript will be (or maybe is today) the best way to write dynamically typed JavaScript.", "id": "d2jue42"}, {"comment": "> On a more serious note when did the strong script experiments \"fail\"?\n\n[Here's the status update](https://groups.google.com/forum/#!topic/strengthen-js/ojj3TDxbHpQ)", "id": "d2jw7w3"}, {"comment": "Hmm it seems like the typing part is still a target and has not failed.", "id": "d2kf9mo"}], [{"comment": "Winning against other JavaScript dialects is like winning in the Special Olympics. It's still fucking retarded.", "id": "d2jytc9"}, {"comment": "On the web we have no choice. I wish Firefox or some major browser will just support a completely different language like squirrel, or even C++ will work sand boxed. If they do sandboxed C++ then we can use any language we want.", "id": "d2k19zt"}, {"comment": "Google already tried with Dart. Nobody cared.", "id": "d2k8iqu"}, {"comment": "They invented a new language which offers nothing new. They should have used an existing language where people already have a code base to use. That way new possibilities will arise.", "id": "d2k8v6s"}, {"comment": "Google over-extended themselves. Transpiling Go to JavaScript would've been a better plan than coming up with some newfangled *whatever* project from Google.", "id": "d2kemr6"}, {"comment": "WebAssembly may yet grant our wish.", "id": "d2k8m2k"}], [{"comment": "As a newbie building little web apps to hopefully get hired later I'm just thinking I hadn't even started working with ES6 and there's apparently this other thing that's already beaten ES6 and has more things in it. I guess I wouldn't even know how to begin using typescript in my JS code.", "id": "d2jsah5"}, {"comment": "It's really easy. Any valid JS works with typescript, as it's designed to be \"progressively\" typed. If you're familiar with node tooling, all you have to do is [pull down the compiler, rename your js files to ts, and run the tsc with the ts files as arguments](http://www.typescriptlang.org/docs/tutorial.html). Or you can [create a config file and just run tsc](http://www.typescriptlang.org/docs/handbook/tsconfig.json.html). I'd recommend looking into it!", "id": "d2jsr6g"}, {"comment": "I was already interested in ES6 just because typing and \"normal\" looking class construction is more familiar to me. I may have to give this a try, thanks for the info!", "id": "d2jsyl5"}, {"comment": "Absolutely! Let me know if you have any questions. The documentation just got a big overhaul so it should be really easy to parse, and the stack overflow tag as well as the gitter channel are always good places to get answers.", "id": "d2jt4ev"}, {"comment": "That's just the thing.  Now that ES has typing and normal looking class constructions there is no point to using TS.  ", "id": "d2jwaze"}, {"comment": "ES doesn't have typing.  It's not even on proposal.", "id": "d2kc7ol"}, {"comment": "TS supports private class members and methods. ES6 doesn't.\n\nNo more prefixing with _ and hoping people don't use them. The honor system is the worst form of encapsulation.", "id": "d2l57fs"}, {"comment": ">  beaten ES6 and has more things in it\n\nIt doesn't beat ES6, it just a different workflow. All your knowledge in plain JS is transferable to it. The only thing you need to be aware is which workflow you find yourself more comfortable \"dynamic\" or \"static\". ", "id": "d2jt4in"}, {"comment": "Once TS2 ships it will be better even if you prefer dynamic due to flow typing.", "id": "d2ju52m"}, {"comment": "[deleted]", "id": "d2jufk0"}, {"comment": "The compiler analyzes the code statically and figures out the possible types for variables even if they are not explicitly declared.\nhttps://channel9.msdn.com/Events/Build/2016/B881 - skip to ~45:00 (15 min total)", "id": "d2jv3zc"}, {"comment": "I started off simply by annotating my javascript code with proper typing. Going through just this step surfaced quite a few subtle bugs.", "id": "d2jsrra"}, {"comment": "You need to jump through the build system hoops regardless of whether you want to use Babel or TS (or modules w/ es5).\n\nIf you are just learning things and fiddling around, you could be better off with Babel as there is less concepts to learn (and trivial apps don't get huge benefits from TS, short of better editor intellisense)", "id": "d2jt4ya"}, {"comment": "As if better intellisense is a small thing. It is even more useful while learning.", "id": "d2ju6dp"}, {"comment": "That's a good point, I feel I'll need something non trivial in my portfolio by the time I finish school though so might be worth getting in to now.", "id": "d2jt83z"}, {"comment": "You have lost nothing. Everything ES6 is valid TypeScript so...", "id": "d2jty7f"}, {"comment": "> Everything ES6 is valid TypeScript so...\n\nI wish.  I had so many little errors trying to convert some ES7 babel modules to TypeScript files.  Granted, I don't know all the little secrets for TypeScript yet, there are some hoops to learn, like inserting \"any\" and mostly empty interfaces to workaround some constructor issues in React.", "id": "d2kb3cl"}, {"comment": "Babel moves faster than TypeScript with the risk of breaking a feature if the standard changes. ES7 is not yet fully supported in TS (only bits and pieces) so you may have hit a piece of ES7 that is not yet supported in TS. Second the TS compiler can still spit the JS even if you ignore the errors so \"every ES6 is valid TypeScript\" is technically true but why would you ignore the errors? As you said there are also little tricks like the \"implicitly typed any\" switch that make the compiler skip certain checks.", "id": "d2ke6vf"}, {"comment": ">  I guess I wouldn't even know how to begin using typescript in my JS code.\n\nYou begin by just writing JS.  That's kind of the guiding principle behind TypeScript.", "id": "d2k69kh"}, {"comment": "http://www.commitstrip.com/en/2015/09/16/how-to-choose-the-right-javascript-framework/\n\nhttps://cube-drone.com/comics/c/relentless-persistence", "id": "d2jxt1w"}, {"comment": "Author is exaggerating. ES6 beats TS in terms of features; they're lagging behind. TS might win at type-checking if you have the patience for it though.", "id": "d2kbegt"}, {"comment": "> TS might win at type-checking if you have the patience for it though.\n\nPatience for what... correct programs? Most JavaScript software should webscale its way straight into the garbage bin.", "id": "d2l5bfk"}, {"comment": "Last few times I tried using it, it just lit up like a christmas tree and I couldn't get anything to compile, even though it ran fine as plain JS. If you're building a big web app, sure, it might be worthwhile to type-hint the shit out of all your existing code *plus* all your exotic 3rd party libs (which can take days), but if you want something up and running quick, maybe not.", "id": "d2lij6d"}], [{"comment": "The fact that Neatbeans Typescript third party plugin give better experience than default Javascript integration says something.", "id": "d2juwvv"}], [{"comment": "Are there any major features of TypeScript that aren't already supported by [Babel](https://babeljs.io/docs/plugins/syntax-flow/) + [Flow](http://flowtype.org/)? Embracing and *extending* JavaScript seems to be a non-goal of TypeScript (although it's not explicitly mentioned [here](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals)).\n\n The Babel codebase itself is written with type annotations. There's even a [plugin](https://github.com/codemix/babel-plugin-typecheck) which allows them to be enforced at runtime.", "id": "d2jvoa7"}, {"comment": "I tried to use Babel + Flow for a project, but that setup is definitely inferior to TypeScript at the moment. Here are a few of the problems:\n\n# Configuration\n\nIt's quite difficult to configure Babel and Flow and a build system to work the way you want. Both projects have also introduced breaking changes pretty frequently, meaning that many of the documentation online is wrong. If you want to use something like ESLint in addition to Babel and Flow, well, good luck!\n\nTo be clear, it is possible to configure all of this stuff, and if you're working on a larger team then maybe it's not as big a deal, but I hate all the complexity that is needed even for small projects.\n\n# Speed\n\nTypeScript is way faster than using Babel and Flow. For some of my builds it was 5-10 times faster, which is pretty ridiculous. I probably could have done a bit more to get Babel and Flow working more quickly, but why should I when I can just run TypeScript and have it work out of the box?\n\n# Flexibility\n\nTypeScript's type system is more flexible than Flow's, though they do have to give up some specificity for it. But for me this ended up being a big deal. Flow complained about many things that should have been perfectly legal. When I tried workarounds, Flow usually seemed to just give up type checking altogether. It became really frustrating and difficult to be productive. In TypeScript, for all of my use cases they had nice examples in their documentation, and I was always able to be as precise as necessary.\n\n# Documentation\n\nTypeScript has much much better documentation than Flow. I also don't like the tone of the Flow docs - they come off as being sort of uppity (for lack of a better word), and they seem more focused on showing off the \"innovations\" they've introduced than demonstrating practical usage of Flow.", "id": "d2jxh9m"}, {"comment": "**Configuration**: That's not an issue for me :-) We all use a bunch of stuff in ES/JS. We all have Grunt/Gulp/Makefiles/Rakefiles &c. tools for dealing with this. This stuff takes a couple of seconds a day in my workflow.\n\n**Speed**: tsc was dealbreakingly slow for me, so I'm not convinced by this.\n\n**Flexibility**: The main reason I gave up on TypeScript was that the compile times were so sloooow.\n\n**Documentation**: Fair enough.\n\nAlso: a) TS has better IDE support/integration and b) better support for interfaces + nominal typing.", "id": "d2jz0t1"}, {"comment": "Hi there, I'm a dev on the TypeScript team. Can you please tell me more about the slowness you experienced, and what version this was on? That is something we're always trying to keep an eye on.", "id": "d2k6dxc"}, {"comment": "With the speed issue, are you talking about file watching or regular builds? Because every real-world Gruntfile or Gulpfile that I've seen takes about 5 seconds just to launch (loading all the tasks/plugins/whatever).", "id": "d2jzjvg"}, {"comment": "Flow just completely failed on my project. It just ate up memory until it died. I mean, I know the JS in my project is fucking awful, but it should at least complete.\n\nTSC I can't say. Every time I try TS I just give up because it's too much of a headache to get anything done.", "id": "d2kbbk5"}, {"comment": "> Also: a) TS has better IDE support/integration and b) better support for interfaces + nominal typing.\n\nTS has **no** support for nominal typing. It's considered for TypeScript 2.1.", "id": "d2kc1b1"}, {"comment": "Not to mention that the typescript compiler does module bundling, so you don't necessarily need to add browserify into your build.", "id": "d2k5rtr"}], [{"comment": "Does it have async/await already?\n\nThat's one killer feature Babel is worth using for.", "id": "d2jyr6y"}, {"comment": "async/await for ES5/3 targets hopefully coming in a couple of months. async/await for ES6 targets already there.", "id": "d2kevck"}, {"comment": "As of a couple versions ago, [yes](https://blogs.msdn.microsoft.com/typescript/2015/11/30/announcing-typescript-1-7/).", "id": "d2k32im"}, {"comment": "Only if you're targeting ES6. Otherwise you need babel or something else to get generator support. ", "id": "d2k5u6y"}, {"comment": "Yeah, it has - although you need to set thd output to ES6 (So the TS compiler generates ES6) and then you compile down with Babel.", "id": "d2kkhgd"}], [{"comment": "I remember first hearing about TypeScript at a Microsoft demo years ago, didn't pay too much attention to it until now, seems like it's gotten big!", "id": "d2k3347"}, {"comment": "It really hit the hype cycle when it (recently) got adopted by Angular.js. So that's why you're hearing about it a lot lately. ", "id": "d2ketfy"}], [{"comment": "I generally agree with other comments - declaring victory is kind of silly.\n\nI would say that TypeScript is the best way to write JavaScript today. That doesn't mean that it's the best for all eternity, but if you're going to start a project now (or even if you have an existing project), the selling points of TypeScript are too good to ignore.", "id": "d2k6esr"}], [{"comment": "Didn't WebAssembly win?", "id": "d2k6jlm"}, {"comment": "[YavaScript will prevail in the end.](https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript).", "id": "d2kendw"}, {"comment": "Ah yes.", "id": "d2kerr2"}], [{"comment": "I certainly find Typescript the most appealing non-Javascript around but ES is not staying idle, and it's instantly and natively supported in all browsers, which gives it a huge advantage.\n\nAs long as ES stays within reasonable distance of Typescript, it will stay ahead in mind share.\n\n", "id": "d2jx7ds"}], [{"comment": "That's not a Venn diagram. That's an Euler diagram.", "id": "d2k91r4"}, {"comment": "It could be both. The difference between a Euler and Venn is that a Euler can show the relationship (or lack of one) between disjoint sets by the set being separate while on a Venn diagram the disjoint sets are showed to intersect with the elements of each set in the non-shared zones.\n\nBecause this situation involves only superset/subset relationships, both would work. You're right that Venn diagrams aren't usually used to represent that kind of relationship, but I don't think there is a rule or property of them that would indicate that they can't be. ", "id": "d2kok7m"}, {"comment": "One of the rules of Venn diagrams is that there exists an enclosed space for every combination of option. Having X inside Y does not give you the option of (Y & not X)", "id": "d2n2xb4"}, {"comment": "Then you wouldn't put X inside of Y...", "id": "d2ny7rc"}, {"comment": "If you don't have Y partly inside X then you don't have the option of (Y & X).\n\nA Venn diagram for sets X and Y requires closed areas for (X & Y), (X & not Y), (Y & not X), (not X & not Y).\n\nX in Y only gives you 3 of those.", "id": "d2o28m1"}, {"comment": "Right, and that's why you don't put X inside of Y.", "id": "d2pkc2m"}, {"comment": "X is inside of Y in the picture in the article. The [picture](https://cdn-images-1.medium.com/max/800/1*8lKzkDJVWuVbqumysxMRYw.png) has 3 choices, which will give you 8 combinations of choices but there are only 4 distinct areas. This is not a Venn diagram.", "id": "d2plk4e"}, {"comment": "That's not \"3 choices\" though. Each smaller circle represents a subset relationship with the one around it. There's only one choice, or if you break it down to three, then the two parents imply their decendents.\n\nThe point is that that relationship cannot be expressed using the kind of Venn diagram you are talking about where it shows \"left\", \"intersection\", \"right\". A Venn shows all possible relationships, and this shows all possible relationships between these sets.\n\nIf a Venn diagram are circles that represent common elements and uncommon elements, then this does that.", "id": "d2pyxlx"}, {"comment": "Okay, \"choices\" was a bad word to use. \n\nI understand that each smaller circle represents a subset relationship. I understand the relationship between parents and descendants here.\n\nThe type of Venn diagram I am describing is the Venn Diagram. The \"left\", \"intersection\", \"right\", (and \"enclosing\") Venn diagram is the way all Venn diagrams for two sets will look. Every property of the graphs that you've described are properties of Euler diagrams, not Venn diagrams.\n\nThe wikipedia page for Venn diagrams has a pretty solid explanation that backs me up on this. https://en.wikipedia.org/wiki/Venn_diagram\n\nAlso, this is how you would express the Euler diagram from the article as a Venn diagram https://i.imgur.com/s9sZdNt.png", "id": "d2tlgqm"}, {"comment": "> The wikipedia page for Venn diagrams has a pretty solid explanation that backs me up on this. https://en.wikipedia.org/wiki/Venn_diagram\n\nAnd notice it says Venn diagrams are a special case of Euler diagrams...\n\n> Also, this is how you would express the Euler diagram from the article as a Venn diagram https://i.imgur.com/s9sZdNt.png\n\nI disagree with this because it implies that there are or could be parts of ES6 that are not a part of TS, for example. And maybe there are actually some, but the point is that the diagram we are discussing was representing the case where there are not.", "id": "d2tpda7"}], [{"comment": "Slightly OT: does the new ES6 spread operator ...args conflict with TypeScript's need to match parameters to call target (common compile error then \"Supplied parameters do not match any signature of call target.\")", "id": "d2kd4mo"}], [{"comment": "I can see that the author wants TypeScript to be \"winning\". That doesn't mean that it is. He is however mentioning a bunch of popular projects who are loosing popularity in favour of mostly ES6/ES2015; Dart and CoffeScript.\n\nIf you look at google search trends for TypeScript and ES6 you will see that they follow each other closely, and I have no reason to belive that TypeScript will go out of that battle victorious.  Just look at the examples that the article says \"failed\", namely Dart and CoffeScript. Both project try to do something different than JavaScript, and in fact; thats what TypeScript do as well. It might try to call itself a superset of JavaScript, but that still makes it something else than JavaScript. And I don't think its going to work, because it didn't work for CoffeScript and it didn't work for Dart. So why should it work for TypeScript?\n\nBabbel definitely looks like where the world is headed. It integrates nicely with a Gulp or Grunt workflow. It's the same principles that fuels PostCSS. We see a clear trend of creating small scoped plugins which we can compose as we see fit. Babel, Gulp, PostCSS; these are the tools are the future! What we need is a Babel plugin for adding and checking types. ", "id": "d2kfvbd"}], [{"comment": "The author's line of reasoning is that, since ECMAScript 6 is introducing new features that also exist in TypeScript, it must be that TypeScript is winning. Except: ES6 started a couple of years before TypeScript - in other words it's not clear that ES6 is adopting new ideas from TypeScript rather than vice versa. And, of course, ES6 has indisputably *not* adopted static type annotations, which is kind of the main feature of TypeScript. That's kind of like saying that, when C99 introduced intermingled variable declarations like C++, C++ 'won'.\n\nTypeScript is great if you're into that sort of thing, just like C++ is great if you're into that sort of thing. But not everyone is.", "id": "d2kjwl9"}], [{"comment": "these short lived languages never \"win\"", "id": "d2kkw7z"}], [{"comment": "Man, I really wish there was a typed CoffeeScript...\nI like Dart a lot, but dart2js compile times can be atrocious.", "id": "d2kmabt"}], [{"comment": "I have no idea who \"won\", but the competition seems to be missing languages like Elm, Clojurescript & Purescript. If, as is the case with most new projects, you are transpiling anyways, you might as well go the whole way and choose a language that's not just an afterthought of JS.", "id": "d2kyrex"}, {"comment": "If you have a team and long term project, you don't want to pick something you can't back away from in case language / community stagnates", "id": "d2l0ihd"}, {"comment": "True. Then again, at least Clojurescript has been around longer than Typescript. Doubt it is going anywhere.\n\nFor the other two it might be too early to tell if they are stable.", "id": "d2l17cm"}], [{"comment": "I have no reason to use TypeScript", "id": "d2ki6hm"}], [{"comment": "Doesn't the rise of WebAssembly means that JavaScript is losing traction?", "id": "d2kufr9"}], [{"comment": "No it didn't.  \n\nActuality it looks like elm is going to win. ", "id": "d2jx2at"}, {"comment": "Does it? I recently started a project in Elm and seriously tried to make it work, but the language lacks in some areas, the ecosystem isn't that great, JS integration via ports feels really awkward.. on top of that, evancz doesn't seem very responsive. I ended up rewriting in TypeScript/React/Redux instead.", "id": "d2k2oxf"}, {"comment": "or purescript ;)\n", "id": "d2jxppf"}, {"comment": "or ES6", "id": "d2khcgi"}, {"comment": "I really really really hope that you are right. I kinda feel that typescript is the bottom-up approach \"We have javascript, how can we add stuff to it until it sucks less?\" whereas elm is the top-down approach \"how would we do this _right_ if we could start from scratch?\".\n\nWith that, elm is still missing some stuff - but its getting there. And I truly hope that it will make it all the way into the mainstream.", "id": "d2keykq"}, {"comment": "Elm is competing with other 'alien' (non-js) languages. It's not clear it's better than other similar languages few years down the line", "id": "d2ksp0e"}], [{"comment": "Until ES7 comes out and then what? Why use Typescript over that? ", "id": "d2jsc2c"}, {"comment": "You have to at least scroll past the first image.\n\n> Overtime it will be more than ES6 maybe something like ES2017. But the same principle will apply, because of TypeScript\u2019s design goals. Its going to be a superset of JavaScript next.", "id": "d2jsggb"}, {"comment": "If TypeScript continues to a superset of JS, doesn't this mean that whatever stupid decisions that the ES standard authors make, TypeScript will need to follow - essentially tying your product to the trust that someone else won't do something stupid.\n\nIf you don't trust the ES guys, you can't trust TypeScript to do the right thing either. It's like an added \"don't mess up\" dependency; I need to rely upon TS and the ES people not to mess up in order to use TS.", "id": "d2jvmec"}, {"comment": "Because it has a static type system, which many developers consider to be better than not having one", "id": "d2jst5q"}, {"comment": ">which many developers consider to be better than not having one\n\n[It's basically this like this.](https://ro-che.info/ccc/images/typing.png) If you have a sound understanding of types, then justifying dynamic typing is really hard.", "id": "d2jtuvv"}, {"comment": "It's more that justifying dynamic typing from a type-theoretic perspective is really hard. This is because the advantages of dynamic typing are rooted in software engineering, not type theory.", "id": "d2k9tik"}, {"comment": "Even then no. Dynamic languages are really only useful when you care about your ability to make out out as many SLOC/day as possible. \n\nWhich most of this is technical debt as you'll need more rigorous testing, and advanced devops solutions as you scale. Eventually you'll perform a full rewrite in a statically typed language.\n\nFrom an engineering perspective dynamic langs are bad. From a management perspective they're an acceptable margin play while growing. ", "id": "d2ki0bb"}, {"comment": "That's my point. [ES7 will have a type system](https://github.com/dslomov/typed-objects-es7), which is the main selling point of abstracting out in TypeScript. ", "id": "d2ktwny"}, {"comment": "ES7 has very little new features.\n\nThe link you point to is not a static type system but a runtime thing", "id": "d2l0f6h"}, {"comment": "Because valid javascript is valid typescript. I use an approach where I \"decorate\" my javascript code with typescript which allows me to opt in to the exact feature set that I want to. A better question, to me, is why wouldn't you?", "id": "d2jsm6u"}, {"comment": "I think Typescript will still win, because they can add new features much faster. Meanwhile ES version X has to be standarized which can take years and another few years for the features to be widely supported cross-browser.", "id": "d2jtb0f"}, {"comment": "Typescript is on top of javascript so it can't beat javascript.\n\nES version X is a world wide standard.\n\nTypeScript is a Microsoft product.\n\nThe last javascript product to rule the world was Dart. Ever hear of that anymore?\n\nNow who do you thinks will \"win\"?", "id": "d2k1sfc"}, {"comment": "Dart didn't rule anything, besides a few Silicon Valley startups trying to look cool for possible Google acquisitions, no one really cared one second about Dart.\n\nTypescript was even adopted by Angular team, I wonder for which company they work for.", "id": "d2kdexr"}, {"comment": "That's my point, though I didn't write that the way I meant. But TypeScript will fade to black just as quickly.", "id": "d2ki26n"}, {"comment": "> But TypeScript will fade to black just as quickly.\n\nThat I doubt, given the industry adoption of it including Google, versus all the JavaScript alternatives that came before it. \n\nIt will only fade the day JavaScript ends up getting all Typescript features or WebAssembly wins in browser space and we finally get rid of JavaScript and its flavors.", "id": "d2kjztu"}, {"comment": "Every new thing claims it will win but standards always win out. This too shall pass.\n\n>and we finally get rid of JavaScript and its flavors.\n\nTypescript is a superset of javascript so eliminating that eliminates typescript. Notice how you've only had this flurry of activity over the last number of months. Not much before and you won't hear as much next year.\n\nIn three years, maybe five, typescript will only be a footnote.", "id": "d2kk7me"}, {"comment": "On Windows shops Typescript does get lots of love.", "id": "d2kku0u"}, {"comment": "Well, of course. It's a Microsoft product but 85% of the internet runs on Unix and Unix-like systems.", "id": "d2klfzj"}, {"comment": "Might be, but I also know quite a few Fortune 500 that have their whole IT infrastructure built on top of Windows, including IIS.", "id": "d2kmd6v"}]]], "4bdyp1": ["Home-made hash tables in C++: a race against Java", "2016-03-21 23:56:45", 0, "http://pzemtsov.github.io/2016/03/21/home-made-hash-tables-in-cpp-a-race-against-java.html", [[21, "Poorly written C++ code runs slower than regular Java code. Yeah, there's a surprise. "], [13, "> The general myth \u201cC++ is always faster than Java\u201d is busted.\n    \n\u0ca0_\u0ca0"], [9, "I only skimmed this, but in a lot of the code you've posted, you're passing by value/copying objects all over the place in the C++ code.  That's a huge red flag for me.  E.g., instead of \"Point w\" in this code: \n\n    void set(Point w)\n    {\n        for (Point p : w.neighbours()) {\n            inc(p);\n        }\n        field.insert(w);\n    }\n\n    void reset(Point w)\n    {\n        for (Point p : w.neighbours()) {\n            dec(p);\n        }\n        field.erase(w);\n    }\n\nYou should use \"const Point& w\":\n\n    void set(const Point& w)\n    {\n        for (const Point& p : w.neighbours()) {\n            inc(p);\n        }\n        field.insert(w);\n    }\n\n    void reset(const Point& w)\n    {\n        for (const Point& p : w.neighbours()) {\n            dec(p);\n        }\n        field.erase(w);\n    }\n\n"], [6, "Short lived Java programs might be slower than long lived, as the JIT is warming up early on. That might be one of the reasons why it's faster in the end."], [7, "Oh, another Lang1 vs Lang2 speed test from someone who obviously doesn't understand the topic enough to comment. Java shines in large applications on servers, its not about running some test case on your laptop. Its about how your application fairs under 10,000 requests. Are you aware of *why* the Java hashmap is written the way it is? Its done so because its an algorithmic solution to the problem of hackers taking sites down by repeatedly making requests of 1k length strings that have the same hash value (thus turning your bucketed hash map into a linked list, leading to slow down, and eventual crash). So when you compare your hacked together library, are you looking which is faster only? If so that is a bad way to think. You also need to worry about security and stability? Are you worried about the fact it has to be fast for floats, int, strings, and objects? \n\nWhen you implement your own code and compare it in two different languages like Java and C++, you have a lot of consider on why the choices were made in their respective libraries. You have to consider the strengths of the languages, and not just that specific structure, but the way the library fits into the language as a whole."], [6, "You should be pre-emptively allocating your memory in C++, otherwise you are wasting a ton of calls to brk().\n"], [4, "He doesn't mention any compiler flags so it is likely that the C++ version was compiled without optimizations."], [2, "> with those of GCC 4.5.4.\n\nwhy not a more recent one ?"], [2, "for(auto w: field) Value& X=w.second... should be slow, need to use (const) auto&."], [0, ">    The C++ program being three times slower than the Java version is an abnormal situation and a mystery. It must be investigated. I\u2019ll do that in one of the next articles.\n\nIndeed abnormal and unexpected. Looking forward to your findings. Maybe HotPath is kicking in? Also memory consumption would be interesting to observe."], [-7, "Java racing against c/c++ performance wise is like combining the Olympic and the Paralympic games... What's your point?"]], [[{"comment": "Poorly written C++ code runs slower than regular Java code. Yeah, there's a surprise. ", "id": "d18m01p"}, {"comment": "Pessimised C++ code, even. Based on a quick test, just editing the reference C++ implementation to keep the vectors between steps is faster than both the \"optimised\" C++ implementation after ~100k rounds and [the best optimised Java implementation after ~140k](http://i.imgur.com/eEhvfku.png).^^^^Based ^^^^on ^^^^the ^^^^shape ^^^^of ^^^^the ^^^^graph ^^^^it ^^^^*seems* ^^^^unlikely ^^^^that ^^^^the ^^^^Java ^^^^version ^^^^can ^^^^catch ^^^^up, ^^^^so ^^^^I ^^^^won't ^^^^bother ^^^^to ^^^^run ^^^^it ^^^^further.", "id": "d18rdtx"}, {"comment": "Could you show your version of the code? My measurements do not confirm this. Reference version modified your way takes about 950s for 200K, which is similar to your results (a bit slower perhaps). The latest C++ version (OK, I won't call it \"optimised\") takes about 670s, and Java takes about 240. The last number seems especially strange: why should your Java VM run four times slower than mine? It is unlikely that your machine is much slower - I'm running on a 2.6 GHz, and the program is single-threaded.", "id": "d18xrn0"}, {"comment": "No longer have the code, but changes were just:\n\n* reusing the vectors\n* commenting out the calls to TEST for things other than the real test\n* switching the implementation from HashAdditive to reference\n* removed the CRC intrinsic as MSVC doesn't have that\n\nAnd for java, just commeting out the other tests.\n\n>why should your Java VM run four times slower than mine? It is unlikely that your machine is much slower - I'm running on a 2.6 GHz, and the program is single-threaded.\n\nBecause this is a dumb microbenchmark that will hit a point where it will be doing nothing except wait for data to arrive from RAM and therefore effectively only measure the size of the CPU's cache. From the low clockrate I'm guessing yours is a Xeon, which have larger caches than what I have (a regular ol' quadcore i7), so meaningless microoptimisations will dominate the results for far longer.\n\nThis is also seemingly why the \"optimised\" C++ implementation is actually slower - profiler showed it spending most of its time just stalling at dereferencing of pointers, which means it was waiting for the stuff to arrive from RAM.\n\nedit: bloody markdown", "id": "d193ofj"}, {"comment": "This still does not explain everything. Fair, the Xeon has bigger L3 cache, but not so big L2. This means that there is a fairly big zone (say, between 1MB and 6MB, I don't know what your cache size is), when on both our machines the data is mostly not in L2 cache but mostly in L3. Here I'd expect similar characteristics regarding relative performance of C and Java and of optimised vs unoptimised C. Another such zone is where the memory consumption is way bigger than L3 cache (say, 2 million iterations use 75MB in Java). However, I didn't observe faster execution on C than on Java and of reference than additive anywhere.\n\nAren't you perhaps using the Client VM in Java?", "id": "d194jf0"}, {"comment": "You've got a good point: if one wants to measure the effects of cache misses, it helps to test on a machine with a smaller cache. The reason I used a Xeon was that a Linux server platform was the most stable with respect to time measurement. You can run the same program twice (Java or C) and get (almost) the same results. The worst in this respect was a Windows notebook.\n\nHowever, there is another way: I can start a hundred (or a thousand) glider guns in parallel. That'll make it unnecessary to wait for millions of iterations.\n\nI don't agree, however, with your definition of the short test as \"dumb\". Not every program deals with huge data. Sometimes it is just \"big\". A one-million-entry hashmap can still fit into L3 cache on a good Xeon, and there are real-world applications for such a hash map. So even micro-optimisations may be of use.\n", "id": "d19ps17"}, {"comment": "[deleted]", "id": "d18xy9p"}, {"comment": "Show a better one then", "id": "d18y9do"}], [{"comment": "> The general myth \u201cC++ is always faster than Java\u201d is busted.\n    \n\u0ca0_\u0ca0", "id": "d18jwkw"}, {"comment": "[deleted]", "id": "d18pr3d"}, {"comment": "The last statement is not correct. Java VM may be written in whatever language; it would only affect the speed if we are talking about direct interpreting. This is not the case, however: the code is hot enough to be fully compiled by HotSpot, and the code generated by HotSpot has nothing to do with the language the HotSpot is written it.", "id": "d18vfvn"}, {"comment": "Yep, that comment is a load or poop - its like comparing Ferrari vs bike - Ferrari is always faster, but then some noob says its not true, because \"Ferrari without fuel will be slower, or the bike might be faster is we will put nuclear rocket in it\"...", "id": "d18v8yk"}], [{"comment": "I only skimmed this, but in a lot of the code you've posted, you're passing by value/copying objects all over the place in the C++ code.  That's a huge red flag for me.  E.g., instead of \"Point w\" in this code: \n\n    void set(Point w)\n    {\n        for (Point p : w.neighbours()) {\n            inc(p);\n        }\n        field.insert(w);\n    }\n\n    void reset(Point w)\n    {\n        for (Point p : w.neighbours()) {\n            dec(p);\n        }\n        field.erase(w);\n    }\n\nYou should use \"const Point& w\":\n\n    void set(const Point& w)\n    {\n        for (const Point& p : w.neighbours()) {\n            inc(p);\n        }\n        field.insert(w);\n    }\n\n    void reset(const Point& w)\n    {\n        for (const Point& p : w.neighbours()) {\n            dec(p);\n        }\n        field.erase(w);\n    }\n\n", "id": "d18fp9p"}, {"comment": "If `Point` is basically two floats the performance difference won't be so obvious.", "id": "d18fsyk"}, {"comment": "Taking copies of 2 floats is still more expensive than not doing any copies at all...  It adds up.", "id": "d18g7qj"}, {"comment": "Not always; a copy may just be a move between registers, while a reference may incur reading from main memory. The compiler can also optimize things differently. Point is, you can't tell with small objects, and you should always measure.", "id": "d18h469"}, {"comment": "> you should always measure.\n\nExactly :)", "id": "d18h96k"}, {"comment": "You realize that even when passing by reference, the processor must still \"copy\" a pointer value to the callstack. If we're using 32-bit floats and 64-bit pointers then there's no size difference, and having a dereference is probably slightly worse.", "id": "d18id22"}, {"comment": "Actually, the compiler isn't required to implement references as pointers.  It is free to optimize them as reusing the same value that is already loaded into a register, or any other way that looks like using the same memory address.", "id": "d18jvgl"}, {"comment": "Well you have to make up your mind. We're either talking about a case where the compiler is able to see across function calls and inline as it pleases, or we're not.\n\nIf we're talking about the former, then it doesn't matter whether you pass by const reference or value. The compiler can see when things are semantically equivalent. Note that this also involves cases with LTO.\n\nFor the latter, you're going to see that in most ABIs (if not all), passing by reference is implemented using pointers. This means that if you have your two-double point sitting nicely in a pair of registers and want to make a function call to a function taking that point by reference, the compiler has to spill that instance to memory (since you can't get a pointer to a register) and pass the pointer to that memory area into the function.\n\nWhen you bring in aliasing, it can get even worse. Consider this silly example:\n\n    struct point { double x, y; };\n\n    double add1(point& p, point p2) {\n      p.x = 0; p.y = 0;\n      return p2.x+p2.y;\n    }\n\n    double add2(point& p, const point& p2) {\n      p.x = 0; p.y = 0;\n      return p2.x+p2.y;\n    }\n\nNow, look at the code generated by GCC 5.3 -O3, x64:\n\n    add1(point&, point):\n           pxor    %xmm2, %xmm2\n           addsd   %xmm1, %xmm0\n           movsd   %xmm2, (%rdi)\n           movsd   %xmm2, 8(%rdi)\n           ret\n    \n    add2(point&, point const&):\n           pxor    %xmm0, %xmm0\n           movsd   %xmm0, (%rdi)\n           movsd   %xmm0, 8(%rdi)\n           movsd   (%rsi), %xmm0\n           addsd   8(%rsi), %xmm0\n           ret\n\nFor add1, the compiler can start clearing xmm2, add x and y into xmm0 (the return register) and finally copy the zero in xmm2 to the 16 bytes pointed to by rdi.\n\nFor add2, the compiler has to assume that p1 and p2 point to the same object, so it first clears 16 bytes that rdi points to, it then loads and adds the object from rsi. It has to do these things in sequence since it can't assume that they are separate.\n\nTL;DR: If you are concerned about performance, don't assume that passing by const reference is always better (or as good) compared to passing by value. Understand what is going on.", "id": "d18riu7"}, {"comment": "Sure, but the same is true for by-value argument passing, so I don't know if there's a reason to prefer a const reference in this case.", "id": "d18pm3i"}, {"comment": "Not at all. I trust the compiler to pass a struct consisting of two int32t's efficiently (in fact, even if it isn't passed in registers, pushing it on stack doesn't seem too bad). If you insist, I'll check the generated code and post it here.\n\nBesides, your point is applicable to the Reference implementation. This one worked quite a bit faster than the similar implementation in Java (1372 ms vs 4061), so I don't think your criticism is well grounded. All the implementations thereafter used int64_t to represent both co-ordinates, and they were still faster than Java counterparts until the super-fast version was introduced, where both times were in the range of 300-400 ms.", "id": "d18g85x"}, {"comment": "It's possible it's not a bottleneck, just something that stood out.  It's not just Point either, there're a few other places where I see things passed by value where they could be by const ref.  Unless I've missed the link, I don't see the actual C++ code anywhere, so I'm just guessing based on the listing posted.", "id": "d18h8wi"}, {"comment": "There is a link; I should have made it stand out more:\n\nhttps://github.com/pzemtsov/article-life/tree/36f962059a6853711f2a3668be8bcf54418ce566\n\nPlease indicate whatever other inefficiencies you spot.", "id": "d18huj8"}], [{"comment": "Short lived Java programs might be slower than long lived, as the JIT is warming up early on. That might be one of the reasons why it's faster in the end.", "id": "d18f76w"}], [{"comment": "Oh, another Lang1 vs Lang2 speed test from someone who obviously doesn't understand the topic enough to comment. Java shines in large applications on servers, its not about running some test case on your laptop. Its about how your application fairs under 10,000 requests. Are you aware of *why* the Java hashmap is written the way it is? Its done so because its an algorithmic solution to the problem of hackers taking sites down by repeatedly making requests of 1k length strings that have the same hash value (thus turning your bucketed hash map into a linked list, leading to slow down, and eventual crash). So when you compare your hacked together library, are you looking which is faster only? If so that is a bad way to think. You also need to worry about security and stability? Are you worried about the fact it has to be fast for floats, int, strings, and objects? \n\nWhen you implement your own code and compare it in two different languages like Java and C++, you have a lot of consider on why the choices were made in their respective libraries. You have to consider the strengths of the languages, and not just that specific structure, but the way the library fits into the language as a whole.", "id": "d18mdll"}, {"comment": "The security issue is a valid point. Just a small correction: even Java-8 version of a HashMap won't help against inputs with absolutely identical hash codes (the binary tree will also deteriorate into a linked list), but it helps against hash codes that fall in the same bucket.\n\nBut this point seems to strengthen the argument that the special version made for the specific task may be better than the generic one, does it not?\n\n> So when you compare your hacked together library, are you looking which is faster only?\n\nThis was the objective of the study - to check which is the fastest solution. It seems obvious that different solutions are the best ones for different requirements.", "id": "d18wpen"}, {"comment": "> won't help against inputs with absolutely identical hash codes (the binary tree will also deteriorate into a linked list), but it helps against hash codes that fall in the same bucket.\n\nAccording to this http://openjdk.java.net/jeps/180 and other sources HashMap falls back to Comparable when implemented by the Key and not the hashCode. ", "id": "d1921m0"}, {"comment": "That's a good point. You are right, I missed this part in the code. Neither of my classes (Point or various LongPoints) implements Comparable. Adding it there may improve performance for cases where hash function is bad. I'll try that. It didn't help in the case of plain Long as the key class, though, but there the hash function was especially bad for my task.", "id": "d193cwl"}, {"comment": ">Java-8 version of a HashMap won't help against inputs with absolutely identical hash codes (the binary tree will also deteriorate into a linked list), but it helps against hash codes that fall in the same bucket. \n\nYes it will. It has a process called treeification that turns the hash map into trees in such an event.", "id": "d195k8j"}], [{"comment": "You should be pre-emptively allocating your memory in C++, otherwise you are wasting a ton of calls to brk().\n", "id": "d18hhcy"}, {"comment": "also your use of push_back() in this usage is also an expensive call which could be pre-emptively done.", "id": "d18iref"}, {"comment": "It'd be interesting to see what it would look like if the c++ version allocated large chunks of memory up front.", "id": "d18i301"}, {"comment": "surely, allocating a million or two objects in C++ should take below one second? We are talking about a program that runs for days.", "id": "d18hxbt"}, {"comment": "A quick check with perf shows around 10% time spent in operator new for the first few tests ( compiled with gcc 4.8.3 ). ", "id": "d18zdgu"}], [{"comment": "He doesn't mention any compiler flags so it is likely that the C++ version was compiled without optimizations.", "id": "d18roh8"}], [{"comment": "> with those of GCC 4.5.4.\n\nwhy not a more recent one ?", "id": "d18cy27"}, {"comment": "In the end he isn't comparing library vs library but self-written implementations. With that in mind even trying to keep a remotely straight face when claiming that java is faster than c++ is hard. \n\nIf at all, then he is comparing some (JIT) optimization or memory allocation strategies. Otherwise, the result _has_ to be the same performance. As the code appears to be a one-to-one translation, there are probably some subtle differences where one implementation does a copy and the other does not. ", "id": "d18gct0"}, {"comment": "The compiler doesn't have special magic optimizations for the standard library as far as I know (apart from intrinsincs). ", "id": "d18hpm3"}, {"comment": "My fault; I don't own the computer, so I used whatever version the sysadmins put there. I didn't see any obvious deficiencies in the code but I agree that there are multiple ways the newer version may be better. I'll try to run it on the newer one.", "id": "d18ggi0"}], [{"comment": "for(auto w: field) Value& X=w.second... should be slow, need to use (const) auto&.", "id": "d18uv1y"}], [{"comment": ">    The C++ program being three times slower than the Java version is an abnormal situation and a mystery. It must be investigated. I\u2019ll do that in one of the next articles.\n\nIndeed abnormal and unexpected. Looking forward to your findings. Maybe HotPath is kicking in? Also memory consumption would be interesting to observe.", "id": "d18fwk9"}, {"comment": "Well, here is the first fact of the investigation. If we run the Java program without compressed pointers (true 64-bit mode), it runs much slower, and after two million steps becomes slower than in C++.\n\nI've also introduced compressed pointers to C++, it runs faster than uncompressed C++ but slower than Java.", "id": "d18gvwf"}], [{"comment": "Java racing against c/c++ performance wise is like combining the Olympic and the Paralympic games... What's your point?", "id": "d18db4u"}, {"comment": "Do you mean you really expected the final three times defeat of C++ to Java?", "id": "d18gaxd"}]]], "42x1z9": ["Introducing Eclipse Che Beta - the open source alternative to IntelliJ.", "2016-01-27 14:22:19", 0, "http://eclipse.org/community/eclipse_newsletter/2016/january/article1.php", [[16, "Once again, a clickbait title from Codeenvy. Because the authors still haven't learned how to honestly describe what Che is, let me be a bit of dick and explain what exactly it is and what concerns me about the way it is presented.\n\n\"Eclipse Che\" is just some IDE built by CodeEnvy that happens to use parts of the Eclipse codebase. They threw out 90% of what Eclipse offers because apparently they *had* to create a web-based frontend for Eclipse's libraries because... What, \"portable workspaces\"? Instead of adding improving support for remote (read: containerized) launches and debugging, they literally created a whole new IDE inside a browser on top of another IDE.\n\nAnd now they are advertising it as an \"open-source alternative to IntelliJ\". Fuck off. It's not an alternative to Eclipse/IntelliJ IDEA/Netbeans.\n\nAlso, it's not clear how IBM and Red Hat are involved when it seems that the main reason that IBM is interested is Orion and Red Hat only said \"we're interested in the Eclipse Cloud Development Initiative\".\n\nThe good news is that it's unlikely that this has slowed down \"main\" Eclipse development.\n\nEDIT: For reference, you can look up CodeEnvy CEO's reponses on Reddit and HN, where he admits that it's mostly a toy project with little reasoning behind it.\n\nEDIT 2: As /u/pakoito pointed out, IntelliJ Community is licensed under Apache and can do much more than Che."], [6, "Why is it the FOSS alternative to IntelliJ? As opposed to normal Eclipse?"], [5, "IntelliJ Community is open source under Apache https://github.com/JetBrains/intellij-community\n\n>Existing IDEs are not up to this task: complex per-computer installations, non-portable localhost workspaces that lead to \"but it works on my machine\" issues, and limited shared collaboration services.\n\nOkay yeah this is just marketing talk, this is not the 90s and Maven/Gradle/Leiningen/sbt/CMake are things.\n\n>Eclipse Che is now the only open source cloud IDE.\n\nhttps://github.com/Microsoft/vscode\n\nhttps://github.com/atom"], [2, "Looks promising, the fact that you wouldn't have to configure environments in every single dev machine is definitely a much needed improvement"], [2, "This isn't exactly in the same realm as IntelliJ. This is a browser IDE, IntelliJ is a desktop IDE. Also, what languages does it support? Is it only for Java?"], [1, "hopefully its not as terrible as the older eclipses were. Being forced to use them for dev work was torturous "]], [[{"comment": "Once again, a clickbait title from Codeenvy. Because the authors still haven't learned how to honestly describe what Che is, let me be a bit of dick and explain what exactly it is and what concerns me about the way it is presented.\n\n\"Eclipse Che\" is just some IDE built by CodeEnvy that happens to use parts of the Eclipse codebase. They threw out 90% of what Eclipse offers because apparently they *had* to create a web-based frontend for Eclipse's libraries because... What, \"portable workspaces\"? Instead of adding improving support for remote (read: containerized) launches and debugging, they literally created a whole new IDE inside a browser on top of another IDE.\n\nAnd now they are advertising it as an \"open-source alternative to IntelliJ\". Fuck off. It's not an alternative to Eclipse/IntelliJ IDEA/Netbeans.\n\nAlso, it's not clear how IBM and Red Hat are involved when it seems that the main reason that IBM is interested is Orion and Red Hat only said \"we're interested in the Eclipse Cloud Development Initiative\".\n\nThe good news is that it's unlikely that this has slowed down \"main\" Eclipse development.\n\nEDIT: For reference, you can look up CodeEnvy CEO's reponses on Reddit and HN, where he admits that it's mostly a toy project with little reasoning behind it.\n\nEDIT 2: As /u/pakoito pointed out, IntelliJ Community is licensed under Apache and can do much more than Che.", "id": "czdr4ma"}, {"comment": ">EDIT 2: As /u/pakoito pointed out, IntelliJ Community is licensed under Apache and can do much more than Che.\n\nIt's weasel words. It's not \"the open source alternative to IntelliJ because IJ is proprietary\", it's \"the alternative to IntelliJ which also happens to be opensource\".", "id": "czdreor"}], [{"comment": "Why is it the FOSS alternative to IntelliJ? As opposed to normal Eclipse?", "id": "czdqosh"}, {"comment": "Maybe it doesn't crash as much as normal Eclipse?", "id": "czds3rr"}], [{"comment": "IntelliJ Community is open source under Apache https://github.com/JetBrains/intellij-community\n\n>Existing IDEs are not up to this task: complex per-computer installations, non-portable localhost workspaces that lead to \"but it works on my machine\" issues, and limited shared collaboration services.\n\nOkay yeah this is just marketing talk, this is not the 90s and Maven/Gradle/Leiningen/sbt/CMake are things.\n\n>Eclipse Che is now the only open source cloud IDE.\n\nhttps://github.com/Microsoft/vscode\n\nhttps://github.com/atom", "id": "czdr2vi"}, {"comment": "VS Code and Atom aren't IDEs, and they don't run on the cloud AFAIK, they're just desktop Javascript applications.", "id": "czdr9zn"}, {"comment": "Shit you are right :p", "id": "czdrdx7"}], [{"comment": "Looks promising, the fact that you wouldn't have to configure environments in every single dev machine is definitely a much needed improvement", "id": "czdqw71"}], [{"comment": "This isn't exactly in the same realm as IntelliJ. This is a browser IDE, IntelliJ is a desktop IDE. Also, what languages does it support? Is it only for Java?", "id": "czdqywf"}, {"comment": "Out of the box on my mac it supports Java, PHP, Node.JS (JS) and ASP.NET projects. There are lots of said \"plugins\" to add support for languages like C++ i.e, but its absolutely explained NOWHERE how to install those. The official documentation doesn't help, and the official plugin repo doesn't either. ", "id": "czedui6"}], [{"comment": "hopefully its not as terrible as the older eclipses were. Being forced to use them for dev work was torturous ", "id": "czdqi1e"}]]], "57xvgy": ["Hack Java's Integer to get better performance.", "2016-10-17 19:21:36", 2, "http://javadeau.lawesson.se/2016/09/javalanginteger-instance-cache.html", [[12, "... this isn't a hack\n\nI was expecting some JVM-level wizardry, but nope, just an object repository :|"], [10, "This is exactly why I personally prefer Scala (among other things): The == operator is not a separate syntactic construct with it's own weird properties, but an alias to the .equals method. No more problem, and you can easily make your own objects work with the == operator as well."], [8, "> \nThe cache ensures that there is exactly one Integer instance for each of the 256 integer numbers closest to 0.\n\nNo, it doesn't. It ensures that `Integer.valueOf` doesn't create a new instance, but `new Integer(0)` still does."], [5, "For Java SE, the caching of values is implementation specific. All of the values in the given range are required by the standard to be cache. However, the identity hash code of a cached value does not have to be the same as another cached value (since it could be stored in a `Reference`). This also means that beyond that range, there could be more caching happening so that the objects are actually the same reference.\n\nFor Java ME, values do not have to be cached at all (since it wastes lots of memory). Thus code that relies on this may fail when ported to Java ME.\n\nAs such, relying on the object reference equality of boxed values is a really bad idea.\n"], [1, "Does .NET have something like this, or any other boxing runtime for that matter?"], [-5, "Better yet, don't use Java and get even better performance."]], [[{"comment": "... this isn't a hack\n\nI was expecting some JVM-level wizardry, but nope, just an object repository :|", "id": "d8vuz4h"}, {"comment": "Lincoln logs are not so versatile.", "id": "d8w6vlu"}], [{"comment": "This is exactly why I personally prefer Scala (among other things): The == operator is not a separate syntactic construct with it's own weird properties, but an alias to the .equals method. No more problem, and you can easily make your own objects work with the == operator as well.", "id": "d8vta65"}, {"comment": "This is true for Kotlin as well.", "id": "d8wb3kw"}], [{"comment": "> \nThe cache ensures that there is exactly one Integer instance for each of the 256 integer numbers closest to 0.\n\nNo, it doesn't. It ensures that `Integer.valueOf` doesn't create a new instance, but `new Integer(0)` still does.", "id": "d8vvvb7"}, {"comment": "That's right, although I think most Integer objects will come from auto-boxing and literals, which are still cached.\n\n    Integer x = 3;\n    int y = 3;\n    Integer y2 = y;", "id": "d8vweod"}, {"comment": "Auto-boxing is implemented as calling `valueOf`.", "id": "d8w2jnj"}, {"comment": "Good point! The quoted sentence is a bit misleading, in particular as seen here out of context. The blog post discusses valueOf and autoboxing, but clearly it is still possible the create new instances with **new**. \n\nIn Java 9, this possibility is proposed to be [deprecated](http://download.java.net/java/jdk9/docs/api/java/lang/Integer.html#Integer-int-).", "id": "d8w1o6q"}], [{"comment": "For Java SE, the caching of values is implementation specific. All of the values in the given range are required by the standard to be cache. However, the identity hash code of a cached value does not have to be the same as another cached value (since it could be stored in a `Reference`). This also means that beyond that range, there could be more caching happening so that the objects are actually the same reference.\n\nFor Java ME, values do not have to be cached at all (since it wastes lots of memory). Thus code that relies on this may fail when ported to Java ME.\n\nAs such, relying on the object reference equality of boxed values is a really bad idea.\n", "id": "d8vtkzn"}, {"comment": "Because the cache is specified in the java se standard it's making it impossible for the JIT to optimize Integer. \n\nThe integer cache may have been a good idea when Java 5 was being developed but it never should have made it into the standard, it should have remained an implementation detail/secret.", "id": "d8vu74p"}, {"comment": "Yes, it should never have been part of the standard. I would guess that they had value caching for garbage collecting and allocation purposes.", "id": "d8vvsv2"}], [{"comment": "Does .NET have something like this, or any other boxing runtime for that matter?", "id": "d8w2qht"}, {"comment": ".NET does not have this problem.  Operators can be overloaded.", "id": "d8w7k8o"}, {"comment": ".NET has still a boxing problem, on a lot of places boxing still occurs while not as often as in Java.", "id": "d8w92ry"}], [{"comment": "Better yet, don't use Java and get even better performance.", "id": "d8w2brx"}]]], "56ws1r": ["Eliminate null-checks using arrays", "2016-10-11 10:34:05", 0, "http://firstclassthoughts.co.uk/Articles/Readability/NullCheckEliminationUsingArrays.html?from=reddit", [[11, "this obfuscates the intent of the code some, especially if you really only mean to be passing one thing in. it might be better to check for null only after making a call to an API you don't own, and then using Optional<> or Maybe (or whatever your language has) in your code."], [9, "Looks like poor man's Option."], [4, "I'm really not sure this is a good idea.  \nFirst, it looks like you want to use Option|Optional|Maybe to achieve that in a more recognizable and idiomatic pattern for most languages.  \nSecond, and this is my major problem, your code does not do the same thing. In the example with null you do not execute Dapper.execute while in the array version you do. This might work in this special method call but generally you need to wrap it something like  \n        `if (!Array.isEmpty()) Method.execute(Array)`  \nanyway which then gains nothing."], [3, "Yeah but now we need to do array index/length checks.\n\nI have an idea: we can avoid that by returning null."], [3, "This looks like poorly written C#, in which case arrays still can be `null ` and therefor null-checks are still required."], [3, "[Array programming?](https://en.wikipedia.org/wiki/Array_programming)\nI wouldn't even put eliminating null checks as the highlight of this technique. It allows to write very concise programs when you are mostly operating on lists of objects. This API style is also used by jQuery which always operates on lists of DOM elements."], [2, "Reminds me of the online functional programming class I took by Erik Meijer in Haskell. He said he likes using lists or arrays in a similar to the Maybe monad. Then higher order functions like map and flatmap can be used on it."], [1, "How about nulls inside the array? This makes very little sense and is also counter-productive. I still need a function operating on a single element in many cases so I can incrementally process a collection of elements that isn't an array."], [1, "I tried this a couple of years ago, and it ended up being really confusing for everyone else to read, and now it's confusing to me when I look at that code. You're trading `if (o != null)` for `foreach (var o in listOfOneObject)`.\n\nMakes C# feel like a shitty Lisp, and that's pretty unfortunate.\n\nZero length arrays/lists *are* really useful if there's a remote chance you might have more than one of a thing though. I'm a fan."]], [[{"comment": "this obfuscates the intent of the code some, especially if you really only mean to be passing one thing in. it might be better to check for null only after making a call to an API you don't own, and then using Optional<> or Maybe (or whatever your language has) in your code.", "id": "d8n1obr"}, {"comment": "as the article says: I'm sure I wouldn't apply this pattern everywhere a variable may be null. But I've found that in code without side effects and code that \"processes\" data such as validation or mutation of input A to output B, the model fits well.", "id": "d8n2yyd"}, {"comment": "Ironically, using 3 different api's could lead to having 3 different maybe types in play ;)  the option type is mentioned in the article. ", "id": "d8ns0o3"}], [{"comment": "Looks like poor man's Option.", "id": "d8n1ol5"}, {"comment": "Sort of, and option types are definitely another null-elimination strategy", "id": "d8n2z6v"}], [{"comment": "I'm really not sure this is a good idea.  \nFirst, it looks like you want to use Option|Optional|Maybe to achieve that in a more recognizable and idiomatic pattern for most languages.  \nSecond, and this is my major problem, your code does not do the same thing. In the example with null you do not execute Dapper.execute while in the array version you do. This might work in this special method call but generally you need to wrap it something like  \n        `if (!Array.isEmpty()) Method.execute(Array)`  \nanyway which then gains nothing.", "id": "d8n21am"}, {"comment": "but dapper supports handling ienumerables and does nothing if the ienumerable is empty", "id": "d8n2zlf"}, {"comment": "Fair enough in this case, but generally I think it is a rather bad idea in many other use cases, or there are better suited options to chose from. \nIn my experience there is often a huge difference between having a zero-sized result (which you don't have to handle/have to handle differently) and a n-sized result (n > 0) where you proceed to call the next procedure on it.  \nI agree, it is a neat little trick to do a for-each on a data structure which might be empty, but that should rather be used locally to have the code stay readable.", "id": "d8n37cw"}], [{"comment": "Yeah but now we need to do array index/length checks.\n\nI have an idea: we can avoid that by returning null.", "id": "d8n2hh5"}, {"comment": "What is the overhead of that nowadays? Have you even measured it recently?", "id": "d8n307v"}, {"comment": "Both operations would be roughly identical in performance and effort, I'd presume.\n\nIt's a common sense tip (I wouldn't even call it a pattern), to return empty collection instead of null when the result is *already* a collection, but I don't think it makes sense to suggest returning an array when you can have at most one result in your function.\n\nSome general-purpose interfaces might do that, one example are SQL result sets, which are always a list (despite the \"set\" misnomer) of results, even when the query clearly intends to get one record back.\n\nBut this is SQL, a remote procedure call for a database. And in there the general case may have more than one results, so it makes sense.\n\nAs a way to design an in-process, in-language API, I don't think it makes sense to use arrays for single-result methods. I get the idea, that when combined with iteration, an array can act as a poor man's Maybe monad. But... it's just misleading.\n\nCheck this out: https://github.com/tejacques/Option\n\nIt's the same idea as your use of an array, but it makes the interface clear, that we have zero or one items back, an \"optional\" result.", "id": "d8n34rq"}, {"comment": "Maybe types are mentioned in the article already. They carry problems of their own. Eg. There is no standard implementation and a many implementations exists eg on github", "id": "d8ns3ss"}], [{"comment": "This looks like poorly written C#, in which case arrays still can be `null ` and therefor null-checks are still required.", "id": "d8n9azq"}, {"comment": "But isn't that the reality of the real world?", "id": "d8nc8pv"}], [{"comment": "[Array programming?](https://en.wikipedia.org/wiki/Array_programming)\nI wouldn't even put eliminating null checks as the highlight of this technique. It allows to write very concise programs when you are mostly operating on lists of objects. This API style is also used by jQuery which always operates on lists of DOM elements.", "id": "d8nacwc"}], [{"comment": "Reminds me of the online functional programming class I took by Erik Meijer in Haskell. He said he likes using lists or arrays in a similar to the Maybe monad. Then higher order functions like map and flatmap can be used on it.", "id": "d8nurfw"}, {"comment": "Map and flatmap can be used on the Maybe monad. If they couldn't, it wouldn't be a monad.\n\n    fmap (1 +) (Just 5)\n    -- Just 6\n\n    (return . (1 +)) =<< (Just 5)\n    -- Just 6", "id": "d8o49ik"}], [{"comment": "How about nulls inside the array? This makes very little sense and is also counter-productive. I still need a function operating on a single element in many cases so I can incrementally process a collection of elements that isn't an array.", "id": "d8ngpcs"}, {"comment": "Please explain what you want to address putting nulls into the array? ", "id": "d8ns6g6"}], [{"comment": "I tried this a couple of years ago, and it ended up being really confusing for everyone else to read, and now it's confusing to me when I look at that code. You're trading `if (o != null)` for `foreach (var o in listOfOneObject)`.\n\nMakes C# feel like a shitty Lisp, and that's pretty unfortunate.\n\nZero length arrays/lists *are* really useful if there's a remote chance you might have more than one of a thing though. I'm a fan.", "id": "d8nmspq"}, {"comment": "Thanks for the input. I think there are many problem domains where operating on a set is just as fine as operating on an instance. Like the article says, don't use it everywhere", "id": "d8ns9t0"}, {"comment": "Having more than 1 of something is the norm.", "id": "d8o5bui"}]]], "4m4tkm": ["You Are Not Your Code", "2016-06-02 05:50:43", 1, "http://roytang.net/2016/06/you-are-not-your-code/", [[16, "[deleted]"], [14, "I only get annoyed when the feedback is bullshit.\n\nBrian: Why did you make that method static?\n\nMe: Well, Brian, it doesn't need access to the state of the class and static seems like a great way to enforce that and communicate that intent to anyone who reads my code.\n\nBrian: But it doesn't feel right.\n\nFuck you, Brian."], [7, "If an artist can get angry over criticism of his or her art, especially in situations where that criticism is needless nit-picking, then a programmer can get angry over criticism of his or her code too. Criticism of your creation is criticism of your ability to create, being irritated is perfectly o.k. as long as you don't completely dismiss the criticism without considering what you might learn from it first."], [1, "I disagree: good programmers are the ones who _are_ their code, *because they're the ones who give a shit*. Yes, pride comes before a fall and all that, but pride is a necessary \"evil\" because if you aren't proud of what you're doing, you will either not do it well, or you'll keep at it until you _are_ proud of it.  \n\nThe best programmers are the ones who take pride in their work, but are able to divorce themselves from it to accept criticism as it's intended. I've been developing software for over a decade now and I still have yet to master that skill fully."]], [[{"comment": "[deleted]", "id": "d3smckc"}, {"comment": "This seems to be an increasing trend all over reddit as far as I can tell but maybe I just hang around in the wrong subs.", "id": "d3susuj"}], [{"comment": "I only get annoyed when the feedback is bullshit.\n\nBrian: Why did you make that method static?\n\nMe: Well, Brian, it doesn't need access to the state of the class and static seems like a great way to enforce that and communicate that intent to anyone who reads my code.\n\nBrian: But it doesn't feel right.\n\nFuck you, Brian.", "id": "d3smh18"}, {"comment": "Brain: We need to be able to Dependency inject this into other modules copy all the methods and place them into a interface. Job well done! ", "id": "d3su84z"}], [{"comment": "If an artist can get angry over criticism of his or her art, especially in situations where that criticism is needless nit-picking, then a programmer can get angry over criticism of his or her code too. Criticism of your creation is criticism of your ability to create, being irritated is perfectly o.k. as long as you don't completely dismiss the criticism without considering what you might learn from it first.", "id": "d3sqjvw"}, {"comment": "\"You made a spelling typo on line 2.\"\n\nFor every time that sort of thing is uttered, 95% of people point it out to be helpful.. but something like 5% of people will just point it out to feel good about themselves.\n\nLike a bug in your code validates their existence/smugness.", "id": "d3t6max"}], [{"comment": "I disagree: good programmers are the ones who _are_ their code, *because they're the ones who give a shit*. Yes, pride comes before a fall and all that, but pride is a necessary \"evil\" because if you aren't proud of what you're doing, you will either not do it well, or you'll keep at it until you _are_ proud of it.  \n\nThe best programmers are the ones who take pride in their work, but are able to divorce themselves from it to accept criticism as it's intended. I've been developing software for over a decade now and I still have yet to master that skill fully.", "id": "d3sur20"}]]], "5c4q35": ["You will write \u2018bad code\u2019.", "2016-11-10 03:08:38", 87, "https://blog.prototypr.io/you-will-write-bad-code-94081bb66bec#.5v8xn19wq", [[271, ">3rd year software development student\n\nGo away"], [75, "No I won't "], [71, "bad code"], [54, "In my coding infancy I had to keep a counter for something, but instead of incrementing an int variable I made a list of ints, added a new int to the list for each count, then used the list's length as the counter.... \n\nI mean it worked but holy shit I've never cringed so hard at myself in my life... "], [46, "i tihnk you made a mistake because I am alot better at coding than you i will never make a mistaek"], [42, "You will write 'bad articles'."], [41, "Ah the wisdom of the 3rd year student"], [26, "The key is refactoring. It's a lot harder to write shit code if you work refactoring into your process. You come back to it, refine it and learn a lot in the process."], [20, "Typo in the first sentence? Third year undergraduate? *Sigh*."], [12, "Why does this article even exist? Does anybody really need to be told that when they first start something, they won't be good at it?"], [12, ">Even if you use Composer, a hipster database and serve an OAuth2.0 compliant RESTful API or whatever buzzword\n\nPlease stop."], [12, "r/programmerhumor"], [4, "I just found a command line \"game\" I wrote back in 2011. \nIt was so bad. The filename even had a space in it and was saved as a .txt\n"], [3, "The best indicator that you're improving is to look at things you wrote a year ago. If you find yourself cringing and questioning your own mental health when you wrote it, then you have my condolences; you have improved massively. If not, maybe it's time to look for a new job."], [3, "I'm a 3rd year student as well and I wondered whether I should create my own blog for ramblings. By reading comments here I concluded that perhaps I shouldn't for now :D \n\nThe idea of writing bad code that will lead to writing good code is obvious, like with everything else. It's called practice. But I understand that making mistakes might feel like **you** are wrong. It boils down to shifting the blame from yourself to your actions, so that you have more power over yourself, therefore you won't hesitate to write any code."], [3, "People need to get away from this \"good/bad\" dichotomy.  Code is more or less optimal, nothing more."], [2, "I can't lie. I'm working in WebFocus these days and it's nothing but terrible code....legacy support and enhancement...yuck."], [2, "Why does every damn person have a need to write something these days?"], [2, ">  for more posts focused on web development, UI and UX\n\nSo by 'code' he means HTML?"], [1, "Awyisss, bad code, I remeber the times when I wrote it, very clearly, so shitty drafts that always needed refactoring, yeah, like one I have wrote yesterday, I am really scared to look at it today and realize that it can be done easier..."], [1, "I'm doing it right now! "], [1, "_All_ code is bad. \n\nEverything we do as programmers involves making trade-offs, and there is no perfect balance or perfection to be achieved. "]], [[{"comment": ">3rd year software development student\n\nGo away", "id": "d9tv2ym"}, {"comment": "Go away is a bit harsh, but this guy is speaking like he has years of experience ", "id": "d9tzmuf"}, {"comment": "technically he has up to three years of experience", "id": "d9u2705"}, {"comment": "Depending on your definition of experience, he might have fifteen years of experience.", "id": "d9u2qs0"}, {"comment": "Or none ", "id": "d9u30p0"}, {"comment": "Web 1.0 (2000):\n\n15 years of experience in Java (launched in 1995)\n\nWeb 3.0 (today)\n\n15 years of experience in Node", "id": "d9u3e6e"}, {"comment": "In the real world (working world), it's defined as years of full-time, professional experience. When the job ad says \"Sr. Software Architect with 10+ years experience,\" and some 22 year old college student applies and says they've been \"programming\" since they were 12, the application gets laughed at and thrown away. ", "id": "d9wkxsk"}, {"comment": "The joke is that \"good code\" will come one day. He has no idea (nor talks about) what the difference between good code and bad code is.\n\nHe has a long way to go before writing books.", "id": "d9u0fqs"}, {"comment": "The GoF Design Patterns book was written by a bunch of grad students. \n\nOh, right...", "id": "d9u1vvw"}, {"comment": "Well grad students, especially PhD students, are much different from undergrads. ", "id": "d9u7mzj"}, {"comment": "In terms of experience, not really. I've met plenty of doctoral graduates who, while being geniuses in their narrow field of study, couldn't write clean code to save their life. There are just too many things that you can only learn from working with groups on a major project, preferably paid for by people who don't understand technology.", "id": "d9uf0xi"}, {"comment": "\"Experience\" is such a broad term I think it's kind of losing its meaning here. PhD and grad students will have 10x more \"experience\" writing things like interpreters and filesystems and things. \"Real world\" devs will have more \"experience\" shipping software for money with other people.\n\nI would argue that experience only comes from _either_ working with other software people for money, or working on research to advance the field. Undergrad/code school/whatever is still training.", "id": "d9uhlis"}, {"comment": "> preferably paid for by people who don't understand technology.\n\nDoes anyone else ever pay?", "id": "d9v1hww"}, {"comment": "Yes, and in those rare cases the job is almost too easy.", "id": "d9vinwe"}, {"comment": "True, but I don't know many grad-students who can give good practical advice for breaking apart a monolith.", "id": "d9ubtu2"}, {"comment": "Is his point (however trivial) contingent on a particular definition though?", "id": "d9u7r63"}, {"comment": "> new tech activist\n\nUgh.", "id": "d9u4vi0"}, {"comment": "Don't judge him, his oppression is real.", "id": "d9ubuus"}, {"comment": "Creating articles is making an activity I guess\n\nBut where is the new tech?", "id": "d9w4qtp"}, {"comment": "Agree. There are way too many of these posts speaking at the entire industry from a place of supposed wisdom, yet the author is really inexperienced and clearly lacking wisdom. \n\nOne of the differences between an (actual) expert and beginner is that the expert not only has knowledge and understanding, but can apply those things while learning a new tool or technology to avoid repeating the mistakes made as a beginner. You'll probably still occasionally write bad code when exhausted, drunk, not focused, or whatever but it will be in spite of your ability, not because of some inherent trait in programming that we all must write bad code.  ", "id": "d9u4ufp"}, {"comment": "Actual experts don't have *time* to make big blog posts :P\n\n(... Says the guy always on Reddit.)", "id": "d9uihy8"}, {"comment": "They have to start making time for it, in other fields they make the time to discuss and debate and analyze their work. In software dev we're driven by business and by fashion. It's fucked up.", "id": "d9utglm"}, {"comment": "There are plenty of resources already out there, the problem is that *inside* many organizations, trying to push for quality is painful or unrewarded.", "id": "d9v0e2c"}, {"comment": "This submission is worth upvoting just for this comment. ", "id": "d9u5mwt"}, {"comment": "What happened here?", "id": "d9tzgol"}, {"comment": "Blunt honesty.", "id": "d9u2a47"}], [{"comment": "No I won't ", "id": "d9ttsft"}, {"comment": "Username checks out. ", "id": "d9twocj"}], [{"comment": "bad code", "id": "d9ttzt0"}, {"comment": "Now what?", "id": "d9tu09y"}, {"comment": "We dance <(^ . \\^)/", "id": "d9u11md"}, {"comment": "[Like this?](https://www.youtube.com/watch?v=VHoT4N43jK8)\n\n^(\"Alors on danse\" basically means \"And then we dance\".)", "id": "d9u3d6v"}, {"comment": "Write good code", "id": "d9u2fp3"}, {"comment": "Apparently \"good code\" will follow, so let's wait and see", "id": "d9u33q6"}, {"comment": "Slightly better, but still bad code.", "id": "d9u1y49"}, {"comment": "whoops, got frustrated and deleted all my code again.", "id": "d9wc0c0"}, {"comment": "I dunno, sometimes I'll dig out old code and wonder how I managed that so long ago.  I think James Hetfield knows what I mean.", "id": "d9u5wtk"}], [{"comment": "In my coding infancy I had to keep a counter for something, but instead of incrementing an int variable I made a list of ints, added a new int to the list for each count, then used the list's length as the counter.... \n\nI mean it worked but holy shit I've never cringed so hard at myself in my life... ", "id": "d9tyi0j"}, {"comment": "So basically younger you preferred functional programming!", "id": "d9tyufj"}, {"comment": "Scala dev here. This made me exhale loudly through my nose", "id": "d9u2vbz"}, {"comment": "Yes, Scala us horrible. I agree.", "id": "d9ue49c"}, {"comment": "1 bonus point for outside the box solution. Stick it to the man!", "id": "d9u1wc5"}, {"comment": "I think I'm going to show this to my students to show them that there are more than 1 way to solve problems ", "id": "d9u51qf"}, {"comment": "More than `(cons 1 nil)` way to solve problems.", "id": "d9u5931"}, {"comment": "You forgot to take the car.", "id": "d9ue4vo"}, {"comment": "Variable variables was my first attempt at a list =/", "id": "d9u5xlw"}, {"comment": "How did you think of this? One of the first things I learned was indexes and loops...", "id": "d9u54cj"}, {"comment": "This is exactly how one might tally things using pen and paper. Instead of erasing the number and writing a new one, you just put another tally mark on there and count the number of marks. Totally makes sense.", "id": "d9u83xt"}, {"comment": "Ans what's wrong with this solution? You reinvented Peano arithmetics/Church numerals. Congratulations. There is a lot of cases when this is the best possible representation.", "id": "d9u5z97"}, {"comment": "Not quite the same thing. To represent a number n in unary you repeat a value n times. Church numerals would represent it as a function that takes two other functions and calls the first function argument on the second one n times.", "id": "d9u6f4h"}, {"comment": "The concepts are very similar, and a lazy functional language representation of a Church number is exactly a list.", "id": "d9u6hm8"}, {"comment": "Congratulations, you made \"a lazy functional language representation of a Church number\" has a different ring to it. ", "id": "d9ud3l0"}, {"comment": "Cannot even parse this.", "id": "d9uddgu"}, {"comment": "You said this:\n\n>You reinvented Peano arithmetics/Church numerals. Congratulations.\n\nand then this:\n\n>a lazy functional language representation of a Church number is exactly a list.\n\nSo I pointed out that:\n\n>Congratulations, you made \"a lazy functional language representation of a Church number\"\n\nDoesn't sound as good as what you originally said. ", "id": "d9uh85l"}, {"comment": "At a conceptual level there is a very little difference anyway. E.g., if you want to use this kind of arithmetics to prove totality, they're interchangeable (but the raw Peano is simpler).", "id": "d9uhrg6"}], [{"comment": "i tihnk you made a mistake because I am alot better at coding than you i will never make a mistaek", "id": "d9tvug9"}, {"comment": "Grammar checks out, official good programmer. ", "id": "d9tylb1"}, {"comment": "If you listen carefully you can hear the compiler scream out in agony.", "id": "d9u3kca"}], [{"comment": "You will write 'bad articles'.", "id": "d9u211v"}, {"comment": "Keep writing...and you will improve", "id": "d9u4xtl"}], [{"comment": "Ah the wisdom of the 3rd year student", "id": "d9u1rlv"}], [{"comment": "The key is refactoring. It's a lot harder to write shit code if you work refactoring into your process. You come back to it, refine it and learn a lot in the process.", "id": "d9tvzwu"}, {"comment": "Nothing feels quite like when you refactor 120 lines of code down to 40 with comments. Your code will always be a rough draft that can be improved upon. ", "id": "d9twrbh"}, {"comment": "As a student, sure, but when you start working on larger projects, refactoring is much larger. I've had times when I've refactored 1000+ lines down to mere hundreds.\n\nPerhaps the most fulfilling is drastically improving performance while simplifying code. I was looking through some of our database queries and realized that by adding a couple columns to one table, I could drastically simplify our queries by significantly limiting the rows it has to look through. The result was that our queries became orders of magnitude more efficient, fixing numerous performance issues we had been experiencing.", "id": "d9tzbhz"}, {"comment": "About a month ago I decided to finally start using the MSSQL query analyzer to see where scalability issues were in the SPs I had written for a large project.\n\nAlan M. Turing that crap is useful!\n\nI improved performance on several of the more crucial SPs an average of 88%.  The most notable SP saw a 98% speed improvement.", "id": "d9v0sr2"}, {"comment": "On one project, I worked with a few pattern purists.  They naively believed a certain set of patterns should be followed regardless the use case.  As soon as they were off the project, and a request for a major feature came trough, I reduced the size of the code base by around 10k to 15k lines in 2 weeks (I forget the exact number).  A coworker didn't believe me, so I showed him the git history.\n\nIf you know the code well, and have a little bit of freedom, making changes like that is completely do able.", "id": "d9v5lot"}, {"comment": "Yep. My boss just cares that we get the features in on time, so we bloat our feature estimates a bit when we know we need to refactor. It helps us reduce technical debt, and now that we have more leeway (not rushing to get an MVP out the door),  we can take time and refactor. It's amazing the awful code we wrote when rushing the product out the door...", "id": "d9vcku8"}, {"comment": "Dude, yes!\n\nMy bitreader was orinially 40 lines, after refactoring it was 7.\n\nI was SO proud of that.\n\nOf course, I recently rewrote it to go byte by byte, so I'll have to refactor that.", "id": "d9u40jh"}, {"comment": "I started working in start-ups in 1984. Start-ups always write bad code because their goal is to get something working, a proof of concept, with minimal time and resources. If you're successful prototype code suddenly takes on the aura of production code. If you're really successful then you're in extra special trouble because you'll never find enough time to refactor the trouble spots. I know, I worked at Netscape. Fun personal trivia: my group was named \"most doomed component\" because it got canceled before release. ", "id": "d9u1kxu"}, {"comment": "I'm not supposed to change old code\n\nNow what\n\nHelp\n\nEdit: it makes me stressed out. Been here a little over 2 years and the code debt is weighing on me. One judge of a good programmer is if they run projects into the ground with debt. I don't have much of a choice...\n\nI did work on another project for these same guys, and I would like to continue that one because the management on it was not suffocating and I did actually manage to refactor old code and even add unit tests to the whole back end!\n\nBut the high profile project has no unit tests and last time I tried to smartly re arrange the code to incorporate a new feature that wanted to act the same as an old feature I accidentally used the wrong wrapper method and shit hit the fan even if I fixed it in literally 10 minutes. I am too scared to touch anything since then and just stressing out over my future now.", "id": "d9ur7gt"}, {"comment": "Refactoring doesn't really work without good test coverage. That's where you should start, but it gets worse. Good test coverage is hard to ensure without a comprehensive system spec.\n\nSo, if you have a spec, start writing tests. Once you have solid coverage, then you have a safety net, you can do whatever you want to that code, safe in the knowledge that if anything breaks, your test suite will notify you.\n\nIf you *don't* have a specification, you'll have to convince your manager that they need one.", "id": "d9uy6pv"}], [{"comment": "Typo in the first sentence? Third year undergraduate? *Sigh*.", "id": "d9u1z1t"}, {"comment": "Forgive him for he is a computer science student; not a liberal arts major.", "id": "d9utij3"}, {"comment": "I think it's great (and brave) that he's writing up his thoughts. But I wasn't aware that only liberal arts students sound less professional when they misspell things?", "id": "d9uups5"}, {"comment": "The quality bar for devs is pretty low; most of us can harldy go a dey without making mistakes even though it's a necessity in our jobs to be detail-oriented.", "id": "d9vx2fp"}, {"comment": "If anything, STEM students need to focus more on proper spelling and grammar.  We typically need to get our points across in a more concise manner than our peers in humanities.", "id": "d9v0vf3"}, {"comment": "You can tell because he typed it, rather than scrawling it on a napkin in crayon and taking a picture of it with the Facebook app on his iphone.", "id": "d9v1nnw"}], [{"comment": "Why does this article even exist? Does anybody really need to be told that when they first start something, they won't be good at it?", "id": "d9u29g7"}, {"comment": "It's filler nonsense from an overenthusiastic beginner blogger who's dying to talk about something but doesn't know enough about anything to provide any useful insight. \n\nI know this because I'm in exactly the same position as the author (although not a webdev), but I don't blog.", "id": "d9u4zbp"}, {"comment": "This is actually the reason I kind of despise blogs.  I've seen too many instances of people speaking with an air of authority they absolutely do not have.  Or defining new words for things that don't need new words for them.", "id": "d9uby1q"}, {"comment": "Amen, brother.", "id": "d9ue62u"}, {"comment": "Kind of like those student films that are usually some kind of pointless coming-of-age tale because it's the only thing the filmmaker has experienced so far. ", "id": "d9wlg76"}], [{"comment": ">Even if you use Composer, a hipster database and serve an OAuth2.0 compliant RESTful API or whatever buzzword\n\nPlease stop.", "id": "d9u2hl7"}], [{"comment": "r/programmerhumor", "id": "d9u1zn4"}], [{"comment": "I just found a command line \"game\" I wrote back in 2011. \nIt was so bad. The filename even had a space in it and was saved as a .txt\n", "id": "d9u1nkx"}], [{"comment": "The best indicator that you're improving is to look at things you wrote a year ago. If you find yourself cringing and questioning your own mental health when you wrote it, then you have my condolences; you have improved massively. If not, maybe it's time to look for a new job.", "id": "d9u5kew"}, {"comment": "Having just finished my first year as an actual full time paid developer, your comment has made me feel a whole lot better.", "id": "d9uqejt"}, {"comment": "Congratulations! It's pretty good to do this test once or twice a year. Be careful not to stagnate.", "id": "d9us7ua"}, {"comment": "Thanks! Its a mid-life career change for me, and it's one of the best moves I ever made.", "id": "d9vftgv"}], [{"comment": "I'm a 3rd year student as well and I wondered whether I should create my own blog for ramblings. By reading comments here I concluded that perhaps I shouldn't for now :D \n\nThe idea of writing bad code that will lead to writing good code is obvious, like with everything else. It's called practice. But I understand that making mistakes might feel like **you** are wrong. It boils down to shifting the blame from yourself to your actions, so that you have more power over yourself, therefore you won't hesitate to write any code.", "id": "d9u4aga"}, {"comment": "You can write your own learnings and people will respect that, but avoiding titles like \"YOU WILL\" or \"X CONSIDERED HARMFUL\" or whatever bullshit titles are in vogue will probably help avoid this kind of criticism.", "id": "d9u4w54"}, {"comment": "Start a blog if you want, I think it's a good way to express ideas, get feedback, gain connections, etc.\n\nThe issue here is mostly that it's a \"you should listen to me\" or \"I know what I'm talking about\" style post coming from someone who is severely lacking in experience in that area.", "id": "d9udc5o"}, {"comment": "If you do something with merit, go for it. But do something with code examples; no matter how small.", "id": "d9ubml9"}, {"comment": "Absolutely start your own blog if that's what you want to do, just don't speak with an air of authority you don't have.\n\nAnd realize that developers have long since become a group to be sold to, so /r/programming can be a bit harsh on blogs that are obviously nothing more than marketing for the blog author.", "id": "d9uc032"}], [{"comment": "People need to get away from this \"good/bad\" dichotomy.  Code is more or less optimal, nothing more.", "id": "d9uc1lj"}], [{"comment": "I can't lie. I'm working in WebFocus these days and it's nothing but terrible code....legacy support and enhancement...yuck.", "id": "d9tzgw7"}], [{"comment": "Why does every damn person have a need to write something these days?", "id": "d9u4ml3"}, {"comment": "Every voice matters, except for the ones that don't.", "id": "d9ucdoc"}, {"comment": "Most people's interactions with most software developers is online, not in person. And we see so many blog posts from so many different people. It makes each person think that that's the expectation for a programmer, and if you don't do that then you aren't one of the best.\n\nOf course it also to has to do with people loving to talk and share their ideas. The same reason both me and you wrote comments here.", "id": "d9uffgj"}, {"comment": "I think a lot of people get career advice that includes having a blog.", "id": "d9uxemx"}], [{"comment": ">  for more posts focused on web development, UI and UX\n\nSo by 'code' he means HTML?", "id": "d9ubkx9"}, {"comment": "One person's program is another person's configuration file.", "id": "d9ugy0b"}], [{"comment": "Awyisss, bad code, I remeber the times when I wrote it, very clearly, so shitty drafts that always needed refactoring, yeah, like one I have wrote yesterday, I am really scared to look at it today and realize that it can be done easier...", "id": "d9u1yoj"}], [{"comment": "I'm doing it right now! ", "id": "d9udw6f"}], [{"comment": "_All_ code is bad. \n\nEverything we do as programmers involves making trade-offs, and there is no perfect balance or perfection to be achieved. ", "id": "d9ulqqh"}, {"comment": "Your glass seems to be half-empty. I for one think that I write pretty good code. Strangely, it seems to transform into bad code, if I don't look at it for too long. Hmmmm....", "id": "d9vqjwz"}, {"comment": "https://i.ytimg.com/vi/WOkBCogaeI8/maxresdefault.jpg", "id": "d9vqoel"}]]], "4f7k6p": ["New debugging method by MIT found 23 security vulnerabilities in 64 seconds", "2016-04-17 21:36:16", 0, "http://news.mit.edu/2016/patching-web-applications-0415", [[16, "> That turns the Rails interpreter, which converts high-level Rails programs into machine-readable code, into a static-analysis tool.\n\nThis is a horrible article."], [14, "3200 seconds, or 53 minutes, actually. 64 seconds per app in 50 apps."], [11, "Anyone have an article on this topic written for programmers?  "], [6, "Clickbait headline."], [1, "Anyone find anything on how to actually use it?"]], [[{"comment": "> That turns the Rails interpreter, which converts high-level Rails programs into machine-readable code, into a static-analysis tool.\n\nThis is a horrible article.", "id": "d26nc7h"}], [{"comment": "3200 seconds, or 53 minutes, actually. 64 seconds per app in 50 apps.", "id": "d26jwpv"}, {"comment": "Yep, you're right.", "id": "d26krym"}], [{"comment": "Anyone have an article on this topic written for programmers?  ", "id": "d26or3q"}, {"comment": "I thought the same thing. It's from the MIT, but yet it's written for kindergarten kids. It's still interesting what they've built though.", "id": "d26sq8b"}, {"comment": "http://www.cs.berkeley.edu/~jnear/papers/ase14.pdf", "id": "d3dgel8"}, {"comment": "You da man or woman!  I'll peruse that when I have some time.  Looks fascinating.  ", "id": "d3dj7gn"}], [{"comment": "Clickbait headline.", "id": "d26u7eg"}, {"comment": " I Don't know. I mean...number seventeen *did* shock me.", "id": "d28gp42"}], [{"comment": "Anyone find anything on how to actually use it?", "id": "d27rx1l"}, {"comment": "Here's the actual paper: http://www.cs.berkeley.edu/~jnear/papers/ase14.pdf\n\nMy 30 second glance over it tells me they basically found authorization bugs where the developer forgot to scope a find to what the current user is allowed to see.\n", "id": "d3dgdyh"}, {"comment": "thanks! I'll take a closer looks at some point. I hope they bundle this up and open source it!", "id": "d3dnt1w"}]]], "409px4": ["How Developing with Feature Flags Works", "2016-01-10 06:41:30", 10, "https://dzone.com/articles/feature-flag-driven-development", [[28, "Seems a bit more like advertisement than article."], [3, "Sorry to say, but this is harder than it looks when code is not particularly modular  and/or when features are cross cutting every which way.  With a codebase like that, finding the line of code causing an incoming bug report is not easy, and there are already many bugs in the codebase and bug reports coming in.  With feature flags everywhere, diagnosing any bug must include determining (1) if inserting a feature flag turned off somehow caused the bug through incompetence or out of memory or by breaking other machine/technical  limits, (2) if turning a feature flag on caused it because the feature is bad (as in the fable of the article) or if we missed a flag somewhere in the turn-on process, or (3) if turning a feature flag off somewhere didn't fix a bug or caused a new  one for some of the same reasons, and (4) WTH do we do when the code covered by different feature flags overlap,  and (5) doesn't the number of configurations we must test increase exponentially with the number of feature flags that may be flipped during the life of the code?"], [2, "Seems like a really cool feature for deployments, but what are the use case projects that would do this? Do you think face book or another large Web app would use something like this?"], [1, "Isnt this just obvious? its nothing hew"], [-7, "Great article\n"]], [[{"comment": "Seems a bit more like advertisement than article.", "id": "cyslqg7"}, {"comment": "I honestly don't know why anyone would pay for fucking feature flags. There are tons of FOSS ones out there, such as [flipper](https://github.com/jnunemaker/flipper), [rollout](https://github.com/FetLife/rollout), [arturo](https://github.com/zendesk/arturo) (which I've used and loved), and you can code one up in about 50-100 lines of code if you cant find one you like.", "id": "cysrads"}, {"comment": "In my experience, most DZone articles are advertisements.", "id": "cysqanj"}, {"comment": "Then you should see the pages they submit to r/agile", "id": "cysqhmf"}], [{"comment": "Sorry to say, but this is harder than it looks when code is not particularly modular  and/or when features are cross cutting every which way.  With a codebase like that, finding the line of code causing an incoming bug report is not easy, and there are already many bugs in the codebase and bug reports coming in.  With feature flags everywhere, diagnosing any bug must include determining (1) if inserting a feature flag turned off somehow caused the bug through incompetence or out of memory or by breaking other machine/technical  limits, (2) if turning a feature flag on caused it because the feature is bad (as in the fable of the article) or if we missed a flag somewhere in the turn-on process, or (3) if turning a feature flag off somewhere didn't fix a bug or caused a new  one for some of the same reasons, and (4) WTH do we do when the code covered by different feature flags overlap,  and (5) doesn't the number of configurations we must test increase exponentially with the number of feature flags that may be flipped during the life of the code?", "id": "cytg30w"}], [{"comment": "Seems like a really cool feature for deployments, but what are the use case projects that would do this? Do you think face book or another large Web app would use something like this?", "id": "cysj3g1"}, {"comment": "Facebook/Amazon/Google already use feature flags in their deployment cycle.  They usually release new features internally to their own employees or to beta groups and then gradually roll out the features to the rest of their users.  \n\nOverall, it helps them control the full lifecycle of the their feature.  If it sucks, they can roll it back.  If it's buggy, they can roll it back and tweak it, then relaunch.   \n\nIt also seems to be used a lot for long term control of features for web/mobile apps or to turn on features for particular user segments (ex. if I wanted to just roll out a feature for *beta* users, then I would flag the feature and then flip it on for those users.  Here's a [feature flags article in the Travis CI blog](https://blog.travis-ci.com/2014-03-04-use-feature-flags-to-ship-changes-with-confidence/) about how they use it. ", "id": "cysjhjb"}, {"comment": "Pretty much all the big companies make heavy use of feature flags and AB testing. There's too much risk in releasing a feature to 100% of users when you've got 1B of them. \n\nThe implementation doesn't have be be specifically as described here either. It could just be a switch inside a debug only menu. Even with that simple implementation it still gives you the benefit of being able to deploy code which isn't finished since it won't be accessible. This can be very helpful in preventing giant feature branches", "id": "cysjnhx"}, {"comment": "> There's too much risk in releasing a feature to 100% of users when you've got 1B of them.\n\nThat's a good heuristic for deploying cosmetic changes.  But if your app is controlling real hardware, real people or real money,  any added complexity (branching) that makes a malfunction more likely or adds cognitive load to your development or deployment process is just another way of testing in production.\n\n\n", "id": "cytqntn"}, {"comment": "Those are some valid cases where feature flags don't make any sense. Most of the things I work on the worst case is that the user has a bad experience and might stop using the app, there's not going to be any damage or money lost.\n\nOne thing you've touched on though is the lifetime and scope of the feature flags. In this example they're production feature flags but it's also valid to have features that can only be turned on in development. In this case the flag only exists until the feature is complete. Then any existing old code and the flag are removed. This can have huge benefits if you've got a lot of developers with long lived feature branches slowly drifting away from the main branch.\n\nYou want to keep branching as limited as possible though. If your code is filled with `if(feature_flag_1)` then as you said it's adding a lot of cognitive load. If you can have a single place which just returns a different class based on the flag then it's not much complexity.", "id": "cytr5ss"}, {"comment": "[deleted]", "id": "cysn9uz"}, {"comment": "That seems terrible. Is there any reason you didn't just disable them with the preprocessor? Did you want to be able to toggle the availability at runtime?", "id": "cysofqo"}, {"comment": "You still want the code to be compiled and pass tests.", "id": "cysopis"}, {"comment": "Not particularly hard if you have your CI infrastructure set up right.", "id": "cysou54"}, {"comment": "Most major software companies, including Facebook, Google, Twitter, LinkedIn, and many others, use feature flags. \n\n* All changes are wrapped in a feature flag, which is off by default, so you can safely check in even if a feature isn't totally done or shouldn't be exposed to all users.  \n* It's used for gradually ramping a feature or shutting it off if there are bugs or perf problems.\n* It's used for bucket testing (AKA A/B testing).\n* It's a must-have for [trunk-based development](http://paulhammant.com/2013/04/05/what-is-trunk-based-development/) and one of the key tools for making it scale for thousands of developers.", "id": "cysjrkh"}, {"comment": "Do you know a good overview of the different development models? Is there a rough consensus on the best one?", "id": "cysvqv3"}, {"comment": "Flickr wrote about it a long time ago. Lots of apps use similar.", "id": "cysjesm"}, {"comment": "As someone who works on a fairly large web app, I can assure you that yes, feature flags are used every day. They are an absolute godsend. Almost every pain point related to deploys is lessened via feature-flags. Need to do a/b testing? Feature flags can do that. Need to see how a feature handles under load? Easy.\n\nBasically feature flags let you take the benefits of continuous deployment without the risks. If something fucks up, you don't have to roll back, just flip a bit off, and you're done", "id": "cysr8l4"}], [{"comment": "Isnt this just obvious? its nothing hew", "id": "cyssda2"}], [{"comment": "Great article\n", "id": "cysokm3"}]]], "4muc3q": ["The way we evaluate developer performance is broken - ignore the broader product context and feed into an already ingrained developer mentality of \u201cmy role is just to build,\u201d with zero accountability for overall product goals (i.e., why we\u2019re building it)", "2016-06-06 22:06:48", 0, "http://venturebeat.com/2016/06/04/the-way-we-evaluate-developer-performance-is-broken/", [[2, "Stop masturbating to metrics, for starters."], [3, "I agree that this is the way it should work in a perfect world.\n\nUnfortunately, the industry is full of shops that want to use contractors to scale their staff up and down on demand.  When you bring in hired guns like that, it is typically with the assumption that they will never attain a deep understanding of the domain subject matter.  They are there to code to whatever half ass specification they are given.\n\n"], [2, "Stop evaluating developer performance wrong then. \n\nOh by 'we' you meant 'the entire software industry'. Then fucking say so. Titles with 'we' in them are almost always obnoxious."]], [[{"comment": "Stop masturbating to metrics, for starters.", "id": "d3ydsrx"}, {"comment": "The easiest thing to fudge in the universe. When I first started working, I'd  occasionally have a day where I didn't feel like being productive, so I would create a few defects found by our static analyzer, fix them and meet a good quota of 'commits' for the day :D\n\nYeah, I can be a jerk sometimes. ", "id": "d3yfc2b"}], [{"comment": "I agree that this is the way it should work in a perfect world.\n\nUnfortunately, the industry is full of shops that want to use contractors to scale their staff up and down on demand.  When you bring in hired guns like that, it is typically with the assumption that they will never attain a deep understanding of the domain subject matter.  They are there to code to whatever half ass specification they are given.\n\n", "id": "d3ykj1k"}, {"comment": "Yup.  I really prefer to work at product companies, because you actually have the opportunity to participate in building something.  Contracting just feels completely soul-draining by comparison.", "id": "d3yom3b"}], [{"comment": "Stop evaluating developer performance wrong then. \n\nOh by 'we' you meant 'the entire software industry'. Then fucking say so. Titles with 'we' in them are almost always obnoxious.", "id": "d3zaasw"}]]], "58zl6c": ["If PHP Were British", "2016-10-23 21:20:57", 5, "https://www.addedbytes.com/blog/if-php-were-british/", [[4, "`would_you_mind { ... } actually_i_do_mind (e) {...}`\n\nLost it here."], [3, "The \"before brexit\" version has been covered as an [april's fools day CVE](http://phpsecure.info/CVE-2014-0401.html) "], [1, "Somewhat similar, a [CPAN library](http://search.cpan.org/~dconway/Lingua-Romana-Perligata-0.50/lib/Lingua/Romana/Perligata.pm#GRATIAE) for writing Perl programs in Latin."], [1, "Jeevesian more than British. I'd like to see a cockney version."], [1, "This is awesome. Thanks for sharing!"]], [[{"comment": "`would_you_mind { ... } actually_i_do_mind (e) {...}`\n\nLost it here.", "id": "d957xro"}], [{"comment": "The \"before brexit\" version has been covered as an [april's fools day CVE](http://phpsecure.info/CVE-2014-0401.html) ", "id": "d94icxz"}], [{"comment": "Somewhat similar, a [CPAN library](http://search.cpan.org/~dconway/Lingua-Romana-Perligata-0.50/lib/Lingua/Romana/Perligata.pm#GRATIAE) for writing Perl programs in Latin.", "id": "d94kfuk"}], [{"comment": "Jeevesian more than British. I'd like to see a cockney version.", "id": "d94vzl6"}], [{"comment": "This is awesome. Thanks for sharing!", "id": "d95ce1w"}]]], "4e0qcp": ["A Visual Explanation of SQL Joins", "2016-04-09 13:53:13", 31, "http://enthusiastprogrammer.com/2016/04/07/a-visual-explanation-of-sql-joins/", [[17, "For those interested, my go to visual explanation is by Jeff Atwood: http://blog.codinghorror.com/a-visual-explanation-of-sql-joins/"], [9, "i love that cl moffet puts a copyright on his image that he shamelessly ripped from jeff atwood and this clown just grabs moffet's image with the copyright still intact. it's like doing a cover of a cover"], [9, "I feel like I got Rick-rolled.\n\nMind you, this is your basic Venn-diagram depiction and all correct... but I was expecting something more \"programmery\", like visualizing an efficient join implementation."], [2, "can someone explain the full outer joins for me - what does the table.key IS NULL do please?"], [2, "I had this printed out and pinned to my wall for years so I could remember how to join.  Really very useful."], [2, "You can also use this app: http://sql-joins.leopard.in.ua/"], [2, "I'm always annoyed by this, because a Venn diagram is a really awful way to think about joins. It works if all your data has the same key, but completely ignores duplication issues caused by the join.\n\nFor instance, if you had a blog and in your blog you had users, posts, and comments then joining them all on userId, which probably exists on them, will produce nonsensical data since comments on post A will match comments on post B."], [1, "The first one of these was \"Joining arrays\". This one was \"Joins: the SQL\"."], [1, "A classic"], [1, "I found this a year or two ago, printed it out and have it posted in my workstation. Use it all the time."]], [[{"comment": "For those interested, my go to visual explanation is by Jeff Atwood: http://blog.codinghorror.com/a-visual-explanation-of-sql-joins/", "id": "d1w0r21"}, {"comment": "Could at least told that it was taken from here: [Visual-Representation-of-SQL-Joins](http://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins).", "id": "d1w2v1z"}], [{"comment": "i love that cl moffet puts a copyright on his image that he shamelessly ripped from jeff atwood and this clown just grabs moffet's image with the copyright still intact. it's like doing a cover of a cover", "id": "d1w6vo7"}, {"comment": "i love that cl moffet puts a copyright on his image that he shamelessly ripped from jeff atwood and this clown just grabs moffet's image with the copyright still intact. it's like doing a cover of a cover", "id": "d1wb86a"}, {"comment": "ORIGINAL ~~CHARACTER~~ VENN DIAGRAM DO NOT STEAL", "id": "d1wnmkb"}], [{"comment": "I feel like I got Rick-rolled.\n\nMind you, this is your basic Venn-diagram depiction and all correct... but I was expecting something more \"programmery\", like visualizing an efficient join implementation.", "id": "d1w2r6j"}, {"comment": "He literally googled \"sql joins\" and put the first picture on his blog with no explanation.\nWay to go.", "id": "d1w3iil"}], [{"comment": "can someone explain the full outer joins for me - what does the table.key IS NULL do please?", "id": "d1w3lyw"}, {"comment": "The IS NULL represent the items that could not be joined (i.e. the items in A but not in B).", "id": "d1w64hc"}, {"comment": "thanks. i was wondering how an id field could be null. i'd expect NOT IN. maybe that's not standard sql", "id": "d1w6nb8"}, {"comment": "Don't confuse IS NULL to mean anything more than what it is. It is not called NOT IN simply because it is already perfectly named.\n\nIS NULL is doing exactly what it says, checking the value to see if it NULL.\n\nIt just turns out that if the key value is NULL that also means that particular row could not be joined.\n\n", "id": "d1w6yi5"}], [{"comment": "I had this printed out and pinned to my wall for years so I could remember how to join.  Really very useful.", "id": "d1w8sge"}], [{"comment": "You can also use this app: http://sql-joins.leopard.in.ua/", "id": "d1wl4tj"}, {"comment": "Very nice tool.", "id": "d212fnf"}], [{"comment": "I'm always annoyed by this, because a Venn diagram is a really awful way to think about joins. It works if all your data has the same key, but completely ignores duplication issues caused by the join.\n\nFor instance, if you had a blog and in your blog you had users, posts, and comments then joining them all on userId, which probably exists on them, will produce nonsensical data since comments on post A will match comments on post B.", "id": "d1wnxzr"}], [{"comment": "The first one of these was \"Joining arrays\". This one was \"Joins: the SQL\".", "id": "d1w46ja"}], [{"comment": "A classic", "id": "d1wafpb"}], [{"comment": "I found this a year or two ago, printed it out and have it posted in my workstation. Use it all the time.", "id": "d1wwvfy"}]]], "58xtdo": ["Dyn post mortem", "2016-10-23 13:03:36", 59, "http://dyn.com/blog/dyn-statement-on-10212016-ddos-attack/", [[197, "This is not a post mortem, contains no details"], [83, "> It is worth noting that we are unlikely to share all details of the attack and our mitigation efforts to preserve future defenses.\n\nSigh.\n\nedit: the post has basically no new information, it's mostly \"this was big, we mitigated quickly, we put new and better stuff in place, we work with everyone from law enforcement to internet actors to face these challenges everyone else also faces (so there's no point in migrating to the competition)\"."], [21, "To everyone saying \"nothing new\", this contains a few concrete factual details that were just speculation before:\n\n- \"10s of millions of IP addresses\"\n- \"one source of the traffic for the attacks were devices infected by the Mirai botnet\"\n"], [2, "Nothing new here."], [1, "Did any CloudFlare customers get dinged?"]], [[{"comment": "This is not a post mortem, contains no details", "id": "d943j01"}, {"comment": "[deleted]", "id": "d944rv7"}, {"comment": "Word floating around was that it was 20Tbps, even with upstream scrubbers , that is practically more traffic than any mitigation could handle.", "id": "d9475mm"}, {"comment": "Where is this word floating around from? Wondering how reliable that figure could be, that's enormous.", "id": "d947m67"}, {"comment": "I don't know if this a correct comparison, but a previous Mirai attack with 50,000 IPs generated 280Gbps. \n\nhttps://www.incapsula.com/blog/malware-analysis-mirai-ddos-botnet.html", "id": "d948vjz"}, {"comment": "If you just use those numbers as a formula, that means each device was pumping out ~5.6Mbps.  At 1M devices that's ~5Tbps,  And this attack was estimated to multi-millions of IoT devices.  The math seems to line up which put it around ~4 Million IoT devices orchestrated to conduct this attack.  Just that many devices alone to be orchestrated is rather impressive.  \n\nIt's all some level of conjecture and speculation based from conversations and until Dyn or someone else upstream actually gives out numbers, take it with a grain of salt.", "id": "d949esy"}, {"comment": "I want to know what devices and what networks are having 5.8 up on average...\n\nEdit nvm that's bps, not Bps. ", "id": "d94hale"}, {"comment": "Yup. To be fair, the original title is merely \"statement\".", "id": "d946xri"}, {"comment": "it's a PR statement, the whole thing reads as 'dyn was great! no full network outages!' when i don't think anyone would really agree about the successes here ", "id": "d94ll7j"}], [{"comment": "> It is worth noting that we are unlikely to share all details of the attack and our mitigation efforts to preserve future defenses.\n\nSigh.\n\nedit: the post has basically no new information, it's mostly \"this was big, we mitigated quickly, we put new and better stuff in place, we work with everyone from law enforcement to internet actors to face these challenges everyone else also faces (so there's no point in migrating to the competition)\".", "id": "d943fpv"}, {"comment": "Absolutely. This is basically an ad... \"Look what happened and we handled it like a boss\" if it's not an ad, it's PR at best. No examination into the problem. ", "id": "d947k8x"}, {"comment": "The infosec person in me probably would do the same initially.  It's nice to know the technical details but stuff like this often has pretty strong op-sec to go with it especially so soon after an attack.", "id": "d9543ah"}, {"comment": "I wonder if it's possible the government issued a gag order to them? If you assume that the botnet was acting on commands from a foreign state I could see wanting to be rather sparse on details in order to avoid confirming the power of the botnet to the owners. Especially if they are details about how they stopped it.\n\nI don't really agree with the logic, but I think it is possible though.", "id": "d94nc44"}, {"comment": "I don't think a gag order related to national security or something like that would make sense. Even in the US, gag orders can't be completely freely distributed. However they have an ongoing investigation as far as I understand so maybe that would be the context for one or for not saying anything.", "id": "d959to4"}], [{"comment": "To everyone saying \"nothing new\", this contains a few concrete factual details that were just speculation before:\n\n- \"10s of millions of IP addresses\"\n- \"one source of the traffic for the attacks were devices infected by the Mirai botnet\"\n", "id": "d948804"}, {"comment": "Thank you.", "id": "d94hmf2"}], [{"comment": "Nothing new here.", "id": "d947afg"}], [{"comment": "Did any CloudFlare customers get dinged?", "id": "d955n90"}]]], "41y1y1": ["Datomic: The most innovative DB you've never heard of", "2016-01-21 06:34:45", 3, "http://augustl.com/blog/2016/datomic_the_most_innovative_db_youve_never_heard_of/", [[23, "It's a proprietary database with a unique behavior. This means nobody will care until the ideas migrate to open source."], [14, "Proprietary AND single threaded writes? Give me a break.  This is an ad and not a very good one."], [5, "Datomic: the DB can not handler counters very well."], [2, "I would really like to see how can single-threaded writes beat multi-threaded. Disk is still blocking, you know, plus, there's caches and multiple CPUs.\n\nI mean, I can think of situations where they *can* (multiple writes congestion on the same piece of data), but from there to being better overall is a huge gap."], [1, "I have heard of it, I just haven't found a use case for it."], [1, "Great article, great Database! One thing to keep in mind though is that Datomic is tested to support up to 10 billion datoms (although some people say they have reached higher volumes). It may not be suitable for large datasets. https://groups.google.com/forum/#!topic/datomic/iZHvQfamirI"], [1, "Datomic should be better known than it is. More generally, Datalog should. Those who are curious about Datalog should check out the [Datalog Educational System](http://www.fdi.ucm.es/profesor/fernan/des/)."]], [[{"comment": "It's a proprietary database with a unique behavior. This means nobody will care until the ideas migrate to open source.", "id": "cz64ub4"}, {"comment": "There is a [DataScript](https://github.com/tonsky/datascript) library that is highly inspired by Datomic.", "id": "cz67y18"}], [{"comment": "Proprietary AND single threaded writes? Give me a break.  This is an ad and not a very good one.", "id": "cz65ksq"}, {"comment": "_INNOVATIVE_", "id": "cz66bfd"}, {"comment": "> single threaded writes\n\nHow much throughput can you get on a single powerful machine that is only performing writes?\n\nI've used a single oracle database node to support close to half a million concurrent users for both read and write without major issues. I understand that isn't Google or Facebook scale.... But it is enough for many many businesses.\n\nIf you could get 3-4x that performance only doing writes you could cover 95% of real world database use.", "id": "cz66r76"}, {"comment": "But why would you use it if it's not on par to far more widely available options. Not seeing any compelling reasons. ", "id": "cz686th"}, {"comment": "Thats an odd comment. Why would you only compare it based on one dimension (write speed) especially when it is clear that it performs fine in that dimension for most use cases?\n\nI'd consider using it for query performance alone. Not having to worry in the same way about query overhead allows you to structure your application very differently.", "id": "cz68jf6"}, {"comment": "Why choose one that performs fine in one dimension when you can have one that performs fine in both dimensions? Needs now are different than needs in the future and hamstringing yourself with a product that only offers half of what you can get from something else within reach is an odd choice. \n\nSingle thread writes also seem odd to me. What are the scenarios where multi thread writing is allowed that you run into problems? Most of the times your writes could be on completely unrelated data. You can support many writes by supporting multiple threads without losing read capability or atomicity. I don't know. I'm not a DBA. This just seems meh based on what I know of databases in coursework and professionally. The post doesn't really sell me on WHY I should care about this even though I want to. ", "id": "cz68u8v"}, {"comment": "> How much throughput can you get on a single powerful machine that is only performing writes?\n\n1 / RTT at best case, and that assuming write in actual DB server takes zero time. So on 10Gbit ethernet it will be about 50k requests/sec. But if you are \"small\" you wont have 10Gbit ethernet, and if you are \"cloud\" you wont have that latency so 5k/sec is probably more likely\n\n", "id": "cz6bcee"}, {"comment": "I'm not sure what you are even saying or asking.  Numbers of users isn't a metric of performance, it gives no indication of the number of reads or writes.\n\nSingle threaded anything isn't worth bragging about. If something doesn't scale with concurrency there is a hard limit on it's uses and a ticking clock on its relevance. ", "id": "cz6jttl"}, {"comment": "> Single threaded anything isn't worth bragging about. \n\nYou are right. It is a limitation and not a feature to brag about. Yet software engineering is all about tradeoffs. \n\nFor example I would happily trade write scalability for better read scalability for the kinds of applications I work on.\n\n> If something doesn't scale with concurrency there is a hard limit on it's uses and a ticking clock on its relevance.\n\nNonsense. Extremely write heavy databases are a tiny fraction of the database market. In 10 years time I'd be willing to bet my house that they will still be <5% of the overall database market.", "id": "czaiiw1"}, {"comment": "It's also tied really closely with clojure, which is somewhere south of rank 50 on the [TIOBE index](http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html).", "id": "cz66sh2"}, {"comment": "It's not clear that tiobe means anything at all and you probably should stop using it", "id": "cz692n5"}, {"comment": "Clojure is far from mainstream, but TIOBE is a joke.", "id": "cz69wf1"}, {"comment": ">  This is an ad \n\nI share your concerns, but TBH the article points them out, as well.", "id": "cz6fv4t"}], [{"comment": "Datomic: the DB can not handler counters very well.", "id": "cz68cdy"}, {"comment": "Huh? It has a single threaded (so afaiu linearizable) restriction on writes. It's all the multi threaded databases that can't handle counters, isn't it? Case in point: all the jepsen tests.", "id": "cz6coc6"}, {"comment": "I can't think of a db that would handle counters better than Datomic, due to the complete transaction isolation :)", "id": "cz6dgws"}], [{"comment": "I would really like to see how can single-threaded writes beat multi-threaded. Disk is still blocking, you know, plus, there's caches and multiple CPUs.\n\nI mean, I can think of situations where they *can* (multiple writes congestion on the same piece of data), but from there to being better overall is a huge gap.", "id": "cz68dmy"}, {"comment": "Wait... didn't you turn the argument upside down? Single-threaded is the simpler and easier way to do it, so the burden of proof would be on the more complicated multi-threaded side. \n\nI would really like to see how can multi-threaded writes beat single-threaded. Disk is blocking, you know, so only one thread is able to write at a time anyway.", "id": "cz69q5u"}, {"comment": "> I would really like to see how can multi-threaded writes beat single-threaded. Disk is blocking, you know, so only one thread is able to write at a time anyway.\n\nLet's see:\n\n* if you communicate via network, max  thoughtput is 1/RTT so about 50k requests/sec per connection, assuming server have to at least send ACK for each request. Note that is optimistic assumption that writes takes 0 time\n* Servers can have more than one disk.... NVMe drives have multiple queues\n* CPUs have more than one core and work inside kernel is heavily paralleled ( https://en.wikipedia.org/wiki/File:IO_stack_of_the_Linux_kernel.svg )\n", "id": "cz6bfkn"}, {"comment": "I don't think I turned anything upside down.\n\nDB systems do writes in parallel as it is. The article is not about me doing multi-threading or not, it's about the product serializing writes because... something. That can't possibly be a good idea.\n\nMy fault for mentioning the blocking disk though. Things are more complex than that. Any write call does block, but that does not prevent another thread to do another write call, and the two will not necessarily be serialized (in fact, the system is made so that they aren't). This is achieved through various layers in between including any DB software involvement (writing to a DB does not mean \"to disk, *right now*\"), OS involvement, disk software (it has buffering and whatnot).", "id": "cz6bnm5"}], [{"comment": "I have heard of it, I just haven't found a use case for it.", "id": "cz6brvu"}], [{"comment": "Great article, great Database! One thing to keep in mind though is that Datomic is tested to support up to 10 billion datoms (although some people say they have reached higher volumes). It may not be suitable for large datasets. https://groups.google.com/forum/#!topic/datomic/iZHvQfamirI", "id": "cz6kp6v"}], [{"comment": "Datomic should be better known than it is. More generally, Datalog should. Those who are curious about Datalog should check out the [Datalog Educational System](http://www.fdi.ucm.es/profesor/fernan/des/).", "id": "cz6pb64"}]]]}